<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Minnesota Then ‚Äî Pro Recorder</title>
  <style>
    :root {
      --primary: #1e3a8a;
      --success: #10b981;
      --warning: #f59e0b;
      --danger: #ef4444;
      --dark: #0f172a;
      --gray: #64748b;
      --light: #f8fafc;
      --glass: rgba(255, 255, 255, 0.85);
      --shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
    }

    * { box-sizing: border-box; user-select: none; }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, var(--light) 0%, #e2e8f0 100%);
      min-height: 100vh;
      margin: 0;
      padding: 1rem;
      display: flex;
      justify-content: center;
      align-items: center;
      color: var(--dark);
    }

    .container {
      max-width: 800px;
      width: 100%;
      background: var(--glass);
      backdrop-filter: blur(12px);
      border-radius: 24px;
      box-shadow: var(--shadow);
      padding: 2.5rem;
      border: 1px solid rgba(255, 255, 255, 0.5);
    }

    header {
      text-align: center;
      margin-bottom: 2.5rem;
    }

    .logo {
      font-size: 2.5rem;
      font-weight: 800;
      background: linear-gradient(135deg, var(--primary), var(--success));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin: 0;
    }

    .tagline {
      color: var(--gray);
      font-size: 1.1rem;
      margin-top: 0.5rem;
      min-height: 1.5rem; /* Prevent layout shift */
    }

    .level-readout.good { color: var(--success); }
    .level-readout.caution { color: var(--warning); }
    .level-readout.danger { color: var(--danger); }

    .vu-meter {
      height: 32px;
      background: var(--dark);
      border-radius: 16px;
      overflow: hidden;
      position: relative;
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    .vu-bar {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, var(--success) 0%, var(--warning) 60%, var(--danger) 85%);
      transition: width 0.05s ease-out;
    }

    .gain-control {
      margin: 1.5rem 0;
      padding: 1rem;
      background: rgba(255, 255, 255, 0.6);
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.8);
    }

    .gain-control label {
      font-weight: 600;
      display: block;
      margin-bottom: 0.5rem;
    }

    .gain-slider {
      width: 100%;
      margin: 0.5rem 0;
      cursor: pointer;
    }

    .gain-labels {
      display: flex;
      justify-content: space-between;
      font-size: 0.85rem;
      color: var(--gray);
    }

    .gain-value-display {
      background: var(--primary);
      color: white;
      padding: 0.25rem 0.5rem;
      border-radius: 6px;
      font-weight: 700;
    }

    .waveform-container {
      height: 100px;
      background: linear-gradient(180deg, #f1f5f9 0%, #e2e8f0 100%);
      border-radius: 12px;
      overflow: hidden;
      margin: 1.5rem 0;
      position: relative;
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.05);
    }

    canvas#waveform {
      width: 100%;
      height: 100%;
      display: block;
    }

    .controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 1rem;
      margin: 2rem 0;
    }

    .btn {
      padding: 16px 24px;
      border: none;
      border-radius: 12px;
      font-size: 1.1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      position: relative;
      overflow: hidden;
      color: white;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    .btn:active { transform: translateY(1px); }
    .btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
      pointer-events: none;
    }
    .btn-start { background: var(--success); }
    .btn-pause { background: var(--warning); }
    .btn-stop { background: var(--danger); }
    .btn-download { background: var(--primary); }
    .btn-monitor { background: var(--warning); }

    .post-recording-panel {
      background: rgba(255, 255, 255, 0.8);
      border-radius: 12px;
      padding: 1.5rem;
      margin-top: 1.5rem;
      border: 2px solid var(--success);
    }

    audio {
      width: 100%;
      margin-bottom: 1rem;
      border-radius: 8px;
    }

    /* State-specific styling */
    .monitor-mode {
      animation: pulse-glow 2s infinite;
    }

    @keyframes pulse-glow {
      0%, 100% { box-shadow: 0 0 0 0 rgba(245, 158, 11, 0.4); }
      50% { box-shadow: 0 0 0 12px rgba(245, 158, 11, 0); }
    }
  </style>
</head>
<body>
  <div class="container" id="container">
    <header>
      <h1 class="logo">Minnesota Then üéôÔ∏è</h1>
      <p class="tagline" id="tagline">Professional Chromebook Recorder</p>
    </header>

    <div class="level-readout good" id="levelReadout">-‚àû dB</div>
    
    <div class="vu-meter" id="vuMeter">
      <div class="vu-bar" id="vuBar"></div>
    </div>

    <div class="gain-control">
      <label for="gainSlider">
        üéöÔ∏è <strong>Microphone Gain Boost:</strong> 
        <span class="gain-value-display" id="gainValue">1.0x</span>
      </label>
      <input type="range" id="gainSlider" class="gain-slider" 
             min="0.5" max="5.0" step="0.1" value="1.0">
      <div class="gain-labels">
        <span>0.5x (quiet)</span>
        <span>1.0x (normal)</span>
        <span>5.0x (loud)</span>
      </div>
    </div>

    <div class="waveform-container">
      <canvas id="waveform"></canvas>
    </div>

    <div class="status-grid">
      <span id="statusLabel" class="status-label">Ready ‚Äî Click "Test Levels" to check your mic</span>
      <span id="timer" class="timer">00:00:00</span>
    </div>

    <div class="controls" id="controls">
      <!-- All buttons always visible, but enabled/disabled by state -->
      <button id="monitorBtn" class="btn btn-monitor">üîç Test Levels</button>
      <button id="startBtn" class="btn btn-start" disabled>‚è∫Ô∏è Start Recording</button>
      <button id="pauseBtn" class="btn btn-pause" disabled>‚è∏Ô∏è Pause</button>
      <button id="stopBtn" class="btn btn-stop" disabled>‚èπÔ∏è Stop</button>
    </div>

    <div id="postRecordingPanel" class="post-recording-panel hidden">
      <h3>üéâ Recording Complete</h3>
      <audio id="audioPlayer" controls></audio>
      <div class="controls">
        <button id="previewBtn" class="btn btn-secondary">‚ñ∂Ô∏è Play / Pause</button>
        <button id="downloadBtn" class="btn btn-download">üì• Download MP3</button>
        <button id="discardBtn" class="btn btn-stop">üóëÔ∏è Record Again</button>
      </div>
    </div>
  </div>

  <script>
    // AudioWorklet processor code (unchanged)
    const AUDIO_WORKLET_CODE = `
      class RecorderProcessor extends AudioWorkletProcessor {
        constructor() {
          super();
          this.isRecording = false;
          this.port.onmessage = (e) => {
            if (e.data.type === 'start') this.isRecording = true;
            else if (e.data.type === 'stop') this.isRecording = false;
          };
        }
        
        process(inputs, outputs, parameters) {
          const input = inputs[0];
          if (this.isRecording && input && input[0]) {
            this.port.postMessage({ data: input[0].slice() });
          }
          return true;
        }
      }
      registerProcessor('recorder-processor', RecorderProcessor);
    `;

    // State management
    const state = {
      isRecording: false,
      isMonitoring: false,
      isPaused: false,
      startTime: null,
      pauseTime: 0,
      processorNode: null,
      gainNode: null,
      gainValue: 1.0,
      audioContext: null,
      analyser: null,
      sourceNode: null,
      monitorStream: null,
      chunks: [],
      audioBuffer: [],
      mp3Encoder: null,
      currentBlob: null,
      currentUrl: null,
      usingAudioWorklet: false
    };

    // DOM elements
    const elements = {
      container: document.getElementById('container'),
      tagline: document.getElementById('tagline'),
      monitor: document.getElementById('monitorBtn'),
      start: document.getElementById('startBtn'),
      pause: document.getElementById('pauseBtn'),
      stop: document.getElementById('stopBtn'),
      preview: document.getElementById('previewBtn'),
      download: document.getElementById('downloadBtn'),
      discard: document.getElementById('discardBtn'),
      status: document.getElementById('statusLabel'),
      timer: document.getElementById('timer'),
      levelReadout: document.getElementById('levelReadout'),
      vuBar: document.getElementById('vuBar'),
      gainSlider: document.getElementById('gainSlider'),
      gainValue: document.getElementById('gainValue'),
      canvas: document.getElementById('waveform'),
      ctx: document.getElementById('waveform').getContext('2d'),
      postPanel: document.getElementById('postRecordingPanel'),
      audioPlayer: document.getElementById('audioPlayer')
    };

    // Gain slider control
    elements.gainSlider.addEventListener('input', (e) => {
      const value = parseFloat(e.target.value);
      elements.gainValue.textContent = value.toFixed(1) + 'x';
      state.gainValue = value;
      
      if (state.gainNode) {
        state.gainNode.gain.value = value;
      }
    });

    // Canvas setup
    const setupCanvas = () => {
      const dpr = window.devicePixelRatio || 1;
      const rect = elements.canvas.getBoundingClientRect();
      elements.canvas.width = rect.width * dpr;
      elements.canvas.height = rect.height * dpr;
      elements.ctx.scale(dpr, dpr);
    };

    window.addEventListener('resize', setupCanvas);
    setupCanvas();

    // Audio level meter
    let peakLevel = 0;
    const updateVUMeter = (data) => {
      let sum = 0, max = 0;
      for (let i = 0; i < data.length; i++) {
        const val = Math.abs((data[i] - 128) / 128);
        max = Math.max(max, val);
        sum += val * val;
      }
      peakLevel = Math.max(max, peakLevel * 0.97);
      const rms = Math.sqrt(sum / data.length);
      const db = 20 * Math.log10(Math.max(rms, 0.00001));
      const percentage = Math.max(0, Math.min(100, (db + 50) * 2));
      elements.vuBar.style.width = `${percentage}%`;
      
      const dbText = db > -50 ? `${db.toFixed(1)} dB` : '-‚àû dB';
      elements.levelReadout.textContent = dbText;
      
      elements.levelReadout.className = 'level-readout';
      if (db > -6) elements.levelReadout.classList.add('danger');
      else if (db > -24) elements.levelReadout.classList.add('good');
      else elements.levelReadout.classList.add('caution');
    };

    // Waveform drawer
    const waveData = new Uint8Array(1024);
    const drawWaveform = (data) => {
      const width = elements.canvas.width / (window.devicePixelRatio || 1);
      const height = elements.canvas.height / (window.devicePixelRatio || 1);
      elements.ctx.fillStyle = '#f1f5f9';
      elements.ctx.fillRect(0, 0, width, height);
      elements.ctx.lineWidth = 2;
      elements.ctx.strokeStyle = state.isRecording ? '#1e3a8a' : '#94a3b8';
      elements.ctx.beginPath();
      const step = Math.ceil(data.length / width);
      for (let x = 0; x < width; x++) {
        let min = 128, max = 128;
        for (let j = 0; j < step; j++) {
          const idx = Math.min(x * step + j, data.length - 1);
          const val = data[idx];
          min = Math.min(min, val);
          max = Math.max(max, val);
        }
        const yMin = (min / 255) * height;
        const yMax = (max / 255) * height;
        if (x === 0) elements.ctx.moveTo(x, yMin);
        elements.ctx.lineTo(x, yMin);
        elements.ctx.lineTo(x, yMax);
      }
      elements.ctx.stroke();
    };

    // Visualization loop
    const startVisualization = () => {
      const loop = () => {
        if ((state.isRecording || state.isMonitoring) && !state.isPaused && state.analyser) {
          state.analyser.getByteTimeDomainData(waveData);
          drawWaveform(waveData);
          updateVUMeter(waveData);
        }
        requestAnimationFrame(loop);
      };
      loop();
    };

    // Timer
    let timerInterval;
    const updateTimer = () => {
      const elapsed = Date.now() - state.startTime - state.pauseTime;
      const hours = Math.floor(elapsed / 3600000);
      const minutes = Math.floor((elapsed % 3600000) / 60000);
      const seconds = Math.floor((elapsed % 60000) / 1000);
      elements.timer.textContent = 
        `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    };

    // MP3 Encoding (with gain applied)
    const processAudioChunk = (float32Data) => {
      if (!state.mp3Encoder) return;
      
      // Apply gain boost BEFORE encoding
      const boosted = new Float32Array(float32Data.length);
      for (let i = 0; i < float32Data.length; i++) {
        boosted[i] = Math.max(-1, Math.min(1, float32Data[i] * state.gainValue));
      }
      
      const int16 = new Int16Array(float32Data.length);
      for (let i = 0; i < boosted.length; i++) {
        const val = boosted[i] * 32768;
        int16[i] = val < -32768 ? -32768 : val > 32767 ? 32767 : Math.floor(val);
      }
      
      const mp3Data = state.mp3Encoder.encodeBuffer(int16);
      state.chunks.push(mp3Data);
    };

    // Setup audio processing
    const setupAudioProcessing = async () => {
      try {
        const blob = new Blob([AUDIO_WORKLET_CODE], { type: 'application/javascript' });
        const url = URL.createObjectURL(blob);
        await state.audioContext.audioWorklet.addModule(url);
        URL.revokeObjectURL(url);
        
        const workletNode = new AudioWorkletNode(state.audioContext, 'recorder-processor');
        
        workletNode.port.onmessage = (e) => {
          if (!state.isRecording || state.isPaused) return;
          processAudioChunk(e.data.data);
        };
        
        state.usingAudioWorklet = true;
        console.log('‚úÖ Using modern AudioWorklet');
        return workletNode;
      } catch (e) {
        console.warn('‚ö†Ô∏è AudioWorklet not supported, falling back to ScriptProcessor', e);
        
        const scriptNode = state.audioContext.createScriptProcessor(4096, 1, 1);
        scriptNode.onaudioprocess = (e) => {
          if (!state.isRecording || state.isPaused) return;
          const inputData = e.inputBuffer.getChannelData(0);
          processAudioChunk(inputData);
        };
        
        state.usingAudioWorklet = false;
        return scriptNode;
      }
    };

    // Start monitoring (test levels without recording)
    const startMonitoring = async () => {
      try {
        elements.status.textContent = 'üîç Monitoring... Speak to test levels';
        elements.monitor.textContent = '‚èπÔ∏è Stop Monitor';
        elements.container.classList.add('monitor-mode');
        elements.start.disabled = true; // Disable record button during monitoring
        
        const stream = await navigator.mediaDevices.getUserMedia({ 
          audio: {
            echoCancellation: false,
            noiseSuppression: false,
            autoGainControl: false
          }
        });

        // Setup audio graph for monitoring only
        state.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        state.analyser = state.audioContext.createAnalyser();
        state.analyser.fftSize = 2048;
        state.analyser.smoothingTimeConstant = 0.8;
        
        state.sourceNode = state.audioContext.createMediaStreamSource(stream);
        state.monitorStream = stream;
        
        // Create gain node for monitoring
        state.gainNode = state.audioContext.createGain();
        state.gainNode.gain.value = state.gainValue;
        
        // Connect: source ‚Üí gain ‚Üí analyser ‚Üí destination (so you can hear yourself)
        state.sourceNode.connect(state.gainNode);
        state.gainNode.connect(state.analyser);
        state.gainNode.connect(state.audioContext.destination); // Loopback to speakers
        
        state.isMonitoring = true;
        elements.tagline.textContent = 'üîç Monitoring Mode ‚Äî Speak to test levels, then click "Stop Monitor"';

      } catch (err) {
        elements.status.textContent = `‚ùå ${err.message}`;
        console.error('Monitoring error:', err);
      }
    };

    // Stop monitoring
    const stopMonitoring = async () => {
      state.isMonitoring = false;
      
      if (state.sourceNode) state.sourceNode.disconnect();
      if (state.gainNode) state.gainNode.disconnect();
      if (state.analyser) state.analyser.disconnect();
      if (state.audioContext) await state.audioContext.close();
      
      if (state.monitorStream) {
        state.monitorStream.getTracks().forEach(track => track.stop());
        state.monitorStream = null;
      }
      
      elements.monitor.textContent = 'üîç Test Levels';
      elements.container.classList.remove('monitor-mode');
      elements.start.disabled = false; // ENABLE RECORD BUTTON
      elements.tagline.textContent = 'Professional Chromebook Recorder';
      elements.status.textContent = '‚úÖ Ready to record (Gain: ' + state.gainValue.toFixed(1) + 'x)';
    };

    // Start recording
    const startRecording = async () => {
      try {
        elements.status.textContent = 'üî¥ Initializing audio...';
        
        const stream = await navigator.mediaDevices.getUserMedia({ 
          audio: {
            echoCancellation: false,
            noiseSuppression: false,
            autoGainControl: false
          }
        });

        // Setup audio graph WITH GAIN NODE
        state.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        state.analyser = state.audioContext.createAnalyser();
        state.analyser.fftSize = 2048;
        state.analyser.smoothingTimeConstant = 0.8;
        
        state.sourceNode = state.audioContext.createMediaStreamSource(stream);
        
        // CREATE GAIN NODE ‚Äî ESSENTIAL FOR BOOSTING QUIET AUDIO
        state.gainNode = state.audioContext.createGain();
        state.gainNode.gain.value = state.gainValue;
        
        state.processorNode = await setupAudioProcessing();
        
        // Connection chain: source ‚Üí gain ‚Üí analyser ‚Üí processor ‚Üí destination
        state.sourceNode.connect(state.gainNode);
        state.gainNode.connect(state.analyser);
        state.analyser.connect(state.processorNode);
        state.processorNode.connect(state.audioContext.destination);

        // Load lamejs
        if (typeof lamejs === 'undefined') {
          await loadScript('https://cdn.jsdelivr.net/npm/lamejs@1.2.0/lame.min.js');
        }
        
        state.mp3Encoder = new lamejs.Mp3Encoder(1, state.audioContext.sampleRate, 192);

        // Start recording
        state.isRecording = true;
        state.startTime = Date.now();
        state.pauseTime = 0;
        state.chunks = [];
        state.audioBuffer = [];
        
        if (state.usingAudioWorklet) {
          state.processorNode.port.postMessage({ type: 'start' });
        }
        
        timerInterval = setInterval(updateTimer, 100);
        
        // Update UI state
        elements.monitor.disabled = true; // Disable test levels during recording
        elements.start.disabled = true;  // Hide start (already recording)
        elements.pause.disabled = false; // Enable pause
        elements.stop.disabled = false;  // Enable stop
        
        elements.tagline.textContent = 'üî¥ Recording ‚Äî Speak clearly and watch your levels';
        
        if (state.currentUrl) {
          URL.revokeObjectURL(state.currentUrl);
          state.currentUrl = null;
        }

        // Handle stream end
        stream.getAudioTracks()[0].onended = () => {
          if (state.isRecording) stopRecording();
        };

      } catch (err) {
        elements.status.textContent = `‚ùå ${err.message}`;
        console.error('Recording error:', err);
      }
    };

    const pauseRecording = () => {
      if (!state.isPaused) {
        state.pauseStart = Date.now();
        state.isPaused = true;
        elements.pause.textContent = '‚è∏Ô∏è Resume';
        elements.status.textContent = '‚è∏Ô∏è PAUSED';
        elements.tagline.textContent = '‚è∏Ô∏è Paused ‚Äî Click Resume to continue recording';
        clearInterval(timerInterval);
      } else {
        state.pauseTime += Date.now() - state.pauseStart;
        state.isPaused = false;
        elements.pause.textContent = '‚è∏Ô∏è Pause';
        elements.status.textContent = 'üî¥ LIVE RECORDING';
        elements.tagline.textContent = 'üî¥ Recording ‚Äî Speak clearly and watch your levels';
        timerInterval = setInterval(updateTimer, 100);
      }
    };

    const finalizeRecording = () => {
      clearInterval(timerInterval);
      
      if (state.usingAudioWorklet && state.processorNode) {
        state.processorNode.port.postMessage({ type: 'stop' });
      }
      
      const mp3End = state.mp3Encoder.flush();
      if (mp3End.length > 0) state.chunks.push(mp3End);
      
      const totalLength = state.chunks.reduce((acc, chunk) => acc + chunk.length, 0);
      const mp3Data = new Uint8Array(totalLength);
      let offset = 0;
      state.chunks.forEach(chunk => {
        mp3Data.set(chunk, offset);
        offset += chunk.length;
      });
      
      state.currentBlob = new Blob([mp3Data], { type: 'audio/mp3' });
      state.currentUrl = URL.createObjectURL(state.currentBlob);
      
      // Show post-recording panel with download button
      elements.postPanel.classList.remove('hidden');
      elements.audioPlayer.src = state.currentUrl;
      elements.status.textContent = `‚úÖ Complete: ${(state.currentBlob.size / 1024 / 1024).toFixed(2)} MB`;
      elements.tagline.textContent = '‚úÖ Recording complete ‚Äî Preview and download below';
      
      // Reset main controls
      elements.monitor.disabled = false; // Re-enable test levels
      elements.pause.disabled = true;
      elements.stop.disabled = true;
    };

    const stopRecording = async () => {
      if (!state.isRecording) return;
      state.isRecording = false;
      state.isPaused = false;
      
      if (state.sourceNode) state.sourceNode.disconnect();
      if (state.gainNode) state.gainNode.disconnect();
      if (state.processorNode) state.processorNode.disconnect();
      if (state.audioContext) await state.audioContext.close();
      
      elements.status.textContent = 'üíæ Finalizing MP3...';
      elements.tagline.textContent = 'üíæ Finalizing MP3...';
      setTimeout(finalizeRecording, 100);
    };

    const previewRecording = () => {
      if (!elements.audioPlayer.src) return;
      if (elements.audioPlayer.paused) {
        elements.audioPlayer.play();
        elements.preview.textContent = '‚è∏Ô∏è Pause Preview';
      } else {
        elements.audioPlayer.pause();
        elements.preview.textContent = '‚ñ∂Ô∏è Play Preview';
      }
    };

    const downloadRecording = () => {
      if (!state.currentBlob) return;
      const timestamp = new Date().toISOString().slice(0, 19).replace(/[-:]/g, '');
      const filename = `MNThen_Docent_${timestamp}.mp3`;
      const a = document.createElement('a');
      a.href = state.currentUrl;
      a.download = filename;
      a.click();
    };

    const discardRecording = () => {
      if (state.currentUrl) {
        URL.revokeObjectURL(state.currentUrl);
        state.currentUrl = null;
        state.currentBlob = null;
      }
      elements.postPanel.classList.add('hidden');
      elements.audioPlayer.src = '';
      elements.preview.textContent = '‚ñ∂Ô∏è Play Preview';
      elements.status.textContent = '‚úÖ Ready to record (Gain: ' + state.gainValue.toFixed(1) + 'x)';
      elements.tagline.textContent = 'Professional Chromebook Recorder';
      elements.monitor.disabled = false;
      elements.pause.disabled = true;
      elements.stop.disabled = true;
    };

    // Event listeners
    elements.monitor.addEventListener('click', () => {
      if (!state.isMonitoring) {
        startMonitoring();
      } else {
        stopMonitoring();
      }
    });
    
    elements.start.addEventListener('click', startRecording);
    elements.pause.addEventListener('click', pauseRecording);
    elements.stop.addEventListener('click', stopRecording);
    elements.preview.addEventListener('click', previewRecording);
    elements.download.addEventListener('click', downloadRecording);
    elements.discard.addEventListener('click', discardRecording);

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if (e.code === 'Space' && !e.target.matches('input, select')) {
        e.preventDefault();
        if (!state.isRecording && !state.isMonitoring) {
          startMonitoring();
        } else if (state.isMonitoring) {
          stopMonitoring();
        } else if (!state.isRecording) {
          startRecording();
        } else {
          pauseRecording();
        }
      } else if (e.code === 'Escape') {
        if (state.isRecording) stopRecording();
        else if (state.isMonitoring) stopMonitoring();
      }
    });

    // Cleanup on unload
    window.addEventListener('beforeunload', () => {
      if (state.currentUrl) URL.revokeObjectURL(state.currentUrl);
      if (state.audioContext) state.audioContext.close();
    });

    // Initialize
    startVisualization();
    elements.status.textContent = '‚úÖ Ready ‚Äî Click "Test Levels" to check your mic';
  </script>
</body>
</html>
