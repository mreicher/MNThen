<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Minnesota Then ‚Äî Pro Recorder</title>
  <style>
    :root {
      --primary: #1e3a8a;
      --primary-light: #3b82f6;
      --success: #10b981;
      --warning: #f59e0b;
      --danger: #ef4444;
      --dark: #0f172a;
      --gray: #64748b;
      --light: #f8fafc;
      --glass: rgba(255, 255, 255, 0.85);
      --shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
    }

    * { box-sizing: border-box; user-select: none; }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, var(--light) 0%, #e2e8f0 100%);
      min-height: 100vh;
      margin: 0;
      padding: 1rem;
      display: flex;
      justify-content: center;
      align-items: center;
      color: var(--dark);
    }

    .container {
      max-width: 800px;
      width: 100%;
      background: var(--glass);
      backdrop-filter: blur(12px);
      border-radius: 24px;
      box-shadow: var(--shadow);
      padding: 2.5rem;
      border: 1px solid rgba(255, 255, 255, 0.5);
    }

    header {
      text-align: center;
      margin-bottom: 2.5rem;
    }

    .logo {
      font-size: 2.5rem;
      font-weight: 800;
      background: linear-gradient(135deg, var(--primary), var(--success));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin: 0;
    }

    .tagline {
      color: var(--gray);
      font-size: 1.1rem;
      margin-top: 0.5rem;
    }

    .vu-meter {
      height: 28px;
      background: var(--dark);
      border-radius: 14px;
      overflow: hidden;
      margin: 1.5rem 0;
      position: relative;
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    .vu-bar {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, var(--success) 0%, var(--warning) 70%, var(--danger) 90%);
      transition: width 0.05s ease-out;
      box-shadow: 0 0 12px rgba(16, 185, 129, 0.5);
    }

    .vu-labels {
      display: flex;
      justify-content: space-between;
      font-size: 0.75rem;
      color: var(--gray);
      margin-top: 0.25rem;
    }

    .waveform-container {
      height: 100px;
      background: linear-gradient(180deg, #f1f5f9 0%, #e2e8f0 100%);
      border-radius: 12px;
      overflow: hidden;
      margin: 1.5rem 0;
      position: relative;
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.05);
    }

    canvas#waveform {
      width: 100%;
      height: 100%;
      display: block;
    }

    .controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 1rem;
      margin: 2rem 0;
    }

    .btn {
      padding: 16px 24px;
      border: none;
      border-radius: 12px;
      font-size: 1.1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      position: relative;
      overflow: hidden;
      color: white;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    .btn:active { transform: translateY(1px); }
    .btn:disabled { opacity: 0.5; cursor: not-allowed; }
    .btn-start { background: var(--success); }
    .btn-pause { background: var(--warning); }
    .btn-stop { background: var(--danger); }
    .btn-secondary { background: var(--gray); color: white; }
    .btn-download { background: var(--primary-light); }

    .status-grid {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 1rem;
      align-items: center;
      background: rgba(255, 255, 255, 0.7);
      padding: 1rem 1.5rem;
      border-radius: 12px;
      margin-bottom: 1.5rem;
    }

    .status-label {
      font-weight: 600;
      color: var(--primary);
    }

    .timer {
      font-family: 'JetBrains Mono', 'Fira Code', monospace;
      font-size: 1.5rem;
      font-weight: 800;
      color: var(--primary);
    }

    .post-recording-panel {
      background: rgba(255, 255, 255, 0.6);
      border-radius: 12px;
      padding: 1.5rem;
      margin-top: 1.5rem;
      border: 1px solid rgba(255, 255, 255, 0.8);
    }

    .post-recording-controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 1rem;
      margin-top: 1rem;
    }

    audio {
      width: 100%;
      margin-bottom: 1rem;
      border-radius: 8px;
    }

    .hidden { display: none; }
    .clipping { animation: pulse 0.3s; }

    @keyframes pulse {
      0%, 100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
      50% { box-shadow: 0 0 0 8px rgba(239, 68, 68, 0); }
    }

    @media (max-width: 640px) {
      .container { padding: 1.5rem; }
      .controls { grid-template-columns: 1fr; }
      .logo { font-size: 2rem; }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1 class="logo">Minnesota Then üéôÔ∏è</h1>
      <p class="tagline">Professional Chromebook Recorder</p>
    </header>

    <div class="vu-meter" id="vuMeter">
      <div class="vu-bar" id="vuBar"></div>
    </div>
    <div class="vu-labels">
      <span>-‚àû</span><span>-24</span><span>-12</span><span>-6</span><span>0 dB</span>
    </div>

    <div class="waveform-container">
      <canvas id="waveform"></canvas>
    </div>

    <div class="status-grid">
      <span id="statusLabel" class="status-label">Ready</span>
      <span id="timer" class="timer">00:00:00</span>
    </div>

    <div class="controls">
      <button id="startBtn" class="btn btn-start">‚è∫Ô∏è Record</button>
      <button id="pauseBtn" class="btn btn-pause hidden">‚è∏Ô∏è Pause</button>
      <button id="stopBtn" class="btn btn-stop" disabled>‚èπÔ∏è Stop</button>
    </div>

    <!-- This panel appears after recording -->
    <div id="postRecordingPanel" class="post-recording-panel hidden">
      <h3>üéâ Recording Complete</h3>
      
      <!-- Inline audio player for immediate playback -->
      <audio id="audioPlayer" controls></audio>
      
      <div class="post-recording-controls">
        <button id="previewBtn" class="btn btn-secondary">‚ñ∂Ô∏è Play / Pause</button>
        <button id="downloadBtn" class="btn btn-download">üì• Download MP3</button>
        <button id="discardBtn" class="btn btn-stop">üóëÔ∏è Discard & Record Again</button>
      </div>
    </div>
  </div>

  <script>
    // Dynamic library loader
    const loadScript = (src) => new Promise((resolve, reject) => {
      const script = document.createElement('script');
      script.src = src;
      script.onload = resolve;
      script.onerror = reject;
      document.head.appendChild(script);
    });

    // State management
    const state = {
      isRecording: false,
      isPaused: false,
      startTime: null,
      pauseTime: 0,
      mediaRecorder: null,
      audioContext: null,
      analyser: null,
      sourceNode: null,
      scriptNode: null,
      chunks: [],
      audioBuffer: [],
      mp3Encoder: null,
      currentBlob: null,
      currentUrl: null
    };

    // DOM elements
    const elements = {
      start: document.getElementById('startBtn'),
      pause: document.getElementById('pauseBtn'),
      stop: document.getElementById('stopBtn'),
      preview: document.getElementById('previewBtn'),
      download: document.getElementById('downloadBtn'),
      discard: document.getElementById('discardBtn'),
      status: document.getElementById('statusLabel'),
      timer: document.getElementById('timer'),
      vuBar: document.getElementById('vuBar'),
      vuMeter: document.getElementById('vuMeter'),
      canvas: document.getElementById('waveform'),
      ctx: document.getElementById('waveform').getContext('2d'),
      postPanel: document.getElementById('postRecordingPanel'),
      audioPlayer: document.getElementById('audioPlayer')
    };

    // Canvas setup
    const setupCanvas = () => {
      const dpr = window.devicePixelRatio || 1;
      const rect = elements.canvas.getBoundingClientRect();
      elements.canvas.width = rect.width * dpr;
      elements.canvas.height = rect.height * dpr;
      elements.ctx.scale(dpr, dpr);
    };

    window.addEventListener('resize', setupCanvas);
    setupCanvas();

    // Audio level meter
    let peakLevel = 0;
    const updateVUMeter = (data) => {
      let sum = 0, max = 0;
      for (let i = 0; i < data.length; i++) {
        const val = Math.abs((data[i] - 128) / 128);
        max = Math.max(max, val);
        sum += val * val;
      }
      peakLevel = Math.max(max, peakLevel * 0.95);
      const rms = Math.sqrt(sum / data.length);
      const db = 20 * Math.log10(Math.max(rms, 0.0001));
      const percentage = Math.max(0, Math.min(100, (db + 50) * 2));
      elements.vuBar.style.width = `${percentage}%`;
      if (peakLevel > 0.95) {
        elements.vuMeter.classList.add('clipping');
        setTimeout(() => elements.vuMeter.classList.remove('clipping'), 300);
      }
    };

    // Waveform drawer
    const waveData = new Uint8Array(1024);
    const drawWaveform = (data) => {
      const width = elements.canvas.width / (window.devicePixelRatio || 1);
      const height = elements.canvas.height / (window.devicePixelRatio || 1);
      elements.ctx.fillStyle = '#f1f5f9';
      elements.ctx.fillRect(0, 0, width, height);
      elements.ctx.lineWidth = 2;
      elements.ctx.strokeStyle = state.isRecording ? '#1e3a8a' : '#94a3b8';
      elements.ctx.beginPath();
      const step = Math.ceil(data.length / width);
      for (let x = 0; x < width; x++) {
        let min = 128, max = 128;
        for (let j = 0; j < step; j++) {
          const idx = Math.min(x * step + j, data.length - 1);
          const val = data[idx];
          min = Math.min(min, val);
          max = Math.max(max, val);
        }
        const yMin = (min / 255) * height;
        const yMax = (max / 255) * height;
        if (x === 0) elements.ctx.moveTo(x, yMin);
        elements.ctx.lineTo(x, yMin);
        elements.ctx.lineTo(x, yMax);
      }
      elements.ctx.stroke();
    };

    // Timer
    let timerInterval;
    const updateTimer = () => {
      const elapsed = Date.now() - state.startTime - state.pauseTime;
      const hours = Math.floor(elapsed / 3600000);
      const minutes = Math.floor((elapsed % 3600000) / 60000);
      const seconds = Math.floor((elapsed % 60000) / 1000);
      elements.timer.textContent = 
        `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    };

    // MP3 Encoding
    const processAudioChunk = (float32Data) => {
      if (!state.mp3Encoder) return;
      const int16 = new Int16Array(float32Data.length);
      for (let i = 0; i < float32Data.length; i++) {
        const val = float32Data[i] * 32768;
        int16[i] = val < -32768 ? -32768 : val > 32767 ? 32767 : Math.floor(val);
      }
      const mp3Data = state.mp3Encoder.encodeBuffer(int16);
      state.chunks.push(mp3Data);
    };

    // Recording logic
    const startRecording = async () => {
      try {
        elements.status.textContent = 'üî¥ Requesting microphone...';
        const stream = await navigator.mediaDevices.getUserMedia({ 
          audio: {
            echoCancellation: false,
            noiseSuppression: false,
            autoGainControl: false
          }
        });

        // Setup audio graph
        state.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        state.analyser = state.audioContext.createAnalyser();
        state.analyser.fftSize = 2048;
        state.analyser.smoothingTimeConstant = 0.8;
        
        state.sourceNode = state.audioContext.createMediaStreamSource(stream);
        state.scriptNode = state.audioContext.createScriptProcessor(4096, 1, 1);
        
        state.sourceNode.connect(state.analyser);
        state.analyser.connect(state.scriptNode);
        state.scriptNode.connect(state.audioContext.destination);

        // Load lamejs if needed
        if (typeof lamejs === 'undefined') {
          await loadScript('https://cdn.jsdelivr.net/npm/lamejs@1.2.0/lame.min.js');
        }
        
        state.mp3Encoder = new lamejs.Mp3Encoder(1, state.audioContext.sampleRate, 192);

        // Audio processing
        state.scriptNode.onaudioprocess = (e) => {
          if (!state.isRecording || state.isPaused) return;
          const inputData = e.inputBuffer.getChannelData(0);
          state.audioBuffer.push(new Float32Array(inputData));
          processAudioChunk(inputData);
          state.analyser.getByteTimeDomainData(waveData);
          drawWaveform(waveData);
          updateVUMeter(waveData);
        };

        // Start recording
        state.isRecording = true;
        state.startTime = Date.now();
        state.pauseTime = 0;
        state.chunks = [];
        state.audioBuffer = [];
        timerInterval = setInterval(updateTimer, 100);
        
        elements.start.classList.add('hidden');
        elements.pause.classList.remove('hidden');
        elements.stop.disabled = false;
        elements.status.textContent = 'üî¥ LIVE RECORDING';
        
        // Hide post-recording panel if visible
        elements.postPanel.classList.add('hidden');
        if (state.currentUrl) {
          URL.revokeObjectURL(state.currentUrl);
          state.currentUrl = null;
        }

        // Handle stream end
        stream.getAudioTracks()[0].onended = () => {
          if (state.isRecording) stopRecording();
        };

      } catch (err) {
        elements.status.textContent = `‚ùå ${err.message}`;
        console.error('Recording error:', err);
      }
    };

    const pauseRecording = () => {
      if (!state.isPaused) {
        state.pauseStart = Date.now();
        state.isPaused = true;
        elements.pause.textContent = '‚è∏Ô∏è Resume';
        elements.status.textContent = '‚è∏Ô∏è PAUSED';
        clearInterval(timerInterval);
      } else {
        state.pauseTime += Date.now() - state.pauseStart;
        state.isPaused = false;
        elements.pause.textContent = '‚è∏Ô∏è Pause';
        elements.status.textContent = 'üî¥ LIVE RECORDING';
        timerInterval = setInterval(updateTimer, 100);
      }
    };

    const finalizeRecording = () => {
      clearInterval(timerInterval);
      const mp3End = state.mp3Encoder.flush();
      if (mp3End.length > 0) state.chunks.push(mp3End);
      const totalLength = state.chunks.reduce((acc, chunk) => acc + chunk.length, 0);
      const mp3Data = new Uint8Array(totalLength);
      let offset = 0;
      state.chunks.forEach(chunk => {
        mp3Data.set(chunk, offset);
        offset += chunk.length;
      });
      state.currentBlob = new Blob([mp3Data], { type: 'audio/mp3' });
      state.currentUrl = URL.createObjectURL(state.currentBlob);
      
      // Show post-recording panel with player
      elements.audioPlayer.src = state.currentUrl;
      elements.postPanel.classList.remove('hidden');
      elements.status.textContent = `‚úÖ Complete: ${(state.currentBlob.size / 1024 / 1024).toFixed(2)} MB`;
    };

    const stopRecording = async () => {
      if (!state.isRecording) return;
      state.isRecording = false;
      state.isPaused = false;
      elements.pause.classList.add('hidden');
      elements.start.classList.remove('hidden');
      elements.stop.disabled = true;
      if (state.scriptNode) state.scriptNode.disconnect();
      if (state.sourceNode) state.sourceNode.disconnect();
      if (state.audioContext) await state.audioContext.close();
      elements.status.textContent = 'üíæ Finalizing MP3...';
      setTimeout(finalizeRecording, 100);
    };

    const previewRecording = () => {
      if (!elements.audioPlayer.src) return;
      if (elements.audioPlayer.paused) {
        elements.audioPlayer.play();
        elements.preview.textContent = '‚è∏Ô∏è Pause Preview';
      } else {
        elements.audioPlayer.pause();
        elements.preview.textContent = '‚ñ∂Ô∏è Play Preview';
      }
    };

    const downloadRecording = () => {
      if (!state.currentBlob) return;
      const timestamp = new Date().toISOString().slice(0, 19).replace(/[-:]/g, '');
      const filename = `MNThen_Docent_${timestamp}.mp3`;
      const a = document.createElement('a');
      a.href = state.currentUrl;
      a.download = filename;
      a.click();
    };

    const discardRecording = () => {
      if (state.currentUrl) {
        URL.revokeObjectURL(state.currentUrl);
        state.currentUrl = null;
        state.currentBlob = null;
      }
      elements.postPanel.classList.add('hidden');
      elements.audioPlayer.src = '';
      elements.preview.textContent = '‚ñ∂Ô∏è Play Preview';
      elements.status.textContent = 'Ready to record';
    };

    // Event listeners
    elements.start.addEventListener('click', startRecording);
    elements.pause.addEventListener('click', pauseRecording);
    elements.stop.addEventListener('click', stopRecording);
    elements.preview.addEventListener('click', previewRecording);
    elements.download.addEventListener('click', downloadRecording);
    elements.discard.addEventListener('click', discardRecording);

    // Cleanup on unload
    window.addEventListener('beforeunload', () => {
      if (state.currentUrl) URL.revokeObjectURL(state.currentUrl);
      if (state.audioContext) state.audioContext.close();
    });

    // Initialize
    elements.status.textContent = '‚úÖ Ready to record';
  </script>
</body>
</html>
