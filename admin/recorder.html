<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Minnesota Then ‚Äî Pro Recorder</title>
  <style>
    :root {
      --primary: #1e3a8a;
      --primary-light: #3b82f6;
      --success: #10b981;
      --warning: #f59e0b;
      --danger: #ef4444;
      --dark: #0f172a;
      --gray: #64748b;
      --light: #f8fafc;
      --glass: rgba(255, 255, 255, 0.85);
      --shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
    }

    * {
      box-sizing: border-box;
      user-select: none;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, var(--light) 0%, #e2e8f0 100%);
      min-height: 100vh;
      margin: 0;
      padding: 1rem;
      display: flex;
      justify-content: center;
      align-items: center;
      color: var(--dark);
    }

    .container {
      max-width: 800px;
      width: 100%;
      background: var(--glass);
      backdrop-filter: blur(12px);
      border-radius: 24px;
      box-shadow: var(--shadow);
      padding: 2.5rem;
      border: 1px solid rgba(255, 255, 255, 0.5);
    }

    header {
      text-align: center;
      margin-bottom: 2.5rem;
    }

    .logo {
      font-size: 2.5rem;
      font-weight: 800;
      background: linear-gradient(135deg, var(--primary), var(--success));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin: 0;
    }

    .tagline {
      color: var(--gray);
      font-size: 1.1rem;
      margin-top: 0.5rem;
    }

    .vu-meter {
      height: 28px;
      background: var(--dark);
      border-radius: 14px;
      overflow: hidden;
      margin: 1.5rem 0;
      position: relative;
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    .vu-bar {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, var(--success) 0%, var(--warning) 70%, var(--danger) 90%);
      transition: width 0.05s ease-out;
      box-shadow: 0 0 12px rgba(16, 185, 129, 0.5);
    }

    .vu-labels {
      display: flex;
      justify-content: space-between;
      font-size: 0.75rem;
      color: var(--gray);
      margin-top: 0.25rem;
    }

    .waveform-container {
      height: 100px;
      background: linear-gradient(180deg, #f1f5f9 0%, #e2e8f0 100%);
      border-radius: 12px;
      overflow: hidden;
      margin: 1.5rem 0;
      position: relative;
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.05);
    }

    canvas#waveform {
      width: 100%;
      height: 100%;
      display: block;
    }

    .controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 1rem;
      margin: 2rem 0;
    }

    .btn {
      padding: 16px 24px;
      border: none;
      border-radius: 12px;
      font-size: 1.1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      position: relative;
      overflow: hidden;
      color: white;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    .btn:active {
      transform: translateY(1px);
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .btn-start { background: var(--success); }
    .btn-pause { background: var(--warning); }
    .btn-stop { background: var(--danger); }
    .btn-secondary { background: var(--gray); color: white; }

    .btn::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.2);
      transform: translate(-50%, -50%);
      transition: width 0.6s, height 0.6s;
    }

    .btn:active::before {
      width: 300px;
      height: 300px;
    }

    .status-grid {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 1rem;
      align-items: center;
      background: rgba(255, 255, 255, 0.7);
      padding: 1rem 1.5rem;
      border-radius: 12px;
      margin-bottom: 1.5rem;
    }

    .status-label {
      font-weight: 600;
      color: var(--primary);
    }

    .timer {
      font-family: 'JetBrains Mono', 'Fira Code', monospace;
      font-size: 1.5rem;
      font-weight: 800;
      color: var(--primary);
    }

    .settings-panel {
      background: rgba(255, 255, 255, 0.6);
      border-radius: 12px;
      padding: 1.5rem;
      margin-bottom: 1.5rem;
      border: 1px solid rgba(255, 255, 255, 0.8);
    }

    .settings-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
    }

    .setting-group {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .setting-group label {
      font-size: 0.9rem;
      font-weight: 600;
      color: var(--gray);
    }

    .setting-group select,
    .setting-group input {
      padding: 0.5rem;
      border: 1px solid #cbd5e1;
      border-radius: 8px;
      font-size: 1rem;
    }

    .recordings-panel {
      max-height: 400px;
      overflow-y: auto;
      background: rgba(255, 255, 255, 0.6);
      border-radius: 12px;
      padding: 1.5rem;
    }

    .recording-item {
      display: grid;
      grid-template-columns: 1fr auto auto;
      gap: 1rem;
      align-items: center;
      padding: 1rem;
      margin-bottom: 0.5rem;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
    }

    .recording-info {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    .recording-name {
      font-weight: 600;
      color: var(--dark);
    }

    .recording-meta {
      font-size: 0.85rem;
      color: var(--gray);
    }

    .btn-small {
      padding: 8px 12px;
      font-size: 0.9rem;
      border-radius: 6px;
      border: none;
      cursor: pointer;
      font-weight: 600;
    }

    .hidden { display: none; }
    .clipping { animation: pulse 0.3s; }

    @keyframes pulse {
      0%, 100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
      50% { box-shadow: 0 0 0 8px rgba(239, 68, 68, 0); }
    }

    @media (max-width: 640px) {
      .container { padding: 1.5rem; }
      .controls { grid-template-columns: 1fr; }
      .logo { font-size: 2rem; }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1 class="logo">Minnesota Then üéôÔ∏è</h1>
      <p class="tagline">Professional Chromebook Recorder</p>
    </header>

    <div class="vu-meter" id="vuMeter">
      <div class="vu-bar" id="vuBar"></div>
    </div>
    <div class="vu-labels">
      <span>-‚àû</span>
      <span>-24</span>
      <span>-12</span>
      <span>-6</span>
      <span>0 dB</span>
    </div>

    <div class="waveform-container">
      <canvas id="waveform"></canvas>
    </div>

    <div class="status-grid">
      <span id="statusLabel" class="status-label">Ready</span>
      <span id="timer" class="timer">00:00:00</span>
    </div>

    <div class="controls">
      <button id="startBtn" class="btn btn-start">‚è∫Ô∏è Record</button>
      <button id="pauseBtn" class="btn btn-pause hidden">‚è∏Ô∏è Pause</button>
      <button id="stopBtn" class="btn btn-stop" disabled>‚èπÔ∏è Stop</button>
      <button id="previewBtn" class="btn btn-secondary hidden">‚ñ∂Ô∏è Preview</button>
    </div>

    <div class="settings-panel">
      <h3 style="margin-top: 0;">Recording Settings</h3>
      <div class="settings-grid">
        <div class="setting-group">
          <label>Bitrate</label>
          <select id="bitrateSelect">
            <option value="128">128 kbps (Standard)</option>
            <option value="192" selected>192 kbps (High)</option>
            <option value="256">256 kbps (Premium)</option>
          </select>
        </div>
        <div class="setting-group">
          <label>Sample Rate</label>
          <select id="sampleRateSelect">
            <option value="44100" selected>44.1 kHz (CD)</option>
            <option value="48000">48 kHz (Pro)</option>
          </select>
        </div>
        <div class="setting-group">
          <label>Filename Prefix</label>
          <input type="text" id="filenamePrefix" value="MNThen_Docent" placeholder="e.g., MNThen_Docent">
        </div>
      </div>
    </div>

    <div id="recordingsPanel" class="recordings-panel hidden">
      <h3 style="margin-top: 0;">Recording History</h3>
      <div id="recordingsList"></div>
    </div>
  </div>

  <!-- Dynamically load LAME.js when needed -->
  <script>
    // Dynamic library loader
    const loadScript = (src) => new Promise((resolve, reject) => {
      const script = document.createElement('script');
      script.src = src;
      script.onload = resolve;
      script.onerror = reject;
      document.head.appendChild(script);
    });

    // State management
    const state = {
      isRecording: false,
      isPaused: false,
      startTime: null,
      pauseTime: 0,
      mediaRecorder: null,
      audioContext: null,
      analyser: null,
      sourceNode: null,
      scriptNode: null,
      chunks: [],
      audioBuffer: [],
      mp3Encoder: null,
      currentBlob: null,
      db: null
    };

    // DOM elements
    const elements = {
      start: document.getElementById('startBtn'),
      pause: document.getElementById('pauseBtn'),
      stop: document.getElementById('stopBtn'),
      preview: document.getElementById('previewBtn'),
      status: document.getElementById('statusLabel'),
      timer: document.getElementById('timer'),
      vuBar: document.getElementById('vuBar'),
      vuMeter: document.getElementById('vuMeter'),
      canvas: document.getElementById('waveform'),
      ctx: document.getElementById('waveform').getContext('2d'),
      settings: {
        bitrate: document.getElementById('bitrateSelect'),
        sampleRate: document.getElementById('sampleRateSelect'),
        prefix: document.getElementById('filenamePrefix')
      },
      recordingsPanel: document.getElementById('recordingsPanel'),
      recordingsList: document.getElementById('recordingsList')
    };

    // Initialize database
    const initDB = async () => {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open('MNThenRecorder', 1);
        request.onerror = () => reject(request.error);
        request.onsuccess = () => {
          state.db = request.result;
          loadRecordings();
          resolve();
        };
        request.onupgradeneeded = (e) => {
          const db = e.target.result;
          db.createObjectStore('recordings', { keyPath: 'id', autoIncrement: true });
        };
      });
    };

    // Canvas setup
    const setupCanvas = () => {
      const dpr = window.devicePixelRatio || 1;
      const rect = elements.canvas.getBoundingClientRect();
      elements.canvas.width = rect.width * dpr;
      elements.canvas.height = rect.height * dpr;
      elements.ctx.scale(dpr, dpr);
    };

    window.addEventListener('resize', setupCanvas);
    setupCanvas();

    // Audio level meter
    let peakLevel = 0;
    const updateVUMeter = (data) => {
      let sum = 0;
      let max = 0;
      for (let i = 0; i < data.length; i++) {
        const val = Math.abs((data[i] - 128) / 128);
        max = Math.max(max, val);
        sum += val * val;
      }
      const rms = Math.sqrt(sum / data.length);
      peakLevel = Math.max(max, peakLevel * 0.95);
      
      const db = 20 * Math.log10(Math.max(rms, 0.0001));
      const percentage = Math.max(0, Math.min(100, (db + 50) * 2));
      
      elements.vuBar.style.width = `${percentage}%`;
      
      // Clipping detection
      if (peakLevel > 0.95) {
        elements.vuMeter.classList.add('clipping');
        setTimeout(() => elements.vuMeter.classList.remove('clipping'), 300);
      }
    };

    // Waveform drawer
    const waveData = new Uint8Array(1024);
    const drawWaveform = (data) => {
      const width = elements.canvas.width / (window.devicePixelRatio || 1);
      const height = elements.canvas.height / (window.devicePixelRatio || 1);
      
      elements.ctx.fillStyle = '#f1f5f9';
      elements.ctx.fillRect(0, 0, width, height);
      
      elements.ctx.lineWidth = 2;
      elements.ctx.strokeStyle = state.isRecording ? '#1e3a8a' : '#94a3b8';
      elements.ctx.beginPath();
      
      const step = Math.ceil(data.length / width);
      for (let x = 0; x < width; x++) {
        let min = 128, max = 128;
        for (let j = 0; j < step; j++) {
          const idx = Math.min(x * step + j, data.length - 1);
          const val = data[idx];
          min = Math.min(min, val);
          max = Math.max(max, val);
        }
        const yMin = (min / 255) * height;
        const yMax = (max / 255) * height;
        
        if (x === 0) elements.ctx.moveTo(x, yMin);
        elements.ctx.lineTo(x, yMin);
        elements.ctx.lineTo(x, yMax);
      }
      elements.ctx.stroke();
    };

    // Timer
    let timerInterval;
    const updateTimer = () => {
      const elapsed = Date.now() - state.startTime - state.pauseTime;
      const hours = Math.floor(elapsed / 3600000);
      const minutes = Math.floor((elapsed % 3600000) / 60000);
      const seconds = Math.floor((elapsed % 60000) / 1000);
      elements.timer.textContent = 
        `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    };

    // MP3 Encoding
    const processAudioChunk = (float32Data) => {
      if (!state.mp3Encoder) return;
      
      // Convert to Int16
      const int16 = new Int16Array(float32Data.length);
      for (let i = 0; i < float32Data.length; i++) {
        const val = float32Data[i] * 32768;
        int16[i] = val < -32768 ? -32768 : val > 32767 ? 32767 : Math.floor(val);
      }
      
      // Encode
      const mp3Data = state.mp3Encoder.encodeBuffer(int16);
      state.chunks.push(mp3Data);
    };

    // Recording logic
    const startRecording = async () => {
      try {
        elements.status.textContent = 'üî¥ Requesting microphone...';
        
        const stream = await navigator.mediaDevices.getUserMedia({ 
          audio: {
            echoCancellation: false,
            noiseSuppression: false,
            autoGainControl: false
          }
        });

        // Setup audio graph
        state.audioContext = new (window.AudioContext || window.webkitAudioContext)({
          sampleRate: parseInt(elements.settings.sampleRate.value)
        });
        
        state.analyser = state.audioContext.createAnalyser();
        state.analyser.fftSize = 2048;
        state.analyser.smoothingTimeConstant = 0.8;
        
        state.sourceNode = state.audioContext.createMediaStreamSource(stream);
        state.scriptNode = state.audioContext.createScriptProcessor(4096, 1, 1);
        
        state.sourceNode.connect(state.analyser);
        state.analyser.connect(state.scriptNode);
        state.scriptNode.connect(state.audioContext.destination);

        // Initialize MP3 encoder
        if (typeof lamejs === 'undefined') {
          await loadScript('https://cdn.jsdelivr.net/npm/lamejs@1.2.0/lame.min.js');
        }
        
        const bitrate = parseInt(elements.settings.bitrate.value);
        state.mp3Encoder = new lamejs.Mp3Encoder(1, state.audioContext.sampleRate, bitrate);

        // Audio processing
        state.scriptNode.onaudioprocess = (e) => {
          if (!state.isRecording || state.isPaused) return;
          
          const inputData = e.inputBuffer.getChannelData(0);
          state.audioBuffer.push(new Float32Array(inputData));
          
          processAudioChunk(inputData);
          
          // Visual feedback
          state.analyser.getByteTimeDomainData(waveData);
          drawWaveform(waveData);
          updateVUMeter(waveData);
        };

        // Start
        state.isRecording = true;
        state.startTime = Date.now();
        state.pauseTime = 0;
        state.chunks = [];
        state.audioBuffer = [];
        
        timerInterval = setInterval(updateTimer, 100);
        
        elements.start.classList.add('hidden');
        elements.pause.classList.remove('hidden');
        elements.stop.disabled = false;
        elements.status.textContent = 'üî¥ LIVE RECORDING';
        
        // Handle stream end
        stream.getAudioTracks()[0].onended = () => {
          if (state.isRecording) stopRecording();
        };

      } catch (err) {
        elements.status.textContent = `‚ùå ${err.message}`;
        console.error('Recording error:', err);
      }
    };

    const pauseRecording = () => {
      if (!state.isPaused) {
        state.pauseStart = Date.now();
        state.isPaused = true;
        elements.pause.textContent = '‚è∏Ô∏è Resume';
        elements.status.textContent = '‚è∏Ô∏è PAUSED';
        clearInterval(timerInterval);
      } else {
        state.pauseTime += Date.now() - state.pauseStart;
        state.isPaused = false;
        elements.pause.textContent = '‚è∏Ô∏è Pause';
        elements.status.textContent = 'üî¥ LIVE RECORDING';
        timerInterval = setInterval(updateTimer, 100);
      }
    };

    const finalizeRecording = () => {
      clearInterval(timerInterval);
      
      // Flush MP3 encoder
      const mp3End = state.mp3Encoder.flush();
      if (mp3End.length > 0) state.chunks.push(mp3End);
      
      // Concatenate
      const totalLength = state.chunks.reduce((acc, chunk) => acc + chunk.length, 0);
      const mp3Data = new Uint8Array(totalLength);
      let offset = 0;
      state.chunks.forEach(chunk => {
        mp3Data.set(chunk, offset);
        offset += chunk.length;
      });

      // Add ID3 tags
      const title = `${elements.settings.prefix.value}_${new Date().toISOString().slice(0, 19).replace(/[-:]/g, '')}`;
      const id3 = {
        title: title,
        artist: 'Minnesota Then Virtual Docent',
        album: 'Site Narrations',
        year: new Date().getFullYear(),
        comment: 'Recorded with Minnesota Then Pro Recorder'
      };

      state.currentBlob = new Blob([mp3Data], { type: 'audio/mp3' });
      
      // Save to IndexedDB
      const recording = {
        id: Date.now(),
        name: `${title}.mp3`,
        blob: state.currentBlob,
        size: state.currentBlob.size,
        duration: Date.now() - state.startTime - state.pauseTime,
        timestamp: new Date()
      };
      
      const tx = state.db.transaction(['recordings'], 'readwrite');
      tx.objectStore('recordings').add(recording);
      
      elements.preview.classList.remove('hidden');
      elements.recordingsPanel.classList.remove('hidden');
      loadRecordings();
      
      elements.status.textContent = `‚úÖ Complete: ${(recording.size / 1024 / 1024).toFixed(2)} MB`;
    };

    const stopRecording = async () => {
      if (!state.isRecording) return;
      
      state.isRecording = false;
      state.isPaused = false;
      
      elements.pause.classList.add('hidden');
      elements.start.classList.remove('hidden');
      elements.stop.disabled = true;
      
      if (state.scriptNode) state.scriptNode.disconnect();
      if (state.sourceNode) state.sourceNode.disconnect();
      if (state.audioContext) await state.audioContext.close();
      
      elements.status.textContent = 'üíæ Finalizing MP3...';
      setTimeout(finalizeRecording, 100);
    };

    const previewRecording = () => {
      if (!state.currentBlob) return;
      const url = URL.createObjectURL(state.currentBlob);
      const audio = new Audio(url);
      audio.play();
      audio.onended = () => URL.revokeObjectURL(url);
    };

    const loadRecordings = async () => {
      const tx = state.db.transaction(['recordings'], 'readonly');
      const recordings = await tx.objectStore('recordings').getAll();
      
      elements.recordingsList.innerHTML = recordings
        .sort((a, b) => b.id - a.id)
        .map(rec => `
          <div class="recording-item">
            <div class="recording-info">
              <div class="recording-name">${rec.name}</div>
              <div class="recording-meta">
                ${formatDuration(rec.duration)} ‚Ä¢ ${(rec.size / 1024 / 1024).toFixed(2)} MB
              </div>
            </div>
            <button class="btn-small btn-secondary" onclick="playRecording(${rec.id})">Play</button>
            <button class="btn-small btn-start" onclick="downloadRecording(${rec.id})">Download</button>
          </div>
        `).join('');
    };

    const formatDuration = (ms) => {
      const minutes = Math.floor(ms / 60000);
      const seconds = Math.floor((ms % 60000) / 1000);
      return `${minutes}:${seconds.toString().padStart(2, '0')}`;
    };

    window.playRecording = async (id) => {
      const tx = state.db.transaction(['recordings'], 'readonly');
      const recording = await tx.objectStore('recordings').get(id);
      const url = URL.createObjectURL(recording.blob);
      const audio = new Audio(url);
      audio.play();
      audio.onended = () => URL.revokeObjectURL(url);
    };

    window.downloadRecording = async (id) => {
      const tx = state.db.transaction(['recordings'], 'readonly');
      const recording = await tx.objectStore('recordings').get(id);
      const url = URL.createObjectURL(recording.blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = recording.name;
      a.click();
      URL.revokeObjectURL(url);
    };

    // Event listeners
    elements.start.addEventListener('click', startRecording);
    elements.pause.addEventListener('click', pauseRecording);
    elements.stop.addEventListener('click', stopRecording);
    elements.preview.addEventListener('click', previewRecording);

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if (e.code === 'Space' && !e.target.matches('input, select')) {
        e.preventDefault();
        if (!state.isRecording) startRecording();
        else if (!state.isPaused) pauseRecording();
        else pauseRecording(); // resume
      } else if (e.code === 'Escape' && state.isRecording) {
        stopRecording();
      }
    });

    // Initialize
    initDB().then(() => {
      elements.status.textContent = '‚úÖ Ready to record';
    }).catch(err => {
      elements.status.textContent = '‚ö†Ô∏è Storage unavailable';
    });

    // Cleanup on unload
    window.addEventListener('beforeunload', () => {
      if (state.audioContext) state.audioContext.close();
    });
  </script>
</body>
</html>
