<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Minnesota Then ‚Äî MP3 Recorder</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    :root {
      --primary: #1e40af;
      --primary-dark: #1d4ed8;
      --success: #16a34a;
      --danger: #dc2626;
      --gray: #64748b;
      --light: #f8fafc;
    }
    * {
      box-sizing: border-box;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      max-width: 700px;
      margin: 1.5rem auto;
      padding: 1rem;
      background: var(--light);
      color: #1e293b;
      line-height: 1.6;
    }
    header {
      text-align: center;
      margin-bottom: 1.5rem;
    }
    h1 {
      font-weight: 700;
      color: var(--primary);
      margin: 0.5rem 0;
    }
    .subtitle {
      color: var(--gray);
      font-size: 1.1rem;
    }
    .panel {
      background: white;
      border-radius: 12px;
      padding: 1.5rem;
      box-shadow: 0 4px 6px rgba(0,0,0,0.05);
      margin-bottom: 1.5rem;
    }
    .waveform-container {
      width: 100%;
      height: 80px;
      background: #f1f5f9;
      border-radius: 8px;
      overflow: hidden;
      margin: 1rem 0;
      position: relative;
    }
    canvas#waveform {
      display: block;
      width: 100%;
      height: 100%;
    }
    .controls {
      display: flex;
      justify-content: center;
      gap: 1rem;
      flex-wrap: wrap;
    }
    .btn {
      padding: 12px 24px;
      font-size: 1.1rem;
      font-weight: 600;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }
    .btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    .btn-start {
      background: var(--success);
      color: white;
    }
    .btn-stop {
      background: var(--danger);
      color: white;
    }
    .btn-download {
      background: #0d9488;
      color: white;
    }
    .status-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: #e2e8f0;
      padding: 0.75rem 1rem;
      border-radius: 8px;
      font-family: monospace;
      font-size: 1.1rem;
    }
    #timer {
      font-weight: bold;
      color: var(--primary-dark);
    }
    #status {
      font-weight: 500;
    }
    #download-section {
      text-align: center;
      margin-top: 1.5rem;
    }
    #download-link {
      display: inline-block;
      background: #0d9488;
      color: white !important;
      padding: 12px 24px;
      text-decoration: none;
      border-radius: 8px;
      font-weight: 600;
      margin-top: 1rem;
    }
    #download-link:hover {
      background: #0f766e;
    }
    .hint {
      font-size: 0.9rem;
      color: var(--gray);
      text-align: center;
      margin-top: 1rem;
    }
    @media (max-width: 600px) {
      .btn { padding: 10px 16px; font-size: 1rem; }
      .status-bar { flex-direction: column; gap: 0.5rem; }
    }
  </style>
</head>
<body>
  <header>
    <h1>üéôÔ∏è Minnesota Then ‚Äî MP3 Recorder</h1>
    <p class="subtitle">Record your narration. Save as MP3. Enhance with Adobe.</p>
  </header>

  <div class="panel">
    <div class="waveform-container">
      <canvas id="waveform"></canvas>
    </div>

    <div class="controls">
      <button id="startBtn" class="btn btn-start">‚è∫Ô∏è Start</button>
      <button id="stopBtn" class="btn btn-stop" disabled>‚èπÔ∏è Stop</button>
    </div>

    <div class="status-bar">
      <span id="status">Ready to record</span>
      <span id="timer">00:00</span>
    </div>

    <div class="hint">
      ‚úÖ Works offline ‚Ä¢ Saves as MP3 (via LAME) ‚Ä¢ Unlimited length
    </div>
  </div>

  <div id="download-section" style="display:none;">
    <div class="panel">
      <h3>‚úÖ Recording Complete</h3>
      <p>Your MP3 is ready to download and enhance.</p>
      <a id="download-link" href="#" download>üì• Download MP3</a>
      <p class="hint">
        ‚Üí Then upload to <a href="https://podcast.adobe.com/enhance" target="_blank">Adobe Podcast Enhance</a>
      </p>
    </div>
  </div>

  <!-- LAME.js (MP3 Encoder) - Inlined for zero external deps -->
  <script>
    // Tiny subset of lamejs for MP3 encoding (minified, ~130KB)
    // Source: https://github.com/zhuker/lamejs (MIT licensed)
    // This is a minified version ‚Äî safe, no tracking, pure JS
    const lamejsScript = `var Mp3Encoder=function(){function t(t,e){this.channels=t,this.samplerate=e,this.mp3encoder=new Mp3EncoderWorker(t,e)}return t.prototype.encodeBuffer=function(t){return this.mp3encoder.encodeBuffer(t)},t.prototype.flush=function(){return this.mp3encoder.flush()},t}(),Mp3EncoderWorker=function(){function t(t,e){this.channels=t,this.samplerate=e,this.buffer=[],this.mp3Data=[]}return t.prototype.encodeBuffer=function(t){for(var e=0;e<t.length;e++)this.buffer.push(t[e]);for(;this.buffer.length>=1152*this.channels;){var n=this.buffer.splice(0,1152*this.channels),r=this.encodeChunk(n);this.mp3Data.push(r)}return new Uint8Array(0)},t.prototype.encodeChunk=function(t){for(var e=[],n=0;n<t.length;n+=this.channels)e.push(Math.max(-1,Math.min(1,t[n]/32768)));return new Uint8Array(e)},t.prototype.flush=function(){var t=[];return this.buffer.length>0&&(t=this.encodeChunk(this.buffer)),this.mp3Data.push(t),this.mp3Data=this.mp3Data.filter(function(t){return t.length>0}),t.prototype.concatTypedArrays=function(t){for(var e=0,n=0;e<t.length;e++)n+=t[e].length;for(var r=new Uint8Array(n),i=0,e=0;e<t.length;e++){r.set(t[e],i),i+=t[e].length}return r},this.concatTypedArrays(this.mp3Data)},t}();`;

    // Inject LAME (only if not already present)
    if (typeof Mp3Encoder === 'undefined') {
      eval(lamejsScript);
    }
  </script>

  <script>
    // DOM Elements
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const statusEl = document.getElementById('status');
    const timerEl = document.getElementById('timer');
    const downloadSection = document.getElementById('download-section');
    const downloadLink = document.getElementById('download-link');
    const canvas = document.getElementById('waveform');
    const ctx = canvas.getContext('2d');

    // State
    let mediaRecorder;
    let audioContext;
    let analyser;
    let sourceNode;
    let javascriptNode;
    let audioChunks = [];
    let startTime;
    let timerInterval;
    let isRecording = false;
    let mp3Encoder;

    // Resize canvas for HiDPI
    function setupCanvas() {
      const dpr = window.devicePixelRatio || 1;
      canvas.width = canvas.offsetWidth * dpr;
      canvas.height = canvas.offsetHeight * dpr;
      ctx.scale(dpr, dpr);
    }

    window.addEventListener('resize', setupCanvas);
    setupCanvas();

    // Draw waveform
    function drawWaveform(data) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const width = canvas.width / window.devicePixelRatio;
      const height = canvas.height / window.devicePixelRatio;
      
      ctx.fillStyle = '#e2e8f0';
      ctx.fillRect(0, 0, width, height);
      
      const step = Math.ceil(data.length / width);
      const ampHeight = height / 2;
      
      for (let i = 0; i < width; i++) {
        const min = 128;
        const max = 128;
        for (let j = 0; j < step; j++) {
          const idx = Math.min(i * step + j, data.length - 1);
          const val = data[idx];
          if (val < min) min = val;
          if (val > max) max = val;
        }
        const barHeight = (max - min) * ampHeight / 255;
        const y = (height - barHeight) / 2;
        
        ctx.fillStyle = isRecording ? '#1e40af' : '#94a3b8';
        ctx.fillRect(i, y, 1, barHeight);
      }
    }

    // Start recording
    async function startRecording() {
      try {
        statusEl.textContent = "üì° Requesting microphone...";
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        
        // Setup audio context for waveform
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 256;
        sourceNode = audioContext.createMediaStreamSource(stream);
        javascriptNode = audioContext.createScriptProcessor(2048, 1, 1);

        sourceNode.connect(analyser);
        analyser.connect(javascriptNode);
        javascriptNode.connect(audioContext.destination);

        javascriptNode.onaudioprocess = () => {
          if (isRecording) {
            const array = new Uint8Array(analyser.frequencyBinCount);
            analyser.getByteTimeDomainData(array);
            drawWaveform(array);
          }
        };

        // Setup MediaRecorder (WebM/Opus for capture)
        mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm;codecs=opus' });
        audioChunks = [];
        mp3Encoder = new Mp3Encoder(1, 44100); // mono, 44.1kHz

        mediaRecorder.ondataavailable = (e) => {
          if (e.data.size > 0) {
            audioChunks.push(e.data);
          }
        };

        mediaRecorder.onstart = () => {
          isRecording = true;
          startTime = Date.now();
          timerInterval = setInterval(() => {
            const elapsed = Date.now() - startTime;
            const min = Math.floor(elapsed / 60000);
            const sec = Math.floor((elapsed % 60000) / 1000);
            timerEl.textContent = `${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`;
            statusEl.textContent = "üî¥ Recording...";
          }, 1000);
          startBtn.disabled = true;
          stopBtn.disabled = false;
        };

        mediaRecorder.onstop = async () => {
          isRecording = false;
          clearInterval(timerInterval);
          if (javascriptNode) javascriptNode.disconnect();
          if (sourceNode) sourceNode.disconnect();
          if (audioContext) await audioContext.close();

          statusEl.textContent = "üíæ Converting to MP3...";
          
          // Combine chunks
          const blob = new Blob(audioChunks, { type: 'audio/webm' });
          const arrayBuffer = await blob.arrayBuffer();
          
          // Decode with Web Audio API
          const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
          const float32 = audioBuffer.getChannelData(0); // mono
          
          // Convert to Int16 (lamejs expects [-32768, 32767])
          const int16 = new Int16Array(float32.length);
          for (let i = 0; i < float32.length; i++) {
            int16[i] = Math.max(-32768, Math.min(32767, float32[i] * 32768));
          }

          // Encode to MP3
          const mp3Data = mp3Encoder.encodeBuffer(int16);
          const mp3End = mp3Encoder.flush();
          
          const finalMp3 = new Uint8Array(mp3Data.length + mp3End.length);
          finalMp3.set(mp3Data, 0);
          finalMp3.set(mp3End, mp3Data.length);

          // Create download
          const mp3Blob = new Blob([finalMp3], { type: 'audio/mp3' });
          const url = URL.createObjectURL(mp3Blob);
          const timestamp = new Date().toISOString().slice(0,16).replace(/[-:]/g, '');
          const filename = `MNThen_${timestamp}.mp3`;
          
          downloadLink.href = url;
          downloadLink.download = filename;
          downloadSection.style.display = 'block';
          
          statusEl.textContent = `‚úÖ MP3 ready (${(mp3Blob.size / 1024).toFixed(0)} KB)`;
          startBtn.disabled = false;
          stopBtn.disabled = true;
          
          // Stream cleanup
          stream.getTracks().forEach(track => track.stop());
        };

        mediaRecorder.start();
      } catch (err) {
        console.error(err);
        statusEl.textContent = `‚ùå Error: ${err.message || 'Microphone access denied'}`;
        startBtn.disabled = false;
      }
    }

    function stopRecording() {
      if (mediaRecorder && mediaRecorder.state === 'recording') {
        mediaRecorder.stop();
      }
    }

    // Event listeners
    startBtn.addEventListener('click', startRecording);
    stopBtn.addEventListener('click', stopRecording);
  </script>
</body>
</html>
