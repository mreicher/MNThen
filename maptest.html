<!DOCTYPE html>
    <html>
        <head>

            <title>Minnesota Then</title>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <meta name="description" content="An interactive map for self-guided Minnesota history museum exhibits statewide">
    <meta name="theme-color" content="#000000">

    <link rel="shortcut icon" type="image/x-icon" href="https://www.mnthen.com/images/mnthenfav.ico">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.markercluster/1.5.1/MarkerCluster.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.markercluster/1.5.1/MarkerCluster.Default.css" />
    <link rel="stylesheet" type="text/css" href="https://www.mnthen.com/css/map_page.css">

    <style>
        .blue-marker { background-color: blue; }
        .orange-marker { background-color: orange; }
        .green-marker { background-color: green; }
        .split-marker { background-color: purple; }
        .wbl_split-marker { background-color: red; }
        .lake-marker { background-color: cyan; }
        .capitol-marker { background-color: brown; }
        .summit-marker { background-color: gray; }
        .northeast-marker { background-color: teal; }

    .custom-pin-icon {
      display: flex;
      justify-content: center;
      align-items: flex-start;
    }

    .pin-head {
      position: absolute;
      top: 0;
      left: 50%;
      transform: translateX(-50%) rotate(-45deg);
      width: 20px;
      height: 20px;
      border-radius: 50% 50% 50% 0;
      border: 2px solid white;
      box-shadow: 0 0 3px rgba(0,0,0,0.1);
    }

        .leaflet-popup {
            transition: opacity 0.5s;
        }

        #distanceBox {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 8px 18px;
            background: var(--light-bg-color);
            border-radius: 20px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            font-size: 22px;
            font-weight: 600;
            color: var(--text-color);
            border: 2px solid #ccc;
            z-index: 1000;
            transition: all 0.3s ease;
        }

        #distanceBox.within-threshold {
            border: 2px solid green;
        }

        #distanceBox.within-cooldown {
            border: 2px solid orange;
        }

        .centered-icon {
            transition: all 0.3s ease-out;
        }
        
#explanation-popup {
    width: 95%; /* Default width */
}

@media only screen and (max-width: 768px) {
 #explanation-popup {
        width: 90%; /* Width for mobile devices */
    }
}

#explanation-popup h3 {
 font-size: 1.3rem;
    color: var(--primary-color);
    border-bottom: 2px solid var(--primary-color);
    padding-bottom: 10px;
    margin-bottom: 15px;
}

#explanation-popup h4 {
    font-size: 1.2rem;
    margin-top: 20px;
 margin-bottom: 10px;
}

#explanation-popup p {
    text-align: left;
    margin: 10px 0;
   -size: 1rem}

#explanation-popup ul.itinerary-list {
    list-style-type: none;
    padding-left: 0;
}

#explanation-popup ul.itinerary-list li {
    font-size: 1rem;
    margin: 8px 0;
    padding-left: 25px;
    position: relative;
}

#explanation-popup ul.itinerary-list li i.fas.fa-map-marker-alt {
    position: absolute;
    left: 0;
 top 2px;
    color: var(--primary-color);
}

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.7);
        }

        .modal-content {
            background-color: #fefefe;
            text-align: center;
            margin: 10% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 90%;
            max-width: 400px;
            border-radius: 12px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            position: relative;
        }

        .close {
            color: #aaa;
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close:hover,
        .close:focus {
            color: #000;
            text-decoration: none;
        }

        .modal-text {
            font-size: 20px;
            margin-bottom: 30px;
            line-height: 1.4;
        }

        .button-container {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 30px;
        }

        .modal-button {
            padding: 12px 24px;
            font-size: 18px;
            cursor: pointer;
            color: white;
            border: none;
            border-radius: 12px;
            flex: 1;
            max-width: 45%;
        }

        #continueButton {
            background-color: #4CAF50;
        }

        #cancelButton {
            background-color: #f44336;
        }

        .modal-button:hover {
            opacity: 0.9;
        }

        #exit-icon {
            color: #333;
            font-size: 30px;
        }
        
        #exit-button button.exit-button {
            background-color: #F5F5F5; /* Set the button background color to white */
            height: 45px;
            border-radius: 20px;
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            font-size: 1.125rem; /* Responsive font size */
            padding: 5px;
            border: 1px solid #717171;
        }

        #exit-button button.exit-button i {
            color: black; 
        }

        #recenter-button, #help-button {
            position: absolute;
            bottom: 10px;
            background-color: #F5F5F5;
            padding: 5px;
            border-radius: 50%;
            border: 1px solid #717171;
        }

        @media screen and (max-width: 600px) {
            .modal-content {
                margin: 15% auto;
                width: 85%;
            }

            .modal-text {
                font-size: 19px;
            }

            .modal-button {
                font-size: 16px;
                padding: 10px 20px;
            }
        }
    </style>
</head>
<body>
    <div id="map-container">
        <div id="map"></div>

        <div id="recenter-button" class="leaflet-bar leaflet-control leaflet-control-custom">
            <i class="fas fa-crosshairs" id="recenter-icon"></i>
        </div>

        <div id="help-button" class="leaflet-bar leaflet-control leaflet-control-custom">
            <i class="fas fa-question-circle" id="help-icon"></i>
        </div>

        <div id="exit-button">
            <button class="exit-button"><i class="fas fa-sign-out-alt" id="exit-icon"></i>
        </button>
    </div>
    
    <div id="distanceBox">Initializing ...</div>

    <div id="explanation-popup" class="hidden">
        <h3>Navigation Tips</h3>
        <p>&#8226; Pinch, zoom, and glide across the map to uncover hidden gems.</p>
        <p>&#8226; Open popups to read articles or get directions to any location you want to learn more about.</p>
        <p>&#8226; Let the map re-align to your location, or tap the recenter button in the bottom-left corner.</p>
        <p>&#8226; Be within 20 feet of a marker to interact with the location.</p>
        <p>&#8226; Wait 90 seconds to revisit a previous location.</p>
        <button id="close-popup">Close</button>
    </div>

    <div id="forwardingModal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <p class="modal-text">Get turn-by-turn directions to the location with Google Maps (opens in a new window). <br><br>Would you like to continue?</p>
            <div class="button-container">
                <button id="continueButton" class="modal-button">Continue</button>
                <button id="cancelButton" class="modal-button">Cancel</button>
            </div>
        </div>
    </div>
    </div>

<script src="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.js"></script> 
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.markercluster/1.5.1/leaflet.markercluster.js"></script> 
<script src="/locations_test.js?ts=091020241"></script>
    
<script> 
// Initialize closestDistance with Infinity
let closestDistance = Infinity;
let newMarkers = {};

// Define alpha-beta filter constants and variables
const alpha = 0.1;
const beta = 0.005;

let lastEstimatedPos = null;

document.addEventListener("DOMContentLoaded", function () {
    const distanceBox = document.getElementById("distanceBox");
    const locationPopup = document.createElement("div");

    locationPopup.id = "location-popup";
    locationPopup.innerHTML = "Locating user...";
    document.body.appendChild(locationPopup);

    // Initial message if location isn't found within 25 seconds
    const locationTimeout = setTimeout(() => {
        locationPopup.innerHTML = `
            <div>
                <p>Still searching ...</p>
            </div>
        `;

        // Second message if location still isn't found after an additional 10 seconds
        const extendedTimeout = setTimeout(() => {
            locationPopup.innerHTML = `
                <div>
                    <p>Unable to find your location. Please check your settings or try again.</p>
                </div>
            `;
        }, 10000);
    }, 15000);

    const INITIAL_DELAY = 2000; // 2 seconds
    const COOLDOWN = 90000; // 90 seconds
    const AUTO_CENTER_THRESHOLD = 25000;  // 25 seconds
    const thresholdFeet = 20; // 20 feet for triggering redirection based on proximity to a marker -- this is the big one.
 
    var lastTransitionTime = sessionStorage.getItem('lastTransitionTime');
    var lastVisitedLocation = sessionStorage.getItem('lastVisitedLocation');

    if (lastTransitionTime && Date.now() - lastTransitionTime < COOLDOWN) {
        console.log('Cooldown active');
    } else {
        console.log('No cooldown');
    }

var map = L.map("map", {
    attributionControl: false,
    zoomControl: false,
    inertia: false,
}).setView([45.09396938812941, -92.99743282865592], 19);

L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    maxZoom: 19,
    id: "mapbox/streets-v11",
    tileSize: 512,
    zoomOffset: -1,
    crossOrigin: true,
    useCache: true,
    maxRequests: 6
}).addTo(map);

L.control.attribution({ prefix: false }).addTo(map);

var userLocationMarker = L.circleMarker([0, 0], {
    color: "red",
    fillColor: "#f03",
    fillOpacity: 0.5,
    radius: 6,
}).addTo(map);

var userInteracted = false;

map.on("dragstart zoomstart", function() {
    userInteracted = true;
});

// Add these new event listeners
map.on('zoomstart dragstart', () => {
    userInteracting = true;
    clearTimeout(userInteractionTimer);
});

map.on('zoomend dragend', () => {
    clearTimeout(userInteractionTimer);
    userInteractionTimer = setTimeout(() => {
        userInteracting = false;
    }, USER_INTERACTION_TIMEOUT);
});

    const markers = L.markerClusterGroup({
        spiderfyOnMaxZoom: false,
        disableClusteringAtZoom: 18,
        chunkedLoading: true,
        chunkInterval: 200,
        chunkDelay: 50,
        maxClusterRadius: function(zoom) {
            return (zoom <= 15) ? 89 : 40;
        },
        iconCreateFunction: function(cluster) {
            return L.divIcon({
                html: `<div style="
                            background-color: #006400; 
                            color: white;
                            border-radius: 50%;
                            width: 35px;
                            height: 35px;
                            display: flex;
                            justify-content: center;
                            align-items: center;
                            font-size: 16px;
                            font-weight: bold;
                        ">
                            ${cluster.getChildCount()}
                       </div>`,
                className: 'custom-cluster-icon',
                iconSize: L.point(35, 35)
            });
        }
    });
    
    map.addLayer(markers);

    markers.on("clusterclick", function (e) {
        var childMarkers = e.layer.getAllChildMarkers();
        if (childMarkers.length > 0) {
            childMarkers[0].openPopup();
        }
    });

    function loadScriptWithCacheBust() {
        const cacheBust = Date.now();
        const script = document.createElement("script");

        if (!document.querySelector('[src^="/locations_test.js"]')) {
            script.src = `/locations_test.js?v=${cacheBust}`;
        }

        let scriptLoadTimeout;

        script.onload = function() {
            if (Array.isArray(locations) && locations.length) {
                console.log("Location data loaded successfully:", locations);
                map.locate({ setView: false, maxZoom: 19 });
            } else {
                console.error("Location data is missing or empty:", locations);
                alert("Location data could not be loaded. Please refresh the page and try again.");
            }
            clearTimeout(scriptLoadTimeout);
        };

        script.onerror = function() {
            if (scriptLoadTimeout) {
                console.error("Failed to load the script:", script.src);
                alert("Failed to load location data. Please check your internet connection and try again.");
            } else {
                scriptLoadTimeout = setTimeout(() => {
                    console.error("Failed to load the script:", script.src);
                    alert("Failed to load location data. Please check your internet connection and try again.");
                }, 15000);
            }
        };

        document.body.appendChild(script);
    }

    loadScriptWithCacheBust();

    var initialLocationSet = false;
    var lastUserInteractionTime = 0;

    map.on("dragstart zoomstart", function() {
        lastUserInteractionTime = Date.now();
    });
  
    map.on("locationfound", function (e) {
        console.log("Location found:", e);
        clearTimeout(locationTimeout);
        locationPopup.innerHTML = "User found.";
        setTimeout(() => {
            locationPopup.style.display = "none";
        }, 2000);

        if (!initialLocationSet) {
            map.setView(e.latlng, 19);
            initialLocationSet = true;
        } else {
            const timeSinceLastInteraction = Date.now() - lastUserInteractionTime;
            if (timeSinceLastInteraction > AUTO_CENTER_THRESHOLD) {
                map.setView(e.latlng, map.getZoom());
            }
        }
    });

    var currentMarkers = {};
    var lastKnownLatLng = null;
    var currentLatLng = null;
    var closestLocation = null;
    let useHighAccuracy = false;
    let lastEstimatedVel = { lat: 0, lng: 0 };

    function alphaBetaFilter(newMeasurement) {
        if (!lastEstimatedPos) {
            lastEstimatedPos = { ...newMeasurement };
            return lastEstimatedPos;
        }

        const { lat: lastLat, lng: lastLng } = lastEstimatedPos;
        const { lat: velLat, lng: velLng } = lastEstimatedVel;

        const predictedPos = {
            lat: lastLat + velLat,
            lng: lastLng + velLng
        };

        const residual = {
            lat: newMeasurement.lat - predictedPos.lat,
            lng: newMeasurement.lng - predictedPos.lng
        };

        lastEstimatedPos.lat += alpha * residual.lat;
        lastEstimatedPos.lng += alpha * residual.lng;
        lastEstimatedVel.lat += beta * residual.lat;
        lastEstimatedVel.lng += beta * residual.lng;

        return lastEstimatedPos;
    }

    class KalmanFilter {
        constructor(R, Q) {
            this.R = R;
            this.Q = Q;
            this.P = 1;
            this.X = null;
            this.K = 0;
        }

        filter(measurement) {
            if (this.X === null) {
                this.X = measurement;
                return this.X;
            }

            this.P = this.P + this.Q;
            this.K = this.P / (this.P + this.R);
            this.X = this.X + this.K * (measurement - this.X);
            this.P = (1 - this.K) * this.P;

            return this.X;
        }
    }

    const latFilter = new KalmanFilter(0.01, 0.1);
    const lngFilter = new KalmanFilter(0.01, 0.1);

    function kalmanFilterPosition(position) {
        return {
            lat: latFilter.filter(position.lat),
            lng: lngFilter.filter(position.lng)
        };
    }

    let lastExpSmoothedValue = null;
    const expSmoothingFactor = 0.2;

    function newExponentialSmoothing(newMeasurement) {
        if (!lastExpSmoothedValue) {
            lastExpSmoothedValue = { ...newMeasurement };
            return lastExpSmoothedValue;
        }

        const smoothed = {};
        Object.keys(newMeasurement).forEach(key => {
            smoothed[key] = lastExpSmoothedValue[key] + expSmoothingFactor * (newMeasurement[key] - lastExpSmoothedValue[key]);
        });

        lastExpSmoothedValue = smoothed;
        return smoothed;
    }

    const movingAverageWindow = 8;
    let positionBuffer = [];

    function movingAverageFilter(newMeasurement) {
        positionBuffer.push(newMeasurement);
        if (positionBuffer.length > movingAverageWindow) {
            positionBuffer.shift();
        }

        const bufferLength = positionBuffer.length;
        const avgPosition = positionBuffer.reduce((acc, pos) => {
            Object.keys(pos).forEach(key => {
                acc[key] = (acc[key] || 0) + pos[key] / bufferLength;
            });
            return acc;
        }, {});

        return L.latLng(avgPosition.lat, avgPosition.lng);
    }

    let lastAppliedLatLng = null;
    let isStationary = true;
    const STATIONARY_THRESHOLD = 0.75; // feet per second

    function combinedFilter(newMeasurement) {
        const alphaBetaPos = alphaBetaFilter(newMeasurement);
        const movingAvgPos = movingAverageFilter(alphaBetaPos);
        const expSmoothPos = newExponentialSmoothing(movingAvgPos);
        return kalmanFilterPosition(expSmoothPos);
    }

    function fastDistanceApprox(latlng1, latlng2) {
        const R = 6371000;
        const { lat: lat1, lng: lng1 } = latlng1;
        const { lat: lat2, lng: lng2 } = latlng2;
        
        const dLat = (lat2 - lat1) * Math.PI / 180;
        const dLng = (lng2 - lng1) * Math.PI / 180;
        
        const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                  Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                  Math.sin(dLng/2) * Math.sin(dLng/2);
        
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        
        return R * c;
    }
    
    function applyDynamicDeadband(latLng, lastLatLng, isStationary) {
        if (!isValidLatLng(latLng) || !isValidLatLng(lastLatLng)) {
            console.warn('Invalid latLng or lastLatLng: Using last known valid position');
            return lastLatLng || latLng;
        }

        if (typeof isStationary !== 'boolean') {
            console.warn('Invalid isStationary value: Defaulting to true');
            isStationary = true;
        }

        const deadbandThresholdMeters = isStationary ? 1.2192 : 0.4572;

        const distanceMeters = fastDistanceApprox(latLng, lastLatLng);

        return distanceMeters < deadbandThresholdMeters ? lastLatLng : latLng;
    }

    function isValidLatLng(latLng) {
        return latLng && 
               typeof latLng.lat === 'number' && 
               typeof latLng.lng === 'number' &&
               !isNaN(latLng.lat) && 
               !isNaN(latLng.lng) &&
               Math.abs(latLng.lat) <= 90 &&
               Math.abs(latLng.lng) <= 180;
    }

    const smoothingFactor = 0.15;

    function lowPassFilter(newMeasurement) {
        if (!lastAppliedLatLng) return newMeasurement;
        return {
            lat: lastAppliedLatLng.lat + smoothingFactor * (newMeasurement.lat - lastAppliedLatLng.lat),
            lng: lastAppliedLatLng.lng + smoothingFactor * (newMeasurement.lng - lastAppliedLatLng.lng)
        };
    }

const SHORT_DISTANCE_THRESHOLD = 100; // meters
const LONG_DISTANCE_THRESHOLD = 1000; // meters
const USER_INTERACTION_TIMEOUT = 3000; // ms
const SMOOTHING_FACTOR = 0.4;
const PREDICTION_TIME = 0.5;
const UPDATE_INTERVAL = 500;

let resetInteractionTimeout;
let lastUpdateTime = null;
let lastCenteredLocation = null;
let userInteracting = false;
let userInteractionTimer = null;

function updateUserLocation(e = null) {
    const now = Date.now();
    console.log('updateUserLocation called with', e);
    currentLatLng = e ? e.latlng : lastKnownLatLng;
    console.log('Set currentLatLng to:', currentLatLng);
    
    if (!currentLatLng) {
        console.warn('No current location available');
        return null;
    }
    
    if (lastUpdateTime && lastAppliedLatLng) {
        const timeDiff = (now - lastUpdateTime) / 1000;
        const distanceFeet = fastDistanceApprox(currentLatLng, lastAppliedLatLng) * 3.28084;
        const speed = distanceFeet / timeDiff;
        isStationary = speed < STATIONARY_THRESHOLD;  // update value with redeclaring
    }
    
    const deadbandFilteredLatLng = applyDynamicDeadband(currentLatLng, lastAppliedLatLng || currentLatLng, isStationary);
    const smoothedLatLng = combinedFilter(deadbandFilteredLatLng);
    const lowPassFiltered = lowPassFilter(currentLatLng);
    console.log('Smoothed currentLatLng:', smoothedLatLng);
    
    lastAppliedLatLng = smoothedLatLng;
    lastUpdateTime = now;
    lastKnownLatLng = smoothedLatLng;
    
    userLocationMarker.setLatLng(smoothedLatLng);
    
    const predictedLat = smoothedLatLng.lat + lastEstimatedVel.lat * PREDICTION_TIME;
    const predictedLng = smoothedLatLng.lng + lastEstimatedVel.lng * PREDICTION_TIME;
    const predictedLatLng = L.latLng(predictedLat, predictedLng);
    
    const { closestLocation, closestDistance } = findClosestLocation(smoothedLatLng);
    
    updateDistanceBox(closestDistance);
    
    checkLocationTransition(closestLocation, closestDistance);
    
    updateAccuracyMode(closestDistance);
    
    // Check distance and recenter or reset map if user is not interacting
if (!userInteracting) {
    const mapBounds = map.getBounds();
    const isUserOnScreen = mapBounds.contains(smoothedLatLng);
    
    if (!lastCenteredLocation || !isUserOnScreen) {
        // First time centering or user is off screen
        map.setView(smoothedLatLng, map.getZoom(), { animate: false });
        lastCenteredLocation = smoothedLatLng;
    } else {
        const distance = map.distance(smoothedLatLng, lastCenteredLocation);
        if (distance > LONG_DISTANCE_THRESHOLD) {
            // Reset map view for long distances
            map.setView(smoothedLatLng, map.getZoom(), { animate: false });
            lastCenteredLocation = smoothedLatLng;
        } else if (distance > SHORT_DISTANCE_THRESHOLD) {
            // Recenter map for short distances
            map.panTo(smoothedLatLng, { animate: false });
            lastCenteredLocation = smoothedLatLng;
        }
}
return smoothedLatLng;
}
    let consolidatedInterval;
    const ANIMATION_DURATION = 500;

function startConsolidatedInterval() {
    consolidatedInterval = setInterval(() => {
        const updatedLocation = updateUserLocation();
        if (updatedLocation && !userInteracting) {
            ensureUserIconOnScreen();
        }
    }, UPDATE_INTERVAL);
}

    function predictFuturePosition(currentLatLng) {
        if (!currentLatLng || !lastEstimatedVel) {
            return currentLatLng;
        }

        const predictedLat = currentLatLng.lat + (lastEstimatedVel?.lat ?? 0) * PREDICTION_TIME;
        const predictedLng = currentLatLng.lng + (lastEstimatedVel?.lng ?? 0) * PREDICTION_TIME;

        return L.latLng(predictedLat, predictedLng);
    }

    function smoothPanMap(targetLatLng) {
        map.panTo(targetLatLng, {
            animate: true,
            duration: ANIMATION_DURATION,
            easeLinearity: 0.5
        });
    }

    startConsolidatedInterval();

    function stopConsolidatedInterval() {
        clearInterval(consolidatedInterval);
    }

    function findClosestLocation(currentLatLng) {
        let closestLocation = null;
        let closestDistance = Infinity;
        
        for (const location of locations) {
            const locationLatLng = L.latLng(location.lat, location.lng);
            const distance = fastDistanceApprox(currentLatLng, locationLatLng);
            const distanceFeet = Math.round(distance * 3.28084);
            
            if (distanceFeet < closestDistance) {
                closestDistance = distanceFeet;
                closestLocation = location;
            }
        }
        
        return { closestLocation, closestDistance };
    }

    function updateDistanceBox(distanceFeet) {
        const distanceBox = document.getElementById("distanceBox");
        if (distanceFeet < 5280) {
            distanceBox.innerHTML = `Nearest Site: ${distanceFeet} feet`;
        } else {
            const distanceMiles = (distanceFeet / 5280).toFixed(2);
            distanceBox.innerHTML = `Nearest Site: ${distanceMiles} miles`;
        }
    }

    function checkLocationTransition(closestLocation, distanceFeet) {
        console.log(`Distance: ${distanceFeet} feet, Threshold: ${thresholdFeet} feet`);
        
        const distanceBox = document.getElementById("distanceBox");
        if (!distanceBox) {
            console.error("distanceBox element not found!");
            return;
        }

        const latLngId = `${closestLocation.lat},${closestLocation.lng}`;
        const lastTransitionTime = parseInt(sessionStorage.getItem('lastTransitionTime') || '0');
        const lastVisitedLocation = sessionStorage.getItem('lastVisitedLocation');
        const timeSinceLastTransition = Date.now() - lastTransitionTime;
        const cooldownActiveForLastLocation = lastVisitedLocation === latLngId && timeSinceLastTransition < COOLDOWN;
        
        console.log(`Last visited location: ${lastVisitedLocation}`);
        console.log(`Current location: ${latLngId}`);
        console.log(`Cooldown active for last location: ${cooldownActiveForLastLocation}`);

        if (distanceFeet <= thresholdFeet) {
            console.log("Within threshold distance");
            if (cooldownActiveForLastLocation) {
                console.log("Cooldown active for this specific location");
                distanceBox.classList.add("within-cooldown");
                distanceBox.classList.remove("within-threshold");
                distanceBox.style.borderColor = 'orange';
                console.log("Added 'within-cooldown' class, removed 'within-threshold' class, set border to orange");
                
                const remainingCooldown = COOLDOWN - timeSinceLastTransition;
                setTimeout(() => {
                    checkLocationTransition(closestLocation, distanceFeet);
                }, remainingCooldown);
            } else {
                console.log("No cooldown active or different location, transition allowed");
                distanceBox.classList.add("within-threshold");
                distanceBox.classList.remove("within-cooldown");
                distanceBox.style.borderColor = 'green';
                console.log("Added 'within-threshold' class, removed 'within-cooldown' class, set border to green");
                
                console.log("Preparing for transition...");
                console.log(`Redirecting to location.html?id=${closestLocation.id} in ${INITIAL_DELAY} ms`);
                setTimeout(() => {
                    console.log("Timeout complete, redirecting now...");
                    sessionStorage.setItem("lastTransitionTime", Date.now().toString());
                    sessionStorage.setItem("lastVisitedLocation", latLngId);
                    window.location.href = `/location.html?id=${closestLocation.id}`;
                }, INITIAL_DELAY);
            }
        } else {
            console.log("Outside threshold distance");
            distanceBox.classList.remove("within-threshold", "within-cooldown");
            distanceBox.style.borderColor = 'red';
            console.log("Removed both 'within-threshold' and 'within-cooldown' classes, set border to red");
        }

        console.log(`Current classes on distanceBox: ${distanceBox.className}`);
        console.log(`Current border color: ${window.getComputedStyle(distanceBox).borderColor}`);
    }

    const ACCURACY_THRESHOLDS = {
        HIGH: 1000,
        MEDIUM: 2500,
        LOW: 5000
    };

    const ACCURACY_SETTINGS = {
        HIGH: { enableHighAccuracy: true, maximumAge: 0, timeout: 5000 },
        MEDIUM: { enableHighAccuracy: true, maximumAge: 10000, timeout: 10000 },
        LOW: { enableHighAccuracy: false, maximumAge: 30000, timeout: 27000 }
    };

    let currentAccuracyMode = 'LOW';

    function updateAccuracyMode(distanceFeet) {
        let newAccuracyMode;

        if (distanceFeet <= ACCURACY_THRESHOLDS.HIGH) {
            newAccuracyMode = 'HIGH';
        } else if (distanceFeet <= ACCURACY_THRESHOLDS.MEDIUM) {
            newAccuracyMode = 'MEDIUM';
        } else {
            newAccuracyMode = 'LOW';
        }

        if (newAccuracyMode !== currentAccuracyMode) {
            currentAccuracyMode = newAccuracyMode;
            restartLocationTracking(ACCURACY_SETTINGS[currentAccuracyMode]);
            console.log(`Switched to ${currentAccuracyMode} accuracy mode`);
        }
    }

    function restartLocationTracking(settings) {
        if (map) {
            map.stopLocate();
            map.locate({
                watch: true,
                ...settings
            });
        } else {
            console.warn('Map object not available for location tracking');
        }
    }
    
    map.on('drag', function() {
        userInteracted = true;
        resetUserInteraction();
    });

    map.on('zoomstart', function() {
        userInteracted = true;
        resetUserInteraction();
    });

    let lastRecenterTime = 0;
    const RECENTER_COOLDOWN = 25000;
    const SIGNIFICANT_MOVE_THRESHOLD = 0.00025;
    
    function resetUserInteraction() {
        clearTimeout(resetInteractionTimeout);
        resetInteractionTimeout = setTimeout(() => {
            userInteracted = false;
            const now = Date.now();
            
            if (currentLatLng && (now - lastRecenterTime > RECENTER_COOLDOWN)) {
                const current = map.getCenter();
                const distanceMoved = current.distanceTo(currentLatLng);
                
                if (distanceMoved > SIGNIFICANT_MOVE_THRESHOLD) {
                    const openPopup = document.querySelector('.leaflet-popup');
                    if (openPopup) {
                        openPopup.style.transition = 'opacity 0.5s';
                        openPopup.style.opacity = '0';
                        setTimeout(() => {
                            map.closePopup();
                        }, 500);
                    }
                    
                    map.panTo(currentLatLng, { animate: true, duration: 1 });
                    lastRecenterTime = now;
                }
                
                userLocationMarker.getElement().classList.add('centered-icon');
            }
            
            ensureUserIconOnScreen();
        }, 25000);
    }

    const PADDING_PERCENTAGE = 0.1;
    const CENTER_COOLDOWN = 60000;
    const EDGE_THRESHOLD = 0.2;
    const MAX_OFFSET = 0.00005;

    let lastCenterTime = 0;

    function ensureUserIconOnScreen() {
        if (!map || !userLocationMarker || userInteracted) return;

        const now = Date.now();
        const userPosition = userLocationMarker.getLatLng();
        const bounds = map.getBounds();
        const visibleBounds = bounds.pad(-PADDING_PERCENTAGE);

        const isNearEdge = !bounds.pad(-EDGE_THRESHOLD).contains(userPosition);

        if (!visibleBounds.contains(userPosition) || (isNearEdge && now - lastCenterTime >= CENTER_COOLDOWN)) {
            const currentCenter = map.getCenter();
            const currentZoom = map.getZoom();

            const randomLat = (Math.random() - 0.5) * MAX_OFFSET;
            const randomLng = (Math.random() - 0.5) * MAX_OFFSET;
            const newCenter = L.latLng(
                (userPosition.lat + currentCenter.lat) / 2 + randomLat,
                (userPosition.lng + currentCenter.lng) / 2 + randomLng
            );

            map.flyTo(newCenter, currentZoom, {
                duration: 0.75,
                easeLinearity: 0.5
            });

            lastCenterTime = now;
        }
    }

    map.on('drag zoomstart touchstart', resetUserInteraction);

    map.on('locationfound', function(e) {
        updateUserLocation(e);
    });

    distanceBox.innerHTML = "Initializing ...";

    map.on("locationfound", updateUserLocation);

    const markerIconClasses = {
        "history": "blue-marker",
        "hamm": "orange-marker",
        "gangster": "green-marker",
        "split": "split-marker",
        "wbl_split": "wbl_split-marker",
        "lake": "lake-marker",
        "capitol": "capitol-marker",
        "summit": "summit-marker",
        "northeast": "northeast-marker",
        "default": "blue-marker"
    };

    markers.clearLayers();

    for (let i = 0; i < locations.length; i++) {
        const location = locations[i];
        const locationLatLng = L.latLng(location.lat, location.lng);
        const markerId = location.lat + ',' + location.lng;
    
        var popupContent = `
          <div class="popup-content">
            <img src="${location.image}" alt="${location.name}">
            <h4><a href="${location.link}" target="_blank">${location.name}</a></h4>
            <a href="#" class="directions-link" data-lat="${location.lat}" data-lng="${location.lng}">
              <img src="/images/route_icon.png" alt="Google Maps" style="width: 40px; height: 40px; margin-bottom: -10px;">
              <div style="margin-top: -10px; margin-bottom: -10px; color: black; font-size: 16px"><p class="dir">Directions</p></div>
            </a>
          </div>
        `;

        function showModal(lat, lng) {
            var modal = document.getElementById("forwardingModal");
            var span = modal.querySelector(".close");
            var continueButton = document.getElementById("continueButton");
            var cancelButton = document.getElementById("cancelButton");

            modal.style.display = "block";

            span.onclick = function() {
                modal.style.display = "none";
                recenterAndClosePopup();
            }

            cancelButton.onclick = function() {
                modal.style.display = "none";
                recenterAndClosePopup();
            }

            continueButton.onclick = function() {
                window.open(`https://www.google.com/maps/dir/?api=1&destination=${lat},${lng}`, '_blank');
                modal.style.display = 'none';
                recenterAndClosePopup();
            }

            window.onclick = function(event) {
                if (event.target == modal) {
                    modal.style.display = "none";
                    recenterAndClosePopup();
                }
            }
        }

        function showDirectionsPopup(lat, lng) {
          showModal(lat, lng);
        }

        function addPopupEventListeners(popup) {
          popup.querySelectorAll('.directions-link').forEach(function(link) {
            link.addEventListener('click', function(event) {
              event.preventDefault();
              var lat = link.getAttribute('data-lat');
              var lng = link.getAttribute('data-lng');
              showDirectionsPopup(lat, lng);
            });
          });
        }

        function bindPopupToExistingMarker(marker, popupContent) {
          marker.bindPopup(popupContent).on('popupopen', function(e) {
            var popup = e.popup._contentNode;
            addPopupEventListeners(popup);
          });
        }

        const iconClass = markerIconClasses[location.tours] || markerIconClasses["default"];

        const newMarkerIcon = L.divIcon({
          className: `custom-pin-icon`,
          iconSize: [20, 20],
          iconAnchor: [10, 20],
          popupAnchor: [0, -20],
          html: `<div class="pin-head ${iconClass}"></div>`
        });
        
        var marker = L.marker(locationLatLng, { icon: newMarkerIcon });
        bindPopupToExistingMarker(marker, popupContent);

        if (!currentMarkers[markerId]) {
            newMarkers[markerId] = marker;
            markers.addLayer(marker);
        } else {
            newMarkers[markerId] = currentMarkers[markerId];
        }
    }

    map.addLayer(markers);

    currentMarkers = newMarkers;

    function recenterAndClosePopup() {
        if (userLocationMarker.getLatLng()) {
            map.setView(userLocationMarker.getLatLng(), 19);
            map.closePopup();
            userInteracted = false;
        }
    }

    function setExitCooldown() {
        const currentTime = Date.now();
        sessionStorage.setItem('lastTransitionTime', currentTime);
        const locationId = getUrlParameter('id');
        if (locationId) {
            const location = locations.find(loc => loc.id === locationId);
            if (location) {
                const latLngId = location.lat + "," + location.lng;
                sessionStorage.setItem('lastVisitedLocation', latLngId);
            }
        }
    }
    
    function getUrlParameter(name) {
        name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
        var regex = new RegExp('[\\?&]' + name + '=([^&#]*)');
        var results = regex.exec(location.search);
        return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
    }

    const FIRST_DELAY = 10000;
    const SECOND_DELAY = 20000;

    function onLocationError(e) {
        clearTimeout(locationTimeout);
        
        locationPopup.innerHTML = "Attempting to access your location...";
        
        setTimeout(() => {
            locationPopup.innerHTML = "Still trying to access your location. This may take a moment...";
            
            setTimeout(() => {
                locationPopup.innerHTML = "Unable to access your location. Please check that:<br>" +
                    "1. Location services are enabled on your device<br>" +
                    "2. You've granted permission to this site<br>" +
                    "3. You have a clear view of the sky<br>" +
                    "Refresh the page to try again.";
            }, SECOND_DELAY);
        }, FIRST_DELAY);
    }

    map.on("locationerror", onLocationError);

    let recenterTimeout;

    function recenterMap() {
        if (!userInteracted && userLocationMarker.getLatLng()) {
            map.setView(userLocationMarker.getLatLng(), map.getZoom());
        }
    }

    map.on("popupclose", function(event) {
        clearTimeout(recenterTimeout);
        recenterTimeout = setTimeout(() => {
            userInteracted = false;
            map.closePopup();
            recenterMap();
        }, 20000);
    });

    map.on("popupopen", function(event) {
        clearTimeout(recenterTimeout);
    });

    map.locate({
        watch: true,
        enableHighAccuracy: true,
        maximumAge: 25000,
    });

    const questionBtn = document.getElementById('help-button');
    const popup = document.getElementById('explanation-popup');

    questionBtn.addEventListener('click', () => {
        popup.classList.toggle('hidden');
    });

    const closeBtn = document.getElementById('close-popup');

    closeBtn.addEventListener('touchstart', closePopup);
    closeBtn.addEventListener('click', closePopup);

    function closePopup(event) {
        event.stopPropagation();
        popup.classList.add('hidden');
    }

    const recenterButton = document.getElementById("recenter-button");

    recenterButton.addEventListener("click", function () {
        if (userLocationMarker.getLatLng()) {
            const userLatLng = userLocationMarker.getLatLng();
            map.setView(userLatLng, 19);
            userInteracted = false;
            clearTimeout(recenterTimeout);
        } else {
            alert("User location not available. Please enable location services.");
        }
    });

    const exitButton = document.querySelector(".exit-button");

    exitButton.addEventListener("click", function () {
        sessionStorage.removeItem('lastTransitionTime');
        window.location.href = "/index.html";
    });
});

document.body.insertAdjacentHTML('beforeend', `
    <div id="forwardingModal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <p style="font-size: 20px">You will be redirected to Google Maps in a new window for directions. Do you want to continue?</p>
            <div class="button-container">
                <button id="continueButton">Continue</button>
                <button id="cancelButton">Cancel</button>
            </div>
        </div>
    </div>
`);
        </script> 

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-0M8KR45LDB"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);} 
        gtag('js', new Date());
        gtag('config', 'G-0M8KR45LDB');
    </script>
    
    </body> 
</html>
