<!DOCTYPE html> 
<html lang="en">
<head> 
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Minnesota Then | A Museum Without Walls</title>
    <link rel="shortcut icon" type="image/x-icon" href="https://www.mnthen.com/images/mnthenfav.ico">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css">
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css" />
    <link rel="stylesheet" href="https://www.mnthen.com/css/mainmap.css">
    <link rel="stylesheet" href="https://www.mnthen.com/css/mnthen_main_map2.css">

    <style>
        /* Base centering styles */
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        .at-location {
            border: 2px solid red !important;
            box-shadow: 0 0 8px rgba(255, 0, 0, 0.5);
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
        }
        
        /* Loading animation */
        .loading-animation {
            margin: 20px auto;
            text-align: center;
        }

        .dot {
            display: inline-block;
            width: 12px;
            height: 12px;
            margin: 0 5px;
            border-radius: 50%;
            background-color: #333;
            opacity: 0.6;
            animation: dotPulse 1.4s infinite ease-in-out;
        }

        .dot:nth-child(1) {
            animation-delay: 0s;
        }

        .dot:nth-child(2) {
            animation-delay: 0.2s;
        }

        .dot:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes dotPulse {
            0%, 80%, 100% { 
                transform: scale(0.8);
                opacity: 0.6;
            }
            40% { 
                transform: scale(1.2);
                opacity: 1;
            }
        }

        /* Minnesota facts container */
        .mn-facts-container {
            margin-top: 30px;
            width: 100%;
            max-width: 700px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 24px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .mn-facts-icon {
            flex-shrink: 0;
            margin-right: 18px;
            transform: scale(1.4);
        }

        .mn-facts {
            text-align: center;
            color: rgba(255, 255, 255, 1);
            flex-grow: 1;
        }

        .mn-facts p {
            margin: 0;
            font-size: 20px;
            line-height: 1.5;
            font-weight: 500;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        /* Location hunt container */
        .lochunt-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            max-width: 90%;
            max-height: 90vh;
            z-index: 1000;
            display: none;
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
        }

        /* Additional info container */
        .additional-info-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            max-width: 90%;
            z-index: 1001;
            display: none;
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
        }

        /* Navigation tips */
        .navigation-tips {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            max-width: 90%;
            z-index: 1002;
            display: none;
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
        }

        /* Modal styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1003;
            background: rgba(0,0,0,0.7);
            display: none;
        }

        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 12px;
            max-width: 90%;
            max-height: 90vh;
            overflow: auto;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .mn-facts-container {
                padding: 20px;
                margin-top: 25px;
                max-width: 90%;
            }
            
            .mn-facts p {
                font-size: 18px;
            }
        }

        @media (max-width: 480px) {
            .mn-facts-container {
                padding: 16px;
                margin-top: 20px;
                flex-direction: column;
                align-items: center;
                text-align: center;
            }
            
            .mn-facts-icon {
                margin-right: 0;
                margin-bottom: 15px;
                transform: scale(1.2);
            }
            
            .mn-facts p {
                font-size: 16px;
            }
        }
    </style>
</head>
<body>
    <div id="app-container">
        <!-- Preloader -->
        <div id="preloader">
            <div class="preloader-content">
                <img class="logo" src="https://www.mnthen.com/images/logo.webp" alt="Minnesota Then Logo">
                <h1>Minnesota Then</h1>
                <h2>Every step tells a story.</h2>
                <p>Loading the Museum Without Walls</p>
                <div class="progress-container">
                    <div class="progress-bar" id="preloaderProgress"></div>
                </div>
                
                <!-- Minnesota facts box -->
                <div class="mn-facts-container">
                    <div class="mn-facts-icon">
                        <svg viewBox="0 0 24 24" width="24" height="24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 22C17.5228 22 22 17.5228 22 12C22 6.47715 17.5228 2 12 2C6.47715 2 2 6.47715 2 12C2 17.5228 6.47715 22 12 22Z" stroke="white" stroke-width="2"/>
                            <path d="M12 8V12" stroke="white" stroke-width="2" stroke-linecap="round"/>
                            <circle cx="12" cy="16" r="1" fill="white"/>
                        </svg>
                    </div>
                    <div class="mn-facts" id="loadingFacts">
                        <p>Did you know? The Mississippi River begins its journey in Minnesota.</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Map -->
        <div id="map"></div>
        <div id="distanceBox">Initializing...</div>

        <!-- Location Hunt Container -->
        <div class="lochunt-container">
            <img id="locationImage" src="/placeholder.svg" alt="Location Image">
            <div class="lochunt-content">
                <div class="lochunt-info">
                    <h2 id="locationTitle" class="mb-2 text-primary"></h2>
                    <p id="locationCity" class="text-muted mb-1"></p>
                    <p id="locationCreator" class="text-muted mb-3"></p>
                </div>
                <div class="audio-player">
                    <div class="audio-progress">
                        <div class="progress">
                            <div id="progressBar" class="progress-bar" role="progressbar" style="width: 0%"></div>
                        </div>
                    </div>
                    <div class="audio-time">
                        <span id="currentTime">0:00</span>
                        <span id="duration">0:00</span>
                    </div>
                    <div class="audio-controls">
                        <button id="rewindBtn" class="audio-button"><i class="fas fa-backward"></i></button>
                        <button id="playPauseBtn" class="audio-button"><i class="fas fa-play"></i></button>
                        <button id="forwardBtn" class="audio-button"><i class="fas fa-forward"></i></button>
                    </div>
                    <audio id="locationAudio" src="/placeholder.svg"></audio>
                </div>
            </div>
        </div>
        
        <!-- Additional Info Container -->
        <div class="additional-info-container">
            <h3 class="mb-3 text-primary text-center">Did You Know?</h3>
            <p id="additionalInfo" class="mb-3 fs-6"></p>
            <div class="d-flex justify-content-center">
                <button id="continueButton" class="btn btn-primary">Continue</button>
            </div>
        </div>
        
        <!-- Map Buttons -->
        <div class="map-buttons">
            <button id="recenterButton" class="map-button"><i class="fas fa-crosshairs"></i></button>
            <button id="returnButton" class="map-button"><i class="fas fa-sign-out-alt"></i></button>
            <button id="tipsButton" class="map-button"><i class="fas fa-question-circle"></i></button>
        </div>

        <!-- Navigation Tips -->
        <div class="navigation-tips">
            <button class="close-button">&times;</button>
            <h3>Navigation Tips</h3>
            <ul>
                <li>Use the map to navigate to the marked locations.</li>
                <li>Tap the recenter button to focus on your current position.</li>
                <li>The distance box shows how far you are from the closest location.</li>
                <li>When you're within 20 feet of a location, you'll be able to interact with it.</li>
                <li>Listen to the audio information for each location.</li>
                <li>After the audio, you'll see additional information about the location.</li>
            </ul>
        </div>

        <!-- Summary Modal -->
        <div id="summaryModal" class="modal">
            <div class="modal-content">
                <p id="summaryContent"></p>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"></script>
    
    <script src="/locations_test.js?v=1.0.4"></script>

    <script>
        // Global variables
let map, userMarker, markerClusterGroup
let currentLocationIndex = 0
const visitedLocations = []
let gameLocations = []
let inactivityTimer
let isLocationHuntVisible = false
let isUserMoving = false;
let lastPosition = null
let positionBuffer = []
const MAX_BUFFER_SIZE = 30 // buffer size for smoother tracking
const DISTANCE_THRESHOLD = 20 // 20 feet to measure threshold distance to marker before opening location page.
const PROXIMITY_THRESHOLD = 45 // 45 feet threshold for zoom changes
let velocity = { lat: 0, lng: 0 }
let isMapInteracting = false
let followUser = true
let locationCooldowns = {}
let userIsInteracting = false
const preloadedImages = new Map() // Map to store preloaded images
const preloadedAudio = new Map() // Map to store preloaded audio
let currentSpeed = 0 // Current speed in meters per second
let lastZoomLevel = 17 // Default zoom level
let stationaryPositionHistory = [] // Array to store stationary positions for averaging
let deviceOrientation = null // Store device orientation data
let deviceMotion = null // Store device motion data
let orientationPermissionGranted = false
let geolocationSensor = null // Store GeolocationSensor instance
let isReturningFromExhibit = false // Flag to track if returning from exhibit

let isWithinProximity = false; // Flag to track if user is within proximity of a location

// Timestamps for throttling checks and changes
let lastProximityCheck = 0; // Initialize to 0 to allow first check
let lastZoomChangeTime = 0; // Initialize to 0 to allow first zoom change

const ZOOM_IN_THRESHOLD = PROXIMITY_THRESHOLD * 0.9; // 90% of threshold
const ZOOM_OUT_THRESHOLD = PROXIMITY_THRESHOLD * 1.1; // 110% of threshold

// State tracking variables
let isNearLocation = false;
let lastProximityDistance = Infinity;

//inacitivty timer recentering
let userIsManuallyNavigating = false;
let manualNavigationTimer = null;

let shouldCheckProximityThreshold = false;

let animationFrameId = null;

// Enhanced constants for better stabilization
const MICRO_MOVEMENT_THRESHOLD = 0.3 // Meters - threshold for detecting micro-movements (reduced for better stability)
const STATIONARY_ACCURACY_MULTIPLIER = 1.2 // Looser accuracy bounds to prevent false movement detection
const MAX_ACCEPTABLE_ACCURACY = 25 // meters - more lenient accuracy requirement
const STATIONARY_THRESHOLD = 2 // Number of consecutive stationary positions to consider user as stationary (reduced for faster stabilization)
const STATIONARY_TIME_THRESHOLD = 3000 // ms - time to consider user stationary (reduced)
const STATIONARY_CHECK_INTERVAL = 1000 // ms - interval to check if still stationary (reduced)
const VELOCITY_DECAY = 0.92 // Higher value for smoother velocity transitions
const MIN_DISTANCE_THRESHOLD = 1.0 // meters - minimum distance to consider movement (reduced)
const EXTENDED_DISTANCE_THRESHOLD = 80 // meters - distance to consider a significant position change
const UPDATE_INTERVAL = 50 // ms - more frequent updates for smoother movement
const STATIONARY_POSITION_HISTORY_SIZE = 15 // Number of positions to keep for stationary averaging (increased)
const STATIONARY_POSITION_WEIGHT_DECAY = 0.9 // Weight decay for older positions in stationary average (reduced)
const SUDDEN_MOVEMENT_THRESHOLD = 0.8 // meters - threshold for detecting sudden movements (reduced)
const POSITION_JUMP_THRESHOLD = 2.0 // meters - threshold for detecting position jumps (reduced)

// Background handling constants
const BACKGROUND_THRESHOLD = 15000 // ms - time to consider app was in background (reduced)
const INACTIVITY_TIMEOUT = 29000 // ms - time to consider user inactive (reduced)

// Kalman filter parameters - optimized for better movement tracking
const KALMAN_PROCESS_NOISE = 0.00001
const KALMAN_MEASUREMENT_NOISE_BASE = 0.1
const KALMAN_STATIONARY_NOISE = 0.000001

// Animation parameters
const ANIMATION_DURATION = 200 // ms - reduced duration of position animation for more responsive transitions
const HEADING_SMOOTHING = 0.85 // Reduced heading smoothing factor for more responsive direction changes

// Zoom level parameters
const MAX_ZOOM_LEVEL = 17 // Maximum zoom level (stationary)
const MIN_ZOOM_LEVEL = 13 // Minimum zoom level (high speed)
const WALKING_ZOOM_LEVEL = 17 // Zoom level for walking speed
const WALKING_SPEED_THRESHOLD = 1.5 // m/s - threshold for walking speed
const RUNNING_SPEED_THRESHOLD = 4.0 // m/s - threshold for running speed
const DRIVING_SPEED_THRESHOLD = 10.0 // m/s - threshold for driving speed
const ZOOM_TRANSITION_DURATION = 0.5 // seconds - reduced duration of zoom transition for more responsive zooming

// Motion detection parameters
const MOTION_THRESHOLD = 0.8 // Reduced threshold for detecting significant motion
const MOTION_SAMPLE_SIZE = 15 // Increased number of motion samples to keep
const MOTION_CHECK_INTERVAL = 200 // ms - reduced interval to check motion for more responsive detection

// Edge recenter parameters - optimized for better edge recentering
const EDGE_THRESHOLD_PERCENTAGE = 0.25 // Percentage of viewport to trigger recenter (reduced)
const CRITICAL_EDGE_THRESHOLD = 0.125 // Critical threshold for emergency recenter (reduced)
const RECENTER_COOLDOWN = 1500 // ms - minimum time between recenters (reduced)

// Speed accuracy parameters
const SPEED_ACCURACY_THRESHOLD = 5.0; // 5 m/s accuracy is reasonable for most GPS systems

// State variables
let lastUpdateTime = null
let lastVelocity = { lat: 0, lng: 0 }
let isStationary = false
let stationaryStartTime = null
let stationaryCheckTimeout = null
let lastUpdateTimestamp = null
let lastHiddenTime = 0
let lastKnownPosition = null
let lastVisitedLocationId = null
let stationaryCount = 0
let lastSmoothedPosition = null
let lastRecenterTime = Date.now()
let retryCount = 0
const stationaryBuffer = []
const stationaryPosition = null
let lastStationaryPosition = null // Last stable position when stationary
const motionSamples = [] // Array to store motion samples
const lastMotionTimestamp = 0 // Last time motion was detected
let deviceStationaryTime = 0 // Time device has been stationary based on motion sensors
let renderTimestamp = null // Last render timestamp
const positionUpdateQueue = [] // Queue for position updates to be processed
let lastHeadingValue = null // Last heading value
const headingBuffer = [] // Buffer for heading values
let isFirstPositionUpdate = true // Flag for first position update
let lastRenderPosition = null // Last rendered position

const DEFAULT_PARAMS = {
  processNoise: 0.03,
  measurementNoise: 1.0,
  adaptivity: 0.01
};
        
const positionInterpolator = {
  currentAnimation: null,
  startTime: null,
  from: null,
  to: null,
  duration: 0,
  
  start: function(from, to, duration) {
    // Cancel any existing animation
    if (this.currentAnimation) {
      cancelAnimationFrame(this.currentAnimation);
    }
    
    // Store animation parameters
    this.startTime = performance.now();
    this.from = from;
    this.to = to;
    this.duration = duration;
    
    // Start animation
    this.update();
  },
  
  update: function() {
    if (!this.startTime) return;
    
    const currentTime = performance.now();
    const elapsed = currentTime - this.startTime;
    const progress = Math.min(elapsed / this.duration, 1);
    
    // Use easing for smoother motion (ease-out)
    const eased = 1 - Math.pow(1 - progress, 3);
    
    // Interpolate between positions
    const currentPosition = {
      lat: this.from.lat + (this.to.lat - this.from.lat) * eased,
      lng: this.from.lng + (this.to.lng - this.from.lng) * eased
    };
    
    // Update marker position
    updateUserMarkerPosition(currentPosition);
    lastRenderPosition = currentPosition;
    
    // Continue animation if not complete
    if (progress < 1) {
      this.currentAnimation = requestAnimationFrame(() => this.update());
    } else {
      this.currentAnimation = null;
      this.startTime = null;
    }
  },
  
  cancel: function() {
    if (this.currentAnimation) {
      cancelAnimationFrame(this.currentAnimation);
      this.currentAnimation = null;
      this.startTime = null;
    }
  },
  
  isInterpolating: function() {
    return this.currentAnimation !== null;
  }
};
      
let mapViewportWidth = 0 // Store map viewport width
let mapViewportHeight = 0 // Store map viewport height
let lastMapCenter = null // Last map center position
let lastMapZoom = null // Last map zoom level
let edgeRecenterInProgress = false // Flag to track edge recentering
const pendingDomUpdates = new Map() // Map to store pending DOM updates
let usingGeolocationSensorAPI = false // Flag to track which geolocation API is being used
const lockStationaryPosition = false // Flag to lock stationary position and prevent jitter
let positionHistory = [] // Array to store recent position history for jump detection
const lastPositionTimestamp = 0 // Last time a position was processed
let suddenMovementCount = 0 // Counter for consecutive sudden movements
let isJumpDetected = false // Flag to track if a position jump is detected
let stationaryPositionLocked = false // Flag to indicate if stationary position is locked
let stationaryPositionLockTime = 0 // Time when stationary position was locked
let lastValidPosition = null // Last valid position before a jump
let stationaryLockTimeout = null // Timeout for locking stationary position
const lastAccuracy = Number.POSITIVE_INFINITY // Last position accuracy
const isAccuracyImproving = false // Flag to track if accuracy is improving
const highFrequencyUpdateDuration = 5000 // ms - duration of high frequency updates
const isUsingHighAccuracy = true // Flag to track if high accuracy is being used
const maxHighAccuracyFailures = 3 // Maximum number of high accuracy failures before fallback
const highAccuracyTimeout = 10000 // ms - timeout for high accuracy updates
let isWatchPositionActive = false // Flag to track if watchPosition is active
let watchPositionId = null // ID for watchPosition
const watchPositionUpdateInterval = 1000 // ms - interval for watchPosition updates
const isUsingDeviceMotionForHeading = false // Flag to track if device motion is being used for heading
const lastCompassHeading = null // Last compass heading
const compassHeadingBuffer = [] // Buffer for compass heading values
const compassHeadingBufferSize = 5 // Size of compass heading buffer
const isCompassCalibrated = false // Flag to track if compass is calibrated
const compassCalibrationTimeout = null // Timeout for compass calibration
const compassCalibrationDuration = 5000 // ms - duration of compass calibration
const isUsingGyroscopeForOrientation = false // Flag to track if gyroscope is being used for orientation
const gyroscopeData = null // Gyroscope data
const gyroscopeUpdateInterval = 100 // ms - interval for gyroscope updates
const isDeviceStationaryByMotion = false // Flag to track if device is stationary based on motion sensors
const deviceStationaryByMotionThreshold = 2000 // ms - threshold for device to be considered stationary by motion
        
// Utility function to calculate distance between two coordinates
function calculateDistance(pos1, pos2) {
  if (
    !pos1 ||
    !pos2 ||
    typeof pos1.lat !== "number" ||
    typeof pos1.lng !== "number" ||
    typeof pos2.lat !== "number" ||
    typeof pos2.lng !== "number"
  ) {
    return Number.POSITIVE_INFINITY
  }

  // Haversine formula for more accurate distance calculation
  const R = 6371000 // Earth radius in meters
  const lat1 = (pos1.lat * Math.PI) / 180
  const lat2 = (pos2.lat * Math.PI) / 180
  const deltaLat = ((pos2.lat - pos1.lat) * Math.PI) / 180
  const deltaLng = ((pos2.lng - pos1.lng) * Math.PI) / 180

  const a =
    Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) +
    Math.cos(lat1) * Math.cos(lat2) * Math.sin(deltaLng / 2) * Math.sin(deltaLng / 2)
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))

  return R * c
}

// Enhanced Kalman Filter implementation
class KalmanFilter {
  constructor() {
    // State vector [x, y, vx, vy]
    this.x = 0
    this.y = 0
    this.vx = 0
    this.vy = 0

    // Error covariance matrix
    this.P = [
      [100, 0, 0, 0], // Initial high uncertainty
      [0, 100, 0, 0],
      [0, 0, 10, 0],
      [0, 0, 0, 10],
    ]

    // Process noise
    this.Q = KALMAN_PROCESS_NOISE

    // Measurement noise (will be adjusted based on GPS accuracy)
    this.R = KALMAN_MEASUREMENT_NOISE_BASE

    // Time delta
    this.dt = 1.0

    // Initialized flag
    this.initialized = false

    // Heading and accuracy tracking
    this.lastHeading = null
    this.headingConfidence = 0

    // Stationary mode flag
    this.stationaryMode = false
    this.stationaryStartTime = 0

    // Last timestamp
    this.lastTimestamp = null

    // Adaptive noise parameters
    this.adaptiveNoiseMin = 0.0002
    this.adaptiveNoiseMax = 0.002
    this.adaptiveNoiseFactor = 1.0

    // Position history for jitter detection
    this.positionHistory = []
    this.maxPositionHistory = 10
    this.jitterThreshold = 0.35 // meters
    this.jitterCount = 0

    // Stationary lock
    this.stationaryLocked = false
    this.stationaryPosition = null

    // Heading smoothing
    this.headingSmoothingFactor = 0.8
    this.headingBuffer = []
    this.headingBufferSize = 7

    // Velocity smoothing
    this.velocitySmoothingFactor = 0.8
    this.velocityBuffer = []
    this.velocityBufferSize = 7

    // Accuracy-based adaptation
    this.accuracyBuffer = []
    this.accuracyBufferSize = 7
    this.lastAccuracy = Number.POSITIVE_INFINITY
    this.isAccuracyImproving = false

    // Motion-based adaptation
    this.motionDetected = false
    this.motionConfidence = 0

    // Adaptive parameters based on device capabilities
    this.deviceCapabilitiesSet = false
    this.deviceSupportsHighAccuracy = true
    this.deviceSupportsMotionSensors = true
    this.deviceSupportsOrientationSensors = true

    // Innovation tracking to detect filter divergence
    this.innovationBuffer = []
    this.innovationBufferSize = 10
    this.innovationThreshold = 3.0 // standard deviations

    // GNSS receiver type (GPS, GLONASS, Galileo, etc)
    this.receiverType = "GPS"

    // Environment type (urban, rural, indoor, etc)
    this.environmentType = "mixed"
  }

  // Set device capabilities
  setDeviceCapabilities(highAccuracy, motionSensors, orientationSensors) {
    this.deviceCapabilitiesSet = true
    this.deviceSupportsHighAccuracy = highAccuracy
    this.deviceSupportsMotionSensors = motionSensors
    this.deviceSupportsOrientationSensors = orientationSensors

    // Adjust parameters based on device capabilities
    if (!highAccuracy) {
      this.adaptiveNoiseMin *= 1.5
      this.adaptiveNoiseMax *= 1.5
      this.jitterThreshold *= 1.5
    }

    if (!motionSensors) {
      this.adaptiveNoiseMin *= 1.2
      this.adaptiveNoiseMax *= 1.2
    }

    if (!orientationSensors) {
      this.headingSmoothingFactor = 0.9
    }

    return this
  }

  // Set the type of GNSS receiver
  setReceiverType(type) {
    this.receiverType = type

    // Adjust parameters based on receiver type
    switch (type.toUpperCase()) {
      case "GPS_GLONASS":
      case "MULTI_CONSTELLATION":
        this.adaptiveNoiseMin *= 0.8
        this.adaptiveNoiseMax *= 0.8
        break
      case "BASIC_GPS":
        this.adaptiveNoiseMin *= 1.2
        this.adaptiveNoiseMax *= 1.2
        break
      case "HIGH_PRECISION":
        this.adaptiveNoiseMin *= 0.5
        this.adaptiveNoiseMax *= 0.5
        break
    }

    return this
  }

  // Set the type of environment
  setEnvironmentType(type) {
    this.environmentType = type

    // Adjust parameters based on environment type
    switch (type.toLowerCase()) {
      case "urban":
        this.adaptiveNoiseMin *= 1.3
        this.adaptiveNoiseMax *= 1.3
        this.jitterThreshold *= 0.9
        break
      case "rural":
        this.adaptiveNoiseMin *= 0.8
        this.adaptiveNoiseMax *= 0.8
        this.jitterThreshold *= 1.2
        break
      case "indoor":
        this.adaptiveNoiseMin *= 1.5
        this.adaptiveNoiseMax *= 1.5
        this.jitterThreshold *= 0.7
        break
    }

    return this
  }

  // Initialize the filter with first position
  reset(position) {
    if (!position || typeof position.lat !== "number" || typeof position.lng !== "number") {
      console.error("Invalid position for Kalman filter reset")
      return
    }

    this.x = position.lng
    this.y = position.lat
    this.vx = 0
    this.vy = 0

    // Reset covariance matrix with high initial uncertainty
    this.P = [
      [100, 0, 0, 0],
      [0, 100, 0, 0],
      [0, 0, 10, 0],
      [0, 0, 0, 10],
    ]

    this.initialized = true
    this.lastHeading = position.heading || null
    this.headingConfidence = 0
    this.stationaryMode = false
    this.lastTimestamp = position.timestamp || Date.now()
    this.adaptiveNoiseFactor = 1.0
    this.positionHistory = []
    this.jitterCount = 0
    this.stationaryLocked = false
    this.stationaryPosition = null
    this.headingBuffer = []
    this.velocityBuffer = []
    this.accuracyBuffer = []
    this.lastAccuracy = position.accuracy || Number.POSITIVE_INFINITY
    this.isAccuracyImproving = false
    this.motionDetected = false
    this.motionConfidence = 0
    this.innovationBuffer = []

    return this
  }

  // Set stationary mode
  setStationaryMode(isStationary) {
    this.stationaryMode = isStationary

    // When entering stationary mode, reduce velocity to zero
    if (isStationary) {
      this.vx = 0
      this.vy = 0
      this.stationaryStartTime = Date.now()

      // Reduce process noise for stationary mode
      this.Q = KALMAN_STATIONARY_NOISE
      this.adaptiveNoiseFactor = 0.03
    } else {
      // Reset to normal process noise when moving
      this.Q = KALMAN_PROCESS_NOISE
      this.adaptiveNoiseFactor = 1.0
      this.stationaryLocked = false
      this.stationaryPosition = null
    }

    return this
  }

  // Lock stationary position
  lockStationaryPosition(position) {
    if (!this.stationaryMode) return this

    this.stationaryLocked = true
    this.stationaryPosition = position
    console.log("Kalman filter: Stationary position locked")

    return this
  }

  // Update accuracy buffer and check if accuracy is improving
  updateAccuracyBuffer(accuracy) {
    if (isNaN(accuracy) || accuracy <= 0) {
      accuracy = this.lastAccuracy || 20
    }

    this.accuracyBuffer.push(accuracy)
    while (this.accuracyBuffer.length > this.accuracyBufferSize) {
      this.accuracyBuffer.shift()
    }

    if (this.accuracyBuffer.length >= 3) {
      const avgRecent =
        (this.accuracyBuffer[this.accuracyBuffer.length - 1] + this.accuracyBuffer[this.accuracyBuffer.length - 2]) / 2
      const avgOlder =
        (this.accuracyBuffer[0] + (this.accuracyBuffer.length > 1 ? this.accuracyBuffer[1] : this.accuracyBuffer[0])) /
        2

      this.isAccuracyImproving = avgRecent < avgOlder
    }

    this.lastAccuracy = accuracy

    return this
  }

  // Track innovation to detect filter divergence
  updateInnovationBuffer(innovation) {
    this.innovationBuffer.push(innovation)
    while (this.innovationBuffer.length > this.innovationBufferSize) {
      this.innovationBuffer.shift()
    }

    if (this.innovationBuffer.length >= 5) {
      // Calculate mean and standard deviation of innovations
      const sum = this.innovationBuffer.reduce((acc, val) => acc + val, 0)
      const mean = sum / this.innovationBuffer.length

      const sumSquaredDiff = this.innovationBuffer.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0)
      const stdDev = Math.sqrt(sumSquaredDiff / this.innovationBuffer.length)

      // If innovation is consistently large, the filter might be diverging
      const latestInnovation = this.innovationBuffer[this.innovationBuffer.length - 1]
      if (Math.abs(latestInnovation - mean) > this.innovationThreshold * stdDev) {
        // Increase uncertainty to force filter to trust measurements more
        for (let i = 0; i < 4; i++) {
          this.P[i][i] *= 2.0
        }
      }
    }

    return this
  }

  // Detect jitter in position updates
  detectJitter(newPosition) {
    if (this.positionHistory.length === 0) {
      this.positionHistory.push(newPosition)
      return false
    }

    const lastPos = this.positionHistory[this.positionHistory.length - 1]
    const distance = calculateDistance(lastPos, newPosition)

    // Add to history
    this.positionHistory.push(newPosition)
    while (this.positionHistory.length > this.maxPositionHistory) {
      this.positionHistory.shift()
    }

    // Check for rapid back-and-forth movement (jitter)
    if (this.positionHistory.length >= 3 && this.stationaryMode) {
      const pos1 = this.positionHistory[this.positionHistory.length - 3]
      const pos2 = this.positionHistory[this.positionHistory.length - 2]
      const pos3 = this.positionHistory[this.positionHistory.length - 1]

      const dist1 = calculateDistance(pos1, pos2)
      const dist2 = calculateDistance(pos2, pos3)

      // If moving back and forth in small distances
      if (
        dist1 < this.jitterThreshold &&
        dist2 < this.jitterThreshold &&
        Math.sign(pos3.lat - pos2.lat) !== Math.sign(pos2.lat - pos1.lat) &&
        Math.sign(pos3.lng - pos2.lng) !== Math.sign(pos2.lng - pos1.lng)
      ) {
        this.jitterCount++
        return this.jitterCount > 1
      }
    }

    // Reset jitter count if no jitter detected
    if (distance > this.jitterThreshold) {
      this.jitterCount = 0
    }

    return false
  }

  // Smooth heading values
  smoothHeading(newHeading) {
    if (newHeading === null || newHeading === undefined || isNaN(newHeading)) {
      return this.lastHeading
    }

    // Normalize to 0-360
    newHeading = ((newHeading % 360) + 360) % 360

    // Add to heading buffer
    this.headingBuffer.push(newHeading)
    while (this.headingBuffer.length > this.headingBufferSize) {
      this.headingBuffer.shift()
    }

    if (this.headingBuffer.length < 2) {
      return newHeading
    }

    // Use median filter to remove outliers
    if (this.headingBuffer.length >= 3) {
      const sortedHeadings = [...this.headingBuffer].sort((a, b) => a - b)
      const medianHeading = sortedHeadings[Math.floor(sortedHeadings.length / 2)]

      // If new heading is very different from median, it might be an outlier
      const headingDiff = Math.abs(((newHeading - medianHeading + 180) % 360) - 180)
      if (headingDiff > 45 && this.headingConfidence > 0.5) {
        // Use median instead of potentially erroneous new heading
        newHeading = medianHeading
      }
    }

    // If we have a previous heading, smooth the transition
    if (this.lastHeading !== null) {
      // Normalize headings to 0-360
      const normalizedCurrent = ((newHeading % 360) + 360) % 360
      const normalizedLast = ((this.lastHeading % 360) + 360) % 360

      // Calculate the smallest angle between the two headings
      let diff = normalizedCurrent - normalizedLast
      if (diff > 180) diff -= 360
      if (diff < -180) diff += 360

      // Apply adaptive smoothing based on motion and stationary state
      let headingWeight = this.headingSmoothingFactor
      if (this.stationaryMode) {
        headingWeight = 0.05 // Very smooth when stationary
      } else if (this.motionDetected) {
        headingWeight = Math.min(0.4, headingWeight * (1 + this.motionConfidence)) // More responsive when motion detected
      }

      // Apply smoothing
      const smoothedHeading = normalizedLast + diff * (1 - headingWeight)

      // Normalize back to 0-360
      return ((smoothedHeading % 360) + 360) % 360
    }

    return newHeading
  }

  // Smooth velocity values
  smoothVelocity(vx, vy) {
    const speed = Math.sqrt(vx * vx + vy * vy)

    this.velocityBuffer.push(speed)
    while (this.velocityBuffer.length > this.velocityBufferSize) {
      this.velocityBuffer.shift()
    }

    if (this.velocityBuffer.length < 2) {
      return { vx, vy }
    }

    // Calculate median velocity to filter outliers
    if (this.velocityBuffer.length >= 3) {
      const sortedVelocities = [...this.velocityBuffer].sort((a, b) => a - b)
      const medianVelocity = sortedVelocities[Math.floor(sortedVelocities.length / 2)]

      const currentVelocity = speed

      // If current velocity is drastically different from median, scale it
      if (currentVelocity > medianVelocity * 2) {
        const scale = (medianVelocity * 2) / currentVelocity
        vx *= scale
        vy *= scale
      }
    }

    return { vx, vy }
  }

  // Adjust process noise based on accuracy, motion, and device capabilities
  adjustProcessNoise(accuracy, motionDetected) {
    // Update accuracy buffer and check if accuracy is improving
    this.updateAccuracyBuffer(accuracy)

    // Update motion detection state
    this.motionDetected = motionDetected
    if (motionDetected) {
      this.motionConfidence = Math.min(1.0, this.motionConfidence + 0.1)
    } else {
      this.motionConfidence = Math.max(0.0, this.motionConfidence - 0.05)
    }

    // Base noise level depends on GPS accuracy
    let noiseLevel =
      this.adaptiveNoiseMin + (this.adaptiveNoiseMax - this.adaptiveNoiseMin) * Math.min(1.0, accuracy / 30.0)

    // Reduce noise when stationary
    if (this.stationaryMode) {
      noiseLevel *= 0.03
    }

    // Increase noise when motion is detected
    if (this.motionDetected && !this.stationaryMode) {
      noiseLevel *= 1.0 + this.motionConfidence
    }

    // Adjust based on accuracy trend
    if (this.isAccuracyImproving) {
      noiseLevel *= 0.9
    } else {
      noiseLevel *= 1.1
    }

    // Apply adaptive factor
    noiseLevel *= this.adaptiveNoiseFactor

    // Set process noise
    this.Q = noiseLevel

    return this
  }

  // Update the filter with new measurement
  update(position, motionDetected = false) {
    if (!this.initialized) {
      this.reset(position)
      return position
    }

    if (!position || typeof position.lat !== "number" || typeof position.lng !== "number") {
      console.warn("Invalid position input to Kalman filter")
      return {
        lat: this.y,
        lng: this.x,
        accuracy: position?.accuracy || 20,
        heading: this.lastHeading,
        timestamp: position?.timestamp || Date.now(),
      }
    }

    // If we're in stationary mode and have a locked position, return the locked position
    if (this.stationaryMode && this.stationaryLocked && this.stationaryPosition) {
      return {
        lat: this.stationaryPosition.lat,
        lng: this.stationaryPosition.lng,
        accuracy: position.accuracy,
        heading: this.smoothHeading(position.heading),
        timestamp: position.timestamp,
        speedMPS: 0,
      }
    }

    // Calculate time delta
    const timestamp = position.timestamp || Date.now()
    if (this.lastTimestamp) {
      this.dt = Math.min(Math.max((timestamp - this.lastTimestamp) / 1000, 0.01), 1.0)
    }
    this.lastTimestamp = timestamp

    // Check for jitter
    const isJittering = this.detectJitter(position)

    // Adjust measurement noise based on GPS accuracy and jitter
    const accuracy = position.accuracy || 20
    this.R = Math.max(KALMAN_MEASUREMENT_NOISE_BASE, accuracy / 5)

    // If in stationary mode, increase measurement noise to reduce jitter
    if (this.stationaryMode) {
      this.R *= 5.0
    }

    // If jittering is detected, increase measurement noise significantly
    if (isJittering) {
      this.R *= 10.0
    }

    // Adjust process noise based on accuracy and motion
    this.adjustProcessNoise(accuracy, motionDetected)

    // State transition matrix
    const F = [
      [1, 0, this.dt, 0],
      [0, 1, 0, this.dt],
      [0, 0, 1, 0],
      [0, 0, 0, 1],
    ]

    // Predict step
    // x = F * x
    const predictedX = this.x + this.dt * this.vx
    const predictedY = this.y + this.dt * this.vy
    const predictedVx = this.stationaryMode ? 0 : this.vx
    const predictedVy = this.stationaryMode ? 0 : this.vy

    // P = F * P * F' + Q
    const Q = [
      [(this.Q * this.dt * this.dt * this.dt * this.dt) / 4, 0, (this.Q * this.dt * this.dt * this.dt) / 2, 0],
      [0, (this.Q * this.dt * this.dt * this.dt * this.dt) / 4, 0, (this.Q * this.dt * this.dt * this.dt) / 2],
      [(this.Q * this.dt * this.dt * this.dt) / 2, 0, this.Q * this.dt * this.dt, 0],
      [0, (this.Q * this.dt * this.dt * this.dt) / 2, 0, this.Q * this.dt * this.dt],
    ]

    // Matrix multiplication F * P
    const FP = [
      [
        this.P[0][0] + this.dt * this.P[2][0],
        this.P[0][1] + this.dt * this.P[2][1],
        this.P[0][2] + this.dt * this.P[2][2],
        this.P[0][3] + this.dt * this.P[2][3],
      ],
      [
        this.P[1][0] + this.dt * this.P[3][0],
        this.P[1][1] + this.dt * this.P[3][1],
        this.P[1][2] + this.dt * this.P[3][2],
        this.P[1][3] + this.dt * this.P[3][3],
      ],
      [this.P[2][0], this.P[2][1], this.P[2][2], this.P[2][3]],
      [this.P[3][0], this.P[3][1], this.P[3][2], this.P[3][3]],
    ]

    // Matrix multiplication FP * F'
    const predictedP = [
      [
        FP[0][0] + this.dt * FP[0][2] + Q[0][0],
        FP[0][1] + this.dt * FP[0][3] + Q[0][1],
        FP[0][2] + Q[0][2],
        FP[0][3] + Q[0][3],
      ],
      [
        FP[1][0] + this.dt * FP[1][2] + Q[1][0],
        FP[1][1] + this.dt * FP[1][3] + Q[1][1],
        FP[1][2] + Q[1][2],
        FP[1][3] + Q[1][3],
      ],
      [FP[2][0] + Q[2][0], FP[2][1] + Q[2][1], FP[2][2] + Q[2][2], FP[2][3] + Q[2][3]],
      [FP[3][0] + Q[3][0], FP[3][1] + Q[3][1], FP[3][2] + Q[3][2], FP[3][3] + Q[3][3]],
    ]

    // Update step
    // y = z - H * x
    const measurementResidualX = position.lng - predictedX
    const measurementResidualY = position.lat - predictedY

    // Track innovation to detect filter divergence
    const innovation = Math.sqrt(
      measurementResidualX * measurementResidualX + measurementResidualY * measurementResidualY,
    )
    this.updateInnovationBuffer(innovation)

    // S = H * P * H' + R
    const S = [
      [predictedP[0][0] + this.R, predictedP[0][1]],
      [predictedP[1][0], predictedP[1][1] + this.R],
    ]

    // Calculate determinant of S
    const detS = S[0][0] * S[1][1] - S[0][1] * S[1][0]

    // Calculate inverse of S
    const invS = [
      [S[1][1] / detS, -S[0][1] / detS],
      [-S[1][0] / detS, S[0][0] / detS],
    ]

    // K = P * H' * inv(S)
    const K = [
      [
        predictedP[0][0] * invS[0][0] + predictedP[0][1] * invS[1][0],
        predictedP[0][0] * invS[0][1] + predictedP[0][1] * invS[1][1],
      ],
      [
        predictedP[1][0] * invS[0][0] + predictedP[1][1] * invS[1][0],
        predictedP[1][0] * invS[0][1] + predictedP[1][1] * invS[1][1],
      ],
      [
        predictedP[2][0] * invS[0][0] + predictedP[2][1] * invS[1][0],
        predictedP[2][0] * invS[0][1] + predictedP[2][1] * invS[1][1],
      ],
      [
        predictedP[3][0] * invS[0][0] + predictedP[3][1] * invS[1][0],
        predictedP[3][0] * invS[0][1] + predictedP[3][1] * invS[1][1],
      ],
    ]

    // x = x + K * y
    this.x = predictedX + K[0][0] * measurementResidualX + K[0][1] * measurementResidualY
    this.y = predictedY + K[1][0] * measurementResidualX + K[1][1] * measurementResidualY

    // In stationary mode, keep velocity at zero
    if (this.stationaryMode) {
      this.vx = 0
      this.vy = 0
    } else {
      this.vx = predictedVx + K[2][0] * measurementResidualX + K[2][1] * measurementResidualY
      this.vy = predictedVy + K[3][0] * measurementResidualX + K[3][1] * measurementResidualY

      // Smooth velocity
      const smoothedVelocity = this.smoothVelocity(this.vx, this.vy)
      this.vx = smoothedVelocity.vx
      this.vy = smoothedVelocity.vy
    }

    // P = (I - K * H) * P
    this.P = [
      [
        predictedP[0][0] - (K[0][0] * predictedP[0][0] + K[0][1] * predictedP[1][0]),
        predictedP[0][1] - (K[0][0] * predictedP[0][1] + K[0][1] * predictedP[1][1]),
        predictedP[0][2] - (K[0][0] * predictedP[0][2] + K[0][1] * predictedP[1][2]),
        predictedP[0][3] - (K[0][0] * predictedP[0][3] + K[0][1] * predictedP[1][3]),
      ],
      [
        predictedP[1][0] - (K[1][0] * predictedP[0][0] + K[1][1] * predictedP[1][0]),
        predictedP[1][1] - (K[1][0] * predictedP[0][1] + K[1][1] * predictedP[1][1]),
        predictedP[1][2] - (K[1][0] * predictedP[0][2] + K[1][1] * predictedP[1][2]),
        predictedP[1][3] - (K[1][0] * predictedP[0][3] + K[1][1] * predictedP[1][3]),
      ],
      [
        predictedP[2][0] - (K[2][0] * predictedP[0][0] + K[2][1] * predictedP[1][0]),
        predictedP[2][1] - (K[2][0] * predictedP[0][1] + K[2][1] * predictedP[1][1]),
        predictedP[2][2] - (K[2][0] * predictedP[0][2] + K[2][1] * predictedP[1][2]),
        predictedP[2][3] - (K[2][0] * predictedP[0][3] + K[2][1] * predictedP[1][3]),
      ],
      [
        predictedP[3][0] - (K[3][0] * predictedP[0][0] + K[3][1] * predictedP[1][0]),
        predictedP[3][1] - (K[3][0] * predictedP[0][1] + K[3][1] * predictedP[1][1]),
        predictedP[3][2] - (K[3][0] * predictedP[0][2] + K[3][1] * predictedP[1][2]),
        predictedP[3][3] - (K[3][0] * predictedP[0][3] + K[3][1] * predictedP[1][3]),
      ],
    ]

    // Process heading data
    const smoothedHeading = this.smoothHeading(position.heading)
    this.lastHeading = smoothedHeading

    // Calculate speed from velocity components
    const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy)

    // Create filtered position
    const filteredPosition = {
      lat: this.y,
      lng: this.x,
      accuracy: position.accuracy,
      heading: smoothedHeading,
      timestamp: position.timestamp,
      speedMPS: this.stationaryMode ? 0 : speed * 111000, // Convert from degrees/second to meters/second (approximate)
    }

    // If we're in stationary mode and don't have a locked position yet,
    // check if we should lock the position
    if (this.stationaryMode && !this.stationaryLocked && this.stationaryStartTime) {
      // If we've been stationary for a while, lock the position
      if (Date.now() - this.stationaryStartTime > 2000) {
        this.lockStationaryPosition(filteredPosition)
      }
    }

    return filteredPosition
  }
}

// Position interpolator for smooth transitions
class PositionInterpolator {
  constructor() {
    this.startPosition = null
    this.targetPosition = null
    this.startTime = null
    this.duration = 0
    this.isActive = false
    this.lastInterpolatedPosition = null
    this.interpolationMethod = "cubic" // "cubic", "linear", "spring"
    this.springParams = {
      stiffness: 100,
      damping: 10,
      mass: 1,
    }
  }

  setInterpolationMethod(method, params = {}) {
    this.interpolationMethod = method

    if (method === "spring" && params) {
      this.springParams.stiffness = params.stiffness || 100
      this.springParams.damping = params.damping || 10
      this.springParams.mass = params.mass || 1
    }

    return this
  }

  start(startPos, targetPos, duration) {
    if (!startPos || !targetPos) return this

    this.startPosition = { ...startPos }
    this.targetPosition = { ...targetPos }
    this.startTime = performance.now()
    this.duration = duration
    this.isActive = true

    // For spring animation, we need initial velocity
    if (this.interpolationMethod === "spring") {
      this.velocity = {
        lat: 0,
        lng: 0,
      }
      this.lastUpdateTime = this.startTime
    }

    return this
  }

  update() {
    if (!this.isActive) return null

    const now = performance.now()
    const elapsed = now - this.startTime

    if (elapsed >= this.duration && this.interpolationMethod !== "spring") {
      this.isActive = false
      this.lastInterpolatedPosition = { ...this.targetPosition }
      return this.targetPosition
    }

    let interpolatedPosition

    switch (this.interpolationMethod) {
      case "linear":
        interpolatedPosition = this.linearInterpolation(elapsed / this.duration)
        break
      case "spring":
        interpolatedPosition = this.springInterpolation(now)
        // Check if spring has settled
        const distToTarget = calculateDistance(interpolatedPosition, this.targetPosition)
        if (distToTarget < 0.1 && Math.abs(this.velocity.lat) < 0.0001 && Math.abs(this.velocity.lng) < 0.0001) {
          this.isActive = false
        }
        break
      case "cubic":
      default:
        interpolatedPosition = this.cubicInterpolation(elapsed / this.duration)
        break
    }

    this.lastInterpolatedPosition = interpolatedPosition
    return interpolatedPosition
  }

  // Linear interpolation
  linearInterpolation(t) {
    // Clamp t between 0 and 1
    t = Math.max(0, Math.min(1, t))

    return {
      lat: this.startPosition.lat + (this.targetPosition.lat - this.startPosition.lat) * t,
      lng: this.startPosition.lng + (this.targetPosition.lng - this.startPosition.lng) * t,
      accuracy: this.targetPosition.accuracy,
      heading: this.targetPosition.heading,
      timestamp: performance.now(),
      speedMPS: this.targetPosition.speedMPS,
    }
  }

  // Cubic easing function for smoother motion
  cubicInterpolation(t) {
    // Clamp t between 0 and 1
    t = Math.max(0, Math.min(1, t))

    // Apply easing
    const easedT = this.easeOutCubic(t)

    return {
      lat: this.startPosition.lat + (this.targetPosition.lat - this.startPosition.lat) * easedT,
      lng: this.startPosition.lng + (this.targetPosition.lng - this.startPosition.lng) * easedT,
      accuracy: this.targetPosition.accuracy,
      heading: this.interpolateHeading(this.startPosition.heading, this.targetPosition.heading, easedT),
      timestamp: performance.now(),
      speedMPS: this.targetPosition.speedMPS,
    }
  }

  // Spring-based physics interpolation
  springInterpolation(now) {
    const dt = (now - this.lastUpdateTime) / 1000 // Convert to seconds
    this.lastUpdateTime = now

    // Spring physics parameters
    const k = this.springParams.stiffness
    const b = this.springParams.damping
    const m = this.springParams.mass

    // Calculate spring force for latitude and longitude
    const forceLatSpring = -k * (this.lastInterpolatedPosition.lat - this.targetPosition.lat)
    const forceLngSpring = -k * (this.lastInterpolatedPosition.lng - this.targetPosition.lng)

    // Calculate damping force
    const forceLatDamping = -b * this.velocity.lat
    const forceLngDamping = -b * this.velocity.lng

    // Calculate total force
    const totalForceLat = forceLatSpring + forceLatDamping
    const totalForceLng = forceLngSpring + forceLngDamping

    // Calculate acceleration (F = ma, so a = F/m)
    const accLat = totalForceLat / m
    const accLng = totalForceLng / m

    // Update velocity (v = v0 + a*t)
    this.velocity.lat += accLat * dt
    this.velocity.lng += accLng * dt

    // Update position (x = x0 + v*t)
    const newLat = this.lastInterpolatedPosition.lat + this.velocity.lat * dt
    const newLng = this.lastInterpolatedPosition.lng + this.velocity.lng * dt

    return {
      lat: newLat,
      lng: newLng,
      accuracy: this.targetPosition.accuracy,
      heading: this.interpolateHeading(this.lastInterpolatedPosition.heading, this.targetPosition.heading, 0.1),
      timestamp: now,
      speedMPS: this.targetPosition.speedMPS,
    }
  }

  // Interpolate heading (special case due to circular nature)
  interpolateHeading(startHeading, endHeading, t) {
    if (startHeading === null || endHeading === null) {
      return endHeading
    }

    // Normalize headings to 0-360
    startHeading = ((startHeading % 360) + 360) % 360
    endHeading = ((endHeading % 360) + 360) % 360

    // Find the shortest path around the circle
    let diff = endHeading - startHeading
    if (diff > 180) diff -= 360
    if (diff < -180) diff += 360

    // Interpolate
    const result = (startHeading + diff * t) % 360
    return result < 0 ? result + 360 : result
  }

  // Cubic easing function
  easeOutCubic(t) {
    return 1 - Math.pow(1 - t, 3)
  }

  // Smoother Hermite easing function with configurable smoothness
  easeHermite(t, smoothness = 0) {
    // Clamp t between 0 and 1
    t = Math.max(0, Math.min(1, t))

    // Apply Hermite interpolation with smoothness parameter
    return t * t * (3 - 2 * t - smoothness * (t - 1) * t)
  }

  isInterpolating() {
    return this.isActive
  }

  cancel() {
    this.isActive = false
    return this
  }

  getLastPosition() {
    return this.lastInterpolatedPosition || this.targetPosition || this.startPosition
  }
}

// Adaptive Kalman Filter Factory
class AdaptiveKalmanFilterFactory {
  static createForDevice(deviceInfo) {
    const filter = new KalmanFilter()

    // Configure based on device type and capabilities
    if (deviceInfo) {
      // Set device capabilities
      filter.setDeviceCapabilities(
        deviceInfo.highAccuracySupported || true,
        deviceInfo.motionSensorsAvailable || true,
        deviceInfo.orientationSensorsAvailable || true,
      )

      // Set receiver type based on device
      if (deviceInfo.gnssType) {
        filter.setReceiverType(deviceInfo.gnssType)
      }

      // Set environment type if known
      if (deviceInfo.environment) {
        filter.setEnvironmentType(deviceInfo.environment)
      }
    }

    return filter
  }

  static createFilterAndInterpolator(deviceInfo, interpolationMethod = "cubic") {
    const filter = this.createForDevice(deviceInfo)
    const interpolator = new PositionInterpolator().setInterpolationMethod(interpolationMethod)

    return {
      filter,
      interpolator,

      // Convenience method to update and interpolate in one step
      update(position, motionDetected = false, interpolationDuration = 300) {
        // First update the filter
        const filteredPosition = filter.update(position, motionDetected)

        // Then start interpolation to the new filtered position
        if (!interpolator.isInterpolating()) {
          const startPos = interpolator.getLastPosition() || position
          interpolator.start(startPos, filteredPosition, interpolationDuration)
        } else {
          // Update target while keeping the interpolation
          interpolator.targetPosition = filteredPosition
        }

        // Return the current interpolated position
        return interpolator.update() || filteredPosition
      },
    }
  }
}

// DOM update manager - batch DOM updates for better performance
const domUpdateManager = {
  updates: new Map(),
  scheduled: false,

  // Schedule a DOM update
  schedule(id, updateFn) {
    this.updates.set(id, updateFn)

    if (!this.scheduled) {
      this.scheduled = true
      requestAnimationFrame(() => this.flush())
    }
  },

  // Flush all scheduled DOM updates
  flush() {
    this.updates.forEach((updateFn) => updateFn())
    this.updates.clear()
    this.scheduled = false
  },
}
/*
// Create tracking system with optimized filter and interpolator
const tracking = AdaptiveKalmanFilterFactory.createFilterAndInterpolator(
  {
    highAccuracySupported: true,
    motionSensorsAvailable: true,
    orientationSensorsAvailable: true,
    gnssType: "GPS_GLONASS",
    environment: "urban",
  },
  "cubic",
)
*/

let tracking;

// Create a function to initialize tracking when needed
function initializeTracking() {
  if (!tracking) {
    try {
      console.log("Initializing Kalman filter tracking system");
      tracking = AdaptiveKalmanFilterFactory.createFilterAndInterpolator(
        {
          highAccuracySupported: true,
          motionSensorsAvailable: true,
          orientationSensorsAvailable: true,
          gnssType: "GPS_GLONASS",
          environment: "urban",
        },
        "cubic",
      );
    } catch (error) {
      console.error("Failed to initialize tracking system:", error);
      tracking = { filter: null }; // Prevent future initialization attempts
    }
  }
  return tracking;
}

const DEBUG_MODE = false;
        
// Core Tracking Function
function enhancedTracking(newPosition, motionDetected) {
  // Early bailout if no tracking object
  if (!tracking) {
    DEBUG_MODE && console.debug("Tracking not initialized - using passthrough");
    return createPassthroughTracker().update(newPosition);
  }

  // Calculate adaptive parameters
  const params = {
    ...DEFAULT_PARAMS,
    processNoise: motionDetected ? 0.05 : 0.01,
    measurementNoise: Math.max(newPosition.accuracy / 10, 0.01),
    adaptivity: motionDetected ? 0.01 : 0.005
  };

  // Silent configuration attempt
  const configMethods = ['configure', 'setParameters', 'updateFilterParameters'];
  configMethods.some(method => {
    try {
      if (typeof tracking[method] === 'function') {
        tracking[method](params);
        return true;
      }
    } catch (error) {
      DEBUG_MODE && console.debug(`Config ${method} failed:`, error);
    }
    return false;
  });

  // Position update logic
  try {
    const animationDuration = motionDetected ? ANIMATION_DURATION / 2 : ANIMATION_DURATION;
    
    return (
      tracking.update?.(newPosition, motionDetected, animationDuration) ||
      tracking.process?.(newPosition, { 
        isMoving: motionDetected, 
        animationDuration 
      }) ||
      tracking.filter?.update?.(newPosition) ||
      (tracking.setPosition?.(newPosition), newPosition) || 
      newPosition // Final fallback
    );
  } catch (error) {
    DEBUG_MODE && console.error("Position update failed:", error);
    return newPosition;
  }
}

// Simplified Passthrough Tracker
const createPassthroughTracker = () => {
  DEBUG_MODE && console.debug("Initializing passthrough tracker");
  return {
    update: position => position,
    configure: () => {},
    setParameters: () => {},
    process: position => position
  };
};
        
// Calculate appropriate zoom level based on speed with device movement filtering
function calculateZoomLevel(speedMPS) {
  // Update current speed for global access
  currentSpeed = speedMPS;
  
  // Check if this is genuine GPS movement or potential device movement
  const isGenuineMovement = lastPosition?.hasOwnProperty('speedAccuracy') &&
                          lastPosition.speedAccuracy < SPEED_ACCURACY_THRESHOLD;
  
  // Use a more conservative speed estimate for non-GPS-confirmed movement
  const reliableSpeed = isGenuineMovement ? speedMPS : Math.min(speedMPS, 1.0);
  
  // Check if we're currently in a location-based zoom mode
  if (isNearLocation) {
    // We're in proximity mode (zoom level 18), don't override with speed-based zoom
    return 18;
  }
  
  // Determine target zoom level based on reliable speed
  let targetZoomLevel;
  
  if (isStationary || reliableSpeed < 0.5) {
    // Stationary or very slow movement
    targetZoomLevel = MAX_ZOOM_LEVEL;
  } else if (reliableSpeed < WALKING_SPEED_THRESHOLD) {
    // Walking speed
    targetZoomLevel = WALKING_ZOOM_LEVEL;
  } else if (reliableSpeed < RUNNING_SPEED_THRESHOLD) {
    // Running speed - linear interpolation between walking and running zoom levels
    const t = (reliableSpeed - WALKING_SPEED_THRESHOLD) / (RUNNING_SPEED_THRESHOLD - WALKING_SPEED_THRESHOLD);
    targetZoomLevel = WALKING_ZOOM_LEVEL - t;
  } else if (reliableSpeed < DRIVING_SPEED_THRESHOLD) {
    // Driving speed - linear interpolation between running and driving zoom levels
    const t = (reliableSpeed - RUNNING_SPEED_THRESHOLD) / (DRIVING_SPEED_THRESHOLD - RUNNING_SPEED_THRESHOLD);
    targetZoomLevel = WALKING_ZOOM_LEVEL - 1 - t;
  } else {
    // High speed
    targetZoomLevel = MIN_ZOOM_LEVEL;
  }
  
  // For non-GPS-confirmed movement, be more conservative with zoom changes
  let smoothingFactor = isGenuineMovement ? 0.15 : 0.05;
  
  // For GPS-confirmed movement, check for significant speed changes
  if (isGenuineMovement) {
    const speedChange = lastPosition ? Math.abs(speedMPS - lastPosition.speedMPS) : 0;
    const significantSpeedChange = speedChange > 1.0;
    
    // More responsive when speed changes significantly
    if (significantSpeedChange) {
      smoothingFactor = 0.4;
    }
  }
  
  // Smooth zoom level changes
  let zoomLevel = targetZoomLevel;
  if (lastZoomLevel !== null) {
    zoomLevel = lastZoomLevel * (1 - smoothingFactor) + targetZoomLevel * smoothingFactor;
  }
  
  // Ensure more immediate response for significant genuine GPS speed transitions
  if (isGenuineMovement && 
     ((isStationary && speedMPS > 1.0) || (!isStationary && speedMPS < 0.5))) {
    zoomLevel = lastZoomLevel * 0.6 + targetZoomLevel * 0.4;
  }
  
  // Round to one decimal place for smoother transitions
  zoomLevel = Math.round(zoomLevel * 10) / 10;
  
  // Clamp to valid zoom range - but don't exceed zoom level 17 if we're not near a location
  // This ensures proximity zoom level control works properly
  zoomLevel = Math.max(MIN_ZOOM_LEVEL, Math.min(MAX_ZOOM_LEVEL, zoomLevel));
  
  // If not near a location, make sure we don't zoom in past 17
  if (!isNearLocation) {
    zoomLevel = Math.min(17, zoomLevel);
  }
  
  // Update last zoom level
  lastZoomLevel = zoomLevel;
  
  return zoomLevel;
}

function isTrackingHealthy() {
  return tracking && 
         tracking.filter && 
         typeof tracking.filter.reset === 'function';
}
        
// Enhanced stationary position calculation
function calculateStationaryPosition(buffer) {
  if (!buffer || buffer.length === 0) {
    return null
  }

  // Sort by accuracy (best first)
  const sortedBuffer = [...buffer].sort((a, b) => a.accuracy - b.accuracy)

  // Take weighted average of best positions
  const topPositions = sortedBuffer.slice(0, Math.ceil(buffer.length / 2))

  const weights = topPositions.map((pos) => 1 / Math.max(1, pos.accuracy))
  const totalWeight = weights.reduce((sum, w) => sum + w, 0)

  if (totalWeight === 0) {
    return sortedBuffer[0]
  }

  // Calculate weighted average
  const avgPosition = {
    lat: topPositions.reduce((sum, pos, i) => sum + pos.lat * weights[i], 0) / totalWeight,
    lng: topPositions.reduce((sum, pos, i) => sum + pos.lng * weights[i], 0) / totalWeight,
    accuracy: topPositions[0].accuracy,
    heading: topPositions[0].heading,
    timestamp: Date.now(),
    speedMPS: 0,
  }

  // If we have a previous stationary position, blend with it for stability
  if (lastStationaryPosition) {
    const blendFactor = 0.5 
    return {
      lat: lastStationaryPosition.lat * blendFactor + avgPosition.lat * (1 - blendFactor),
      lng: lastStationaryPosition.lng * blendFactor + avgPosition.lng * (1 - blendFactor),
      accuracy: avgPosition.accuracy,
      heading: avgPosition.heading,
      timestamp: avgPosition.timestamp,
      speedMPS: 0,
    }
  }

  return avgPosition
}

// Update stationary position history
function updateStationaryHistory(position) {
  // Add new position to history
  stationaryPositionHistory.push(position)

  // Keep history at maximum size
  while (stationaryPositionHistory.length > STATIONARY_POSITION_HISTORY_SIZE) {
    stationaryPositionHistory.shift()
  }

  // Calculate weighted average of positions
  let totalWeight = 0
  let weightedLat = 0
  let weightedLng = 0

  // Newer positions have higher weight
  for (let i = 0; i < stationaryPositionHistory.length; i++) {
    const pos = stationaryPositionHistory[i]
    const weight = Math.pow(STATIONARY_POSITION_WEIGHT_DECAY, stationaryPositionHistory.length - i - 1)
    totalWeight += weight
    weightedLat += pos.lat * weight
    weightedLng += pos.lng * weight
  }

  return {
    lat: weightedLat / totalWeight,
    lng: weightedLng / totalWeight,
    accuracy: position.accuracy,
    heading: position.heading,
    timestamp: position.timestamp,
    speedMPS: 0,
  }
}

// Check if device is in motion based on motion sensors
function isDeviceInMotion() {
  if (!motionSamples || motionSamples.length < 3) {
    return false
  }

  // Calculate average motion magnitude
  const avgMotion = motionSamples.reduce((sum, sample) => {
    return sum + Math.sqrt(sample.x * sample.x + sample.y * sample.y + sample.z * sample.z)
  }, 0) / motionSamples.length

  return avgMotion > MOTION_THRESHOLD
}

// Process device motion data
function handleDeviceMotion(event) {
  if (!event || !event.acceleration) return

  const motion = {
    x: event.acceleration.x || 0,
    y: event.acceleration.y || 0,
    z: event.acceleration.z || 0,
    timestamp: Date.now(),
  }

  // Add to motion samples
  motionSamples.push(motion)

  // Keep only recent samples
  while (motionSamples.length > MOTION_SAMPLE_SIZE) {
    motionSamples.shift()
  }

  // Update device motion state
  deviceMotion = motion

  // Check if device is stationary based on motion
  const inMotion = isDeviceInMotion()

  if (!inMotion) {
    deviceStationaryTime += MOTION_CHECK_INTERVAL
  } else {
    deviceStationaryTime = 0
  }
}

// Process device orientation data
function handleDeviceOrientation(event) {
  if (!event || event.alpha === null) return

  deviceOrientation = {
    alpha: event.alpha, // z-axis rotation [0,360)
    beta: event.beta, // x-axis rotation [-180,180)
    gamma: event.gamma, // y-axis rotation [-90,90)
    timestamp: Date.now(),
  }

  // Update heading buffer if we have a compass heading
  if (event.webkitCompassHeading !== undefined) {
    const heading = event.webkitCompassHeading

    // Add to heading buffer
    headingBuffer.push(heading)

    // Keep only recent headings
    while (headingBuffer.length > 5) {
      headingBuffer.shift()
    }

    // Calculate median heading to filter outliers
    if (headingBuffer.length >= 3) {
      const sortedHeadings = [...headingBuffer].sort((a, b) => a - b)
      lastHeadingValue = sortedHeadings[Math.floor(sortedHeadings.length / 2)]
    }
  }
}

// Request device motion and orientation permissions
function requestMotionPermission() {
  if (typeof DeviceMotionEvent !== "undefined" && typeof DeviceMotionEvent.requestPermission === "function") {
    DeviceMotionEvent.requestPermission()
      .then((response) => {
        if (response === "granted") {
          window.addEventListener("devicemotion", handleDeviceMotion, true)
        }
      })
      .catch(console.error)
  } else {
    window.addEventListener("devicemotion", handleDeviceMotion, true)
  }

  if (typeof DeviceOrientationEvent !== "undefined" && typeof DeviceOrientationEvent.requestPermission === "function") {
    DeviceOrientationEvent.requestPermission()
      .then((response) => {
        if (response === "granted") {
          orientationPermissionGranted = true
          window.addEventListener("deviceorientation", handleDeviceOrientation, true)
        }
      })
      .catch(console.error)
  } else {
    window.addEventListener("deviceorientation", handleDeviceOrientation, true)
    orientationPermissionGranted = true
  }
}

// Image preloading function
function preloadImages(locations) {
  return new Promise((resolve) => {
    if (!locations || locations.length === 0) {
      resolve()
      return
    }

    const totalImages = locations.length
    let loadedImages = 0
    const progressBar = document.getElementById("preloaderProgress")

    locations.forEach((location, index) => {
      if (!location.image) {
        loadedImages++
        updateProgress()
        if (loadedImages === totalImages) resolve()
        return
      }

      // Skip if already preloaded
      if (preloadedImages.has(location.image)) {
        loadedImages++
        updateProgress()
        if (loadedImages === totalImages) resolve()
        return
      }

      const img = new Image()
      img.crossOrigin = "anonymous" // Set crossOrigin for canvas operations
      img.onload = () => {
        preloadedImages.set(location.image, img)
        loadedImages++
        updateProgress()
        if (loadedImages === totalImages) resolve()
      }

      img.onerror = () => {
        console.warn(`Failed to load image: ${location.image}`)
        loadedImages++
        updateProgress()
        if (loadedImages === totalImages) resolve()
      }

      img.src = location.image
    })

    // Also preload audio files
    locations.forEach((location) => {
      if (location.audio && !preloadedAudio.has(location.audio)) {
        const audio = new Audio()
        audio.preload = "auto"
        audio.oncanplaythrough = () => {
          preloadedAudio.set(location.audio, audio)
        }
        audio.src = location.audio
      }
    })

    function updateProgress() {
      const percent = (loadedImages / totalImages) * 100
      domUpdateManager.schedule("preloaderProgress", () => {
        if (progressBar) {
          progressBar.style.width = `${percent}%`
        }
      })
    }
  })
}

// Detect sudden movements or position jumps
function detectSuddenMovement(newPosition, lastPosition) {
  if (!lastPosition || !newPosition) return false

  const distance = calculateDistance(lastPosition, newPosition)
  const timeDelta = (newPosition.timestamp - lastPosition.timestamp) / 1000 // seconds

  // If time delta is too small, consider it a valid update
  if (timeDelta < 0.05) return false

  // Calculate speed in meters per second
  const speed = distance / timeDelta

  // Check for unrealistic speeds (teleportation)
  if (speed > 40) {
    // Reduced from 50 to 40 m/s for more sensitive jump detection
    console.log(`Position jump detected: ${distance.toFixed(2)}m in ${timeDelta.toFixed(2)}s (${speed.toFixed(2)} m/s)`)
    return true
  }

  // Check for sudden movements when stationary
  if (isStationary && distance > POSITION_JUMP_THRESHOLD) {
    console.log(`Sudden movement detected while stationary: ${distance.toFixed(2)}m`)
    return true
  }

  // Check for small sudden movements (jitter)
  if (isStationary && distance > SUDDEN_MOVEMENT_THRESHOLD) {
    suddenMovementCount++
    if (suddenMovementCount >= 2) {
      console.log(`Multiple sudden movements detected: ${distance.toFixed(2)}m`)
      return true
    }
  } else {
    suddenMovementCount = 0
  }

  return false
}

// Track if we're in frequent checking mode
let inFrequentCheckingMode = false;
let lastOutsideCheckTime = 0;
let currentTransition = null;

function checkProximityForZoom() {
    const ZOOM_CHANGE_COOLDOWN = 3000;
    const PROXIMITY_CHECK_RADIUS = 100; // Feet
    const ZOOM_OUT_BUFFER_PERCENT = 0.15; // 15% buffer for zooming out
    const OUTSIDE_CHECK_INTERVAL = 15000; // Check every 15 seconds when outside radius
    const ZOOM_TRANSITION_DURATION = 1200; // Longer, smoother transition
    const now = Date.now();
    
    // Basic rate limiting check
    if (now - lastProximityCheck < 1000) {
        return;
    }
    lastProximityCheck = now;
    
    // Don't check if zoom was recently changed
    if (now - lastZoomChangeTime < ZOOM_CHANGE_COOLDOWN) {
        return;
    }
    
    // If we're not in frequent checking mode, only check every OUTSIDE_CHECK_INTERVAL
    if (!inFrequentCheckingMode && now - lastOutsideCheckTime < OUTSIDE_CHECK_INTERVAL) {
        return;
    }
    
    // Safety checks for required variables
    if (!userMarker || !gameLocations || gameLocations.length === 0) {
        console.log("Missing required objects for proximity check");
        return;
    }
    
    const userLatLng = userMarker.getLatLng();
    
    // Validate user coordinates
    if (!userLatLng || typeof userLatLng.lat !== 'number' || typeof userLatLng.lng !== 'number' || 
        isNaN(userLatLng.lat) || isNaN(userLatLng.lng)) {
        console.log("Invalid user coordinates");
        return;
    }
    
    const userPos = { lat: userLatLng.lat, lng: userLatLng.lng };
    
    // Find closest location
    let closestDistance = Infinity;
    let closestLocation = null;
    
    for (const location of gameLocations) {
        if (!location || typeof location.lat !== 'number' || typeof location.lng !== 'number' || 
            isNaN(location.lat) || isNaN(location.lng)) {
            continue;
        }
        
        const locationPos = { lat: location.lat, lng: location.lng };
        const distance = calculateDistance(userPos, locationPos);
        
        if (isFinite(distance) && distance < closestDistance) {
            closestDistance = distance;
            closestLocation = location;
        }
    }
    
    // If no valid locations found, exit
    if (!closestLocation || !isFinite(closestDistance)) {
        console.log("No valid locations found");
        lastOutsideCheckTime = now;
        inFrequentCheckingMode = false;
        return;
    }
    
    // Convert to feet for threshold comparison
    const distanceFeet = Math.round(closestDistance * 3.28084);
    
    // Calculate zoom out threshold with 15% buffer
    const zoomOutThreshold = Math.round(PROXIMITY_THRESHOLD * (1 + ZOOM_OUT_BUFFER_PERCENT));
    
    // Check if we should be in frequent checking mode
    if (distanceFeet <= PROXIMITY_CHECK_RADIUS) {
        if (!inFrequentCheckingMode) {
            console.log(`Entering frequent proximity check mode (${distanceFeet}ft)`);
            inFrequentCheckingMode = true;
        }
    } else {
        if (inFrequentCheckingMode) {
            console.log(`Exiting frequent proximity check mode (${distanceFeet}ft)`);
            inFrequentCheckingMode = false;
        }
        lastOutsideCheckTime = now;
    }
    
    console.log(`Distance to closest location: ${distanceFeet}ft (Threshold In: ${PROXIMITY_THRESHOLD}ft, Out: ${zoomOutThreshold}ft)`);
    
    // Cancel any ongoing transition
    if (currentTransition) {
        clearInterval(currentTransition);
        currentTransition = null;
    }
    
    // Enhanced smooth zoom logic
    if (!isNearLocation && distanceFeet <= PROXIMITY_THRESHOLD) {
        // User has entered the proximity zone - smooth zoom in
        console.log(`User entered proximity zone (${distanceFeet}ft), smoothly zooming in`);
        isNearLocation = true;
        lastZoomChangeTime = now;
        
        smoothZoomTo(18, ZOOM_TRANSITION_DURATION);
        
    } else if (isNearLocation && distanceFeet >= zoomOutThreshold) {
        // User has left the proximity zone - smooth zoom out
        console.log(`User left proximity zone (${distanceFeet}ft > ${zoomOutThreshold}ft), smoothly zooming out`);
        isNearLocation = false;
        lastZoomChangeTime = now;
        
        smoothZoomTo(17, ZOOM_TRANSITION_DURATION);
    }
    
    // Update for next time
    lastProximityDistance = closestDistance;
}

// Smooth zoom function that uses easing and lerp
function smoothZoomTo(targetZoom, duration) {
    const startZoom = map.getZoom();
    const startTime = Date.now();
    
    // Don't zoom if we're already at target
    if (Math.abs(targetZoom - startZoom) < 0.01) return;
    
    // Clear any existing transition
    if (currentTransition) {
        clearInterval(currentTransition);
    }
    
    currentTransition = setInterval(() => {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        // Calculate easing factor (easeInOutCubic)
        const easedProgress = progress < 0.5 
            ? 4 * progress * progress * progress 
            : 1 - Math.pow(-2 * progress + 2, 3) / 2;
        
        // Use lerp for the actual interpolation
        const newZoom = lerp(startZoom, targetZoom, easedProgress);
        
        map.setZoom(newZoom, { animate: false });
        
        if (progress >= 1) {
            clearInterval(currentTransition);
            currentTransition = null;
            
            // Ensure we end exactly at target zoom
            map.setZoom(targetZoom, { animate: false });
        }
    }, 16); // ~60fps for smooth animation
}

        function handleResize() {
            if (map) {
                map.invalidateSize();
                
                if (userMarker) {
                    const userPos = userMarker.getLatLng();
                    map.setView(userPos, map.getZoom(), { animate: false });
                }
            }
        }

        window.addEventListener('resize', handleResize);
        
function initMap() {
  // Ensure we have access to the Leaflet library
  const L = window.L;
  
  // Map initialization - using globally declared variables
  map = L.map("map", {
    zoomControl: false,
    attributionControl: false,
    zoomSnap: 0.1,
    zoomDelta: 0.5,
    wheelDebounceTime: 100,
    tapTolerance: 15,
    bounceAtZoomLimits: false,
    preferCanvas: true, // Use canvas renderer for better performance
    renderer: L.canvas({ padding: 0.5 }),
  }).fitWorld();
  
  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    maxZoom: 18,
    attribution: " OpenStreetMap contributors",
    updateWhenIdle: true,
    updateWhenZooming: false,
    keepBuffer: 2,
  }).addTo(map);
  
  // Initialize marker cluster group
  markerClusterGroup = L.markerClusterGroup({
    showCoverageOnHover: false,
    zoomToBoundsOnClick: true,
    spiderfyOnMaxZoom: true,
    animate: true,
    animateAddingMarkers: true,
    disableClusteringAtZoom: 17,
    maxClusterRadius: 60,
    iconCreateFunction: (cluster) =>
      L.divIcon({
        html: "<div><span>" + cluster.getChildCount() + "</span></div>",
        className: "marker-cluster-custom",
        iconSize: L.point(40, 40),
      }),
  })
  map.addLayer(markerClusterGroup)
  
  // Create user icon with custom styling
  const userIcon = L.divIcon({
    className: 'user-marker',
    html: '<div class="user-marker-icon"></div>',
    iconSize: [20, 20],
    iconAnchor: [10, 10] // Center the icon precisely
  });
  
  // Initialize user marker with a higher z-index to ensure visibility
  userMarker = L.marker([0, 0], { 
    icon: userIcon,
    zIndexOffset: 1000, // Ensure user marker is on top
    interactive: false, // Prevent marker from being clickable
    bubblingMouseEvents: false // Prevent events from bubbling
  }).addTo(map);
  
  // Store map viewport dimensions
  updateMapViewportDimensions();
  showLoadingMessage();
  
  // Request motion and orientation permissions
  requestMotionPermission();
  
  // Initialize geolocation tracking
  initGeolocation();
  
  // Handle visibility changes (tab switching, app in background)
  document.addEventListener("visibilitychange", handleVisibilityChange);
  
  // Track when the user is manually interacting with the map
  let userInteractionTimeout;
  
  map.on("movestart zoomstart dragstart", () => {
    followUser = false;
    isMapInteracting = true;
    userIsManuallyNavigating = true;
    
    // Clear any existing timers
    clearTimeout(userInteractionTimeout);
  });
  
  map.on("moveend zoomend dragend", () => {
    isMapInteracting = false;
    resetInactivityTimer();
    updateMapViewportDimensions();
    
    // Set a timer to re-enable auto-follow after period of inactivity
    clearTimeout(userInteractionTimeout);
    userInteractionTimeout = setTimeout(() => {
      userIsManuallyNavigating = false;
      // Only re-enable follow mode if we're not currently interacting
      if (!isMapInteracting) {
        followUser = true;
        // Update user marker position immediately
        if (lastKnownPosition) {
          updateUserMarkerPosition(lastKnownPosition);
        }
      }
    }, 30000); // 30 seconds of inactivity before re-enabling follow
  });
  
  // Listen for resize events to update viewport dimensions
  window.addEventListener("resize", () => {
    updateMapViewportDimensions(); // Then update map-specific dimensions
    
    // Re-center user marker if in follow mode
    if (followUser && lastKnownPosition) {
      updateUserMarkerPosition(lastKnownPosition);
    } else {
      // Force map to redraw even if not following user
      map.invalidateSize({animate: false});
    }
  });
  
  // Start animation loop for smooth rendering
  startAnimationLoop();
  
  // Enable touch interactions
  map.touchZoom.enable();
  map.doubleClickZoom.enable();
  
  // Add CSS for user marker direction indicator
  addUserMarkerStyles();
  
  // Important: Center map properly after initialization
  setTimeout(() => {
    if (map) {
      map.invalidateSize({animate: false});
      
      // If we already have a position, center on it immediately
      if (lastKnownPosition) {
        updateUserMarkerPosition(lastKnownPosition);
        centerMap();
      }
    }
  }, 100);
      // Add this at the end of the function
  ensureMapCentering()
}

// Update map viewport dimensions with improved centering logic
function updateMapViewportDimensions() {
  if (map && map._container) {
    // Store dimensions
    mapViewportWidth = map._container.clientWidth;
    mapViewportHeight = map._container.clientHeight;
    
    // Store current map center and zoom
    if (map.getCenter()) {
      lastMapCenter = map.getCenter();
      lastMapZoom = map.getZoom();
    }
    
    // Ensure map container is properly sized
    if (map._container.style.height !== window.innerHeight + 'px') {
      map._container.style.height = window.innerHeight + 'px';
      map._container.style.width = window.innerWidth + 'px';
    }
  }
}

// Add this function to ensure map centering
function centerMap() {
  if (map && userMarker) {
    // Get the current user position
    const userPosition = userMarker.getLatLng();
    
    // Center map on user's position
    map.setView(userPosition, map.getZoom(), {
      animate: false // Disable animation for immediate centering
    });
    
    // Force redraw
    map.invalidateSize({
      animate: false,
      pan: false
    });
  }
}

// Add CSS styles for user marker direction indicator
function addUserMarkerStyles() {
  const style = document.createElement("style")
  style.textContent = `
        .user-marker-icon {
            width: 16px;
            height: 16px;
            background-color: #ff3b30;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            position: relative;
        }
        
        .user-marker-direction {
            position: absolute;
            top: -4px;
            left: 50%;
            margin-left: -2px;
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-bottom: 12px solid #ff3b30;
            transform-origin: center bottom;
            z-index: -1;
        }
        
        .user-marker-icon.pulsing {
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(1.2);
                opacity: 0.8;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }
    `
  document.head.appendChild(style)
}

// Initialize geolocation with priority for Geolocation Sensor API
function initGeolocation() {
  // Declaring GeolocationSensor here
  const GeolocationSensor = window.GeolocationSensor

  if ("GeolocationSensor" in window) {
    try {
      console.log("Trying GeolocationSensor API")
      geolocationSensor = new GeolocationSensor({ frequency: 1 })

      geolocationSensor.addEventListener("reading", () => {
        const position = {
          coords: {
            latitude: geolocationSensor.latitude,
            longitude: geolocationSensor.longitude,
            accuracy: geolocationSensor.accuracy,
            altitude: geolocationSensor.altitude,
            altitudeAccuracy: geolocationSensor.altitudeAccuracy,
            heading: geolocationSensor.heading,
            speed: geolocationSensor.speed,
          },
          timestamp: geolocationSensor.timestamp,
        }

        if (!lastPosition) {
          initializeUserLocation(position)
        } else {
          handlePositionUpdate(position)
        }
      })

      geolocationSensor.addEventListener("error", (error) => {
        console.warn("GeolocationSensor error:", error)
        // Fall back to standard Geolocation API
        useStandardGeolocation()
      })

      geolocationSensor.start()
      usingGeolocationSensorAPI = true
      console.log("Using GeolocationSensor API")
    } catch (error) {
      console.warn("GeolocationSensor error:", error)
      // Fall back to standard Geolocation API
      useStandardGeolocation()
    }
  } else {
    // Fall back to standard Geolocation API
    useStandardGeolocation()
  }
}

// Update map viewport dimensions
function updateMapViewportDimensions() {
  if (map && map._container) {
    mapViewportWidth = map._container.clientWidth
    mapViewportHeight = map._container.clientHeight

    // Store current map center and zoom
    if (map.getCenter()) {
      lastMapCenter = map.getCenter()
      lastMapZoom = map.getZoom()
    }
  }
}

// Update map viewport dimensions and maintain centering
function updateMapViewportDimensions() {
  if (map && map._container) {
    // Store dimensions
    mapViewportWidth = map._container.clientWidth;
    mapViewportHeight = map._container.clientHeight;
    
    // Store current map center and zoom
    if (map.getCenter()) {
      lastMapCenter = map.getCenter();
      lastMapZoom = map.getZoom();
    }
    
    // Update viewport parameters for the tracking function
    const viewportDimensions = {
      width: mapViewportWidth,
      height: mapViewportHeight
    };
    
    // Pass these dimensions to the enhanced tracking function if needed
    if (typeof enhancedTracking === 'function' && userMarker) {
      // This allows the tracking function to use these dimensions for centering
      const userPosition = userMarker.getLatLng();
      enhancedTracking(userPosition, isUserMoving, viewportDimensions);
    }
  }
}

// Standard Geolocation API fallback
function useStandardGeolocation() {
  console.log("Using standard Geolocation API");
  usingGeolocationSensorAPI = false;
  
  if ("geolocation" in navigator) {
    const options = {
      enableHighAccuracy: true,
      timeout: 15000, // Reduced timeout for faster fallback
      maximumAge: 0,
    };
    
    // Track retry attempts
    let retryCount = 0;
    const maxRetries = 2;
    
    // Function to handle successful position acquisition
    function handleGeolocationSuccess(position) {
      if (!lastPosition) {
        initializeUserLocation(position);
      } else {
        handlePositionUpdate(position);
      }
      
      // Store this position as our last known position for recovery
      lastKnownPosition = position;
      
      // Start continuous watching after initial position
      if (watchPositionId === null) {
        startWatchPosition();
      }
    }
    
    // Function to handle geolocation errors with retry logic
    function handleGeolocationRetry(error) {
      console.warn(`Geolocation error (attempt ${retryCount + 1}/${maxRetries + 1}):`, error.code, error.message);
      
      retryCount++;
      if (retryCount <= maxRetries) {
        console.log(`Retrying geolocation (attempt ${retryCount + 1}/${maxRetries + 1})...`);
        navigator.geolocation.getCurrentPosition(handleGeolocationSuccess, handleGeolocationRetry, options);
      } else {
        handleLocationError(error);
      }
    }
    
    // Function to start continuous position watching
    function startWatchPosition() {
      // Clear any existing watch
      if (watchPositionId !== null) {
        navigator.geolocation.clearWatch(watchPositionId);
      }
      
      // Set up continuous location watching
      watchPositionId = navigator.geolocation.watchPosition(
        handlePositionUpdate,
        (error) => {
          console.warn("Watch position error:", error.code, error.message);
          
          // If watching fails, try to restart after a short delay
          if (watchPositionId !== null) {
            navigator.geolocation.clearWatch(watchPositionId);
            watchPositionId = null;
            
            setTimeout(() => {
              if (watchPositionId === null) {
                startWatchPosition();
              }
            }, 5000);
          }
        },
        {
          ...options,
          timeout: 27000, // Longer timeout for continuous watching
        }
      );
    }
    
    // Initial position acquisition
    navigator.geolocation.getCurrentPosition(handleGeolocationSuccess, handleGeolocationRetry, options);
  } else {
    showPopup("Geolocation is not supported by your browser");
    map.setView([44.9778, -93.265], 17); // Default view (Minneapolis)
    hideLoadingMessage();
    
    // Add a manual location button as fallback
    addManualLocationButton();
  }
}

// Simple IP fallback (add this new function)
function getFallbackPosition() {
  return new Promise((resolve) => {
    fetch('https://ipapi.co/json/')
      .then(response => response.json())
      .then(data => {
        resolve({
          coords: {
            latitude: data.latitude,
            longitude: data.longitude,
            accuracy: 50000, // Make it clear this is low accuracy
            altitude: null,
            altitudeAccuracy: null,
            heading: null,
            speed: null
          },
          timestamp: Date.now()
        });
      })
      .catch(() => {
        // If even IP fails, use your manual fallback
        resolve(null);
      });
  });
}

function ensureMapCentering() {
  // Ensure the map centers properly on initial load
  let centeringAttempts = 0;
  const maxAttempts = 5;
  
  function attemptCentering() {
    centeringAttempts++;
    console.log(`Map centering attempt ${centeringAttempts}`);
    
    if (map && userMarker && lastKnownPosition) {
      // Force proper centering on user position
      updateUserMarkerPosition(lastKnownPosition);
      
      // Set view directly without animation
      map.setView(
        [lastKnownPosition.lat, lastKnownPosition.lng],
        calculateZoomLevel(lastKnownPosition.speedMPS || 0),
        { animate: false, duration: 0, noMoveStart: true }
      );
      
      // Force redraw
      map.invalidateSize({ animate: false, pan: false });
      
      // Set follow mode to true
      followUser = true;
    } else if (centeringAttempts < maxAttempts) {
      // If we don't have position yet, try again in a moment
      setTimeout(attemptCentering, 500);
    }
  }
  
  // Start centering attempts
  attemptCentering();
  
  // Also add one final centering attempt after the app is fully loaded
  window.addEventListener('load', () => {
    setTimeout(() => {
      if (lastKnownPosition) {
        updateUserMarkerPosition(lastKnownPosition);
        map.setView(
          [lastKnownPosition.lat, lastKnownPosition.lng],
          calculateZoomLevel(lastKnownPosition.speedMPS || 0),
          { animate: false }
        );
        map.invalidateSize();
      }
    }, 1000);
  });
}
        
// Variables for dynamic zoom functionality
let speedSamples = [];
const MAX_SPEED_SAMPLES = 5;
let lastSpeedForZoom = 0;
let targetZoomLevel = MAX_ZOOM_LEVEL;
let lastZoomUpdateTime = 0;
const ZOOM_UPDATE_INTERVAL = 500; // ms - interval between zoom updates
let zoomTransitionInProgress = false;

// Update speed samples for dynamic zoom
function updateSpeedSamples(position) {
  if (!position || typeof position.speedMPS !== 'number') {
    // If no valid speed, add a zero (stationary) rather than skipping
    speedSamples.push(0);
  } else {
    // Add speed to samples
    speedSamples.push(position.speedMPS);
  }
  
  // Keep only recent samples
  while (speedSamples.length > MAX_SPEED_SAMPLES) {
    speedSamples.shift();
  }
}
   
// Calculate optimal zoom level based on speed
function calculateOptimalZoom(speed) {
  // Ensure speed is non-negative
  speed = Math.max(0, speed);
  
  // Stationary or very slow
  if (speed < 0.5) {
    return MAX_ZOOM_LEVEL;
  }
  // Walking speed
  else if (speed < WALKING_SPEED_THRESHOLD) {
    return WALKING_ZOOM_LEVEL;
  }
  // Running speed - linear interpolation
  else if (speed < RUNNING_SPEED_THRESHOLD) {
    const t = (speed - WALKING_SPEED_THRESHOLD) / (RUNNING_SPEED_THRESHOLD - WALKING_SPEED_THRESHOLD);
    return WALKING_ZOOM_LEVEL - t;
  }
  // Driving speed - linear interpolation
  else if (speed < DRIVING_SPEED_THRESHOLD) {
    const t = (speed - RUNNING_SPEED_THRESHOLD) / (DRIVING_SPEED_THRESHOLD - RUNNING_SPEED_THRESHOLD);
    return (WALKING_ZOOM_LEVEL - 1) - t * 2;
  }
  // High speed
  else {
    return MIN_ZOOM_LEVEL;
  }
}

// Update zoom level based on speed
function updateDynamicZoom() {
  const now = Date.now();
  
  // Don't update too frequently
  if (now - lastZoomUpdateTime < ZOOM_UPDATE_INTERVAL) return;
  lastZoomUpdateTime = now;
  
  // Skip if user is interacting with map or a zoom transition is in progress
  if (isMapInteracting || userIsInteracting || zoomTransitionInProgress) return;
  
  // Skip if not in follow mode
  if (!followUser) return;
  
  // Calculate average speed from samples
  let avgSpeed = 0;
  if (speedSamples.length > 0) {
    avgSpeed = speedSamples.reduce((sum, speed) => sum + speed, 0) / speedSamples.length;
  } else if (lastPosition && typeof lastPosition.speedMPS === 'number') {
    avgSpeed = lastPosition.speedMPS;
  }
  
  // Apply exponential smoothing for speed changes
  // Using 0.7 for previous value weight gives a good balance between
  // responsiveness and stability
  const smoothedSpeed = lastSpeedForZoom * 0.7 + avgSpeed * 0.3;
  lastSpeedForZoom = smoothedSpeed;
  
  // Calculate optimal zoom level
  const optimalZoom = calculateOptimalZoom(smoothedSpeed);
  
  // Only update if zoom level needs to change significantly
  if (Math.abs(optimalZoom - targetZoomLevel) >= 0.2) {
    targetZoomLevel = optimalZoom;
    
    // Apply zoom change with smooth animation
    if (map && followUser) {
      const currentZoom = map.getZoom();
      const zoomDiff = Math.abs(currentZoom - targetZoomLevel);
      
      // Use faster transition for larger zoom changes
      const duration = zoomDiff > 1 ? 300 : ZOOM_TRANSITION_DURATION;
      
      // Track zoom transition state
      zoomTransitionInProgress = true;
      
      // Perform the zoom
      map.setZoom(targetZoomLevel, {
        animate: true,
        duration: duration,
        noMoveStart: true,
      });
      
      // Reset transition flag after animation completes
      setTimeout(() => {
        zoomTransitionInProgress = false;
        // Re-center on user position after zoom completes
        if (followUser && lastPosition) {
          updateUserMarkerPosition(lastPosition);
        }
      }, duration + 50); // Add small buffer
    }
  }
}

// Optimize dynamic zoom transitions
function optimizeDynamicZoom(currentZoom, targetZoom) {
  // Apply easing for smoother zoom transitions
  const zoomDiff = targetZoom - currentZoom
  
  // Small differences use faster transitions
  if (Math.abs(zoomDiff) <= 0.5) {
    return {
      newZoom: targetZoom,
      duration: ZOOM_TRANSITION_DURATION * 0.5
    }
  }
  
  // Larger differences use slower, smoother transitions
  return {
    newZoom: currentZoom + (zoomDiff * 0.3),
    duration: ZOOM_TRANSITION_DURATION * 1.2
  }
}

// Improved position prediction for smoother tracking
function predictNextPosition(position, velocity, deltaTime) {
  if (!position || !velocity || !deltaTime) return position
  
  return {
    lat: position.lat + velocity.lat * deltaTime,
    lng: position.lng + velocity.lng * deltaTime,
    accuracy: position.accuracy,
    heading: position.heading,
    timestamp: position.timestamp + deltaTime * 1000,
    speedMPS: position.speedMPS
  }
}

// Animation loop for smooth rendering
function startAnimationLoop() {
  let lastValidPosition = null;
  let lastHeading = null;
  let lastSpeed = 0;

  function animate(timestamp) {
    // Calculate delta time
    const deltaTime = renderTimestamp ? (timestamp - renderTimestamp) / 1000 : 0;
    renderTimestamp = timestamp;

    // Process position updates - this presumably stores positions in your system
    processPositionUpdateQueue();

    // Try to get a position from your existing interpolator first
    let renderPosition;
    if (positionInterpolator && positionInterpolator.isInterpolating()) {
      renderPosition = positionInterpolator.update();
    }
    
    // If no interpolation available, use prediction
    if (!renderPosition && lastRenderPosition) {
      // Use your existing lastRenderPosition as the base
      const currentPosition = lastRenderPosition;
      
      // Only predict if we have movement (speed > 0.5 m/s) and heading
      if (currentPosition.speedMPS > 0.5 && currentPosition.heading) {
        // Calculate velocity (converting m/s to degrees/sec)
        const headingRad = currentPosition.heading * Math.PI / 180;
        const latVelocity = currentPosition.speedMPS * Math.cos(headingRad) / 111111;
        const lngVelocity = currentPosition.speedMPS * Math.sin(headingRad) / 
                           (111111 * Math.cos(currentPosition.lat * Math.PI / 180));
        
        renderPosition = predictNextPosition(
          currentPosition,
          { lat: latVelocity, lng: lngVelocity },
          deltaTime
        );
      } else {
        // Use last position if stationary
        renderPosition = currentPosition;
      }
    }

    // Update marker if we have a position
    if (renderPosition) {
      updateUserMarkerPosition(renderPosition);
      lastRenderPosition = renderPosition;
    }

    // Rest of your existing loop...
    if (followUser && !isMapInteracting && !edgeRecenterInProgress) {
      const recenterInfo = shouldRecenter(map, userMarker);
      if (recenterInfo.needsRecenter) {
        performEdgeRecenter(recenterInfo);
      }
    }
    checkProximityForZoom();
    animationFrameId = requestAnimationFrame(animate);
  }

  animationFrameId = requestAnimationFrame(animate);
}
    
// Create variables to track smoothing
let positionSmoothingActive = false;
let smoothingBuffer = [];
const MAX_SMOOTHING_SAMPLES = 3;

// Update user marker position and rotation with smoothing
function updateUserMarkerPosition(position, forceImmediate = false) {
  if (!userMarker || !position || position.lat === undefined || position.lng === undefined) return;

  // Dynamic smoothing based on speed
  let smoothedPosition = position;
  const speed = position.speedMPS || 0;
  
  // Apply different smoothing strategies based on speed
  if (!forceImmediate) {
    if (speed < 0.5) { // Very slow or stationary
      smoothingBuffer.push(position);
      if (smoothingBuffer.length > MAX_SMOOTHING_SAMPLES) {
        smoothingBuffer.shift();
      }
      
      if (smoothingBuffer.length >= 2) {
        const weights = [0.6, 0.3, 0.1];
        let lat = 0, lng = 0, totalWeight = 0;
        
        for (let i = 0; i < Math.min(weights.length, smoothingBuffer.length); i++) {
          const idx = smoothingBuffer.length - 1 - i;
          const weight = weights[i];
          lat += smoothingBuffer[idx].lat * weight;
          lng += smoothingBuffer[idx].lng * weight;
          totalWeight += weight;
        }
        
        smoothedPosition = {
          ...position,
          lat: lat / totalWeight,
          lng: lng / totalWeight
        };
      }
    }
    else if (speed < 5) { // Moderate speed
      // Use simpler averaging with fewer samples
      smoothingBuffer.push(position);
      if (smoothingBuffer.length > 3) smoothingBuffer.shift();
      
      if (smoothingBuffer.length >= 2) {
        smoothedPosition = {
          ...position,
          lat: smoothingBuffer.reduce((sum, p) => sum + p.lat, 0) / smoothingBuffer.length,
          lng: smoothingBuffer.reduce((sum, p) => sum + p.lng, 0) / smoothingBuffer.length
        };
      }
    }
    else { // High speed
      // Minimal smoothing, just keep last position
      smoothingBuffer = [position];
    }
  } else {
    smoothingBuffer = [position];
  }

  // Update marker position
  userMarker.setLatLng([smoothedPosition.lat, smoothedPosition.lng]);

  // Enhanced map centering with speed-based animation
  if (followUser && !isMapInteracting && !edgeRecenterInProgress) {
    if (forceImmediate) {
      map.setView([smoothedPosition.lat, smoothedPosition.lng], map.getZoom(), {
        animate: false
      });
    } else {
      // Dynamic pan duration based on speed (faster movement = quicker pan)
      const panDuration = Math.max(0.1, Math.min(0.5, 0.5 - (speed / 20)));
      
      map.panTo([smoothedPosition.lat, smoothedPosition.lng], {
        animate: true,
        duration: panDuration,
        noMoveStart: true,
        easeLinearity: 0.25 // Tighter easing for more responsive feeling
      });
    }
  }

  // Rotation handling (unchanged)
  if (position.heading !== undefined && position.heading !== null) {
    const markerElement = userMarker.getElement();
    if (markerElement) {
      const directionElement = markerElement.querySelector(".user-marker-direction");
      if (directionElement) {
        directionElement.style.transform = `rotate(${position.heading}deg)`;
      }
    }
  }
    
  // Speed-based visual effects (unchanged)
  if (position.speedMPS !== undefined && !isNaN(position.speedMPS)) {
    const markerElement = userMarker.getElement();
    if (markerElement) {
      const iconElement = markerElement.querySelector(".user-marker-icon");
      if (iconElement) {
        if (position.speedMPS > 0.5) {
          iconElement.classList.add("pulsing");
          const pulseRate = Math.max(0.5, Math.min(2.0, 1.0 + position.speedMPS / 5));
          iconElement.style.animationDuration = `${1 / pulseRate}s`;
        } else {
          iconElement.classList.remove("pulsing");
          iconElement.style.animationDuration = "";
        }
      }
    }
  }
  
  lastRenderPosition = smoothedPosition;
}
        
// Process position update queue
function processPositionUpdateQueue() {
  if (positionUpdateQueue.length === 0) return
  
  // Only process the oldest position update in the queue
  // This allows for smoother transitions between positions
  const update = positionUpdateQueue.shift()
  processPositionUpdate(update)
  
  // If we still have items in the queue, schedule the next update
  if (positionUpdateQueue.length > 0) {
    requestAnimationFrame(processPositionUpdateQueue)
  }
}
        
// Add these variables to your existing scope
const BACKGROUND_THRESHOLD_MS = 1500; // 1.5 seconds threshold to detect background

function processPositionUpdate(position) {
  // Calculate time since last update to detect background state
  const currentTime = Date.now();
  const timeSinceLastUpdate = currentTime - lastUpdateTime;
  const possibleBackgroundTransition = timeSinceLastUpdate > BACKGROUND_THRESHOLD_MS;
  
  // Update timestamp for next call
  lastUpdateTime = currentTime;
  
  // Skip if invalid position
  if (!position || typeof position.lat !== "number" || typeof position.lng !== "number") {
    return;
  }

  // Force immediate positioning after background transition
  if (possibleBackgroundTransition) {
    updateUserMarkerPosition(position);
    lastRenderPosition = position;
    
    // Force recenter after coming from background
    if (followUser) {
      map.setView([position.lat, position.lng], calculateZoomLevel(position.speedMPS), {
        animate: false,
        duration: 0
      });
      map.invalidateSize(); // Force redraw
    }
    return;
  }
  
  // Handle large position changes
  if (lastRenderPosition && calculateDistance(lastRenderPosition, position) > EXTENDED_DISTANCE_THRESHOLD) {
    console.debug(`Large position change detected (${calculateDistance(lastRenderPosition, position).toFixed(2)}m). Skipping interpolation.`);
    updateUserMarkerPosition(position); // Direct update without animation
    
    // Also snap map center after large jumps
    if (followUser && !isMapInteracting) {
      map.setView([position.lat, position.lng], calculateZoomLevel(position.speedMPS), {
        animate: false
      });
    }
    
    lastRenderPosition = position;
    return;
  }
  
  // Normal case: Apply smooth interpolation between positions
  if (lastRenderPosition && !isFirstPositionUpdate) {
    if (positionInterpolator) {
      // Use slower animation when stationary for more stability
      positionInterpolator.start(
        lastRenderPosition, 
        position,
        isStationary ? 300 : ANIMATION_DURATION,
      );
    } else {
      console.warn("Position interpolator not available, using direct position update");
      updateUserMarkerPosition(position);
      lastRenderPosition = position;
    }
  } else {
    // First position update - set directly without animation
    updateUserMarkerPosition(position);
    lastRenderPosition = position;
    isFirstPositionUpdate = false;
    
    // Ensure first position is centered properly
    if (followUser) {
      map.setView([position.lat, position.lng], calculateZoomLevel(position.speedMPS), {
        animate: false
      });
    }
  }
  
  // Handle auto-recentering and zoom adjustments
  if (followUser && !isMapInteracting) {
    const recenterInfo = shouldRecenter(map, userMarker);
    if (recenterInfo.needsRecenter) {
      performEdgeRecenter(recenterInfo);
    } else if (Math.abs(map.getZoom() - calculateZoomLevel(position.speedMPS)) > 0.5) {
      const newZoom = calculateZoomLevel(position.speedMPS);
      map.setZoom(newZoom, {
        animate: true,
        duration: ZOOM_TRANSITION_DURATION,
      });
    }
  }
}
       
// Perform edge recentering with smoother transitions based on speed
function performEdgeRecenter(recenterInfo) {
  edgeRecenterInProgress = true
  
  // Get current position
  const position = userMarker.getLatLng()
  
  // Get current speed (in meters per second)
  const currentSpeed = lastPosition?.speedMPS || 0
  
  // Only trust GPS-reported speed, not calculated from position changes
  // This helps filter out device movements like shaking
  const isGenuineMovement = lastPosition?.hasOwnProperty('speedAccuracy') && 
                            lastPosition.speedAccuracy < SPEED_ACCURACY_THRESHOLD
  
  // Use a conservative speed value if we're not confident in the movement
  const reliableSpeed = isGenuineMovement ? currentSpeed : Math.min(currentSpeed, 1.0)
  
  // Calculate appropriate zoom level based on reliable speed
  const dynamicZoom = calculateZoomLevel(reliableSpeed)
  
  // Get current map center
  const currentCenter = map.getCenter()
  
  // Calculate optimal center point that keeps the user icon away from edges
  const optimalCenter = calculateOptimalCenter(map, position, recenterInfo.edgeInfo)
  
  // Calculate edge proximity using your existing function
  const proximity = calculateEdgeProximity(map, position)
  
  // Find the minimum proximity (closest edge)
  const minProximity = Math.min(proximity.north, proximity.south, proximity.east, proximity.west)
  
  // Calculate speed factor (0-1) based on reliable speed
  const SPEED_THRESHOLD_SLOW = 1.5
  const SPEED_THRESHOLD_FAST = 10.0
  const speedFactor = Math.min(1, Math.max(0, (reliableSpeed - SPEED_THRESHOLD_SLOW) / 
                              (SPEED_THRESHOLD_FAST - SPEED_THRESHOLD_SLOW)))
  
  // Calculate combined transition factor
  const baseTransitionFactor = Math.max(0.3, Math.min(0.8, minProximity * 2))
  const speedAdjustedFactor = baseTransitionFactor - (speedFactor * 0.3)
  
  // Blend current and optimal centers for smoother transition
  const blendedCenter = {
    lat: currentCenter.lat + (optimalCenter.lat - currentCenter.lat) * (1 - speedAdjustedFactor),
    lng: currentCenter.lng + (optimalCenter.lng - currentCenter.lng) * (1 - speedAdjustedFactor)
  }
  
  // Only apply forward bias for genuine GPS movement
  let adjustedCenter = blendedCenter
  if (lastPosition && isGenuineMovement) {
    const direction = {
      lat: position.lat - lastPosition.lat,
      lng: position.lng - lastPosition.lng
    }
    
    // Calculate movement magnitude
    const movement = Math.sqrt(direction.lat * direction.lat + direction.lng * direction.lng)
    
    // Only apply forward bias if moving significantly
    if (movement > 0.00001) {
      // Apply forward bias scaled to speed
      const forwardBiasAmount = 0.00005 + (speedFactor * 0.0001)
      
      // Normalize direction and apply forward bias
      adjustedCenter = {
        lat: blendedCenter.lat + (direction.lat / movement) * forwardBiasAmount,
        lng: blendedCenter.lng + (direction.lng / movement) * forwardBiasAmount
      }
    }
  }
  
  // Calculate duration based on reliable speed
  const baseDuration = recenterInfo.isEmergency ? 0.2 : ZOOM_TRANSITION_DURATION
  const speedAdjustedDuration = baseDuration * (1 - (speedFactor * 0.5))
  
  // Set view with animation
  map.setView([adjustedCenter.lat, adjustedCenter.lng], dynamicZoom, {
    animate: true,
    duration: speedAdjustedDuration,
    noMoveStart: true,
    easeLinearity: 0.3 + (speedFactor * 0.2)
  })
  
  // Reset edge recenter flag after animation completes
  setTimeout(
    () => {
      edgeRecenterInProgress = false
    },
    recenterInfo.isEmergency ? 300 : speedAdjustedDuration * 1000,
  )
}

function showLoadingMessage() {
    // Skip creating the loading message element
    // Just log to console for debugging purposes
    console.log("Searching for location...");
    
    // Set a flag to track that we're in the loading state
    window.isSearchingLocation = true;
    
    // If you need to maintain any timing-dependent behavior that might
    // rely on this function, you can add a small timeout
    setTimeout(() => {
        // This ensures any code expecting this function to take some time
        // will still work correctly
    }, 100);
}

function hideLoadingMessage() {
    // Clear the loading state flag
    window.isSearchingLocation = false;
    
    // No need to remove any elements since we didn't create them
    // Just log for debugging
    console.log("Location found, proceeding to stabilization...");
    
    // If any code relies on this function completing, ensure it still works
    const fakeLoadingMessage = document.getElementById('loadingMessage');
    if (fakeLoadingMessage) {
        document.body.removeChild(fakeLoadingMessage);
    }
}
        
function initializeUserLocation(position) {
  console.log("Initial position data:", JSON.stringify(position))
  if (typeof tracking === 'undefined') {
    tracking = initializeTracking();
  }
  if (!position || !position.coords) {
    console.error("Invalid initial position object")
    handleLocationError(new Error("Invalid initial position"))
    return
  }
  const { latitude: userLat, longitude: userLng, accuracy } = position.coords
  if (isNaN(userLat) || isNaN(userLng)) {
    console.error("Invalid initial coordinates:", { userLat, userLng })
    handleLocationError(new Error("Invalid initial coordinates"))
    return
  }
  console.log("Valid initial position:", { userLat, userLng, accuracy })
  try {
    // Set initial marker position
    updateUserMarkerPosition({
      lat: userLat,
      lng: userLng,
      accuracy: accuracy,
      heading: position.coords.heading,
      timestamp: Date.now(),
      speedMPS: 0,
    })
    map.setView([userLat, userLng], 17)
    // Initialize Kalman filter with first position
    tracking.filter.reset({
      lat: userLat,
      lng: userLng,
      accuracy: accuracy,
      heading: position.coords.heading,
      timestamp: Date.now(),
    })
    // Initialize stationary position
    lastStationaryPosition = {
      lat: userLat,
      lng: userLng,
      accuracy: accuracy,
      heading: position.coords.heading,
      timestamp: Date.now(),
      speedMPS: 0,
    }
    // Initialize last render position
    lastRenderPosition = {
      lat: userLat,
      lng: userLng,
      accuracy: accuracy,
      heading: position.coords.heading,
      timestamp: Date.now(),
      speedMPS: 0,
    }
    // Initialize last valid position
    lastValidPosition = {
      lat: userLat,
      lng: userLng,
      accuracy: accuracy,
      heading: position.coords.heading,
      timestamp: Date.now(),
      speedMPS: 0,
    }
    
    // Start position updates immediately
    startPositionUpdates()
    
    // Start the preloader
    startPreloader()
    
    // Start hunt after preloader finishes (exactly 10 seconds)
    setTimeout(() => {
      startHunt()
    }, 10000)
  } catch (error) {
    console.error("Error setting initial user location:", error)
    handleLocationError(error)
  }
}
       
function startPositionUpdates() {
  // If already using GeolocationSensor API, don't start again
  if (usingGeolocationSensorAPI) {
    console.log("Position updates already using GeolocationSensor API")
    return
  }

  // Use standard Geolocation API with high frequency updates
  watchPositionId = navigator.geolocation.watchPosition(handlePositionUpdate, handleLocationError, {
    enableHighAccuracy: true,
    maximumAge: 0,
    timeout: 10000,
  })
  isWatchPositionActive = true
  console.log("Position updates using standard Geolocation API")
}

// Main function to handle position updates
function handlePositionUpdate(position) {
  if (!map || !userMarker) return;
  
  // Update user marker position
  const userPos = {
    lat: position.coords.latitude,
    lng: position.coords.longitude
  };
  
  // Update marker position (but don't move the map yet)
  userMarker.setLatLng(userPos);
  
  // Store position for calculations
  lastPosition = {
    lat: userPos.lat,
    lng: userPos.lng,
    accuracy: position.coords.accuracy,
    heading: position.coords.heading,
    speedMPS: position.coords.speed || 0,
    timestamp: Date.now()
  };
  
  // If follow mode is enabled, update map position
  if (followUser && !isMapInteracting) {
    // Check if user is near edge
    const edgeInfo = isMarkerNearEdge(map, userMarker);
    
    // Update map position using the optimal center calculation
    updateMapPosition(map, userMarker, true);
  }
  
  // Update distance box
  updateDistanceBox();
}

function handleVisibilityChange() {
  if (document.hidden) {
    lastHiddenTime = Date.now()
    lastKnownPosition = userMarker ? userMarker.getLatLng() : null

    // Cancel any active interpolation
    if (positionInterpolator) {
      positionInterpolator.cancel()
    }

    // Cancel animation frame
    if (animationFrameId) {
      cancelAnimationFrame(animationFrameId)
      animationFrameId = null
    }

    // Stop GeolocationSensor if using it
    if (usingGeolocationSensorAPI && geolocationSensor) {
      geolocationSensor.stop()
    }
  } else {
    const hiddenDuration = Date.now() - lastHiddenTime
    if (hiddenDuration > BACKGROUND_THRESHOLD) {
      updateLocationAfterBackground()
    } else {
      map.invalidateSize()

      // Restart animation loop
      if (!animationFrameId) {
        startAnimationLoop()
      }

      // Restart GeolocationSensor if using it
      if (usingGeolocationSensorAPI && geolocationSensor) {
        geolocationSensor.start()
      }

      // If returning from exhibit, ensure movement resumes properly
      if (isReturningFromExhibit) {
        isReturningFromExhibit = false
        // Force a position update to resume tracking
        if (lastValidPosition) {
          updateUserLocation(
            {
              coords: {
                latitude: lastValidPosition.lat,
                longitude: lastValidPosition.lng,
                accuracy: lastValidPosition.accuracy,
                heading: lastValidPosition.heading,
                speed: lastValidPosition.speedMPS,
              },
              timestamp: Date.now(),
            },
            true,
          )
        }
      }
    }
  }
  resetInactivityTimer()
}

function updateLocationAfterBackground() {
    if (!("geolocation" in navigator)) {
        console.warn("Geolocation is not available");
        return;
    }
    
    // First try with cached position to get quick response
    const quickOptions = {
        enableHighAccuracy: false,
        timeout: 5000,
        maximumAge: 60000,  // Use a position from last minute if available
    };
    
    // Then try with high accuracy
    const accurateOptions = {
        enableHighAccuracy: true,
        timeout: 15000,
        maximumAge: 30000,
    };
    
    // Final fallback with very permissive settings
    const fallbackOptions = {
        enableHighAccuracy: false,
        timeout: 25000,
        maximumAge: 120000, // Accept positions up to 2 minutes old
    };

const handleSuccess = (position) => {
    console.log("Background update raw position:", JSON.stringify(position));
    
    if (!position?.coords) {
        console.warn("Invalid position object in background update");
        return;
    }
    const { latitude, longitude, accuracy } = position.coords;
    if (isNaN(latitude) || isNaN(longitude)) {
        console.warn("Invalid coordinates in background update:", { latitude, longitude });
        return;
    }
    console.log("Valid background position update:", { lat: latitude, lng: longitude });
    
    try {
        // Ensure tracking is initialized
        initializeTracking();
        
        if (!tracking?.filter) {
            console.error("Kalman filter initialization failed");
            return;
        }

        updateUserLocation(position, true);
        
        // Reset tracking state
        lastPosition = null;
        positionBuffer = [];
        velocity = { lat: 0, lng: 0 };
        lastVelocity = { lat: 0, lng: 0 };
        isStationary = false;
        stationaryStartTime = null;
        stationaryCount = 0;
        stationaryPositionHistory = [];
        lastStationaryPosition = null;
        stationaryPositionLocked = false;
        positionHistory = [];
        suddenMovementCount = 0;
        isJumpDetected = false;
        
        // Reset Kalman filter with proper error handling
        try {
            if (typeof tracking.filter.reset === 'function') {
                tracking.filter.reset({
                    lat: latitude,
                    lng: longitude,
                    accuracy: accuracy,
                    heading: position.coords.heading || 0,
                    timestamp: Date.now(),
                });
            } else {
                console.warn("Kalman filter reset not available, reinitializing");
                tracking = AdaptiveKalmanFilterFactory.createFilterAndInterpolator(
                    {
                        highAccuracySupported: true,
                        motionSensorsAvailable: true,
                        orientationSensorsAvailable: true,
                        gnssType: "GPS_GLONASS",
                        environment: "urban",
                    },
                    "cubic",
                );
            }
        } catch (filterError) {
            console.error("Error resetting Kalman filter:", filterError);
            // Attempt to recreate the filter
            tracking = AdaptiveKalmanFilterFactory.createFilterAndInterpolator(
                {
                    highAccuracySupported: true,
                    motionSensorsAvailable: true,
                    orientationSensorsAvailable: true,
                    gnssType: "GPS_GLONASS",
                    environment: "urban",
                },
                "cubic",
            );
        }
        
        // Restart animation if needed
        if (!animationFrameId) {
            startAnimationLoop();
        }
        
        // Restart GeolocationSensor if using it
        if (usingGeolocationSensorAPI && geolocationSensor) {
            geolocationSensor.start();
        }
        
        updateDistanceBox();
        followUser = true;
        map.invalidateSize();
    } catch (error) {
        console.error("Error in updateUserLocation during background update:", error);
    }
};
    
    const handleError = (error, stage) => {
        console.error(`Error getting location during ${stage} attempt:`, error);
        
        switch (error.code) {
            case error.PERMISSION_DENIED:
                console.warn("User denied geolocation access");
                break;
                
            case error.POSITION_UNAVAILABLE:
                if (stage === "quick") {
                    console.log("Quick position unavailable, trying accurate position...");
                    navigator.geolocation.getCurrentPosition(
                        handleSuccess,
                        (err) => handleError(err, "accurate"),
                        accurateOptions
                    );
                } else if (stage === "accurate") {
                    console.log("Accurate position unavailable, trying fallback...");
                    navigator.geolocation.getCurrentPosition(
                        handleSuccess,
                        (err) => handleError(err, "fallback"),
                        fallbackOptions
                    );
                } else {
                    console.warn("All position attempts failed - location unavailable");
                }
                break;
                
            case error.TIMEOUT:
                if (stage === "quick") {
                    console.log("Quick position timed out, trying accurate position...");
                    navigator.geolocation.getCurrentPosition(
                        handleSuccess,
                        (err) => handleError(err, "accurate"),
                        accurateOptions
                    );
                } else if (stage === "accurate") {
                    console.log("Accurate position timed out, trying fallback...");
                    navigator.geolocation.getCurrentPosition(
                        handleSuccess,
                        (err) => handleError(err, "fallback"),
                        fallbackOptions
                    );
                } else {
                    console.warn("All position attempts timed out");
                }
                break;
                
            default:
                if (stage !== "fallback") {
                    console.log("Unknown error, trying fallback options...");
                    navigator.geolocation.getCurrentPosition(
                        handleSuccess,
                        (err) => handleError(err, "fallback"),
                        fallbackOptions
                    );
                } else {
                    console.warn("All position attempts failed with unknown error");
                }
        }
    };

    // Start with quick attempt to get position
    navigator.geolocation.getCurrentPosition(
        handleSuccess,
        (error) => handleError(error, "quick"),
        quickOptions
    );
}
        
// Helper function to validate position data
function isValidPosition(pos) {
  return (
    pos &&
    typeof pos.lat === "number" &&
    !isNaN(pos.lat) &&
    typeof pos.lng === "number" &&
    !isNaN(pos.lng) &&
    typeof pos.accuracy === "number" &&
    !isNaN(pos.accuracy)
  )
}

// Linear interpolation helper
function lerp(a, b, t) {
  if (typeof a !== "number" || typeof b !== "number" || typeof t !== "number") {
    return a
  }

  return a + (b - a) * Math.max(0, Math.min(1, t))
}

// Update position buffer with new position
function updatePositionBuffer(position) {
  if (!isValidPosition(position)) {
    return
  }

  // Add new position to buffer
  positionBuffer.push({
    lat: position.lat,
    lng: position.lng,
    accuracy: position.accuracy,
    heading: position.heading,
    timestamp: position.timestamp,
    speedMPS: position.speedMPS,
  })

  // Remove old positions if buffer exceeds maxSize
  while (positionBuffer.length > MAX_BUFFER_SIZE) {
    positionBuffer.shift()
  }
}

// Update position history for jump detection
function updatePositionHistory(position) {
  if (!isValidPosition(position)) {
    return
  }

  // Add new position to history
  positionHistory.push({
    lat: position.lat,
    lng: position.lng,
    accuracy: position.accuracy,
    heading: position.heading,
    timestamp: position.timestamp,
    speedMPS: position.speedMPS,
  })

  // Keep only recent positions
  while (positionHistory.length > 10) {
    positionHistory.shift()
  }
}

// Check stationary state
function checkStationaryState(newPosition) {
  if (!lastPosition) return

  // Calculate distance between current and last position
  const distance = calculateDistance(lastPosition, newPosition)

  // Check if device motion sensors indicate movement
  const motionDetected = isDeviceInMotion()

  // If significant movement is detected or motion sensors indicate activity
  if (distance >= MICRO_MOVEMENT_THRESHOLD || motionDetected) {
    if (isStationary) {
      console.debug("Movement detected, transitioning to moving state")
      isStationary = false
      stationaryStartTime = null
      stationaryPositionLocked = false
      stationaryCount = 0 // Reset stationary count
      tracking.filter.setStationaryMode(false)

      // Clear any stationary lock timeout
      if (stationaryLockTimeout) {
        clearTimeout(stationaryLockTimeout)
        stationaryLockTimeout = null
      }
    }

    // Clear the stationary check timeout
    if (stationaryCheckTimeout) {
      clearTimeout(stationaryCheckTimeout)
      stationaryCheckTimeout = null
    }
  } else {
    // If no significant movement, increment stationary count
    stationaryCount++

    // If stationary count exceeds threshold, transition to stationary state
    if (!isStationary && stationaryCount >= STATIONARY_THRESHOLD) {
      console.debug("User is now stationary")
      isStationary = true
      stationaryStartTime = Date.now()
      tracking.filter.setStationaryMode(true)

      // Calculate a stable position by averaging recent positions
      const stablePosition = calculateStationaryPosition(positionBuffer)
      if (stablePosition) {
        lastStationaryPosition = stablePosition

        // Set a timeout to lock the stationary position after a delay
        if (stationaryLockTimeout) {
          clearTimeout(stationaryLockTimeout)
        }

        stationaryLockTimeout = setTimeout(() => {
          stationaryPositionLocked = true
          stationaryPositionLockTime = Date.now()
          console.log("Stationary position locked after delay")

          // Also lock in the Kalman filter
          tracking.filter.lockStationaryPosition(lastStationaryPosition)
        }, 2000) // Reduced from 3000ms for faster locking
      }
    }

    // Schedule the next stationary check
    if (isStationary && !stationaryCheckTimeout) {
      stationaryCheckTimeout = setTimeout(() => {
        stationaryCheckTimeout = null
        checkStationaryState(newPosition)
      }, STATIONARY_CHECK_INTERVAL)
    }
  }
}

// Main function to update user location
function updateUserLocation(position, forceUpdate = false) {
  // Validate input position
  if (!position?.coords?.latitude || !position?.coords?.longitude) {
    console.warn("Invalid position data received")
    return
  }

  const currentTime = Date.now()
  const timeDelta = lastUpdateTime ? (currentTime - lastUpdateTime) / 1000 : 0

  // Create position object
  const newPosition = {
    lat: position.coords.latitude,
    lng: position.coords.longitude,
    accuracy: position.coords.accuracy || 20,
    heading: position.coords.heading !== null ? position.coords.heading : lastHeadingValue || undefined,
    timestamp: currentTime,
    speedMPS: position.coords.speed !== null ? position.coords.speed : 0,
  }

  // Update speed samples for dynamic zoom
  updateSpeedSamples(newPosition)

  // First position initialization
  if (!lastPosition) {
    lastPosition = newPosition
    lastValidPosition = newPosition
    updateUserMarkerPosition(newPosition)
    tracking.filter.reset(newPosition)
    lastUpdateTime = currentTime
    stationaryStartTime = currentTime
    positionBuffer = [newPosition]
    positionHistory = [newPosition]
    lastStationaryPosition = newPosition
    lastRenderPosition = newPosition

    // Set initial zoom based on stationary state
    const initialZoom = calculateZoomLevel(0)
    map.setView([newPosition.lat, newPosition.lng], initialZoom, { animate: false })
    updateDistanceBox()
    
    // Initialize proximity check variables if needed
    lastProximityCheck = 0
    lastZoomChangeTime = 0
    isNearLocation = false
    
    // Check proximity after initial position is set
    checkProximityForZoom()
    return
  }

  // Calculate distance from last position
  const distance = calculateDistance(lastPosition, newPosition)

  // Check for sudden movements or position jumps
  const isJump = !forceUpdate && detectSuddenMovement(newPosition, lastPosition)

  // If a jump is detected and we're stationary, ignore this update
  if (isJump && isStationary && stationaryPositionLocked) {
    console.log("Position jump detected while stationary, ignoring update")
    isJumpDetected = true
    return
  }

  // Handle large position changes or forced updates
  if (distance > EXTENDED_DISTANCE_THRESHOLD || forceUpdate) {
    if (stationaryCheckTimeout) {
      clearTimeout(stationaryCheckTimeout)
      stationaryCheckTimeout = null
    }

    if (stationaryLockTimeout) {
      clearTimeout(stationaryLockTimeout)
      stationaryLockTimeout = null
    }

    isStationary = false
    stationaryStartTime = null
    stationaryCount = 0
    stationaryPositionHistory = []
    lastStationaryPosition = null
    stationaryPositionLocked = false
    isJumpDetected = false

    // Reset tracking variables
    tracking.filter.reset(newPosition)
    tracking.filter.setStationaryMode(false)
    
    // Update marker position IMMEDIATELY without interpolation
    updateUserMarkerPosition(newPosition)
    
    lastPosition = newPosition
    lastValidPosition = newPosition
    lastRenderPosition = newPosition
    positionBuffer = [newPosition]
    positionHistory = [newPosition]
    lastVelocity = { lat: 0, lng: 0 }
    lastSmoothedPosition = null

    // Update map view INSTANTLY without animation
    const zoomLevel = calculateZoomLevel(newPosition.speedMPS)
    map.setView([newPosition.lat, newPosition.lng], zoomLevel, {
      animate: false,
      duration: 0
    })

    lastUpdateTime = currentTime
    lastUpdateTimestamp = currentTime
    updateDistanceBox()

    if (map._container) {
      map._onResize()
    }
    
    // Reset proximity state on large position changes
    if (isNearLocation) {
      isNearLocation = false
      // Don't set lastZoomChangeTime here to allow immediate proximity checks
    }
    
    // Check proximity after large position change
    checkProximityForZoom()
    return
  }

  // Skip updates with poor accuracy or unrealistic movement
  if (
    !forceUpdate &&
    (newPosition.accuracy > MAX_ACCEPTABLE_ACCURACY || (timeDelta > 0 && distance / timeDelta > 40))
  ) {
    console.log("Skipping update due to poor accuracy or unrealistic movement")
    return
  }

  try {
    // Check if device is in motion based on motion sensors
    const motionDetected = deviceMotion && isDeviceInMotion()

    // Check stationary state
    checkStationaryState(newPosition)

    // If we're in stationary mode and have a locked position, use that position
    if (isStationary && stationaryPositionLocked && lastStationaryPosition) {
      // Just update the distance box without changing position
      updateDistanceBox()
      
      // Still check proximity even when stationary - user might be stationary near POI
      checkProximityForZoom()
      return
    }

    // Apply enhanced tracking with motion detection
    const smoothedPosition = tracking.update(newPosition, motionDetected, ANIMATION_DURATION)

    // Position prediction logic
    let finalPosition = smoothedPosition;
    
    // Only apply prediction if we're moving and have a valid heading
    if (!isStationary && smoothedPosition.speedMPS > 0.5 && smoothedPosition.heading !== undefined && smoothedPosition.heading !== null) {
      // Calculate prediction distance based on speed and a time factor
      // Predict 300ms into the future as a reasonable value
      const predictionTimeSeconds = 0.3;
      const distanceInMeters = smoothedPosition.speedMPS * predictionTimeSeconds;
      
      // Get predicted position
      const predictedPosition = predictPositionFromHeading(
        smoothedPosition, 
        smoothedPosition.heading, 
        distanceInMeters
      );
      
      // Blend predicted position with filtered position
      // Use a lower weight for prediction at lower speeds, higher at higher speeds
      // This makes prediction more aggressive at higher speeds where it's more needed
      const predictionWeight = Math.min(0.4, smoothedPosition.speedMPS / 15);
      
      finalPosition = {
        lat: smoothedPosition.lat * (1 - predictionWeight) + predictedPosition.lat * predictionWeight,
        lng: smoothedPosition.lng * (1 - predictionWeight) + predictedPosition.lng * predictionWeight,
        accuracy: smoothedPosition.accuracy,
        heading: smoothedPosition.heading,
        timestamp: smoothedPosition.timestamp,
        speedMPS: smoothedPosition.speedMPS
      };
      
      // Log prediction info if needed
      // console.log(`Prediction applied: ${predictionWeight.toFixed(2)} weight, ${distanceInMeters.toFixed(2)}m ahead`);
    }

    // Update position buffer and history with final position (which may include prediction)
    updatePositionBuffer(finalPosition)
    updatePositionHistory(finalPosition)

    // Add to position update queue
    positionUpdateQueue.push(finalPosition)
    lastPosition = finalPosition
    lastValidPosition = finalPosition

    // Call processPositionUpdateQueue to handle the new position
    processPositionUpdateQueue()

    lastUpdateTime = currentTime
    lastUpdateTimestamp = currentTime
    updateDistanceBox()
    
    // Check proximity after normal position update
    checkProximityForZoom()
  } catch (error) {
    console.error("Location update error:", error)
    // Fallback with basic filtering
    updateUserMarkerPosition(newPosition)
    lastPosition = newPosition
    lastValidPosition = newPosition
    lastRenderPosition = newPosition
    updateDistanceBox()
    
    // Check proximity even in error case
    checkProximityForZoom()
  }
}
     
/*
function updateUserLocation(position, forceUpdate = false) {
    if (typeof tracking === 'undefined') {
    tracking = initializeTracking();
  }
    
  // Validate input position
  if (!position?.coords?.latitude || !position?.coords?.longitude) {
    console.warn("Invalid position data received");
    return;
  }

  const currentTime = Date.now();
  const timeDelta = lastUpdateTime ? (currentTime - lastUpdateTime) / 1000 : 0;

  // Create position object
  const newPosition = {
    lat: position.coords.latitude,
    lng: position.coords.longitude,
    accuracy: position.coords.accuracy || 20,
    heading: position.coords.heading !== null ? position.coords.heading : lastHeadingValue || undefined,
    timestamp: currentTime,
    speedMPS: position.coords.speed !== null ? position.coords.speed : 0,
  };

  // Update speed samples for dynamic zoom
  updateSpeedSamples(newPosition);

  // First position initialization
  if (!lastPosition) {
    lastPosition = newPosition;
    lastValidPosition = newPosition;
    updateUserMarkerPosition(newPosition, true); // Force immediate update
    tracking.filter.reset(newPosition);
    lastUpdateTime = currentTime;
    stationaryStartTime = currentTime;
    positionBuffer = [newPosition];
    positionHistory = [newPosition];
    lastStationaryPosition = newPosition;
    lastRenderPosition = newPosition;

    const initialZoom = calculateZoomLevel(0);
    map.setView([newPosition.lat, newPosition.lng], initialZoom, { animate: false });
    updateDistanceBox();
    
    lastProximityCheck = 0;
    lastZoomChangeTime = 0;
    isNearLocation = false;
    
    checkProximityForZoom();
    return;
  }

  // Calculate distance from last position
  const distance = calculateDistance(lastPosition, newPosition);

  // Check for sudden movements or position jumps
  const isJump = !forceUpdate && detectSuddenMovement(newPosition, lastPosition);

  if (isJump && isStationary && stationaryPositionLocked) {
    console.log("Position jump detected while stationary, ignoring update");
    isJumpDetected = true;
    return;
  }

  // Handle large position changes or forced updates
  if (distance > EXTENDED_DISTANCE_THRESHOLD || forceUpdate) {
    if (stationaryCheckTimeout) clearTimeout(stationaryCheckTimeout);
    if (stationaryLockTimeout) clearTimeout(stationaryLockTimeout);

    isStationary = false;
    stationaryStartTime = null;
    stationaryCount = 0;
    stationaryPositionHistory = [];
    lastStationaryPosition = null;
    stationaryPositionLocked = false;
    isJumpDetected = false;

    tracking.filter.reset(newPosition);
    tracking.filter.setStationaryMode(false);
    
    updateUserMarkerPosition(newPosition, true);
    
    lastPosition = newPosition;
    lastValidPosition = newPosition;
    lastRenderPosition = newPosition;
    positionBuffer = [newPosition];
    positionHistory = [newPosition];
    lastVelocity = { lat: 0, lng: 0 };
    lastSmoothedPosition = null;

    const zoomLevel = calculateZoomLevel(newPosition.speedMPS);
    map.setView([newPosition.lat, newPosition.lng], zoomLevel, {
      animate: false,
      duration: 0
    });

    lastUpdateTime = currentTime;
    lastUpdateTimestamp = currentTime;
    updateDistanceBox();

    if (map._container) map._onResize();
    
    if (isNearLocation) isNearLocation = false;
    
    checkProximityForZoom();
    return;
  }

  if (!forceUpdate && (newPosition.accuracy > MAX_ACCEPTABLE_ACCURACY || (timeDelta > 0 && distance / timeDelta > 40))) {
    console.log("Skipping update due to poor accuracy or unrealistic movement");
    return;
  }

  try {
    const motionDetected = deviceMotion && isDeviceInMotion();
    checkStationaryState(newPosition);

    if (isStationary && stationaryPositionLocked && lastStationaryPosition) {
      updateDistanceBox();
      checkProximityForZoom();
      return;
    }

    const smoothedPosition = tracking.update(newPosition, motionDetected, ANIMATION_DURATION);
    let finalPosition = smoothedPosition;
    
    // Enhanced prediction logic for smoother high-speed movement
    if (!isStationary && smoothedPosition.speedMPS > 0.5 && smoothedPosition.heading !== undefined) {
      // Dynamic prediction time based on speed (0.1s to 0.5s)
      const predictionTime = Math.min(0.5, 0.1 + (smoothedPosition.speedMPS / 20));
      const distanceInMeters = smoothedPosition.speedMPS * predictionTime;
      
      const predictedPosition = predictPositionFromHeading(
        smoothedPosition, 
        smoothedPosition.heading, 
        distanceInMeters
      );
      
      // More aggressive prediction at higher speeds (up to 60% influence)
      const predictionWeight = Math.min(0.6, smoothedPosition.speedMPS / 15);
      
      finalPosition = {
        lat: smoothedPosition.lat * (1 - predictionWeight) + predictedPosition.lat * predictionWeight,
        lng: smoothedPosition.lng * (1 - predictionWeight) + predictedPosition.lng * predictionWeight,
        accuracy: smoothedPosition.accuracy,
        heading: smoothedPosition.heading,
        timestamp: smoothedPosition.timestamp,
        speedMPS: smoothedPosition.speedMPS
      };
    }

    // Update position history
    updatePositionBuffer(finalPosition);
    updatePositionHistory(finalPosition);

    // Instead of queueing, process immediately with smoother transition
    if (positionUpdateQueue.length === 0) {
      positionUpdateQueue.push(finalPosition);
      processPositionUpdateQueue();
    } else {
      positionUpdateQueue = [finalPosition]; // Replace queued positions with latest
    }

    lastPosition = finalPosition;
    lastValidPosition = finalPosition;
    lastUpdateTime = currentTime;
    lastUpdateTimestamp = currentTime;
    updateDistanceBox();
    checkProximityForZoom();
  } catch (error) {
    console.error("Location update error:", error);
    updateUserMarkerPosition(newPosition);
    lastPosition = newPosition;
    lastValidPosition = newPosition;
    lastRenderPosition = newPosition;
    updateDistanceBox();
    checkProximityForZoom();
  }
}
    */    
// Predict position based on heading and speed
function predictPositionFromHeading(position, heading, distance) {
  // Input validation
  if (
    !position ||
    typeof heading !== "number" ||
    typeof distance !== "number" ||
    !position.lat ||
    !position.lng ||
    isNaN(heading) ||
    isNaN(distance)
  ) {
    return position
  }

  // Normalize heading to 0-360 range
  heading = ((heading % 360) + 360) % 360

  // Earth's radius in meters
  const R = 6371e3

  // Convert to radians
  const d = distance / R
  const  = (heading * Math.PI) / 180
  const 1 = (position.lat * Math.PI) / 180
  const 1 = (position.lng * Math.PI) / 180

  // Calculate predicted position with error handling
  try {
    const sin1 = Math.sin(1)
    const cos1 = Math.cos(1)
    const cosd = Math.cos(d)
    const sind = Math.sin(d)
    const cos = Math.cos()

    const 2 = Math.asin(sin1 * cosd + cos1 * sind * cos)

    const 2 = 1 + Math.atan2(Math.sin() * sind * cos1, cosd - sin1 * Math.sin(2))

    // Convert back to degrees with bounds checking
    const newLat = Math.max(-90, Math.min(90, (2 * 180) / Math.PI))
    const newLng = (((2 * 180) / Math.PI + 540) % 360) - 180

    return {
      lat: newLat,
      lng: newLng,
    }
  } catch (error) {
    // Fallback to original position if calculation fails
    return position
  }
}

// Check if user marker is near map edge
function isMarkerNearEdge(map, marker, threshold = 0.25) {
  if (!map || !marker) return { isNearEdge: false };
  
  const position = marker.getLatLng();
  const bounds = map.getBounds();
  
  // Calculate normalized distances from edges (0-1 range)
  const proximities = {
    north: Math.abs(position.lat - bounds.getNorth()) / (bounds.getNorth() - bounds.getSouth()),
    south: Math.abs(position.lat - bounds.getSouth()) / (bounds.getNorth() - bounds.getSouth()),
    east: Math.abs(position.lng - bounds.getEast()) / (bounds.getEast() - bounds.getWest()),
    west: Math.abs(position.lng - bounds.getWest()) / (bounds.getEast() - bounds.getWest())
  };
  
  // Check if any edge is closer than threshold
  const edges = {
    north: proximities.north < threshold,
    south: proximities.south < threshold,
    east: proximities.east < threshold,
    west: proximities.west < threshold
  };
  
  const isNearEdge = edges.north || edges.south || edges.east || edges.west;
  
  return {
    isNearEdge,
    edges,
    proximities
  };
}

// Update map position to keep user centered
function updateMapPosition(map, userMarker, followUser = true) {
  if (!map || !userMarker || !followUser) return;
  
  // Get current user position
  const userPosition = userMarker.getLatLng();
  
  // Check if user is near edge
  const edgeInfo = isMarkerNearEdge(map, userMarker);
  
  // Calculate optimal center point
  const optimalCenter = calculateOptimalCenter(map, userPosition, edgeInfo, {
    headingBias: true,
    speedAdjust: true,
    viewportOffset: true,
    smoothTransition: true
  });
  
  // Get current speed for animation duration
  const speed = lastPosition?.speedMPS || 0;
  
  // Faster animation at higher speeds
  const animationDuration = Math.max(0.1, 0.5 - (speed * 0.02));
  
  // Update map center with animation
  map.panTo(optimalCenter, {
    animate: true,
    duration: animationDuration,
    easeLinearity: 0.25,
    noMoveStart: true
  });
}

// Main function to handle position updates
function handlePositionUpdate(position) {
  if (!map || !userMarker) return;
  
  // Update user marker position
  const userPos = {
    lat: position.coords.latitude,
    lng: position.coords.longitude
  };
  
  // Update marker position (but don't move the map yet)
  userMarker.setLatLng(userPos);
  
  // Store position for calculations
  lastPosition = {
    lat: userPos.lat,
    lng: userPos.lng,
    accuracy: position.coords.accuracy,
    heading: position.coords.heading,
    speedMPS: position.coords.speed || 0,
    timestamp: Date.now()
  };
  
  // If follow mode is enabled, update map position
  if (followUser && !isMapInteracting) {
    updateMapPosition(map, userMarker, true);
  }
  
  // Update other UI elements
  updateDistanceBox();
}

// Calculate proximity to map edges
function calculateEdgeProximity(map, point) {
  const bounds = map.getBounds();
  const latSpan = bounds.getNorth() - bounds.getSouth();
  const lngSpan = bounds.getEast() - bounds.getWest();
  
  // Add pixel-based proximity calculation for more accurate edge detection
  const mapSize = map.getSize();
  const pixelPoint = map.latLngToContainerPoint(point);
  
  return {
    north: Math.abs(point.lat - bounds.getNorth()) / latSpan,
    south: Math.abs(point.lat - bounds.getSouth()) / latSpan,
    east: Math.abs(point.lng - bounds.getEast()) / lngSpan,
    west: Math.abs(point.lng - bounds.getWest()) / lngSpan,
    // Add pixel-based proximities
    northPx: pixelPoint.y / mapSize.y,
    southPx: (mapSize.y - pixelPoint.y) / mapSize.y,
    eastPx: (mapSize.x - pixelPoint.x) / mapSize.x,
    westPx: pixelPoint.x / mapSize.x
  };
}

// Determine if map should recenter
function shouldRecenter(map, marker) {
  // Fail-fast if invalid inputs
  if (!map?.getBounds || !marker?.getLatLng) {
    console.warn('shouldRecenter: Invalid map or marker');
    return { needsRecenter: false, reason: 'invalid_input' };
  }
  
  // Check if user is actively moving via GPS
  const currentSpeed = lastPosition?.speedMPS || 0;
  const isUserMoving = isDeviceInMotion() || (currentSpeed > 0.5); // 0.5 m/s threshold
  
  // Only allow manual navigation to override recentering when NOT actively moving
  if (userIsManuallyNavigating && !isUserMoving) {
    return { needsRecenter: false, reason: 'manual_navigation_while_stationary' };
  }
  
  // Dynamic thresholds based on speed
  const baseEdgeThreshold = typeof EDGE_THRESHOLD_PERCENTAGE !== 'undefined' 
    ? EDGE_THRESHOLD_PERCENTAGE 
    : 0.25;
  
  const baseCriticalThreshold = typeof CRITICAL_EDGE_THRESHOLD !== 'undefined'
    ? CRITICAL_EDGE_THRESHOLD
    : baseEdgeThreshold * 0.5;
  
  // Adjust thresholds based on speed - higher speeds need more visibility ahead
  const speedFactor = Math.min(3.0, 1.0 + (currentSpeed / 10)); // Cap at 3x normal threshold
  const edgeThreshold = baseEdgeThreshold * speedFactor;
  const criticalThreshold = baseCriticalThreshold * speedFactor;
  
  // Dynamic cooldown based on speed - faster movement needs quicker recentering
  const baseCooldown = typeof RECENTER_COOLDOWN !== 'undefined'
    ? RECENTER_COOLDOWN
    : 1500;
  
  // Reduce cooldown for higher speeds to ensure more responsive recentering
  const cooldown = isUserMoving ? Math.max(300, baseCooldown / speedFactor) : baseCooldown;
  
  const lastRecenter = typeof lastRecenterTime !== 'undefined'
    ? lastRecenterTime
    : 0;
  
  try {
    const position = marker.getLatLng();
    const proximity = calculateEdgeProximity(map, position);
    
    // Safely extract proximity values with Infinity fallbacks
    const {
      north = Infinity, south = Infinity,
      east = Infinity, west = Infinity,
      pixelNorth = Infinity, pixelSouth = Infinity,
      pixelEast = Infinity, pixelWest = Infinity
    } = proximity || {};
    
    // Calculate closest edge
    const minProximity = Math.min(north, south, east, west);
    const minPixelProximity = Math.min(pixelNorth, pixelSouth, pixelEast, pixelWest);
    
    // Determine closest edge direction
    const edgeInfo = {
      isNorth: north === minProximity,
      isSouth: south === minProximity,
      isEast: east === minProximity,
      isWest: west === minProximity,
      pixelProximity: minPixelProximity,
      speed: currentSpeed
    };
    
    // Threshold checks with speed adjustments
    const needsRecenter = minProximity < edgeThreshold;
    const isEmergency = minProximity < criticalThreshold;
    const canRecenter = Date.now() - lastRecenter > cooldown;
    
    // For high speeds, consider directional bias (we need more space in the direction of movement)
    let directionalUrgency = false;
    if (currentSpeed > 5.0 && lastPosition?.heading !== undefined) {
      const heading = lastPosition.heading;
      // Check if we're approaching an edge in our direction of travel
      if ((heading > 315 || heading < 45) && north < edgeThreshold * 1.2) {
        directionalUrgency = true; // Moving north and north edge is close
      } else if (heading >= 45 && heading < 135 && east < edgeThreshold * 1.2) {
        directionalUrgency = true; // Moving east and east edge is close
      } else if (heading >= 135 && heading < 225 && south < edgeThreshold * 1.2) {
        directionalUrgency = true; // Moving south and south edge is close
      } else if (heading >= 225 && heading < 315 && west < edgeThreshold * 1.2) {
        directionalUrgency = true; // Moving west and west edge is close
      }
    }
    
    if ((needsRecenter || directionalUrgency) && canRecenter) {
      lastRecenterTime = Date.now(); // Update global
      
      // Log recenter event with speed info for debugging
      console.log(`Recentering at speed ${currentSpeed.toFixed(1)} m/s, threshold: ${edgeThreshold.toFixed(2)}, cooldown: ${cooldown}ms`);
      
      return { 
        needsRecenter: true,
        isEmergency: isEmergency || (currentSpeed > 10.0 && directionalUrgency),
        edgeInfo,
        reason: directionalUrgency ? 'high_speed_directional' : 
                (isUserMoving ? 'moving_near_edge' : 
                (isEmergency ? 'critical_edge' : 'near_edge'))
      };
    }
    
    return { 
      needsRecenter: false,
      reason: !needsRecenter ? 'within_bounds' : 'cooldown_active'
    };
  } catch (error) {
    console.error('shouldRecenter failed:', error);
    return { needsRecenter: false, reason: 'calculation_error' };
  }
}

// Add this function to ensure proper centering on initialization
function ensureMapCentering() {
  // Force immediate viewport update
  window.addEventListener("load", () => {
    // Force layout recalculation
    document.body.style.display = "none"
    document.body.offsetHeight // Force reflow
    document.body.style.display = ""

    // Update map dimensions immediately
    updateMapViewportDimensions()

    // Force map to center if user position is available
    if (userMarker && userMarker.getLatLng()) {
      map.setView(userMarker.getLatLng(), map.getZoom(), {
        animate: false,
      })
    }

    // Additional check after a short delay
    setTimeout(() => {
      updateMapViewportDimensions()
      if (userMarker && userMarker.getLatLng()) {
        map.setView(userMarker.getLatLng(), map.getZoom(), {
          animate: false,
        })
      }
    }, 100)
  })

  // Also ensure proper centering when returning from background
  document.addEventListener("visibilitychange", () => {
    if (!document.hidden) {
      setTimeout(() => {
        map.invalidateSize()
        updateMapViewportDimensions()
        if (userMarker && userMarker.getLatLng()) {
          map.setView(userMarker.getLatLng(), map.getZoom(), {
            animate: false,
          })
        }
      }, 100)
    }
  })
}
        
// Calculate optimal center point to keep user icon centered with map moving underneath
function calculateOptimalCenter(map, userPosition, edgeInfo, options = {}) {
  // Default options
  const {
    headingBias = true,        // Whether to bias centering based on heading
    speedAdjust = true,        // Whether to adjust centering based on speed
    viewportOffset = false,    // Whether to apply viewport aspect ratio offsets
    smoothTransition = true    // Whether to apply smoothing to transitions
  } = options;
  
  // Safety checks for required parameters
  if (!map || !userPosition || !userPosition.lat || !userPosition.lng) {
    console.warn('Invalid parameters in calculateOptimalCenter');
    return userPosition; // Return original position as fallback
  }
  
  // Get current speed and heading if available
  const speed = lastPosition?.speedMPS || 0;
  const heading = lastPosition?.heading;
  const isMovingSignificantly = speed > 1.5; // m/s, walking speed threshold
  
  // For stationary or very slow movement, just center directly on user
  if (!isMovingSignificantly && !edgeInfo?.isNearEdge) {
    return userPosition;
  }
  
  // Get viewport dimensions for aspect ratio calculations
  const viewportWidth = map._container.clientWidth;
  const viewportHeight = map._container.clientHeight;
  const aspectRatio = viewportWidth / viewportHeight;
  
  // Calculate map bounds
  const bounds = map.getBounds();
  const latSpan = bounds.getNorth() - bounds.getSouth();
  const lngSpan = bounds.getEast() - bounds.getWest();
  
  // Initialize offset values
  let latOffset = 0;
  let lngOffset = 0;
  
  // If we're near an edge, calculate offset to keep user away from that edge
  if (edgeInfo && edgeInfo.isNearEdge) {
    // Calculate edge-based offsets
    if (edgeInfo.edges.north) latOffset = -latSpan * 0.2;
    if (edgeInfo.edges.south) latOffset = latSpan * 0.2;
    if (edgeInfo.edges.east) lngOffset = lngSpan * 0.2;
    if (edgeInfo.edges.west) lngOffset = -lngSpan * 0.2;
    
    // Apply stronger offset for the closest edge
    const minProximity = Math.min(
      edgeInfo.edges.north ? edgeInfo.proximities.north : 1,
      edgeInfo.edges.south ? edgeInfo.proximities.south : 1,
      edgeInfo.edges.east ? edgeInfo.proximities.east : 1,
      edgeInfo.edges.west ? edgeInfo.proximities.west : 1
    );
    
    // Amplify the offset for the closest edge
    if (edgeInfo.proximities.north === minProximity && edgeInfo.edges.north) latOffset *= 1.5;
    else if (edgeInfo.proximities.south === minProximity && edgeInfo.edges.south) latOffset *= 1.5;
    else if (edgeInfo.proximities.east === minProximity && edgeInfo.edges.east) lngOffset *= 1.5;
    else if (edgeInfo.proximities.west === minProximity && edgeInfo.edges.west) lngOffset *= 1.5;
  }
  
  // Apply viewport aspect ratio adjustments if enabled
  if (viewportOffset) {
    // Adjust offsets based on viewport dimensions
    latOffset *= (1 / aspectRatio); // Less latitude offset for wide screens
    lngOffset *= aspectRatio;       // More longitude offset for wide screens
  }
  
  // Apply heading bias for forward-looking view when moving at speed
  if (headingBias && isMovingSignificantly && heading !== undefined && heading !== null) {
    // Calculate forward bias based on speed (more bias at higher speeds)
    const forwardBias = Math.min(0.3, speed * 0.02); // Cap at 0.3 (30% of viewport)
    
    // Convert heading to radians
    const headingRad = (heading * Math.PI) / 180;
    
    // Calculate directional components
    const headingLatOffset = -Math.cos(headingRad) * forwardBias * latSpan;
    const headingLngOffset = Math.sin(headingRad) * forwardBias * lngSpan;
    
    // Apply heading bias
    latOffset += headingLatOffset;
    lngOffset += headingLngOffset;
  }
  
  // Apply speed-based adjustments if enabled
  if (speedAdjust && speed > 0) {
    // Reduce offsets at higher speeds to keep user more centered
    const speedFactor = Math.max(0.5, 1 - (speed * 0.01));
    latOffset *= speedFactor;
    lngOffset *= speedFactor;
  }
  
  // Apply smoothing if enabled
  if (smoothTransition && window.lastCenterOffsets) {
    const smoothFactor = 0.8; // Higher = smoother but less responsive
    latOffset = window.lastCenterOffsets.lat * smoothFactor + latOffset * (1 - smoothFactor);
    lngOffset = window.lastCenterOffsets.lng * smoothFactor + lngOffset * (1 - smoothFactor);
  }
  
  // Store offsets for next smoothing calculation
  window.lastCenterOffsets = { lat: latOffset, lng: lngOffset };
  
  // Calculate and return the optimal center point
  return {
    lat: userPosition.lat + latOffset,
    lng: userPosition.lng + lngOffset
  };
}
        
function updateDistanceBox() {
  const distanceBox = document.getElementById("distanceBox");
  if (!distanceBox) return;
  
  // Schedule DOM update
  domUpdateManager.schedule("distanceBox", () => {
    // Initial validation
    if (!userMarker || !gameLocations || gameLocations.length === 0) {
      distanceBox.innerText = "Initializing...";
      distanceBox.classList.remove("at-location"); // Remove highlight if present
      return;
    }
    
    // Get user coordinates
    const userLatLng = userMarker.getLatLng();
    let userLat = userLatLng.lat;
    let userLng = userLatLng.lng;
    
    // Coordinate validation
    if (!isFinite(userLat) || !isFinite(userLng)) {
      console.warn("Invalid user coordinates:", userLat, userLng);
      distanceBox.innerText = "Initializing...";
      distanceBox.classList.remove("at-location"); // Remove highlight if present
      return;
    }
    
    // Use map center if at origin
    if (userLat === 0 && userLng === 0) {
      const center = map.getCenter();
      userLat = center.lat;
      userLng = center.lng;
    }
    
    // Find closest location
    let closestDistance = Number.POSITIVE_INFINITY;
    let closestLocation = null;
    const userPos = { lat: userLat, lng: userLng };
    
    for (const location of gameLocations) {
      if (!location || typeof location.lat !== "number" || typeof location.lng !== "number") {
        console.warn("Invalid location data:", location);
        continue;
      }
      const locationPos = { lat: location.lat, lng: location.lng };
      const distance = calculateDistance(userPos, locationPos);
      if (isFinite(distance) && distance < closestDistance) {
        closestDistance = distance;
        closestLocation = location;
      }
    }
    
    // Validate final distance calculation
    if (!isFinite(closestDistance) || closestDistance === Number.POSITIVE_INFINITY) {
      console.warn("Invalid distance calculation:", closestDistance);
      distanceBox.innerText = "Initializing...";
      distanceBox.classList.remove("at-location"); // Remove highlight if present
      return;
    }
    
    // Calculate and display distance
    const distanceFeet = Math.round(closestDistance * 3.28084);
    const distanceText =
      distanceFeet < 5280 ? `${distanceFeet.toLocaleString()} feet` : `${(distanceFeet / 5280).toFixed(2)} miles`;
    distanceBox.innerText = `Closest Stop: ${distanceText}`;
    
    // Add or remove highlight class based on proximity
    if (distanceFeet <= DISTANCE_THRESHOLD) {
      distanceBox.classList.add("at-location"); // Add red border class
    } else {
      distanceBox.classList.remove("at-location"); // Remove highlight if present
    }
    
    // Check if we should show location hunt
    if (distanceFeet <= DISTANCE_THRESHOLD && !isLocationHuntVisible && closestLocation) {
      showLocationHunt(closestLocation);
    }
  });
}

const MAX_RETRIES = 3
const RETRY_DELAY = 1000

function getGeolocationOptions(retryNumber) {
  return {
    enableHighAccuracy: retryNumber < 2,
    timeout: 10000 + retryNumber * 5000,
    maximumAge: retryNumber * 5000,
  }
}
/*
function handleLocationError(error) {
 console.warn("Error getting user location:", error)
 if (retryCount < MAX_RETRIES) {
   retryCount++
   console.log(`Retrying to get location (Attempt ${retryCount} of ${MAX_RETRIES})`)
   setTimeout(() => {
     navigator.geolocation.getCurrentPosition(
       (position) => {
         console.log("Location retrieved successfully after retry")
         hideLoadingMessage()
         updateUserLocation(position, true)
         retryCount = 0
       },
       handleLocationError,
       getGeolocationOptions(retryCount),
     )
   }, RETRY_DELAY * Math.pow(2, retryCount - 1)) // Exponential backoff
   return
 }
 retryCount = 0
 hideLoadingMessage()
 let errorMessage = "An error occurred while getting your location."
 if (error && error.code) {
   switch (error.code) {
     case 1:
       errorMessage = "Please allow access to your location to use this feature."
       // Try to continue with limited functionality
       notifyAppLocationDenied()
       break
     case 2:
       errorMessage = "Your location is currently unavailable. Please try again later."
       // Check if we have a cached location we can use temporarily
       if (localStorage.getItem('lastKnownLocation')) {
         const cachedLocation = JSON.parse(localStorage.getItem('lastKnownLocation'))
         updateUserLocation(cachedLocation, false)
         errorMessage += " Using your last known location for now."
       }
       break
     case 3:
       errorMessage = "Getting your location took too long. Please try again."
       // Register to check when device might have better signal
       if (navigator.connection) {
         navigator.connection.addEventListener('change', checkForReconnection)
       }
       break
   }
 }
 // Log the failure for analytics
 showPopup("Location Error", errorMessage)
}
*/

function handleLocationError(error) {
  console.warn("Error getting user location:", error)
  
  // Store last known good position if available
  if (lastValidPosition) {
    try {
      localStorage.setItem('lastKnownLocation', JSON.stringify(lastValidPosition));
    } catch (e) {
      console.error("Failed to save position to localStorage:", e);
    }
  }
  
  // Handle retry logic with exponential backoff
  if (retryCount < MAX_RETRIES) {
    retryCount++
    console.log(`Retrying to get location (Attempt ${retryCount} of ${MAX_RETRIES})`)
    setTimeout(() => {
      navigator.geolocation.getCurrentPosition(
        (position) => {
          console.log("Location retrieved successfully after retry")
          hideLoadingMessage()
          updateUserLocation(position, true)
          retryCount = 0
        },
        handleLocationError,
        getGeolocationOptions(retryCount),
      )
    }, RETRY_DELAY * (1 << (retryCount - 1))) // Bitwise shift for faster power of 2
    return
  }
  
  // Reset retry counter
  retryCount = 0
  hideLoadingMessage()
  
  // Try IP-based fallback when all retries fail
  if (typeof getFallbackPosition === 'function') {
    console.log("Attempting IP-based location fallback")
    getFallbackPosition().then(position => {
      if (position) {
        showPopup(
          "Using approximate location", 
          "Precise location unavailable. Using approximate location instead."
        )
        updateUserLocation(position, true)
        return // Skip the error-specific handling below
      }
      // Continue with error-specific handling if IP fallback fails
      handleErrorByCode(error)
    }).catch(() => {
      // Also continue with error-specific handling if IP fallback throws
      handleErrorByCode(error)
    })
  } else {
    // No fallback function available, proceed with error-specific handling
    handleErrorByCode(error)
  }
  
  // Local function to handle error by code (keeps everything within the original function)
  function handleErrorByCode(error) {
    let errorMessage = "An error occurred while getting your location."
    if (error && error.code) {
      switch (error.code) {
        case 1:
          errorMessage = "Please allow access to your location to use this feature."
          // Try to continue with limited functionality
          notifyAppLocationDenied()
          break
        case 2:
          errorMessage = "Your location is currently unavailable. Please try again later."
          // Check if we have a cached location we can use temporarily
          try {
            const cachedLocationJson = localStorage.getItem('lastKnownLocation')
            if (cachedLocationJson) {
              const cachedLocation = JSON.parse(cachedLocationJson)
              if (cachedLocation) {
                updateUserLocation(cachedLocation, false)
                errorMessage += " Using your last known location for now."
              }
            }
          } catch (e) {
            console.error("Error parsing cached location:", e)
          }
          break
        case 3:
          errorMessage = "Getting your location took too long. Please try again."
          // Register to check when device might have better signal
          if (navigator.connection && !window._hasConnectionListener) {
            navigator.connection.addEventListener('change', checkForReconnection)
            window._hasConnectionListener = true
          }
          break
      }
    }
    // Log the failure for analytics
    showPopup("Location Error", errorMessage)
  }
}
        
function showPopup(title, message, type = "info", callback = null) {
  const popup = document.createElement("div")
  popup.classList.add("popup")
  popup.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: white;
        padding: 24px;
        border-radius: 16px;
        box-shadow: var(--shadow-lg);
        z-index: 2000;
        text-align: center;
        max-width: 80%;
    `
  const titleElement = document.createElement("h3")
  titleElement.textContent = title
  titleElement.style.cssText = `
        margin-bottom: 16px;
        font-size: 20px;
        font-weight: 600;
        color: var(--dark);
    `
  const messageElement = document.createElement("p")
  messageElement.textContent = message
  messageElement.style.cssText = `
        margin-bottom: 24px;
        font-size: 16px;
        line-height: 1.5;
    `
  const buttonContainer = document.createElement("div")
  buttonContainer.style.cssText = `
        display: flex;
        justify-content: center;
        gap: 12px;
    `
  const okButton = document.createElement("button")
  okButton.textContent = "OK"
  okButton.style.cssText = `
        padding: 10px 24px;
        background-color: var(--primary);
        color: white;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-weight: 500;
        transition: var(--transition-normal);
    `
  okButton.addEventListener("click", () => {
    document.body.removeChild(popup)
    if (callback) callback()
  })

  buttonContainer.appendChild(okButton)

  if (type === "info") {
    const cancelButton = document.createElement("button")
    cancelButton.textContent = "Cancel"
    cancelButton.style.cssText = `
            padding: 10px 24px;
            background-color: #f2f2f2;
            color: var(--dark);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: var(--transition-normal);
        `

    cancelButton.addEventListener("click", () => {
      document.body.removeChild(popup)
    })

    buttonContainer.appendChild(cancelButton)
  }

  popup.appendChild(titleElement)
  popup.appendChild(messageElement)
  popup.appendChild(buttonContainer)
  document.body.appendChild(popup)
}

//Handles notification when location access is denied by the user
function notifyAppLocationDenied() {
  console.log("Location access denied by user");
  
  // Update app state
  const locationStatusElement = document.getElementById('location-status');
  if (locationStatusElement) {
    locationStatusElement.textContent = 'Location access denied';
    locationStatusElement.classList.add('error');
  }
  
  // Store the denied state
  localStorage.setItem('locationPermissionDenied', 'true');
  
  // Show a message to the user
  showPopup("Location Required", "This app needs location access to function properly. Please enable location services in your browser settings.");
}        

// Checks if network conditions have improved to try getting location again
function checkForReconnection() {
  console.log("Network connection changed, checking if we can get location now");
  
  // Only attempt to get location again if we're not already trying
  if (retryCount === 0) {
    // Remove the event listener to avoid multiple calls
    if (navigator.connection) {
      navigator.connection.removeEventListener('change', checkForReconnection);
    }
    
    // Try to get location again
    navigator.geolocation.getCurrentPosition(
      (position) => {
        console.log("Location retrieved successfully after network change");
        updateUserLocation(position, true);
      },
      (error) => {
        console.warn("Still unable to get location after network change:", error);
      },
      {
        enableHighAccuracy: true,
        timeout: 15000,
        maximumAge: 0
      }
    );
  }
}
        
function recenterMap() {
  const recenterButton = document.getElementById("recenterButton")
  recenterButton.style.backgroundColor = "var(--primary)"
  recenterButton.style.color = "var(--white)"

  // Force map to center on user marker immediately
  if (userMarker && userMarker.getLatLng()) {
    map.closePopup()

    // Get dynamic zoom level based on current speed
    const dynamicZoom = calculateZoomLevel(currentSpeed)

    // Use flyTo instead of setView for smoother animation
    map.flyTo(userMarker.getLatLng(), dynamicZoom, {
      duration: 0.5,
    })

    followUser = true

    setTimeout(() => {
      recenterButton.style.backgroundColor = "var(--white)"
      recenterButton.style.color = "var(--primary)"
    }, 500)
  }
}

function addUIEventListeners() {
  document.getElementById("recenterButton").addEventListener("click", () => {
    recenterMap()
    resetInactivityTimer()
  })
  document.getElementById("returnButton").addEventListener("click", () => {
    returnToIndex()
    resetInactivityTimer()
  })
  document.getElementById("tipsButton").addEventListener("click", () => {
    toggleNavigationTips()
    resetInactivityTimer()
  })
  document.querySelector(".navigation-tips .close-button").addEventListener("click", () => {
    closeNavigationTips()
    resetInactivityTimer()
  })
}

function addMapEventListeners() {
  const startInteraction = () => {
    isMapInteracting = true
    userIsInteracting = true
    followUser = false
    resetInactivityTimer()
  }

  map.on("movestart zoomstart dragstart", startInteraction)
}

// Reset inactivity timer
function resetInactivityTimer() {
  clearTimeout(inactivityTimer)
  inactivityTimer = setTimeout(checkInactivity, INACTIVITY_TIMEOUT)
}

// Check for user inactivity
function checkInactivity() {
  console.log("Inactivity timer triggered")
  isMapInteracting = false
  userIsInteracting = false

  // Close any open popups
  map.closePopup()
  map.eachLayer((layer) => {
    if (layer.getPopup && layer.getPopup()?.isOpen()) {
      layer.closePopup()
    }
  })

  if (!isMapInteracting && !userIsInteracting) {
    recenterMap()
  }
}

let lastVisitTime = 0
const cooldownPeriod = 3 * 60 * 1000

function showLocationHunt(location) {
  const now = performance.now()
  if (location.id === lastVisitedLocationId && now - lastVisitTime < 180000) {
    console.log(`Location ${location.id} is on cooldown. Skipping.`)
    return
  }

  lastVisitedLocationId = location.id
  lastVisitTime = now
  isLocationHuntVisible = true

  domUpdateManager.schedule("locationHunt", () => {
    const lochuntContainer = document.querySelector(".lochunt-container")
    if (!lochuntContainer) return

    lochuntContainer.innerHTML = ""
    lochuntContainer.style.cssText = `
      display: flex;
      flex-direction: column;
      height: 100%;
      overflow: hidden;
      background-color: #fff;
      max-width: 1200px;
      margin: 0 auto;
      box-shadow: 0 2px 20px rgba(0,0,0,0.025);
      will-change: transform;
    `

    const scrollableContent = document.createElement("div")
    scrollableContent.style.cssText = `
      flex: 1;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      scroll-behavior: smooth;
      will-change: scroll-position;
    `

    const locationImage = document.createElement("img")
    if (preloadedImages.has(location.image)) {
      locationImage.src = location.image
    } else {
      locationImage.src = location.image
      const img = new Image()
      img.crossOrigin = "anonymous"
      img.src = location.image
      preloadedImages.set(location.image, img)
    }
    locationImage.alt = location.name
    locationImage.style.cssText = `
      width: 100%;
      height: 45vh;
      object-fit: cover;
      object-position: center;
    `

    scrollableContent.appendChild(locationImage)

    const contentContainer = document.createElement("div")
    contentContainer.classList.add("lochunt-content")
    contentContainer.style.cssText = `
      padding: 24px;
      display: flex;
      flex-direction: column;
      align-items: center;
      max-width: 800px;
      margin: 0 auto;
    `
    const locationInfo = document.createElement("div")
    locationInfo.classList.add("lochunt-info")
    locationInfo.style.cssText = `
      text-align: center;
      width: 100%;
      margin-bottom: 15px;
    `
    const locationName = document.createElement("h1")
    locationName.textContent = location.name
    locationName.style.cssText = `
      font-size: clamp(1.8rem, 4vw, 2.5rem);
      font-weight: 700;
      color: #1a1a1a;
      margin-bottom: 8px;
      line-height: 1.2;
    `
    const locationCity = document.createElement("p")
    locationCity.textContent = `${location.city}`
    locationCity.style.cssText = `
      font-size: clamp(1.1rem, 2vw, 1.3rem);
      color: #ff0000;
      font-weight: 600;
      margin-bottom: 4px;
    `
    const locationCreator = document.createElement("p")
    locationCreator.textContent = `Created by: ${location.creator}`
    locationCreator.style.cssText = `
      font-size: calc(0.9rem + 0.4vw);
      color: #666666;
      font-weight: 500;
    `
    locationInfo.appendChild(locationName)
    locationInfo.appendChild(locationCity)
    locationInfo.appendChild(locationCreator)
    contentContainer.appendChild(locationInfo)
    const audioPlayerContainer = createAudioPlayer(location.audio)
    contentContainer.appendChild(audioPlayerContainer)
    scrollableContent.appendChild(contentContainer)
    lochuntContainer.appendChild(scrollableContent)
    const blueBar = createBlueBar(location)
    blueBar.style.cssText += `
      position: sticky;
      bottom: 0;
      width: 100%;
    `
    lochuntContainer.appendChild(blueBar)

    requestAnimationFrame(initAudioPlayer)
  })
}

function createAudioPlayer(audioSrc) {
  const audioPlayerContainer = document.createElement("div")
  audioPlayerContainer.classList.add("audio-player")
  audioPlayerContainer.style.cssText = `
    width: 100%;
    max-width: 400px;
    margin-bottom: 15px;
  `

  const audio = document.createElement("audio")
  audio.id = "locationAudio"

  if (preloadedAudio.has(audioSrc)) {
    audio.src = audioSrc
  } else {
    audio.src = audioSrc
    const audioPreload = new Audio()
    audioPreload.preload = "auto"
    audioPreload.src = audioSrc
    preloadedAudio.set(audioSrc, audioPreload)
  }

  const audioProgress = document.createElement("div")
  audioProgress.classList.add("audio-progress")
  audioProgress.style.cssText = `
    width: 100%;
    margin-bottom: 15px;
  `

  const progressContainer = document.createElement("div")
  progressContainer.classList.add("progress")
  progressContainer.style.cssText = `
    height: 8px;
    background-color: #e2e8f0;
    border-radius: 4px;
    cursor: pointer;
    margin-bottom: 12px;
    overflow: hidden;
  `

  const progressBar = document.createElement("div")
  progressBar.id = "progressBar"
  progressBar.classList.add("progress-bar")
  progressBar.style.cssText = `
    height: 100%;
    background-color: #ff0000;
    width: 0%;
    transition: width 0.1s linear;
  `

  progressContainer.appendChild(progressBar)
  audioProgress.appendChild(progressContainer)

  const timeInfo = document.createElement("div")
  timeInfo.classList.add("audio-time")
  timeInfo.style.cssText = `
    display: flex;
    justify-content: space-between;
    color: #4a5568;
    font-size: 0.875rem;
    margin-bottom: 16px;
    font-weight: 500;
  `

  const currentTimeSpan = document.createElement("span")
  currentTimeSpan.id = "currentTime"
  currentTimeSpan.textContent = "0:00"

  const durationSpan = document.createElement("span")
  durationSpan.id = "duration"
  durationSpan.textContent = "0:00"

  timeInfo.appendChild(currentTimeSpan)
  timeInfo.appendChild(durationSpan)

  const audioControls = document.createElement("div")
  audioControls.classList.add("audio-controls")
  audioControls.style.cssText = `
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 24px;
  `

  const rewindBtn = createAudioButton("skip-backward", "rewindBtn")
  const playPauseBtn = createAudioButton("play", "playPauseBtn")
  const forwardBtn = createAudioButton("skip-forward", "forwardBtn")

  audioControls.appendChild(rewindBtn)
  audioControls.appendChild(playPauseBtn)
  audioControls.appendChild(forwardBtn)

  audioPlayerContainer.appendChild(audio)
  audioPlayerContainer.appendChild(audioProgress)
  audioPlayerContainer.appendChild(timeInfo)
  audioPlayerContainer.appendChild(audioControls)

  return audioPlayerContainer
}

function createAudioButton(iconName, id) {
  const button = document.createElement("button")
  button.id = id
  button.classList.add("audio-button")
  button.innerHTML = `<i class="bi bi-${iconName}"></i>`
  button.style.cssText = `
    background-color: white;
    color: #0000ff;
    border: 2px solid #0000ff;
    border-radius: 50%;
    width: 55px;
    height: 55px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.3s ease;
  `

  button.addEventListener("mouseover", () => {
    button.style.backgroundColor = "rgba(0, 0, 255, 0.1)"
  })

  button.addEventListener("mouseout", () => {
    button.style.backgroundColor = "white"
  })

  button.addEventListener("click", () => {
    button.style.backgroundColor = "#0000ff"
    button.style.color = "white"
    button.style.transform = "scale(0.95)"

    setTimeout(() => {
      button.style.backgroundColor = "white"
      button.style.color = "#0000ff"
      button.style.transform = "scale(1)"
    }, 200)
  })

  return button
}

function createBlueBar(location) {
  const blueBar = document.createElement("div")
  blueBar.style.cssText = `
    width: 100%;
    height: 60px;
    background: linear-gradient(to right, #0a1f80, #0f2bab);
    margin-top: auto;
    box-shadow: 0 -2px 10px rgba(0,0,0,0.025);
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0 24px;
    position: sticky;
    bottom: 0;
  `

  const infoButton = document.createElement("button")
  infoButton.innerHTML = '<i class="bi bi-info-circle-fill text-white" style="font-size: 1.5rem; z-index: 2500;"></i>'
  infoButton.classList.add("btn", "btn-sm", "me-2")
  infoButton.onclick = () => {
    if (location && location.imageSource) {
      showPopup("Image Source", location.imageSource)
    } else {
      showPopup("Image Source", "Image source information is not available")
    }
  }

  const feedbackButton = document.createElement("a")
  feedbackButton.href = "mailto:mattreicher@protonmail.com?subject=Feedback"
  feedbackButton.target = "_blank"
  feedbackButton.rel = "noopener noreferrer"
  feedbackButton.innerHTML = '<i class="bi bi-envelope-fill text-white" style="font-size: 1.5rem;"></i>'
  feedbackButton.classList.add("btn", "btn-sm")

  blueBar.appendChild(infoButton)
  blueBar.appendChild(feedbackButton)
  return blueBar
}

function initAudioPlayer() {
  const audio = document.getElementById("locationAudio")
  const playPauseBtn = document.getElementById("playPauseBtn")
  const rewindBtn = document.getElementById("rewindBtn")
  const forwardBtn = document.getElementById("forwardBtn")
  const progressBar = document.getElementById("progressBar")
  const progressContainer = document.querySelector(".progress")
  const currentTimeSpan = document.getElementById("currentTime")
  const durationSpan = document.getElementById("duration")

  if (
    !audio ||
    !playPauseBtn ||
    !rewindBtn ||
    !forwardBtn ||
    !progressBar ||
    !progressContainer ||
    !currentTimeSpan ||
    !durationSpan
  ) {
    console.warn("Audio player elements not found, retrying...")
    requestAnimationFrame(initAudioPlayer)
    return
  }

  let lastProgressUpdate = 0
  const PROGRESS_UPDATE_INTERVAL = 250

  playPauseBtn.addEventListener("click", togglePlay)
  rewindBtn.addEventListener("click", () => seek(-10))
  forwardBtn.addEventListener("click", () => seek(10))

  audio.addEventListener("timeupdate", () => {
    const now = Date.now()
    if (now - lastProgressUpdate > PROGRESS_UPDATE_INTERVAL) {
      lastProgressUpdate = now
      updateProgress()
    }
  })

  audio.addEventListener("loadedmetadata", setDuration)
  audio.addEventListener("ended", () => {
    domUpdateManager.schedule("playPauseBtn", () => {
      playPauseBtn.innerHTML = '<i class="bi bi-play"></i>'
    })
    showAdditionalInfo()
  })

  progressContainer.addEventListener("click", setProgress)

  function togglePlay() {
    if (audio.paused) {
      const playPromise = audio.play()
      if (playPromise !== undefined) {
        playPromise
          .then(() => {
            domUpdateManager.schedule("playPauseBtn", () => {
              playPauseBtn.innerHTML = '<i class="bi bi-pause"></i>'
            })
          })
          .catch((error) => {
            console.error("Audio playback failed:", error)
          })
      }
    } else {
      audio.pause()
      domUpdateManager.schedule("playPauseBtn", () => {
        playPauseBtn.innerHTML = '<i class="bi bi-play"></i>'
      })
    }
  }

  function seek(seconds) {
    audio.currentTime = Math.max(0, Math.min(audio.currentTime + seconds, audio.duration))
  }

  function updateProgress() {
    const percent = (audio.currentTime / audio.duration) * 100
    domUpdateManager.schedule("audioProgress", () => {
      progressBar.style.width = `${percent}%`
      currentTimeSpan.textContent = formatTime(audio.currentTime)
    })
  }

  function setProgress(e) {
    const width = this.clientWidth
    const clickX = e.offsetX
    const duration = audio.duration
    audio.currentTime = (clickX / width) * duration
  }

  function setDuration() {
    domUpdateManager.schedule("audioDuration", () => {
      durationSpan.textContent = formatTime(audio.duration)
    })
  }

  function formatTime(time) {
    const minutes = Math.floor(time / 60)
    const seconds = Math.floor(time % 60)
    return `${minutes}:${seconds.toString().padStart(2, "0")}`
  }
}

function showAdditionalInfo() {
    // Find the location using lastVisitedLocationId
    const location = gameLocations.find(loc => loc.id === lastVisitedLocationId);
    console.log('Current location:', location);
    
    // Set flag to indicate we're returning from exhibit
    isReturningFromExhibit = true;
    
    domUpdateManager.schedule('additionalInfo', () => {
        const additionalInfoContainer = document.querySelector('.additional-info-container');
        if (!additionalInfoContainer) {
            console.error("Additional info container not found");
            return;
        }
        
        additionalInfoContainer.style.display = 'block';
        
        // Add transition class
        additionalInfoContainer.classList.add('location-transition');
        
        // Trigger reflow to ensure transition works
        void additionalInfoContainer.offsetWidth;
        
        // Make visible with transition
        additionalInfoContainer.classList.add('visible');
        
        const additionalInfoElement = document.getElementById('additionalInfo');
        if (additionalInfoElement && location) {
            additionalInfoElement.textContent = location.additionalInfo;
        }

        const continueButton = document.getElementById('continueButton');
        if (continueButton) {
            continueButton.onclick = () => {
                // Fade out with transition
                additionalInfoContainer.classList.remove('visible');
                
                // Hide after transition completes
                setTimeout(() => {
                    additionalInfoContainer.style.display = 'none';
                    
                    // Also hide location hunt container with transition
                    const lochuntContainer = document.querySelector('.lochunt-container');
                    if (lochuntContainer) {
                        lochuntContainer.classList.remove('visible');
                        
                        setTimeout(() => {
                            lochuntContainer.style.display = 'none';
                            isLocationHuntVisible = false;
                            updateDistanceBox();
                        }, 500);
                    }
                }, 500);
            };
        }
    });
}

function showErrorMessage(message) {
    const errorContainer = document.createElement('div');
    errorContainer.className = 'error-message';
    errorContainer.style.cssText = `
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background-color: #ff3b30;
        color: white;
        padding: 12px 20px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        z-index: 2000;
        max-width: 90%;
        text-align: center;
        font-weight: 500;
    `;
    errorContainer.textContent = message;
    
    document.body.appendChild(errorContainer);
    
    // Auto-dismiss after 5 seconds
    setTimeout(() => {
        errorContainer.style.opacity = '0';
        errorContainer.style.transition = 'opacity 0.5s ease';
        
        setTimeout(() => {
            if (errorContainer.parentNode) {
                errorContainer.parentNode.removeChild(errorContainer);
            }
        }, 500);
    }, 5000);
}

function toggleNavigationTips() {
  const tipsElement = document.querySelector(".navigation-tips")
  const computedStyle = window.getComputedStyle(tipsElement)

  if (computedStyle.display === "none") {
    tipsElement.style.display = "block"
  } else {
    tipsElement.style.display = "none"
  }

  document.getElementById("tipsButton").classList.toggle("active")
}

function closeNavigationTips() {
  document.querySelector(".navigation-tips").style.display = "none"
  document.getElementById("tipsButton").classList.remove("active")
}

// Wait for both DOM and window load events to be safe
document.addEventListener('DOMContentLoaded', function() {
  startPreloader();
});

function startPreloader() {
  // Add preloading of critical assets
  const preloaderAssets = [
    'https://www.mnthen.com/images/logo.webp',
    'https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css',
    'https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.css'
  ];
  
  // Preload critical assets
  preloaderAssets.forEach(asset => {
    const link = document.createElement(asset.endsWith('.css') ? 'link' : 'img');
    if (asset.endsWith('.css')) {
      link.rel = 'stylesheet';
      link.href = asset;
    } else {
      link.src = asset;
    }
    document.head.appendChild(link);
  });
  
  const preloader = document.getElementById('preloader');
  const progressBar = document.getElementById('preloaderProgress');
  
  if (!preloader || !progressBar) {
    console.error('Preloader elements not found');
    return;
  }
  
  // Reset and show preloader
  preloader.style.display = 'flex';
  preloader.style.opacity = '1';
  progressBar.style.width = '0%';
  
  console.log('Preloader started at:', new Date().toISOString());
  const startTime = Date.now();
  const EXACT_DURATION = 10000; // 10 seconds
  
  // Set up the animation
  progressBar.style.transition = 'none'; // Reset transition
  void progressBar.offsetWidth; // Force layout recalc
  progressBar.style.transition = 'width 0.3s cubic-bezier(0.4, 0.0, 0.2, 1)';
  
  // Use requestAnimationFrame for smoother animation
  let animationId;
  
  function updateProgress() {
    // Calculate elapsed time since start
    const elapsedTime = Date.now() - startTime;
    
    // Calculate what percentage of our 10 seconds has elapsed
    let progressPercentage = Math.min((elapsedTime / EXACT_DURATION) * 100, 99);
    
    // Update progress bar width
    progressBar.style.width = progressPercentage + '%';
    
    // Continue animation if we haven't reached 10 seconds yet
    if (elapsedTime < EXACT_DURATION) {
      animationId = requestAnimationFrame(updateProgress);
    }
  }
  
  // Start the animation
  animationId = requestAnimationFrame(updateProgress);
  
  // Force the preloader to stay for EXACTLY 10 seconds
  setTimeout(function() {
    // Cancel any ongoing animation
    if (animationId) {
      cancelAnimationFrame(animationId);
    }
    
    // Log the exact time when we're completing
    const actualDuration = Date.now() - startTime;
    console.log('Preloader completing after:', actualDuration, 'ms');
    
    // Ensure progress bar is at 100%
    progressBar.style.width = '100%';
    
    // Wait a small amount of time for the progress bar to reach 100%
    setTimeout(function() {
      // Fade out the preloader
      preloader.style.opacity = '0';
      
      // Remove from DOM after fade completes
      setTimeout(function() {
        preloader.style.display = 'none';
        console.log('Preloader hidden at:', new Date().toISOString());
        
        // Update distance box immediately after preloader is hidden
        updateDistanceBox();
        
        // Call it a second time after a short delay in case user position wasn't ready immediately
        setTimeout(updateDistanceBox, 500);
      }, 500);
    }, 200);
  }, EXACT_DURATION); // Exactly 10 seconds
  
  // Additional safeguard - force check at 10.5 seconds to ensure it's completed
  setTimeout(function() {
    const finalDuration = Date.now() - startTime;
    console.log('Final safeguard check after:', finalDuration, 'ms');
    
    if (preloader.style.opacity !== '0') {
      console.log('Forcing preloader completion');
      preloader.style.opacity = '0';
      
      setTimeout(function() {
        preloader.style.display = 'none';
        // Also update distance box here as a safeguard
        updateDistanceBox();
      }, 500);
    }
  }, EXACT_DURATION + 500); // 10.5 seconds
}
        
function getMarkerColor(tours) {
  switch (tours.toLowerCase()) {
    case "person":
      return "#FFA500"
    case "gangster":
      return "#3f9b0b"
    case "event":
      return "#8B0000"
    case "place":
      return "#0f2bab"
    default:
      return "#0f2bab"
  }
}

function loadAllLocations() {
    gameLocations.forEach((location, index) => {
        const markerColor = getMarkerColor(location.tours);
        
        const locationMarker = L.marker([location.lat, location.lng], {
            icon: L.divIcon({
                className: 'custom-pin-icon',
                html: `<div class="pin-head" style="background-color: ${markerColor};">
                       </div>`,
                iconSize: [30, 30],
                iconAnchor: [15, 30],
            })
        });
                
        const popupContent = `
            <div class="popup-content">
                <img src="${location.image}" alt="${location.name}" class="location-image">
                <h4 class="location-name">
                    <a href="${location.link}" target="_blank" rel="noopener noreferrer" style="text-decoration: none; color: inherit;">${location.name}</a>
                </h4>
                <div class="popup-buttons">
                    <button class="button route-button" data-lat="${location.lat}" data-lng="${location.lng}">Directions</button>
                    <button class="button summary-button" data-location-id="${location.id}">Summary</button>
                </div>
            </div>
        `;
        locationMarker.bindPopup(popupContent, {
            offset: L.point(0, -25),
            className: 'custom-popup'
        });
        
        locationMarker.on('popupopen', function(e) {
            const popup = e.popup._contentNode;
            const routeButton = popup.querySelector('.route-button');
            const summaryButton = popup.querySelector('.summary-button');
            
            if (routeButton) {
                routeButton.addEventListener('click', function(event) {
                    event.preventDefault();
                    const lat = this.getAttribute('data-lat');
                    const lng = this.getAttribute('data-lng');
                    
                    // Create and show the modal
                    const modal = document.createElement('div');
                    modal.className = 'modal';
                    modal.innerHTML = `
                        <div class="modal-content">
                            <h3>Choose your preferred navigation app:</h3>
                            <div class="modal-buttons">
                                <button class="modal-button google-maps">
                                    Google Maps
                                </button>
                                <button class="modal-button waze">
                                    Waze
                                </button>
                                <button class="modal-button apple-maps">
                                    Apple Maps
                                </button>
                                <button class="modal-button cancel">Cancel</button>
                            </div>
                        </div>
                    `;

// direction modal styles
if (!document.querySelector('#modal-styles')) {
    const style = document.createElement('style');
    style.id = 'modal-styles';
    style.textContent = `
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.75);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            padding: 16px;
            backdrop-filter: blur(4px);
        }
        .modal-content {
            background: white;
            padding: 24px 16px;
            border-radius: 16px;
            width: 100%;
            max-width: 320px;
            text-align: center;
            box-shadow: 0 20px 40px rgba(0,0,0,0.2);
        }
        .modal-buttons {
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            align-items: center;
        }
        .modal-button {
            padding: 16px;
            border-radius: 12px;
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: 500;
            border: none;
            cursor: pointer;
            transition: transform 0.15s ease;
        }
        .modal-button:active {
            transform: scale(0.98);
        }
        .google-maps {
            background: #4285F4;
            color: white;
            box-shadow: 0 2px 8px rgba(66,133,244,0.3);
        }
        .waze {
            background: #33ccff;
            color: white;
            box-shadow: 0 2px 8px rgba(51,204,255,0.3);
        }
        .apple-maps {
            background: #000000;
            color: white;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
        .cancel {
            background: #f2f2f2;
            color: #666;
        }
    `;
    document.head.appendChild(style);
}

                    document.body.appendChild(modal);

                    // Handle button clicks
                    modal.querySelector('.google-maps').addEventListener('click', () => {
                        window.location.href = `https://www.google.com/maps/dir/?api=1&destination=${lat},${lng}`;
                        modal.remove();
                    });

                    modal.querySelector('.waze').addEventListener('click', () => {
                        window.location.href = `https://www.waze.com/ul?ll=${lat}%2C${lng}&navigate=yes`;
                        modal.remove();
                    });

                    modal.querySelector('.apple-maps').addEventListener('click', () => {
                        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
                        if (isIOS) {
                            window.location.href = `maps://maps.apple.com/?daddr=${lat},${lng}`;
                            modal.remove();
                        } else {
                            const alertEl = document.createElement('div');
                            alertEl.className = 'modal';
                            alertEl.innerHTML = `
                                <div class="modal-content">
                                    <p>Apple Maps is only available on iOS devices</p>
                                    <button class="modal-button">OK</button>
                                </div>
                            `;
                            document.body.appendChild(alertEl);
                            alertEl.querySelector('button').onclick = () => {
                                alertEl.remove();
                                // Don't remove the original modal when showing the alert
                                return false;
                            };
                        }
                    });
                    
                    modal.querySelector('.cancel').addEventListener('click', () => {
                        modal.remove();
                    });

                    // Close modal if clicking outside
                    modal.addEventListener('click', (e) => {
                        if (e.target === modal) {
                            modal.remove();
                        }
                    });
                });
            }
            
            if (summaryButton) {
                summaryButton.addEventListener('click', function(event) {
                    event.preventDefault();
                    const locationId = this.getAttribute('data-location-id');
                    showLocationSummary(locationId);
                });
            }
        });
        
        markerClusterGroup.addLayer(locationMarker);
    });
    map.addLayer(markerClusterGroup);
    updateDistanceBox();
    resetInactivityTimer();
} 

function returnToIndex() {
  // Create popup with proper centering and animation
  const popupDiv = document.createElement("div");
  popupDiv.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,0.6);
    backdrop-filter: blur(4px);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
    opacity: 0;
    transition: opacity 0.3s ease;
  `;
  // Using #1a3a8a as the dark blue color
  const darkBlue = "#1a3a8a";
  const darkBlueHover = "#0d2c6e";
  popupDiv.innerHTML = `
    <div class="modal-container" style="
      background-color: white;
      border-radius: 16px;
      padding: 28px;
      width: 90%;
      max-width: 420px;
      max-height: 90vh;
      box-shadow: 0 15px 40px rgba(0,0,0,0.2);
      margin: auto;
      transform: translateY(20px);
      transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      overflow: hidden;
      display: flex;
      flex-direction: column;
    ">
      <div style="
        text-align: center;
        margin-bottom: 25px;
      ">
        <svg width="50" height="50" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <circle cx="12" cy="12" r="10" stroke="${darkBlue}" stroke-width="1.5"/>
          <path d="M12 8V13" stroke="${darkBlue}" stroke-width="2" stroke-linecap="round"/>
          <circle cx="12" cy="16" r="1" fill="${darkBlue}"/>
        </svg>
      </div>
      <h3 style="
        text-align: center;
        margin: 0 0 15px 0;
        color: #2c3e50;
        font-size: 1.5rem;
        font-weight: 600;
      ">Ready to Leave?</h3>
      <div style="flex-grow: 1; overflow-y: auto; padding: 0 10px;">
        <p style="
          text-align: center;
          margin: 0 0 30px 0;
          color: #5c6c7c;
          line-height: 1.5;
          font-size: 1rem;
        ">Are you sure you want to return to the main page?</p>
      </div>
      <div style="
        display: flex;
        justify-content: center;
        gap: 15px;
        margin-bottom: 15px;
      ">
        <button class="confirm-btn" style="
          padding: 14px 24px;
          background-color: ${darkBlue};
          color: white;
          border: none;
          border-radius: 10px;
          cursor: pointer;
          font-size: 1rem;
          font-weight: 600;
          min-width: 130px;
          transition: all 0.2s ease;
        ">Yes, Exit</button>
        <button class="cancel-btn" style="
          padding: 14px 24px;
          background-color: transparent;
          color: ${darkBlue};
          border: 1.5px solid ${darkBlue};
          border-radius: 10px;
          cursor: pointer;
          font-size: 1rem;
          font-weight: 600;
          min-width: 130px;
          transition: all 0.2s ease;
        ">Stay Here</button>
      </div>
      <div style="text-align: center; margin-top: 15px;">
        <a href="#" class="credits-link" style="
          display: inline-block;
          text-align: center;
          color: #64748b;
          text-decoration: none;
          font-size: 0.9rem;
          padding: 8px 20px;
          border-radius: 100px;
          border: 1px solid rgba(100, 116, 139, 0.2);
          background-color: rgba(100, 116, 139, 0.05);
          transition: all 0.2s ease;
        ">View Acknowledgements</a>
      </div>
    </div>
  `;
  document.body.appendChild(popupDiv);
  // Trigger animation
  setTimeout(() => {
    popupDiv.style.opacity = "1";
    popupDiv.querySelector(".modal-container").style.transform = "translateY(0)";
  }, 10);
  // Button hover effects
  const confirmBtn = popupDiv.querySelector(".confirm-btn");
  confirmBtn.addEventListener("mouseover", function() {
    this.style.backgroundColor = darkBlueHover;
  });
  confirmBtn.addEventListener("mouseout", function() {
    this.style.backgroundColor = darkBlue;
  });
  const cancelBtn = popupDiv.querySelector(".cancel-btn");
  cancelBtn.addEventListener("mouseover", function() {
    this.style.backgroundColor = "rgba(26, 58, 138, 0.05)";
  });
  cancelBtn.addEventListener("mouseout", function() {
    this.style.backgroundColor = "transparent";
  });
  const creditsLink = popupDiv.querySelector(".credits-link");
  creditsLink.addEventListener("mouseover", function() {
    this.style.backgroundColor = "rgba(100, 116, 139, 0.1)";
    this.style.borderColor = "rgba(100, 116, 139, 0.3)";
  });
  creditsLink.addEventListener("mouseout", function() {
    this.style.backgroundColor = "rgba(100, 116, 139, 0.05)";
    this.style.borderColor = "rgba(100, 116, 139, 0.2)";
  });
  // Event listeners
  confirmBtn.addEventListener("click", function() {
    popupDiv.style.opacity = "0";
    popupDiv.querySelector(".modal-container").style.transform = "translateY(20px)";
    setTimeout(() => {
      document.body.removeChild(popupDiv);
      window.location.href = "/index.html";
    }, 300);
  });
  cancelBtn.addEventListener("click", function() {
    popupDiv.style.opacity = "0";
    popupDiv.querySelector(".modal-container").style.transform = "translateY(20px)";
    setTimeout(() => {
      document.body.removeChild(popupDiv);
    }, 300);
  });
  creditsLink.addEventListener("click", function(e) {
    e.preventDefault();
    // Simplified credits popup with dark blue
    const creditsPopup = document.createElement("div");
    creditsPopup.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.7);
      backdrop-filter: blur(6px);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1001;
      opacity: 0;
      transition: opacity 0.3s ease;
    `;
    creditsPopup.innerHTML = `
      <div class="credits-container" style="
        background-color: white;
        border-radius: 16px;
        width: 92%;
        max-width: 450px;
        max-height: 80vh;
        box-shadow: 0 20px 50px rgba(0,0,0,0.25);
        margin: auto;
        transform: translateY(20px);
        transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        overflow: hidden;
        display: flex;
        flex-direction: column;
      ">
        <div style="
          background-color: ${darkBlue};
          padding: 20px;
          color: white;
          text-align: center;
        ">
          <h3 style="margin: 0; font-size: 1.5rem; font-weight: 600;">Acknowledgements</h3>
        </div>
        <div style="
          padding: 20px;
          flex-grow: 1;
          overflow-y: auto;
        ">
          <ul style="list-style-type: none; padding: 0; margin: 0;">
            <li style="margin-bottom: 20px;">
              <strong style="color: #1e293b; font-size: 1.05rem;">OpenStreetMap</strong>
              <p style="color: #64748b; margin: 5px 0 0 0; font-size: 0.9rem; line-height: 1.5;">
                Providing the map data and tiles for this interactive experience.
              </p>
            </li>
            <li style="margin-bottom: 20px;">
              <strong style="color: #1e293b; font-size: 1.05rem;">Minnesota Historical Society</strong>
              <p style="color: #64748b; margin: 5px 0 0 0; font-size: 0.9rem; line-height: 1.5;">
                For their invaluable historical data, photographs, and archive materials.
              </p>
            </li>
            <li style="margin-bottom: 20px;">
              <strong style="color: #1e293b; font-size: 1.05rem;">Metropolitan State University</strong>
              <p style="color: #64748b; margin: 5px 0 0 0; font-size: 0.9rem; line-height: 1.5;">
                For fostering a passion for history and research methodology.
              </p>
            </li>
            <li style="margin-bottom: 20px;">
              <strong style="color: #1e293b; font-size: 1.05rem;">Leaflet.js</strong>
              <p style="color: #64748b; margin: 5px 0 0 0; font-size: 0.9rem; line-height: 1.5;">
                The open-source JavaScript library that powers the mapping features.
              </p>
            </li>
            <li>
              <strong style="color: #1e293b; font-size: 1.05rem;">All Contributors</strong>
              <p style="color: #64748b; margin: 5px 0 0 0; font-size: 0.9rem; line-height: 1.5;">
                Researchers, testers, and developers who made this project possible.
              </p>
            </li>
          </ul>
        </div>
        <div style="padding: 15px; text-align: center; border-top: 1px solid #eee;">
          <button class="close-credits-btn" style="
            padding: 12px 30px;
            background-color: ${darkBlue};
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 0.95rem;
            font-weight: 600;
            transition: background-color 0.2s ease;
          ">Close</button>
        </div>
      </div>
    `;
    document.body.appendChild(creditsPopup);
    // Trigger animation
    setTimeout(() => {
      creditsPopup.style.opacity = "1";
      creditsPopup.querySelector(".credits-container").style.transform = "translateY(0)";
    }, 10);
    // Close button interaction
    const closeBtn = creditsPopup.querySelector(".close-credits-btn");
    closeBtn.addEventListener("mouseover", function() {
      this.style.backgroundColor = darkBlueHover;
    });
    closeBtn.addEventListener("mouseout", function() {
      this.style.backgroundColor = darkBlue;
    });
    closeBtn.addEventListener("click", function() {
      creditsPopup.style.opacity = "0";
      creditsPopup.querySelector(".credits-container").style.transform = "translateY(20px)";
      setTimeout(() => {
        document.body.removeChild(creditsPopup);
      }, 300);
    });
  });
  document.getElementById("returnButton").classList.remove("active");
}

function showLocationSummary(locationId) {
    console.log("Showing summary for location ID:", locationId);
    
    const location = gameLocations.find(loc => loc.id === locationId);
    console.log("Found location:", location);
    
    if (location && location.summary) {
        domUpdateManager.schedule('summaryModal', () => {
            const modal = document.getElementById('summaryModal');
            const summaryContent = document.getElementById('summaryContent');
            
            if (!modal || !summaryContent) {
                console.error("Summary modal elements not found");
                return;
            }
            
            // Improved modal background with subtle animation
            modal.style.backgroundColor = 'rgba(0, 0, 0, 0.75)';
            modal.style.display = 'flex';
            modal.style.justifyContent = 'center';
            modal.style.alignItems = 'center';
            modal.style.backdropFilter = 'blur(5px)';
            modal.style.transition = 'opacity 0.3s ease';
            modal.style.opacity = '0';
            setTimeout(() => { modal.style.opacity = '1'; }, 10);
            
            const modalContent = modal.querySelector('.modal-content');
            if (modalContent) {
                modalContent.style.cssText = `
                    background-color: white;
                    padding: 30px;
                    border-radius: 15px;
                    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
                    max-width: 500px;
                    width: 90%;
                    max-height: 80vh;
                    overflow-y: auto;
                    position: relative;
                    transform: translateY(0);
                    transition: transform 0.3s ease-out;
                    border: 1px solid rgba(230, 230, 230, 0.9);
                `;
            }
            
            const closeBtn = modal.querySelector('.close');
            if (closeBtn) {
                closeBtn.remove();
            }
            
            // Dark blue color scheme to match map buttons
            const darkBlue = '#1a3b5d';
            const lightBlue = '#e8f0f8';
            
            summaryContent.style.textAlign = 'left';
            summaryContent.innerHTML = `
                <div class="location-header" style="
                    margin: -30px -30px 20px -30px;
                    padding: 20px 30px;
                    background: ${darkBlue};
                    border-radius: 15px 15px 0 0;
                ">
                    <h3 class="summary-heading" style="
                        font-size: 24px;
                        margin: 0;
                        color: white;
                        text-align: center;
                        font-weight: 700;
                        text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
                    ">${location.name}</h3>
                </div>
                
                <p style="
                    line-height: 1.65;
                    margin-bottom: 18px;
                    color: #333;
                    font-size: 16px;
                ">
                    ${location.summary}
                </p>
                
                <div style="
                    background: ${lightBlue};
                    padding: 15px;
                    border-radius: 10px;
                    border-left: 4px solid ${darkBlue};
                    margin-bottom: 20px;
                ">
                    <p style="
                        line-height: 1.6;
                        margin: 0;
                        display: flex;
                        align-items: center;
                    ">
                        <strong style="color: ${darkBlue};">Location:</strong>
                        <span style="margin-left: 8px;">${location.today}</span>
                    </p>
                </div>
            `;
            
            const continueButton = document.createElement('button');
            continueButton.textContent = 'Continue';
            continueButton.className = 'summary-button';
            continueButton.style.cssText = `
                display: block;
                width: auto;
                padding: 12px 30px;
                color: white;
                background-color: ${darkBlue};
                border: none;
                border-radius: 10px;
                cursor: pointer;
                font-size: 18px;
                font-weight: bold;
                transition: all 0.3s ease;
                margin: 10px auto -15px;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.12);
            `;
            
            continueButton.onmouseover = function() {
                this.style.transform = 'translateY(-2px)';
                this.style.boxShadow = '0 6px 10px rgba(0, 0, 0, 0.15)';
                this.style.backgroundColor = '#254b73';  // Slightly lighter blue on hover
            };
            
            continueButton.onmouseout = function() {
                this.style.transform = 'translateY(0)';
                this.style.boxShadow = '0 4px 6px rgba(0, 0, 0, 0.12)';
                this.style.backgroundColor = darkBlue;
            };
            
            continueButton.onclick = function() {
                modal.style.opacity = '0';
                setTimeout(() => { modal.style.display = 'none'; }, 300);
            };
            
            summaryContent.appendChild(continueButton);
            modal.style.display = 'flex';
            
            window.onclick = function(event) {
                if (event.target === modal) {
                    modal.style.opacity = '0';
                    setTimeout(() => { modal.style.display = 'none'; }, 300);
                }
            };
        });
    } else {
        console.log("Location or summary not found. Location ID:", locationId);
        console.log("Available IDs:", gameLocations.map(loc => loc.id));
        showPopup("Error", "Summary not available for this location.");
    }
}
//trying this to free up some memory
function cleanupMemory() {
  const now = Date.now();
  let bytesFreed = 0; // Track approximate memory freed
  
  // Clear old position data
  if (positionHistory.length > 50) {
    const removed = positionHistory.length - 30;
    positionHistory = positionHistory.slice(-30);
    bytesFreed += removed * 200; // Rough estimate: 200 bytes per position
  }
  
  // Clear old images from cache that haven't been used recently
  for (const [url, img] of preloadedImages.entries()) {
    // Add lastUsed tracking if not present
    if (!img.lastUsed) {
      img.lastUsed = now;
      continue;
    }
    
    if (now - img.lastUsed > 300000) { // 5 minutes
      // Don't delete images for locations near the user's current position
      if (isImageForNearbyLocation(url)) {
        // Update lastUsed to prevent frequent checks
        img.lastUsed = now - 240000; // Check again in 1 minute
        continue;
      }
      
      // Free the image memory
      preloadedImages.delete(url);
      bytesFreed += 100000; // Rough estimate: 100KB per image
    }
  }
  
  // Clear audio cache with similar logic
  for (const [url, audio] of preloadedAudio.entries()) {
    if (!audio.lastUsed) {
      audio.lastUsed = now;
      continue;
    }
    
    if (now - audio.lastUsed > 600000) { // 10 minutes for audio (longer than images)
      preloadedAudio.delete(url);
      bytesFreed += 500000; // Rough estimate: 500KB per audio file
    }
  }
  
  // Only log if we actually freed memory
  if (bytesFreed > 0) {
    console.log(`Memory cleanup: ~${(bytesFreed / 1048576).toFixed(2)} MB freed`);
  }
}

// Helper function to check if an image is for a nearby location
function isImageForNearbyLocation(imageUrl) {
  if (!userMarker) return false;
  
  const userPos = userMarker.getLatLng();
  const nearbyLocations = gameLocations.filter(loc => {
    if (!loc || !loc.lat || !loc.lng) return false;
    const distance = calculateDistance(
      {lat: userPos.lat, lng: userPos.lng},
      {lat: loc.lat, lng: loc.lng}
    );
    return distance < 500; // Within 500 meters
  });
  
  // Check if this image URL belongs to a nearby location
  return nearbyLocations.some(loc => loc.image === imageUrl);
}

// Call every 2 minutes, but only when the tab is visible
function setupMemoryCleanup() {
  let cleanupInterval;
  
  function startCleanup() {
    cleanupInterval = setInterval(cleanupMemory, 120000);
  }
  
  function stopCleanup() {
    clearInterval(cleanupInterval);
  }
  
  // Start/stop based on visibility
  document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
      stopCleanup();
    } else {
      startCleanup();
    }
  });
  
  // Initial start
  if (!document.hidden) {
    startCleanup();
  }
}
        
function startHunt() {
    // Check network status before starting
    if (!navigator.onLine) {
        showErrorMessage("No internet connection. Please connect to the internet and try again.");
        
        // Set a timeout to retry
        setTimeout(() => {
            if (navigator.onLine) {
                startHunt();
            }
        }, 5000); //5 seconds
        
        return;
    }
    
    try {
        // Ensure locations is defined before using it
        if (typeof locations !== 'undefined' && Array.isArray(locations)) {
            gameLocations = locations.sort((a, b) => a.id - b.id);
        } else {
            console.warn("Locations data is not available");
            gameLocations = [];
        }
        
        currentLocationIndex = 0;
        locationCooldowns = {};
        lastVisitedLocationId = null;
        
        // Preload all location images before starting
        preloadImages(gameLocations).then(() => {
            // Hide preloader when images are loaded
            const preloader = document.getElementById('preloader');
            if (preloader) {
                preloader.style.opacity = '0';
                preloader.style.transition = 'opacity 0.5s ease';
                setTimeout(() => {
                    if (preloader && preloader.parentNode) {
                        preloader.parentNode.removeChild(preloader);
                    }
                    
                    // Force an immediate update of the distance box
                    updateDistanceBox();
                }, 500);
            }
            
            loadAllLocations();
            
            // Also update distance box after loading locations
            setTimeout(updateDistanceBox, 100);
        }).catch(error => {
            console.error("Error preloading images:", error);
            showErrorMessage("Error loading resources. Please check your connection and try again.");
            
            // Try to continue anyway after a delay
            setTimeout(() => {
                loadAllLocations();
                updateDistanceBox();
            }, 3000);
        });
    } catch (error) {
        console.error("Error starting hunt:", error);
        showErrorMessage("Error starting the experience. Please reload the page.");
    }
}

// Initialize the map when the DOM is loaded
document.addEventListener("DOMContentLoaded", () => {
  // Initialize the map and start preloading images
  initMap()
  addUIEventListeners()
  addMapEventListeners()
  setupMemoryCleanup()
  
  // Initial update of distance box if user location is already available
  setTimeout(updateDistanceBox, 1000);
})

// Export the main functions and classes for testing
if (typeof module !== 'undefined' && module.exports) {
  module.exports = {
    KalmanFilter,
    PositionInterpolator,
    AdaptiveKalmanFilterFactory,
    calculateDistance,
    calculateZoomLevel,
    checkProximityForZoom,
    processPositionUpdate,
    updateUserLocation,
  //  enhancedMotionDetection,
    optimizeDynamicZoom,
    predictNextPosition
  };
}

document.addEventListener("DOMContentLoaded", function() {
    const facts = [
        "Did you know? The Mississippi River begins its journey in Minnesota.",
        "Minnesota has more than 10,000 lakes across the state.",
        "Minneapolis is home to the first indoor shopping mall in the United States.",
        "The Mayo Clinic in Rochester is one of the world's most prestigious medical facilities.",
        "The Minneapolis Skyway System is the largest contiguous skyway system in the world.",
        "Minnesota's official state bird is the common loon.",
        "The Mall of America in Bloomington is the largest shopping mall in the United States."
    ];
    
    // Get elements
    const factElement = document.getElementById("loadingFacts").querySelector("p");
    const factsContainer = document.getElementById("loadingFacts");
    const progressBar = document.getElementById("preloaderProgress");
    
    // Set initial fact
    let currentFact = 0;
    factElement.textContent = facts[currentFact];
    
    // Add responsive styles with improved progress bar transition
    const style = document.createElement('style');
    style.textContent = `
        /* Progress bar styles - improved transition */
        #preloaderProgress {
            transition: width 0.3s cubic-bezier(0.4, 0.0, 0.2, 1) !important;
            will-change: width !important;
        }
        
        /* Facts container styles */
        #loadingFacts {
            border-left: none !important;
            background-color: transparent !important;
            width: 100% !important;
            max-width: 600px !important;
            height: 120px !important; /* Fixed height */
            margin: 0 auto !important;
            padding: 10px 15px !important;
            box-sizing: border-box !important;
            display: flex !important;
            flex-direction: column !important;
            justify-content: center !important;
            align-items: flex-start !important; /* Left align content */
            overflow: hidden !important; /* Prevent content overflow */
        }
        
        /* Facts text styles */
        #loadingFacts p {
            width: 100% !important;
            text-align: left !important; /* Left justified text */
            font-size: 22px !important; /* Larger font */
            font-weight: 500 !important;
            line-height: 1.4 !important;
            margin: 0 !important;
            padding: 0 !important;
            transition: opacity 0.5s ease !important;
        }
        
        /* Responsive adjustments */
        @media (max-width: 768px) {
            #loadingFacts {
                height: 140px !important; /* Slightly taller on mobile */
                max-width: 90% !important; /* Responsive width */
            }
            
            #loadingFacts p {
                font-size: 20px !important; /* Still large font on mobile */
            }
        }
        
        @media (max-width: 480px) {
            #loadingFacts {
                height: 160px !important; /* Even taller on small mobile */
            }
            
            #loadingFacts p {
                font-size: 18px !important; /* Slightly smaller on small mobile but still large */
            }
        }
    `;
    document.head.appendChild(style);
    
    // Progress bar animation setup
    const startTime = new Date().getTime();
    const minimumLoadTime = 10000; // 10 seconds minimum (increased from 7)
    const duration = 10000; // 10 seconds for the animation (increased from 7)
    let animationStartTime;
    
    // Use requestAnimationFrame for smoother animation
    function animateProgressBar(timestamp) {
        if (!animationStartTime) animationStartTime = timestamp;
        
        const elapsed = timestamp - animationStartTime;
        const progress = Math.min(elapsed / duration * 100, 100);
        
        // Update progress bar width
        progressBar.style.width = progress + "%";
        
        // Continue animation if not complete
        if (progress < 100) {
            requestAnimationFrame(animateProgressBar);
        } else {
            // Animation complete
            const currentTime = new Date().getTime();
            const totalElapsed = currentTime - startTime;
            
            if (totalElapsed < minimumLoadTime) {
                // Ensure we wait until the full 10 seconds have passed
                setTimeout(() => {
                    console.log("Loading complete - minimum time of 10 seconds reached");
                }, minimumLoadTime - totalElapsed);
            } else {
                console.log("Loading complete - exceeded minimum time of 10 seconds");
            }
        }
    }
    
    // Start the smooth animation
    requestAnimationFrame(animateProgressBar);
    
    // Rotate facts with fade transition
    // With a 10-second loading time, we'll show about 2 facts during the loading period
    setInterval(() => {
        // Fade out
        factElement.style.opacity = 0;
        
        // Change text and fade in
        setTimeout(() => {
            currentFact = (currentFact + 1) % facts.length;
            factElement.textContent = facts[currentFact];
            factElement.style.opacity = 1;
        }, 500);
    }, 5000);
});

console.log("Kalman filter implementation optimized successfully!");
    </script>
  </body>
</html>
