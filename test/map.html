<!DOCTYPE html>
<html lang="en">
<head> 
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Minnesota Then | Museum Without Walls</title>
    <link rel="shortcut icon" type="image/x-icon" href="https://www.mnthen.com/images/mnthenfav.ico">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css">
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css" />
    
    <style>
        :root {
            --primary-color: #005f9e;
            --secondary-color: #004b7d;
            --hover-color: #e6f2fa;
            --text-color: #333333;
            --light-text: #ffffff;
            --background-color: #f8f9fa;
            --border-color: #dee2e6;
            --success-color: #28a745;
            --warning-color: #ffc107;
            --danger-color: #dc3545;
            --shadow-color: rgba(0, 0, 0, 0.1);
            --safe-bottom: env(safe-area-inset-bottom, 0px);
            --safe-top: env(safe-area-inset-top, 0px);
            --modal-width: 90%;
            --modal-max-width: 400px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            overflow: hidden;
            position: relative;
            height: 100vh;
            width: 100vw;
            background-color: var(--background-color);
            color: var(--text-color);
        }

        #map {
            height: 100vh;
            width: 100vw;
            z-index: 1;
        }

        /* User marker styling */
        .user-marker-icon {
            width: 24px;
            height: 24px;
            background-color: #ff3b30; /* Red user icon */
            border: 3px solid white;
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            transition: all 0.3s ease;
            position: relative;
        }

        .user-marker-icon::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 36px;
            height: 36px;
            background-color: rgba(255, 59, 48, 0.2);
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        /* Custom marker cluster styling - DARK GREEN as requested */
        .marker-cluster-custom {
            background-color: rgba(0, 100, 0, 0.6); /* Dark green background */
            border-radius: 50%;
            width: 40px !important;
            height: 40px !important;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid white;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
        }

        .marker-cluster-custom div {
            width: 34px;
            height: 34px;
            border-radius: 50%;
            background-color: rgba(0, 100, 0, 0.8); /* Darker green inner circle */
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .marker-cluster-custom span {
            color: white;
            font-weight: bold;
            font-size: 14px;
        }

        /* Custom pin icon */
        .custom-pin-icon {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .pin-head {
            width: 30px;
            height: 30px;
            border-radius: 50% 50% 50% 0;
            background-color: #0f2bab;
            transform: rotate(-45deg);
            position: relative;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            border: 2px solid white;
        }

        .pin-head::after {
            content: '';
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: white;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        /* Distance box styling */
        #distanceBox {
            position: fixed;
            top: max(20px, calc(var(--safe-top) + 10px));
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(255, 255, 255, 0.95);
            padding: 12px 24px;
            border-radius: 30px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            font-weight: 600;
            font-size: 18px;
            color: var(--primary-color);
            text-align: center;
            transition: all 0.3s cubic-bezier(0.25, 0.1, 0.25, 1);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.7);
            will-change: transform, opacity;
            max-width: 90%;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Map buttons container */
        .map-buttons-container {
            position: fixed;
            bottom: max(20px, calc(var(--safe-bottom) + 20px));
            left: 0;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            padding: 0 10px;
        }

        .map-buttons {
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: center;
            gap: 24px;
            background-color: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border-radius: 50px;
            padding: 12px 24px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
            will-change: transform;
        }

        .map-button {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-color: white;
            color: var(--primary-color);
            border: none;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.25, 0.1, 0.25, 1);
            font-size: 24px;
            -webkit-tap-highlight-color: transparent;
        }

        .map-button:hover {
            background-color: var(--hover-color);
            transform: translateY(-2px);
        }

        .map-button:active {
            transform: scale(0.95);
        }

        .map-button.active {
            background-color: var(--primary-color);
            color: white;
        }

        /* Navigation tips */
        .navigation-tips {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1500;
            background-color: rgba(0, 0, 0, 0.5);
        }

        .navigation-tips-content {
            background-color: white;
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.2);
            width: var(--modal-width);
            max-width: var(--modal-max-width);
            will-change: transform, opacity;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .navigation-tips h3 {
            font-size: 26px;
            font-weight: 600;
            margin-bottom: 20px;
            color: var(--primary-color);
            text-align: center;
        }

        .navigation-tips ul {
            padding-left: 24px;
            margin-bottom: 0;
        }

        .navigation-tips li {
            margin-bottom: 16px;
            font-size: 20px;
            line-height: 1.5;
        }

        .navigation-tips .close-button {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: var(--dark-gray);
            -webkit-tap-highlight-color: transparent;
            padding: 8px;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Location hunt container */
        .lochunt-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: white;
            z-index: 2000;
            display: none;
            flex-direction: column;
            overflow: hidden;
        }

        .lochunt-content {
            padding: 25px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .lochunt-info {
            text-align: center;
            margin-bottom: 25px;
        }

        /* Audio player */
        .audio-player {
            width: 100%;
            max-width: 400px;
            margin-bottom: 25px;
        }

        .audio-progress {
            width: 100%;
            margin-bottom: 15px;
        }

        .progress {
            height: 10px;
            background-color: #e2e8f0;
            border-radius: 5px;
            overflow: hidden;
            cursor: pointer;
        }

        .progress-bar {
            height: 100%;
            background-color: var(--primary-color);
            width: 0%;
            transition: width 0.1s linear;
        }

        .audio-time {
            display: flex;
            justify-content: space-between;
            color: #666;
            font-size: 16px;
            margin-bottom: 15px;
        }

        .audio-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .audio-button {
            background-color: white;
            color: var(--primary-color);
            border: 2px solid var(--primary-color);
            border-radius: 50%;
            width: 55px;
            height: 55px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 20px;
        }

        .audio-button:hover {
            background-color: var(--hover-color);
        }

        .audio-button:active {
            transform: scale(0.95);
        }

        /* Additional info container */
        .additional-info-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: white;
            z-index: 2500;
            display: none;
            padding: 30px 20px;
            text-align: center;
            overflow-y: auto;
        }

        .additional-info-container h3 {
            color: var(--primary-color);
            margin-bottom: 25px;
            font-size: 26px;
            font-weight: 600;
        }

        .additional-info-container p {
            margin-bottom: 30px;
            line-height: 1.6;
            font-size: 18px;
        }

        /* Custom popup */
        .custom-popup {
            margin-bottom: 10px;
        }

        .custom-popup .leaflet-popup-content-wrapper {
            border-radius: 15px;
            padding: 0;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .custom-popup .leaflet-popup-content {
            margin: 0;
            width: 280px !important;
        }

        .popup-content {
            display: flex;
            flex-direction: column;
        }

        .location-image {
            width: 100%;
            height: 180px;
            object-fit: cover;
        }

        .location-name {
            padding: 15px;
            margin: 0;
            font-size: 18px;
            font-weight: 600;
            color: var(--text-color);
            text-align: center;
        }

        .popup-buttons {
            display: flex;
            border-top: 1px solid var(--border-color);
        }

        .popup-buttons .button {
            flex: 1;
            padding: 12px;
            background: none;
            border: none;
            font-size: 16px;
            font-weight: 500;
            color: var(--primary-color);
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .popup-buttons .button:first-child {
            border-right: 1px solid var(--border-color);
        }

        .popup-buttons .button:hover {
            background-color: var(--hover-color);
        }

        /* Summary Modal */
        #summaryModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.75);
            z-index: 3000;
            padding: 16px;
            backdrop-filter: blur(4px);
            will-change: opacity;
        }

        #summaryModal .modal-content {
            background-color: white;
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.2);
            max-width: var(--modal-max-width);
            width: var(--modal-width);
            max-height: 80vh;
            overflow-y: auto;
            text-align: left;
            font-size: 20px;
            line-height: 1.6;
            will-change: transform;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        /* Loading animation */
        .loading-spinner {
            display: inline-block;
            width: 30px;
            height: 30px;
            border: 3px solid rgba(0, 95, 158, 0.3);
            border-radius: 50%;
            border-top-color: var(--primary-color);
            animation: spin 1s ease-in-out infinite;
            margin-right: 10px;
            vertical-align: middle;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Pulse animation for distance indicator */
        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(2); opacity: 0; }
        }

        .pulse {
            animation: pulse-box 2s infinite;
        }

        @keyframes pulse-box {
            0% { box-shadow: 0 0 0 0 rgba(0, 95, 158, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(0, 95, 158, 0); }
            100% { box-shadow: 0 0 0 0 rgba(0, 95, 158, 0); }
        }

        /* Transition animations */
        .fade-in {
            animation: fadeIn 0.3s forwards;
        }

        .fade-out {
            animation: fadeOut 0.3s forwards;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes fadeOut {
            from { opacity: 1; transform: translateY(0); }
            to { opacity: 0; transform: translateY(10px); }
        }

        /* Modal animations */
        .modal-fade-in {
            animation: modalFadeIn 0.3s forwards;
        }

        .modal-fade-out {
            animation: modalFadeOut 0.3s forwards;
        }

        @keyframes modalFadeIn {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }

        @keyframes modalFadeOut {
            from { opacity: 1; transform: scale(1); }
            to { opacity: 0; transform: scale(0.95); }
        }

        /* Accessibility improvements */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }

        /* Focus styles for better keyboard navigation */
        button:focus-visible, a:focus-visible {
            outline: 3px solid rgba(0, 95, 158, 0.5);
            outline-offset: 2px;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            #distanceBox {
                top: max(15px, calc(var(--safe-top) + 10px));
                padding: 10px 20px;
                font-size: 22px;
            }

            .map-buttons {
                bottom: max(15px, calc(var(--safe-bottom) + 15px));
                gap: 12px;
            }

            .map-button {
                width: 50px;
                height: 50px;
                font-size: 20px;
            }

            .audio-button {
                width: 50px;
                height: 50px;
                font-size: 18px;
            }
        }

        @media (max-width: 480px) {
            #summaryModal .modal-content {
                max-width: 95%;
                max-height: 95vh;
                padding: 20px;
            }
            
            .navigation-tips-content {
                width: 95%;
                max-width: 95%;
                padding: 20px;
            }
            
            .navigation-tips li {
                font-size: 18px;
                margin-bottom: 10px;
            }
        }

        /* Location error modal - CENTERED as requested */
        .location-error-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 3000;
            background-color: rgba(0, 0, 0, 0.5);
        }

        .location-error-content {
            background-color: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.2);
            width: 90%;
            max-width: 400px;
            text-align: center;
        }

        .modal-title {
            font-size: 22px;
            margin-bottom: 15px;
            color: var(--primary-color);
        }

        .modal-message {
            font-size: 16px;
            margin-bottom: 25px;
            line-height: 1.5;
        }

        .modal-button {
            padding: 12px 25px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            transition: background-color 0.2s;
        }

        .modal-button:hover {
            background-color: var(--secondary-color);
        }

        /* Modal container - CENTERED as requested */
        .modal-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.75);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 3000;
            padding: 16px;
            backdrop-filter: blur(4px);
        }
        
        .modal-box {
            background-color: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.2);
            width: 90%;
            max-width: 400px;
            text-align: center;
        }

        .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
        }

        .modal-button.secondary {
            background-color: #f2f2f2;
            color: #333;
        }

        .modal-button.secondary:hover {
            background-color: #e0e0e0;
        }

        /* Loading message */
        #loadingMessage {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 15px;
            z-index: 3000;
            display: flex;
            align-items: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }
        
        /* Auto-recenter indicator */
        #autoRecenterIndicator {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 3500;
        }
        
        #autoRecenterIndicator.visible {
            opacity: 1;
        }

        /* Enhanced visual feedback */
        .haptic-feedback {
            animation: haptic 0.15s ease-in-out;
        }

        @keyframes haptic {
            0% { transform: scale(1); }
            50% { transform: scale(0.97); }
            100% { transform: scale(1); }
        }

        /* Improved accessibility for interactive elements */
        .interactive {
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .interactive:active {
            transform: scale(0.98);
        }

        /* Improved visual hierarchy */
        .primary-heading {
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--primary-color);
            margin-bottom: 1rem;
        }

        .secondary-heading {
            font-size: 1.4rem;
            font-weight: 600;
            color: var(--secondary-color);
            margin-bottom: 0.8rem;
        }

        /* Improved touch targets for mobile */
        @media (max-width: 480px) {
            .touch-target {
                min-height: 44px;
                min-width: 44px;
            }
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <div id="distanceBox">Initializing...</div>
    <div id="autoRecenterIndicator">Auto-recentering in <span id="recenterCountdown">5</span>s</div>

    <div class="lochunt-container">
        <img id="locationImage" src="/placeholder.svg" alt="Location Image">
        <div class="lochunt-content">
            <div class="lochunt-info">
                <h2 id="locationTitle" class="mb-2 text-primary"></h2>
                <p id="locationCity" class="text-muted mb-1"></p>
                <p id="locationCreator" class="text-muted mb-3"></p>
            </div>
            <div class="audio-player">
                <div class="audio-progress">
                    <div class="progress">
                        <div id="progressBar" class="progress-bar" role="progressbar" style="width: 0%"></div>
                    </div>
                </div>
                <div class="audio-time">
                    <span id="currentTime">0:00</span>
                    <span id="duration">0:00</span>
                </div>
                <div class="audio-controls">
                    <button id="rewindBtn" class="audio-button touch-target" aria-label="Rewind 10 seconds"><i class="fas fa-backward"></i></button>
                    <button id="playPauseBtn" class="audio-button touch-target" aria-label="Play"><i class="fas fa-play"></i></button>
                    <button id="forwardBtn" class="audio-button touch-target" aria-label="Forward 10 seconds"><i class="fas fa-forward"></i></button>
                </div>
                <audio id="locationAudio" src="/placeholder.svg" preload="auto"></audio>
            </div>
        </div>
    </div>

    <div class="additional-info-container">
        <h3 class="mb-3 text-primary text-center">Did You Know?</h3>
        <p id="additionalInfo" class="mb-3 fs-6"></p>
        <div class="d-flex justify-content-center">
            <button id="continueButton" class="btn btn-primary touch-target">Continue</button>
        </div>
    </div>

    <div class="map-buttons-container">
        <div class="map-buttons">
            <button id="recenterButton" class="map-button touch-target" aria-label="Recenter map"><i class="fas fa-crosshairs"></i></button>
            <button id="returnButton" class="map-button touch-target" aria-label="Return to home"><i class="fas fa-sign-out-alt"></i></button>
            <button id="tipsButton" class="map-button touch-target" aria-label="Navigation tips"><i class="fas fa-question-circle"></i></button>
        </div>
    </div>

    <!-- Navigation tips -->
    <div class="navigation-tips">
        <div class="navigation-tips-content">
            <button class="close-button touch-target" aria-label="Close tips">&times;</button>
            <h3>Navigation Tips</h3>
            <ul>
                <li>Use the map to navigate to the marked locations.</li>
                <li>The distance box shows how far you are from the current location.</li>
                <li>Tap the recenter button to focus on your current position.</li>
                <li>When you're within 20 feet of a location, you'll be able to interact with it.</li>
                <li>Listen to the audio information for each location.</li>
                <li>After the audio, you'll see additional information about the location.</li>
            </ul>
        </div>
    </div>

    <div id="summaryModal" class="modal">
        <div class="modal-content">
            <p id="summaryContent"></p>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"></script>
    <script src="/locations_test.js?v=1.0.4"></script>

    <script>
    // Core application variables
    let map, userMarker, markerClusterGroup;
    let currentLocationIndex = 0;
    let visitedLocations = [];
    let gameLocations = [];
    let isLocationHuntVisible = false;
    let lastPosition = null;
    let positionBuffer = [];
    let filteredPosition = null;
    let followUser = true;
    let locationCooldowns = {};
    let lastVisitedLocationId = null;
    let lastKnownPosition = null;
    let isTransitioning = false;
    let lastVelocity = { lat: 0, lng: 0 };
    let isMapInteracting = false;
    let isStationary = false;
    let stationaryStartTime = null;
    let stationaryCheckTimeout = null;
    let lastUpdateTime = null;
    let lastUpdateTimestamp = null;
    let stationaryBuffer = [];
    let stationaryPosition = null;
    let stationaryCount = 0;
    let lastSmoothedPosition = null;
    let lastHiddenTime = 0;
    let retryCount = 0;
    let inactivityTimer = null;
    let recenterTimer = null;
    let lastRecenterTime = 0;
    let autoRecenterCountdown = 5;
    let autoRecenterInterval = null;
    let lastZoomLevel = null;
    let userInteractionTime = Date.now();
    let isSummaryModalOpen = false;
    let activeModals = [];
    let imageCache = {};
    let locationImagePreloaded = false;
    let pendingLocationImages = new Set();

    // Configuration constants
    const DISTANCE_THRESHOLD = 20; // should be 20 feet
    const MAX_BUFFER_SIZE = 5;
    const MAX_ACCEPTABLE_ACCURACY = 39; // meters
    const BACKGROUND_THRESHOLD = 25000; // ms
    const INACTIVITY_TIMEOUT = 30000; // ms
    const UPDATE_INTERVAL = 50; // ms
    const MICRO_MOVEMENT_THRESHOLD = 0.3; // meters
    const STATIONARY_ACCURACY_MULTIPLIER = 1.1;
    const MAX_SPEED = 50; // m/s
    const MIN_DISTANCE_THRESHOLD = 2; // meters
    const VELOCITY_DECAY = 0.8;
    const BEARING_WEIGHT = 0.3;
    const SMOOTHING_FACTOR = 0.3;
    const EXTENDED_DISTANCE_THRESHOLD = 100; // meters
    const STATIONARY_THRESHOLD = 2;
    const STATIONARY_TIME_THRESHOLD = 5000; // ms
    const STATIONARY_CHECK_INTERVAL = 2500; // ms
    const STATIONARY_SMOOTHING = 0.95;
    const STATIONARY_BUFFER_SIZE = 10;
    const STATIONARY_ACCURACY_WEIGHT = 0.7;
    const STATIONARY_THRESHOLDB = 3;
    const MAX_ALPHA = 0.2;
    const MIN_ALPHA = 0.025;
    const MAX_RETRIES = 3;
    const RETRY_DELAY = 1000; // ms
    const EDGE_THRESHOLD_PERCENTAGE = 0.10; // 10% from edge of screen
    const STRICT_EDGE_THRESHOLD_PERCENTAGE = 0.07; // 7% from edge for strict recenter
    const CRITICAL_EDGE_THRESHOLD_PERCENTAGE = 0.05; // 5% from edge for critical recenter
    const MAX_ACCURACY_THRESHOLD = 2500;
    const TARGET_ACCURACY_THRESHOLD = 100;
    const MIN_RECENTER_INTERVAL = 2000; // ms
    const AUTO_RECENTER_INTERVAL = 30000; // 30 seconds for auto-recenter
    const AUTO_RECENTER_COUNTDOWN_START = 5; // seconds before auto-recenter to show countdown
    const FIRST_LOCATION_TIMEOUT = 10000; // 10 seconds for first location attempt
    const SECOND_LOCATION_TIMEOUT = 5000; // 5 seconds for second location attempt
    const SPEED_ZOOM_THRESHOLDS = [
        { speed: 35, zoom: 14 },  // Highway speeds
        { speed: 25, zoom: 15 },  // Major roads
        { speed: 15, zoom: 16 },  // Urban driving
        { speed: 8, zoom: 17 },   // Slow driving - bicycling
    ];
    const IMAGE_PRELOAD_BATCH_SIZE = 3; // Number of images to preload at once
    const HAPTIC_FEEDBACK_DURATION = 0; // ms

    // Initialize map and core functionality
    function initMap() {
        // Create map with optimized settings
        map = L.map('map', {
            zoomControl: false,
            attributionControl: false,
            zoomSnap: 0.1,
            zoomDelta: 0.5,
            wheelDebounceTime: 100,
            tapTolerance: 15,
            bounceAtZoomLimits: false,
            preferCanvas: true, // Better performance for many markers
            renderer: L.canvas({ padding: 0.5 })
        }).fitWorld();

        // Add tile layer with performance optimizations
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: 'Â© OpenStreetMap contributors',
            updateWhenIdle: true,
            updateWhenZooming: false,
            keepBuffer: 2
        }).addTo(map);

        // Initialize marker cluster group with custom styling
        markerClusterGroup = L.markerClusterGroup({
            showCoverageOnHover: false,
            zoomToBoundsOnClick: true,
            spiderfyOnMaxZoom: true,
            animate: true,
            animateAddingMarkers: true,
            chunkedLoading: true,
            chunkProgress: updateLoadingStatus,
            maxClusterRadius: function(zoom) {
                return zoom > 16 ? 40 : 80; // Adaptive clustering based on zoom
            },
            iconCreateFunction: function(cluster) {
                return L.divIcon({
                    html: '<div><span>' + cluster.getChildCount() + '</span></div>',
                    className: 'marker-cluster-custom',
                    iconSize: L.point(40, 40)
                });
            }
        });
        map.addLayer(markerClusterGroup);

        // Create user location marker with RED color
        const userIcon = L.divIcon({
            className: 'user-marker',
            html: '<div class="user-marker-icon"></div>',
            iconSize: [20, 20],
            iconAnchor: [10, 10]
        });
        userMarker = L.marker([0, 0], { icon: userIcon, zIndexOffset: 1000 }).addTo(map);
        
        showLoadingMessage();

        // Initialize geolocation with fallback
        if ("geolocation" in navigator) {
            const options = {
                enableHighAccuracy: true,
                timeout: FIRST_LOCATION_TIMEOUT,
                maximumAge: 0
            };

            // Try to get initial position with retry
            navigator.geolocation.getCurrentPosition(
                initializeUserLocation,
                (error) => {
                    // On error, try one more time with shorter timeout
                    console.log("First location attempt failed, trying again with shorter timeout");
                    navigator.geolocation.getCurrentPosition(
                        initializeUserLocation,
                        handleLocationError,
                        {
                            enableHighAccuracy: true,
                            timeout: SECOND_LOCATION_TIMEOUT,
                            maximumAge: 0
                        }
                    );
                },
                options
            );
        } else {
            showPopup("Geolocation Error", "Geolocation is not supported by your browser");
            map.setView([44.9778, -93.2650], 19); // Default to Minneapolis
            hideLoadingMessage();
        }
        
        // Set up event listeners
        document.addEventListener('visibilitychange', handleVisibilityChange);

        map.on('movestart zoomstart', () => {
            followUser = false;
            isMapInteracting = true;
            userInteractionTime = Date.now();
            stopAutoRecenterCountdown();
            
            // Store current zoom level
            lastZoomLevel = map.getZoom();
        });

        map.on('moveend zoomend', () => {
            isMapInteracting = false;
            resetInactivityTimer();
            startAutoRecenterTimer();
        });

        // Enable touch interactions
        map.touchZoom.enable();
        map.doubleClickZoom.enable();
        
        // Start auto-recenter timer
        startAutoRecenterTimer();
    }

    // Preload location images for faster display
    function preloadLocationImages() {
        if (locationImagePreloaded || !gameLocations || !gameLocations.length) return;
        
        console.log("Starting to preload location images...");
        
        // Create a queue of locations to preload
        const locationsToPreload = [...gameLocations];
        
        // Function to preload a batch of images
        function preloadNextBatch() {
            if (locationsToPreload.length === 0) {
                console.log("All location images preloaded");
                locationImagePreloaded = true;
                return;
            }
            
            // Take the next batch of locations
            const batch = locationsToPreload.splice(0, IMAGE_PRELOAD_BATCH_SIZE);
            
            // Preload each image in the batch
            batch.forEach(location => {
                if (location && location.image && !imageCache[location.id]) {
                    pendingLocationImages.add(location.id);
                    
                    const img = new Image();
                    img.onload = () => {
                        imageCache[location.id] = img;
                        pendingLocationImages.delete(location.id);
                        console.log(`Preloaded image for location ${location.id}`);
                    };
                    img.onerror = () => {
                        pendingLocationImages.delete(location.id);
                        console.error(`Failed to preload image for location ${location.id}`);
                    };
                    img.src = location.image;
                }
            });
            
            // Schedule the next batch
            setTimeout(preloadNextBatch, 300);
        }
        
        // Start preloading
        preloadNextBatch();
    }

    // Provide haptic feedback if available
    function provideHapticFeedback() {
        if ('vibrate' in navigator) {
            navigator.vibrate(HAPTIC_FEEDBACK_DURATION);
        }
    }

    function startAutoRecenterTimer() {
        // Clear any existing timer
        if (recenterTimer) {
            clearTimeout(recenterTimer);
            recenterTimer = null;
        }
        
        // Set up new timer to recenter after 30 seconds of inactivity
        recenterTimer = setTimeout(() => {
            if (userMarker && lastPosition) {
                // If summary modal is open, show countdown
                if (isSummaryModalOpen) {
                    startAutoRecenterCountdown();
                } else {
                    // Otherwise, just recenter immediately
                    performAutoRecenter();
                }
            }
        }, AUTO_RECENTER_INTERVAL);
    }
    
    function startAutoRecenterCountdown() {
        // Only show countdown for summary modals
        if (!isSummaryModalOpen) return;
        
        const indicator = document.getElementById('autoRecenterIndicator');
        const countdownEl = document.getElementById('recenterCountdown');
        
        // Reset countdown
        autoRecenterCountdown = AUTO_RECENTER_COUNTDOWN_START;
        countdownEl.textContent = autoRecenterCountdown;
        
        // Show indicator
        indicator.classList.add('visible');
        
        // Clear any existing countdown
        if (autoRecenterInterval) {
            clearInterval(autoRecenterInterval);
        }
        
        // Start countdown
        autoRecenterInterval = setInterval(() => {
            autoRecenterCountdown--;
            countdownEl.textContent = autoRecenterCountdown;
            
            if (autoRecenterCountdown <= 0) {
                // Time to recenter
                clearInterval(autoRecenterInterval);
                indicator.classList.remove('visible');
                
                // Perform auto-recenter with the same zoom level
                performAutoRecenter();
            }
        }, 1000);
    }
    
    function stopAutoRecenterCountdown() {
        if (autoRecenterInterval) {
            clearInterval(autoRecenterInterval);
            autoRecenterInterval = null;
        }
        
        const indicator = document.getElementById('autoRecenterIndicator');
        indicator.classList.remove('visible');
    }
    
    function performAutoRecenter() {
        if (userMarker && lastPosition) {
            console.log("Auto-recentering map after 30 seconds");
            
            // Close any open popups and modals
            closeAllModals();
            map.closePopup();
            
            // Use the stored zoom level or current zoom level
            const zoomToUse = lastZoomLevel || map.getZoom();
            
            // Recenter with smooth animation
            map.setView([lastPosition.lat, lastPosition.lng], zoomToUse, {
                animate: true,
                duration: 0.8,
                easeLinearity: 0.5
            });
            
            followUser = true;
            lastRecenterTime = Date.now();
            
            // Restart the auto-recenter timer
            startAutoRecenterTimer();
        }
    }
    
    function closeAllModals() {
        // Close summary modal if open
        const summaryModal = document.getElementById('summaryModal');
        if (summaryModal && window.getComputedStyle(summaryModal).display !== 'none') {
            summaryModal.style.display = 'none';
            isSummaryModalOpen = false;
        }
        
        // Close navigation tips if open
        const navTips = document.querySelector('.navigation-tips');
        if (navTips && window.getComputedStyle(navTips).display !== 'none') {
            navTips.style.display = 'none';
        }
        
        // Close any other modals in the activeModals array
        activeModals.forEach(modal => {
            if (document.body.contains(modal)) {
                document.body.removeChild(modal);
            }
        });
        activeModals = [];
    }

    function updateLoadingStatus(processed, total, elapsed) {
        if (processed === total) {
            // All markers loaded
            console.log(`Loaded ${processed} markers in ${elapsed.toFixed(2)}ms`);
            
            // Start preloading images after markers are loaded
            setTimeout(preloadLocationImages, 500);
        }
    }

    function showLoadingMessage() {
        const existingMessage = document.getElementById('loadingMessage');
        if (existingMessage) return;

        const loadingMessage = document.createElement('div');
        loadingMessage.id = 'loadingMessage';
        loadingMessage.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 15px;
            z-index: 3000;
            display: flex;
            align-items: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        `;
        loadingMessage.innerHTML = '<div class="loading-spinner"></div><p style="margin: 0;">Finding your location...</p>';
        document.body.appendChild(loadingMessage);
    }

    function hideLoadingMessage() {
        const loadingMessage = document.getElementById('loadingMessage');
        if (loadingMessage) {
            loadingMessage.classList.add('fade-out');
            setTimeout(() => {
                if (loadingMessage.parentNode) {
                    document.body.removeChild(loadingMessage);
                }
            }, 300);
        }
    }

    function initializeUserLocation(position) {
        console.log("Initial position data:", JSON.stringify(position));

        if (!position || !position.coords) {
            console.error("Invalid initial position object");
            handleLocationError(new Error("Invalid initial position"));
            return;
        }

        const { latitude: userLat, longitude: userLng, accuracy } = position.coords;

        if (isNaN(userLat) || isNaN(userLng)) {
            console.error("Invalid initial coordinates:", { userLat, userLng });
            handleLocationError(new Error("Invalid initial coordinates"));
            return;
        }

        console.log("Valid initial position:", { userLat, userLng, accuracy });

        try {
            userMarker.setLatLng([userLat, userLng]);
            map.setView([userLat, userLng], 19);
            lastZoomLevel = 19; // Store initial zoom level
            
            // Initialize Kalman filter with first position
            kalmanFilter.reset({
                lat: userLat,
                lng: userLng,
                accuracy: accuracy || 20
            });
            
            hideLoadingMessage();
            startPositionUpdates();
            startHunt();
            
            // Pulse the distance box to draw attention
            const distanceBox = document.getElementById('distanceBox');
            distanceBox.classList.add('pulse');
            setTimeout(() => distanceBox.classList.remove('pulse'), 3000);
        } catch (error) {
            console.error("Error setting initial user location:", error);
            handleLocationError(error);
        }
    }

    function startPositionUpdates() {
        // Use high accuracy watchPosition with optimized settings
        navigator.geolocation.watchPosition(
            handlePositionUpdate,
            handleLocationError,
            {
                enableHighAccuracy: true,
                maximumAge: 1000,
                timeout: 10000
            }
        );
    }

    function handlePositionUpdate(position) {
        if (!position || !position.coords || 
            isNaN(position.coords.latitude) || 
            isNaN(position.coords.longitude)) {
            console.warn("Invalid position data received");
            return;
        }
        
        // Process valid position update
        updateUserLocation(position);
    }

    function handleVisibilityChange() {
        if (document.hidden) {
            lastHiddenTime = Date.now();
            lastKnownPosition = userMarker ? userMarker.getLatLng() : null;
            stopAutoRecenterCountdown();
        } else {
            const hiddenDuration = Date.now() - lastHiddenTime;
            if (hiddenDuration > BACKGROUND_THRESHOLD) {
                updateLocationAfterBackground();
            } else {
                // Just refresh the map size
                map.invalidateSize();
            }
        }
        resetInactivityTimer();
        
        // Reset auto-recenter timer when app becomes visible again
        if (!document.hidden) {
            startAutoRecenterTimer();
        }
    }

    function updateLocationAfterBackground() {
        if ("geolocation" in navigator) {
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    if (!position || !position.coords) {
                        console.warn("Invalid position object in background update");
                        return;
                    }
                    
                    const { latitude, longitude, accuracy } = position.coords;
                    if (isNaN(latitude) || isNaN(longitude)) {
                        console.warn("Invalid coordinates in background update");
                        return;
                    }
                    
                    try {
                        // Force update with new position
                        updateUserLocation(position, true);
                        
                        // Reset all position tracking variables
                        lastPosition = null;
                        positionBuffer = [];
                        filteredPosition = null;
                        lastVelocity = { lat: 0, lng: 0 };
                        
                        updateDistanceBox();
                        followUser = true;
                        map.invalidateSize();
                    } catch (error) {
                        console.error("Error updating location after background:", error);
                    }
                },
                (error) => {
                    console.error("Error getting location after background:", error);
                    if (error.code === 3) { // If timeout, retry with lower accuracy
                        navigator.geolocation.getCurrentPosition(
                            position => {
                                updateUserLocation(position, true);
                            },
                            error => console.error("Error on retry:", error),
                            {
                                enableHighAccuracy: false,
                                timeout: 20000,
                                maximumAge: 30000
                            }
                        );
                    }
                },
                {
                    enableHighAccuracy: true,
                    timeout: 10000,
                    maximumAge: 0
                }
            );
        } else {
            console.warn("Geolocation is not available");
        }
    }

    // Enhanced Kalman filter implementation for position smoothing
const kalmanFilter = {
    // State variables
    x: { estimate: 0, error: 1 }, // Longitude
    y: { estimate: 0, error: 1 }, // Latitude
    vx: { estimate: 0, error: 1 }, // Velocity in longitude direction
    vy: { estimate: 0, error: 1 }, // Velocity in latitude direction
    
    // Noise parameters
    q: 0.015, // Process noise (can be dynamically adjusted)
    r: 1,     // Measurement noise (should be adjusted based on GPS accuracy)
    
    // Time tracking
    lastTimestamp: null,
    
    // Enhanced update function with velocity state
    update: function(measurement) {
        // Calculate time delta
        const dt = this.lastTimestamp ? (measurement.timestamp - this.lastTimestamp) / 1000 : 0;
        this.lastTimestamp = measurement.timestamp;
        
        // If first measurement or reset
        if (this.x.estimate === 0 && this.y.estimate === 0) {
            this.x.estimate = measurement.lng;
            this.y.estimate = measurement.lat;
            this.vx.estimate = 0;
            this.vy.estimate = 0;
            return measurement;
        }
        
        // Skip prediction step if no time has passed
        if (dt <= 0) {
            return {
                lat: this.y.estimate,
                lng: this.x.estimate,
                accuracy: measurement.accuracy,
                timestamp: measurement.timestamp,
                heading: measurement.heading,
                speedMPS: measurement.speedMPS
            };
        }
        
        // Prediction step - incorporate velocity
        const predX = this.x.estimate + this.vx.estimate * dt;
        const predY = this.y.estimate + this.vy.estimate * dt;
        
        // Prediction error increases with time
        const predErrX = this.x.error + this.q * dt;
        const predErrY = this.y.error + this.q * dt;
        const predErrVX = this.vx.error + this.q * dt * 2; // Velocity error grows faster
        const predErrVY = this.vy.error + this.q * dt * 2;
        
        // Dynamic measurement noise based on GPS accuracy
        const dynamicR = (measurement.accuracy * measurement.accuracy) / 100;
        
        // Kalman gain calculation
        const gainX = predErrX / (predErrX + dynamicR);
        const gainY = predErrY / (predErrY + dynamicR);
        const gainVX = predErrVX / (predErrVX + dynamicR * 4); // Less trust in velocity measurements
        const gainVY = predErrVY / (predErrVY + dynamicR * 4);
        
        // Update position estimates
        this.x.estimate = predX + gainX * (measurement.lng - predX);
        this.y.estimate = predY + gainY * (measurement.lat - predY);
        
        // Calculate velocities from measurements if time delta exists
        let measuredVX = 0;
        let measuredVY = 0;
        
        if (dt > 0 && measurement.speedMPS > 0 && measurement.heading !== null) {
            // Convert speed and heading to velocity components
            const headingRad = (measurement.heading * Math.PI) / 180;
            measuredVX = measurement.speedMPS * Math.sin(headingRad) / 111320 * Math.cos((this.y.estimate * Math.PI) / 180);
            measuredVY = measurement.speedMPS * Math.cos(headingRad) / 110540;
        } else if (dt > 0) {
            // Estimate velocity from position change
            measuredVX = (measurement.lng - this.x.estimate) / dt;
            measuredVY = (measurement.lat - this.y.estimate) / dt;
        }
        
        // Update velocity estimates
        this.vx.estimate = this.vx.estimate + gainVX * (measuredVX - this.vx.estimate);
        this.vy.estimate = this.vy.estimate + gainVY * (measuredVY - this.vy.estimate);
        
        // Update error estimates
        this.x.error = (1 - gainX) * predErrX;
        this.y.error = (1 - gainY) * predErrY;
        this.vx.error = (1 - gainVX) * predErrVX;
        this.vy.error = (1 - gainVY) * predErrVY;
        
        // Calculate speed and heading from velocity components
        const speed = Math.sqrt(
            Math.pow(this.vx.estimate * 111320 * Math.cos((this.y.estimate * Math.PI) / 180), 2) +
            Math.pow(this.vy.estimate * 110540, 2)
        );
        
        let heading = null;
        if (speed > 0.1) { // Only calculate heading if moving
            heading = (Math.atan2(this.vx.estimate, this.vy.estimate) * 180) / Math.PI;
            if (heading < 0) heading += 360;
        }
        
        return {
            lat: this.y.estimate,
            lng: this.x.estimate,
            accuracy: measurement.accuracy * (1 - Math.min(0.5, Math.max(gainX, gainY))), // Improved accuracy estimate
            timestamp: measurement.timestamp,
            heading: heading !== null ? heading : measurement.heading,
            speedMPS: speed > 0.1 ? speed : measurement.speedMPS,
            kalmanGain: Math.max(gainX, gainY) // Export gain for debugging
        };
    },
    
    // Project position forward in time (for predictions between updates)
    predict: function(dt) {
        if (dt <= 0 || this.x.estimate === 0 && this.y.estimate === 0) {
            return {
                lat: this.y.estimate,
                lng: this.x.estimate
            };
        }
        
        return {
            lat: this.y.estimate + this.vy.estimate * dt,
            lng: this.x.estimate + this.vx.estimate * dt,
            heading: this.getHeading(),
            speedMPS: this.getSpeed()
        };
    },
    
    // Get current speed estimate
    getSpeed: function() {
        return Math.sqrt(
            Math.pow(this.vx.estimate * 111320 * Math.cos((this.y.estimate * Math.PI) / 180), 2) +
            Math.pow(this.vy.estimate * 110540, 2)
        );
    },
    
    // Get current heading estimate
    getHeading: function() {
        const speed = this.getSpeed();
        if (speed < 0.1) return null;
        
        let heading = (Math.atan2(this.vx.estimate, this.vy.estimate) * 180) / Math.PI;
        if (heading < 0) heading += 360;
        return heading;
    },
    
    // Reset the filter
    reset: function(measurement) {
        this.x.estimate = measurement.lng;
        this.y.estimate = measurement.lat;
        this.vx.estimate = 0;
        this.vy.estimate = 0;
        this.x.error = 1;
        this.y.error = 1;
        this.vx.error = 1;
        this.vy.error = 1;
        this.lastTimestamp = measurement.timestamp;
    },
    
    // Adjust filter parameters dynamically
    adjustParameters: function(accuracy, isStationary, speedMPS) {
        // Dynamic process noise based on movement state
        if (isStationary) {
            this.q = 0.001; // Very low process noise when stationary
        } else {
            // Increase process noise with speed for more responsive tracking
            this.q = 0.005 + Math.min(0.03, speedMPS / 30);
        }
        
        // Measurement noise is set externally through this.r
    }
};
        
    // Kalman filter implementation for position smoothing
// Enhanced Kalman filter implementation for position smoothing
const kalmanFilter = {
    // State variables
    x: { estimate: 0, error: 1 }, // Longitude
    y: { estimate: 0, error: 1 }, // Latitude
    vx: { estimate: 0, error: 1 }, // Velocity in longitude direction
    vy: { estimate: 0, error: 1 }, // Velocity in latitude direction
    
    // Noise parameters
    q: 0.015, // Process noise (can be dynamically adjusted)
    r: 1,     // Measurement noise (should be adjusted based on GPS accuracy)
    
    // Time tracking
    lastTimestamp: null,
    
    // Enhanced update function with velocity state
    update: function(measurement) {
        // Calculate time delta
        const dt = this.lastTimestamp ? (measurement.timestamp - this.lastTimestamp) / 1000 : 0;
        this.lastTimestamp = measurement.timestamp;
        
        // If first measurement or reset
        if (this.x.estimate === 0 && this.y.estimate === 0) {
            this.x.estimate = measurement.lng;
            this.y.estimate = measurement.lat;
            this.vx.estimate = 0;
            this.vy.estimate = 0;
            return measurement;
        }
        
        // Skip prediction step if no time has passed
        if (dt <= 0) {
            return {
                lat: this.y.estimate,
                lng: this.x.estimate,
                accuracy: measurement.accuracy,
                timestamp: measurement.timestamp,
                heading: measurement.heading,
                speedMPS: measurement.speedMPS
            };
        }
        
        // Prediction step - incorporate velocity
        const predX = this.x.estimate + this.vx.estimate * dt;
        const predY = this.y.estimate + this.vy.estimate * dt;
        
        // Prediction error increases with time
        const predErrX = this.x.error + this.q * dt;
        const predErrY = this.y.error + this.q * dt;
        const predErrVX = this.vx.error + this.q * dt * 2; // Velocity error grows faster
        const predErrVY = this.vy.error + this.q * dt * 2;
        
        // Dynamic measurement noise based on GPS accuracy
        const dynamicR = (measurement.accuracy * measurement.accuracy) / 100;
        
        // Kalman gain calculation
        const gainX = predErrX / (predErrX + dynamicR);
        const gainY = predErrY / (predErrY + dynamicR);
        const gainVX = predErrVX / (predErrVX + dynamicR * 4); // Less trust in velocity measurements
        const gainVY = predErrVY / (predErrVY + dynamicR * 4);
        
        // Update position estimates
        this.x.estimate = predX + gainX * (measurement.lng - predX);
        this.y.estimate = predY + gainY * (measurement.lat - predY);
        
        // Calculate velocities from measurements if time delta exists
        let measuredVX = 0;
        let measuredVY = 0;
        
        if (dt > 0 && measurement.speedMPS > 0 && measurement.heading !== null) {
            // Convert speed and heading to velocity components
            const headingRad = (measurement.heading * Math.PI) / 180;
            measuredVX = measurement.speedMPS * Math.sin(headingRad) / 111320 * Math.cos((this.y.estimate * Math.PI) / 180);
            measuredVY = measurement.speedMPS * Math.cos(headingRad) / 110540;
        } else if (dt > 0) {
            // Estimate velocity from position change
            measuredVX = (measurement.lng - this.x.estimate) / dt;
            measuredVY = (measurement.lat - this.y.estimate) / dt;
        }
        
        // Update velocity estimates
        this.vx.estimate = this.vx.estimate + gainVX * (measuredVX - this.vx.estimate);
        this.vy.estimate = this.vy.estimate + gainVY * (measuredVY - this.vy.estimate);
        
        // Update error estimates
        this.x.error = (1 - gainX) * predErrX;
        this.y.error = (1 - gainY) * predErrY;
        this.vx.error = (1 - gainVX) * predErrVX;
        this.vy.error = (1 - gainVY) * predErrVY;
        
        // Calculate speed and heading from velocity components
        const speed = Math.sqrt(
            Math.pow(this.vx.estimate * 111320 * Math.cos((this.y.estimate * Math.PI) / 180), 2) +
            Math.pow(this.vy.estimate * 110540, 2)
        );
        
        let heading = null;
        if (speed > 0.1) { // Only calculate heading if moving
            heading = (Math.atan2(this.vx.estimate, this.vy.estimate) * 180) / Math.PI;
            if (heading < 0) heading += 360;
        }
        
        return {
            lat: this.y.estimate,
            lng: this.x.estimate,
            accuracy: measurement.accuracy * (1 - Math.min(0.5, Math.max(gainX, gainY))), // Improved accuracy estimate
            timestamp: measurement.timestamp,
            heading: heading !== null ? heading : measurement.heading,
            speedMPS: speed > 0.1 ? speed : measurement.speedMPS,
            kalmanGain: Math.max(gainX, gainY) // Export gain for debugging
        };
    },
    
    // Project position forward in time (for predictions between updates)
    predict: function(dt) {
        if (dt <= 0 || this.x.estimate === 0 && this.y.estimate === 0) {
            return {
                lat: this.y.estimate,
                lng: this.x.estimate
            };
        }
        
        return {
            lat: this.y.estimate + this.vy.estimate * dt,
            lng: this.x.estimate + this.vx.estimate * dt,
            heading: this.getHeading(),
            speedMPS: this.getSpeed()
        };
    },
    
    // Get current speed estimate
    getSpeed: function() {
        return Math.sqrt(
            Math.pow(this.vx.estimate * 111320 * Math.cos((this.y.estimate * Math.PI) / 180), 2) +
            Math.pow(this.vy.estimate * 110540, 2)
        );
    },
    
    // Get current heading estimate
    getHeading: function() {
        const speed = this.getSpeed();
        if (speed < 0.1) return null;
        
        let heading = (Math.atan2(this.vx.estimate, this.vy.estimate) * 180) / Math.PI;
        if (heading < 0) heading += 360;
        return heading;
    },
    
    // Reset the filter
    reset: function(measurement) {
        this.x.estimate = measurement.lng;
        this.y.estimate = measurement.lat;
        this.vx.estimate = 0;
        this.vy.estimate = 0;
        this.x.error = 1;
        this.y.error = 1;
        this.vx.error = 1;
        this.vy.error = 1;
        this.lastTimestamp = measurement.timestamp;
    },
    
    // Adjust filter parameters dynamically
    adjustParameters: function(accuracy, isStationary, speedMPS) {
        // Dynamic process noise based on movement state
        if (isStationary) {
            this.q = 0.001; // Very low process noise when stationary
        } else {
            // Increase process noise with speed for more responsive tracking
            this.q = 0.005 + Math.min(0.03, speedMPS / 30);
        }
        
        // Measurement noise is set externally through this.r
    }
};
        /*
        const kalmanFilter = {
        x: { estimate: 0, error: 1 },
        y: { estimate: 0, error: 1 },
        q: 0.015, // Process noise
        r: 1,     // Measurement noise
        
        update: function(measurement) {
            // Initialize if first measurement
            if (this.x.estimate === 0 && this.y.estimate === 0) {
                this.x.estimate = measurement.lng;
                this.y.estimate = measurement.lat;
                return measurement;
            }
            
            // X coordinate (longitude)
            const predX = this.x.estimate;
            const predErrX = this.x.error + this.q;
            const gainX = predErrX / (predErrX + this.r);
            this.x.estimate = predX + gainX * (measurement.lng - predX);
            this.x.error = (1 - gainX) * predErrX;
            
            // Y coordinate (latitude)
            const predY = this.y.estimate;
            const predErrY = this.y.error + this.q;
            const gainY = predErrY / (predErrY + this.r);
            this.y.estimate = predY + gainY * (measurement.lat - predY);
            this.y.error = (1 - gainY) * predErrY;
            
            return {
                lat: this.y.estimate,
                lng: this.x.estimate,
                accuracy: measurement.accuracy,
                timestamp: measurement.timestamp,
                heading: measurement.heading,
                speedMPS: measurement.speedMPS
            };
        },
        
        reset: function(measurement) {
            this.x.estimate = measurement.lng;
            this.y.estimate = measurement.lat;
            this.x.error = 1;
            this.y.error = 1;
        }
    };
*/
    function updatePositionBuffer(position) {
        // Add new position to buffer
        positionBuffer.push({
            lat: position.lat,
            lng: position.lng,
            accuracy: position.accuracy,
            timestamp: position.timestamp,
            heading: position.heading,
            speedMPS: position.speedMPS
        });

        // Remove old positions if buffer exceeds maxSize
        while (positionBuffer.length > MAX_BUFFER_SIZE) {
            positionBuffer.shift();
        }
    }

    function calculateWeightedPosition(positions, smoothingFactor = 0.8) {
        if (!Array.isArray(positions) || positions.length === 0) {
            return null;
        }

        // Filter out invalid positions
        const validPositions = positions.filter(pos => 
            pos && typeof pos.lat === 'number' && typeof pos.lng === 'number' && 
            !isNaN(pos.lat) && !isNaN(pos.lng)
        );

        if (validPositions.length === 0) {
            return null;
        }

        let sumLat = 0, sumLng = 0, totalWeight = 0;

        for (let i = 0; i < validPositions.length; i++) {
            const position = validPositions[i];
            const weight = Math.pow(smoothingFactor, validPositions.length - i - 1);
            sumLat += position.lat * weight;
            sumLng += position.lng * weight;
            totalWeight += weight;
        }

        const result = {
            lat: sumLat / totalWeight,
            lng: sumLng / totalWeight,
            accuracy: Math.min(...validPositions.map(p => p.accuracy || 20)),
            timestamp: validPositions[validPositions.length - 1].timestamp,
            heading: validPositions[validPositions.length - 1].heading,
            speedMPS: validPositions[validPositions.length - 1].speedMPS
        };

        return result;
    }

    function getSpeedBasedZoom(speedMPS) {
        // Convert m/s to mph
        const speedMPH = speedMPS * 2.23694;

        for (const threshold of SPEED_ZOOM_THRESHOLDS) {
            if (speedMPH >= threshold.speed) {
                return threshold.zoom;
            }
        }

        // If speed is below the lowest threshold, return -1 to indicate user control
        return -1;
    }

    function isValidPosition(pos) {
        return pos && 
               typeof pos.lat === 'number' && !isNaN(pos.lat) &&
               typeof pos.lng === 'number' && !isNaN(pos.lng) &&
               typeof pos.accuracy === 'number' && !isNaN(pos.accuracy);
    }

    function applyExponentialSmoothing(newPosition, lastPosition, baseAlpha = 0.25) {
        // Validate inputs
        if (!isValidPosition(newPosition) || !isValidPosition(lastPosition)) {
            return newPosition;
        }

        // Initialize lastSmoothedPosition if it doesn't exist
        if (!lastSmoothedPosition) {
            lastSmoothedPosition = lastPosition;
        }

        const distance = calculateDistance(newPosition, lastSmoothedPosition);
        
        // Enhanced stationary detection
        if (distance < MIN_DISTANCE_THRESHOLD) {
            stationaryCount = Math.min(stationaryCount + 1, STATIONARY_THRESHOLD);
        } else {
            stationaryCount = Math.max(stationaryCount - 1, 0);
        }

        // Calculate adaptive alpha
        let alpha = baseAlpha;

        // Adjust alpha based on movement state
        if (stationaryCount >= STATIONARY_THRESHOLD) {
            alpha = MIN_ALPHA;
        } else {
            // Gradually reduce alpha as we approach stationary state
            alpha = MAX_ALPHA - (stationaryCount / STATIONARY_THRESHOLD) * (MAX_ALPHA - MIN_ALPHA);
        }

        // Accuracy-based adjustment
        const accuracyRatio = Math.max(0, Math.min(1, 1 - (newPosition.accuracy / MAX_ACCEPTABLE_ACCURACY)));
        alpha = alpha * (0.5 + 0.5 * accuracyRatio);

        // Speed-based adjustment
        if (newPosition.speedMPS !== undefined && newPosition.speedMPS < 0.5) {
            alpha *= 0.4; // Extra smoothing at very low speeds
        }

        // Time-based adjustment to handle GPS jitter
        const timeDelta = newPosition.timestamp - lastPosition.timestamp;
        if (timeDelta < 1000) { // If updates are very frequent
            alpha *= 0.7; // Reduce impact of rapid updates
        }

        // Apply smoothing with weighted factors
        const smoothedPosition = {
            lat: lastSmoothedPosition.lat + alpha * (newPosition.lat - lastSmoothedPosition.lat),
            lng: lastSmoothedPosition.lng + alpha * (newPosition.lng - lastSmoothedPosition.lng),
            accuracy: Math.min(newPosition.accuracy, lastSmoothedPosition.accuracy),
            heading: newPosition.heading,
            timestamp: newPosition.timestamp,
            speedMPS: newPosition.speedMPS ? 
                      lastSmoothedPosition.speedMPS * 0.7 + newPosition.speedMPS * 0.3 : // Smooth speed changes
                      newPosition.speedMPS
        };

        // Apply additional smoothing to heading when stationary
        if (stationaryCount >= STATIONARY_THRESHOLD && lastSmoothedPosition.heading !== undefined) {
            smoothedPosition.heading = alpha * newPosition.heading + (1 - alpha) * lastSmoothedPosition.heading;
        }

        // Additional stabilization for very small movements
        if (distance < MIN_DISTANCE_THRESHOLD * 0.5) {
            smoothedPosition.lat = lastSmoothedPosition.lat * 0.95 + smoothedPosition.lat * 0.05;
            smoothedPosition.lng = lastSmoothedPosition.lng * 0.95 + smoothedPosition.lng * 0.05;
        }

        // Update last smoothed position
        lastSmoothedPosition = smoothedPosition;

        return smoothedPosition;
    }

    function calculateVelocityFilter(newPos, lastPos) {
        if (!lastVelocity) {
            lastVelocity = { lat: 0, lng: 0 };
        }

        if (!newPos || !lastPos || 
            typeof newPos.lat !== 'number' || typeof newPos.lng !== 'number' || 
            typeof lastPos.lat !== 'number' || typeof lastPos.lng !== 'number') {
            return newPos;
        }

        const dt = (newPos.timestamp - lastPos.timestamp) / 1000;
        if (dt <= 0 || dt > 10) {
            return newPos;
        }

        const currentVelocity = {
            lat: (newPos.lat - lastPos.lat) / dt,
            lng: (newPos.lng - lastPos.lng) / dt
        };

        lastVelocity = {
            lat: lastVelocity.lat * VELOCITY_DECAY + currentVelocity.lat * (1 - VELOCITY_DECAY),
            lng: lastVelocity.lng * VELOCITY_DECAY + currentVelocity.lng * (1 - VELOCITY_DECAY)
        };

        // Apply velocity prediction
        return {
            lat: lastPos.lat + lastVelocity.lat * dt,
            lng: lastPos.lng + lastVelocity.lng * dt,
            accuracy: newPos.accuracy,
            timestamp: newPos.timestamp,
            heading: newPos.heading,
            speedMPS: newPos.speedMPS
        };
    }

    function checkStationaryState(newPosition) {
        if (!lastPosition) return;
        
        const distance = calculateDistance(lastPosition, newPosition);
        
        if (distance >= MICRO_MOVEMENT_THRESHOLD) {
            isStationary = false;
            stationaryStartTime = null;
            console.debug("Movement detected, resuming normal updates");
        }
        
        if (stationaryCheckTimeout) {
            clearTimeout(stationaryCheckTimeout);
            stationaryCheckTimeout = null;
        }
        
        if (isStationary) {
            stationaryCheckTimeout = setTimeout(() => checkStationaryState(newPosition), STATIONARY_CHECK_INTERVAL);
        }
    }

    function calculateFinalPosition() {
        // If buffer is empty, return null
        if (positionBuffer.length === 0) {
            return null;
        }
        
        // If only one position in buffer, return it
        if (positionBuffer.length === 1) {
            return positionBuffer[0];
        }
        
        // Calculate weighted average of positions in buffer
        return calculateWeightedPosition(positionBuffer);
    }

    function updateMarkerAndMap(position, speedMPS) {
        if (!position || typeof position.lat !== 'number' || typeof position.lng !== 'number') {
            console.warn("Invalid position for marker update");
            return;
        }
        
        // Update marker position with animation
        userMarker.setLatLng([position.lat, position.lng], { animate: true, duration: 0.3 });
        
        // Check if we need to recenter map based on user position
        if (followUser && !isMapInteracting) {
            const recenterInfo = shouldRecenter(map, userMarker);
            
            if (recenterInfo.needsRecenter) {
                const newCenter = recenterInfo.isEmergency ? 
                    [position.lat, position.lng] : 
                    calculateOptimalCenter(map, position, recenterInfo.edgeInfo);
                    
                map.panTo(newCenter, {
                    animate: true,
                    duration: recenterInfo.isEmergency ? 0.1 : 0.5,
                    easeLinearity: 0.5
                });
            }
            
            // Adjust zoom based on speed if needed
            const zoomLevel = getSpeedBasedZoom(speedMPS);
            if (zoomLevel !== -1 && Math.abs(map.getZoom() - zoomLevel) > 0.5) {
                map.setZoom(zoomLevel, { animate: true, duration: 1 });
                lastZoomLevel = zoomLevel; // Store the new zoom level
            }
        }
        
        // Update distance box
        updateDistanceBox();
    }
/*
    function updateUserLocation(position, forceUpdate = false) {
        // Validate input position
        if (!position?.coords?.latitude || !position?.coords?.longitude) {
            console.warn("Invalid position data received");
            return;
        }

        const currentTime = Date.now();
        const timeDelta = lastUpdateTime ? (currentTime - lastUpdateTime) / 1000 : 0;

        const newPosition = {
            lat: position.coords.latitude,
            lng: position.coords.longitude,
            accuracy: position.coords.accuracy || 20,
            heading: position.coords.heading ?? null,
            timestamp: currentTime,
            speedMPS: position.coords.speed || 0
        };

        // First position initialization
        if (!lastPosition) {
            lastPosition = newPosition;
            userMarker.setLatLng([newPosition.lat, newPosition.lng]);
            kalmanFilter.reset(newPosition);
            lastUpdateTime = currentTime;
            stationaryStartTime = currentTime;
            positionBuffer = [newPosition];
            
            const zoomLevel = getSpeedBasedZoom(newPosition.speedMPS);
            if (zoomLevel !== -1) {
                map.setZoom(zoomLevel, { animate: false });
                lastZoomLevel = zoomLevel;
            }
            map.setView([newPosition.lat, newPosition.lng], map.getZoom(), { animate: false });
            updateDistanceBox();
            return;
        }

        const distance = calculateDistance(lastPosition, newPosition);

        // Extended distance handling with immediate response
        if (distance > EXTENDED_DISTANCE_THRESHOLD || forceUpdate) {
            if (stationaryCheckTimeout) {
                clearTimeout(stationaryCheckTimeout);
                stationaryCheckTimeout = null;
            }
            isStationary = false;
            stationaryStartTime = null;

            userMarker.setLatLng([newPosition.lat, newPosition.lng], { animate: false });
            lastPosition = newPosition;
            positionBuffer = [newPosition];
            kalmanFilter.reset(newPosition);
            lastVelocity = { lat: 0, lng: 0 };

            const zoomLevel = getSpeedBasedZoom(newPosition.speedMPS);
            if (zoomLevel !== -1) {
                map.setZoom(zoomLevel, { animate: false });
                lastZoomLevel = zoomLevel;
            }
            map.setView([newPosition.lat, newPosition.lng], map.getZoom(), { 
                animate: false, 
                duration: 0,
                noMoveStart: true
            });
            
            lastUpdateTime = currentTime;
            lastUpdateTimestamp = currentTime;
            updateDistanceBox();
            
            if (map._container) {
                map._onResize();
            }
            return;
        }

        // Enhanced stationary detection with Kalman filtering
        kalmanFilter.r = newPosition.accuracy / 100; // Adjust measurement noise based on accuracy
        const kalmanFiltered = kalmanFilter.update({
            lat: newPosition.lat,
            lng: newPosition.lng,
            accuracy: newPosition.accuracy,
            heading: newPosition.heading,
            timestamp: newPosition.timestamp,
            speedMPS: newPosition.speedMPS
        });

        if (distance < MICRO_MOVEMENT_THRESHOLD && !forceUpdate) {
            if (!isStationary) {
                if (!stationaryStartTime) {
                    stationaryStartTime = currentTime;
                } else if (currentTime - stationaryStartTime >= STATIONARY_TIME_THRESHOLD) {
                    isStationary = true;
                    
                    // Use Kalman filter for stationary position
                    kalmanFilter.r = Math.min(newPosition.accuracy, lastPosition.accuracy) / 200; // Increase confidence when stationary
                    const stationaryPosition = kalmanFilter.update({
                        lat: newPosition.lat,
                        lng: newPosition.lng,
                        accuracy: Math.min(lastPosition.accuracy, newPosition.accuracy) * STATIONARY_ACCURACY_MULTIPLIER,
                        heading: newPosition.heading,
                        timestamp: newPosition.timestamp,
                        speedMPS: 0
                    });
                    
                    userMarker.setLatLng([stationaryPosition.lat, stationaryPosition.lng], { animate: false });
                    lastPosition = stationaryPosition;
                    positionBuffer = [stationaryPosition];
                    
                    if (stationaryCheckTimeout) clearTimeout(stationaryCheckTimeout);
                    stationaryCheckTimeout = setTimeout(() => checkStationaryState(newPosition), STATIONARY_CHECK_INTERVAL);
                    
                    updateDistanceBox();
                    return;
                }
            }
            
            if (isStationary) {
                // Apply tight Kalman filtering while stationary
                if (newPosition.accuracy < lastPosition.accuracy * 0.9) {
                    kalmanFilter.r = newPosition.accuracy / 400; // Even tighter filtering when stationary
                    const refinedPosition = kalmanFilter.update({
                        lat: newPosition.lat,
                        lng: newPosition.lng,
                        accuracy: newPosition.accuracy,
                        heading: newPosition.heading,
                        timestamp: newPosition.timestamp,
                        speedMPS: 0
                    });
                    
                    // Only apply the update if the movement is truly minimal
                    if (calculateDistance(lastPosition, refinedPosition) < MICRO_MOVEMENT_THRESHOLD / 2) {
                        userMarker.setLatLng([refinedPosition.lat, refinedPosition.lng], { animate: false });
                        lastPosition = refinedPosition;
                        updateDistanceBox();
                    }
                }
                return;
            }
        } else {
            isStationary = false;
            stationaryStartTime = null;
            if (stationaryCheckTimeout) {
                clearTimeout(stationaryCheckTimeout);
                stationaryCheckTimeout = null;
            }
            // Reset Kalman filter noise when moving
            kalmanFilter.r = newPosition.accuracy / 50;
        }

        // Skip updates with poor accuracy or unrealistic movement
        if (!forceUpdate && (
            newPosition.accuracy > MAX_ACCEPTABLE_ACCURACY ||
            distance < MIN_DISTANCE_THRESHOLD ||
            (timeDelta > 0 && distance / timeDelta > MAX_SPEED)
        )) {
            return;
        }

        try {
            // Apply Kalman filter to movement updates
            kalmanFilter.r = newPosition.accuracy / 75; // Balanced filtering for movement
            const filteredPosition = kalmanFilter.update({
                lat: newPosition.lat,
                lng: newPosition.lng,
                accuracy: newPosition.accuracy,
                heading: newPosition.heading,
                timestamp: newPosition.timestamp,
                speedMPS: newPosition.speedMPS
            });

            // Update position buffer with Kalman filtered positions
            updatePositionBuffer(filteredPosition);

            // Calculate final position using buffer of Kalman filtered positions
            const finalPosition = calculateFinalPosition();
            if (!finalPosition) throw new Error("Final position calculation failed");

            // Apply velocity-based prediction for smoother movement
            const predictedPosition = calculateVelocityFilter(finalPosition, lastPosition);

            // Apply final smoothing for smooth transition
            const smoothedPosition = applyExponentialSmoothing(predictedPosition, lastPosition);

            // Update marker and map with smoothed position
            updateMarkerAndMap(smoothedPosition, newPosition.speedMPS);

            lastPosition = smoothedPosition;
            lastUpdateTime = currentTime;
            lastUpdateTimestamp = currentTime;

        } catch (error) {
            console.error("Location update error:", error);
            // Fallback with basic Kalman filtering
            kalmanFilter.r = newPosition.accuracy / 50;
            const fallbackPosition = kalmanFilter.update(newPosition);
            userMarker.setLatLng([fallbackPosition.lat, fallbackPosition.lng], { animate: true, duration: 0.3 });
            lastPosition = fallbackPosition;
            positionBuffer = [fallbackPosition];
            updateDistanceBox();
        }
    }
*/

function updateUserLocation(position, forceUpdate = false) {
    // Validate input position
    if (!position?.coords?.latitude || !position?.coords?.longitude) {
        console.warn("Invalid position data received");
        return;
    }

    const currentTime = Date.now();
    const timeDelta = lastUpdateTime ? (currentTime - lastUpdateTime) / 1000 : 0;

    // Enhanced position object with additional properties
    const newPosition = {
        lat: position.coords.latitude,
        lng: position.coords.longitude,
        accuracy: position.coords.accuracy || 20,
        heading: position.coords.heading ?? null,
        timestamp: currentTime,
        speedMPS: position.coords.speed || calculateSpeedFromLastPosition(position, lastPosition, timeDelta),
        altitude: position.coords.altitude || null,
        altitudeAccuracy: position.coords.altitudeAccuracy || null
    };

    // First position initialization with improved initial settings
    if (!lastPosition) {
        lastPosition = newPosition;
        userMarker.setLatLng([newPosition.lat, newPosition.lng]);
        kalmanFilter.reset(newPosition);
        lastUpdateTime = currentTime;
        stationaryStartTime = currentTime;
        positionBuffer = [newPosition];
        lastAcceleration = { lat: 0, lng: 0 };  // Track acceleration for better prediction
        
        const zoomLevel = getSpeedBasedZoom(newPosition.speedMPS);
        if (zoomLevel !== -1) {
            map.setZoom(zoomLevel, { animate: false });
            lastZoomLevel = zoomLevel;
        }
        map.setView([newPosition.lat, newPosition.lng], map.getZoom(), { animate: false });
        updateDistanceBox();
        
        // Start animation loop for smoother rendering
        if (!animationFrameId) {
            startSmoothAnimationLoop();
        }
        return;
    }

    // Debounce rapid updates for performance (add this)
    if (!forceUpdate && timeDelta < MIN_UPDATE_INTERVAL && !isFirstFewUpdates) {
        pendingPosition = newPosition; // Store for later processing
        return;
    }

    const distance = calculateDistance(lastPosition, newPosition);

    // Calculate confidence factor based on accuracy and consistency
    const confidenceFactor = calculateConfidenceFactor(newPosition, lastPosition);
    
    // Extended distance handling with immediate response
    if (distance > EXTENDED_DISTANCE_THRESHOLD || forceUpdate) {
        if (stationaryCheckTimeout) {
            clearTimeout(stationaryCheckTimeout);
            stationaryCheckTimeout = null;
        }
        isStationary = false;
        stationaryStartTime = null;

        // Only reset completely if confidence is high or it's a forced update
        if (confidenceFactor > 0.7 || forceUpdate) {
            userMarker.setLatLng([newPosition.lat, newPosition.lng], { animate: false });
            lastPosition = newPosition;
            positionBuffer = [newPosition];
            kalmanFilter.reset(newPosition);
            lastVelocity = { lat: 0, lng: 0 };
            lastAcceleration = { lat: 0, lng: 0 };
        } else {
            // For lower confidence jumps, apply a weighted transition
            const transitionPosition = {
                lat: lastPosition.lat * 0.3 + newPosition.lat * 0.7,
                lng: lastPosition.lng * 0.3 + newPosition.lng * 0.7,
                accuracy: newPosition.accuracy,
                heading: newPosition.heading,
                timestamp: currentTime,
                speedMPS: newPosition.speedMPS
            };
            userMarker.setLatLng([transitionPosition.lat, transitionPosition.lng], { animate: true, duration: 0.3 });
            lastPosition = transitionPosition;
            positionBuffer = [transitionPosition];
            kalmanFilter.reset(transitionPosition);
        }

        const zoomLevel = getSpeedBasedZoom(newPosition.speedMPS);
        if (zoomLevel !== -1 && Math.abs(lastZoomLevel - zoomLevel) > 1) {
            map.setZoom(zoomLevel, { animate: true, duration: 0.5 });
            lastZoomLevel = zoomLevel;
        }
        
        map.setView([lastPosition.lat, lastPosition.lng], map.getZoom(), { 
            animate: true, 
            duration: 0.5,
            noMoveStart: true
        });
        
        lastUpdateTime = currentTime;
        lastUpdateTimestamp = currentTime;
        updateDistanceBox();
        
        return;
    }

    // Dynamic Kalman filter tuning based on movement and accuracy
    const dynamicKalmanR = calculateDynamicKalmanNoise(newPosition, lastPosition, isStationary);
    kalmanFilter.r = dynamicKalmanR;

    // Enhanced stationary detection with adaptive thresholds
    const stationaryThreshold = Math.min(
        MICRO_MOVEMENT_THRESHOLD,
        Math.max(newPosition.accuracy * 0.08, MIN_STATIONARY_THRESHOLD)
    );

    if (distance < stationaryThreshold && !forceUpdate) {
        handleStationaryState(newPosition, currentTime);
        return;
    } else {
        isStationary = false;
        stationaryStartTime = null;
        if (stationaryCheckTimeout) {
            clearTimeout(stationaryCheckTimeout);
            stationaryCheckTimeout = null;
        }
    }

    // Enhanced movement quality check with adaptive thresholds
    const maxAcceptableAccuracy = calculateDynamicAccuracyThreshold(newPosition.speedMPS);
    const maxSpeedThreshold = calculateDynamicSpeedThreshold(lastPosition.speedMPS);
    
    if (!forceUpdate && (
        newPosition.accuracy > maxAcceptableAccuracy ||
        distance < calculateDynamicMinDistance(timeDelta, newPosition.accuracy) ||
        (timeDelta > 0 && distance / timeDelta > maxSpeedThreshold)
    )) {
        // Store rejected position for analysis and potential recovery
        rejectedPositions.push({position: newPosition, reason: 'quality_check_failed'});
        if (rejectedPositions.length > MAX_REJECTED_POSITIONS) {
            rejectedPositions.shift();
        }
        return;
    }

    try {
        // Apply Enhanced Kalman filter with predictive components
        const filteredPosition = applyEnhancedKalmanFilter(newPosition, lastPosition, timeDelta);
        
        // Update position buffer with intelligent weighting
        updatePositionBuffer(filteredPosition, confidenceFactor);

        // Calculate final position using weighted buffer algorithm
        const finalPosition = calculateWeightedFinalPosition();
        if (!finalPosition) throw new Error("Final position calculation failed");

        // Apply velocity and acceleration based prediction
        const predictedPosition = calculateAdvancedPrediction(finalPosition, lastPosition, timeDelta);

        // Apply adaptive smoothing based on speed and accuracy
        const smoothingFactor = calculateAdaptiveSmoothingFactor(newPosition, lastPosition);
        const smoothedPosition = applyAdaptiveSmoothing(predictedPosition, lastPosition, smoothingFactor);

        // Update position state
        updatePositionState(smoothedPosition, newPosition.speedMPS);

        // Queue visual update for next animation frame
        pendingVisualUpdate = {
            position: smoothedPosition,
            speedMPS: newPosition.speedMPS,
            timestamp: currentTime
        };

        lastPosition = smoothedPosition;
        lastUpdateTime = currentTime;
        lastUpdateTimestamp = currentTime;
        
        // Update velocities and accelerations for next prediction
        updateMotionVectors(smoothedPosition, lastPosition, timeDelta);

    } catch (error) {
        console.error("Location update error:", error);
        // Improved fallback with weighted combination
        applyFallbackUpdate(newPosition);
    }
}

// New helper function for dynamic Kalman filter tuning
function calculateDynamicKalmanNoise(newPosition, lastPosition, isStationary) {
    if (isStationary) {
        return newPosition.accuracy / 400; // Tighter filtering when stationary
    }
    
    // Adjust noise based on accuracy, speed and consistency
    const speedFactor = Math.min(1, newPosition.speedMPS / 5); // 0-1 factor based on speed
    const accuracyRatio = newPosition.accuracy / (lastPosition?.accuracy || 20);
    
    // Lower values = more filtering/smoothing
    let dynamicR = newPosition.accuracy / (75 + 50 * speedFactor); 
    
    // Adjust for sudden accuracy changes
    if (accuracyRatio > 2) { // Accuracy suddenly worse
        dynamicR *= 0.7; // More filtering
    } else if (accuracyRatio < 0.5) { // Accuracy suddenly better
        dynamicR *= 1.2; // Less filtering, trust the measurement more
    }
    
    return Math.max(newPosition.accuracy / 400, Math.min(dynamicR, newPosition.accuracy / 25));
}

// New helper function for adaptive smoothing
function calculateAdaptiveSmoothingFactor(newPosition, lastPosition) {
    // Base smoothing factor - higher values = more smoothing
    let smoothingFactor = 0.75;
    
    // Adjust for speed (less smoothing at higher speeds for responsiveness)
    smoothingFactor -= Math.min(0.4, newPosition.speedMPS / 15);
    
    // Adjust for accuracy (more smoothing for lower accuracy)
    smoothingFactor += Math.min(0.2, (newPosition.accuracy - MIN_EXPECTED_ACCURACY) / 100);
    
    // Adjust for heading changes (less smoothing during turns)
    if (lastPosition?.heading != null && newPosition.heading != null) {
        const headingDiff = Math.abs(lastPosition.heading - newPosition.heading);
        if (headingDiff > 15 && headingDiff < 180) {
            smoothingFactor -= Math.min(0.3, headingDiff / 180);
        }
    }
    
    return Math.max(0.3, Math.min(smoothingFactor, 0.9));
}

// New function for improved animation
function startSmoothAnimationLoop() {
    // Use requestAnimationFrame for smoother visual updates
    function animationLoop(timestamp) {
        // Apply interpolation if we have a pending update
        if (pendingVisualUpdate) {
            // Calculate interpolation factor based on time since update
            const timeSinceUpdate = timestamp - pendingVisualUpdate.timestamp;
            
            // Create smooth transition
            applyVisualUpdate(pendingVisualUpdate, timeSinceUpdate);
            
            // Clear pending update if fully applied
            if (timeSinceUpdate > VISUAL_UPDATE_DURATION) {
                pendingVisualUpdate = null;
            }
        }
        
        // Apply any motion prediction if needed
        if (lastPosition && !isStationary && (Date.now() - lastUpdateTime) > PREDICTION_THRESHOLD) {
            applyMotionPrediction();
        }
        
        animationFrameId = requestAnimationFrame(animationLoop);
    }
    
    animationFrameId = requestAnimationFrame(animationLoop);
}

// New function for advanced position prediction
function calculateAdvancedPrediction(currentPosition, lastPosition, timeDelta) {
    if (!lastVelocity || !lastAcceleration || timeDelta <= 0) {
        return currentPosition;
    }
    
    // Calculate predicted position using current velocity and acceleration
    // using motion equations: position = initial_position + velocity*time + 0.5*acceleration*timeÂ²
    const predictionFactor = Math.min(1, Math.max(0.1, timeDelta));
    
    return {
        lat: currentPosition.lat + (lastVelocity.lat * predictionFactor) + 
             (0.5 * lastAcceleration.lat * predictionFactor * predictionFactor),
        lng: currentPosition.lng + (lastVelocity.lng * predictionFactor) + 
             (0.5 * lastAcceleration.lng * predictionFactor * predictionFactor),
        accuracy: currentPosition.accuracy,
        heading: currentPosition.heading,
        timestamp: currentPosition.timestamp,
        speedMPS: currentPosition.speedMPS,
        altitude: currentPosition.altitude,
        altitudeAccuracy: currentPosition.altitudeAccuracy
    };
}

// Calculate speed when not provided by GPS
function calculateSpeedFromLastPosition(position, lastPosition, timeDelta) {
    if (!lastPosition || timeDelta <= 0) return 0;
    
    const distance = calculateDistance(
        {lat: lastPosition.lat, lng: lastPosition.lng}, 
        {lat: position.coords.latitude, lng: position.coords.longitude}
    );
    
    return distance / timeDelta; // meters per second
}
        
    function calculateEdgeProximity(map, point) {
        const bounds = map.getBounds();
        const latSpan = bounds.getNorth() - bounds.getSouth();
        const lngSpan = bounds.getEast() - bounds.getWest();
        
        return {
            north: Math.abs(point.lat - bounds.getNorth()) / latSpan,
            south: Math.abs(point.lat - bounds.getSouth()) / latSpan,
            east: Math.abs(point.lng - bounds.getEast()) / lngSpan,
            west: Math.abs(point.lng - bounds.getWest()) / lngSpan
        };
    }

    function isMarkerNearEdge(map, marker, isStrict = false) {
        const bounds = map.getBounds();
        const point = marker.getLatLng();
        const proximities = calculateEdgeProximity(map, point);
        
        const thresholdPercentage = isStrict ? 
            STRICT_EDGE_THRESHOLD_PERCENTAGE : 
            EDGE_THRESHOLD_PERCENTAGE;
        
        const edges = {
            north: proximities.north < thresholdPercentage,
            south: proximities.south < thresholdPercentage,
            east: proximities.east < thresholdPercentage,
            west: proximities.west < thresholdPercentage
        };
        
        return {
            isNearEdge: Object.values(edges).some(edge => edge),
            edges: edges,
            proximities: proximities
        };
    }

    function calculateOptimalCenter(map, markerPosition, edgeInfo) {
        const bounds = map.getBounds();
        
        let latOffset = 0;
        let lngOffset = 0;
        
        if (edgeInfo.edges.north) latOffset = -1 * (bounds.getNorth() - bounds.getSouth()) * 0.2;
        if (edgeInfo.edges.south) latOffset = (bounds.getNorth() - bounds.getSouth()) * 0.2;
        if (edgeInfo.edges.east) lngOffset = -1 * (bounds.getEast() - bounds.getWest()) * 0.2;
        if (edgeInfo.edges.west) lngOffset = (bounds.getEast() - bounds.getWest()) * 0.2;
        
        return {
            lat: markerPosition.lat + latOffset,
            lng: markerPosition.lng + lngOffset
        };
    }

    function shouldRecenter(map, marker) {
        const now = Date.now();
        if (now - lastRecenterTime < MIN_RECENTER_INTERVAL) {
            return { needsRecenter: false };
        }
        
        const edgeInfo = isMarkerNearEdge(map, marker);
        const proximities = edgeInfo.proximities;
        
        const isCritical = Object.values(proximities).some(
            proximity => proximity < CRITICAL_EDGE_THRESHOLD_PERCENTAGE
        );
        
        if (isCritical) {
            lastRecenterTime = now;
            return {
                needsRecenter: true,
                isEmergency: true,
                edgeInfo: edgeInfo
            };
        }
        
        if (edgeInfo.isNearEdge) {
            lastRecenterTime = now;
            return {
                needsRecenter: true,
                isEmergency: false,
                edgeInfo: edgeInfo
            };
        }
        
        return {
            needsRecenter: false,
            isEmergency: false,
            edgeInfo: edgeInfo
        };
    }

    function updateDistanceBox() {
        const distanceBox = document.getElementById('distanceBox');
        
        // Initial validation
        if (!userMarker || !gameLocations || gameLocations.length === 0) {
            distanceBox.innerText = 'Initializing...';
            return;
        }

        // Get user coordinates
        const userLatLng = userMarker.getLatLng();
        let userLat = userLatLng.lat;
        let userLng = userLatLng.lng;

        // Coordinate validation
        if (!isFinite(userLat) || !isFinite(userLng)) {
            console.warn('Invalid user coordinates:', userLat, userLng);
            distanceBox.innerText = 'Initializing...';
            return;
        }

        // Use map center if at origin
        if (userLat === 0 && userLng === 0) {
            const center = map.getCenter();
            userLat = center.lat;
            userLng = center.lng;
        }

        // Find closest location
        let closestDistance = Infinity;
        let closestLocation = null;
        const userPos = { lat: userLat, lng: userLng };

        for (const location of gameLocations) {
            if (!location || typeof location.lat !== 'number' || typeof location.lng !== 'number') {
                console.warn('Invalid location data:', location);
                continue;
            }

            const locationPos = { lat: location.lat, lng: location.lng };
            const distance = calculateDistance(userPos, locationPos);

            if (isFinite(distance) && distance < closestDistance) {
                closestDistance = distance;
                closestLocation = location;
            }
        }

        // Validate final distance calculation
        if (!isFinite(closestDistance) || closestDistance === Infinity) {
            console.warn('Invalid distance calculation:', closestDistance);
            distanceBox.innerText = 'Initializing...';
            return;
        }

        // Calculate and display distance
        const distanceFeet = Math.round(closestDistance * 3.28084);
        const distanceText = distanceFeet < 5280 
            ? `${distanceFeet.toLocaleString()} feet` 
            : `${(distanceFeet / 5280).toFixed(2)} miles`;
        
        distanceBox.innerText = `Closest Stop: ${distanceText}`;

        // Check if we should show location hunt
        if (distanceFeet <= DISTANCE_THRESHOLD && !isLocationHuntVisible && closestLocation) {
            showLocationHunt(closestLocation);
        }
    }

    // Calculate distance between two points using Haversine formula
    function calculateDistance(pos1, pos2) {
        if (!pos1 || !pos2 || 
            typeof pos1.lat !== 'number' || typeof pos1.lng !== 'number' || 
            typeof pos2.lat !== 'number' || typeof pos2.lng !== 'number') {
            return Infinity;
        }
        
        // Haversine formula implementation
        const R = 6371000; // Earth's radius in meters
        const lat1 = pos1.lat * Math.PI / 180;
        const lat2 = pos2.lat * Math.PI / 180;
        const deltaLat = (pos2.lat - pos1.lat) * Math.PI / 180;
        const deltaLng = (pos2.lng - pos1.lng) * Math.PI / 180;

        const a = Math.sin(deltaLat/2) * Math.sin(deltaLat/2) +
                Math.cos(lat1) * Math.cos(lat2) *
                Math.sin(deltaLng/2) * Math.sin(deltaLng/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

        return R * c;
    }

    function getGeolocationOptions(retryNumber) {
        return {
            enableHighAccuracy: retryNumber < 2,
            timeout: retryNumber === 0 ? FIRST_LOCATION_TIMEOUT : SECOND_LOCATION_TIMEOUT,
            maximumAge: retryNumber * 5000
        };
    }

    function handleLocationError(error) {
        console.warn("Error getting user location:", error);
        
        if (retryCount < MAX_RETRIES) {
            retryCount++;
            console.log(`Retrying to get location (Attempt ${retryCount} of ${MAX_RETRIES})`);
            
            setTimeout(() => {
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        console.log("Location retrieved successfully after retry");
                        hideLoadingMessage();
                        updateUserLocation(position, true);
                        retryCount = 0;
                    },
                    handleLocationError,
                    getGeolocationOptions(retryCount)
                );
            }, RETRY_DELAY);
            return;
        }
        
        retryCount = 0;
        hideLoadingMessage();
        
        let errorMessage = "An error occurred while getting your location.";
        if (error && error.code) {
            switch(error.code) {
                case 1:
                    errorMessage = "Please allow access to your location to use this feature.";
                    break;
                case 2:
                    errorMessage = "Your location is currently unavailable. Please try again later.";
                    break;
                case 3:
                    errorMessage = "Getting your location took too long. Please try again.";
                    break;
            }
        }
        showPopup("Location Error", errorMessage);
    }

    function showPopup(title, message, type = 'info', callback = null) {
        // Remove any existing popups
        const existingPopups = document.querySelectorAll('.popup');
        existingPopups.forEach(popup => {
            if (document.body.contains(popup)) {
                document.body.removeChild(popup);
            }
        });
        
        const popup = document.createElement('div');
        popup.classList.add('popup', 'fade-in');
        popup.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 3000;
            display: flex;
            justify-content: center;
            align-items: center;
        `;

        const popupContent = document.createElement('div');
        popupContent.style.cssText = `
            background-color: white;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            max-width: 85%;
            width: 350px;
            text-align: center;
        `;

        const titleElement = document.createElement('h3');
        titleElement.textContent = title;
        titleElement.style.cssText = `
            margin-bottom: 15px;
            font-size: 20px;
            font-weight: 600;
            color: var(--primary-color);
        `;

        const messageElement = document.createElement('p');
        messageElement.textContent = message;
        messageElement.style.cssText = `
            margin-bottom: 25px;
            font-size: 16px;
            line-height: 1.5;
            color: #333;
        `;

        const buttonContainer = document.createElement('div');
        buttonContainer.style.cssText = `
            display: flex;
            justify-content: center;
            gap: 15px;
        `;

        const okButton = document.createElement('button');
        okButton.textContent = 'OK';
        okButton.classList.add('touch-target');
        okButton.style.cssText = `
            padding: 10px 25px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            transition: background-color 0.2s;
        `;
        okButton.onmouseover = () => { okButton.style.backgroundColor = '#004b7d'; };
        okButton.onmouseout = () => { okButton.style.backgroundColor = 'var(--primary-color)'; };

        okButton.addEventListener('click', () => {
            provideHapticFeedback();
            popup.classList.add('fade-out');
            setTimeout(() => {
                if (document.body.contains(popup)) {
                    document.body.removeChild(popup);
                }
                if (callback) callback();
            }, 300);
        });

        buttonContainer.appendChild(okButton);

        if (type === 'info') {
            const cancelButton = document.createElement('button');
            cancelButton.textContent = 'Cancel';
            cancelButton.classList.add('touch-target');
            cancelButton.style.cssText = `
                padding: 10px 25px;
                background-color: #f2f2f2;
                color: #333;
                border: none;
                border-radius: 8px;
                cursor: pointer;
                font-size: 16px;
                font-weight: 500;
                transition: background-color 0.2s;
            `;
            cancelButton.onmouseover = () => { cancelButton.style.backgroundColor = '#e0e0e0'; };
            cancelButton.onmouseout = () => { cancelButton.style.backgroundColor = '#f2f2f2'; };

            cancelButton.addEventListener('click', () => {
                provideHapticFeedback();
                popup.classList.add('fade-out');
                setTimeout(() => {
                    if (document.body.contains(popup)) {
                        document.body.removeChild(popup);
                    }
                }, 300);
            });

            buttonContainer.appendChild(cancelButton);
        }

        popupContent.appendChild(titleElement);
        popupContent.appendChild(messageElement);
        popupContent.appendChild(buttonContainer);
        popup.appendChild(popupContent);
        document.body.appendChild(popup);
        
        // Add to active modals
        activeModals.push(popup);
        
        // Reset auto-recenter timer when showing a popup
        startAutoRecenterTimer();
    }

    function recenterMap() {
        const recenterButton = document.getElementById('recenterButton');
        recenterButton.style.backgroundColor = 'var(--primary-color)';
        recenterButton.style.color = 'white';
        recenterButton.classList.add('haptic-feedback');
        provideHapticFeedback();
        
        if (userMarker && userMarker.getLatLng()) {
            map.closePopup();
            // Use the stored zoom level or current zoom level
            const zoomToUse = lastZoomLevel || map.getZoom();
            
            map.setView(userMarker.getLatLng(), zoomToUse, {
                animate: true,
                duration: 0.5
            });
            followUser = true;
            
            // Reset auto-recenter timer
            stopAutoRecenterCountdown();
            startAutoRecenterTimer();
        }
        
        setTimeout(() => {
            recenterButton.style.backgroundColor = 'white';
            recenterButton.style.color = 'var(--primary-color)';
            recenterButton.classList.remove('haptic-feedback');
        }, 500);
    }

    let lastVisitTime = 0;
    const cooldownPeriod = 3 * 60 * 1000; // 3 minutes

    function showLocationHunt(location) {
        const now = performance.now();
        if (location.id === lastVisitedLocationId && now - lastVisitTime < cooldownPeriod) {
            console.log(`Location ${location.id} is on cooldown. Skipping.`);
            return;
        }
        
        lastVisitedLocationId = location.id;
        lastVisitTime = now;
        isLocationHuntVisible = true;
        
        // Stop auto-recenter countdown when showing location hunt
        stopAutoRecenterCountdown();

        const lochuntContainer = document.querySelector('.lochunt-container');
        lochuntContainer.innerHTML = '';
        lochuntContainer.style.display = 'flex';
        lochuntContainer.classList.add('fade-in');

        const scrollableContent = document.createElement('div');
        scrollableContent.style.cssText = `
            flex: 1;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            scroll-behavior: smooth;
            will-change: scroll-position;
        `;

        // Use cached image if available
        let locationImage;
        if (imageCache[location.id]) {
            console.log(`Using cached image for location ${location.id}`);
            locationImage = imageCache[location.id].cloneNode(false);
        } else {
            locationImage = new Image();
            locationImage.src = location.image;
        }
        
        locationImage.alt = location.name;
        locationImage.style.cssText = `
            width: 100%;
            height: 45vh;
            object-fit: cover;
            object-position: center;
        `;
        locationImage.loading = "eager"; // Prioritize image loading

        scrollableContent.appendChild(locationImage);
 
        const contentContainer = document.createElement('div');
        contentContainer.classList.add('lochunt-content');
        contentContainer.style.cssText = `
            padding: 24px;
            display: flex;
            flex-direction: column;
            align-items: center;
            max-width: 800px;
            margin: 0 auto;
        `;
        
        const locationInfo = document.createElement('div');
        locationInfo.classList.add('lochunt-info');
        locationInfo.style.cssText = `
            text-align: center;
            width: 100%;
            margin-bottom: 15px;
        `;
        
        const locationName = document.createElement('h1');
        locationName.textContent = location.name;
        locationName.style.cssText = `
            font-size: clamp(1.8rem, 4vw, 2.5rem);
            font-weight: 700;
            color: #1a1a1a;
            margin-bottom: 8px;
            line-height: 1.2;
        `;
        
        const locationCity = document.createElement('p');
        locationCity.textContent = `${location.city}`;
        locationCity.style.cssText = `
            font-size: clamp(1.1rem, 2vw, 1.3rem);
            color: #2c5282;
            font-weight: 600;
            margin-bottom: 4px;
        `;
        
        const locationCreator = document.createElement('p');
        locationCreator.textContent = `Created by: ${location.creator}`;
        locationCreator.style.cssText = `
            font-size: calc(0.9rem + 0.4vw);
            color: #666666;
            font-weight: 500;
        `;
        
        locationInfo.appendChild(locationName);
        locationInfo.appendChild(locationCity);
        locationInfo.appendChild(locationCreator);
        contentContainer.appendChild(locationInfo);
        
        const audioPlayerContainer = createAudioPlayer(location.audio);
        contentContainer.appendChild(audioPlayerContainer);
        scrollableContent.appendChild(contentContainer);
        lochuntContainer.appendChild(scrollableContent);
        
        const blueBar = createBlueBar(location);
        blueBar.style.cssText += `
            position: sticky;
            bottom: 0;
            width: 100%;
        `;
        lochuntContainer.appendChild(blueBar);
        
        // Initialize audio player after DOM is updated
        setTimeout(() => {
            initAudioPlayer();
        }, 100);
    }

    function createAudioPlayer(audioSrc) {
        const audioPlayerContainer = document.createElement('div');
        audioPlayerContainer.classList.add('audio-player');
        audioPlayerContainer.style.cssText = `
            width: 100%;
            max-width: 400px;
            margin-bottom: 15px;
        `;

        const audio = document.createElement('audio');
        audio.id = 'locationAudio';
        audio.src = audioSrc;
        audio.preload = "auto";

        const audioProgress = document.createElement('div');
        audioProgress.classList.add('audio-progress');
        audioProgress.style.cssText = `
            width: 100%;
            margin-bottom: 15px;
        `;

        const progressContainer = document.createElement('div');
        progressContainer.classList.add('progress');
        progressContainer.style.cssText = `
            height: 8px;
            background-color: #e2e8f0;
            border-radius: 4px;
            cursor: pointer;
            margin-bottom: 12px;
            overflow: hidden;
        `;

        const progressBar = document.createElement('div');
        progressBar.id = 'progressBar';
        progressBar.classList.add('progress-bar');
        progressBar.style.cssText = `
            height: 100%;
            background-color: #2c5282;
            width: 0%;
            transition: width 0.1s linear;
        `;

        progressContainer.appendChild(progressBar);
        audioProgress.appendChild(progressContainer);

        const timeInfo = document.createElement('div');
        timeInfo.classList.add('audio-time');
        timeInfo.style.cssText = `
            display: flex;
            justify-content: space-between;
            color: #4a5568;
            font-size: 0.875rem;
            margin-bottom: 16px;
            font-weight: 500;
        `;

        const currentTimeSpan = document.createElement('span');
        currentTimeSpan.id = 'currentTime';
        currentTimeSpan.textContent = '0:00';

        const durationSpan = document.createElement('span');
        durationSpan.id = 'duration';
        durationSpan.textContent = '0:00';

        timeInfo.appendChild(currentTimeSpan);
        timeInfo.appendChild(durationSpan);

        const audioControls = document.createElement('div');
        audioControls.classList.add('audio-controls');
        audioControls.style.cssText = `
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 24px;
        `;

        const rewindBtn = createAudioButton('skip-backward', 'rewindBtn', 'Rewind 10 seconds');
        const playPauseBtn = createAudioButton('play', 'playPauseBtn', 'Play');
        const forwardBtn = createAudioButton('skip-forward', 'forwardBtn', 'Forward 10 seconds');

        audioControls.appendChild(rewindBtn);
        audioControls.appendChild(playPauseBtn);
        audioControls.appendChild(forwardBtn);

        audioPlayerContainer.appendChild(audio);
        audioPlayerContainer.appendChild(audioProgress);
        audioPlayerContainer.appendChild(timeInfo);
        audioPlayerContainer.appendChild(audioControls);

        return audioPlayerContainer;
    }

    function createAudioButton(iconName, id, ariaLabel) {
        const button = document.createElement('button');
        button.id = id;
        button.classList.add('audio-button', 'touch-target', 'interactive');
        button.setAttribute('aria-label', ariaLabel);
        button.innerHTML = `<i class="bi bi-${iconName}"></i>`;
        button.style.cssText = `
            background-color: white;
            color: var(--primary-color);
            border: 2px solid var(--primary-color);
            border-radius: 50%;
            width: 55px;
            height: 55px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
        `;

        button.addEventListener('mouseover', () => {
            button.style.backgroundColor = 'var(--hover-color)';
        });

        button.addEventListener('mouseout', () => {
            button.style.backgroundColor = 'white';
        });

        button.addEventListener('click', () => {
            provideHapticFeedback();
            button.style.backgroundColor = 'var(--primary-color)';
            button.style.color = 'white';
            button.style.transform = 'scale(0.95)';
            
            setTimeout(() => {
                button.style.backgroundColor = 'white';
                button.style.color = 'var(--primary-color)';
                button.style.transform = 'scale(1)';
            }, 200);
        });

        return button;
    }

    function createBlueBar(location) {
        const blueBar = document.createElement('div');
        blueBar.style.cssText = `
            width: 100%;
            height: 60px;
            background: linear-gradient(to right, #2c5282, #2b6cb0);
            margin-top: auto;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.025);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 24px;
            position: sticky;
            bottom: 0;
        `;
        
        const infoButton = document.createElement('button');
        infoButton.innerHTML = '<i class="bi bi-info-circle-fill text-white" style="font-size: 1.5rem; z-index: 2500;"></i>';
        infoButton.classList.add('btn', 'btn-sm', 'me-2', 'touch-target', 'interactive');
        infoButton.setAttribute('aria-label', 'Image source information');
        infoButton.onclick = () => {
            provideHapticFeedback();
            if (location && location.imageSource) {
                showPopup('Image Source', location.imageSource);
            } else {
                showPopup('Image Source', 'Image source information is not available');
            }
        };

        const feedbackButton = document.createElement('a');
        feedbackButton.href = 'mailto:mattreicher@protonmail.com?subject=Feedback';
        feedbackButton.target = '_blank';
        feedbackButton.rel = 'noopener noreferrer';
        feedbackButton.setAttribute('aria-label', 'Send feedback email');
        feedbackButton.innerHTML = '<i class="bi bi-envelope-fill text-white" style="font-size: 1.5rem;"></i>';
        feedbackButton.classList.add('btn', 'btn-sm', 'touch-target', 'interactive');

        blueBar.appendChild(infoButton);
        blueBar.appendChild(feedbackButton);
        return blueBar;
    }

    function initAudioPlayer() {
        const audio = document.getElementById('locationAudio');
        const playPauseBtn = document.getElementById('playPauseBtn');
        const rewindBtn = document.getElementById('rewindBtn');
        const forwardBtn = document.getElementById('forwardBtn');
        const progressBar = document.getElementById('progressBar');
        const progressContainer = document.querySelector('.progress');
        const currentTimeSpan = document.getElementById('currentTime');
        const durationSpan = document.getElementById('duration');

        if (!audio || !playPauseBtn || !progressBar) {
            console.error("Audio player elements not found");
            return;
        }

        // Set up event listeners
        playPauseBtn.addEventListener('click', togglePlay);
        rewindBtn.addEventListener('click', () => seek(-10));
        forwardBtn.addEventListener('click', () => seek(10));
        audio.addEventListener('timeupdate', updateProgress);
        audio.addEventListener('loadedmetadata', setDuration);
        audio.addEventListener('ended', () => {
            playPauseBtn.innerHTML = '<i class="bi bi-play"></i>';
            playPauseBtn.setAttribute('aria-label', 'Play');
            showAdditionalInfo();
        });
        
        if (progressContainer) {
            progressContainer.addEventListener('click', setProgress);
        }

        // Preload audio
        audio.load();

        function togglePlay() {
            if (audio.paused) {
                const playPromise = audio.play();
                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        playPauseBtn.innerHTML = '<i class="bi bi-pause"></i>';
                        playPauseBtn.setAttribute('aria-label', 'Pause');
                    }).catch(error => {
                        console.error("Audio play error:", error);
                        showPopup("Audio Error", "There was a problem playing the audio. Please try again.");
                    });
                }
            } else {
                audio.pause();
                playPauseBtn.innerHTML = '<i class="bi bi-play"></i>';
                playPauseBtn.setAttribute('aria-label', 'Play');
            }
        }

        function seek(seconds) {
            audio.currentTime = Math.max(0, Math.min(audio.currentTime + seconds, audio.duration));
        }

        function updateProgress() {
            if (!isFinite(audio.duration)) return;
            
            const percent = (audio.currentTime / audio.duration) * 100;
            progressBar.style.width = `${percent}%`;
            currentTimeSpan.textContent = formatTime(audio.currentTime);
        }

        function setProgress(e) {
            const width = this.clientWidth;
            const clickX = e.offsetX;
            const duration = audio.duration;
            
            if (isFinite(duration) && width > 0) {
                audio.currentTime = (clickX / width) * duration;
            }
        }

        function setDuration() {
            if (isFinite(audio.duration)) {
                durationSpan.textContent = formatTime(audio.duration);
            }
        }

        function formatTime(time) {
            if (!isFinite(time)) return "0:00";
            
            const minutes = Math.floor(time / 60);
            const seconds = Math.floor(time % 60);
            return `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }
    }

    function showAdditionalInfo() {
        // Find the location using lastVisitedLocationId
        const location = gameLocations.find(loc => loc.id === lastVisitedLocationId);
        if (!location) {
            console.error('Location not found for ID:', lastVisitedLocationId);
            return;
        }
        
        const additionalInfoContainer = document.querySelector('.additional-info-container');
        additionalInfoContainer.style.display = 'block';
        additionalInfoContainer.classList.add('fade-in');
        
        document.getElementById('additionalInfo').textContent = location.additionalInfo || 
            "No additional information available for this location.";

        const continueButton = document.getElementById('continueButton');
        continueButton.onclick = () => {
            provideHapticFeedback();
            additionalInfoContainer.classList.add('fade-out');
            setTimeout(() => {
                additionalInfoContainer.style.display = 'none';
                additionalInfoContainer.classList.remove('fade-out');
                
                document.querySelector('.lochunt-container').classList.add('fade-out');
                setTimeout(() => {
                    document.querySelector('.lochunt-container').style.display = 'none';
                    document.querySelector('.lochunt-container').classList.remove('fade-out');
                    isLocationHuntVisible = false;
                    updateDistanceBox();
                    
                    // Restart auto-recenter timer when returning to map
                    startAutoRecenterTimer();
                }, 300);
            }, 300);
        };
    }

    function showLocationSummary(locationId) {
        const location = locations.find(loc => String(loc.id) === String(locationId));
        
        if (location && location.summary) {
            // Preload the image if it exists
            if (location.image && !imageCache[location.id]) {
                const preloadImage = new Image();
                preloadImage.src = location.image;
                imageCache[location.id] = preloadImage;
            }
            
            const modal = document.getElementById('summaryModal');
            const summaryContent = document.getElementById('summaryContent');
            
            modal.style.display = 'flex';
            modal.classList.add('fade-in');
            isSummaryModalOpen = true;
            
            const modalContent = modal.querySelector('.modal-content');
            modalContent.style.cssText = `
                background-color: white;
                padding: 30px;
                border-radius: 10px;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
                max-width: 500px;
                width: 90%;
                max-height: 80vh;
                overflow-y: auto;
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
            `;
            
            // Remove existing close button if any
            const closeBtn = modal.querySelector('.close');
            if (closeBtn) {
                closeBtn.remove();
            }
            
            summaryContent.style.textAlign = 'left';

            /*
            // Create content with image preloaded
            let summaryHTML = `
                <h3 style="color: var(--primary-color); font-size: 22px; margin-bottom: 15px; text-align: center;">${location.name}</h3>
            `;
            
            // Add image if available
            if (location.image) {
                summaryHTML += `
                    <div style="text-align: center; margin-bottom: 15px;">
                        <img src="${location.image}" alt="${location.name}" style="max-width: 100%; max-height: 200px; border-radius: 8px; object-fit: cover;">
                    </div>
                `;
            }

            */

            let summaryHTML = `
    <h3 style="color: var(--primary-color); font-size: 22px; margin-bottom: 15px; text-align: center;">${location.name}</h3>
    <p style="line-height: 1.6; margin-bottom: 15px;">
        ${location.summary}
    </p>
    <p style="line-height: 1.6; margin-bottom: 15px;">
        <strong>Location:</strong> ${location.today || "Information not available"}
    </p>
`;
            /*
            summaryHTML += `
                <p style="line-height: 1.6; margin-bottom: 15px;">
                    ${location.summary}
                </p>
                <p style="line-height: 1.6; margin-bottom: 15px;">
                    <strong>Location:</strong> ${location.today || "Information not available"}
                </p>
            `;
            */
            summaryContent.innerHTML = summaryHTML;
            
            const continueButton = document.createElement('button');
            continueButton.textContent = 'Continue';
            continueButton.classList.add('touch-target', 'interactive');
            continueButton.style.cssText = `
                display: block;
                width: auto;
                padding: 12px 20px;
                background-color: var(--primary-color);
                color: white;
                border: none;
                border-radius: 10px;
                cursor: pointer;
                font-size: 18px;
                font-weight: bold;
                transition: background-color 0.3s ease;
                margin: 10px auto -15px;
            `;
            continueButton.onmouseover = function() {
                this.style.backgroundColor = '#0077c2';
            };
            continueButton.onmouseout = function() {
                this.style.backgroundColor = 'var(--primary-color)';
            };
            continueButton.onclick = function() {
                provideHapticFeedback();
                modal.classList.add('fade-out');
                setTimeout(() => {
                    modal.style.display = 'none';
                    modal.classList.remove('fade-out');
                    isSummaryModalOpen = false;
                    stopAutoRecenterCountdown();
                    startAutoRecenterTimer();
                }, 300);
            };
            
            summaryContent.appendChild(continueButton);
            
            // Close modal when clicking outside
            window.onclick = function(event) {
                if (event.target === modal) {
                    modal.classList.add('fade-out');
                    setTimeout(() => {
                        modal.style.display = 'none';
                        modal.classList.remove('fade-out');
                        isSummaryModalOpen = false;
                        stopAutoRecenterCountdown();
                        startAutoRecenterTimer();
                    }, 300);
                }
            };
            
            // Start auto-recenter timer for summary modal
            startAutoRecenterTimer();
        } else {
            console.log("Location or summary not found. Location ID:", locationId);
            showPopup("Error", "Summary not available for this location.");
        }
    }

    function startHunt() {
        gameLocations = locations.sort((a, b) => a.id - b.id);
        currentLocationIndex = 0;
        locationCooldowns = {};
        lastVisitedLocationId = null;
        loadAllLocations();
    }

    function getMarkerColor(tours) {
        if (!tours) return '#0f2bab'; // Default color
        
        switch (tours.toLowerCase()) {
            case 'person':
                return '#FFA500'; // Orange
            case 'gangster':
                return '#3f9b0b'; // Green
            case 'event':
                return '#8B0000'; // Dark red
            case 'place':
                return '#0f2bab'; // Blue
            default:
                return '#0f2bab'; // Default blue
        }
    }

    function loadAllLocations() {
        if (!gameLocations || !Array.isArray(gameLocations) || gameLocations.length === 0) {
            console.error("No locations available to load");
            showPopup("Error", "No locations available. Please try reloading the page.");
            return;
        }

        // Clear existing markers if any
        markerClusterGroup.clearLayers();

        // Create markers for each location
        gameLocations.forEach((location) => {
            if (!location || typeof location.lat !== 'number' || typeof location.lng !== 'number') {
                console.warn("Invalid location data:", location);
                return;
            }

            const markerColor = getMarkerColor(location.tours);
            
            const locationMarker = L.marker([location.lat, location.lng], {
                icon: L.divIcon({
                    className: 'custom-pin-icon',
                    html: `<div class="pin-head" style="background-color: ${markerColor};"></div>`,
                    iconSize: [30, 30],
                    iconAnchor: [15, 30],
                })
            });
                    
            const popupContent = `
                <div class="popup-content">
                    <img src="${location.image}" alt="${location.name}" class="location-image">
                    <h4 class="location-name">
                        <a href="${location.link}" target="_blank" rel="noopener noreferrer" style="text-decoration: none; color: inherit;">${location.name}</a>
                    </h4>
                    <div class="popup-buttons">
                        <button class="button route-button touch-target" data-lat="${location.lat}" data-lng="${location.lng}">Directions</button>
                        <button class="button summary-button touch-target" data-location-id="${location.id}">Summary</button>
                    </div>
                </div>
            `;
            
            locationMarker.bindPopup(popupContent, {
                offset: L.point(0, -25),
                className: 'custom-popup',
                maxWidth: 300
            });
            
            locationMarker.on('popupopen', function(e) {
                const popup = e.popup._contentNode;
                const routeButton = popup.querySelector('.route-button');
                const summaryButton = popup.querySelector('.summary-button');
                
                if (routeButton) {
                    routeButton.addEventListener('click', function(event) {
                        event.preventDefault();
                        provideHapticFeedback();
                        const lat = this.getAttribute('data-lat');
                        const lng = this.getAttribute('data-lng');
                        
                        // Create and show the modal
                        const modal = document.createElement('div');
                        modal.className = 'modal';
                        modal.style.display = 'flex';
                        modal.classList.add('fade-in');
                        modal.innerHTML = `
                            <div class="modal-content">
                                <h3>Choose your preferred navigation app:</h3>
                                <div class="modal-buttons">
                                    <button class="modal-button google-maps touch-target">
                                        Google Maps
                                    </button>
                                    <button class="modal-button waze touch-target">
                                        Waze
                                    </button>
                                    <button class="modal-button apple-maps touch-target">
                                        Apple Maps
                                    </button>
                                    <button class="modal-button cancel touch-target">Cancel</button>
                                </div>
                            </div>
                        `;

                        // Add modal styles if not already present
                        if (!document.querySelector('#modal-styles')) {
                            const style = document.createElement('style');
                            style.id = 'modal-styles';
                            style.textContent = `
                                .modal {
                                    position: fixed;
                                    top: 0;
                                    left: 0;
                                    width: 100%;
                                    height: 100%;
                                    background: rgba(0, 0, 0, 0.75);
                                    display: flex;
                                    justify-content: center;
                                    align-items: center;
                                    z-index: 3000;
                                    padding: 16px;
                                    backdrop-filter: blur(4px);
                                }
                                .modal-content {
                                    background: white;
                                    padding: 24px 16px;
                                    border-radius: 16px;
                                    width: 100%;
                                    max-width: 320px;
                                    text-align: center;
                                    box-shadow: 0 20px 40px rgba(0,0,0,0.2);
                                }
                                .modal-buttons {
                                    margin-top: 20px;
                                    display: flex;
                                    flex-direction: column;
                                    gap: 12px;
                                    align-items: center;
                                }
                                .modal-button {
                                    padding: 16px;
                                    border-radius: 12px;
                                    width: 100%;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    font-size: 16px;
                                    font-weight: 500;
                                    border: none;
                                    cursor: pointer;
                                    transition: transform 0.15s ease;
                                }
                                .modal-button:active {
                                    transform: scale(0.98);
                                }
                                .google-maps {
                                    background: #4285F4;
                                    color: white;
                                    box-shadow: 0 2px 8px rgba(66,133,244,0.3);
                                }
                                .waze {
                                    background: #33ccff;
                                    color: white;
                                    box-shadow: 0 2px 8px rgba(51,204,255,0.3);
                                }
                                .apple-maps {
                                    background: #000000;
                                    color: white;
                                    box-shadow: 0 2px 8px rgba(0,0,0,0.2);
                                }
                                .cancel {
                                    background: #f2f2f2;
                                    color: #666;
                                }
                            `;
                            document.head.appendChild(style);
                        }

                        document.body.appendChild(modal);
                        activeModals.push(modal);

                        // Handle button clicks
                        modal.querySelector('.google-maps').addEventListener('click', () => {
                            provideHapticFeedback();
                            window.location.href = `https://www.google.com/maps/dir/?api=1&destination=${lat},${lng}`;
                            modal.classList.add('fade-out');
                            setTimeout(() => modal.remove(), 300);
                        });

                        modal.querySelector('.waze').addEventListener('click', () => {
                            provideHapticFeedback();
                            window.location.href = `https://www.waze.com/ul?ll=${lat}%2C${lng}&navigate=yes`;
                            modal.classList.add('fade-out');
                            setTimeout(() => modal.remove(), 300);
                        });

                        modal.querySelector('.apple-maps').addEventListener('click', () => {
                            provideHapticFeedback();
                            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
                            if (isIOS) {
                                window.location.href = `maps://maps.apple.com/?daddr=${lat},${lng}`;
                                modal.classList.add('fade-out');
                                setTimeout(() => modal.remove(), 300);
                            } else {
                                const alertEl = document.createElement('div');
                                alertEl.className = 'modal';
                                alertEl.style.zIndex = '4000';
                                alertEl.innerHTML = `
                                    <div class="modal-content">
                                        <p>Apple Maps is only available on iOS devices</p>
                                        <button class="modal-button touch-target">OK</button>
                                    </div>
                                `;
                                document.body.appendChild(alertEl);
                                activeModals.push(alertEl);
                                alertEl.querySelector('button').onclick = () => {
                                    provideHapticFeedback();
                                    alertEl.remove();
                                };
                            }
                        });
                        
                        modal.querySelector('.cancel').addEventListener('click', () => {
                            provideHapticFeedback();
                            modal.classList.add('fade-out');
                            setTimeout(() => modal.remove(), 300);
                        });

                        // Close modal if clicking outside
                        modal.addEventListener('click', (e) => {
                            if (e.target === modal) {
                                modal.classList.add('fade-out');
                                setTimeout(() => modal.remove(), 300);
                            }
                        });
                    });
                }
                
                if (summaryButton) {
                    summaryButton.addEventListener('click', function(event) {
                        event.preventDefault();
                        provideHapticFeedback();
                        const locationId = this.getAttribute('data-location-id');
                        showLocationSummary(locationId);
                    });
                }
            });
            
            markerClusterGroup.addLayer(locationMarker);
        });
        
        map.addLayer(markerClusterGroup);
        updateDistanceBox();
        resetInactivityTimer();
    }

    function returnToIndex() {
        showPopup("Confirm", "Are you ready to exit?", 'info', () => {
            window.location.href = "/index.html";
        });
        document.getElementById('returnButton').classList.remove('active');
    }

    function toggleNavigationTips() {
        const tipsElement = document.querySelector('.navigation-tips');
        const computedStyle = window.getComputedStyle(tipsElement);

        if (computedStyle.display === 'none') {
            tipsElement.style.display = 'block';
            tipsElement.classList.add('fade-in');
        } else {
            tipsElement.classList.add('fade-out');
            setTimeout(() => {
                tipsElement.style.display = 'none';
                tipsElement.classList.remove('fade-out');
            }, 300);
        }

        document.getElementById('tipsButton').classList.toggle('active');
    }

    function closeNavigationTips() {
        const tipsElement = document.querySelector('.navigation-tips');
        tipsElement.classList.add('fade-out');
        setTimeout(() => {
            tipsElement.style.display = 'none';
            tipsElement.classList.remove('fade-out');
        }, 300);
        document.getElementById('tipsButton').classList.remove('active');
    }

    function addUIEventListeners() {
        document.getElementById('recenterButton').addEventListener('click', () => {
            recenterMap();
            resetInactivityTimer();
        });
        
        document.getElementById('returnButton').addEventListener('click', () => {
            provideHapticFeedback();
            returnToIndex();
            resetInactivityTimer();
        });
        
        document.getElementById('tipsButton').addEventListener('click', () => {
            provideHapticFeedback();
            toggleNavigationTips();
            resetInactivityTimer();
        });
        
        document.querySelector('.navigation-tips .close-button').addEventListener('click', () => {
            provideHapticFeedback();
            closeNavigationTips();
            resetInactivityTimer();
        });
    }

    function addMapEventListeners() {
        const startInteraction = () => {
            isMapInteracting = true;
            followUser = false;
            resetInactivityTimer();
            userInteractionTime = Date.now();
            stopAutoRecenterCountdown();
        };

        map.on('movestart zoomstart dragstart', startInteraction);
        
        // Add touch event listeners for mobile
        map.getContainer().addEventListener('touchstart', () => {
            resetInactivityTimer();
            userInteractionTime = Date.now();
        });
    }

    function resetInactivityTimer() {
        clearTimeout(inactivityTimer);
        inactivityTimer = setTimeout(checkInactivity, INACTIVITY_TIMEOUT);
    }

    function checkInactivity() {
        console.log('Inactivity timer triggered');
        isMapInteracting = false;
        
        // Close any open popups
        map.closePopup();
        map.eachLayer((layer) => {
            if (layer.getPopup && layer.getPopup()?.isOpen()) {
                layer.closePopup();
            }
        });
        
        if (!isLocationHuntVisible) {
            recenterMap();
        }
    }

    // Periodic update for smooth following
    setInterval(() => {
        if (lastPosition && followUser && !isMapInteracting) {
            map.panTo([lastPosition.lat, lastPosition.lng], {
                animate: true,
                duration: 0.5,
                easeLinearity: 0.5,
                noMoveStart: true
            });
        }
    }, UPDATE_INTERVAL);

    // Initialize the application
    document.addEventListener('DOMContentLoaded', function() {
        initMap();
        addUIEventListeners();
        addMapEventListeners();
        resetInactivityTimer();
    });
    </script>
</body>
</html>
