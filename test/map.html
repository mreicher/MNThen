<!DOCTYPE html>
<html lang="en">
<head> 
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Minnesota Then | Museum Without Walls</title>
    <link rel="shortcut icon" type="image/x-icon" href="https://www.mnthen.com/images/mnthenfav.ico">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css">
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css" />
    <link rel="stylesheet" href="https://www.mnthen.com/css/mainmap.css">
    <style>
        .user-marker-icon {
            width: 20px;
            height: 20px;
            background-color: #ff0000; /* Red user icon */
            border: 3px solid white;
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            position: relative;
            transition: transform 0.3s cubic-bezier(0.25, 0.1, 0.25, 1);
            will-change: transform;
        }
        
        .user-marker-icon::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 30px;
            height: 30px;
            background-color: rgba(255, 0, 0, 0.2); /* Red with opacity */
            border-radius: 50%;
            transform: translate(-50%, -50%);
            animation: pulse 2s infinite;
            will-change: transform, opacity;
        }
        
        @keyframes pulse {
            0% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
            100% {
                transform: translate(-50%, -50%) scale(2);
                opacity: 0;
            }
        }
        
        .stabilizing-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            z-index: 2000;
            text-align: center;
            max-width: 80%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .stabilizing-modal h3 {
            margin-bottom: 15px;
            color: #ff0000; /* Red */
        }
        
        .stabilizing-modal p {
            margin-bottom: 20px;
        }
        
        .stabilizing-modal .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255, 0, 0, 0.2); /* Red with opacity */
            border-top: 4px solid #ff0000; /* Red */
            border-radius: 50%;
            margin-bottom: 20px;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Preloader styles */
        #preloader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }

        #preloader .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(255, 0, 0, 0.2);
            border-top: 5px solid #ff0000;
            border-radius: 50%;
            margin-bottom: 20px;
            animation: spin 1s linear infinite;
        }

        #preloader p {
            font-size: 18px;
            color: #333;
            margin-top: 15px;
        }

        #preloader .progress-container {
            width: 80%;
            max-width: 300px;
            height: 10px;
            background-color: #f0f0f0;
            border-radius: 5px;
            margin-top: 15px;
            overflow: hidden;
        }

        #preloader .progress-bar {
            height: 100%;
            background-color: #ff0000;
            width: 0%;
            transition: width 0.3s ease;
        }

        /* Dark blue color for summary elements */
        .summary-heading {
            color: #0f2bab !important;
        }

        .summary-button {
            background-color: #0f2bab !important;
        }

        .summary-button:hover {
            background-color: #0a1f80 !important;
        }
        
        /* Optimize for hardware acceleration */
        #map, .user-marker-icon, .lochunt-container, .additional-info-container {
            transform: translateZ(0);
            backface-visibility: hidden;
            perspective: 1000px;
        }
        
        /* Stationary indicator - removed green glow and modified for consistent appearance */
        .user-marker-stationary .user-marker-icon {
            /* Keep the same red color and white border */
            border-color: white;
        }
        
        .user-marker-stationary .user-marker-icon::after {
            /* Keep the same red pulse effect */
            background-color: rgba(255, 0, 0, 0.2);
            animation: pulse 2s infinite;
        }
        
        /* Center the "Did you know?" modal */
        .additional-info-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            z-index: 2000;
            text-align: center;
            max-width: 80%;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            display: none;
        }
        
/* Green route button and dark blue summary button */
.button.route-button {
    background-color: #1b5e20 !important; /* Dark green color */
    color: white !important;
    border: none !important;
    padding: 8px 15px !important;
    border-radius: 0px !important;
    cursor: pointer !important;
    font-weight: 500 !important;
    transition: background-color 0.3s ease !important;
}

.button.summary-button {
    background-color: #0f2bab !important; /* Dark blue color */
    color: white !important;
    border: none !important;
    padding: 8px 15px !important;
    border-radius: 0px !important;
    cursor: pointer !important;
    font-weight: 500 !important;
    transition: background-color 0.3s ease !important;
}

.button.route-button:hover {
    background-color: #0d3c12 !important; /* Darker green on hover */
}

.button.summary-button:hover {
    background-color: #0a1f80 !important; /* Darker blue on hover */
}
        
        .custom-popup .popup-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
        }

        /* Error message styles */
        .error-message {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(255, 59, 48, 0.9);
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 2500;
            max-width: 90%;
            text-align: center;
            font-weight: 500;
            animation: fadeInOut 5s forwards;
            pointer-events: none;
        }

        @keyframes fadeInOut {
            0% { opacity: 0; transform: translate(-50%, -20px); }
            10% { opacity: 1; transform: translate(-50%, 0); }
            90% { opacity: 1; transform: translate(-50%, 0); }
            100% { opacity: 0; transform: translate(-50%, -20px); }
        }

        /* Location transition styles */
        .location-transition {
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .location-transition.visible {
            opacity: 1;
        }

/* Confidence indicator styles */
#accuracyIndicator {
    position: fixed;
    top: 10px;
    left: 10px;
    background-color: rgba(255, 255, 255, 0.8);
    padding: 5px 10px;
    border-radius: 15px;
    font-size: 12px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    z-index: 1000;
    display: flex;
    align-items: center;
    pointer-events: none;
}
.accuracy-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    margin-right: 5px;
}
.accuracy-high {
    background-color: #4CD964; /* Green */
}
.accuracy-medium {
    background-color: #FFCC00; /* Yellow */
}
.accuracy-low {
    background-color: #FF3B30; /* Red */
}
    </style>
</head>
<body>
    <!-- Preloader -->
    <div id="preloader">
        <div class="spinner"></div>
        <p>Loading Minnesota Then...</p>
        <div class="progress-container">
            <div class="progress-bar" id="preloaderProgress"></div>
        </div>
    </div>

    <div id="map"></div>
    <div id="distanceBox">Initializing...</div>
    <div id="networkStatus" title="Network Status"></div>
    <div id="accuracyIndicator"><span class="accuracy-dot accuracy-medium"></span><span id="accuracyText">GPS Signal</span></div>

    <div class="lochunt-container location-transition">
        <img id="locationImage" src="" alt="Location Image">
        <div class="lochunt-content">
            <div class="lochunt-info">
                <h2 id="locationTitle" class="mb-2 text-primary"></h2>
                <p id="locationCity" class="text-muted mb-1"></p>
                <p id="locationCreator" class="text-muted mb-3"></p>
            </div>
            <div class="audio-player">
                <div class="audio-progress">
                    <div class="progress">
                        <div id="progressBar" class="progress-bar" role="progressbar" style="width: 0%"></div>
                    </div>
                </div>
                <div class="audio-time">
                    <span id="currentTime">0:00</span>
                    <span id="duration">0:00</span>
                </div>
                <div class="audio-controls">
                    <button id="rewindBtn" class="audio-button"><i class="fas fa-backward"></i></button>
                    <button id="playPauseBtn" class="audio-button"><i class="fas fa-play"></i></button>
                    <button id="forwardBtn" class="audio-button"><i class="fas fa-forward"></i></button>
                </div>
                <audio id="locationAudio" src=""></audio>
            </div>
        </div>
    </div>
    
    <div class="additional-info-container location-transition">
       <h3 class="mb-3 text-primary text-center">Did You Know?</h3>
       <p id="additionalInfo" class="mb-3 fs-6"></p>
       <div class="d-flex justify-content-center">
           <button id="continueButton" class="btn btn-primary">Continue</button>
       </div>
    </div>
    
    <div class="map-buttons">
        <button id="recenterButton" class="map-button"><i class="fas fa-crosshairs"></i></button>
        <button id="returnButton" class="map-button"><i class="fas fa-sign-out-alt"></i></button>
        <button id="tipsButton" class="map-button"><i class="fas fa-question-circle"></i></button>
    </div>

    <div class="navigation-tips">
        <button class="close-button">&times;</button>
        <h3>Navigation Tips</h3>
        <ul>
            <li>Use the map to navigate to the marked locations.</li>
            <li>The distance box shows how far you are from the current location.</li>
            <li>Tap the recenter button to focus on your current position.</li>
            <li>When you're within 20 feet of a location, you'll be able to interact with it.</li>
            <li>Listen to the audio information for each location.</li>
            <li>After the audio, you'll see additional information about the location.</li>
        </ul>
    </div>

    <div id="summaryModal" class="modal" style="display: none;">
        <div class="modal-content">
            <p id="summaryContent"></p>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"></script>
    <script src="/locations_test.js?v=1.0.4"></script>

    <script>
// Global variables
// Global variables
let map, userMarker, markerClusterGroup;
let currentLocationIndex = 0;
let visitedLocations = [];
let gameLocations = [];
let inactivityTimer;
let isLocationHuntVisible = false;
let lastPosition = null;
let positionBuffer = [];
const MAX_BUFFER_SIZE = 20; // Increased buffer size for smoother tracking
const DISTANCE_THRESHOLD = 20; // 20 feet to measure threshold distance to marker before opening location page.
const PROXIMITY_THRESHOLD = 40; // 40 feet threshold for zoom changes
let velocity = { lat: 0, lng: 0 };
let isMapInteracting = false;
let followUser = true;
let locationCooldowns = {};
let userIsInteracting = false;
let preloadedImages = new Map(); // Map to store preloaded images
let preloadedAudio = new Map(); // Map to store preloaded audio
let currentSpeed = 0; // Current speed in meters per second
let lastZoomLevel = 18; // Default zoom level
let stationaryPositionHistory = []; // Array to store stationary positions for averaging
let deviceOrientation = null; // Store device orientation data
let deviceMotion = null; // Store device motion data
let orientationPermissionGranted = false;
let geolocationSensor = null; // Store GeolocationSensor instance
let isNearLocation = false; // Flag to track if user is near a location
let lastProximityCheck = 0; // Last time proximity was checked
let isReturningFromExhibit = false; // Flag to track if returning from exhibit

// Enhanced constants for better stabilization
const MICRO_MOVEMENT_THRESHOLD = 0.5; // Meters - threshold for detecting micro-movements (increased for better stability)
const STATIONARY_ACCURACY_MULTIPLIER = 1.5; // Looser accuracy bounds to prevent false movement detection
const MAX_ACCEPTABLE_ACCURACY = 30; // meters - more lenient accuracy requirement
const STATIONARY_THRESHOLD = 3; // Number of consecutive stationary positions to consider user as stationary (reduced for faster stabilization)
const STATIONARY_TIME_THRESHOLD = 5000; // ms - time to consider user stationary (increased)
const STATIONARY_CHECK_INTERVAL = 2000; // ms - interval to check if still stationary (increased)
const VELOCITY_DECAY = 0.95; // Higher value for smoother velocity transitions
const MIN_DISTANCE_THRESHOLD = 1.5; // meters - minimum distance to consider movement (increased)
const EXTENDED_DISTANCE_THRESHOLD = 80; // meters - distance to consider a significant position change
const UPDATE_INTERVAL = 100; // ms - less frequent updates for more stability
const STATIONARY_POSITION_HISTORY_SIZE = 10; // Number of positions to keep for stationary averaging (reduced)
const STATIONARY_POSITION_WEIGHT_DECAY = 0.95; // Weight decay for older positions in stationary average (increased)
const SUDDEN_MOVEMENT_THRESHOLD = 1.0; // meters - threshold for detecting sudden movements (increased)
const POSITION_JUMP_THRESHOLD = 3.0; // meters - threshold for detecting position jumps (increased)
const ZOOM_CHANGE_COOLDOWN = 2000; // ms - cooldown between zoom changes

// Background handling constants
const BACKGROUND_THRESHOLD = 20000; // ms - time to consider app was in background
const INACTIVITY_TIMEOUT = 25000; // ms - time to consider user inactive

// Kalman filter parameters - optimized for better stationary stability
const KALMAN_PROCESS_NOISE = 0.001; // Lower value for smoother tracking
const KALMAN_MEASUREMENT_NOISE_BASE = 2.0; // Higher base measurement noise to reduce jitter
const KALMAN_STATIONARY_NOISE = 0.0005; // Lower noise when stationary (reduced to minimize jitter)

// Animation parameters
const ANIMATION_DURATION = 300; // ms - increased duration of position animation for smoother transitions
const HEADING_SMOOTHING = 0.95; // Increased heading smoothing factor

// Zoom level parameters
const MAX_ZOOM_LEVEL = 18; // Maximum zoom level (stationary)
const MIN_ZOOM_LEVEL = 14; // Minimum zoom level (high speed)
const WALKING_ZOOM_LEVEL = 18; // Zoom level for walking speed
const WALKING_SPEED_THRESHOLD = 1.5; // m/s - threshold for walking speed
const RUNNING_SPEED_THRESHOLD = 4.0; // m/s - threshold for running speed
const DRIVING_SPEED_THRESHOLD = 10.0; // m/s - threshold for driving speed
const ZOOM_TRANSITION_DURATION = 0.8; // seconds - increased duration of zoom transition

// Motion detection parameters
const MOTION_THRESHOLD = 1.0; // Increased threshold for detecting significant motion
const MOTION_SAMPLE_SIZE = 10; // Increased number of motion samples to keep
const MOTION_CHECK_INTERVAL = 300; // ms - increased interval to check motion

// Edge recenter parameters - optimized for better edge recentering
const EDGE_THRESHOLD_PERCENTAGE = 0.25; // Percentage of viewport to trigger recenter (reduced to recenter more aggressively)
const CRITICAL_EDGE_THRESHOLD = 0.15; // Critical threshold for emergency recenter
const RECENTER_COOLDOWN = 500; // ms - reduced minimum time between recenters for more responsive recentering

// Error handling constants
const MAX_LOCATION_RETRIES = 5; // Maximum number of retries for location
const LOCATION_RETRY_DELAY = 2000; // Delay between location retries in ms
const NETWORK_CHECK_INTERVAL = 5000; // Interval to check network status in ms
const GPS_CONFIDENCE_THRESHOLD_HIGH = 10; // meters - high confidence threshold
const GPS_CONFIDENCE_THRESHOLD_MEDIUM = 25; // meters - medium confidence threshold
const GPS_SIGNAL_CHECK_INTERVAL = 3000; // Interval to check GPS signal quality in ms
const PERMISSION_DENIED_ERROR = 1; // Error code for permission denied
const POSITION_UNAVAILABLE_ERROR = 2; // Error code for position unavailable
const TIMEOUT_ERROR = 3; // Error code for timeout
const UNKNOWN_ERROR = 4; // Error code for unknown error

// Performance optimization constants
const DOM_UPDATE_THROTTLE = 100; // ms - throttle interval for DOM updates
const MAP_UPDATE_THROTTLE = 150; // ms - throttle interval for map updates
const EDGE_CHECK_THROTTLE = 250; // ms - throttle interval for edge checks
const PROXIMITY_CHECK_THROTTLE = 1000; // ms - throttle interval for proximity checks
const ANIMATION_FRAME_THROTTLE = 16; // ms - throttle interval for animation frames (~60fps)
const PASSIVE_EVENT_OPTIONS = { passive: true }; // Options for passive event listeners
const TOUCH_MOVE_THROTTLE = 50; // ms - throttle interval for touch move events
const RESIZE_THROTTLE = 250; // ms - throttle interval for resize events
const NETWORK_STATUS_UPDATE_THROTTLE = 10000; // ms - throttle interval for network status updates
const PRELOAD_BATCH_SIZE = 2; // Number of items to preload at once
const PRELOAD_BATCH_DELAY = 100; // ms - delay between preload batches
const WORKER_MESSAGE_THROTTLE = 50; // ms - throttle interval for worker messages

// State variables
let lastUpdateTime = null;
let lastVelocity = { lat: 0, lng: 0 };
let isStationary = false;
let stationaryStartTime = null;
let stationaryCheckTimeout = null;
let lastUpdateTimestamp = null;
let lastHiddenTime = 0;
let lastKnownPosition = null;
let isTransitioning = false;
let lastVisitedLocationId = null;
let stationaryCount = 0;
let lastSmoothedPosition = null;
let lastRecenterTime = Date.now();
let retryCount = 0;
let stationaryBuffer = [];
let stationaryPosition = null;
let isStabilizing = true; // Flag to track initial stabilization
let lastStationaryPosition = null; // Last stable position when stationary
let motionSamples = []; // Array to store motion samples
let lastMotionTimestamp = 0; // Last time motion was detected
let deviceStationaryTime = 0; // Time device has been stationary based on motion sensors
let animationFrameId = null; // Store requestAnimationFrame ID
let renderTimestamp = null; // Last render timestamp
let positionUpdateQueue = []; // Queue for position updates to be processed
let lastHeadingValue = null; // Last heading value
let headingBuffer = []; // Buffer for heading values
let isFirstPositionUpdate = true; // Flag for first position update
let lastRenderPosition = null; // Last rendered position
let positionInterpolator = null; // Position interpolator for smooth transitions
let mapViewportWidth = 0; // Store map viewport width
let mapViewportHeight = 0; // Store map viewport height
let lastMapCenter = null; // Last map center position
let lastMapZoom = null; // Last map zoom level
let edgeRecenterInProgress = false; // Flag to track edge recentering
let domUpdateScheduled = false; // Flag to track scheduled DOM updates
let pendingDomUpdates = new Map(); // Map to store pending DOM updates
let usingGeolocationSensorAPI = false; // Flag to track which geolocation API is being used
let lockStationaryPosition = false; // Flag to lock stationary position and prevent jitter
let positionHistory = []; // Array to store recent position history for jump detection
let lastPositionTimestamp = 0; // Last time a position was processed
let suddenMovementCount = 0; // Counter for consecutive sudden movements
let isJumpDetected = false; // Flag to track if a position jump is detected
let stationaryPositionLocked = false; // Flag to indicate if stationary position is locked
let stationaryPositionLockTime = 0; // Time when stationary position was locked
let lastValidPosition = null; // Last valid position before a jump
let stationaryLockTimeout = null; // Timeout for locking stationary position
let positionStabilityCounter = 0; // Counter for position stability
let lastZoomChangeTime = 0; // Last time zoom was changed due to proximity
let lastProximityDistance = Infinity; // Last distance to nearest location
let isOnline = navigator.onLine; // Track online status
let lastGpsSignalCheck = 0; // Last time GPS signal was checked
let gpsConfidenceScore = 0.5; // GPS confidence score (0-1)
let permissionDenied = false; // Flag to track if location permission was denied
let locationErrorCount = 0; // Counter for location errors
let networkErrorCount = 0; // Counter for network errors
let lastNetworkErrorTime = 0; // Last time a network error occurred
let isLocationAvailable = true; // Flag to track if location is available
let confidenceScoreHistory = []; // Array to store confidence scores for averaging
let stationaryConfidenceScore = 0; // Confidence score for stationary state (0-1)
let movingConfidenceScore = 0; // Confidence score for moving state (0-1)
let stationaryTransitionState = 0; // Transition state between stationary and moving (0-1)
let lastAccuracyUpdate = 0; // Last time accuracy indicator was updated
let locationWatchId = null; // ID for geolocation watch
let permissionRequestInProgress = false; // Flag to track if permission request is in progress
let lastPermissionRequest = 0; // Last time permission was requested
let imagePreloadQueue = []; // Queue for image preloading
let audioPreloadQueue = []; // Queue for audio preloading
let preloadBatchSize = 3; // Number of items to preload at once
let isPreloading = false; // Flag to track if preloading is in progress
let preloadStartTime = 0; // Time when preloading started
let lastMapUpdate = 0; // Last time map was updated
let mapUpdateThrottleInterval = 100; // Throttle interval for map updates
let lastEdgeCheck = 0; // Last time edge check was performed
let edgeCheckInterval = 200; // Interval for edge checks in ms
let lastEdgeCheckResult = null; // Cache for edge check results
let lastDomUpdate = 0; // Last time DOM was updated
let touchMoveThrottled = false; // Flag for throttling touch move events
let resizeThrottled = false; // Flag for throttling resize events
let positionWorker = null; // Web Worker for position calculations
let workerBusy = false; // Flag to track if worker is busy
let pendingWorkerTasks = []; // Queue for pending worker tasks
let pendingDistanceCalculations = new Map(); // Map for pending distance calculations
let distanceCalculationId = 0; // Counter for distance calculation IDs
let rafThrottleTimestamp = 0; // Timestamp for throttling requestAnimationFrame
let currentFps = 60; // Current frames per second
let targetFps = 60; // Target frames per second
let frameCount = 0; // Counter for FPS calculation
let lastFpsCheck = 0; // Last time FPS was checked
let fpsCheckInterval = 5000; // Interval for FPS checks
let lowPowerMode = false; // Flag for low power mode
let batteryLevel = 1.0; // Battery level (0-1)
let deviceMemory = navigator.deviceMemory || 4; // Device memory in GB
let hardwareConcurrency = navigator.hardwareConcurrency || 4; // CPU cores
let isLowEndDevice = deviceMemory < 4 || hardwareConcurrency < 4; // Flag for low-end devices
let isHighEndDevice = deviceMemory >= 8 && hardwareConcurrency >= 8; // Flag for high-end devices
let adaptivePerformanceMode = 'balanced'; // Performance mode (low, balanced, high)
let lastAdaptiveCheck = 0; // Last time adaptive performance was checked
let adaptiveCheckInterval = 5000; // Interval for adaptive performance checks
let hasBatteryAPI = 'getBattery' in navigator; // Flag for battery API support
let lastBatteryCheck = 0; // Last time battery was checked
let batteryCheckInterval = 30000; // Interval for battery checks
let idleCallbackHandle = null; // Handle for requestIdleCallback
let pendingIdleTasks = []; // Queue for idle tasks
let intersectionObserver = null; // Intersection observer for visibility detection
let visibleElements = new Set(); // Set of visible elements
let eventListeners = new Map(); // Map of event listeners for cleanup

// Enhanced Kalman Filter implementation
class KalmanFilter {
 constructor() {
     // State variables
     this.x = 0; // Longitude estimate
     this.y = 0; // Latitude estimate
     this.vx = 0; // Longitude velocity
     this.vy = 0; // Latitude velocity
     
     // Error covariance matrix
     this.P = [
         [100, 0, 0, 0],  // Initial high uncertainty
         [0, 100, 0, 0],
         [0, 0, 10, 0],
         [0, 0, 0, 10]
     ];
     
     // Process noise
     this.Q = KALMAN_PROCESS_NOISE;
     
     // Measurement noise (will be adjusted based on GPS accuracy)
     this.R = KALMAN_MEASUREMENT_NOISE_BASE;
     
     // Time delta
     this.dt = 1.0;
     
     // Initialized flag
     this.initialized = false;
     
     // Heading and accuracy tracking
     this.lastHeading = null;
     this.headingConfidence = 0;
     
     // Stationary mode flag
     this.stationaryMode = false;
     
     // Last timestamp
     this.lastTimestamp = null;
     
     // Adaptive noise parameters
     this.adaptiveNoiseMin = 0.0005; // Reduced for better stability
     this.adaptiveNoiseMax = 0.005; // Reduced for better stability
     this.adaptiveNoiseFactor = 1.0;
     
     // Position history for jitter detection
     this.positionHistory = [];
     this.maxPositionHistory = 5;
     this.jitterThreshold = 0.5; // meters - increased to be more tolerant
     this.jitterCount = 0;
     
     // Stationary lock
     this.stationaryLocked = false;
     this.stationaryPosition = null;
 }
 
 // Initialize the filter with first position
 reset(position) {
     if (!position || typeof position.lat !== 'number' || typeof position.lng !== 'number') {
         console.error("Invalid position for Kalman filter reset");
         return;
     }
     
     this.x = position.lng;
     this.y = position.lat;
     this.vx = 0;
     this.vy = 0;
     
     // Reset covariance matrix with high initial uncertainty
     this.P = [
         [100, 0, 0, 0],
         [0, 100, 0, 0],
         [0, 0, 10, 0],
         [0, 0, 0, 10]
     ];
     
     this.initialized = true;
     this.lastHeading = position.heading || null;
     this.headingConfidence = 0;
     this.stationaryMode = false;
     this.lastTimestamp = position.timestamp || Date.now();
     this.adaptiveNoiseFactor = 1.0;
     this.positionHistory = [];
     this.jitterCount = 0;
     this.stationaryLocked = false;
     this.stationaryPosition = null;
 }
 
 // Set stationary mode
 setStationaryMode(isStationary) {
     this.stationaryMode = isStationary;
     
     // When entering stationary mode, reduce velocity to zero
     if (isStationary) {
         this.vx = 0;
         this.vy = 0;
         
         // Reduce process noise for stationary mode
         this.Q = KALMAN_STATIONARY_NOISE;
         this.adaptiveNoiseFactor = 0.05; // Reduce noise in stationary mode (reduced further to minimize jitter)
     } else {
         // Reset to normal process noise when moving
         this.Q = KALMAN_PROCESS_NOISE;
         this.adaptiveNoiseFactor = 1.0; // Normal noise when moving
         this.stationaryLocked = false;
         this.stationaryPosition = null;
     }
 }
 
 // Lock stationary position
 lockStationaryPosition(position) {
     if (!this.stationaryMode) return;
     
     this.stationaryLocked = true;
     this.stationaryPosition = position;
     console.log("Kalman filter: Stationary position locked");
 }
 
 // Detect jitter in position updates
 detectJitter(newPosition) {
     if (this.positionHistory.length === 0) {
         this.positionHistory.push(newPosition);
         return false;
     }
     
     const lastPos = this.positionHistory[this.positionHistory.length - 1];
     const distance = calculateDistance(lastPos, newPosition);
     
     // Add to history
     this.positionHistory.push(newPosition);
     if (this.positionHistory.length > this.maxPositionHistory) {
         this.positionHistory.shift();
     }
     
     // Check for rapid back-and-forth movement (jitter)
     if (this.positionHistory.length >= 3 && this.stationaryMode) {
         const pos1 = this.positionHistory[this.positionHistory.length - 3];
         const pos2 = this.positionHistory[this.positionHistory.length - 2];
         const pos3 = this.positionHistory[this.positionHistory.length - 1];
         
         const dist1 = calculateDistance(pos1, pos2);
         const dist2 = calculateDistance(pos2, pos3);
         
         // If moving back and forth in small distances
         if (dist1 < this.jitterThreshold && dist2 < this.jitterThreshold && 
             Math.sign(pos3.lat - pos2.lat) !== Math.sign(pos2.lat - pos1.lat) &&
             Math.sign(pos3.lng - pos2.lng) !== Math.sign(pos2.lng - pos1.lng)) {
             this.jitterCount++;
             return this.jitterCount > 2; // Require multiple jitter detections
         }
     }
     
     // Reset jitter count if no jitter detected
     if (distance > this.jitterThreshold) {
         this.jitterCount = 0;
     }
     
     return false;
 }
 
 // Adjust process noise based on accuracy and motion
 adjustProcessNoise(accuracy, motionDetected) {
     // Base noise level depends on GPS accuracy
     let noiseLevel = this.adaptiveNoiseMin + 
         (this.adaptiveNoiseMax - this.adaptiveNoiseMin) * 
         Math.min(1.0, accuracy / 40.0);
     
     // Reduce noise when stationary
     if (this.stationaryMode) {
         noiseLevel *= 0.05; // Reduced further to minimize jitter
     }
     
     // Increase noise when motion is detected
     if (motionDetected && !this.stationaryMode) {
         noiseLevel *= 1.5;
     }
     
     // Apply adaptive factor
     noiseLevel *= this.adaptiveNoiseFactor;
     
     // Set process noise
     this.Q = noiseLevel;
 }
 
 // Update the filter with new measurement
 update(position, motionDetected = false) {
     if (!this.initialized) {
         this.reset(position);
         return position;
     }
     
     if (!position || typeof position.lat !== 'number' || typeof position.lng !== 'number') {
         console.warn("Invalid position input to Kalman filter");
         return {
             lat: this.y,
             lng: this.x,
             accuracy: position?.accuracy || 20,
             heading: this.lastHeading,
             timestamp: position?.timestamp || Date.now()
         };
     }
     
     // If we're in stationary mode and have a locked position, return the locked position
     if (this.stationaryMode && this.stationaryLocked && this.stationaryPosition) {
         return {
             lat: this.stationaryPosition.lat,
             lng: this.stationaryPosition.lng,
             accuracy: position.accuracy,
             heading: position.heading,
             timestamp: position.timestamp,
             speedMPS: 0
         };
     }
     
     // Calculate time delta
     const timestamp = position.timestamp || Date.now();
     if (this.lastTimestamp) {
         this.dt = Math.min(Math.max((timestamp - this.lastTimestamp) / 1000, 0.01), 2.0);
     }
     this.lastTimestamp = timestamp;
     
     // Check for jitter
     const isJittering = this.detectJitter(position);
     
     // Adjust measurement noise based on GPS accuracy and jitter
     const accuracy = position.accuracy || 20;
     this.R = Math.max(KALMAN_MEASUREMENT_NOISE_BASE, accuracy / 5);
     
     // If in stationary mode, increase measurement noise to reduce jitter
     if (this.stationaryMode) {
         this.R *= 10.0; // Increased to further reduce jitter
     }
     
     // If jittering is detected, increase measurement noise significantly
     if (isJittering) {
         this.R *= 20.0; // Increased to further reduce jitter
     }
     
     // Adjust process noise based on accuracy and motion
     this.adjustProcessNoise(accuracy, motionDetected);
     
     // State transition matrix
     const F = [
         [1, 0, this.dt, 0],
         [0, 1, 0, this.dt],
         [0, 0, 1, 0],
         [0, 0, 0, 1]
     ];
     
     // Process noise matrix
     const G = [
         [0.5 * this.dt * this.dt, 0],
         [0, 0.5 * this.dt * this.dt],
         [this.dt, 0],
         [0, this.dt]
     ];
     
     // Measurement matrix
     const H = [
         [1, 0, 0, 0],
         [0, 1, 0, 0]
     ];
     
     // Predict step
     // x = F * x
     const predictedX = this.x + this.dt * this.vx;
     const predictedY = this.y + this.dt * this.vy;
     const predictedVx = this.stationaryMode ? 0 : this.vx;
     const predictedVy = this.stationaryMode ? 0 : this.vy;
     
     // P = F * P * F' + Q
     const Q = [
         [this.Q * this.dt * this.dt * this.dt * this.dt / 4, 0, this.Q * this.dt * this.dt * this.dt / 2, 0],
         [0, this.Q * this.dt * this.dt * this.dt * this.dt / 4, 0, this.Q * this.dt * this.dt * this.dt / 2],
         [this.Q * this.dt * this.dt * this.dt / 2, 0, this.Q * this.dt * this.dt, 0],
         [0, this.Q * this.dt * this.dt * this.dt / 2, 0, this.Q * this.dt * this.dt]
     ];
     
     // Matrix multiplication F * P
     const FP = [
         [this.P[0][0] + this.dt * this.P[2][0], this.P[0][1] + this.dt * this.P[2][1], this.P[0][2] + this.dt * this.P[2][2], this.P[0][3] + this.dt * this.P[2][3]],
         [this.P[1][0] + this.dt * this.P[3][0], this.P[1][1] + this.dt * this.P[3][1], this.P[1][2] + this.dt * this.P[3][2], this.P[1][3] + this.dt * this.P[3][3]],
         [this.P[2][0], this.P[2][1], this.P[2][2], this.P[2][3]],
         [this.P[3][0], this.P[3][1], this.P[3][2], this.P[3][3]]
     ];
     
     // Matrix multiplication FP * F'
     const predictedP = [
         [FP[0][0] + this.dt * FP[0][2] + Q[0][0], FP[0][1] + this.dt * FP[0][3] + Q[0][1], FP[0][2] + Q[0][2], FP[0][3] + Q[0][3]],
         [FP[1][0] + this.dt * FP[1][2] + Q[1][0], FP[1][1] + this.dt * FP[1][3] + Q[1][1], FP[1][2] + Q[1][2], FP[1][3] + Q[1][3]],
         [FP[2][0] + Q[2][0], FP[2][1] + Q[2][1], FP[2][2] + Q[2][2], FP[2][3] + Q[2][3]],
         [FP[3][0] + Q[3][0], FP[3][1] + Q[3][1], FP[3][2] + Q[3][2], FP[3][3] + Q[3][3]]
     ];
             
     // Update step
     // y = z - H * x
     const measurementResidualX = position.lng - predictedX;
     const measurementResidualY = position.lat - predictedY;
     
     // S = H * P * H' + R
     const S = [
         [predictedP[0][0] + this.R, predictedP[0][1]],
         [predictedP[1][0], predictedP[1][1] + this.R]
     ];
     
     // Calculate determinant of S
     const detS = S[0][0] * S[1][1] - S[0][1] * S[1][0];
     
     // Calculate inverse of S
     const invS = [
         [S[1][1] / detS, -S[0][1] / detS],
         [-S[1][0] / detS, S[0][0] / detS]
     ];
     
     // K = P * H' * inv(S)
     const K = [
         [predictedP[0][0] * invS[0][0] + predictedP[0][1] * invS[1][0], predictedP[0][0] * invS[0][1] + predictedP[0][1] * invS[1][1]],
         [predictedP[1][0] * invS[0][0] + predictedP[1][1] * invS[1][0], predictedP[1][0] * invS[0][1] + predictedP[1][1] * invS[1][1]],
         [predictedP[2][0] * invS[0][0] + predictedP[2][1] * invS[1][0], predictedP[2][0] * invS[0][1] + predictedP[2][1] * invS[1][1]],
         [predictedP[3][0] * invS[0][0] + predictedP[3][1] * invS[1][0], predictedP[3][0] * invS[0][1] + predictedP[3][1] * invS[1][1]]
     ];
     
     // x = x + K * y
     this.x = predictedX + K[0][0] * measurementResidualX + K[0][1] * measurementResidualY;
     this.y = predictedY + K[1][0] * measurementResidualX + K[1][1] * measurementResidualY;
     
     // In stationary mode, keep velocity at zero
     if (this.stationaryMode) {
         this.vx = 0;
         this.vy = 0;
     } else {
         this.vx = predictedVx + K[2][0] * measurementResidualX + K[2][1] * measurementResidualY;
         this.vy = predictedVy + K[3][0] * measurementResidualX + K[3][1] * measurementResidualY;
     }
     
     // P = (I - K * H) * P 
     this.P = [ 
         [predictedP[0][0] - (K[0][0] * predictedP[0][0] + K[0][1] * predictedP[1][0]), 
          predictedP[0][1] - (K[0][0] * predictedP[0][1] + K[0][1] * predictedP[1][1]), 
          predictedP[0][2] - (K[0][0] * predictedP[0][2] + K[0][1] * predictedP[1][2]), 
          predictedP[0][3] - (K[0][0] * predictedP[0][3] + K[0][1] * predictedP[1][3])], 
         
         [predictedP[1][0] - (K[1][0] * predictedP[0][0] + K[1][1] * predictedP[1][0]), 
          predictedP[1][1] - (K[1][0] * predictedP[0][1] + K[1][1] * predictedP[1][1]), 
          predictedP[1][2] - (K[1][0] * predictedP[0][2] + K[1][1] * predictedP[1][2]), 
          predictedP[1][3] - (K[1][0] * predictedP[0][3] + K[1][1] * predictedP[1][3])], 
         
         [predictedP[2][0] - (K[2][0] * predictedP[0][0] + K[2][1] * predictedP[1][0]), 
          predictedP[2][1] - (K[2][0] * predictedP[0][1] + K[2][1] * predictedP[1][1]), 
          predictedP[2][2] - (K[2][0] * predictedP[0][2] + K[2][1] * predictedP[1][2]), 
          predictedP[2][3] - (K[2][0] * predictedP[0][3] + K[2][1] * predictedP[1][3])], 
         
         [predictedP[3][0] - (K[3][0] * predictedP[0][0] + K[3][1] * predictedP[1][0]), 
          predictedP[3][1] - (K[3][0] * predictedP[0][1] + K[3][1] * predictedP[1][1]), 
          predictedP[3][2] - (K[3][0] * predictedP[0][2] + K[3][1] * predictedP[1][2]), 
          predictedP[3][3] - (K[3][0] * predictedP[0][3] + K[3][1] * predictedP[1][3])]
     ];
     
     // Process heading data
     let smoothedHeading = position.heading;
     if (position.heading !== null && position.heading !== undefined) {
         if (this.lastHeading !== null) {
             // Normalize headings to 0-360
             const normalizedCurrent = ((position.heading % 360) + 360) % 360;
             const normalizedLast = ((this.lastHeading % 360) + 360) % 360;
             
             // Calculate the smallest angle between the two headings
             let diff = normalizedCurrent - normalizedLast;
             if (diff > 180) diff -= 360;
             if (diff < -180) diff += 360;
             
             // Apply stronger smoothing when stationary
             const headingWeight = this.stationaryMode ? 0.01 : (motionDetected ? 0.3 : 0.15);
             smoothedHeading = normalizedLast + diff * headingWeight;
             
             // Normalize back to 0-360
             smoothedHeading = ((smoothedHeading % 360) + 360) % 360;
             
             // Increase confidence with consistent headings
             if (Math.abs(diff) < 12) {
                 this.headingConfidence = Math.min(1.0, this.headingConfidence + 0.1);
             } else {
                 this.headingConfidence = Math.max(0.1, this.headingConfidence - 0.2);
             }
         }
         this.lastHeading = smoothedHeading;
     }
     
     // Calculate speed from velocity components
     const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
     
     // Create filtered position
     const filteredPosition = {
         lat: this.y,
         lng: this.x,
         accuracy: position.accuracy,
         heading: smoothedHeading,
         timestamp: position.timestamp,
         speedMPS: this.stationaryMode ? 0 : speed * 111000 // Convert from degrees/second to meters/second (approximate)
     };
     
     // If we're in stationary mode and don't have a locked position yet,
     // check if we should lock the position
     if (this.stationaryMode && !this.stationaryLocked) {
         // If we've been stationary for a while, lock the position
         if (Date.now() - stationaryStartTime > 3000) {
             this.lockStationaryPosition(filteredPosition);
         }
     }
     
     return filteredPosition;
 }
}

// Position interpolator for smooth transitions
class PositionInterpolator {
 constructor() {
     this.startPosition = null;
     this.targetPosition = null;
     this.startTime = null;
     this.duration = 0;
     this.isActive = false;
 }
 
 start(startPos, targetPos, duration) {
     if (!startPos || !targetPos) return;
     
     this.startPosition = { ...startPos };
     this.targetPosition = { ...targetPos };
     this.startTime = performance.now();
     this.duration = duration;
     this.isActive = true;
 }
 
 update() {
     if (!this.isActive) return null;
     
     const now = performance.now();
     const elapsed = now - this.startTime;
     
     if (elapsed >= this.duration) {
         this.isActive = false;
         return this.targetPosition;
     }
     
     // Calculate progress with easing
     const t = elapsed / this.duration;
     const easedT = this.easeOutCubic(t);
     
     // Interpolate position
     return {
         lat: this.startPosition.lat + (this.targetPosition.lat - this.startPosition.lat) * easedT,
         lng: this.startPosition.lng + (this.targetPosition.lng - this.startPosition.lng) * easedT,
         accuracy: this.targetPosition.accuracy,
         heading: this.targetPosition.heading,
         timestamp: now,
         speedMPS: this.targetPosition.speedMPS
     };
 }
 
 // Cubic easing function for smoother motion
 easeOutCubic(t) {
     return 1 - Math.pow(1 - t, 3);
 }
 
 isInterpolating() {
     return this.isActive;
 }
 
 cancel() {
     this.isActive = false;
 }
}

// Create Kalman filter instance
const kalmanFilter = new KalmanFilter();

// Create position interpolator
positionInterpolator = new PositionInterpolator();

// Enhanced DOM update manager with throttling
const domUpdateManager = {
 updates: new Map(),
 scheduled: false,
 maxUpdates: 100, // Limit the number of updates to prevent memory bloat
 lastFlushTime: 0,
 flushInterval: DOM_UPDATE_THROTTLE,

 // Schedule a DOM update with optional priority
 schedule(id, updateFn, priority = 0) {
     // Enforce size limit
     if (this.updates.size >= this.maxUpdates) {
         // If we're at capacity and this is a low priority update, skip it
         if (priority <= 0) {
             return;
         }
         
         // Find and remove lowest priority update to make room
         let lowestPriority = Infinity;
         let lowestId = null;
         
         for (const [id, update] of this.updates.entries()) {
             if (update.priority < lowestPriority) {
                 lowestPriority = update.priority;
                 lowestId = id;
             }
         }
         
         if (lowestId && lowestPriority < priority) {
             this.updates.delete(lowestId);
         } else {
             console.warn("DOM update limit reached, skipping update for:", id);
             return;
         }
     }

     // Store the update with its priority
     this.updates.set(id, { updateFn, priority });

     // Schedule a flush if not already scheduled
     if (!this.scheduled) {
         this.scheduled = true;
         
         const now = Date.now();
         const timeSinceLastFlush = now - this.lastFlushTime;
         
         // For high priority updates or if enough time has passed, use requestAnimationFrame
         if (priority > 5 || timeSinceLastFlush >= this.flushInterval) {
             requestAnimationFrame(() => this.flush());
         } else {
             // For lower priority updates, use setTimeout to batch updates
             setTimeout(() => this.flush(), this.flushInterval - timeSinceLastFlush);
         }
     }
 },

 // Flush all scheduled DOM updates
 flush() {
     try {
         this.lastFlushTime = Date.now();
         
         // Convert updates to an array and sort by priority (higher priority first)
         const sortedUpdates = Array.from(this.updates.values())
             .sort((a, b) => b.priority - a.priority);

         // Execute updates
         sortedUpdates.forEach(({ updateFn }) => {
             try {
                 updateFn();
             } catch (error) {
                 console.error("Error executing DOM update:", error);
             }
         });
     } catch (error) {
         console.error("Error during DOM update flush:", error);
     } finally {
         // Clear updates and reset state
         this.updates.clear();
         this.scheduled = false;
     }
 },

 // Cancel a scheduled update by ID
 cancel(id) {
     this.updates.delete(id);
 },

 // Clear all pending updates
 clear() {
     this.updates.clear();
     this.scheduled = false;
 }
};

// Initialize Web Worker for position calculations
function initPositionWorker() {
    if (window.Worker) {
        try {
            // Create a blob URL for the worker script
            const workerScript = `
                // Position calculation worker
                
                // Constants
                const KALMAN_PROCESS_NOISE = ${KALMAN_PROCESS_NOISE};
                const KALMAN_MEASUREMENT_NOISE_BASE = ${KALMAN_MEASUREMENT_NOISE_BASE};
                const KALMAN_STATIONARY_NOISE = ${KALMAN_STATIONARY_NOISE};
                
                // Kalman filter implementation for worker
                class KalmanFilter {
                    constructor() {
                        // State variables
                        this.x = 0; // Longitude estimate
                        this.y = 0; // Latitude estimate
                        this.vx = 0; // Longitude velocity
                        this.vy = 0; // Latitude velocity
                        
                        // Error covariance matrix
                        this.P = [
                            [100, 0, 0, 0],
                            [0, 100, 0, 0],
                            [0, 0, 10, 0],
                            [0, 0, 0, 10]
                        ];
                        
                        // Process noise
                        this.Q = KALMAN_PROCESS_NOISE;
                        
                        // Measurement noise
                        this.R = KALMAN_MEASUREMENT_NOISE_BASE;
                        
                        // Time delta
                        this.dt = 1.0;
                        
                        // Initialized flag
                        this.initialized = false;
                        
                        // Heading and accuracy tracking
                        this.lastHeading = null;
                        this.headingConfidence = 0;
                        
                        // Stationary mode flag
                        this.stationaryMode = false;
                        
                        // Last timestamp
                        this.lastTimestamp = null;
                        
                        // Adaptive noise parameters
                        this.adaptiveNoiseMin = 0.0005;
                        this.adaptiveNoiseMax = 0.005;
                        this.adaptiveNoiseFactor = 1.0;
                        
                        // Position history for jitter detection
                        this.positionHistory = [];
                        this.maxPositionHistory = 5;
                        this.jitterThreshold = 0.5;
                        this.jitterCount = 0;
                        
                        // Stationary lock
                        this.stationaryLocked = false;
                        this.stationaryPosition = null;
                    }
                    
                    // Initialize the filter with first position
                    reset(position) {
                        if (!position || typeof position.lat !== 'number' || typeof position.lng !== 'number') {
                            return;
                        }
                        
                        this.x = position.lng;
                        this.y = position.lat;
                        this.vx = 0;
                        this.vy = 0;
                        
                        // Reset covariance matrix with high initial uncertainty
                        this.P = [
                            [100, 0, 0, 0],
                            [0, 100, 0, 0],
                            [0, 0, 10, 0],
                            [0, 0, 0, 10]
                        ];
                        
                        this.initialized = true;
                        this.lastHeading = position.heading || null;
                        this.headingConfidence = 0;
                        this.stationaryMode = false;
                        this.lastTimestamp = position.timestamp || Date.now();
                        this.adaptiveNoiseFactor = 1.0;
                        this.positionHistory = [];
                        this.jitterCount = 0;
                        this.stationaryLocked = false;
                        this.stationaryPosition = null;
                    }
                    
                    // Set stationary mode
                    setStationaryMode(isStationary) {
                        this.stationaryMode = isStationary;
                        
                        if (isStationary) {
                            this.vx = 0;
                            this.vy = 0;
                            this.Q = KALMAN_STATIONARY_NOISE;
                            this.adaptiveNoiseFactor = 0.05;
                        } else {
                            this.Q = KALMAN_PROCESS_NOISE;
                            this.adaptiveNoiseFactor = 1.0;
                            this.stationaryLocked = false;
                            this.stationaryPosition = null;
                        }
                    }
                    
                    // Lock stationary position
                    lockStationaryPosition(position) {
                        if (!this.stationaryMode) return;
                        
                        this.stationaryLocked = true;
                        this.stationaryPosition = position;
                    }
                    
                    // Detect jitter in position updates
                    detectJitter(newPosition) {
                        if (this.positionHistory.length === 0) {
                            this.positionHistory.push(newPosition);
                            return false;
                        }
                        
                        const lastPos = this.positionHistory[this.positionHistory.length - 1];
                        const distance = calculateDistance(lastPos, newPosition);
                        
                        // Add to history
                        this.positionHistory.push(newPosition);
                        if (this.positionHistory.length > this.maxPositionHistory) {
                            this.positionHistory.shift();
                        }
                        
                        // Check for rapid back-and-forth movement (jitter)
                        if (this.positionHistory.length >= 3 && this.stationaryMode) {
                            const pos1 = this.positionHistory[this.positionHistory.length - 3];
                            const pos2 = this.positionHistory[this.positionHistory.length - 2];
                            const pos3 = this.positionHistory[this.positionHistory.length - 1];
                            
                            const dist1 = calculateDistance(pos1, pos2);
                            const dist2 = calculateDistance(pos2, pos3);
                            
                            // If moving back and forth in small distances
                            if (dist1 < this.jitterThreshold && dist2 < this.jitterThreshold && 
                                Math.sign(pos3.lat - pos2.lat) !== Math.sign(pos2.lat - pos1.lat) &&
                                Math.sign(pos3.lng - pos2.lng) !== Math.sign(pos2.lng - pos1.lng)) {
                                this.jitterCount++;
                                return this.jitterCount > 2;
                            }
                        }
                        
                        // Reset jitter count if no jitter detected
                        if (distance > this.jitterThreshold) {
                            this.jitterCount = 0;
                        }
                        
                        return false;
                    }
                    
                    // Calculate distance between two points using Haversine formula
                    calculateDistance(pos1, pos2) {
                        if (!pos1 || !pos2 || 
                            typeof pos1.lat !== 'number' || typeof pos1.lng !== 'number' || 
                            typeof pos2.lat !== 'number' || typeof pos2.lng !== 'number') {
                            return Infinity;
                        }
                        
                        const R = 6371000; // Earth's radius in meters
                        const lat1 = pos1.lat * Math.PI / 180;
                        const lat2 = pos2.lat * Math.PI / 180;
                        const deltaLat = (pos2.lat - pos1.lat) * Math.PI / 180;
                        const deltaLng = (pos2.lng - pos1.lng) * Math.PI / 180;
                    
                        const a = Math.sin(deltaLat/2) * Math.sin(deltaLat/2) +
                                Math.cos(lat1) * Math.cos(lat2) *
                                Math.sin(deltaLng/2) * Math.sin(deltaLng/2);
                        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                    
                        return R * c;
                    }
                    
                    // Adjust process noise based on accuracy and motion
                    adjustProcessNoise(accuracy, motionDetected) {
                        // Base noise level depends on GPS accuracy
                        let noiseLevel = this.adaptiveNoiseMin + 
                            (this.adaptiveNoiseMax - this.adaptiveNoiseMin) * 
                            Math.min(1.0, accuracy / 40.0);
                        
                        // Reduce noise when stationary
                        if (this.stationaryMode) {
                            noiseLevel *= 0.05;
                        }
                        
                        // Increase noise when motion is detected
                        if (motionDetected && !this.stationaryMode) {
                            noiseLevel *= 1.5;
                        }
                        
                        // Apply adaptive factor
                        noiseLevel *= this.adaptiveNoiseFactor;
                        
                        // Set process noise
                        this.Q = noiseLevel;
                    }
                    
                    // Update the filter with new measurement
                    update(position, motionDetected = false) {
                        if (!this.initialized) {
                            this.reset(position);
                            return position;
                        }
                        
                        if (!position || typeof position.lat !== 'number' || typeof position.lng !== 'number') {
                            return {
                                lat: this.y,
                                lng: this.x,
                                accuracy: position?.accuracy || 20,
                                heading: this.lastHeading,
                                timestamp: position?.timestamp || Date.now()
                            };
                        }
                        
                        // If we're in stationary mode and have a locked position, return the locked position
                        if (this.stationaryMode && this.stationaryLocked && this.stationaryPosition) {
                            return {
                                lat: this.stationaryPosition.lat,
                                lng: this.stationaryPosition.lng,
                                accuracy: position.accuracy,
                                heading: position.heading,
                                timestamp: position.timestamp,
                                speedMPS: 0
                            };
                        }
                        
                        // Calculate time delta
                        const timestamp = position.timestamp || Date.now();
                        if (this.lastTimestamp) {
                            this.dt = Math.min(Math.max((timestamp - this.lastTimestamp) / 1000, 0.01), 2.0);
                        }
                        this.lastTimestamp = timestamp;
                        
                        // Check for jitter
                        const isJittering = this.detectJitter(position);
                        
                        // Adjust measurement noise based on GPS accuracy and jitter
                        const accuracy = position.accuracy || 20;
                        this.R = Math.max(KALMAN_MEASUREMENT_NOISE_BASE, accuracy / 5);
                        
                        // If in stationary mode, increase measurement noise to reduce jitter
                        if (this.stationaryMode) {
                            this.R *= 10.0;
                        }
                        
                        // If jittering is detected, increase measurement noise significantly
                        if (isJittering) {
                            this.R *= 20.0;
                        }
                        
                        // Adjust process noise based on accuracy and motion
                        this.adjustProcessNoise(accuracy, motionDetected);
                        
                        // State transition matrix
                        const F = [
                            [1, 0, this.dt, 0],
                            [0, 1, 0, this.dt],
                            [0, 0, 1, 0],
                            [0, 0, 0, 1]
                        ];
                        
                        // Predict step
                        // x = F * x
                        const predictedX = this.x + this.dt * this.vx;
                        const predictedY = this.y + this.dt * this.vy;
                        const predictedVx = this.stationaryMode ? 0 : this.vx;
                        const predictedVy = this.stationaryMode ? 0 : this.vy;
                        
                        // P = F * P * F' + Q
                        const Q = [
                            [this.Q * this.dt * this.dt * this.dt * this.dt / 4, 0, this.Q * this.dt * this.dt * this.dt / 2, 0],
                            [0, this.Q * this.dt * this.dt * this.dt * this.dt / 4, 0, this.Q * this.dt * this.dt * this.dt / 2],
                            [this.Q * this.dt * this.dt * this.dt / 2, 0, this.Q * this.dt * this.dt, 0],
                            [0, this.Q * this.dt * this.dt * this.dt / 2, 0, this.Q * this.dt * this.dt]
                        ];
                        
                        // Matrix multiplication F * P
                        const FP = [
                            [this.P[0][0] + this.dt * this.P[2][0], this.P[0][1] + this.dt * this.P[2][1], this.P[0][2] + this.dt * this.P[2][2], this.P[0][3] + this.dt * this.P[2][3]],
                            [this.P[1][0] + this.dt * this.P[3][0], this.P[1][1] + this.dt * this.P[3][1], this.P[1][2] + this.dt * this.P[3][2], this.P[1][3] + this.dt * this.P[3][3]],
                            [this.P[2][0], this.P[2][1], this.P[2][2], this.P[2][3]],
                            [this.P[3][0], this.P[3][1], this.P[3][2], this.P[3][3]]
                        ];
                        
                        // Matrix multiplication FP * F'
                        const predictedP = [
                            [FP[0][0] + this.dt * FP[0][2] + Q[0][0], FP[0][1] + this.dt * FP[0][3] + Q[0][1], FP[0][2] + Q[0][2], FP[0][3] + Q[0][3]],
                            [FP[1][0] + this.dt * FP[1][2] + Q[1][0], FP[1][1] + this.dt * FP[1][3] + Q[1][1], FP[1][2] + Q[1][2], FP[1][3] + Q[1][3]],
                            [FP[2][0] + Q[2][0], FP[2][1] + Q[2][1], FP[2][2] + Q[2][2], FP[2][3] + Q[2][3]],
                            [FP[3][0] + Q[3][0], FP[3][1] + Q[3][1], FP[3][2] + Q[3][2], FP[3][3] + Q[3][3]]
                        ];
                                
                        // Update step
                        // y = z - H * x
                        const measurementResidualX = position.lng - predictedX;
                        const measurementResidualY = position.lat - predictedY;
                        
                        // S = H * P * H' + R
                        const S = [
                            [predictedP[0][0] + this.R, predictedP[0][1]],
                            [predictedP[1][0], predictedP[1][1] + this.R]
                        ];
                        
                        // Calculate determinant of S
                        const detS = S[0][0] * S[1][1] - S[0][1] * S[1][0];
                        
                        // Calculate inverse of S
                        const invS = [
                            [S[1][1] / detS, -S[0][1] / detS],
                            [-S[1][0] / detS, S[0][0] / detS]
                        ];
                        
                        // K = P * H' * inv(S)
                        const K = [
                            [predictedP[0][0] * invS[0][0] + predictedP[0][1] * invS[1][0], predictedP[0][0] * invS[0][1] + predictedP[0][1] * invS[1][1]],
                            [predictedP[1][0] * invS[0][0] + predictedP[1][1] * invS[1][0], predictedP[1][0] * invS[0][1] + predictedP[1][1] * invS[1][1]],
                            [predictedP[2][0] * invS[0][0] + predictedP[2][1] * invS[1][0], predictedP[2][0] * invS[0][1] + predictedP[2][1] * invS[1][1]],
                            [predictedP[3][0] * invS[0][0] + predictedP[3][1] * invS[1][0], predictedP[3][0] * invS[0][1] + predictedP[3][1] * invS[1][1]]
                        ];
                        
                        // x = x + K * y
                        this.x = predictedX + K[0][0] * measurementResidualX + K[0][1] * measurementResidualY;
                        this.y = predictedY + K[1][0] * measurementResidualX + K[1][1] * measurementResidualY;
                        
                        // In stationary mode, keep velocity at zero
                        if (this.stationaryMode) {
                            this.vx = 0;
                            this.vy = 0;
                        } else {
                            this.vx = predictedVx + K[2][0] * measurementResidualX + K[2][1] * measurementResidualY;
                            this.vy = predictedVy + K[3][0] * measurementResidualX + K[3][1] * measurementResidualY;
                        }
                        
                        // P = (I - K * H) * P 
                        this.P = [ 
                            [predictedP[0][0] - (K[0][0] * predictedP[0][0] + K[0][1] * predictedP[1][0]), 
                             predictedP[0][1] - (K[0][0] * predictedP[0][1] + K[0][1] * predictedP[1][1]), 
                             predictedP[0][2] - (K[0][0] * predictedP[0][2] + K[0][1] * predictedP[1][2]), 
                             predictedP[0][3] - (K[0][0] * predictedP[0][3] + K[0][1] * predictedP[1][3])], 
                            
                            [predictedP[1][0] - (K[1][0] * predictedP[0][0] + K[1][1] * predictedP[1][0]), 
                             predictedP[1][1] - (K[1][0] * predictedP[0][1] + K[1][1] * predictedP[1][1]), 
                             predictedP[1][2] - (K[1][0] * predictedP[0][2] + K[1][1] * predictedP[1][2]), 
                             predictedP[1][3] - (K[1][0] * predictedP[0][3] + K[1][1] * predictedP[1][3])], 
                            
                            [predictedP[2][0] - (K[2][0] * predictedP[0][0] + K[2][1] * predictedP[1][0]), 
                             predictedP[2][1] - (K[2][0] * predictedP[0][1] + K[2][1] * predictedP[1][1]), 
                             predictedP[2][2] - (K[2][0] * predictedP[0][2] + K[2][1] * predictedP[1][2]), 
                             predictedP[2][3] - (K[2][0] * predictedP[0][3] + K[2][1] * predictedP[1][3])], 
                            
                            [predictedP[3][0] - (K[3][0] * predictedP[0][0] + K[3][1] * predictedP[1][0]), 
                             predictedP[3][1] - (K[3][0] * predictedP[0][1] + K[3][1] * predictedP[1][1]), 
                             predictedP[3][2] - (K[3][0] * predictedP[0][2] + K[3][1] * predictedP[1][2]), 
                             predictedP[3][3] - (K[3][0] * predictedP[0][3] + K[3][1] * predictedP[1][3])]
                        ];
                        
                        // Process heading data
                        let smoothedHeading = position.heading;
                        if (position.heading !== null && position.heading !== undefined) {
                            if (this.lastHeading !== null) {
                                // Normalize headings to 0-360
                                const normalizedCurrent = ((position.heading % 360) + 360) % 360;
                                const normalizedLast = ((this.lastHeading % 360) + 360) % 360;
                                
                                // Calculate the smallest angle between the two headings
                                let diff = normalizedCurrent - normalizedLast;
                                if (diff > 180) diff -= 360;
                                if (diff < -180) diff += 360;
                                
                                // Apply stronger smoothing when stationary
                                const headingWeight = this.stationaryMode ? 0.01 : (motionDetected ? 0.3 : 0.15);
                                smoothedHeading = normalizedLast + diff * headingWeight;
                                
                                // Normalize back to 0-360
                                smoothedHeading = ((smoothedHeading % 360) + 360) % 360;
                                
                                // Increase confidence with consistent headings
                                if (Math.abs(diff) < 12) {
                                    this.headingConfidence = Math.min(1.0, this.headingConfidence + 0.1);
                                } else {
                                    this.headingConfidence = Math.max(0.1, this.headingConfidence - 0.2);
                                }
                            }
                            this.lastHeading = smoothedHeading;
                        }
                        
                        // Calculate speed from velocity components
                        const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                        
                        // Create filtered position
                        const filteredPosition = {
                            lat: this.y,
                            lng: this.x,
                            accuracy: position.accuracy,
                            heading: smoothedHeading,
                            timestamp: position.timestamp,
                            speedMPS: this.stationaryMode ? 0 : speed * 111000 // Convert from degrees/second to meters/second (approximate)
                        };
                        
                        return filteredPosition;
                    }
                }
                
                // Calculate distance between two points using Haversine formula
                function calculateDistance(pos1, pos2) {
                    if (!pos1 || !pos2 || 
                        typeof pos1.lat !== 'number' || typeof pos1.lng !== 'number' || 
                        typeof pos2.lat !== 'number' || typeof pos2.lng !== 'number') {
                        return Infinity;
                    }
                    
                    const R = 6371000; // Earth's radius in meters
                    const lat1 = pos1.lat * Math.PI / 180;
                    const lat2 = pos2.lat * Math.PI / 180;
                    const deltaLat = (pos2.lat - pos1.lat) * Math.PI / 180;
                    const deltaLng = (pos2.lng - pos1.lng) * Math.PI / 180;
                
                    const a = Math.sin(deltaLat/2) * Math.sin(deltaLat/2) +
                            Math.cos(lat1) * Math.cos(lat2) *
                            Math.sin(deltaLng/2) * Math.sin(deltaLng/2);
                    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                
                    return R * c;
                }
                
                // Create Kalman filter instance
                const kalmanFilter = new KalmanFilter();
                
                // Handle messages from main thread
                self.onmessage = function(e) {
                    const { type, data } = e.data;
                    
                    switch(type) {
                        case 'init':
                            kalmanFilter.reset(data.position);
                            self.postMessage({ type: 'initialized' });
                            break;
                            
                        case 'update':
                            const filteredPosition = kalmanFilter.update(data.position, data.motionDetected);
                            self.postMessage({ 
                                type: 'position', 
                                position: filteredPosition,
                                isStationary: kalmanFilter.stationaryMode
                            });
                            break;
                            
                        case 'setStationary':
                            kalmanFilter.setStationaryMode(data.isStationary);
                            self.postMessage({ 
                                type: 'stationarySet', 
                                isStationary: data.isStationary 
                            });
                            break;
                            
                        case 'lockPosition':
                            kalmanFilter.lockStationaryPosition(data.position);
                            self.postMessage({ 
                                type: 'positionLocked', 
                                position: data.position 
                            });
                            break;
                            
                        case 'calculateDistance':
                            const distance = calculateDistance(data.pos1, data.pos2);
                            self.postMessage({ 
                                type: 'distance', 
                                distance: distance,
                                id: data.id
                            });
                            break;
                            
                        case 'ping':
                            self.postMessage({ type: 'pong' });
                            break;
                    }
                };
            `;
            
            const blob = new Blob([workerScript], { type: 'application/javascript' });
            const workerUrl = URL.createObjectURL(blob);
            
            positionWorker = new Worker(workerUrl);
            
            // Set up message handler
            positionWorker.onmessage = handleWorkerMessage;
            
            // Clean up the URL
            URL.revokeObjectURL(workerUrl);
            
            console.log('Position worker initialized');
            return true;
        } catch (error) {
            console.error('Error creating position worker:', error);
            return false;
        }
    } else {
        console.warn('Web Workers not supported in this browser');
        return false;
    }
}

// Handle messages from the worker
function handleWorkerMessage(e) {
    const now = Date.now();
    if (now - lastWorkerMessage < WORKER_MESSAGE_THROTTLE && e.data.type !== 'pong') {
        // Queue non-critical messages for later processing
        pendingWorkerTasks.push(e);
        return;
    }
    
    lastWorkerMessage = now;
    workerBusy = false;
    
    const { type, position, isStationary, distance, id } = e.data;
    
    switch(type) {
        case 'position':
            // Process filtered position from worker
            if (position) {
                positionUpdateQueue.push(position);
                
                // Update stationary state if needed
                if (isStationary !== undefined && isStationary !== isStationary) {
                    isStationary = isStationary;
                }
            }
            break;
            
        case 'distance':
            // Handle distance calculation result
            if (typeof distance === 'number' && id) {
                // Find the callback for this distance calculation
                const callback = pendingDistanceCalculations.get(id);
                if (callback) {
                    callback(distance);
                    pendingDistanceCalculations.delete(id);
                }
            }
            break;
            
        case 'initialized':
        case 'stationarySet':
        case 'positionLocked':
        case 'pong':
            // Just acknowledgments, no action needed
            break;
    }
    
    // Process any pending tasks if we have them
    processPendingWorkerTasks();
}

// Process pending worker tasks
function processPendingWorkerTasks() {
    // Use requestIdleCallback if available, otherwise use setTimeout
    if (window.requestIdleCallback && pendingWorkerTasks.length > 0) {
        if (!idleCallbackHandle) {
            idleCallbackHandle = window.requestIdleCallback(() => {
                idleCallbackHandle = null;
                const now = Date.now();
                
                // Process up to 5 tasks at a time
                const tasksToProcess = Math.min(5, pendingWorkerTasks.length);
                for (let i = 0; i < tasksToProcess; i++) {
                    const task = pendingWorkerTasks.shift();
                    handleWorkerMessage(task);
                }
                
                // If we still have tasks, schedule another callback
                if (pendingWorkerTasks.length > 0) {
                    processPendingWorkerTasks();
                }
            }, { timeout: 100 });
        }
    } else if (pendingWorkerTasks.length > 0) {
        setTimeout(() => {
            const task = pendingWorkerTasks.shift();
            handleWorkerMessage(task);
            
            // If we still have tasks, schedule another callback
            if (pendingWorkerTasks.length > 0) {
                processPendingWorkerTasks();
            }
        }, 16);
    }
}

// Send position update to worker
function updatePositionInWorker(position, motionDetected = false) {
    if (!positionWorker) return;
    
    const now = Date.now();
    if (now - lastPositionWorkerUpdate < positionWorkerUpdateThrottle) {
        return;
    }
    
    lastPositionWorkerUpdate = now;
    
    if (!workerBusy) {
        workerBusy = true;
        positionWorker.postMessage({
            type: 'update',
            data: {
                position: position,
                motionDetected: motionDetected
            }
        });
    }
}

// Set stationary mode in worker
function setStationaryInWorker(isStationary) {
    if (!positionWorker) return;
    
    positionWorker.postMessage({
        type: 'setStationary',
        data: {
            isStationary: isStationary
        }
    });
}

// Lock position in worker
function lockPositionInWorker(position) {
    if (!positionWorker) return;
    
    positionWorker.postMessage({
        type: 'lockPosition',
        data: {
            position: position
        }
    });
}

// Calculate distance using worker
function calculateDistanceInWorker(pos1, pos2) {
    return new Promise((resolve) => {
        if (!positionWorker) {
            // Fallback to local calculation
            resolve(calculateDistance(pos1, pos2));
            return;
        }
        
        const id = distanceCalculationId++;
        
        // Store callback
        pendingDistanceCalculations.set(id, resolve);
        
        // Send to worker
        positionWorker.postMessage({
            type: 'calculateDistance',
            data: {
                pos1: pos1,
                pos2: pos2,
                id: id
            }
        });
    });
}

// Calculate appropriate zoom level based on speed
function calculateZoomLevel(speedMPS) {
 // Update current speed for global access
 currentSpeed = speedMPS;
 
 // Determine zoom level based on speed
 let zoomLevel;
 if (isStationary || speedMPS < 0.5) {
     // Stationary or very slow movement
     zoomLevel = MAX_ZOOM_LEVEL;
 } else if (speedMPS < WALKING_SPEED_THRESHOLD) {
     // Walking speed
     zoomLevel = WALKING_ZOOM_LEVEL;
 } else if (speedMPS < RUNNING_SPEED_THRESHOLD) { 
     // Running speed - linear interpolation between walking and running zoom levels
     const t = (speedMPS - WALKING_SPEED_THRESHOLD) / (RUNNING_SPEED_THRESHOLD - WALKING_SPEED_THRESHOLD);
     zoomLevel = WALKING_ZOOM_LEVEL - t * 2; // More aggressive zoom out for running
 } else if (speedMPS < DRIVING_SPEED_THRESHOLD) {
     // Driving speed - linear interpolation between running and driving zoom levels
     const t = (speedMPS - RUNNING_SPEED_THRESHOLD) / (DRIVING_SPEED_THRESHOLD - RUNNING_SPEED_THRESHOLD);
     zoomLevel = (WALKING_ZOOM_LEVEL - 2) - t * 2; // More aggressive zoom out for driving
 } else {
     // High speed
     zoomLevel = MIN_ZOOM_LEVEL;
 }
 
 // Smooth zoom level changes
 if (lastZoomLevel !== null) {
     // Apply smoothing to avoid abrupt zoom changes
     zoomLevel = lastZoomLevel * 0.85 + zoomLevel * 0.15; // Increased responsiveness
 }
 
 // Round to one decimal place for smoother transitions
 zoomLevel = Math.round(zoomLevel * 10) / 10;
 
 // Clamp to valid zoom range
 zoomLevel = Math.max(MIN_ZOOM_LEVEL, Math.min(MAX_ZOOM_LEVEL, zoomLevel));
 
 // Update last zoom level
 lastZoomLevel = zoomLevel;
 
 return zoomLevel;
}

// Enhanced stationary position calculation
function calculateStationaryPosition(buffer) {
 if (!buffer || buffer.length === 0) {
     return null;
 }
 
 // Sort by accuracy (best first)
 const sortedBuffer = [...buffer].sort((a, b) => a.accuracy - b.accuracy);
 
 // Take weighted average of best positions
 const topPositions = sortedBuffer.slice(0, Math.ceil(buffer.length / 2));
 
 const weights = topPositions.map(pos => 1 / Math.max(1, pos.accuracy));
 const totalWeight = weights.reduce((sum, w) => sum + w, 0);
 
 if (totalWeight === 0) {
     return sortedBuffer[0];
 }
 
 // Calculate weighted average
 const avgPosition = {
     lat: topPositions.reduce((sum, pos, i) => sum + pos.lat * weights[i], 0) / totalWeight,
     lng: topPositions.reduce((sum, pos, i) => sum + pos.lng * weights[i], 0) / totalWeight,
     accuracy: topPositions[0].accuracy,
     heading: topPositions[0].heading,
     timestamp: Date.now(),
     speedMPS: 0
 };
 
 // If we have a previous stationary position, blend with it for stability
 if (lastStationaryPosition) {
     const blendFactor = 0.98; // Increased to 98% previous, 2% new for extreme stability
     return {
         lat: lastStationaryPosition.lat * blendFactor + avgPosition.lat * (1 - blendFactor),
         lng: lastStationaryPosition.lng * blendFactor + avgPosition.lng * (1 - blendFactor),
         accuracy: avgPosition.accuracy,
         heading: avgPosition.heading,
         timestamp: avgPosition.timestamp,
         speedMPS: 0
     };
 }
 
 return avgPosition;
}

// Update stationary position history
function updateStationaryHistory(position) {
 // Add new position to history
 stationaryPositionHistory.push(position);
 
 // Keep history at maximum size
 while (stationaryPositionHistory.length > STATIONARY_POSITION_HISTORY_SIZE) {
     stationaryPositionHistory.shift();
 }
 
 // Calculate weighted average of positions
 let totalWeight = 0;
 let weightedLat = 0;
 let weightedLng = 0;
 
 // Newer positions have higher weight
 for (let i = 0; i < stationaryPositionHistory.length; i++) {
     const pos = stationaryPositionHistory[i];
     const weight = Math.pow(STATIONARY_POSITION_WEIGHT_DECAY, stationaryPositionHistory.length - i - 1);
     totalWeight += weight;
     weightedLat += pos.lat * weight;
     weightedLng += pos.lng * weight;
 }
 
 return {
     lat: weightedLat / totalWeight,
     lng: weightedLng / totalWeight,
     accuracy: position.accuracy,
     heading: position.heading,
     timestamp: position.timestamp,
     speedMPS: 0
 };
}

// Check if device is in motion based on motion sensors
function isDeviceInMotion() {
 if (!motionSamples || motionSamples.length < 3) {
     return false;
 }
 
 // Calculate average motion magnitude
 const avgMotion = motionSamples.reduce((sum, sample) => {
     return sum + Math.sqrt(
         sample.x * sample.x + 
         sample.y * sample.y + 
         sample.z * sample.z
     );
 }, 0) / motionSamples.length;
 
 return avgMotion > MOTION_THRESHOLD;
}

// Process device motion data
function handleDeviceMotion(event) {
 if (!event || !event.acceleration) return;
 
 const motion = {
     x: event.acceleration.x || 0,
     y: event.acceleration.y || 0,
     z: event.acceleration.z || 0,
     timestamp: Date.now()
 };
 
 // Add to motion samples
 motionSamples.push(motion);
 
 // Keep only recent samples
 while (motionSamples.length > MOTION_SAMPLE_SIZE) {
     motionSamples.shift();
 }
 
 // Update device motion state
 deviceMotion = motion;
 
 // Check if device is stationary based on motion
 const inMotion = isDeviceInMotion();
 
 if (!inMotion) {
     deviceStationaryTime += MOTION_CHECK_INTERVAL;
 } else {
     deviceStationaryTime = 0;
 }
}

// Process device orientation data
function handleDeviceOrientation(event) {
 if (!event || event.alpha === null) return;
 
 deviceOrientation = {
     alpha: event.alpha, // z-axis rotation [0,360)
     beta: event.beta,   // x-axis rotation [-180,180)
     gamma: event.gamma, // y-axis rotation [-90,90)
     timestamp: Date.now()
 };
 
 // Update heading buffer if we have a compass heading
 if (event.webkitCompassHeading !== undefined) {
     const heading = event.webkitCompassHeading;
     
     // Add to heading buffer
     headingBuffer.push(heading);
     
     // Keep only recent headings
     while (headingBuffer.length > 5) {
         headingBuffer.shift();
     }
     
     // Calculate median heading to filter outliers
     if (headingBuffer.length >= 3) {
         const sortedHeadings = [...headingBuffer].sort((a, b) => a - b);
         lastHeadingValue = sortedHeadings[Math.floor(sortedHeadings.length / 2)];
     }
 }
}

    // Request motion and orientation permissions
function requestMotionPermission() {
    // Check if DeviceMotionEvent and DeviceOrientationEvent are available
    if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceOrientationEvent !== 'undefined') {
        // Check if permission request is needed (iOS 13+)
        if (typeof DeviceMotionEvent.requestPermission === 'function' && 
            typeof DeviceOrientationEvent.requestPermission === 'function') {
            
            // Don't request too frequently
            const now = Date.now();
            if (permissionRequestInProgress || now - lastPermissionRequest < 10000) {
                return;
            }
            
            permissionRequestInProgress = true;
            lastPermissionRequest = now;
            
            // Request device motion permission
            DeviceMotionEvent.requestPermission()
                .then(permissionState => {
                    if (permissionState === 'granted') {
                        // Add event listener for device motion
                        window.addEventListener('devicemotion', handleDeviceMotion, PASSIVE_EVENT_OPTIONS);
                        
                        // Request device orientation permission
                        return DeviceOrientationEvent.requestPermission();
                    } else {
                        throw new Error('Device motion permission denied');
                    }
                })
                .then(permissionState => {
                    if (permissionState === 'granted') {
                        // Add event listener for device orientation
                        window.addEventListener('deviceorientation', handleDeviceOrientation, PASSIVE_EVENT_OPTIONS);
                        orientationPermissionGranted = true;
                        console.log('Motion and orientation permissions granted');
                    } else {
                        throw new Error('Device orientation permission denied');
                    }
                })
                .catch(error => {
                    console.warn('Error requesting motion/orientation permissions:', error);
                })
                .finally(() => {
                    permissionRequestInProgress = false;
                });
        } else {
            // No permission request needed, add event listeners directly
            window.addEventListener('devicemotion', handleDeviceMotion, PASSIVE_EVENT_OPTIONS);
            window.addEventListener('deviceorientation', handleDeviceOrientation, PASSIVE_EVENT_OPTIONS);
            orientationPermissionGranted = true;
        }
    } else {
        console.warn('Device motion/orientation not supported');
    }
}

// Initialize geolocation
function initGeolocation() {
    // Try to use Geolocation Sensor API first if available
    if ('GeolocationSensor' in window) {
        try {
            geolocationSensor = new GeolocationSensor({ frequency: 1 });
            geolocationSensor.addEventListener('reading', () => {
                handlePositionUpdate({
                    coords: {
                        latitude: geolocationSensor.latitude,
                        longitude: geolocationSensor.longitude,
                        accuracy: geolocationSensor.accuracy,
                        heading: geolocationSensor.heading,
                        speed: geolocationSensor.speed
                    },
                    timestamp: geolocationSensor.timestamp
                });
            });
            geolocationSensor.addEventListener('error', handleGeolocationError);
            geolocationSensor.start();
            usingGeolocationSensorAPI = true;
            console.log('Using GeolocationSensor API');
        } catch (error) {
            console.warn('GeolocationSensor API failed:', error);
            usingGeolocationSensorAPI = false;
            initStandardGeolocation();
        }
    } else {
        // Fall back to standard Geolocation API
        initStandardGeolocation();
    }
}

// Initialize standard Geolocation API
function initStandardGeolocation() {
    if (navigator.geolocation) {
        const options = {
            enableHighAccuracy: true,
            timeout: 10000,
            maximumAge: 0
        };
        
        try {
            locationWatchId = navigator.geolocation.watchPosition(
                handlePositionUpdate,
                handleGeolocationError,
                options
            );
            console.log('Using standard Geolocation API');
        } catch (error) {
            console.error('Error starting geolocation watch:', error);
            showErrorMessage('Error starting location tracking. Please reload the page.');
        }
    } else {
        console.error('Geolocation not supported');
        showErrorMessage('Your browser does not support geolocation.');
    }
}

// Handle geolocation errors
function handleGeolocationError(error) {
    locationErrorCount++;
    
    let errorMessage = 'Unknown location error';
    let errorCode = UNKNOWN_ERROR;
    
    if (error) {
        errorCode = error.code || UNKNOWN_ERROR;
        
        switch (errorCode) {
            case PERMISSION_DENIED_ERROR:
                errorMessage = 'Location permission denied';
                permissionDenied = true;
                break;
            case POSITION_UNAVAILABLE_ERROR:
                errorMessage = 'Location information unavailable';
                break;
            case TIMEOUT_ERROR:
                errorMessage = 'Location request timed out';
                break;
            default:
                errorMessage = error.message || 'Unknown location error';
        }
    }
    
    console.warn(`Geolocation error (${errorCode}): ${errorMessage}`);
    
    // Update location availability status
    isLocationAvailable = !(errorCode === PERMISSION_DENIED_ERROR || locationErrorCount > MAX_LOCATION_RETRIES);
    
    // Show error message to user
    if (errorCode === PERMISSION_DENIED_ERROR) {
        showErrorMessage('Location permission denied. Please enable location services for this website.');
    } else if (locationErrorCount > MAX_LOCATION_RETRIES) {
        showErrorMessage('Unable to get your location. Please check your device settings.');
    } else {
        // For temporary errors, retry after delay
        setTimeout(() => {
            if (!usingGeolocationSensorAPI && locationWatchId === null && !permissionDenied) {
                initStandardGeolocation();
            }
        }, LOCATION_RETRY_DELAY);
    }
    
    // Update GPS signal indicator
    updateGpsSignalIndicator(0);
}

// Handle position updates
function handlePositionUpdate(position) {
    if (!position || !position.coords) {
        console.warn('Invalid position update received');
        return;
    }
    
    // Reset error counter on successful position
    locationErrorCount = 0;
    isLocationAvailable = true;
    
    // Extract position data
    const coords = position.coords;
    const timestamp = position.timestamp || Date.now();
    
    // Create position object
    const newPosition = {
        lat: coords.latitude,
        lng: coords.longitude,
        accuracy: coords.accuracy,
        heading: coords.heading || lastHeadingValue,
        timestamp: timestamp,
        speedMPS: coords.speed || 0
    };
    
    // If this is the first position update, initialize the map
    if (isFirstPositionUpdate) {
        isFirstPositionUpdate = false;
        
        // Center map on initial position
        if (map) {
            map.setView([newPosition.lat, newPosition.lng], MAX_ZOOM_LEVEL);
            hideLoadingMessage();
        }
        
        // Initialize Kalman filter with first position
        if (positionWorker) {
            positionWorker.postMessage({
                type: 'init',
                data: {
                    position: newPosition
                }
            });
        } else {
            kalmanFilter.reset(newPosition);
        }
        
        // Start location hunt if online
        if (isOnline) {
            startHunt();
        }
    }
    
    // Process position update
    processPositionUpdate(newPosition);
}

// Process position update
function processPositionUpdate(position) {
    // Check if position is valid
    if (!position || typeof position.lat !== 'number' || typeof position.lng !== 'number') {
        console.warn('Invalid position data:', position);
        return;
    }
    
    // Calculate time since last update
    const now = Date.now();
    const timeDelta = lastPositionTimestamp ? (now - lastPositionTimestamp) / 1000 : 0;
    lastPositionTimestamp = now;
    
    // Check if device was in background
    const wasInBackground = now - lastUpdateTime > BACKGROUND_THRESHOLD;
    
    // Update GPS signal confidence score
    updateGpsConfidenceScore(position.accuracy);
    
    // Detect if device is in motion using motion sensors
    const motionDetected = isDeviceInMotion();
    
    // Process position with Kalman filter
    let filteredPosition;
    if (positionWorker) {
        // Use Web Worker for filtering
        updatePositionInWorker(position, motionDetected);
        
        // We'll get the result asynchronously via worker message
        // For now, use the last filtered position if available
        if (positionUpdateQueue.length > 0) {
            filteredPosition = positionUpdateQueue[positionUpdateQueue.length - 1];
        } else {
            filteredPosition = position;
        }
    } else {
        // Use local Kalman filter
        filteredPosition = kalmanFilter.update(position, motionDetected);
    }
    
    // Add to position buffer
    positionBuffer.push(filteredPosition);
    
    // Keep buffer at maximum size
    while (positionBuffer.length > MAX_BUFFER_SIZE) {
        positionBuffer.shift();
    }
    
    // Check if position is stationary
    checkIfStationary(filteredPosition);
    
    // Update last position
    lastPosition = filteredPosition;
    
    // Update last update time
    lastUpdateTime = now;
    
    // If we were in background, reset the map view
    if (wasInBackground && followUser) {
        resetMapView(filteredPosition);
    }
    
    // Update marker position with interpolation
    updateMarkerWithInterpolation(filteredPosition);
    
    // Check if user is near any locations
    if (gameLocations.length > 0 && !isMapInteracting) {
        checkLocationProximity();
    }
    
    // Update distance box
    updateDistanceBox();
    
    // Update GPS signal indicator
    updateGpsSignalIndicator();
    
    // Reset inactivity timer
    resetInactivityTimer();
}

// Process position update queue
function processPositionUpdateQueue() {
    // Process up to 3 updates at a time to avoid blocking
    const maxUpdates = Math.min(3, positionUpdateQueue.length);
    
    for (let i = 0; i < maxUpdates; i++) {
        const position = positionUpdateQueue.shift();
        
        if (position) {
            // Update last position
            lastPosition = position;
            
            // Update marker position with interpolation
            updateMarkerWithInterpolation(position);
        }
    }
}

// Update marker with interpolation
function updateMarkerWithInterpolation(position) {
    if (!position || !userMarker) return;
    
    // If this is the first update or we're returning from background, skip interpolation
    if (!lastRenderPosition || Date.now() - lastUpdateTime > 2000) {
        updateMarkerPosition(position);
        lastRenderPosition = position;
        return;
    }
    
    // Calculate distance between current and last position
    const distance = calculateDistance(lastRenderPosition, position);
    
    // If distance is very small, just update directly
    if (distance < 1) {
        updateMarkerPosition(position);
        lastRenderPosition = position;
        return;
    }
    
    // Start interpolation
    positionInterpolator.start(lastRenderPosition, position, ANIMATION_DURATION);
    
    // Update last render position
    lastRenderPosition = position;
}

// Update marker position with throttling
function updateMarkerPosition(position) {
    const now = Date.now();
    
    // Throttle updates to improve performance
    if (now - lastMapUpdate < mapUpdateThrottleInterval) {
        return;
    }
    
    lastMapUpdate = now;
    
    if (userMarker) {
        userMarker.setLatLng([position.lat, position.lng]);
        
        // Update marker rotation if heading is available
        if (position.heading !== null && position.heading !== undefined) {
            const markerIcon = userMarker.getElement();
            if (markerIcon) {
                const iconDiv = markerIcon.querySelector('.user-marker-icon');
                if (iconDiv) {
                    iconDiv.style.transform = `rotate(${position.heading}deg)`;
                }
            }
        }
    }
}

// Check if position is stationary
function checkIfStationary(position) {
    if (!position) return;
    
    // Get motion detection from sensors if available
    const motionDetected = isDeviceInMotion();
    
    // If we have recent positions, check for movement
    if (positionBuffer.length >= 2) {
        const lastPos = positionBuffer[positionBuffer.length - 2];
        const currentPos = position;
        
        // Calculate distance between positions
        const distance = calculateDistance(lastPos, currentPos);
        
        // Check if distance is below threshold
        if (distance < MIN_DISTANCE_THRESHOLD && !motionDetected) {
            stationaryCount++;
            
            // If we've been stationary for enough updates, mark as stationary
            if (!isStationary && stationaryCount >= STATIONARY_THRESHOLD) {
                isStationary = true;
                stationaryStartTime = Date.now();
                stationaryBuffer = positionBuffer.slice(-STATIONARY_THRESHOLD);
                
                // Calculate stable stationary position
                stationaryPosition = calculateStationaryPosition(stationaryBuffer);
                lastStationaryPosition = stationaryPosition;
                
                // Update worker with stationary state
                if (positionWorker) {
                    setStationaryInWorker(true);
                    
                    // Lock position in worker after a delay
                    setTimeout(() => {
                        if (isStationary && stationaryPosition) {
                            lockPositionInWorker(stationaryPosition);
                        }
                    }, 2000);
                } else {
                    kalmanFilter.setStationaryMode(true);
                    
                    // Lock position in Kalman filter after a delay
                    setTimeout(() => {
                        if (isStationary && stationaryPosition) {
                            kalmanFilter.lockStationaryPosition(stationaryPosition);
                        }
                    }, 2000);
                }
                
                console.log('Device is now stationary');
                
                // Schedule periodic checks to verify we're still stationary
                scheduleStationaryCheck();
            }
        } else {
            // Reset stationary count if we're moving
            stationaryCount = 0;
            
            // If we were stationary but now we're moving, update state
            if (isStationary) {
                isStationary = false;
                stationaryPosition = null;
                lastStationaryPosition = null;
                
                // Update worker with moving state
                if (positionWorker) {
                    setStationaryInWorker(false);
                } else {
                    kalmanFilter.setStationaryMode(false);
                }
                
                // Clear stationary check timeout
                if (stationaryCheckTimeout) {
                    clearTimeout(stationaryCheckTimeout);
                    stationaryCheckTimeout = null;
                }
                
                console.log('Device is now moving');
            }
        }
    }
}

// Schedule periodic check to verify we're still stationary
function scheduleStationaryCheck() {
    // Clear existing timeout
    if (stationaryCheckTimeout) {
        clearTimeout(stationaryCheckTimeout);
    }
    
    // Set new timeout
    stationaryCheckTimeout = setTimeout(() => {
        // If we're still marked as stationary, verify it
        if (isStationary && positionBuffer.length >= 2) {
            const recentPositions = positionBuffer.slice(-2);
            const distance = calculateDistance(recentPositions[0], recentPositions[1]);
            
            // If we've moved significantly, exit stationary state
            if (distance > MIN_DISTANCE_THRESHOLD * 2 || isDeviceInMotion()) {
                isStationary = false;
                stationaryPosition = null;
                
                // Update worker with moving state
                if (positionWorker) {
                    setStationaryInWorker(false);
                } else {
                    kalmanFilter.setStationaryMode(false);
                }
                
                console.log('Device is no longer stationary (verified by check)');
            } else {
                // Still stationary, schedule another check
                scheduleStationaryCheck();
            }
        }
    }, STATIONARY_CHECK_INTERVAL);
}

// Update GPS confidence score
function updateGpsConfidenceScore(accuracy) {
    // Calculate base confidence score (0-1) based on accuracy
    let score = 0;
    
    if (accuracy <= GPS_CONFIDENCE_THRESHOLD_HIGH) {
        // High accuracy (0-10m): 0.8-1.0
        score = 0.8 + 0.2 * (1 - accuracy / GPS_CONFIDENCE_THRESHOLD_HIGH);
    } else if (accuracy <= GPS_CONFIDENCE_THRESHOLD_MEDIUM) {
        // Medium accuracy (10-25m): 0.5-0.8
        score = 0.5 + 0.3 * (1 - (accuracy - GPS_CONFIDENCE_THRESHOLD_HIGH) / (GPS_CONFIDENCE_THRESHOLD_MEDIUM - GPS_CONFIDENCE_THRESHOLD_HIGH));
    } else {
        // Low accuracy (>25m): 0-0.5
        score = Math.max(0, 0.5 - (accuracy - GPS_CONFIDENCE_THRESHOLD_MEDIUM) / 100);
    }
    
    // Add to history
    confidenceScoreHistory.push(score);
    
    // Keep history at maximum size
    while (confidenceScoreHistory.length > 5) {
        confidenceScoreHistory.shift();
    }
    
    // Calculate average confidence score
    gpsConfidenceScore = confidenceScoreHistory.reduce((sum, s) => sum + s, 0) / confidenceScoreHistory.length;
}

// Update GPS signal indicator
function updateGpsSignalIndicator(forcedAccuracy) {
    const now = Date.now();
    
    // Don't update too frequently
    if (now - lastAccuracyUpdate < GPS_SIGNAL_CHECK_INTERVAL && forcedAccuracy === undefined) {
        return;
    }
    
    lastAccuracyUpdate = now;
    
    // Get current accuracy
    const accuracy = forcedAccuracy !== undefined ? forcedAccuracy : (lastPosition ? lastPosition.accuracy : 100);
    
    // Update indicator element
    const indicator = document.getElementById('accuracyIndicator');
    if (!indicator) return;
    
    // Determine signal strength
    let signalClass = '';
    let signalText = '';
    
    if (forcedAccuracy === 0 || !isLocationAvailable) {
        // No signal
        signalClass = 'no-signal';
        signalText = 'No GPS Signal';
    } else if (accuracy <= GPS_CONFIDENCE_THRESHOLD_HIGH) {
        // High accuracy
        signalClass = 'high-accuracy';
        signalText = 'GPS: High';
    } else if (accuracy <= GPS_CONFIDENCE_THRESHOLD_MEDIUM) {
        // Medium accuracy
        signalClass = 'medium-accuracy';
        signalText = 'GPS: Medium';
    } else {
        // Low accuracy
        signalClass = 'low-accuracy';
        signalText = 'GPS: Low';
    }
    
    // Schedule DOM update
    domUpdateManager.schedule('gpsIndicator', () => {
        // Remove all classes
        indicator.classList.remove('no-signal', 'low-accuracy', 'medium-accuracy', 'high-accuracy');
        
        // Add current class
        indicator.classList.add(signalClass);
        
        // Update text
        indicator.textContent = signalText;
    }, 3); // Medium priority
}

// Calculate distance between two points using Haversine formula
function calculateDistance(pos1, pos2) {
    if (!pos1 || !pos2 || 
        typeof pos1.lat !== 'number' || typeof pos1.lng !== 'number' || 
        typeof pos2.lat !== 'number' || typeof pos2.lng !== 'number') {
        return Infinity;
    }
    
    const R = 6371000; // Earth's radius in meters
    const lat1 = pos1.lat * Math.PI / 180;
    const lat2 = pos2.lat * Math.PI / 180;
    const deltaLat = (pos2.lat - pos1.lat) * Math.PI / 180;
    const deltaLng = (pos2.lng - pos1.lng) * Math.PI / 180;
    
    const a = Math.sin(deltaLat/2) * Math.sin(deltaLat/2) +
            Math.cos(lat1) * Math.cos(lat2) *
            Math.sin(deltaLng/2) * Math.sin(deltaLng/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    
    return R * c;
}

// Update distance box
function updateDistanceBox() {
    if (!userMarker || !gameLocations || gameLocations.length === 0) return;
    
    // Schedule as a low-priority DOM update
    domUpdateManager.schedule('distanceBox', () => {
        const distanceBox = document.getElementById('distanceBox');
        if (!distanceBox) return;
        
        const userLatLng = userMarker.getLatLng();
        const userPos = { lat: userLatLng.lat, lng: userLatLng.lng };
        
        // Find closest location
        let closestDistance = Infinity;
        let closestLocation = null;
        
        for (const location of gameLocations) {
            if (!location || typeof location.lat !== 'number' || typeof location.lng !== 'number') continue;
            
            const locationPos = { lat: location.lat, lng: location.lng };
            const distance = calculateDistance(userPos, locationPos);
            
            if (distance < closestDistance) {
                closestDistance = distance;
                closestLocation = location;
            }
        }
        
        // Update distance box
        if (closestLocation) {
            // Convert to feet for display
            const distanceFeet = Math.round(closestDistance * 3.28084);
            
            // Update text
            distanceBox.textContent = `${distanceFeet} ft to ${closestLocation.name}`;
            
            // Show distance box
            distanceBox.style.display = 'block';
        } else {
            // Hide distance box if no locations
            distanceBox.style.display = 'none';
        }
    }, 2); // Low priority
}

// Check if marker is near edge of map with throttling
function isMarkerNearEdge(map, marker, isStrict = false) {
    const now = Date.now();
    if (now - lastEdgeCheck < edgeCheckInterval && !isStrict) {
        return lastEdgeCheckResult || { isNearEdge: false };
    }
    
    lastEdgeCheck = now;
    
    if (!map || !marker) return { isNearEdge: false };
    
    const bounds = map.getBounds();
    const point = marker.getLatLng();
    const proximities = calculateEdgeProximity(map, point);
    
    const thresholdPercentage = isStrict ? 0.12 : EDGE_THRESHOLD_PERCENTAGE;
    
    const edges = {
        north: proximities.north < thresholdPercentage,
        south: proximities.south < thresholdPercentage,
        east: proximities.east < thresholdPercentage,
        west: proximities.west < thresholdPercentage
    };
    
    const result = {
        isNearEdge: Object.values(edges).some(edge => edge),
        edges: edges,
        proximities: proximities
    };
    
    // Cache result
    lastEdgeCheckResult = result;
    
    return result;
}

// Calculate proximity to map edges
function calculateEdgeProximity(map, point) {
    const bounds = map.getBounds();
    const latSpan = bounds.getNorth() - bounds.getSouth();
    const lngSpan = bounds.getEast() - bounds.getWest();
    
    return {
        north: Math.abs(point.lat - bounds.getNorth()) / latSpan,
        south: Math.abs(point.lat - bounds.getSouth()) / latSpan,
        east: Math.abs(point.lng - bounds.getEast()) / lngSpan,
        west: Math.abs(point.lng - bounds.getWest()) / lngSpan
    };
}

// Determine if map should recenter with throttling
function shouldRecenter(map, marker) {
    const now = Date.now();
    if (now - lastRecenterTime < RECENTER_COOLDOWN) {
        return { needsRecenter: false };
    }
    
    if (!map || !marker) return { needsRecenter: false };
    
    const edgeInfo = isMarkerNearEdge(map, marker);
    const proximities = edgeInfo.proximities;
    
    // Check for critical edge proximity (very close to edge)
    const isCritical = Object.values(proximities).some(
        proximity => proximity < CRITICAL_EDGE_THRESHOLD
    );
    
    if (isCritical) {
        lastRecenterTime = now;
        return {
            needsRecenter: true,
            isEmergency: true,
            edgeInfo: edgeInfo
        };
    }
    
    // Check for normal edge proximity
    if (edgeInfo.isNearEdge) {
        lastRecenterTime = now;
        return {
            needsRecenter: true,
            isEmergency: false,
            edgeInfo: edgeInfo
        };
    }
    
    return {
        needsRecenter: false,
        isEmergency: false,
        edgeInfo: edgeInfo
    };
}

// Perform edge recentering
function performEdgeRecenter(recenterInfo) {
    edgeRecenterInProgress = true;
    
    // Get current position
    const position = userMarker.getLatLng();
    
    // Calculate appropriate zoom level based on speed
    const dynamicZoom = calculateZoomLevel(lastPosition?.speedMPS || 0);
    
    // Calculate optimal center point that keeps the user icon away from edges
    const optimalCenter = calculateOptimalCenter(map, position, recenterInfo.edgeInfo);
    
    // Set view with animation
    map.setView([optimalCenter.lat, optimalCenter.lng], dynamicZoom, {
        animate: true,
        duration: recenterInfo.isEmergency ? 0.2 : ZOOM_TRANSITION_DURATION,
        noMoveStart: true,
        easeLinearity: 0.5
    });
    
    // Reset edge recenter flag after animation completes
    setTimeout(() => {
        edgeRecenterInProgress = false;
    }, recenterInfo.isEmergency ? 300 : ZOOM_TRANSITION_DURATION * 1000);
}

// Calculate optimal center point
function calculateOptimalCenter(map, markerPosition, edgeInfo) {
    const bounds = map.getBounds();
    
    // Calculate offsets based on which edges are being approached
    let latOffset = 0;
    let lngOffset = 0;
    
    // Apply stronger offset for the closest edge
    const proximities = edgeInfo.proximities;
    const edges = edgeInfo.edges;
    
    // Get viewport dimensions
    const viewportWidth = mapViewportWidth || map._container.clientWidth;
    const viewportHeight = mapViewportHeight || map._container.clientHeight;
    
    // Calculate aspect ratio to adjust offsets
    const aspectRatio = viewportWidth / viewportHeight;
    
    // Adjust offsets based on viewport dimensions
    const latSpan = bounds.getNorth() - bounds.getSouth();
    const lngSpan = bounds.getEast() - bounds.getWest();
    
    // Calculate offsets with consideration for viewport aspect ratio
    if (edges.north) {
        latOffset = -1 * latSpan * 0.25 * (1 / aspectRatio);
    }
    if (edges.south) {
        latOffset = latSpan * 0.25 * (1 / aspectRatio);
    }
    if (edges.east) {
        lngOffset = -1 * lngSpan * 0.25 * aspectRatio;
    }
    if (edges.west) {
        lngOffset = lngSpan * 0.25 * aspectRatio;
    }
    
    // Find the closest edge and apply extra offset
    const minProximity = Math.min(
        edges.north ? proximities.north : 1,
        edges.south ? proximities.south : 1,
        edges.east ? proximities.east : 1,
        edges.west ? proximities.west : 1
    );
    
    if (minProximity === proximities.north && edges.north) {
        latOffset *= 1.5;
    } else if (minProximity === proximities.south && edges.south) {
        latOffset *= 1.5;
    } else if (minProximity === proximities.east && edges.east) {
        lngOffset *= 1.5;
    } else if (minProximity === proximities.west && edges.west) {
        lngOffset *= 1.5;
    }
    
    return {
        lat: markerPosition.lat + latOffset,
        lng: markerPosition.lng + lngOffset
    };
}

// Update map viewport dimensions
function updateMapViewportDimensions() {
    if (!map || !map._container) return;
    
    mapViewportWidth = map._container.clientWidth;
    mapViewportHeight = map._container.clientHeight;
}

// Reset map view
function resetMapView(position) {
    if (!map || !position) return;
    
    // Calculate appropriate zoom level based on speed
    const dynamicZoom = calculateZoomLevel(position.speedMPS || 0);
    
    // Set view with animation
    map.setView([position.lat, position.lng], dynamicZoom, {
        animate: true,
        duration: ZOOM_TRANSITION_DURATION,
        noMoveStart: true
    });
    
    // Reset follow user flag
    followUser = true;
}

// Check proximity to locations and adjust zoom accordingly with throttling
function checkLocationProximity() {
    if (!userMarker || !gameLocations || gameLocations.length === 0) return;
    
    const now = Date.now();
    
    // Don't check too frequently
    if (now - lastProximityCheck < PROXIMITY_CHECK_THROTTLE) return;
    lastProximityCheck = now;
    
    // Don't check if zoom was recently changed
    if (now - lastZoomChangeTime < ZOOM_CHANGE_COOLDOWN) return;
    
    const userLatLng = userMarker.getLatLng();
    const userPos = { lat: userLatLng.lat, lng: userLatLng.lng };
    
    // Use Web Worker for distance calculations if available
    const findClosestLocation = async () => {
        let closestDistance = Infinity;
        let closestLocation = null;
        
        // Process locations in batches to avoid blocking the main thread
        const batchSize = 5;
        for (let i = 0; i < gameLocations.length; i += batchSize) {
            const batch = gameLocations.slice(i, i + batchSize);
            
            // Process batch in parallel
            const distancePromises = batch.map(async (location) => {
                if (!location || typeof location.lat !== 'number' || typeof location.lng !== 'number') {
                    return { distance: Infinity, location: null };
                }
                
                const locationPos = { lat: location.lat, lng: location.lng };
                let distance;
                
                if (positionWorker) {
                    // Use worker for calculation
                    distance = await calculateDistanceInWorker(userPos, locationPos);
                } else {
                    // Fallback to local calculation
                    distance = calculateDistance(userPos, locationPos);
                }
                
                return { distance, location };
            });
            
            const results = await Promise.all(distancePromises);
            
            // Find closest in this batch
            for (const { distance, location } of results) {
                if (isFinite(distance) && distance < closestDistance) {
                    closestDistance = distance;
                    closestLocation = location;
                }
            }
            
            // If we're processing a large number of locations, yield to main thread occasionally
            if (gameLocations.length > 20 && i % 20 === 0 && i > 0) {
                await new Promise(resolve => setTimeout(resolve, 0));
            }
        }
        
        return { closestDistance, closestLocation };
    };
    
    // Use promise to handle async distance calculations
    findClosestLocation().then(({ closestDistance, closestLocation }) => {
        // Convert to feet for threshold comparison
        const distanceFeet = Math.round(closestDistance * 3.28084);
        
        // Check if we need to adjust zoom based on proximity
        if (distanceFeet <= PROXIMITY_THRESHOLD) {
            // If we weren't near a location before, zoom in
            if (!isNearLocation && Math.abs(lastProximityDistance - closestDistance) > 1) {
                console.log(`User is now within ${PROXIMITY_THRESHOLD} feet of a location, zooming in`);
                isNearLocation = true;
                lastZoomChangeTime = now;
                
                // Get current zoom and zoom in by 1 level
                const currentZoom = map.getZoom();
                const newZoom = Math.min(currentZoom + 1, MAX_ZOOM_LEVEL);
                
                map.setZoom(newZoom, {
                    animate: true,
                    duration: ZOOM_TRANSITION_DURATION
                });
            }
        } else if (isNearLocation && distanceFeet > PROXIMITY_THRESHOLD + 10) {
            // If we were near a location but now we're not, zoom out
            console.log(`User is now outside ${PROXIMITY_THRESHOLD} feet of a location, zooming out`);
            isNearLocation = false;
            lastZoomChangeTime = now;
            
            // Get current zoom and zoom out by 1 level
            const currentZoom = map.getZoom();
            const newZoom = Math.max(currentZoom - 1, MIN_ZOOM_LEVEL);
            
            map.setZoom(newZoom, {
                animate: true,
                duration: ZOOM_TRANSITION_DURATION
            });
        }
        
        // Update last proximity distance
        lastProximityDistance = closestDistance;
    }).catch(error => {
        console.error("Error in proximity check:", error);
    });
}

// Animation loop for smooth rendering with throttling
function startAnimationLoop() {
    function animate(timestamp) {
        // Throttle animation frame rate based on device capabilities
        const now = performance.now();
        const elapsed = now - rafThrottleTimestamp;
        
        // Skip frames if we're running too fast
        if (elapsed < (1000 / targetFps)) {
            animationFrameId = requestAnimationFrame(animate);
            return;
        }
        
        rafThrottleTimestamp = now;
        frameCount++;
        
        // Calculate delta time
        const deltaTime = renderTimestamp ? (timestamp - renderTimestamp) / 1000 : 0;
        renderTimestamp = timestamp;
        
        // Process position updates
        processPositionUpdateQueue();
        
        // Update interpolated position
        if (positionInterpolator && positionInterpolator.isInterpolating()) {
            const interpolatedPosition = positionInterpolator.update();
            if (interpolatedPosition) {
                // Update marker position
                updateMarkerPosition(interpolatedPosition);
                lastRenderPosition = interpolatedPosition;
            }
        }
        
        // Check if marker is near edge and recenter if needed
        if (followUser && !isMapInteracting && !edgeRecenterInProgress) {
            const now = Date.now();
            // Only check edge proximity at regular intervals to improve performance
            if (now - lastEdgeCheck > edgeCheckInterval) {
                lastEdgeCheck = now;
                const recenterInfo = shouldRecenter(map, userMarker);
                if (recenterInfo.needsRecenter) {
                    performEdgeRecenter(recenterInfo);
                }
            }
        }
        
        // Check proximity to locations for zoom adjustments (throttled)
        const now = Date.now();
        if (now - lastProximityCheck > PROXIMITY_CHECK_THROTTLE) {
            lastProximityCheck = now;
            checkLocationProximity();
        }
        
        // Update GPS signal indicator (throttled)
        if (now - lastAccuracyUpdate > GPS_SIGNAL_CHECK_INTERVAL) {
            lastAccuracyUpdate = now;
            updateGpsSignalIndicator();
        }
        
        // Check FPS and adjust target if needed
        if (now - lastFpsCheck > fpsCheckInterval) {
            const fps = frameCount / ((now - lastFpsCheck) / 1000);
            currentFps = fps;
            frameCount = 0;
            lastFpsCheck = now;
            
            // Adjust target FPS based on performance
            adjustPerformanceSettings();
        }
        
        // Request next frame
        animationFrameId = requestAnimationFrame(animate);
    }
    
    // Start animation loop
    rafThrottleTimestamp = performance.now();
    lastFpsCheck = performance.now();
    animationFrameId = requestAnimationFrame(animate);
}

// Adjust performance settings based on device capabilities and current performance
function adjustPerformanceSettings() {
    const now = Date.now();
    if (now - lastAdaptiveCheck < adaptiveCheckInterval) return;
    
    lastAdaptiveCheck = now;
    
    // Check battery level if available
    if (hasBatteryAPI && now - lastBatteryCheck > batteryCheckInterval) {
        lastBatteryCheck = now;
        
        navigator.getBattery().then(battery => {
            batteryLevel = battery.level;
            lowPowerMode = battery.charging ? false : batteryLevel < 0.2;
        }).catch(() => {
            // Battery API failed, assume normal power
            batteryLevel = 0.5;
            lowPowerMode = false;
        });
    }
    
    // Determine appropriate performance mode
    if (lowPowerMode || isLowEndDevice || currentFps < 30) {
        // Low power mode - reduce updates and animations
        adaptivePerformanceMode = 'low';
        targetFps = 30;
        edgeCheckInterval = 500;
        mapUpdateThrottleInterval = 250;
        positionWorkerUpdateThrottle = 250;
        PROXIMITY_CHECK_THROTTLE = 2000;
    } else if (isHighEndDevice && currentFps > 55) {
        // High performance mode - more responsive
        adaptivePerformanceMode = 'high';
        targetFps = 60;
        edgeCheckInterval = 150;
        mapUpdateThrottleInterval = 100;
        positionWorkerUpdateThrottle = 50;
        PROXIMITY_CHECK_THROTTLE = 500;
    } else {
        // Balanced mode
        adaptivePerformanceMode = 'balanced';
        targetFps = 45;
        edgeCheckInterval = 250;
        mapUpdateThrottleInterval = 150;
        positionWorkerUpdateThrottle = 100;
        PROXIMITY_CHECK_THROTTLE = 1000;
    }
}

// Initialize the map with optimized event listeners
function initMap() {
    map = L.map('map', {
        zoomControl: false,
        attributionControl: false,
        zoomSnap: 0.1,
        zoomDelta: 0.5,
        wheelDebounceTime: 100,
        tapTolerance: 15,
        bounceAtZoomLimits: false,
        preferCanvas: true,
        renderer: L.canvas({ padding: 0.5 })
    }).fitWorld();
    
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 18,
        attribution: '© OpenStreetMap contributors',
        updateWhenIdle: true,
        updateWhenZooming: false,
        keepBuffer: 2
    }).addTo(map);
    
    markerClusterGroup = L.markerClusterGroup({
        showCoverageOnHover: false,
        zoomToBoundsOnClick: true,
        spiderfyOnMaxZoom: true,
        animate: true,
        animateAddingMarkers: true,
        disableClusteringAtZoom: 18,
        maxClusterRadius: 60,
        iconCreateFunction: function(cluster) {
            return L.divIcon({
                html: '<div><span>' + cluster.getChildCount() + '</span></div>',
                className: 'marker-cluster-custom',
                iconSize: L.point(40, 40)
            });
        }
    });
    map.addLayer(markerClusterGroup);
    
    // Create user icon with custom styling (red)
    const userIcon = L.divIcon({
        className: 'user-marker',
        html: '<div class="user-marker-icon"></div>',
        iconSize: [20, 20],
        iconAnchor: [10, 10]
    });
    userMarker = L.marker([0, 0], { 
        icon: userIcon,
        zIndexOffset: 1000,
        interactive: false
    }).addTo(map);
    
    // Store map viewport dimensions
    updateMapViewportDimensions();
    
    showLoadingMessage();
    
    // Initialize Web Worker for position calculations
    if (!initPositionWorker()) {
        // Fallback to local Kalman filter if Web Worker fails
        console.log('Using local Kalman filter implementation');
    }
    
    // Request motion and orientation permissions
    requestMotionPermission();
    
    // Try to use Geolocation Sensor API first, then fall back to standard Geolocation API
    initGeolocation();
    
    // Add optimized event listeners
    addOptimizedEventListeners();
    
    // Initialize network status monitoring
    initNetworkMonitoring();
    
    // Initialize intersection observer for visibility detection
    initIntersectionObserver();
    
    // Start animation loop for smooth rendering
    startAnimationLoop();
    
    // Initialize idle callback for background tasks
    initIdleCallback();
    
    // Check device capabilities
    checkDeviceCapabilities();
}

// Add optimized event listeners with passive option and throttling
function addOptimizedEventListeners() {
    // Document visibility change
    document.addEventListener('visibilitychange', throttle(handleVisibilityChange, visibilityChangeThrottle), PASSIVE_EVENT_OPTIONS);
    
    // Map events with throttling
    map.on('movestart', () => {
        followUser = false;
        isMapInteracting = true;
    });
    
    map.on('zoomstart', () => {
        isMapInteracting = true;
    });
    
    map.on('moveend', throttle(() => {
        isMapInteracting = false;
        resetInactivityTimer();
        updateMapViewportDimensions();
    }, 100));
    
    map.on('zoomend', throttle(() => {
        isMapInteracting = false;
        resetInactivityTimer();
    }, 100));
    
    // Touch events with passive option
    map.getContainer().addEventListener('touchmove', throttleTouchMove, PASSIVE_EVENT_OPTIONS);
    map.getContainer().addEventListener('touchstart', () => {
        userIsInteracting = true;
        resetInactivityTimer();
    }, PASSIVE_EVENT_OPTIONS);
    map.getContainer().addEventListener('touchend', () => {
        setTimeout(() => {
            userIsInteracting = false;
        }, 300);
    }, PASSIVE_EVENT_OPTIONS);
    
    // Window resize with throttling
    window.addEventListener('resize', throttleResize, PASSIVE_EVENT_OPTIONS);
    
    // Orientation change
    window.addEventListener('orientationchange', throttle(() => {
        setTimeout(() => {
            if (map) {
                map.invalidateSize();
                if (followUser && userMarker) {
                    map.setView(userMarker.getLatLng(), map.getZoom());
                }
            }
        }, 200);
    }, orientationChangeThrottle), PASSIVE_EVENT_OPTIONS);
    
    // Online/offline events
    window.addEventListener('online', () => {
        isOnline = true;
        showErrorMessage("Internet connection restored");
        if (gameLocations.length === 0) {
            startHunt();
        }
    });
    
    window.addEventListener('offline', () => {
        isOnline = false;
        showErrorMessage("No internet connection. Some features may not work properly.");
    });
    
    // Store event listeners for cleanup
    eventListeners.set('visibilitychange', handleVisibilityChange);
    eventListeners.set('resize', throttleResize);
    eventListeners.set('touchmove', throttleTouchMove);
}

// Throttle touch move events
function throttleTouchMove() {
    if (touchMoveThrottled) return;
    
    touchMoveThrottled = true;
    userIsInteracting = true;
    followUser = false;
    
    setTimeout(() => {
        touchMoveThrottled = false;
    }, TOUCH_MOVE_THROTTLE);
    
    resetInactivityTimer();
}

// Throttle resize events
function throttleResize() {
    if (resizeThrottled) return;
    
    resizeThrottled = true;
    
    setTimeout(() => {
        if (map) {
            map.invalidateSize();
            updateMapViewportDimensions();
        }
        resizeThrottled = false;
    }, RESIZE_THROTTLE);
}

// Generic throttle function
function throttle(func, limit) {
    let lastFunc;
    let lastRan;
    return function() {
        const context = this;
        const args = arguments;
        if (!lastRan) {
            func.apply(context, args);
            lastRan = Date.now();
        } else {
            clearTimeout(lastFunc);
            lastFunc = setTimeout(function() {
                if ((Date.now() - lastRan) >= limit) {
                    func.apply(context, args);
                    lastRan = Date.now();
                }
            }, limit - (Date.now() - lastRan));
        }
    };
}

// Handle visibility change
function handleVisibilityChange() {
    if (document.hidden) {
        // App going to background
        lastHiddenTime = Date.now();
        
        // Pause any animations or timers
        if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
        }
    } else {
        // App coming to foreground
        const hiddenDuration = Date.now() - lastHiddenTime;
        
        // If hidden for significant time, reset view
        if (hiddenDuration > BACKGROUND_THRESHOLD && followUser && userMarker) {
            resetMapView(lastPosition || { lat: userMarker.getLatLng().lat, lng: userMarker.getLatLng().lng });
        }
        
        // Restart animation loop
        if (!animationFrameId) {
            startAnimationLoop();
        }
        
        // Reset inactivity timer
        resetInactivityTimer();
    }
}

// Initialize network status monitoring
function initNetworkMonitoring() {
    // Check network status periodically
    setInterval(() => {
        const now = Date.now();
        if (now - lastNetworkStatusUpdate < NETWORK_STATUS_UPDATE_THROTTLE) return;
        
        lastNetworkStatusUpdate = now;
        
        // Update online status
        const wasOnline = isOnline;
        isOnline = navigator.onLine;
        
        // If status changed, handle it
        if (wasOnline !== isOnline) {
            if (isOnline) {
                console.log('Network connection restored');
                showErrorMessage('Internet connection restored');
                
                // Reload locations if needed
                if (gameLocations.length === 0) {
                    startHunt();
                }
            } else {
                console.log('Network connection lost');
                showErrorMessage('No internet connection. Some features may not work properly.');
            }
        }
    }, NETWORK_CHECK_INTERVAL);
}

// Initialize intersection observer for visibility detection
function initIntersectionObserver() {
    if ('IntersectionObserver' in window) {
        intersectionObserver = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    visibleElements.add(entry.target);
                } else {
                    visibleElements.delete(entry.target);
                }
            });
        }, {
            root: null,
            rootMargin: '0px',
            threshold: 0.1
        });
        
        // Observe important elements
        const elementsToObserve = [
            document.getElementById('map'),
            document.getElementById('distanceBox'),
            document.getElementById('accuracyIndicator')
        ];
        
        elementsToObserve.forEach(el => {
            if (el) intersectionObserver.observe(el);
        });
    }
}

// Initialize idle callback for background tasks
function initIdleCallback() {
    if ('requestIdleCallback' in window) {
        scheduleIdleCallback();
    }
}

function scheduleIdleCallback() {
    if (idleCallbackHandle) {
        cancelIdleCallback(idleCallbackHandle);
    }
    
    idleCallbackHandle = requestIdleCallback((deadline) => {
        while (deadline.timeRemaining() > 0 && pendingIdleTasks.length > 0) {
            const task = pendingIdleTasks.shift();
            try {
                task();
            } catch (error) {
                console.error('Error in idle task:', error);
            }
        }
        
        // Reschedule if we have more tasks
        if (pendingIdleTasks.length > 0) {
            scheduleIdleCallback();
        } else {
            idleCallbackHandle = null;
        }
    }, { timeout: 1000 });
}

// Add a task to be executed during idle time
function addIdleTask(task) {
    pendingIdleTasks.push(task);
    
    if (!idleCallbackHandle && 'requestIdleCallback' in window) {
        scheduleIdleCallback();
    } else if (!('requestIdleCallback' in window)) {
        // Fallback for browsers without requestIdleCallback
        setTimeout(() => {
            const task = pendingIdleTasks.shift();
            if (task) {
                try {
                    task();
                } catch (error) {
                    console.error('Error in idle task fallback:', error);
                }
            }
        }, 200);
    }
}

// Check device capabilities
function checkDeviceCapabilities() {
    // Check device memory
    if (navigator.deviceMemory) {
        deviceMemory = navigator.deviceMemory;
    }
    
    // Check CPU cores
    if (navigator.hardwareConcurrency) {
        hardwareConcurrency = navigator.hardwareConcurrency;
    }
    
    // Determine device class
    isLowEndDevice = deviceMemory < 4 || hardwareConcurrency < 4;
    isHighEndDevice = deviceMemory >= 8 && hardwareConcurrency >= 8;
    
    // Check battery API
    if ('getBattery' in navigator) {
        hasBatteryAPI = true;
        navigator.getBattery().then(battery => {
            batteryLevel = battery.level;
            lowPowerMode = battery.charging ? false : batteryLevel < 0.2;
            
            // Listen for battery changes
            battery.addEventListener('levelchange', () => {
                batteryLevel = battery.level;
                lowPowerMode = battery.charging ? false : batteryLevel < 0.2;
                adjustPerformanceSettings();
            });
            
            battery.addEventListener('chargingchange', () => {
                lowPowerMode = battery.charging ? false : batteryLevel < 0.2;
                adjustPerformanceSettings();
            });
        });
    }
    
    // Set initial performance mode based on device capabilities
    if (isLowEndDevice) {
        adaptivePerformanceMode = 'low';
        targetFps = 30;
    } else if (isHighEndDevice) {
        adaptivePerformanceMode = 'high';
        targetFps = 60;
    } else {
        adaptivePerformanceMode = 'balanced';
        targetFps = 45;
    }
    
    console.log(`Device capabilities: Memory: ${deviceMemory}GB, Cores: ${hardwareConcurrency}, Mode: ${adaptivePerformanceMode}`);
}

// Reset inactivity timer
function resetInactivityTimer() {
    // Clear existing timer
    if (inactivityTimer) {
        clearTimeout(inactivityTimer);
    }
    
    // Set new timer
    inactivityTimer = setTimeout(() => {
        // If user is inactive and not following, re-enable follow mode
        if (!userIsInteracting && !followUser && userMarker) {
            followUser = true;
            resetMapView(lastPosition || { lat: userMarker.getLatLng().lat, lng: userMarker.getLatLng().lng });
        }
    }, INACTIVITY_TIMEOUT);
}

// Show loading message
function showLoadingMessage() {
    domUpdateManager.schedule('loadingMessage', () => {
        const loadingElement = document.getElementById('loadingMessage');
        if (loadingElement) {
            loadingElement.style.display = 'flex';
        } else {
            // Create loading message if it doesn't exist
            const loadingDiv = document.createElement('div');
            loadingDiv.id = 'loadingMessage';
            loadingDiv.className = 'loading-message';
            loadingDiv.innerHTML = '<div class="spinner"></div><p>Loading map...</p>';
            document.body.appendChild(loadingDiv);
        }
    }, 10); // High priority
}

// Hide loading message
function hideLoadingMessage() {
    domUpdateManager.schedule('loadingMessage', () => {
        const loadingElement = document.getElementById('loadingMessage');
        if (loadingElement) {
            loadingElement.style.display = 'none';
        }
    }, 10); // High priority
}

// Show error message
function showErrorMessage(message, duration = 3000) {
    domUpdateManager.schedule('errorMessage', () => {
        let errorElement = document.getElementById('errorMessage');
        
        if (!errorElement) {
            // Create error message element if it doesn't exist
            errorElement = document.createElement('div');
            errorElement.id = 'errorMessage';
            errorElement.className = 'error-message';
            document.body.appendChild(errorElement);
        }
        
        // Update message
        errorElement.textContent = message;
        errorElement.style.display = 'block';
        
        // Hide after duration
        setTimeout(() => {
            if (errorElement) {
                errorElement.style.display = 'none';
            }
        }, duration);
    }, 10); // High priority
}

// Start location hunt
function startHunt() {
    // Fetch locations from API
    fetch('/api/locations')
        .then(response => {
            if (!response.ok) {
                throw new Error('Network response was not ok');
            }
            return response.json();
        })
        .then(data => {
            // Process locations
            gameLocations = data.locations || [];
            
            // Add markers to map
            addLocationMarkers();
            
            // Preload location images and audio
            preloadLocationAssets();
            
            console.log(`Loaded ${gameLocations.length} locations`);
        })
        .catch(error => {
            console.error('Error fetching locations:', error);
            showErrorMessage('Error loading locations. Please try again later.');
            
            // Use fallback locations if available
            if (typeof fallbackLocations !== 'undefined' && fallbackLocations.length > 0) {
                gameLocations = fallbackLocations;
                addLocationMarkers();
                preloadLocationAssets();
                console.log(`Using ${gameLocations.length} fallback locations`);
            }
        });
}

// Add location markers to map
function addLocationMarkers() {
    // Clear existing markers
    markerClusterGroup.clearLayers();
    
    // Add markers for each location
    gameLocations.forEach(location => {
        if (!location || typeof location.lat !== 'number' || typeof location.lng !== 'number') return;
        
        // Create custom icon
        const locationIcon = L.divIcon({
            className: 'location-marker',
            html: `<div class="location-marker-icon ${location.visited ? 'visited' : ''}"></div>`,
            iconSize: [30, 30],
            iconAnchor: [15, 15]
        });
        
        // Create marker
        const marker = L.marker([location.lat, location.lng], {
            icon: locationIcon,
            title: location.name
        });
        
        // Add click handler
        marker.on('click', () => {
            // Check if user is close enough to interact
            if (userMarker) {
                const userLatLng = userMarker.getLatLng();
                const userPos = { lat: userLatLng.lat, lng: userLatLng.lng };
                const locationPos = { lat: location.lat, lng: location.lng };
                
                const distance = calculateDistance(userPos, locationPos);
                const distanceFeet = Math.round(distance * 3.28084);
                
                if (distanceFeet <= DISTANCE_THRESHOLD) {
                    // User is close enough, open location page
                    openLocationPage(location);
                } else {
                    // User is too far, show message
                    showErrorMessage(`You need to be within ${DISTANCE_THRESHOLD} feet of this location to interact with it.`);
                }
            }
        });
        
        // Add marker to cluster group
        markerClusterGroup.addLayer(marker);
    });
}

// Preload location assets
function preloadLocationAssets() {
    // Clear existing preload queues
    imagePreloadQueue = [];
    audioPreloadQueue = [];
    
    // Add assets to preload queues
    gameLocations.forEach(location => {
        if (location.imageUrl && !preloadedImages.has(location.imageUrl)) {
            imagePreloadQueue.push(location.imageUrl);
        }
        
        if (location.audioUrl && !preloadedAudio.has(location.audioUrl)) {
            audioPreloadQueue.push(location.audioUrl);
        }
    });
    
    // Start preloading
    if (imagePreloadQueue.length > 0 || audioPreloadQueue.length > 0) {
        preloadBatchSize = isLowEndDevice ? 1 : (isHighEndDevice ? 3 : 2);
        startPreloading();
    }
}

// Start preloading assets
function startPreloading() {
    if (isPreloading) return;
    
    isPreloading = true;
    preloadStartTime = Date.now();
    
    // Preload next batch
    preloadNextBatch();
}

// Preload next batch of assets
function preloadNextBatch() {
    // Check if we're done
    if (imagePreloadQueue.length === 0 && audioPreloadQueue.length === 0) {
        isPreloading = false;
        console.log(`Preloading complete in ${(Date.now() - preloadStartTime) / 1000}s`);
        return;
    }
    
    // Preload images first
    const imagesToPreload = Math.min(preloadBatchSize, imagePreloadQueue.length);
    for (let i = 0; i < imagesToPreload; i++) {
        const imageUrl = imagePreloadQueue.shift();
        preloadImage(imageUrl);
    }
    
    // Then preload audio
    const audioToPreload = Math.min(preloadBatchSize, audioPreloadQueue.length);
    for (let i = 0; i < audioToPreload; i++) {
        const audioUrl = audioPreloadQueue.shift();
        preloadAudio(audioUrl);
    }
    
    // Schedule next batch
    setTimeout(preloadNextBatch, PRELOAD_BATCH_DELAY);
}

// Preload image
function preloadImage(url) {
    if (!url || preloadedImages.has(url)) return;
    
    const img = new Image();
    img.onload = () => {
        preloadedImages.set(url, img);
    };
    img.onerror = () => {
        console.warn(`Failed to preload image: ${url}`);
    };
    img.src = url;
}

// Preload audio
function preloadAudio(url) {
    if (!url || preloadedAudio.has(url)) return;
    
    const audio = new Audio();
    audio.oncanplaythrough = () => {
        preloadedAudio.set(url, audio);
    };
    audio.onerror = () => {
        console.warn(`Failed to preload audio: ${url}`);
    };
    audio.src = url;
    audio.load();
}

// Open location page
function openLocationPage(location) {
    // Check if location is on cooldown
    const now = Date.now();
    const cooldownTime = locationCooldowns[location.id] || 0;
    
    if (now < cooldownTime) {
        const remainingSeconds = Math.ceil((cooldownTime - now) / 1000);
        showErrorMessage(`This location is on cooldown. Please wait ${remainingSeconds} seconds.`);
        return;
    }
    
    // Set cooldown for this location
    locationCooldowns[location.id] = now + (location.cooldown || 60000); // Default 1 minute cooldown
    
    // Mark location as visited
    if (!location.visited) {
        location.visited = true;
        visitedLocations.push(location.id);
        lastVisitedLocationId = location.id;
        
        // Update marker to show visited state
        updateLocationMarker(location);
    }
    
    // Show location page
    showLocationPage(location);
}

// Update location marker to show visited state
function updateLocationMarker(location) {
    markerClusterGroup.eachLayer(marker => {
        const markerLatLng = marker.getLatLng();
        
        if (markerLatLng.lat === location.lat && markerLatLng.lng === location.lng) {
            // Update icon
            const icon = marker.getIcon();
            const iconHtml = `<div class="location-marker-icon visited"></div>`;
            
            const newIcon = L.divIcon({
                className: 'location-marker',
                html: iconHtml,
                iconSize: [30, 30],
                iconAnchor: [15, 15]
            });
            
            marker.setIcon(newIcon);
        }
    });
}

// Show location page
function showLocationPage(location) {
    // Create location page if it doesn't exist
    let locationPage = document.getElementById('locationPage');
    
    if (!locationPage) {
        locationPage = document.createElement('div');
        locationPage.id = 'locationPage';
        locationPage.className = 'location-page';
        document.body.appendChild(locationPage);
    }
    
    // Update location page content
    domUpdateManager.schedule('locationPage', () => {
        locationPage.innerHTML = `
            <div class="location-header">
                <h2>${location.name}</h2>
                <button class="close-button" onclick="closeLocationPage()">×</button>
            </div>
            <div class="location-content">
                ${location.imageUrl ? `<img src="${location.imageUrl}" alt="${location.name}" class="location-image">` : ''}
                <p>${location.description || 'No description available.'}</p>
                ${location.audioUrl ? `<div class="audio-player">
                    <button class="play-button" onclick="playLocationAudio('${location.audioUrl}')">Play Audio</button>
                </div>` : ''}
            </div>
        `;
        
        // Show the page
        locationPage.style.display = 'block';
        
        // Set flag to indicate location page is visible
        isLocationHuntVisible = true;
        
        // Play audio if available
        if (location.audioUrl) {
            playLocationAudio(location.audioUrl);
        }
    }, 10); // High priority
}

// Close location page
function closeLocationPage() {
    domUpdateManager.schedule('locationPage', () => {
        const locationPage = document.getElementById('locationPage');
        if (locationPage) {
            locationPage.style.display = 'none';
        }
        
        // Set flag to indicate location page is hidden
        isLocationHuntVisible = false;
        
        // Stop audio if playing
        stopLocationAudio();
        
        // Set flag to indicate returning from exhibit
        isReturningFromExhibit = true;
        
        // Reset map view after a short delay
        setTimeout(() => {
            if (userMarker && followUser) {
                resetMapView(lastPosition || { lat: userMarker.getLatLng().lat, lng: userMarker.getLatLng().lng });
            }
            isReturningFromExhibit = false;
        }, 500);
    }, 10); // High priority
}

// Play location audio
function playLocationAudio(url) {
    // Stop any currently playing audio
    stopLocationAudio();
    
    // Get preloaded audio if available
    let audio = preloadedAudio.get(url);
    
    if (!audio) {
        // Create new audio element if not preloaded
        audio = new Audio(url);
    }
    
    // Set as current audio
    currentAudio = audio;
    
    // Play audio
    audio.play().catch(error => {
        console.error('Error playing audio:', error);
        showErrorMessage('Error playing audio. Please try again.');
    });
    
    // Update play button
    domUpdateManager.schedule('audioPlayer', () => {
        const playButton = document.querySelector('.play-button');
        if (playButton) {
            playButton.textContent = 'Pause Audio';
            playButton.onclick = () => pauseLocationAudio(url);
        }
    }, 5); // Medium priority
}

// Pause location audio
function pauseLocationAudio(url) {
    if (currentAudio) {
        currentAudio.pause();
        
        // Update play button
        domUpdateManager.schedule('audioPlayer', () => {
            const playButton = document.querySelector('.play-button');
            if (playButton) {
                playButton.textContent = 'Resume Audio';
                playButton.onclick = () => resumeLocationAudio(url);
            }
        }, 5); // Medium priority
    }
}

// Resume location audio
function resumeLocationAudio(url) {
    if (currentAudio) {
        currentAudio.play().catch(error => {
            console.error('Error resuming audio:', error);
            showErrorMessage('Error resuming audio. Please try again.');
        });
        
        // Update play button
        domUpdateManager.schedule('audioPlayer', () => {
            const playButton = document.querySelector('.play-button');
            if (playButton) {
                playButton.textContent = 'Pause Audio';
                playButton.onclick = () => pauseLocationAudio(url);
            }
        }, 5); // Medium priority
    }
}

// Stop location audio
function stopLocationAudio() {
    if (currentAudio) {
        currentAudio.pause();
        currentAudio.currentTime = 0;
        currentAudio = null;
    }
}

// Clean up resources when component unmounts
function cleanup() {
    // Cancel animation frame
    if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
    }
    
    // Clear timeouts
    if (stationaryCheckTimeout) {
        clearTimeout(stationaryCheckTimeout);
        stationaryCheckTimeout = null;
    }
    
    if (stationaryLockTimeout) {
        clearTimeout(stationaryLockTimeout);
        stationaryLockTimeout = null;
    }
    
    if (idleCallbackHandle && 'cancelIdleCallback' in window) {
        cancelIdleCallback(idleCallbackHandle);
        idleCallbackHandle = null;
    }
    
    // Stop geolocation watch
    if (locationWatchId) {
        navigator.geolocation.clearWatch(locationWatchId);
        locationWatchId = null;
    }
    
    // Stop geolocation sensor
    if (geolocationSensor) {
        geolocationSensor.stop();
        geolocationSensor = null;
    }
    
    // Terminate Web Worker
    if (positionWorker) {
        positionWorker.terminate();
        positionWorker = null;
    }
    
    // Disconnect intersection observer
    if (intersectionObserver) {
        intersectionObserver.disconnect();
        intersectionObserver = null;
    }
    
    // Remove event listeners
    for (const [event, handler] of eventListeners.entries()) {
        document.removeEventListener(event, handler);
    }
    eventListeners.clear();
    
    // Clear DOM update manager
    domUpdateManager.clear();
    
    // Clear pending tasks
    pendingIdleTasks = [];
    pendingWorkerTasks = [];
    pendingDistanceCalculations.clear();
    
    // Clear map if it exists
    if (map) {
        map.remove();
        map = null;
    }
}

// Initialize the map when the page loads
window.addEventListener('load', () => {
    try {
        initMap();
        
        // Check if the browser supports the required features
        if (!navigator.geolocation) {
            showErrorMessage("Your browser doesn't support geolocation. Please use a modern browser.");
        }
        
        // Check network status
        if (!navigator.onLine) {
            showErrorMessage("No internet connection. Some features may not work properly.");
        }
        
        // Clean up resources when page unloads
        window.addEventListener('beforeunload', cleanup, PASSIVE_EVENT_OPTIONS);
        
    } catch (error) {
        console.error("Error initializing app:", error);
        showErrorMessage("Error initializing the app. Please reload the page.");
    }
});
    </script>
</body>
</html>
