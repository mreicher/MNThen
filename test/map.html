<!DOCTYPE html>
<html lang="en">
<head> 
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Minnesota Then | A Museum Without Walls</title>
    <link rel="shortcut icon" type="image/x-icon" href="https://www.mnthen.com/images/mnthenfav.ico">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css">
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css" />
    <link rel="stylesheet" href="https://www.mnthen.com/css/mainmap.css">
    <link rel="stylesheet" href="https://www.mnthen.com/css/mnthen_main_map2.css">

    <style>
        .at-location {
            border: 2px solid red !important;
            box-shadow: 0 0 8px rgba(255, 0, 0, 0.5);
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
        }
        
        /* User marker styles */
        .user-marker-icon {
            width: 16px;
            height: 16px;
            background-color: #ff3b30;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            position: relative;
        }
        
        .user-marker-direction {
            position: absolute;
            top: -4px;
            left: 50%;
            margin-left: -2px;
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-bottom: 12px solid #ff3b30;
            transform-origin: center bottom;
            z-index: -1;
        }
        
        .user-marker-icon.pulsing {
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(1.2);
                opacity: 0.8;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }
        
        /* Preloader styles */
        #preloader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 0.5s ease;
        }
        
        .preloader-content {
            text-align: center;
            padding: 20px;
            max-width: 80%;
        }
        
        .preloader-content .logo {
            width: 120px;
            height: auto;
            margin-bottom: 20px;
        }
        
        .progress-container {
            width: 100%;
            height: 8px;
            background-color: #f0f0f0;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 20px;
        }
        
        .progress-bar {
            height: 100%;
            background-color: #0f2bab;
            width: 0%;
            transition: width 0.3s ease;
        }
        
        /* Location hunt container */
        .lochunt-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: white;
            z-index: 1000;
            display: none;
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        
        .lochunt-container.visible {
            opacity: 1;
        }
        
        /* Additional info container */
        .additional-info-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: white;
            z-index: 1001;
            display: none;
            padding: 20px;
            text-align: center;
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        
        .additional-info-container.visible {
            opacity: 1;
        }
        
        /* Navigation tips */
        .navigation-tips {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            max-width: 80%;
            display: none;
        }
        
        .close-button {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
        }
        
        /* Map buttons */
        .map-buttons {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 900;
        }
        
        .map-button {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background-color: white;
            color: #0f2bab;
            border: none;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .map-button:active {
            transform: scale(0.95);
        }
        
        /* Distance box */
        #distanceBox {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: white;
            padding: 10px 15px;
            border-radius: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            z-index: 900;
            font-weight: 500;
            font-size: 14px;
            transition: all 0.3s ease;
        }
        
        /* Stabilizing modal */
        .stabilizing-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            text-align: center;
            padding: 20px;
        }
        
        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(0, 0, 255, 0.1);
            border-radius: 50%;
            border-top-color: #0f2bab;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Custom marker styles */
        .custom-pin-icon {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .pin-head {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: #0f2bab;
            border: 2px solid white;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }
        
        /* Custom popup styles */
        .custom-popup {
            max-width: 300px;
        }
        
        .popup-content {
            padding: 10px;
        }
        
        .location-image {
            width: 100%;
            height: 150px;
            object-fit: cover;
            border-radius: 8px;
            margin-bottom: 10px;
        }
        
        .location-name {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 10px;
        }
        
        .popup-buttons {
            display: flex;
            gap: 10px;
        }
        
        .button {
            flex: 1;
            padding: 8px;
            border: none;
            border-radius: 4px;
            background-color: #0f2bab;
            color: white;
            font-size: 14px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        
        .button:hover {
            background-color: #0a1f80;
        }
    </style>
</head>
<body>
<!-- Preloader -->
<div id="preloader">
    <div class="preloader-content">
        <img class="logo" src="https://www.mnthen.com/images/logo.webp" alt="Minnesota Then Logo">
        <h1>Minnesota Then</h1>
        <h2>Every step tells a story.</h2>
        <p>Loading the Museum Without Walls</p>
        <div class="progress-container">
            <div class="progress-bar" id="preloaderProgress"></div>
        </div>
    </div>
</div>

    <div id="map"></div>
    <div id="distanceBox">Initializing...</div>

    <div class="lochunt-container">
        <img id="locationImage" src="/placeholder.svg" alt="Location Image">
            <div class="lochunt-content">
                <div class="lochunt-info">
                    <h2 id="locationTitle" class="mb-2 text-primary"></h2>
                        <p id="locationCity" class="text-muted mb-1"></p>
                        <p id="locationCreator" class="text-muted mb-3"></p>
                </div>
            <div class="audio-player">
                <div class="audio-progress">
                    <div class="progress">
                        <div id="progressBar" class="progress-bar" role="progressbar" style="width: 0%"></div>
                    </div>
                </div>
                <div class="audio-time">
                    <span id="currentTime">0:00</span>
                    <span id="duration">0:00</span>
                </div>
                <div class="audio-controls">
                    <button id="rewindBtn" class="audio-button"><i class="fas fa-backward"></i></button>
                    <button id="playPauseBtn" class="audio-button"><i class="fas fa-play"></i></button>
                    <button id="forwardBtn" class="audio-button"><i class="fas fa-forward"></i></button>
                </div>
                <audio id="locationAudio" src="/placeholder.svg"></audio>
            </div>
        </div>
    </div>
    
    <div class="additional-info-container">
       <h3 class="mb-3 text-primary text-center">Did You Know?</h3>
       <p id="additionalInfo" class="mb-3 fs-6"></p>
       <div class="d-flex justify-content-center">
           <button id="continueButton" class="btn btn-primary">Continue</button>
       </div>
    </div>
    
    <div class="map-buttons">
        <button id="recenterButton" class="map-button"><i class="fas fa-crosshairs"></i></button>
        <button id="returnButton" class="map-button"><i class="fas fa-sign-out-alt"></i></button>
        <button id="tipsButton" class="map-button"><i class="fas fa-question-circle"></i></button>
    </div>

    <div class="navigation-tips">
        <button class="close-button">&times;</button>
        <h3>Navigation Tips</h3>
        <ul>
            <li>Use the map to navigate to the marked locations.</li>
            <li>Tap the recenter button to focus on your current position.</li>
            <li>The distance box shows how far you are from the closest location.</li>
            <li>When you're within 20 feet of a location, you'll be able to interact with it.</li>
            <li>Listen to the audio information for each location.</li>
            <li>After the audio, you'll see additional information about the location.</li>
        </ul>
    </div>

    <div id="summaryModal" class="modal" style="display: none;">
        <div class="modal-content">
            <p id="summaryContent"></p>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"></script>
    
    <script src="/locations_test.js?v=1.0.4"></script>

    <script>
        // Global variables
let map, userMarker, markerClusterGroup;
let currentLocationIndex = 0;
const visitedLocations = [];
let gameLocations = [];
let inactivityTimer;
let isLocationHuntVisible = false;
let lastPosition = null;
let positionBuffer = [];
const MAX_BUFFER_SIZE = 30; // Buffer size for smoother tracking
const DISTANCE_THRESHOLD = 20; // 20 feet to trigger location interaction
const PROXIMITY_THRESHOLD = 55; // 55 feet threshold for zoom changes
let velocity = { lat: 0, lng: 0 };
let isMapInteracting = false;
let followUser = true;
let locationCooldowns = {};
let userIsInteracting = false;
const preloadedImages = new Map(); // Map to store preloaded images
const preloadedAudio = new Map(); // Map to store preloaded audio
let currentSpeed = 0; // Current speed in meters per second
let lastZoomLevel = 17; // Default zoom level
let stationaryPositionHistory = []; // Array to store stationary positions for averaging
let deviceOrientation = null; // Store device orientation data
let deviceMotion = null; // Store device motion data
let orientationPermissionGranted = false;
let geolocationSensor = null; // Store GeolocationSensor instance
let isReturningFromExhibit = false; // Flag to track if returning from exhibit
let isWithinProximity = false; // Flag to track if user is within proximity of a location
let proximityZoomActive = false; // Flag to track if proximity zoom is active
const DEFAULT_ZOOM_LEVEL = 17; // Default zoom level
const PROXIMITY_ZOOM_LEVEL = 18; // Zoom level when in proximity to a location

// Enhanced constants for better stabilization
const MICRO_MOVEMENT_THRESHOLD = 0.3; // Meters - threshold for detecting micro-movements
const STATIONARY_ACCURACY_MULTIPLIER = 1.2; // Looser accuracy bounds to prevent false movement detection
const MAX_ACCEPTABLE_ACCURACY = 25; // meters - more lenient accuracy requirement
const STATIONARY_THRESHOLD = 2; // Number of consecutive stationary positions to consider user as stationary
const STATIONARY_TIME_THRESHOLD = 3000; // ms - time to consider user stationary
const STATIONARY_CHECK_INTERVAL = 1000; // ms - interval to check if still stationary
const VELOCITY_DECAY = 0.92; // Higher value for smoother velocity transitions
const MIN_DISTANCE_THRESHOLD = 1.0; // meters - minimum distance to consider movement
const EXTENDED_DISTANCE_THRESHOLD = 80; // meters - distance to consider a significant position change
const UPDATE_INTERVAL = 50; // ms - more frequent updates for smoother movement
const STATIONARY_POSITION_HISTORY_SIZE = 15; // Number of positions to keep for stationary averaging
const STATIONARY_POSITION_WEIGHT_DECAY = 0.9; // Weight decay for older positions in stationary average
const SUDDEN_MOVEMENT_THRESHOLD = 0.8; // meters - threshold for detecting sudden movements
const POSITION_JUMP_THRESHOLD = 2.0; // meters - threshold for detecting position jumps

// Background handling constants
const BACKGROUND_THRESHOLD = 15000; // ms - time to consider app was in background
const INACTIVITY_TIMEOUT = 20000; // ms - time to consider user inactive

// Kalman filter parameters - optimized for better movement tracking
const KALMAN_PROCESS_NOISE = 0.00001;
const KALMAN_MEASUREMENT_NOISE_BASE = 0.1;
const KALMAN_STATIONARY_NOISE = 0.000001;

// Animation parameters
const ANIMATION_DURATION = 200; // ms - reduced duration of position animation for more responsive transitions
const HEADING_SMOOTHING = 0.85; // Reduced heading smoothing factor for more responsive direction changes

// Zoom level parameters
const MAX_ZOOM_LEVEL = 17; // Maximum zoom level (stationary)
const MIN_ZOOM_LEVEL = 13; // Minimum zoom level (high speed)
const WALKING_ZOOM_LEVEL = 17; // Zoom level for walking speed
const WALKING_SPEED_THRESHOLD = 1.5; // m/s - threshold for walking speed
const RUNNING_SPEED_THRESHOLD = 4.0; // m/s - threshold for running speed
const DRIVING_SPEED_THRESHOLD = 10.0; // m/s - threshold for driving speed
const ZOOM_TRANSITION_DURATION = 0.5; // seconds - reduced duration of zoom transition for more responsive zooming

// Motion detection parameters
const MOTION_THRESHOLD = 0.8; // Reduced threshold for detecting significant motion
const MOTION_SAMPLE_SIZE = 15; // Increased number of motion samples to keep
const MOTION_CHECK_INTERVAL = 200; // ms - reduced interval to check motion for more responsive detection

// Edge recenter parameters - optimized for better edge recentering
const EDGE_THRESHOLD_PERCENTAGE = 0.25; // Percentage of viewport to trigger recenter
const CRITICAL_EDGE_THRESHOLD = 0.125; // Critical threshold for emergency recenter
const RECENTER_COOLDOWN = 1500; // ms - minimum time between recenters

// Speed accuracy parameters
const SPEED_ACCURACY_THRESHOLD = 5.0; // 5 m/s accuracy is reasonable for most GPS systems

// State variables
let lastUpdateTime = null;
let lastVelocity = { lat: 0, lng: 0 };
let isStationary = false;
let stationaryStartTime = null;
let stationaryCheckTimeout = null;
let lastUpdateTimestamp = null;
let lastHiddenTime = 0;
let lastKnownPosition = null;
let lastVisitedLocationId = null;
let stationaryCount = 0;
let lastSmoothedPosition = null;
let lastRecenterTime = Date.now();
let retryCount = 0;
const stationaryBuffer = [];
let isStabilizing = true; // Flag to track initial stabilization
let lastStationaryPosition = null; // Last stable position when stationary
const motionSamples = []; // Array to store motion samples
let animationFrameId = null; // Store requestAnimationFrame ID
let renderTimestamp = null; // Last render timestamp
const positionUpdateQueue = []; // Queue for position updates to be processed
let lastHeadingValue = null; // Last heading value
const headingBuffer = []; // Buffer for heading values
let isFirstPositionUpdate = true; // Flag for first position update
let lastRenderPosition = null; // Last rendered position

// Position interpolator for smooth transitions
const positionInterpolator = {
  currentAnimation: null,
  startTime: null,
  from: null,
  to: null,
  duration: 0,
  
  start: function(from, to, duration) {
    // Cancel any existing animation
    if (this.currentAnimation) {
      cancelAnimationFrame(this.currentAnimation);
    }
    
    // Store animation parameters
    this.startTime = performance.now();
    this.from = from;
    this.to = to;
    this.duration = duration;
    
    // Start animation
    this.update();
  },
  
  update: function() {
    if (!this.startTime) return;
    
    const currentTime = performance.now();
    const elapsed = currentTime - this.startTime;
    const progress = Math.min(elapsed / this.duration, 1);
    
    // Use easing for smoother motion (ease-out)
    const eased = 1 - Math.pow(1 - progress, 3);
    
    // Interpolate between positions
    const currentPosition = {
      lat: this.from.lat + (this.to.lat - this.from.lat) * eased,
      lng: this.from.lng + (this.to.lng - this.from.lng) * eased
    };
    
    // Update marker position
    updateUserMarkerPosition(currentPosition);
    lastRenderPosition = currentPosition;
    
    // Continue animation if not complete
    if (progress < 1) {
      this.currentAnimation = requestAnimationFrame(() => this.update());
    } else {
      this.currentAnimation = null;
      this.startTime = null;
    }
  },
  
  cancel: function() {
    if (this.currentAnimation) {
      cancelAnimationFrame(this.currentAnimation);
      this.currentAnimation = null;
      this.startTime = null;
    }
  },
  
  isInterpolating: function() {
    return this.currentAnimation !== null;
  }
};
      
let mapViewportWidth = 0; // Store map viewport width
let mapViewportHeight = 0; // Store map viewport height
let lastMapCenter = null; // Last map center position
let lastMapZoom = null; // Last map zoom level
let edgeRecenterInProgress = false; // Flag to track edge recentering
const pendingDomUpdates = new Map(); // Map to store pending DOM updates
let usingGeolocationSensorAPI = false; // Flag to track which geolocation API is being used
let positionHistory = []; // Array to store recent position history for jump detection
let suddenMovementCount = 0; // Counter for consecutive sudden movements
let isJumpDetected = false; // Flag to track if a position jump is detected
let stationaryPositionLocked = false; // Flag to indicate if stationary position is locked
let stationaryPositionLockTime = 0; // Time when stationary position was locked
let lastValidPosition = null; // Last valid position before a jump
let stationaryLockTimeout = null; // Timeout for locking stationary position
let lastZoomChangeTime = 0; // Last time zoom was changed due to proximity

// Utility function to calculate distance between two coordinates
function calculateDistance(pos1, pos2) {
  if (
    !pos1 ||
    !pos2 ||
    typeof pos1.lat !== "number" ||
    typeof pos1.lng !== "number" ||
    typeof pos2.lat !== "number" ||
    typeof pos2.lng !== "number"
  ) {
    return Number.POSITIVE_INFINITY;
  }

  // Haversine formula for more accurate distance calculation
  const R = 6371000; // Earth radius in meters
  const lat1 = (pos1.lat * Math.PI) / 180;
  const lat2 = (pos2.lat * Math.PI) / 180;
  const deltaLat = ((pos2.lat - pos1.lat) * Math.PI) / 180;
  const deltaLng = ((pos2.lng - pos1.lng) * Math.PI) / 180;

  const a =
    Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) +
    Math.cos(lat1) * Math.cos(lat2) * Math.sin(deltaLng / 2) * Math.sin(deltaLng / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

  return R * c;
}

// Enhanced Kalman Filter implementation
class KalmanFilter {
  constructor() {
    // State vector [x, y, vx, vy]
    this.x = 0;
    this.y = 0;
    this.vx = 0;
    this.vy = 0;

    // Error covariance matrix
    this.P = [
      [100, 0, 0, 0], // Initial high uncertainty
      [0, 100, 0, 0],
      [0, 0, 10, 0],
      [0, 0, 0, 10],
    ];

    // Process noise
    this.Q = KALMAN_PROCESS_NOISE;

    // Measurement noise (will be adjusted based on GPS accuracy)
    this.R = KALMAN_MEASUREMENT_NOISE_BASE;

    // Time delta
    this.dt = 1.0;

    // Initialized flag
    this.initialized = false;

    // Heading and accuracy tracking
    this.lastHeading = null;
    this.headingConfidence = 0;

    // Stationary mode flag
    this.stationaryMode = false;
    this.stationaryStartTime = 0;

    // Last timestamp
    this.lastTimestamp = null;

    // Adaptive noise parameters
    this.adaptiveNoiseMin = 0.0002;
    this.adaptiveNoiseMax = 0.002;
    this.adaptiveNoiseFactor = 1.0;

    // Position history for jitter detection
    this.positionHistory = [];
    this.maxPositionHistory = 10;
    this.jitterThreshold = 0.35; // meters
    this.jitterCount = 0;

    // Stationary lock
    this.stationaryLocked = false;
    this.stationaryPosition = null;

    // Heading smoothing
    this.headingSmoothingFactor = 0.8;
    this.headingBuffer = [];
    this.headingBufferSize = 7;

    // Velocity smoothing
    this.velocitySmoothingFactor = 0.8;
    this.velocityBuffer = [];
    this.velocityBufferSize = 7;

    // Accuracy-based adaptation
    this.accuracyBuffer = [];
    this.accuracyBufferSize = 7;
    this.lastAccuracy = Number.POSITIVE_INFINITY;
    this.isAccuracyImproving = false;

    // Motion-based adaptation
    this.motionDetected = false;
    this.motionConfidence = 0;

    // Adaptive parameters based on device capabilities
    this.deviceCapabilitiesSet = false;
    this.deviceSupportsHighAccuracy = true;
    this.deviceSupportsMotionSensors = true;
    this.deviceSupportsOrientationSensors = true;

    // Innovation tracking to detect filter divergence
    this.innovationBuffer = [];
    this.innovationBufferSize = 10;
    this.innovationThreshold = 3.0; // standard deviations

    // GNSS receiver type (GPS, GLONASS, Galileo, etc)
    this.receiverType = "GPS";

    // Environment type (urban, rural, indoor, etc)
    this.environmentType = "mixed";
  }

  // Set device capabilities
  setDeviceCapabilities(highAccuracy, motionSensors, orientationSensors) {
    this.deviceCapabilitiesSet = true;
    this.deviceSupportsHighAccuracy = highAccuracy;
    this.deviceSupportsMotionSensors = motionSensors;
    this.deviceSupportsOrientationSensors = orientationSensors;

    // Adjust parameters based on device capabilities
    if (!highAccuracy) {
      this.adaptiveNoiseMin *= 1.5;
      this.adaptiveNoiseMax *= 1.5;
      this.jitterThreshold *= 1.5;
    }

    if (!motionSensors) {
      this.adaptiveNoiseMin *= 1.2;
      this.adaptiveNoiseMax *= 1.2;
    }

    if (!orientationSensors) {
      this.headingSmoothingFactor = 0.9;
    }

    return this;
  }

  // Set the type of GNSS receiver
  setReceiverType(type) {
    this.receiverType = type;

    // Adjust parameters based on receiver type
    switch (type.toUpperCase()) {
      case "GPS_GLONASS":
      case "MULTI_CONSTELLATION":
        this.adaptiveNoiseMin *= 0.8;
        this.adaptiveNoiseMax *= 0.8;
        break;
      case "BASIC_GPS":
        this.adaptiveNoiseMin *= 1.2;
        this.adaptiveNoiseMax *= 1.2;
        break;
      case "HIGH_PRECISION":
        this.adaptiveNoiseMin *= 0.5;
        this.adaptiveNoiseMax *= 0.5;
        break;
    }

    return this;
  }

  // Set the type of environment
  setEnvironmentType(type) {
    this.environmentType = type;

    // Adjust parameters based on environment type
    switch (type.toLowerCase()) {
      case "urban":
        this.adaptiveNoiseMin *= 1.3;
        this.adaptiveNoiseMax *= 1.3;
        this.jitterThreshold *= 0.9;
        break;
      case "rural":
        this.adaptiveNoiseMin *= 0.8;
        this.adaptiveNoiseMax *= 0.8;
        this.jitterThreshold *= 1.2;
        break;
      case "indoor":
        this.adaptiveNoiseMin *= 1.5;
        this.adaptiveNoiseMax *= 1.5;
        this.jitterThreshold *= 0.7;
        break;
    }

    return this;
  }

  // Initialize the filter with first position
  reset(position) {
    if (!position || typeof position.lat !== "number" || typeof position.lng !== "number") {
      console.error("Invalid position for Kalman filter reset");
      return;
    }

    this.x = position.lng;
    this.y = position.lat;
    this.vx = 0;
    this.vy = 0;

    // Reset covariance matrix with high initial uncertainty
    this.P = [
      [100, 0, 0, 0],
      [0, 100, 0, 0],
      [0, 0, 10, 0],
      [0, 0, 0, 10],
    ];

    this.initialized = true;
    this.lastHeading = position.heading || null;
    this.headingConfidence = 0;
    this.stationaryMode = false;
    this.lastTimestamp = position.timestamp || Date.now();
    this.adaptiveNoiseFactor = 1.0;
    this.positionHistory = [];
    this.jitterCount = 0;
    this.stationaryLocked = false;
    this.stationaryPosition = null;
    this.headingBuffer = [];
    this.velocityBuffer = [];
    this.accuracyBuffer = [];
    this.lastAccuracy = position.accuracy || Number.POSITIVE_INFINITY;
    this.isAccuracyImproving = false;
    this.motionDetected = false;
    this.motionConfidence = 0;
    this.innovationBuffer = [];

    return this;
  }

  // Set stationary mode
  setStationaryMode(isStationary) {
    this.stationaryMode = isStationary;

    // When entering stationary mode, reduce velocity to zero
    if (isStationary) {
      this.vx = 0;
      this.vy = 0;
      this.stationaryStartTime = Date.now();

      // Reduce process noise for stationary mode
      this.Q = KALMAN_STATIONARY_NOISE;
      this.adaptiveNoiseFactor = 0.03;
    } else {
      // Reset to normal process noise when moving
      this.Q = KALMAN_PROCESS_NOISE;
      this.adaptiveNoiseFactor = 1.0;
      this.stationaryLocked = false;
      this.stationaryPosition = null;
    }

    return this;
  }

  // Lock stationary position
  lockStationaryPosition(position) {
    if (!this.stationaryMode) return this;

    this.stationaryLocked = true;
    this.stationaryPosition = position;
    console.log("Kalman filter: Stationary position locked");

    return this;
  }

  // Update accuracy buffer and check if accuracy is improving
  updateAccuracyBuffer(accuracy) {
    if (isNaN(accuracy) || accuracy <= 0) {
      accuracy = this.lastAccuracy || 20;
    }

    this.accuracyBuffer.push(accuracy);
    while (this.accuracyBuffer.length > this.accuracyBufferSize) {
      this.accuracyBuffer.shift();
    }

    if (this.accuracyBuffer.length >= 3) {
      const avgRecent =
        (this.accuracyBuffer[this.accuracyBuffer.length - 1] + this.accuracyBuffer[this.accuracyBuffer.length - 2]) / 2;
      const avgOlder =
        (this.accuracyBuffer[0] + (this.accuracyBuffer.length > 1 ? this.accuracyBuffer[1] : this.accuracyBuffer[0])) /
        2;

      this.isAccuracyImproving = avgRecent < avgOlder;
    }

    this.lastAccuracy = accuracy;

    return this;
  }

  // Track innovation to detect filter divergence
  updateInnovationBuffer(innovation) {
    this.innovationBuffer.push(innovation);
    while (this.innovationBuffer.length > this.innovationBufferSize) {
      this.innovationBuffer.shift();
    }

    if (this.innovationBuffer.length >= 5) {
      // Calculate mean and standard deviation of innovations
      const sum = this.innovationBuffer.reduce((acc, val) => acc + val, 0);
      const mean = sum / this.innovationBuffer.length;

      const sumSquaredDiff = this.innovationBuffer.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0);
      const stdDev = Math.sqrt(sumSquaredDiff / this.innovationBuffer.length);

      // If innovation is consistently large, the filter might be diverging
      const latestInnovation = this.innovationBuffer[this.innovationBuffer.length - 1];
      if (Math.abs(latestInnovation - mean) > this.innovationThreshold * stdDev) {
        // Increase uncertainty to force filter to trust measurements more
        for (let i = 0; i < 4; i++) {
          this.P[i][i] *= 2.0;
        }
      }
    }

    return this;
  }

  // Detect jitter in position updates
  detectJitter(newPosition) {
    if (this.positionHistory.length === 0) {
      this.positionHistory.push(newPosition);
      return false;
    }

    const lastPos = this.positionHistory[this.positionHistory.length - 1];
    const distance = calculateDistance(lastPos, newPosition);

    // Add to history
    this.positionHistory.push(newPosition);
    while (this.positionHistory.length > this.maxPositionHistory) {
      this.positionHistory.shift();
    }

    // Check for rapid back-and-forth movement (jitter)
    if (this.positionHistory.length >= 3 && this.stationaryMode) {
      const pos1 = this.positionHistory[this.positionHistory.length - 3];
      const pos2 = this.positionHistory[this.positionHistory.length - 2];
      const pos3 = this.positionHistory[this.positionHistory.length - 1];

      const dist1 = calculateDistance(pos1, pos2);
      const dist2 = calculateDistance(pos2, pos3);

      // If moving back and forth in small distances
      if (
        dist1 < this.jitterThreshold &&
        dist2 < this.jitterThreshold &&
        Math.sign(pos3.lat - pos2.lat) !== Math.sign(pos2.lat - pos1.lat) &&
        Math.sign(pos3.lng - pos2.lng) !== Math.sign(pos2.lng - pos1.lng)
      ) {
        this.jitterCount++;
        return this.jitterCount > 1;
      }
    }

    // Reset jitter count if no jitter detected
    if (distance > this.jitterThreshold) {
      this.jitterCount = 0;
    }

    return false;
  }

  // Smooth heading values
  smoothHeading(newHeading) {
    if (newHeading === null || newHeading === undefined || isNaN(newHeading)) {
      return this.lastHeading;
    }

    // Normalize to 0-360
    newHeading = ((newHeading % 360) + 360) % 360;

    // Add to heading buffer
    this.headingBuffer.push(newHeading);
    while (this.headingBuffer.length > this.headingBufferSize) {
      this.headingBuffer.shift();
    }

    if (this.headingBuffer.length < 2) {
      return newHeading;
    }

    // Use median filter to remove outliers
    if (this.headingBuffer.length >= 3) {
      const sortedHeadings = [...this.headingBuffer].sort((a, b) => a - b);
      const medianHeading = sortedHeadings[Math.floor(sortedHeadings.length / 2)];

      // If new heading is very different from median, it might be an outlier
      const headingDiff = Math.abs(((newHeading - medianHeading + 180) % 360) - 180);
      if (headingDiff > 45 && this.headingConfidence > 0.5) {
        // Use median instead of potentially erroneous new heading
        newHeading = medianHeading;
      }
    }

    // If we have a previous heading, smooth the transition
    if (this.lastHeading !== null) {
      // Normalize headings to 0-360
      const normalizedCurrent = ((newHeading % 360) + 360) % 360;
      const normalizedLast = ((this.lastHeading % 360) + 360) % 360;

      // Calculate the smallest angle between the two headings
      let diff = normalizedCurrent - normalizedLast;
      if (diff > 180) diff -= 360;
      if (diff < -180) diff += 360;

      // Apply adaptive smoothing based on motion and stationary state
      let headingWeight = this.headingSmoothingFactor;
      if (this.stationaryMode) {
        headingWeight = 0.05; // Very smooth when stationary
      } else if (this.motionDetected) {
        headingWeight = Math.min(0.4, headingWeight * (1 + this.motionConfidence)); // More responsive when motion detected
      }

      // Apply smoothing
      const smoothedHeading = normalizedLast + diff * (1 - headingWeight);

      // Normalize back to 0-360
      return ((smoothedHeading % 360) + 360) % 360;
    }

    return newHeading;
  }

  // Smooth velocity values
  smoothVelocity(vx, vy) {
    const speed = Math.sqrt(vx * vx + vy * vy);

    this.velocityBuffer.push(speed);
    while (this.velocityBuffer.length > this.velocityBufferSize) {
      this.velocityBuffer.shift();
    }

    if (this.velocityBuffer.length < 2) {
      return { vx, vy };
    }

    // Calculate median velocity to filter outliers
    if (this.velocityBuffer.length >= 3) {
      const sortedVelocities = [...this.velocityBuffer].sort((a, b) => a - b);
      const medianVelocity = sortedVelocities[Math.floor(sortedVelocities.length / 2)];

      const currentVelocity = speed;

      // If current velocity is drastically different from median, scale it
      if (currentVelocity > medianVelocity * 2) {
        const scale = (medianVelocity * 2) / currentVelocity;
        vx *= scale;
        vy *= scale;
      }
    }

    return { vx, vy };
  }

  // Adjust process noise based on accuracy, motion, and device capabilities
  adjustProcessNoise(accuracy, motionDetected) {
    // Update accuracy buffer and check if accuracy is improving
    this.updateAccuracyBuffer(accuracy);

    // Update motion detection state
    this.motionDetected = motionDetected;
    if (motionDetected) {
      this.motionConfidence = Math.min(1.0, this.motionConfidence + 0.1);
    } else {
      this.motionConfidence = Math.max(0.0, this.motionConfidence - 0.05);
    }

    // Base noise level depends on GPS accuracy
    let noiseLevel =
      this.adaptiveNoiseMin + (this.adaptiveNoiseMax - this.adaptiveNoiseMin) * Math.min(1.0, accuracy / 30.0);

    // Reduce noise when stationary
    if (this.stationaryMode) {
      noiseLevel *= 0.03;
    }

    // Increase noise when motion is detected
    if (this.motionDetected && !this.stationaryMode) {
      noiseLevel *= 1.0 + this.motionConfidence;
    }

    // Adjust based on accuracy trend
    if (this.isAccuracyImproving) {
      noiseLevel *= 0.9;
    } else {
      noiseLevel *= 1.1;
    }

    // Apply adaptive factor
    noiseLevel *= this.adaptiveNoiseFactor;

    // Set process noise
    this.Q = noiseLevel;

    return this;
  }

  // Update the filter with new measurement
  update(position, motionDetected = false) {
    if (!this.initialized) {
      this.reset(position);
      return position;
    }

    if (!position || typeof position.lat !== "number" || typeof position.lng !== "number") {
      console.warn("Invalid position input to Kalman filter");
      return {
        lat: this.y,
        lng: this.x,
        accuracy: position?.accuracy || 20,
        heading: this.lastHeading,
        timestamp: position?.timestamp || Date.now(),
      };
    }

    // If we're in stationary mode and have a locked position, return the locked position
    if (this.stationaryMode && this.stationaryLocked && this.stationaryPosition) {
      return {
        lat: this.stationaryPosition.lat,
        lng: this.stationaryPosition.lng,
        accuracy: position.accuracy,
        heading: this.smoothHeading(position.heading),
        timestamp: position.timestamp,
        speedMPS: 0,
      };
    }

    // Calculate time delta
    const timestamp = position.timestamp || Date.now();
    if (this.lastTimestamp) {
      this.dt = Math.min(Math.max((timestamp - this.lastTimestamp) / 1000, 0.01), 1.0);
    }
    this.lastTimestamp = timestamp;

    // Check for jitter
    const isJittering = this.detectJitter(position);

    // Adjust measurement noise based on GPS accuracy and jitter
    const accuracy = position.accuracy || 20;
    this.R = Math.max(KALMAN_MEASUREMENT_NOISE_BASE, accuracy / 5);

    // If in stationary mode, increase measurement noise to reduce jitter
    if (this.stationaryMode) {
      this.R *= 5.0;
    }

    // If jittering is detected, increase measurement noise significantly
    if (isJittering) {
      this.R *= 10.0;
    }

    // Adjust process noise based on accuracy and motion
    this.adjustProcessNoise(accuracy, motionDetected);

    // State transition matrix
    const F = [
      [1, 0, this.dt, 0],
      [0, 1, 0, this.dt],
      [0, 0, 1, 0],
      [0, 0, 0, 1],
    ];

    // Predict step
    // x = F * x
    const predictedX = this.x + this.dt * this.vx;
    const predictedY = this.y + this.dt * this.vy;
    const predictedVx = this.stationaryMode ? 0 : this.vx;
    const predictedVy = this.stationaryMode ? 0 : this.vy;

    // P = F * P * F' + Q
    const Q = [
      [(this.Q * this.dt * this.dt * this.dt * this.dt) / 4, 0, (this.Q * this.dt * this.dt * this.dt) / 2, 0],
      [0, (this.Q * this.dt * this.dt * this.dt * this.dt) / 4, 0, (this.Q * this.dt * this.dt * this.dt) / 2],
      [(this.Q * this.dt * this.dt * this.dt) / 2, 0, this.Q * this.dt * this.dt, 0],
      [0, (this.Q * this.dt * this.dt * this.dt) / 2, 0, this.Q * this.dt * this.dt],
    ];

    // Matrix multiplication F * P
    const FP = [
      [
        this.P[0][0] + this.dt * this.P[2][0],
        this.P[0][1] + this.dt * this.P[2][1],
        this.P[0][2] + this.dt * this.P[2][2],
        this.P[0][3] + this.dt * this.P[2][3],
      ],
      [
        this.P[1][0] + this.dt * this.P[3][0],
        this.P[1][1] + this.dt * this.P[3][1],
        this.P[1][2] + this.dt * this.P[3][2],
        this.P[1][3] + this.dt * this.P[3][3],
      ],
      [this.P[2][0], this.P[2][1], this.P[2][2], this.P[2][3]],
      [this.P[3][0], this.P[3][1], this.P[3][2], this.P[3][3]],
    ];

    // Matrix multiplication FP * F'
    const predictedP = [
      [
        FP[0][0] + this.dt * FP[0][2] + Q[0][0],
        FP[0][1] + this.dt * FP[0][3] + Q[0][1],
        FP[0][2] + Q[0][2],
        FP[0][3] + Q[0][3],
      ],
      [
        FP[1][0] + this.dt * FP[1][2] + Q[1][0],
        FP[1][1] + this.dt * FP[1][3] + Q[1][1],
        FP[1][2] + Q[1][2],
        FP[1][3] + Q[1][3],
      ],
      [FP[2][0] + Q[2][0], FP[2][1] + Q[2][1], FP[2][2] + Q[2][2], FP[2][3] + Q[2][3]],
      [FP[3][0] + Q[3][0], FP[3][1] + Q[3][1], FP[3][2] + Q[3][2], FP[3][3] + Q[3][3]],
    ];

    // Update step
    // y = z - H * x
    const measurementResidualX = position.lng - predictedX;
    const measurementResidualY = position.lat - predictedY;

    // Track innovation to detect filter divergence
    const innovation = Math.sqrt(
      measurementResidualX * measurementResidualX + measurementResidualY * measurementResidualY,
    );
    this.updateInnovationBuffer(innovation);

    // S = H * P * H' + R
    const S = [
      [predictedP[0][0] + this.R, predictedP[0][1]],
      [predictedP[1][0], predictedP[1][1] + this.R],
    ];

    // Calculate determinant of S
    const detS = S[0][0] * S[1][1] - S[0][1] * S[1][0];

    // Calculate inverse of S
    const invS = [
      [S[1][1] / detS, -S[0][1] / detS],
      [-S[1][0] / detS, S[0][0] / detS],
    ];

    // K = P * H' * inv(S)
    const K = [
      [
        predictedP[0][0] * invS[0][0] + predictedP[0][1] * invS[1][0],
        predictedP[0][0] * invS[0][1] + predictedP[0][1] * invS[1][1],
      ],
      [
        predictedP[1][0] * invS[0][0] + predictedP[1][1] * invS[1][0],
        predictedP[1][0] * invS[0][1] + predictedP[1][1] * invS[1][1],
      ],
      [
        predictedP[2][0] * invS[0][0] + predictedP[2][1] * invS[1][0],
        predictedP[2][0] * invS[0][1] + predictedP[2][1] * invS[1][1],
      ],
      [
        predictedP[3][0] * invS[0][0] + predictedP[3][1] * invS[1][0],
        predictedP[3][0] * invS[0][1] + predictedP[3][1] * invS[1][1],
      ],
    ];

    // x = x + K * y
    this.x = predictedX + K[0][0] * measurementResidualX + K[0][1] * measurementResidualY;
    this.y = predictedY + K[1][0] * measurementResidualX + K[1][1] * measurementResidualY;

    // In stationary mode, keep velocity at zero
    if (this.stationaryMode) {
      this.vx = 0;
      this.vy = 0;
    } else {
      this.vx = predictedVx + K[2][0] * measurementResidualX + K[2][1] * measurementResidualY;
      this.vy = predictedVy + K[3][0] * measurementResidualX + K[3][1] * measurementResidualY;

      // Smooth velocity
      const smoothedVelocity = this.smoothVelocity(this.vx, this.vy);
      this.vx = smoothedVelocity.vx;
      this.vy = smoothedVelocity.vy;
    }

    // P = (I - K * H) * P
    this.P = [
      [
        predictedP[0][0] - (K[0][0] * predictedP[0][0] + K[0][1] * predictedP[1][0]),
        predictedP[0][1] - (K[0][0] * predictedP[0][1] + K[0][1] * predictedP[1][1]),
        predictedP[0][2] - (K[0][0] * predictedP[0][2] + K[0][1] * predictedP[1][2]),
        predictedP[0][3] - (K[0][0] * predictedP[0][3] + K[0][1] * predictedP[1][3]),
      ],
      [
        predictedP[1][0] - (K[1][0] * predictedP[0][0] + K[1][1] * predictedP[1][0]),
        predictedP[1][1] - (K[1][0] * predictedP[0][1] + K[1][1] * predictedP[1][1]),
        predictedP[1][2] - (K[1][0] * predictedP[0][2] + K[1][1] * predictedP[1][2]),
        predictedP[1][3] - (K[1][0] * predictedP[0][3] + K[1][1] * predictedP[1][3]),
      ],
      [
        predictedP[2][0] - (K[2][0] * predictedP[0][0] + K[2][1] * predictedP[1][0]),
        predictedP[2][1] - (K[2][0] * predictedP[0][1] + K[2][1] * predictedP[1][1]),
        predictedP[2][2] - (K[2][0] * predictedP[0][2] + K[2][1] * predictedP[1][2]),
        predictedP[2][3] - (K[2][0] * predictedP[0][3] + K[2][1] * predictedP[1][3]),
      ],
      [
        predictedP[3][0] - (K[3][0] * predictedP[0][0] + K[3][1] * predictedP[1][0]),
        predictedP[3][1] - (K[3][0] * predictedP[0][1] + K[3][1] * predictedP[1][1]),
        predictedP[3][2] - (K[3][0] * predictedP[0][2] + K[3][1] * predictedP[1][2]),
        predictedP[3][3] - (K[3][0] * predictedP[0][3] + K[3][1] * predictedP[1][3]),
      ],
    ];

    // Process heading data
    const smoothedHeading = this.smoothHeading(position.heading);
    this.lastHeading = smoothedHeading;

    // Calculate speed from velocity components
    const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);

    // Create filtered position
    const filteredPosition = {
      lat: this.y,
      lng: this.x,
      accuracy: position.accuracy,
      heading: smoothedHeading,
      timestamp: position.timestamp,
      speedMPS: this.stationaryMode ? 0 : speed * 111000, // Convert from degrees/second to meters/second (approximate)
    };

    // If we're in stationary mode and don't have a locked position yet,
    // check if we should lock the position
    if (this.stationaryMode && !this.stationaryLocked && this.stationaryStartTime) {
      // If we've been stationary for a while, lock the position
      if (Date.now() - this.stationaryStartTime > 2000) {
        this.lockStationaryPosition(filteredPosition);
      }
    }

    return filteredPosition;
  }
}

// Position interpolator for smooth transitions
class PositionInterpolator {
  constructor() {
    this.startPosition = null;
    this.targetPosition = null;
    this.startTime = null;
    this.duration = 0;
    this.isActive = false;
    this.lastInterpolatedPosition = null;
    this.interpolationMethod = "cubic"; // "cubic", "linear", "spring"
    this.springParams = {
      stiffness: 100,
      damping: 10,
      mass: 1,
    };
  }

  setInterpolationMethod(method, params = {}) {
    this.interpolationMethod = method;

    if (method === "spring" && params) {
      this.springParams.stiffness = params.stiffness || 100;
      this.springParams.damping = params.damping || 10;
      this.springParams.mass = params.mass || 1;
    }

    return this;
  }

  start(startPos, targetPos, duration) {
    if (!startPos || !targetPos) return this;

    this.startPosition = { ...startPos };
    this.targetPosition = { ...targetPos };
    this.startTime = performance.now();
    this.duration = duration;
    this.isActive = true;

    // For spring animation, we need initial velocity
    if (this.interpolationMethod === "spring") {
      this.velocity = {
        lat: 0,
        lng: 0,
      };
      this.lastUpdateTime = this.startTime;
    }

    return this;
  }

  update() {
    if (!this.isActive) return null;

    const now = performance.now();
    const elapsed = now - this.startTime;

    if (elapsed >= this.duration && this.interpolationMethod !== "spring") {
      this.isActive = false;
      this.lastInterpolatedPosition = { ...this.targetPosition };
      return this.targetPosition;
    }

    let interpolatedPosition;

    switch (this.interpolationMethod) {
      case "linear":
        interpolatedPosition = this.linearInterpolation(elapsed / this.duration);
        break;
      case "spring":
        interpolatedPosition = this.springInterpolation(now);
        // Check if spring has settled
        const distToTarget = calculateDistance(interpolatedPosition, this.targetPosition);
        if (distToTarget < 0.1 && Math.abs(this.velocity.lat) < 0.0001 && Math.abs(this.velocity.lng) < 0.0001) {
          this.isActive = false;
        }
        break;
      case "cubic":
      default:
        interpolatedPosition = this.cubicInterpolation(elapsed / this.duration);
        break;
    }

    this.lastInterpolatedPosition = interpolatedPosition;
    return interpolatedPosition;
  }

  // Linear interpolation
  linearInterpolation(t) {
    // Clamp t between 0 and 1
    t = Math.max(0, Math.min(1, t));

    return {
      lat: this.startPosition.lat + (this.targetPosition.lat - this.startPosition.lat) * t,
      lng: this.startPosition.lng + (this.targetPosition.lng - this.startPosition.lng) * t,
      accuracy: this.targetPosition.accuracy,
      heading: this.targetPosition.heading,
      timestamp: performance.now(),
      speedMPS: this.targetPosition.speedMPS,
    };
  }

  // Cubic easing function for smoother motion
  cubicInterpolation(t) {
    // Clamp t between 0 and 1
    t = Math.max(0, Math.min(1, t));

    // Apply easing
    const easedT = this.easeOutCubic(t);

    return {
      lat: this.startPosition.lat + (this.targetPosition.lat - this.startPosition.lat) * easedT,
      lng: this.startPosition.lng + (this.targetPosition.lng - this.startPosition.lng) * easedT,
      accuracy: this.targetPosition.accuracy,
      heading: this.interpolateHeading(this.startPosition.heading, this.targetPosition.heading, easedT),
      timestamp: performance.now(),
      speedMPS: this.targetPosition.speedMPS,
    };
  }

  // Spring-based physics interpolation
  springInterpolation(now) {
    const dt = (now - this.lastUpdateTime) / 1000; // Convert to seconds
    this.lastUpdateTime = now;

    // Spring physics parameters
    const k = this.springParams.stiffness;
    const b = this.springParams.damping;
    const m = this.springParams.mass;

    // Calculate spring force for latitude and longitude
    const forceLatSpring = -k * (this.lastInterpolatedPosition.lat - this.targetPosition.lat);
    const forceLngSpring = -k * (this.lastInterpolatedPosition.lng - this.targetPosition.lng);

    // Calculate damping force
    const forceLatDamping = -b * this.velocity.lat;
    const forceLngDamping = -b * this.velocity.lng;

    // Calculate total force
    const totalForceLat = forceLatSpring + forceLatDamping;
    const totalForceLng = forceLngSpring + forceLngDamping;

    // Calculate acceleration (F = ma, so a = F/m)
    const accLat = totalForceLat / m;
    const accLng = totalForceLng / m;

    // Update velocity (v = v0 + a*t)
    this.velocity.lat += accLat * dt;
    this.velocity.lng += accLng * dt;

    // Update position (x = x0 + v*t)
    const newLat = this.lastInterpolatedPosition.lat + this.velocity.lat * dt;
    const newLng = this.lastInterpolatedPosition.lng + this.velocity.lng * dt;

    return {
      lat: newLat,
      lng: newLng,
      accuracy: this.targetPosition.accuracy,
      heading: this.interpolateHeading(this.lastInterpolatedPosition.heading, this.targetPosition.heading, 0.1),
      timestamp: now,
      speedMPS: this.targetPosition.speedMPS,
    };
  }

  // Interpolate heading (special case due to circular nature)
  interpolateHeading(startHeading, endHeading, t) {
    if (startHeading === null || endHeading === null) {
      return endHeading;
    }

    // Normalize headings to 0-360
    startHeading = ((startHeading % 360) + 360) % 360;
    endHeading = ((endHeading % 360) + 360) % 360;

    // Find the shortest path around the circle
    let diff = endHeading - startHeading;
    if (diff > 180) diff -= 360;
    if (diff < -180) diff += 360;

    // Interpolate
    const result = (startHeading + diff * t) % 360;
    return result < 0 ? result + 360 : result;
  }

  // Cubic easing function
  easeOutCubic(t) {
    return 1 - Math.pow(1 - t, 3);
  }

  // Smoother Hermite easing function with configurable smoothness
  easeHermite(t, smoothness = 0) {
    // Clamp t between 0 and 1
    t = Math.max(0, Math.min(1, t));

    // Apply Hermite interpolation with smoothness parameter
    return t * t * (3 - 2 * t - smoothness * (t - 1) * t);
  }

  isInterpolating() {
    return this.isActive;
  }

  cancel() {
    this.isActive = false;
    return this;
  }

  getLastPosition() {
    return this.lastInterpolatedPosition || this.targetPosition || this.startPosition;
  }
}

// Adaptive Kalman Filter Factory
class AdaptiveKalmanFilterFactory {
  static createForDevice(deviceInfo) {
    const filter = new KalmanFilter();

    // Configure based on device type and capabilities
    if (deviceInfo) {
      // Set device capabilities
      filter.setDeviceCapabilities(
        deviceInfo.highAccuracySupported || true,
        deviceInfo.motionSensorsAvailable || true,
        deviceInfo.orientationSensorsAvailable || true,
      );

      // Set receiver type based on device
      if (deviceInfo.gnssType) {
        filter.setReceiverType(deviceInfo.gnssType);
      }

      // Set environment type if known
      if (deviceInfo.environment) {
        filter.setEnvironmentType(deviceInfo.environment);
      }
    }

    return filter;
  }

  static createFilterAndInterpolator(deviceInfo, interpolationMethod = "cubic") {
    const filter = this.createForDevice(deviceInfo);
    const interpolator = new PositionInterpolator().setInterpolationMethod(interpolationMethod);

    return {
      filter,
      interpolator,

      // Convenience method to update and interpolate in one step
      update(position, motionDetected = false, interpolationDuration = 300) {
        // First update the filter
        const filteredPosition = filter.update(position, motionDetected);

        // Then start interpolation to the new filtered position
        if (!interpolator.isInterpolating()) {
          const startPos = interpolator.getLastPosition() || position;
          interpolator.start(startPos, filteredPosition, interpolationDuration);
        } else {
          // Update target while keeping the interpolation
          interpolator.targetPosition = filteredPosition;
        }

        // Return the current interpolated position
        return interpolator.update() || filteredPosition;
      },
    };
  }
}

// DOM update manager - batch DOM updates for better performance
const domUpdateManager = {
  updates: new Map(),
  scheduled: false,

  // Schedule a DOM update
  schedule(id, updateFn) {
    this.updates.set(id, updateFn);

    if (!this.scheduled) {
      this.scheduled = true;
      requestAnimationFrame(() => this.flush());
    }
  },

  // Flush all scheduled DOM updates
  flush() {
    this.updates.forEach((updateFn) => updateFn());
    this.updates.clear();
    this.scheduled = false;
  },
};

// Create tracking system with optimized filter and interpolator
const tracking = AdaptiveKalmanFilterFactory.createFilterAndInterpolator(
  {
    highAccuracySupported: true,
    motionSensorsAvailable: true,
    orientationSensorsAvailable: true,
    gnssType: "GPS_GLONASS",
    environment: "urban",
  },
  "cubic",
);

// Calculate appropriate zoom level based on speed with device movement filtering
function calculateZoomLevel(speedMPS) {
  // Update current speed for global access
  currentSpeed = speedMPS;
  
  // Check if this is genuine GPS movement or potential device movement
  const isGenuineMovement = lastPosition?.hasOwnProperty('speedAccuracy') && 
                           lastPosition.speedAccuracy < SPEED_ACCURACY_THRESHOLD;
  
  // Use a more conservative speed estimate for non-GPS-confirmed movement
  const reliableSpeed = isGenuineMovement ? speedMPS : Math.min(speedMPS, 1.0);
  
  // Determine target zoom level based on reliable speed
  let targetZoomLevel;
  
  if (isStationary || reliableSpeed < 0.5) {
    // Stationary or very slow movement
    targetZoomLevel = MAX_ZOOM_LEVEL;
  } else if (reliableSpeed < WALKING_SPEED_THRESHOLD) {
    // Walking speed
    targetZoomLevel = WALKING_ZOOM_LEVEL;
  } else if (reliableSpeed < RUNNING_SPEED_THRESHOLD) {
    // Running speed - linear interpolation between walking and running zoom levels
    const t = (reliableSpeed - WALKING_SPEED_THRESHOLD) / (RUNNING_SPEED_THRESHOLD - WALKING_SPEED_THRESHOLD);
    targetZoomLevel = WALKING_ZOOM_LEVEL - t;
  } else if (reliableSpeed < DRIVING_SPEED_THRESHOLD) {
    // Driving speed - linear interpolation between running and driving zoom levels
    const t = (reliableSpeed - RUNNING_SPEED_THRESHOLD) / (DRIVING_SPEED_THRESHOLD - RUNNING_SPEED_THRESHOLD);
    targetZoomLevel = WALKING_ZOOM_LEVEL - 1 - t;
  } else {
    // High speed
    targetZoomLevel = MIN_ZOOM_LEVEL;
  }
  
  // For non-GPS-confirmed movement, be more conservative with zoom changes
  let smoothingFactor = isGenuineMovement ? 0.15 : 0.05;
  
  // For GPS-confirmed movement, check for significant speed changes
  if (isGenuineMovement) {
    const speedChange = lastPosition ? Math.abs(speedMPS - lastPosition.speedMPS) : 0;
    const significantSpeedChange = speedChange > 1.0;
    
    // More responsive when speed changes significantly
    if (significantSpeedChange) {
      smoothingFactor = 0.4;
    }
  }
  
  // Smooth zoom level changes
  let zoomLevel = targetZoomLevel;
  if (lastZoomLevel !== null) {
    zoomLevel = lastZoomLevel * (1 - smoothingFactor) + targetZoomLevel * smoothingFactor;
  }
  
  // Ensure more immediate response for significant genuine GPS speed transitions
  if (isGenuineMovement && 
      ((isStationary && speedMPS > 1.0) || (!isStationary && speedMPS < 0.5))) {
    zoomLevel = lastZoomLevel * 0.6 + targetZoomLevel * 0.4;
  }
  
  // Round to one decimal place for smoother transitions
  zoomLevel = Math.round(zoomLevel * 10) / 10;
  
  // Clamp to valid zoom range
  zoomLevel = Math.max(MIN_ZOOM_LEVEL, Math.min(MAX_ZOOM_LEVEL, zoomLevel));
  
  // Update last zoom level
  lastZoomLevel = zoomLevel;
  
  return zoomLevel;
}
        
// Enhanced stationary position calculation
function calculateStationaryPosition(buffer) {
  if (!buffer || buffer.length === 0) {
    return null;
  }

  // Sort by accuracy (best first)
  const sortedBuffer = [...buffer].sort((a, b) => a.accuracy - b.accuracy);

  // Take weighted average of best positions
  const topPositions = sortedBuffer.slice(0, Math.ceil(buffer.length / 2));

  const weights = topPositions.map((pos) => 1 / Math.max(1, pos.accuracy));
  const totalWeight = weights.reduce((sum, w) => sum + w, 0);

  if (totalWeight === 0) {
    return sortedBuffer[0];
  }

  // Calculate weighted average
  const avgPosition = {
    lat: topPositions.reduce((sum, pos, i) => sum + pos.lat * weights[i], 0) / totalWeight,
    lng: topPositions.reduce((sum, pos, i) => sum + pos.lng * weights[i], 0) / totalWeight,
    accuracy: topPositions[0].accuracy,
    heading: topPositions[0].heading,
    timestamp: Date.now(),
    speedMPS: 0,
  };

  // If we have a previous stationary position, blend with it for stability
  if (lastStationaryPosition) {
    const blendFactor = 0.9;
    return {
      lat: lastStationaryPosition.lat * blendFactor + avgPosition.lat * (1 - blendFactor),
      lng: lastStationaryPosition.lng * blendFactor + avgPosition.lng * (1 - blendFactor),
      accuracy: avgPosition.accuracy,
      heading: avgPosition.heading,
      timestamp: avgPosition.timestamp,
      speedMPS: 0,
    };
  }

  return avgPosition;
}

// Update stationary position history
function updateStationaryHistory(position) {
  // Add new position to history
  stationaryPositionHistory.push(position);

  // Keep history at maximum size
  while (stationaryPositionHistory.length > STATIONARY_POSITION_HISTORY_SIZE) {
    stationaryPositionHistory.shift();
  }

  // Calculate weighted average of positions
  let totalWeight = 0;
  let weightedLat = 0;
  let weightedLng = 0;

  // Newer positions have higher weight
  for (let i = 0; i < stationaryPositionHistory.length; i++) {
    const pos = stationaryPositionHistory[i];
    const weight = Math.pow(STATIONARY_POSITION_WEIGHT_DECAY, stationaryPositionHistory.length - i - 1);
    totalWeight += weight;
    weightedLat += pos.lat * weight;
    weightedLng += pos.lng * weight;
  }

  return {
    lat: weightedLat / totalWeight,
    lng: weightedLng / totalWeight,
    accuracy: position.accuracy,
    heading: position.heading,
    timestamp: position.timestamp,
    speedMPS: 0,
  };
}

// Check if device is in motion based on motion sensors
function isDeviceInMotion() {
  if (!motionSamples || motionSamples.length < 3) {
    return false;
  }

  // Calculate average motion magnitude
  const avgMotion = motionSamples.reduce((sum, sample) => {
    return sum + Math.sqrt(sample.x * sample.x + sample.y * sample.y + sample.z * sample.z);
  }, 0) / motionSamples.length;

  return avgMotion > MOTION_THRESHOLD;
}

// Process device motion data
function handleDeviceMotion(event) {
  if (!event || !event.acceleration) return;

  const motion = {
    x: event.acceleration.x || 0,
    y: event.acceleration.y || 0,
    z: event.acceleration.z || 0,
    timestamp: Date.now(),
  };

  // Add to motion samples
  motionSamples.push(motion);

  // Keep only recent samples
  while (motionSamples.length > MOTION_SAMPLE_SIZE) {
    motionSamples.shift();
  }

  // Update device motion state
  deviceMotion = motion;
}

// Process device orientation data
function handleDeviceOrientation(event) {
  if (!event || event.alpha === null) return;

  deviceOrientation = {
    alpha: event.alpha, // z-axis rotation [0,360)
    beta: event.beta, // x-axis rotation [-180,180)
    gamma: event.gamma, // y-axis rotation [-90,90)
    timestamp: Date.now(),
  };

  // Update heading buffer if we have a compass heading
  if (event.webkitCompassHeading !== undefined) {
    const heading = event.webkitCompassHeading;

    // Add to heading buffer
    headingBuffer.push(heading);

    // Keep only recent headings
    while (headingBuffer.length > 5) {
      headingBuffer.shift();
    }

    // Calculate median heading to filter outliers
    if (headingBuffer.length >= 3) {
      const sortedHeadings = [...headingBuffer].sort((a, b) => a - b);
      lastHeadingValue = sortedHeadings[Math.floor(sortedHeadings.length / 2)];
    }
  }
}

// Request device motion and orientation permissions
function requestMotionPermission() {
  if (typeof DeviceMotionEvent !== "undefined" && typeof DeviceMotionEvent.requestPermission === "function") {
    DeviceMotionEvent.requestPermission()
      .then((response) => {
        if (response === "granted") {
          window.addEventListener("devicemotion", handleDeviceMotion, true);
        }
      })
      .catch(console.error);
  } else {
    window.addEventListener("devicemotion", handleDeviceMotion, true);
  }

  if (typeof DeviceOrientationEvent !== "undefined" && typeof DeviceOrientationEvent.requestPermission === "function") {
    DeviceOrientationEvent.requestPermission()
      .then((response) => {
        if (response === "granted") {
          orientationPermissionGranted = true;
          window.addEventListener("deviceorientation", handleDeviceOrientation, true);
        }
      })
      .catch(console.error);
  } else {
    window.addEventListener("deviceorientation", handleDeviceOrientation, true);
    orientationPermissionGranted = true;
  }
}

// Image preloading function
function preloadImages(locations) {
  return new Promise((resolve) => {
    if (!locations || locations.length === 0) {
      resolve();
      return;
    }

    const totalImages = locations.length;
    let loadedImages = 0;
    const progressBar = document.getElementById("preloaderProgress");

    locations.forEach((location, index) => {
      if (!location.image) {
        loadedImages++;
        updateProgress();
        if (loadedImages === totalImages) resolve();
        return;
      }

      // Skip if already preloaded
      if (preloadedImages.has(location.image)) {
        loadedImages++;
        updateProgress();
        if (loadedImages === totalImages) resolve();
        return;
      }

      const img = new Image();
      img.crossOrigin = "anonymous"; // Set crossOrigin for canvas operations
      img.onload = () => {
        preloadedImages.set(location.image, img);
        loadedImages++;
        updateProgress();
        if (loadedImages === totalImages) resolve();
      };

      img.onerror = () => {
        console.warn(`Failed to load image: ${location.image}`);
        loadedImages++;
        updateProgress();
        if (loadedImages === totalImages) resolve();
      };

      img.src = location.image;
    });

    // Also preload audio files
    locations.forEach((location) => {
      if (location.audio && !preloadedAudio.has(location.audio)) {
        const audio = new Audio();
        audio.preload = "auto";
        audio.oncanplaythrough = () => {
          preloadedAudio.set(location.audio, audio);
        };
        audio.src = location.audio;
      }
    });

    function updateProgress() {
      const percent = (loadedImages / totalImages) * 100;
      domUpdateManager.schedule("preloaderProgress", () => {
        if (progressBar) {
          progressBar.style.width = `${percent}%`;
        }
      });
    }
  });
}

// Detect sudden movements or position jumps
function detectSuddenMovement(newPosition, lastPosition) {
  if (!lastPosition || !newPosition) return false;

  const distance = calculateDistance(lastPosition, newPosition);
  const timeDelta = (newPosition.timestamp - lastPosition.timestamp) / 1000; // seconds

  // If time delta is too small, consider it a valid update
  if (timeDelta < 0.05) return false;

  // Calculate speed in meters per second
  const speed = distance / timeDelta;

  // Check for unrealistic speeds (teleportation)
  if (speed > 40) {
    // Reduced from 50 to 40 m/s for more sensitive jump detection
    console.log(`Position jump detected: ${distance.toFixed(2)}m in ${timeDelta.toFixed(2)}s (${speed.toFixed(2)} m/s)`);
    return true;
  }

  // Check for sudden movements when stationary
  if (isStationary && distance > POSITION_JUMP_THRESHOLD) {
    console.log(`Sudden movement detected while stationary: ${distance.toFixed(2)}m`);
    return true;
  }

  // Check for small sudden movements (jitter)
  if (isStationary && distance > SUDDEN_MOVEMENT_THRESHOLD) {
    suddenMovementCount++;
    if (suddenMovementCount >= 2) {
      console.log(`Multiple sudden movements detected: ${distance.toFixed(2)}m`);
      return true;
    }
  } else {
    suddenMovementCount = 0;
  }

  return false;
}

// Check for proximity to locations for zoom level adjustment
function checkProximityForZoom() {
    if (!lastPosition || !gameLocations || gameLocations.length === 0) return;
    
    // Only check the current location
    const location = gameLocations[currentLocationIndex];
    if (!location) return;
    
    // Calculate distance to current location
    const distance = calculateDistance(
        { lat: lastPosition.lat, lng: lastPosition.lng },
        { lat: location.lat, lng: location.lng }
    );
    
    // Convert to feet
    const distanceFeet = Math.round(distance * 3.28084);
    
    // Check if user is within proximity threshold
    const withinProximity = distanceFeet <= PROXIMITY_THRESHOLD;
    
    // Only update if proximity state has changed
    if (withinProximity !== isWithinProximity) {
        isWithinProximity = withinProximity;
        
        // Adjust zoom level based on proximity
        if (isWithinProximity && !proximityZoomActive) {
            // Zoom in when entering proximity
            proximityZoomActive = true;
            if (map && followUser) {
                map.setZoom(PROXIMITY_ZOOM_LEVEL, {
                    animate: true,
                    duration: 1.0,
                    noMoveStart: true
                });
            }
        } else if (!isWithinProximity && proximityZoomActive) {
            // Zoom out when leaving proximity
            proximityZoomActive = false;
            if (map && followUser) {
                map.setZoom(DEFAULT_ZOOM_LEVEL, {
                    animate: true,
                    duration: 1.0,
                    noMoveStart: true
                });
            }
        }
    }
}

function initMap() {
  // Ensure we have access to the Leaflet library
  const L = window.L;
  
  // Map initialization - using globally declared variables
  map = L.map("map", {
    zoomControl: false,
    attributionControl: false,
    zoomSnap: 0.1,
    zoomDelta: 0.5,
    wheelDebounceTime: 100,
    tapTolerance: 15,
    bounceAtZoomLimits: false,
    preferCanvas: true, // Use canvas renderer for better performance
    renderer: L.canvas({ padding: 0.5 }),
  }).fitWorld();
  
  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    maxZoom: 18,
    attribution: " OpenStreetMap contributors",
    updateWhenIdle: true,
    updateWhenZooming: false,
    keepBuffer: 2,
  }).addTo(map);
  
  // Initialize marker cluster group
  markerClusterGroup = L.markerClusterGroup({
    showCoverageOnHover: false,
    zoomToBoundsOnClick: true,
    spiderfyOnMaxZoom: true,
    animate: true,
    animateAddingMarkers: true,
    disableClusteringAtZoom: 17,
    maxClusterRadius: 60,
    iconCreateFunction: (cluster) =>
      L.divIcon({
        html: "<div><span>" + cluster.getChildCount() + "</span></div>",
        className: "marker-cluster-custom",
        iconSize: L.point(40, 40),
      }),
  });
  
  map.addLayer(markerClusterGroup);
  
  // Create user icon with custom styling (red)
  const userIcon = L.divIcon({
    className: 'user-marker',
    html: '<div class="user-marker-icon"><div class="user-marker-direction"></div></div>',
    iconSize: [20, 20],
    iconAnchor: [10, 10]
  });
  
  userMarker = L.marker([0, 0], { 
    icon: userIcon,
    zIndexOffset: 1000, // Ensure user marker is on top
    interactive: false // Prevent marker from being clickable
  }).addTo(map);
  
  // Store map viewport dimensions
  updateMapViewportDimensions();
  showLoadingMessage();
  
  // Request motion and orientation permissions
  requestMotionPermission();
  
  // Try to use Geolocation Sensor API first, then fall back to standard Geolocation API
  initGeolocation();
  
  document.addEventListener("visibilitychange", handleVisibilityChange);
  
  map.on("movestart zoomstart", () => {
    followUser = false;
    isMapInteracting = true;
  });
  
  map.on("moveend zoomend", () => {
    isMapInteracting = false;
    resetInactivityTimer();
    updateMapViewportDimensions();
  });
  
  // Listen for resize events to update viewport dimensions
  window.addEventListener("resize", updateMapViewportDimensions);
  
  // Start animation loop for smooth rendering
  startAnimationLoop();
  
  // Enable touch interactions
  map.touchZoom.enable();
  map.doubleClickZoom.enable();
}

// Update map viewport dimensions
function updateMapViewportDimensions() {
  if (map && map._container) {
    mapViewportWidth = map._container.clientWidth;
    mapViewportHeight = map._container.clientHeight;

    // Store current map center and zoom
    if (map.getCenter()) {
      lastMapCenter = map.getCenter();
      lastMapZoom = map.getZoom();
    }
  }
}

// Initialize geolocation with priority for Geolocation Sensor API
function initGeolocation() {
  // Declaring GeolocationSensor here
  const GeolocationSensor = window.GeolocationSensor;

  if ("GeolocationSensor" in window) {
    try {
      console.log("Trying GeolocationSensor API");
      geolocationSensor = new GeolocationSensor({ frequency: 1 });

      geolocationSensor.addEventListener("reading", () => {
        const position = {
          coords: {
            latitude: geolocationSensor.latitude,
            longitude: geolocationSensor.longitude,
            accuracy: geolocationSensor.accuracy,
            altitude: geolocationSensor.altitude,
            altitudeAccuracy: geolocationSensor.altitudeAccuracy,
            heading: geolocationSensor.heading,
            speed: geolocationSensor.speed,
          },
          timestamp: geolocationSensor.timestamp,
        };

        if (!lastPosition) {
          initializeUserLocation(position);
        } else {
          handlePositionUpdate(position);
        }
      });

      geolocationSensor.addEventListener("error", (error) => {
        console.warn("GeolocationSensor error:", error);
        // Fall back to standard Geolocation API
        useStandardGeolocation();
      });

      geolocationSensor.start();
      usingGeolocationSensorAPI = true;
      console.log("Using GeolocationSensor API");
    } catch (error) {
      console.warn("GeolocationSensor error:", error);
      // Fall back to standard Geolocation API
      useStandardGeolocation();
    }
  } else {
    // Fall back to standard Geolocation API
    useStandardGeolocation();
  }
}

// Standard Geolocation API fallback
function useStandardGeolocation() {
  console.log("Using standard Geolocation API");
  usingGeolocationSensorAPI = false;

  if ("geolocation" in navigator) {
    const options = {
      enableHighAccuracy: true,
      timeout: 30000, // Reduced timeout for faster fallback
      maximumAge: 0,
    };

    // Try first time
    navigator.geolocation.getCurrentPosition(
      initializeUserLocation,
      (error) => {
        // On error, try one more time before falling back
        navigator.geolocation.getCurrentPosition(initializeUserLocation, handleLocationError, options);
      },
      options,
    );
  } else {
    showPopup("Geolocation is not supported by your browser");
    map.setView([44.9778, -93.265], 17);
    hideLoadingMessage();
  }
}

// Variables for dynamic zoom functionality
let speedSamples = [];
const MAX_SPEED_SAMPLES = 5;
let lastSpeedForZoom = 0;
let targetZoomLevel = MAX_ZOOM_LEVEL;
let lastZoomUpdateTime = 0;
const ZOOM_UPDATE_INTERVAL = 500; // ms - interval between zoom updates

// Update speed samples for dynamic zoom
function updateSpeedSamples(position) {
  if (!position || typeof position.speedMPS !== 'number') return;
  
  // Add speed to samples
  speedSamples.push(position.speedMPS);
  
  // Keep only recent samples
  while (speedSamples.length > MAX_SPEED_SAMPLES) {
    speedSamples.shift();
  }
}

// Update dynamic zoom based on speed
function updateDynamicZoom() {
  const now = Date.now();
  if (now - lastZoomUpdateTime < ZOOM_UPDATE_INTERVAL) return;
  lastZoomUpdateTime = now;

  // Skip if user is interacting with map
  if (isMapInteracting || userIsInteracting) return;

  // Calculate average speed from samples
  let avgSpeed = 0;
  if (speedSamples.length > 0) {
    avgSpeed = speedSamples.reduce((sum, speed) => sum + speed, 0) / speedSamples.length;
  } else if (lastPosition) {
    avgSpeed = lastPosition.speedMPS || 0;
  }

  // Smooth speed changes
  const smoothedSpeed = lastSpeedForZoom * 0.7 + avgSpeed * 0.3;
  lastSpeedForZoom = smoothedSpeed;

  // Calculate optimal zoom level
  const optimalZoom = calculateZoomLevel(smoothedSpeed);

  // Only update if zoom level needs to change
  if (Math.abs(optimalZoom - targetZoomLevel) >= 0.1) {
    targetZoomLevel = optimalZoom;

    // Apply zoom change with smooth animation
    if (map && followUser) {
      const currentZoom = map.getZoom();
      const zoomDiff = Math.abs(currentZoom - targetZoomLevel);

      // Use faster transition for larger zoom changes
      const duration = zoomDiff > 1 ? 0.3 : ZOOM_TRANSITION_DURATION;

      map.setZoom(targetZoomLevel, {
        animate: true,
        duration: duration,
        noMoveStart: true,
      });
    }
  }
}

// Enhanced motion detection for better accuracy
function enhancedMotionDetection() {
  if (!deviceMotion || !motionSamples || motionSamples.length < 5) {
    return false;
  }

  // Calculate motion variance to detect significant movement
  const magnitudes = motionSamples.map(sample => 
    Math.sqrt(sample.x * sample.x + sample.y * sample.y + sample.z * sample.z)
  );
  
  const avgMagnitude = magnitudes.reduce((sum, mag) => sum + mag, 0) / magnitudes.length;
  
  // Calculate variance
  const variance = magnitudes.reduce((sum, mag) => sum + Math.pow(mag - avgMagnitude, 2), 0) / magnitudes.length;
  
  // Higher variance indicates more erratic movement
  return variance > MOTION_THRESHOLD * 0.5 || avgMagnitude > MOTION_THRESHOLD;
}

// Animation loop for smooth rendering
function startAnimationLoop() {
  // Local variables for optimization (not visible outside)
  let _frameCount = 0;
  let _lastFpsTime = 0;
  let _totalFrames = 0;
  let _accumulatedTime = 0;
  let _frameInterval = 16.667; // ms (60fps)
  let _skipThreshold = 16; // ms
  let _lowPerformanceMode = false;
  let _proximityCheckFrequency = 1;
  let lastProximityCheckTime = 0;
  
  function animate(timestamp) {
    // Calculate delta time
    const deltaTime = renderTimestamp ? (timestamp - renderTimestamp) / 1000 : 0;
    renderTimestamp = timestamp;
    
    // Performance tracking (hidden implementation detail)
    if (!_lastFpsTime) _lastFpsTime = timestamp;
    _frameCount++;
    _totalFrames++;
    if (timestamp - _lastFpsTime > 1000) {
      const fps = Math.round((_frameCount * 1000) / (timestamp - _lastFpsTime));
      _lowPerformanceMode = fps < 30;
      _proximityCheckFrequency = _lowPerformanceMode ? 3 : 1;
      _frameCount = 0;
      _lastFpsTime = timestamp;
    }
    
    // Frame limiting (hidden implementation detail)
    _accumulatedTime += deltaTime * 1000;
    if (_accumulatedTime < _skipThreshold) {
      animationFrameId = requestAnimationFrame(animate);
      return;
    }

    try {
      // Process position updates
      processPositionUpdateQueue();

      // Update interpolated position
      if (positionInterpolator && positionInterpolator.isInterpolating()) {
        const interpolatedPosition = positionInterpolator.update();
        if (interpolatedPosition) {
          // Update marker position and rotation
          updateUserMarkerPosition(interpolatedPosition);
          lastRenderPosition = interpolatedPosition;
        }
      }

      // Check if marker is near edge and recenter if needed
      if (followUser && !isMapInteracting && !edgeRecenterInProgress) {
        const recenterInfo = shouldRecenter(map, userMarker);
        if (recenterInfo.needsRecenter) {
          performEdgeRecenter(recenterInfo);
        }
      }

      // Update dynamic zoom based on speed
      updateDynamicZoom();

      // Check for proximity to locations
      if (Date.now() - lastProximityCheckTime > 500) {
        checkProximityForZoom();
        lastProximityCheckTime = Date.now();
      }
      
      // Reset accumulated time (hidden implementation detail)
      _accumulatedTime -= _frameInterval;
      if (_accumulatedTime > _frameInterval * 2) {
        _accumulatedTime = _frameInterval;
      }

      // Request next frame
      animationFrameId = requestAnimationFrame(animate);
    } catch (error) {
      // Error handling (hidden implementation detail)
      console.error('Error in animation loop:', error);
      animationFrameId = requestAnimationFrame(animate);
    }
  }

  // Start animation loop
  animationFrameId = requestAnimationFrame(animate);
}
       
// Process queued position updates
function processPositionUpdateQueue() {
  // Skip if no updates in queue
  if (positionUpdateQueue.length === 0) return;
  
  // Process all updates in the queue
  while (positionUpdateQueue.length > 0) {
    const update = positionUpdateQueue.shift();
    
    // Apply the update (assuming update contains position data)
    if (update && update.coords) {
      const position = {
        lat: update.coords.latitude,
        lng: update.coords.longitude,
        accuracy: update.coords.accuracy,
        heading: update.coords.heading,
        speedMPS: update.coords.speed,
        speedAccuracy: update.coords.speedAccuracy,
        timestamp: update.timestamp
      };
      
      // Process the position update
      processPositionUpdate(position);
    }
  }
}
      
// Update user marker position and rotation
function updateUserMarkerPosition(position) {
  if (!userMarker) return;

  // Update marker position
  userMarker.setLatLng([position.lat, position.lng]);

  // Update marker rotation based on heading if available
  if (position.heading !== undefined && position.heading !== null) {
    // Get the marker element
    const markerElement = userMarker.getElement();
    if (markerElement) {
      // Find the direction indicator element
      const directionElement = markerElement.querySelector(".user-marker-direction");
      if (directionElement) {
        // Update the rotation of the direction indicator
        directionElement.style.transform = `rotate(${position.heading}deg)`;
      }
    }
  }

  // Apply visual effects based on speed
  if (position.speedMPS !== undefined) {
    const markerElement = userMarker.getElement();
    if (markerElement) {
      const iconElement = markerElement.querySelector(".user-marker-icon");
      if (iconElement) {
        // Add pulsing effect when moving
        if (position.speedMPS > 0.5) {
          iconElement.classList.add("pulsing");
          // Adjust pulse speed based on movement speed
          const pulseRate = Math.max(0.5, Math.min(2.0, 1.0 + position.speedMPS / 5));
          iconElement.style.animationDuration = `${1 / pulseRate}s`;
        } else {
          iconElement.classList.remove("pulsing");
        }
      }
    }
  }
}
        
//process position update
function processPositionUpdate(position) {
  // Skip if invalid position
  if (!position || typeof position.lat !== "number" || typeof position.lng !== "number") {
    return;
  }

  // This prevents disorienting visual effects when position changes significantly
  if (lastRenderPosition && calculateDistance(lastRenderPosition, position) > EXTENDED_DISTANCE_THRESHOLD) {
    console.debug(`Large position change detected (${calculateDistance(lastRenderPosition, position).toFixed(2)}m). Skipping interpolation.`);
    updateUserMarkerPosition(position); // Direct update without animation
    lastRenderPosition = position;
    return; // Skip the rest of the interpolation logic
  }

  // Normal case: Apply smooth interpolation between positions
  if (lastRenderPosition && !isFirstPositionUpdate) {
    if (positionInterpolator) {
      // Use slower animation when stationary for more stability
      positionInterpolator.start(
        lastRenderPosition, 
        position,
        isStationary ? 300 : ANIMATION_DURATION,
      );
    } else {
      console.warn("Position interpolator not available, using direct position update");
      updateUserMarkerPosition(position);
      lastRenderPosition = position;
    }
  } else {
    // First position update - set directly without animation
    updateUserMarkerPosition(position);
    lastRenderPosition = position;
    isFirstPositionUpdate = false;
  }

  // Handle auto-recentering and zoom adjustments
  if (followUser && !isMapInteracting) {
    const recenterInfo = shouldRecenter(map, userMarker);
    if (recenterInfo.needsRecenter) {
      performEdgeRecenter(recenterInfo);
    } else if (Math.abs(map.getZoom() - calculateZoomLevel(position.speedMPS)) > 0.5) {
      const newZoom = calculateZoomLevel(position.speedMPS);
      map.setZoom(newZoom, {
        animate: true,
        duration: ZOOM_TRANSITION_DURATION,
      });
    }
  }
}
        
// Perform edge recentering with smoother transitions based on speed
function performEdgeRecenter(recenterInfo) {
  edgeRecenterInProgress = true;
  
  // Get current position
  const position = userMarker.getLatLng();
  
  // Get current speed (in meters per second)
  const currentSpeed = lastPosition?.speedMPS || 0;
  
  // Only trust GPS-reported speed, not calculated from position changes
  // This helps filter out device movements like shaking
  const isGenuineMovement = lastPosition?.hasOwnProperty('speedAccuracy') && 
                            lastPosition.speedAccuracy < SPEED_ACCURACY_THRESHOLD;
  
  // Use a conservative speed value if we're not confident in the movement
  const reliableSpeed = isGenuineMovement ? currentSpeed : Math.min(currentSpeed, 1.0);
  
  // Calculate appropriate zoom level based on reliable speed
  const dynamicZoom = calculateZoomLevel(reliableSpeed);
  
  // Get current map center
  const currentCenter = map.getCenter();
  
  // Calculate optimal center point that keeps the user icon away from edges
  const optimalCenter = calculateOptimalCenter(map, position, recenterInfo.edgeInfo);
  
  // Calculate edge proximity using your existing function
  const proximity = calculateEdgeProximity(map, position);
  
  // Find the minimum proximity (closest edge)
  const minProximity = Math.min(proximity.north, proximity.south, proximity.east, proximity.west);
  
  // Calculate speed factor (0-1) based on reliable speed
  const SPEED_THRESHOLD_SLOW = 1.5;
  const SPEED_THRESHOLD_FAST = 10.0;
  const speedFactor = Math.min(1, Math.max(0, (reliableSpeed - SPEED_THRESHOLD_SLOW) / 
                              (SPEED_THRESHOLD_FAST - SPEED_THRESHOLD_SLOW)));
  
  // Calculate combined transition factor
  const baseTransitionFactor = Math.max(0.3, Math.min(0.8, minProximity * 2));
  const speedAdjustedFactor = baseTransitionFactor - (speedFactor * 0.3);
  
  // Blend current and optimal centers for smoother transition
  const blendedCenter = {
    lat: currentCenter.lat + (optimalCenter.lat - currentCenter.lat) * (1 - speedAdjustedFactor),
    lng: currentCenter.lng + (optimalCenter.lng - currentCenter.lng) * (1 - speedAdjustedFactor)
  };
  
  // Only apply forward bias for genuine GPS movement
  let adjustedCenter = blendedCenter;
  if (lastPosition && isGenuineMovement) {
    const direction = {
      lat: position.lat - lastPosition.lat,
      lng: position.lng - lastPosition.lng
    };
    
    // Calculate movement magnitude
    const movement = Math.sqrt(direction.lat * direction.lat + direction.lng * direction.lng);
    
    // Only apply forward bias if moving significantly
    if (movement > 0.00001) {
      // Apply forward bias scaled to speed
      const forwardBiasAmount = 0.00005 + (speedFactor * 0.0001);
      
      // Normalize direction and apply forward bias
      adjustedCenter = {
        lat: blendedCenter.lat + (direction.lat / movement) * forwardBiasAmount,
        lng: blendedCenter.lng + (direction.lng / movement) * forwardBiasAmount
      };
    }
  }
  
  // Calculate duration based on reliable speed
  const baseDuration = recenterInfo.isEmergency ? 0.2 : ZOOM_TRANSITION_DURATION;
  const speedAdjustedDuration = baseDuration * (1 - (speedFactor * 0.5));
  
  // Set view with animation
  map.setView([adjustedCenter.lat, adjustedCenter.lng], dynamicZoom, {
    animate: true,
    duration: speedAdjustedDuration,
    noMoveStart: true,
    easeLinearity: 0.3 + (speedFactor * 0.2)
  });
  
  // Reset edge recenter flag after animation completes
  setTimeout(
    () => {
      edgeRecenterInProgress = false;
    },
    recenterInfo.isEmergency ? 300 : speedAdjustedDuration * 1000,
  );
}

function showLoadingMessage() {
    // Skip creating the loading message element
    // Just log to console for debugging purposes
    console.log("Searching for location...");
    
    // Set a flag to track that we're in the loading state
    window.isSearchingLocation = true;
    
    // If you need to maintain any timing-dependent behavior that might
    // rely on this function, you can add a small timeout
    setTimeout(() => {
        // This ensures any code expecting this function to take some time
        // will still work correctly
    }, 100);
}

function hideLoadingMessage() {
    // Clear the loading state flag
    window.isSearchingLocation = false;
    
    // No need to remove any elements since we didn't create them
    // Just log for debugging
    console.log("Location found, proceeding to stabilization...");
    
    // If any code relies on this function completing, ensure it still works
    const fakeLoadingMessage = document.getElementById('loadingMessage');
    if (fakeLoadingMessage) {
        document.body.removeChild(fakeLoadingMessage);
    }
}
       
function showStabilizingModal() {
  // Hide jitter immediately
  if (userMarker) userMarker.setOpacity(0);

  const modal = document.createElement("div");
  modal.id = "stabilizingModal";
  modal.className = "stabilizing-modal";
  modal.innerHTML = `
    <div class="spinner"></div>
    <h3>Stabilizing Your Location</h3>
    <p>Please wait while we fine-tune your position.</p>
  `;
  document.body.appendChild(modal);

  // Auto-dismiss after 5 seconds
  setTimeout(() => {
    if (userMarker) userMarker.setOpacity(1); // Restore visibility
    const modal = document.getElementById("stabilizingModal");
    if (modal) {
      modal.style.opacity = "0";
      setTimeout(() => modal.remove(), 500);
    }
    isStabilizing = false;
  }, 5000);
}

function initializeUserLocation(position) {
  console.log("Initial position data:", JSON.stringify(position));

  if (!position || !position.coords) {
    console.error("Invalid initial position object");
    handleLocationError(new Error("Invalid initial position"));
    return;
  }

  const { latitude: userLat, longitude: userLng, accuracy } = position.coords;

  if (isNaN(userLat) || isNaN(userLng)) {
    console.error("Invalid initial coordinates:", { userLat, userLng });
    handleLocationError(new Error("Invalid initial coordinates"));
    return;
  }

  console.log("Valid initial position:", { userLat, userLng, accuracy });

  try {
    // Set initial marker position
    updateUserMarkerPosition({
      lat: userLat,
      lng: userLng,
      accuracy: accuracy,
      heading: position.coords.heading,
      timestamp: Date.now(),
      speedMPS: 0,
    });

    map.setView([userLat, userLng], 17);

    // Initialize Kalman filter with first position
    tracking.filter.reset({
      lat: userLat,
      lng: userLng,
      accuracy: accuracy,
      heading: position.coords.heading,
      timestamp: Date.now(),
    });

    // Initialize stationary position
    lastStationaryPosition = {
      lat: userLat,
      lng: userLng,
      accuracy: accuracy,
      heading: position.coords.heading,
      timestamp: Date.now(),
      speedMPS: 0,
    };

    // Initialize last render position
    lastRenderPosition = {
      lat: userLat,
      lng: userLng,
      accuracy: accuracy,
      heading: position.coords.heading,
      timestamp: Date.now(),
      speedMPS: 0,
    };

    // Initialize last valid position
    lastValidPosition = {
      lat: userLat,
      lng: userLng,
      accuracy: accuracy,
      heading: position.coords.heading,
      timestamp: Date.now(),
      speedMPS: 0,
    };

    // Show stabilizing modal
    hideLoadingMessage();
    showStabilizingModal();

    // Start position updates
    startPositionUpdates();
    startHunt();
  } catch (error) {
    console.error("Error setting initial user location:", error);
    handleLocationError(error);
  }
}

function startPositionUpdates() {
  // If already using GeolocationSensor API, don't start again
  if (usingGeolocationSensorAPI) {
    console.log("Position updates already using GeolocationSensor API");
    return;
  }

  // Use standard Geolocation API with high frequency updates
  watchPositionId = navigator.geolocation.watchPosition(handlePositionUpdate, handleLocationError, {
    enableHighAccuracy: true,
    maximumAge: 0,
    timeout: 10000,
  });
  isWatchPositionActive = true;
  console.log("Position updates using standard Geolocation API");
}

function handlePositionUpdate(position) {
  if (!position?.coords?.latitude || !position?.coords?.longitude) {
    console.warn("Invalid position data received");
    return;
  }
  updateUserLocation(position);
}

function handleVisibilityChange() {
  if (document.hidden) {
    lastHiddenTime = Date.now();
    lastKnownPosition = userMarker ? userMarker.getLatLng() : null;

    // Cancel any active interpolation
    if (positionInterpolator) {
      positionInterpolator.cancel();
    }

    // Cancel animation frame
    if (animationFrameId) {
      cancelAnimationFrame(animationFrameId);
      animationFrameId = null;
    }

    // Stop GeolocationSensor if using it
    if (usingGeolocationSensorAPI && geolocationSensor) {
      geolocationSensor.stop();
    }
  } else {
    const hiddenDuration = Date.now() - lastHiddenTime;
    if (hiddenDuration > BACKGROUND_THRESHOLD) {
      updateLocationAfterBackground();
    } else {
      map.invalidateSize();

      // Restart animation loop
      if (!animationFrameId) {
        startAnimationLoop();
      }

      // Restart GeolocationSensor if using it
      if (usingGeolocationSensorAPI && geolocationSensor) {
        geolocationSensor.start();
      }

      // If returning from exhibit, ensure movement resumes properly
      if (isReturningFromExhibit) {
        isReturningFromExhibit = false;
        // Force a position update to resume tracking
        if (lastValidPosition) {
          updateUserLocation(
            {
              coords: {
                latitude: lastValidPosition.lat,
                longitude: lastValidPosition.lng,
                accuracy: lastValidPosition.accuracy,
                heading: lastValidPosition.heading,
                speed: lastValidPosition.speedMPS,
              },
              timestamp: Date.now(),
            },
            true,
          );
        }
      }
    }
  }
  resetInactivityTimer();
}

function updateLocationAfterBackground() {
    if (!("geolocation" in navigator)) {
        console.warn("Geolocation is not available");
        return;
    }

    const geolocationOptions = {
        enableHighAccuracy: true,
        timeout: 15000,
        maximumAge: 30000,  // Increased to allow cached positions
    };

    const handleSuccess = (position) => {
        console.log("Background update raw position:", JSON.stringify(position));
        
        if (!position?.coords) {
            console.warn("Invalid position object in background update");
            return;
        }

        const { latitude, longitude, accuracy } = position.coords;
        if (isNaN(latitude) || isNaN(longitude)) {
            console.warn("Invalid coordinates in background update:", { latitude, longitude });
            return;
        }

        console.log("Valid background position update:", { lat: latitude, lng: longitude });
        
        try {
            updateUserLocation(position, true);
            
            // Reset tracking state
            lastPosition = null;
            positionBuffer = [];
            velocity = { lat: 0, lng: 0 };
            lastVelocity = { lat: 0, lng: 0 };
            isStationary = false;
            stationaryStartTime = null;
            stationaryCount = 0;
            stationaryPositionHistory = [];
            lastStationaryPosition = null;
            stationaryPositionLocked = false;
            positionHistory = [];
            suddenMovementCount = 0;
            isJumpDetected = false;

            // Reset Kalman filter
            tracking.filter.reset({
                lat: latitude,
                lng: longitude,
                accuracy: accuracy,
                heading: position.coords.heading || 0,
                timestamp: Date.now(),
            });

            // Restart animation if needed
            if (!animationFrameId) {
                startAnimationLoop();
            }

            // Restart GeolocationSensor if using it
            if (usingGeolocationSensorAPI && geolocationSensor) {
                geolocationSensor.start();
            }

            updateDistanceBox();
            followUser = true;
            map.invalidateSize();
        } catch (error) {
            console.error("Error in updateUserLocation during background update:", error);
        }
    };

    const handleError = (error) => {
        console.error("Error getting location after background:", error);
        
        switch (error.code) {
            case error.PERMISSION_DENIED:
                console.warn("User denied geolocation access");
                break;
            case error.POSITION_UNAVAILABLE:
                console.warn("Location information unavailable");
                break;
            case error.TIMEOUT:
                console.warn("Location request timed out - retrying with lower accuracy");
                navigator.geolocation.getCurrentPosition(
                    handleSuccess,
                    (retryError) => console.error("Retry failed:", retryError),
                    {
                        enableHighAccuracy: false,
                        timeout: 20000,
                        maximumAge: 60000,
                    }
                );
                break;
            default:
                console.warn("Unknown geolocation error", error);
        }
    };

    navigator.geolocation.getCurrentPosition(
        handleSuccess,
        handleError,
        geolocationOptions
    );
}
        
// Helper function to validate position data
function isValidPosition(pos) {
  return (
    pos &&
    typeof pos.lat === "number" &&
    !isNaN(pos.lat) &&
    typeof pos.lng === "number" &&
    !isNaN(pos.lng) &&
    typeof pos.accuracy === "number" &&
    !isNaN(pos.accuracy)
  );
}

// Linear interpolation helper
function lerp(a, b, t) {
  if (typeof a !== "number" || typeof b !== "number" || typeof t !== "number") {
    return a;
  }

  return a + (b - a) * Math.max(0, Math.min(1, t));
}

// Update position buffer with new position
function updatePositionBuffer(position) {
  if (!isValidPosition(position)) {
    return;
  }

  // Add new position to buffer
  positionBuffer.push({
    lat: position.lat,
    lng: position.lng,
    accuracy: position.accuracy,
    heading: position.heading,
    timestamp: position.timestamp,
    speedMPS: position.speedMPS,
  });

  // Remove old positions if buffer exceeds maxSize
  while (positionBuffer.length > MAX_BUFFER_SIZE) {
    positionBuffer.shift();
  }
}

// Update position history for jump detection
function updatePositionHistory(position) {
  if (!isValidPosition(position)) {
    return;
  }

  // Add new position to history
  positionHistory.push({
    lat: position.lat,
    lng: position.lng,
    accuracy: position.accuracy,
    heading: position.heading,
    timestamp: position.timestamp,
    speedMPS: position.speedMPS,
  });

  // Keep only recent positions
  while (positionHistory.length > 10) {
    positionHistory.shift();
  }
}

// Check stationary state
function checkStationaryState(newPosition) {
  if (!lastPosition) return;

  // Calculate distance between current and last position
  const distance = calculateDistance(lastPosition, newPosition);

  // Check if device motion sensors indicate movement
  const motionDetected = isDeviceInMotion();

  // If significant movement is detected or motion sensors indicate activity
  if (distance >= MICRO_MOVEMENT_THRESHOLD || motionDetected) {
    if (isStationary) {
      console.debug("Movement detected, transitioning to moving state");
      isStationary = false;
      stationaryStartTime = null;
      stationaryPositionLocked = false;
      stationaryCount = 0; // Reset stationary count
      tracking.filter.setStationaryMode(false);

      // Clear any stationary lock timeout
      if (stationaryLockTimeout) {
        clearTimeout(stationaryLockTimeout);
        stationaryLockTimeout = null;
      }
    }

    // Clear the stationary check timeout
    if (stationaryCheckTimeout) {
      clearTimeout(stationaryCheckTimeout);
      stationaryCheckTimeout = null;
    }
  } else {
    // If no significant movement, increment stationary count
    stationaryCount++;

    // If stationary count exceeds threshold, transition to stationary state
    if (!isStationary && stationaryCount >= STATIONARY_THRESHOLD) {
      console.debug("User is now stationary");
      isStationary = true;
      stationaryStartTime = Date.now();
      tracking.filter.setStationaryMode(true);

      // Calculate a stable position by averaging recent positions
      const stablePosition = calculateStationaryPosition(positionBuffer);
      if (stablePosition) {
        lastStationaryPosition = stablePosition;

        // Set a timeout to lock the stationary position after a delay
        if (stationaryLockTimeout) {
          clearTimeout(stationaryLockTimeout);
        }

        stationaryLockTimeout = setTimeout(() => {
          stationaryPositionLocked = true;
          stationaryPositionLockTime = Date.now();
          console.log("Stationary position locked after delay");

          // Also lock in the Kalman filter
          tracking.filter.lockStationaryPosition(lastStationaryPosition);
        }, 2000); // Reduced from 3000ms for faster locking
      }
    }

    // Schedule the next stationary check
    if (isStationary && !stationaryCheckTimeout) {
      stationaryCheckTimeout = setTimeout(() => {
        stationaryCheckTimeout = null;
        checkStationaryState(newPosition);
      }, STATIONARY_CHECK_INTERVAL);
    }
  }
}

// Main function to update user location
function updateUserLocation(position, forceUpdate = false) {
  // Validate input position
  if (!position?.coords?.latitude || !position?.coords?.longitude) {
    console.warn("Invalid position data received");
    return;
  }

  const currentTime = Date.now();
  const timeDelta = lastUpdateTime ? (currentTime - lastUpdateTime) / 1000 : 0;

  // Create position object
  const newPosition = {
    lat: position.coords.latitude,
    lng: position.coords.longitude,
    accuracy: position.coords.accuracy || 20,
    heading: position.coords.heading !== null ? position.coords.heading : lastHeadingValue || undefined,
    timestamp: currentTime,
    speedMPS: position.coords.speed !== null ? position.coords.speed : 0,
  };

  // First position initialization
  if (!lastPosition) {
    lastPosition = newPosition;
    lastValidPosition = newPosition;
    updateUserMarkerPosition(newPosition);
    tracking.filter.reset(newPosition);
    lastUpdateTime = currentTime;
    stationaryStartTime = currentTime;
    positionBuffer = [newPosition];
    positionHistory = [newPosition];
    lastStationaryPosition = newPosition;
    lastRenderPosition = newPosition;

    // Set initial zoom based on stationary state
    const initialZoom = calculateZoomLevel(0);
    map.setView([newPosition.lat, newPosition.lng], initialZoom, { animate: false });
    updateDistanceBox();
    return;
  }

  // Calculate distance from last position
  const distance = calculateDistance(lastPosition, newPosition);

  // Check for sudden movements or position jumps
  const isJump = !forceUpdate && detectSuddenMovement(newPosition, lastPosition);

  // If a jump is detected and we're stationary, ignore this update
  if (isJump && isStationary && stationaryPositionLocked) {
    console.log("Position jump detected while stationary, ignoring update");
    isJumpDetected = true;
    return;
  }

  // Handle large position changes or forced updates - THIS IS THE CRITICAL CHANGE
  if (distance > EXTENDED_DISTANCE_THRESHOLD || forceUpdate) {
    if (stationaryCheckTimeout) {
      clearTimeout(stationaryCheckTimeout);
      stationaryCheckTimeout = null;
    }

    if (stationaryLockTimeout) {
      clearTimeout(stationaryLockTimeout);
      stationaryLockTimeout = null;
    }

    isStationary = false;
    stationaryStartTime = null;
    stationaryCount = 0;
    stationaryPositionHistory = [];
    lastStationaryPosition = null;
    stationaryPositionLocked = false;
    isJumpDetected = false;

    // Reset tracking variables
    tracking.filter.reset(newPosition);
    tracking.filter.setStationaryMode(false);
    
    // Update marker position IMMEDIATELY without interpolation
    updateUserMarkerPosition(newPosition);
    
    lastPosition = newPosition;
    lastValidPosition = newPosition;
    lastRenderPosition = newPosition;
    positionBuffer = [newPosition];
    positionHistory = [newPosition];
    lastVelocity = { lat: 0, lng: 0 };
    lastSmoothedPosition = null;

    // Update map view INSTANTLY without animation
    const zoomLevel = calculateZoomLevel(newPosition.speedMPS);
    map.setView([newPosition.lat, newPosition.lng], zoomLevel, {
      animate: false,  
      duration: 0      
    });

    lastUpdateTime = currentTime;
    lastUpdateTimestamp = currentTime;
    updateDistanceBox();

    if (map._container) {
      map._onResize();
    }
    return;
  }

  // Skip updates with poor accuracy or unrealistic movement
  if (
    !forceUpdate &&
    (newPosition.accuracy > MAX_ACCEPTABLE_ACCURACY || (timeDelta > 0 && distance / timeDelta > 40))
  ) {
    console.log("Skipping update due to poor accuracy or unrealistic movement");
    return;
  }

  try {
    // Check if device is in motion based on motion sensors
    const motionDetected = deviceMotion && isDeviceInMotion();

    // Check stationary state
    checkStationaryState(newPosition);

    // If we're in stationary mode and have a locked position, use that position
    if (isStationary && stationaryPositionLocked && lastStationaryPosition) {
      // Just update the distance box without changing position
      updateDistanceBox();
      return;
    }

    // Apply enhanced tracking with motion detection
    const smoothedPosition = tracking.update(newPosition, motionDetected, ANIMATION_DURATION);

    // Update position buffer and history
    updatePositionBuffer(smoothedPosition);
    updatePositionHistory(smoothedPosition);

    // Add this line to collect speed samples
    updateSpeedSamples(smoothedPosition);

    // Add to position update queue
    positionUpdateQueue.push(smoothedPosition);
    lastPosition = smoothedPosition;
    lastValidPosition = smoothedPosition;

    lastUpdateTime = currentTime;
    lastUpdateTimestamp = currentTime;
    updateDistanceBox();
  } catch (error) {
    console.error("Location update error:", error);
    // Fallback with basic filtering
    updateUserMarkerPosition(newPosition);
    lastPosition = newPosition;
    lastValidPosition = newPosition;
    lastRenderPosition = newPosition;
    updateDistanceBox();
  }
}

// Calculate proximity to map edges
function calculateEdgeProximity(map, point) {
  const bounds = map.getBounds();
  const latSpan = bounds.getNorth() - bounds.getSouth();
  const lngSpan = bounds.getEast() - bounds.getWest();
  
  // Add pixel-based proximity calculation for more accurate edge detection
  const mapSize = map.getSize();
  const pixelPoint = map.latLngToContainerPoint(point);
  
  return {
    north: Math.abs(point.lat - bounds.getNorth()) / latSpan,
    south: Math.abs(point.lat - bounds.getSouth()) / latSpan,
    east: Math.abs(point.lng - bounds.getEast()) / lngSpan,
    west: Math.abs(point.lng - bounds.getWest()) / lngSpan,
    
    // Pixel-based proximity (normalized 0-1)
    pixelNorth: pixelPoint.y / mapSize.y,
    pixelSouth: 1 - (pixelPoint.y / mapSize.y),
    pixelEast: 1 - (pixelPoint.x / mapSize.x),
    pixelWest: pixelPoint.x / mapSize.x
  };
}

// Check if user marker is near edge and should recenter
function shouldRecenter(map, marker) {
  if (!map || !marker) return { needsRecenter: false };
  
  const position = marker.getLatLng();
  const proximity = calculateEdgeProximity(map, position);
  
  // Get minimum proximity to any edge
  const minProximity = Math.min(
    proximity.north, 
    proximity.south, 
    proximity.east, 
    proximity.west
  );
  
  // Get minimum pixel-based proximity
  const minPixelProximity = Math.min(
    proximity.pixelNorth,
    proximity.pixelSouth,
    proximity.pixelEast,
    proximity.pixelWest
  );
  
  // Determine which edge is closest
  const edgeInfo = {
    isNorth: proximity.north === minProximity,
    isSouth: proximity.south === minProximity,
    isEast: proximity.east === minProximity,
    isWest: proximity.west === minProximity,
    pixelProximity: minPixelProximity
  };
  
  // Check if we need to recenter (either normal or emergency)
  const needsRecenter = minProximity < EDGE_THRESHOLD_PERCENTAGE;
  const isEmergency = minProximity < CRITICAL_EDGE_THRESHOLD;
  
  // Check if enough time has passed since last recenter
  const canRecenter = Date.now() - lastRecenterTime > RECENTER_COOLDOWN;
  
  if (needsRecenter && canRecenter) {
    lastRecenterTime = Date.now();
    return { 
      needsRecenter: true, 
      isEmergency, 
      edgeInfo 
    };
  }
  
  return { needsRecenter: false };
}

// Calculate optimal center point to keep user away from edges
function calculateOptimalCenter(map, position, edgeInfo) {
  const currentCenter = map.getCenter();
  
  // Calculate offset based on which edge is closest
  let latOffset = 0;
  let lngOffset = 0;
  
  if (edgeInfo.isNorth) {
    latOffset = -0.0002; // Move center south
  } else if (edgeInfo.isSouth) {
    latOffset = 0.0002; // Move center north
  }
  
  if (edgeInfo.isEast) {
    lngOffset = -0.0002; // Move center west
  } else if (edgeInfo.isWest) {
    lngOffset = 0.0002; // Move center east
  }
  
  // Calculate optimal center
  return {
    lat: position.lat + latOffset,
    lng: position.lng + lngOffset
  };
}

// Update distance box with distance to closest location
function updateDistanceBox() {
  if (!lastPosition || !gameLocations || gameLocations.length === 0) return;
  
  // Find closest location
  let closestLocation = null;
  let minDistance = Number.POSITIVE_INFINITY;
  
  gameLocations.forEach((location, index) => {
    const distance = calculateDistance(
      { lat: lastPosition.lat, lng: lastPosition.lng },
      { lat: location.lat, lng: location.lng }
    );
    
    if (distance < minDistance) {
      minDistance = distance;
      closestLocation = location;
      currentLocationIndex = index;
    }
  });
  
  if (!closestLocation) return;
  
  // Convert to feet
  const distanceFeet = Math.round(minDistance * 3.28084);
  
  // Update distance box
  const distanceBox = document.getElementById("distanceBox");
  if (distanceBox) {
    domUpdateManager.schedule("distanceBox", () => {
      distanceBox.textContent = `${distanceFeet} feet to ${closestLocation.name}`;
      
      // Add visual indicator when very close
      if (distanceFeet <= DISTANCE_THRESHOLD) {
        distanceBox.classList.add("close-proximity");
      } else {
        distanceBox.classList.remove("close-proximity");
      }
    });
  }
  
  // Check if user is within interaction distance
  if (distanceFeet <= DISTANCE_THRESHOLD && !isLocationHuntVisible) {
    // Only trigger if not on cooldown
    if (!locationCooldowns[closestLocation.id] || 
        Date.now() - locationCooldowns[closestLocation.id] > 60000) {
      showLocationHunt(closestLocation);
    }
  }
}

// Reset inactivity timer
function resetInactivityTimer() {
  if (inactivityTimer) {
    clearTimeout(inactivityTimer);
  }
  
  inactivityTimer = setTimeout(() => {
    if (!isLocationHuntVisible && followUser === false) {
      followUser = true;
      if (lastPosition) {
        map.setView([lastPosition.lat, lastPosition.lng], calculateZoomLevel(lastPosition.speedMPS), {
          animate: true,
          duration: 0.5
        });
      }
    }
  }, INACTIVITY_TIMEOUT);
}

// Handle location error
function handleLocationError(error) {
  console.error("Location error:", error);
  
  // Increment retry count
  retryCount++;
  
  if (retryCount <= 3) {
    console.log(`Retrying location (attempt ${retryCount})...`);
    
    // Try again with less strict options
    navigator.geolocation.getCurrentPosition(
      initializeUserLocation,
      (retryError) => {
        console.error(`Retry ${retryCount} failed:`, retryError);
        
        if (retryCount === 3) {
          // Final fallback - show error and use default location
          showPopup("Unable to get your location. Using default location.");
          map.setView([44.9778, -93.265], 17);
          hideLoadingMessage();
        } else {
          handleLocationError(retryError);
        }
      },
      {
        enableHighAccuracy: retryCount < 2, // Try without high accuracy after first retry
        timeout: 20000,
        maximumAge: retryCount * 10000 // Allow older positions on retries
      }
    );
  } else {
    // Give up after 3 retries
    showPopup("Unable to get your location. Please check your GPS settings.");
    map.setView([44.9778, -93.265], 17);
    hideLoadingMessage();
  }
}

// Show popup message
function showPopup(message) {
  const popup = document.createElement("div");
  popup.className = "popup-message";
  popup.textContent = message;
  document.body.appendChild(popup);
  
  setTimeout(() => {
    popup.classList.add("show");
    
    setTimeout(() => {
      popup.classList.remove("show");
      setTimeout(() => popup.remove(), 300);
    }, 3000);
  }, 10);
}

// Show location hunt screen
function showLocationHunt(location) {
  if (isLocationHuntVisible || userIsInteracting) return;
  
  isLocationHuntVisible = true;
  userIsInteracting = true;
  
  // Set cooldown for this location
  locationCooldowns[location.id] = Date.now();
  lastVisitedLocationId = location.id;
  
  // Update location hunt container
  const locationImage = document.getElementById("locationImage");
  const locationTitle = document.getElementById("locationTitle");
  const locationCity = document.getElementById("locationCity");
  const locationCreator = document.getElementById("locationCreator");
  const locationAudio = document.getElementById("locationAudio");
  
  if (locationImage) locationImage.src = location.image || "/placeholder.svg";
  if (locationTitle) locationTitle.textContent = location.name || "Unknown Location";
  if (locationCity) locationCity.textContent = location.city || "";
  if (locationCreator) locationCreator.textContent = location.creator || "";
  if (locationAudio) locationAudio.src = location.audio || "";
  
  // Show location hunt container
  const container = document.querySelector(".lochunt-container");
  if (container) {
    container.style.display = "block";
    setTimeout(() => container.classList.add("visible"), 10);
  }
  
  // Setup audio player
  setupAudioPlayer(location);
  
  // Add to visited locations if not already visited
  if (!visitedLocations.includes(location.id)) {
    visitedLocations.push(location.id);
  }
}

// Setup audio player
function setupAudioPlayer(location) {
  const audio = document.getElementById("locationAudio");
  const playPauseBtn = document.getElementById("playPauseBtn");
  const progressBar = document.getElementById("progressBar");
  const currentTimeEl = document.getElementById("currentTime");
  const durationEl = document.getElementById("duration");
  const rewindBtn = document.getElementById("rewindBtn");
  const forwardBtn = document.getElementById("forwardBtn");
  
  if (!audio || !playPauseBtn || !progressBar) return;
  
  // Reset audio player
  audio.currentTime = 0;
  progressBar.style.width = "0%";
  currentTimeEl.textContent = "0:00";
  playPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
  
  // Load audio
  audio.src = location.audio || "";
  audio.load();
  
  // Setup event listeners
  audio.addEventListener("loadedmetadata", () => {
    const minutes = Math.floor(audio.duration / 60);
    const seconds = Math.floor(audio.duration % 60).toString().padStart(2, "0");
    durationEl.textContent = `${minutes}:${seconds}`;
  });
  
  audio.addEventListener("timeupdate", () => {
    const progress = (audio.currentTime / audio.duration) * 100;
    progressBar.style.width = `${progress}%`;
    
    const minutes = Math.floor(audio.currentTime / 60);
    const seconds = Math.floor(audio.currentTime % 60).toString().padStart(2, "0");
    currentTimeEl.textContent = `${minutes}:${seconds}`;
  });
  
  audio.addEventListener("ended", () => {
    playPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
    showAdditionalInfo(location);
  });
  
  // Play/pause button
  playPauseBtn.addEventListener("click", () => {
    if (audio.paused) {
      audio.play();
      playPauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
    } else {
      audio.pause();
      playPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
    }
  });
  
  // Rewind button
  rewindBtn.addEventListener("click", () => {
    audio.currentTime = Math.max(0, audio.currentTime - 10);
  });
  
  // Forward button
  forwardBtn.addEventListener("click", () => {
    audio.currentTime = Math.min(audio.duration, audio.currentTime + 10);
  });
  
  // Auto-play after a short delay
  setTimeout(() => {
    audio.play().catch(error => {
      console.warn("Auto-play prevented:", error);
      playPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
    });
    playPauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
  }, 500);
}

// Show additional info after audio
function showAdditionalInfo(location) {
  // Hide location hunt container
  const huntContainer = document.querySelector(".lochunt-container");
  if (huntContainer) {
    huntContainer.classList.remove("visible");
    setTimeout(() => {
      huntContainer.style.display = "none";
    }, 500);
  }
  
  // Show additional info container
  const infoContainer = document.querySelector(".additional-info-container");
  const additionalInfo = document.getElementById("additionalInfo");
  const continueButton = document.getElementById("continueButton");
  
  if (infoContainer && additionalInfo) {
    additionalInfo.textContent = location.additionalInfo || "No additional information available.";
    infoContainer.style.display = "block";
    setTimeout(() => infoContainer.classList.add("visible"), 10);
    
    // Setup continue button
    if (continueButton) {
      continueButton.addEventListener("click", () => {
        infoContainer.classList.remove("visible");
        setTimeout(() => {
          infoContainer.style.display = "none";
          isLocationHuntVisible = false;
          userIsInteracting = false;
          isReturningFromExhibit = true;
        }, 500);
      }, { once: true });
    }
  }
}

// Start the hunt
function startHunt() {
  // Load locations from the global variable
  if (typeof locations !== "undefined") {
    gameLocations = locations;
  } else {
    // Fallback to sample locations
    gameLocations = [
      {
        id: "loc1",
        name: "Sample Location 1",
        lat: 44.9778,
        lng: -93.265,
        city: "Minneapolis, MN",
        creator: "Minnesota Historical Society",
        image: "https://www.mnthen.com/images/placeholder.jpg",
        audio: "https://www.mnthen.com/audio/sample.mp3",
        additionalInfo: "This is a sample location with additional information."
      },
      {
        id: "loc2",
        name: "Sample Location 2",
        lat: 44.9798,
        lng: -93.267,
        city: "Minneapolis, MN",
        creator: "Minnesota Historical Society",
        image: "https://www.mnthen.com/images/placeholder.jpg",
        audio: "https://www.mnthen.com/audio/sample.mp3",
        additionalInfo: "This is another sample location with additional information."
      }
    ];
  }
  
  // Preload images
  preloadImages(gameLocations).then(() => {
    // Add markers to map
    addLocationMarkers();
    
    // Hide preloader
    const preloader = document.getElementById("preloader");
    if (preloader) {
      preloader.style.opacity = "0";
      setTimeout(() => {
        preloader.style.display = "none";
      }, 500);
    }
    
    // Setup event listeners
    setupEventListeners();
  });
}

// Add location markers to map
function addLocationMarkers() {
  if (!gameLocations || !markerClusterGroup) return;
  
  gameLocations.forEach(location => {
    // Create custom marker
    const customIcon = L.divIcon({
      className: 'custom-pin-icon',
      html: '<div class="pin-head"></div>',
      iconSize: [20, 20],
      iconAnchor: [10, 10]
    });
    
    // Create marker
    const marker = L.marker([location.lat, location.lng], {
      icon: customIcon,
      title: location.name
    });
    
    // Create popup content
    const popupContent = `
      <div class="custom-popup">
        <div class="popup-content">
          <img class="location-image" src="${location.image || '/placeholder.svg'}" alt="${location.name}">
          <div class="location-name">${location.name}</div>
          <div class="popup-buttons">
            <button class="button view-button" data-id="${location.id}">View</button>
          </div>
        </div>
      </div>
    `;
    
    // Add popup to marker
    marker.bindPopup(popupContent);
    
    // Add marker to cluster group
    markerClusterGroup.addLayer(marker);
    
    // Add event listener to view button
    marker.on('popupopen', () => {
      setTimeout(() => {
        const viewButton = document.querySelector(`.view-button[data-id="${location.id}"]`);
        if (viewButton) {
          viewButton.addEventListener('click', () => {
            showLocationHunt(location);
            marker.closePopup();
          });
        }
      }, 10);
    });
  });
}

// Setup event listeners
function setupEventListeners() {
  // Recenter button
  const recenterButton = document.getElementById("recenterButton");
  if (recenterButton) {
    recenterButton.addEventListener("click", () => {
      if (lastPosition) {
        followUser = true;
        map.setView([lastPosition.lat, lastPosition.lng], calculateZoomLevel(lastPosition.speedMPS), {
          animate: true,
          duration: 0.5
        });
      }
    });
  }
  
  // Return button
  const returnButton = document.getElementById("returnButton");
  if (returnButton) {
    returnButton.addEventListener("click", () => {
      // Hide any open containers
      const huntContainer = document.querySelector(".lochunt-container");
      const infoContainer = document.querySelector(".additional-info-container");
      
      if (huntContainer) {
        huntContainer.classList.remove("visible");
        setTimeout(() => {
          huntContainer.style.display = "none";
        }, 500);
      }
      
      if (infoContainer) {
        infoContainer.classList.remove("visible");
        setTimeout(() => {
          infoContainer.style.display = "none";
        }, 500);
      }
      
      // Reset state
      isLocationHuntVisible = false;
      userIsInteracting = false;
      isReturningFromExhibit = true;
      
      // Pause audio if playing
      const audio = document.getElementById("locationAudio");
      if (audio && !audio.paused) {
        audio.pause();
      }
    });
  }
  
  // Tips button
  const tipsButton = document.getElementById("tipsButton");
  const tipsContainer = document.querySelector(".navigation-tips");
  const closeButton = document.querySelector(".navigation-tips .close-button");
  
  if (tipsButton && tipsContainer && closeButton) {
    tipsButton.addEventListener("click", () => {
      tipsContainer.style.display = "block";
    });
    
    closeButton.addEventListener("click", () => {
      tipsContainer.style.display = "none";
    });
  }
}

// Initialize map when DOM is loaded
document.addEventListener("DOMContentLoaded", () => {
  initMap();
});
    </script>
</body>
</html>
