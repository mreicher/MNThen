<!DOCTYPE html>
<html lang="en">
<head> 
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Minnesota Then | Museum Without Walls</title>
    <link rel="shortcut icon" type="image/x-icon" href="https://www.mnthen.com/images/mnthenfav.ico">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css">
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css" />
    <link rel="stylesheet" href="https://www.mnthen.com/css/mainmap.css">
    <style>
        .user-marker-icon {
            width: 20px;
            height: 20px;
            background-color: #ff0000; /* Red user icon */
            border: 3px solid white;
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            position: relative;
            transition: transform 0.3s cubic-bezier(0.25, 0.1, 0.25, 1);
            will-change: transform;
        }
        
        .user-marker-icon::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 30px;
            height: 30px;
            background-color: rgba(255, 0, 0, 0.2); /* Red with opacity */
            border-radius: 50%;
            transform: translate(-50%, -50%);
            animation: pulse 2s infinite;
            will-change: transform, opacity;
        }
        
        @keyframes pulse {
            0% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
            100% {
                transform: translate(-50%, -50%) scale(2);
                opacity: 0;
            }
        }
        
        .stabilizing-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            z-index: 2000;
            text-align: center;
            max-width: 80%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .stabilizing-modal h3 {
            margin-bottom: 15px;
            color: #ff0000; /* Red */
        }
        
        .stabilizing-modal p {
            margin-bottom: 20px;
        }
        
        .stabilizing-modal .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255, 0, 0, 0.2); /* Red with opacity */
            border-top: 4px solid #ff0000; /* Red */
            border-radius: 50%;
            margin-bottom: 20px;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Preloader styles */
        #preloader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }

        #preloader .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(255, 0, 0, 0.2);
            border-top: 5px solid #ff0000;
            border-radius: 50%;
            margin-bottom: 20px;
            animation: spin 1s linear infinite;
        }

        #preloader p {
            font-size: 18px;
            color: #333;
            margin-top: 15px;
        }

        #preloader .progress-container {
            width: 80%;
            max-width: 300px;
            height: 10px;
            background-color: #f0f0f0;
            border-radius: 5px;
            margin-top: 15px;
            overflow: hidden;
        }

        #preloader .progress-bar {
            height: 100%;
            background-color: #ff0000;
            width: 0%;
            transition: width 0.3s ease;
        }

        /* Dark blue color for summary elements */
        .summary-heading {
            color: #0f2bab !important;
        }

        .summary-button {
            background-color: #0f2bab !important;
        }

        .summary-button:hover {
            background-color: #0a1f80 !important;
        }
        
        /* Optimize for hardware acceleration */
        #map, .user-marker-icon, .lochunt-container, .additional-info-container {
            transform: translateZ(0);
            backface-visibility: hidden;
            perspective: 1000px;
        }
        
        /* Stationary indicator - removed green glow and modified for consistent appearance */
        .user-marker-stationary .user-marker-icon {
            /* Keep the same red color and white border */
            border-color: white;
        }
        
        .user-marker-stationary .user-marker-icon::after {
            /* Keep the same red pulse effect */
            background-color: rgba(255, 0, 0, 0.2);
            animation: pulse 2s infinite;
        }
        
        /* Center the "Did you know?" modal */
        .additional-info-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            z-index: 2000;
            text-align: center;
            max-width: 80%;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            display: none;
        }
        
/* Green route button and dark blue summary button */
.button.route-button {
    background-color: #1b5e20 !important; /* Dark green color */
    color: white !important;
    border: none !important;
    padding: 8px 15px !important;
    border-radius: 0px !important;
    cursor: pointer !important;
    font-weight: 500 !important;
    transition: background-color 0.3s ease !important;
}

.button.summary-button {
    background-color: #0f2bab !important; /* Dark blue color */
    color: white !important;
    border: none !important;
    padding: 8px 15px !important;
    border-radius: 0px !important;
    cursor: pointer !important;
    font-weight: 500 !important;
    transition: background-color 0.3s ease !important;
}

.button.route-button:hover {
    background-color: #0d3c12 !important; /* Darker green on hover */
}

.button.summary-button:hover {
    background-color: #0a1f80 !important; /* Darker blue on hover */
}
        
        .custom-popup .popup-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
        }

        /* Error message styles */
        .error-message {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(255, 59, 48, 0.9);
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 2500;
            max-width: 90%;
            text-align: center;
            font-weight: 500;
            animation: fadeInOut 5s forwards;
            pointer-events: none;
        }

        @keyframes fadeInOut {
            0% { opacity: 0; transform: translate(-50%, -20px); }
            10% { opacity: 1; transform: translate(-50%, 0); }
            90% { opacity: 1; transform: translate(-50%, 0); }
            100% { opacity: 0; transform: translate(-50%, -20px); }
        }

        /* Location transition styles */
        .location-transition {
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .location-transition.visible {
            opacity: 1;
        }

/* Confidence indicator styles */
#accuracyIndicator {
    position: fixed;
    top: 10px;
    left: 10px;
    background-color: rgba(255, 255, 255, 0.8);
    padding: 5px 10px;
    border-radius: 15px;
    font-size: 12px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    z-index: 1000;
    display: flex;
    align-items: center;
    pointer-events: none;
}
.accuracy-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    margin-right: 5px;
}
.accuracy-high {
    background-color: #4CD964; /* Green */
}
.accuracy-medium {
    background-color: #FFCC00; /* Yellow */
}
.accuracy-low {
    background-color: #FF3B30; /* Red */
}
    </style>
</head>
<body>
    <!-- Preloader -->
    <div id="preloader">
        <div class="spinner"></div>
        <p>Loading Minnesota Then...</p>
        <div class="progress-container">
            <div class="progress-bar" id="preloaderProgress"></div>
        </div>
    </div>

    <div id="map"></div>
    <div id="distanceBox">Initializing...</div>
    <div id="networkStatus" title="Network Status"></div>
    <div id="accuracyIndicator"><span class="accuracy-dot accuracy-medium"></span><span id="accuracyText">GPS Signal</span></div>

    <div class="lochunt-container location-transition">
        <img id="locationImage" src="" alt="Location Image">
        <div class="lochunt-content">
            <div class="lochunt-info">
                <h2 id="locationTitle" class="mb-2 text-primary"></h2>
                <p id="locationCity" class="text-muted mb-1"></p>
                <p id="locationCreator" class="text-muted mb-3"></p>
            </div>
            <div class="audio-player">
                <div class="audio-progress">
                    <div class="progress">
                        <div id="progressBar" class="progress-bar" role="progressbar" style="width: 0%"></div>
                    </div>
                </div>
                <div class="audio-time">
                    <span id="currentTime">0:00</span>
                    <span id="duration">0:00</span>
                </div>
                <div class="audio-controls">
                    <button id="rewindBtn" class="audio-button"><i class="fas fa-backward"></i></button>
                    <button id="playPauseBtn" class="audio-button"><i class="fas fa-play"></i></button>
                    <button id="forwardBtn" class="audio-button"><i class="fas fa-forward"></i></button>
                </div>
                <audio id="locationAudio" src=""></audio>
            </div>
        </div>
    </div>
    
    <div class="additional-info-container location-transition">
       <h3 class="mb-3 text-primary text-center">Did You Know?</h3>
       <p id="additionalInfo" class="mb-3 fs-6"></p>
       <div class="d-flex justify-content-center">
           <button id="continueButton" class="btn btn-primary">Continue</button>
       </div>
    </div>
    
    <div class="map-buttons">
        <button id="recenterButton" class="map-button"><i class="fas fa-crosshairs"></i></button>
        <button id="returnButton" class="map-button"><i class="fas fa-sign-out-alt"></i></button>
        <button id="tipsButton" class="map-button"><i class="fas fa-question-circle"></i></button>
    </div>

    <div class="navigation-tips">
        <button class="close-button">&times;</button>
        <h3>Navigation Tips</h3>
        <ul>
            <li>Use the map to navigate to the marked locations.</li>
            <li>The distance box shows how far you are from the current location.</li>
            <li>Tap the recenter button to focus on your current position.</li>
            <li>When you're within 20 feet of a location, you'll be able to interact with it.</li>
            <li>Listen to the audio information for each location.</li>
            <li>After the audio, you'll see additional information about the location.</li>
        </ul>
    </div>

    <div id="summaryModal" class="modal" style="display: none;">
        <div class="modal-content">
            <p id="summaryContent"></p>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"></script>
    <script src="/locations_test.js?v=1.0.4"></script>
 
    <script>
// Global variables
let map, userMarker, markerClusterGroup;
let currentLocationIndex = 0;
let visitedLocations = [];
let gameLocations = [];
let inactivityTimer;
let isLocationHuntVisible = false;
let lastPosition = null;
let positionBuffer = [];
const MAX_BUFFER_SIZE = 20; // Increased buffer size for smoother tracking
const DISTANCE_THRESHOLD = 20; // 20 feet threshold for opening location page
  
//initial location notification constants      
const GEOFENCE_RADIUS_FEET = 0; // 90 feet
const FEET_TO_METERS = 0.3048; // 1 foot = 0.3048 meters
const GEOFENCE_RADIUS_METERS = GEOFENCE_RADIUS_FEET * FEET_TO_METERS; // ~27.432 meters

const PROXIMITY_THRESHOLD = 40; // 40 feet threshold for zoom changes
let velocity = { lat: 0, lng: 0 };
let isMapInteracting = false;
let followUser = true;
let locationCooldowns = {};
let userIsInteracting = false;
let preloadedImages = new Map(); // Map to store preloaded images
let preloadedAudio = new Map(); // Map to store preloaded audio
let currentSpeed = 0; // Current speed in meters per second
let lastZoomLevel = 18; // Default zoom level
let stationaryPositionHistory = []; // Array to store stationary positions for averaging
let deviceOrientation = null; // Store device orientation data
let deviceMotion = null; // Store device motion data
let orientationPermissionGranted = false;
let geolocationSensor = null; // Store GeolocationSensor instance
let isNearLocation = false; // Flag to track if user is near a location
let lastProximityCheck = 0; // Last time proximity was checked
let isReturningFromExhibit = false; // Flag to track if returning from exhibit

// Enhanced constants for better stabilization
const MICRO_MOVEMENT_THRESHOLD = 0.5; // Meters - threshold for detecting micro-movements (increased for better stability)
const STATIONARY_ACCURACY_MULTIPLIER = 1.5; // Looser accuracy bounds to prevent false movement detection
const MAX_ACCEPTABLE_ACCURACY = 30; // meters - more lenient accuracy requirement
const STATIONARY_THRESHOLD = 3; // Number of consecutive stationary positions to consider user as stationary (reduced for faster stabilization)
const STATIONARY_TIME_THRESHOLD = 5000; // ms - time to consider user stationary (increased)
const STATIONARY_CHECK_INTERVAL = 2000; // ms - interval to check if still stationary (increased)
const VELOCITY_DECAY = 0.95; // Higher value for smoother velocity transitions
const MIN_DISTANCE_THRESHOLD = 1.5; // meters - minimum distance to consider movement (increased)
const EXTENDED_DISTANCE_THRESHOLD = 80; // meters - distance to consider a significant position change
const UPDATE_INTERVAL = 100; // ms - less frequent updates for more stability
const STATIONARY_POSITION_HISTORY_SIZE = 10; // Number of positions to keep for stationary averaging (reduced)
const STATIONARY_POSITION_WEIGHT_DECAY = 0.95; // Weight decay for older positions in stationary average (increased)
const SUDDEN_MOVEMENT_THRESHOLD = 1.0; // meters - threshold for detecting sudden movements (increased)
const POSITION_JUMP_THRESHOLD = 3.0; // meters - threshold for detecting position jumps (increased)
const ZOOM_CHANGE_COOLDOWN = 2000; // ms - cooldown between zoom changes

// Background handling constants
const BACKGROUND_THRESHOLD = 20000; // ms - time to consider app was in background
const INACTIVITY_TIMEOUT = 39000; // ms - time to consider user inactive (changed to 39 seconds)

// Kalman filter parameters - optimized for better stationary stability
const KALMAN_PROCESS_NOISE = 0.001; // Lower value for smoother tracking
const KALMAN_MEASUREMENT_NOISE_BASE = 2.0; // Higher base measurement noise to reduce jitter
const KALMAN_STATIONARY_NOISE = 0.0005; // Lower noise when stationary (reduced to minimize jitter)

// Animation parameters
const ANIMATION_DURATION = 300; // ms - increased duration of position animation for smoother transitions
const HEADING_SMOOTHING = 0.95; // Increased heading smoothing factor

// Zoom level parameters
const MAX_ZOOM_LEVEL = 18; // Maximum zoom level (stationary)
const MIN_ZOOM_LEVEL = 14; // Minimum zoom level (high speed)
const WALKING_ZOOM_LEVEL = 18; // Zoom level for walking speed
const WALKING_SPEED_THRESHOLD = 1.5; // m/s - threshold for walking speed
const RUNNING_SPEED_THRESHOLD = 4.0; // m/s - threshold for running speed
const DRIVING_SPEED_THRESHOLD = 10.0; // m/s - threshold for driving speed
const ZOOM_TRANSITION_DURATION = 0.8; // seconds - increased duration of zoom transition

// Motion detection parameters
const MOTION_THRESHOLD = 1.0; // Increased threshold for detecting significant motion
const MOTION_SAMPLE_SIZE = 10; // Increased number of motion samples to keep
const MOTION_CHECK_INTERVAL = 300; // ms - increased interval to check motion

// Edge recenter parameters - optimized for better edge recentering
const EDGE_THRESHOLD_PERCENTAGE = 0.15; // Percentage of viewport to trigger recenter (15%)
const CRITICAL_EDGE_THRESHOLD = 0.15; // Critical threshold for emergency recenter (15%)
const RECENTER_COOLDOWN = 500; // ms - reduced minimum time between recenters for more responsive recentering

// Error handling constants
const MAX_LOCATION_RETRIES = 5; // Maximum number of retries for location
const LOCATION_RETRY_DELAY = 2000; // Delay between location retries in ms
const NETWORK_CHECK_INTERVAL = 5000; // Interval to check network status in ms
const GPS_CONFIDENCE_THRESHOLD_HIGH = 10; // meters - high confidence threshold
const GPS_CONFIDENCE_THRESHOLD_MEDIUM = 25; // meters - medium confidence threshold
const GPS_SIGNAL_CHECK_INTERVAL = 3000; // Interval to check GPS signal quality in ms
const PERMISSION_DENIED_ERROR = 1; // Error code for permission denied
const POSITION_UNAVAILABLE_ERROR = 2; // Error code for position unavailable
const TIMEOUT_ERROR = 3; // Error code for timeout
const UNKNOWN_ERROR = 4; // Error code for unknown error

// State variables
let lastUpdateTime = null;
let lastVelocity = { lat: 0, lng: 0 };
let isStationary = false;
let stationaryStartTime = null;
let stationaryCheckTimeout = null;
let lastUpdateTimestamp = null;
let lastHiddenTime = 0;
let lastKnownPosition = null;
let isTransitioning = false;
let lastVisitedLocationId = null;
let stationaryCount = 0;
let lastSmoothedPosition = null;
let lastRecenterTime = Date.now();
let retryCount = 0;
let stationaryBuffer = [];
let stationaryPosition = null;
let isStabilizing = true; // Flag to track initial stabilization
let lastStationaryPosition = null; // Last stable position when stationary
let motionSamples = []; // Array to store motion samples
let lastMotionTimestamp = 0; // Last time motion was detected
let deviceStationaryTime = 0; // Time device has been stationary based on motion sensors
let animationFrameId = null; // Store requestAnimationFrame ID
let renderTimestamp = null; // Last render timestamp
let positionUpdateQueue = []; // Queue for position updates to be processed
let lastHeadingValue = null; // Last heading value
let headingBuffer = []; // Buffer for heading values
let isFirstPositionUpdate = true; // Flag for first position update
let lastRenderPosition = null; // Last rendered position
let positionInterpolator = null; // Position interpolator for smooth transitions
let mapViewportWidth = 0; // Store map viewport width
let mapViewportHeight = 0; // Store map viewport height
let lastMapCenter = null; // Last map center position
let lastMapZoom = null; // Last map zoom level
let edgeRecenterInProgress = false; // Flag to track edge recentering
let domUpdateScheduled = false; // Flag to track scheduled DOM updates
let pendingDomUpdates = new Map(); // Map to store pending DOM updates
let usingGeolocationSensorAPI = false; // Flag to track which geolocation API is being used
let lockStationaryPosition = false; // Flag to lock stationary position and prevent jitter
let positionHistory = []; // Array to store recent position history for jump detection
let lastPositionTimestamp = 0; // Last time a position was processed
let suddenMovementCount = 0; // Counter for consecutive sudden movements
let isJumpDetected = false; // Flag to track if a position jump is detected
let stationaryPositionLocked = false; // Flag to indicate if stationary position is locked
let stationaryPositionLockTime = 0; // Time when stationary position was locked
let lastValidPosition = null; // Last valid position before a jump
let stationaryLockTimeout = null; // Timeout for locking stationary position
let positionStabilityCounter = 0; // Counter for position stability
let lastZoomChangeTime = 0; // Last time zoom was changed due to proximity
let lastProximityDistance = Infinity; // Last distance to nearest location
let isOnline = navigator.onLine; // Track online status
let lastGpsSignalCheck = 0; // Last time GPS signal was checked
let gpsConfidenceScore = 0.5; // GPS confidence score (0-1)
let permissionDenied = false; // Flag to track if location permission was denied
let locationErrorCount = 0; // Counter for location errors
let networkErrorCount = 0; // Counter for network errors
let lastNetworkErrorTime = 0; // Last time a network error occurred
let isLocationAvailable = true; // Flag to track if location is available
let confidenceScoreHistory = []; // Array to store confidence scores for averaging
let stationaryConfidenceScore = 0; // Confidence score for stationary state (0-1)
let movingConfidenceScore = 0; // Confidence score for moving state (0-1)
let stationaryTransitionState = 0; // Transition state between stationary and moving (0-1)
let lastAccuracyUpdate = 0; // Last time accuracy indicator was updated
let locationWatchId = null; // ID for geolocation watch
let permissionRequestInProgress = false; // Flag to track if permission request is in progress
let lastPermissionRequest = 0; // Last time permission was requested

// Edge recenter variables
let lastEdgeCheck = 0;
const edgeCheckInterval = 500;

// Map update throttling variables
let lastMapUpdate = 0;
const mapUpdateThrottleInterval = 100;

// Dummy locations variable for testing
const myLocations = [];

// Dummy onMapRecentered variable for testing
const onMapRecentered = () => {};

// Dummy L variable for testing
const L = window.L;

// Dummy GeolocationSensor variable for testing
const GeolocationSensor = window.GeolocationSensor;

// Enhanced Kalman Filter implementation
class KalmanFilter {
    constructor() {
        // State variables
        this.x = 0; // Longitude estimate
        this.y = 0; // Latitude estimate
        this.vx = 0; // Longitude velocity
        this.vy = 0; // Latitude velocity
        
        // Error covariance matrix
        this.P = [
            [100, 0, 0, 0],  // Initial high uncertainty
            [0, 100, 0, 0],
            [0, 0, 10, 0],
            [0, 0, 0, 10]
        ];
        
        // Process noise
        this.Q = KALMAN_PROCESS_NOISE;
        
        // Measurement noise (will be adjusted based on GPS accuracy)
        this.R = KALMAN_MEASUREMENT_NOISE_BASE;
        
        // Time delta
        this.dt = 1.0;
        
        // Initialized flag
        this.initialized = false;
        
        // Heading and accuracy tracking
        this.lastHeading = null;
        this.headingConfidence = 0;
        
        // Stationary mode flag
        this.stationaryMode = false;
        
        // Last timestamp
        this.lastTimestamp = null;
        
        // Adaptive noise parameters
        this.adaptiveNoiseMin = 0.0005; // Reduced for better stability
        this.adaptiveNoiseMax = 0.005; // Reduced for better stability
        this.adaptiveNoiseFactor = 1.0;
        
        // Position history for jitter detection
        this.positionHistory = [];
        this.maxPositionHistory = 5;
        this.jitterThreshold = 0.5; // meters - increased to be more tolerant
        this.jitterCount = 0;
        
        // Stationary lock
        this.stationaryLocked = false;
        this.stationaryPosition = null;
        
        // New: Enhanced jitter detection with hysteresis
        this.jitterHysteresis = 0;
        this.maxJitterHysteresis = 5;
        this.jitterConfidence = 0;
    }
    
    // Initialize the filter with first position
    reset(position) {
        if (!position || typeof position.lat !== 'number' || typeof position.lng !== 'number') {
            console.error("Invalid position for Kalman filter reset");
            return;
        }
        
        this.x = position.lng;
        this.y = position.lat;
        this.vx = 0;
        this.vy = 0;
        
        // Reset covariance matrix with high initial uncertainty
        this.P = [
            [100, 0, 0, 0],
            [0, 100, 0, 0],
            [0, 0, 10, 0],
            [0, 0, 0, 10]
        ];
        
        this.initialized = true;
        this.lastHeading = position.heading || null;
        this.headingConfidence = 0;
        this.stationaryMode = false;
        this.lastTimestamp = position.timestamp || Date.now();
        this.adaptiveNoiseFactor = 1.0;
        this.positionHistory = [];
        this.jitterCount = 0;
        this.stationaryLocked = false;
        this.stationaryPosition = null;
        this.jitterHysteresis = 0;
        this.jitterConfidence = 0;
    }
    
    // Set stationary mode
    setStationaryMode(isStationary) {
        this.stationaryMode = isStationary;
        
        // When entering stationary mode, reduce velocity to zero
        if (isStationary) {
            this.vx = 0;
            this.vy = 0;
            
            // Reduce process noise for stationary mode
            this.Q = KALMAN_STATIONARY_NOISE;
            this.adaptiveNoiseFactor = 0.03; // Further reduced for even less jitter in stationary mode
        } else {
            // Reset to normal process noise when moving
            this.Q = KALMAN_PROCESS_NOISE;
            this.adaptiveNoiseFactor = 1.0; // Normal noise when moving
            this.stationaryLocked = false;
            this.stationaryPosition = null;
            this.jitterHysteresis = 0;
        }
    }
    
    // Lock stationary position
    lockStationaryPosition(position) {
        if (!this.stationaryMode) return;
        
        this.stationaryLocked = true;
        this.stationaryPosition = position;
        console.log("Kalman filter: Stationary position locked");
    }
    
    // Enhanced jitter detection with hysteresis and confidence scoring
    detectJitter(newPosition) {
        if (this.positionHistory.length === 0) {
            this.positionHistory.push(newPosition);
            return false;
        }
        
        const lastPos = this.positionHistory[this.positionHistory.length - 1];
        const distance = calculateDistance(lastPos, newPosition);
        
        // Add to history
        this.positionHistory.push(newPosition);
        if (this.positionHistory.length > this.maxPositionHistory) {
            this.positionHistory.shift();
        }
        
        // Check for rapid back-and-forth movement (jitter)
        if (this.positionHistory.length >= 3 && this.stationaryMode) {
            const pos1 = this.positionHistory[this.positionHistory.length - 3];
            const pos2 = this.positionHistory[this.positionHistory.length - 2];
            const pos3 = this.positionHistory[this.positionHistory.length - 1];
            
            const dist1 = calculateDistance(pos1, pos2);
            const dist2 = calculateDistance(pos2, pos3);
            
            // If moving back and forth in small distances
            if (dist1 < this.jitterThreshold && dist2 < this.jitterThreshold) {
                // Check for direction change (sign change in lat/lng differences)
                const latDiff1 = pos2.lat - pos1.lat;
                const latDiff2 = pos3.lat - pos2.lat;
                const lngDiff1 = pos2.lng - pos1.lng;
                const lngDiff2 = pos3.lng - pos2.lng;
                
                // If direction changed in either lat or lng
                if ((Math.sign(latDiff1) !== Math.sign(latDiff2) && Math.abs(latDiff1) > 0.00001 && Math.abs(latDiff2) > 0.00001) || 
                    (Math.sign(lngDiff1) !== Math.sign(lngDiff2) && Math.abs(lngDiff1) > 0.00001 && Math.abs(lngDiff2) > 0.00001)) {
                    
                    // Increase jitter hysteresis
                    this.jitterHysteresis = Math.min(this.maxJitterHysteresis, this.jitterHysteresis + 1);
                    
                    // Increase jitter confidence
                    this.jitterConfidence = Math.min(1.0, this.jitterConfidence + 0.2);
                    
                    return this.jitterHysteresis > 2 && this.jitterConfidence > 0.5;
                }
            }
        }
        
        // Gradually decrease jitter hysteresis and confidence if no jitter detected
        if (distance > this.jitterThreshold * 1.5) {
            this.jitterHysteresis = Math.max(0, this.jitterHysteresis - 0.5);
            this.jitterConfidence = Math.max(0, this.jitterConfidence - 0.1);
        }
        
        return false;
    }
    
    // Adjust process noise based on accuracy, motion, and jitter confidence
    adjustProcessNoise(accuracy, motionDetected) {
        // Base noise level depends on GPS accuracy
        let noiseLevel = this.adaptiveNoiseMin + 
            (this.adaptiveNoiseMax - this.adaptiveNoiseMin) * 
            Math.min(1.0, accuracy / 40.0);
        
        // Reduce noise when stationary
        if (this.stationaryMode) {
            noiseLevel *= 0.03; // Further reduced for even less jitter
        }
        
        // Increase noise when motion is detected
        if (motionDetected && !this.stationaryMode) {
            noiseLevel *= 1.5;
        }
        
        // Reduce noise when jitter is detected (counter-intuitive but effective)
        if (this.jitterConfidence > 0.3) {
            noiseLevel *= 0.01; // Drastically reduce noise to stabilize position
        }
        
        // Apply adaptive factor
        noiseLevel *= this.adaptiveNoiseFactor;
        
        // Set process noise
        this.Q = noiseLevel;
    }
    
    // Update the filter with new measurement
    update(position, motionDetected = false) {
        if (!this.initialized) {
            this.reset(position);
            return position;
        }
        
        if (!position || typeof position.lat !== 'number' || typeof position.lng !== 'number') {
            console.warn("Invalid position input to Kalman filter");
            return {
                lat: this.y,
                lng: this.x,
                accuracy: position?.accuracy || 20,
                heading: this.lastHeading,
                timestamp: position?.timestamp || Date.now()
            };
        }
        
        // If we're in stationary mode and have a locked position, return the locked position
        if (this.stationaryMode && this.stationaryLocked && this.stationaryPosition) {
            return {
                lat: this.stationaryPosition.lat,
                lng: this.stationaryPosition.lng,
                accuracy: position.accuracy,
                heading: position.heading,
                timestamp: position.timestamp,
                speedMPS: 0
            };
        }
        
        // Calculate time delta
        const timestamp = position.timestamp || Date.now();
        if (this.lastTimestamp) {
            this.dt = Math.min(Math.max((timestamp - this.lastTimestamp) / 1000, 0.01), 2.0);
        }
        this.lastTimestamp = timestamp;
        
        // Check for jitter
        const isJittering = this.detectJitter(position);
        
        // Adjust measurement noise based on GPS accuracy and jitter
        const accuracy = position.accuracy || 20;
        this.R = Math.max(KALMAN_MEASUREMENT_NOISE_BASE, accuracy / 5);
        
        // If in stationary mode, increase measurement noise to reduce jitter
        if (this.stationaryMode) {
            this.R *= 15.0; // Increased to further reduce jitter
        }
        
        // If jittering is detected, increase measurement noise significantly
        if (isJittering) {
            this.R *= 30.0; // Increased to further reduce jitter
        }
        
        // Adjust process noise based on accuracy and motion
        this.adjustProcessNoise(accuracy, motionDetected);
        
        // State transition matrix
        const F = [
            [1, 0, this.dt, 0],
            [0, 1, 0, this.dt],
            [0, 0, 1, 0],
            [0, 0, 0, 1]
        ];
        
        // Process noise matrix
        const G = [
            [0.5 * this.dt * this.dt, 0],
            [0, 0.5 * this.dt * this.dt],
            [this.dt, 0],
            [0, this.dt]
        ];
        
        // Measurement matrix
        const H = [
            [1, 0, 0, 0],
            [0, 1, 0, 0]
        ];
        
        // Predict step
        // x = F * x
        const predictedX = this.x + this.dt * this.vx;
        const predictedY = this.y + this.dt * this.vy;
        const predictedVx = this.stationaryMode ? 0 : this.vx;
        const predictedVy = this.stationaryMode ? 0 : this.vy;
        
        // P = F * P * F' + Q
        const Q = [
            [this.Q * this.dt * this.dt * this.dt * this.dt / 4, 0, this.Q * this.dt * this.dt * this.dt / 2, 0],
            [0, this.Q * this.dt * this.dt * this.dt * this.dt / 4, 0, this.Q * this.dt * this.dt * this.dt / 2],
            [this.Q * this.dt * this.dt * this.dt / 2, 0, this.Q * this.dt * this.dt, 0],
            [0, this.Q * this.dt * this.dt * this.dt / 2, 0, this.Q * this.dt * this.dt]
        ];
        
        // Matrix multiplication F * P
        const FP = [
            [this.P[0][0] + this.dt * this.P[2][0], this.P[0][1] + this.dt * this.P[2][1], this.P[0][2] + this.dt * this.P[2][2], this.P[0][3] + this.dt * this.P[2][3]],
            [this.P[1][0] + this.dt * this.P[3][0], this.P[1][1] + this.dt * this.P[3][1], this.P[1][2] + this.dt * this.P[3][2], this.P[1][3] + this.dt * this.P[3][3]],
            [this.P[2][0], this.P[2][1], this.P[2][2], this.P[2][3]],
            [this.P[3][0], this.P[3][1], this.P[3][2], this.P[3][3]]
        ];
        
        // Matrix multiplication FP * F'
        const predictedP = [
            [FP[0][0] + this.dt * FP[0][2] + Q[0][0], FP[0][1] + this.dt * FP[0][3] + Q[0][1], FP[0][2] + Q[0][2], FP[0][3] + Q[0][3]],
            [FP[1][0] + this.dt * FP[1][2] + Q[1][0], FP[1][1] + this.dt * FP[1][3] + Q[1][1], FP[1][2] + Q[1][2], FP[1][3] + Q[1][3]],
            [FP[2][0] + Q[2][0], FP[2][1] + Q[2][1], FP[2][2] + Q[2][2], FP[2][3] + Q[2][3]],
            [FP[3][0] + Q[3][0], FP[3][1] + Q[3][1], FP[3][2] + Q[3][2], FP[3][3] + Q[3][3]]
        ];
                
        // Update step
        // y = z - H * x
        const measurementResidualX = position.lng - predictedX;
        const measurementResidualY = position.lat - predictedY;
        
        // S = H * P * H' + R
        const S = [
            [predictedP[0][0] + this.R, predictedP[0][1]],
            [predictedP[1][0], predictedP[1][1] + this.R]
        ];
        
        // Calculate determinant of S
        const detS = S[0][0] * S[1][1] - S[0][1] * S[1][0];
        
        // Calculate inverse of S
        const invS = [
            [S[1][1] / detS, -S[0][1] / detS],
            [-S[1][0] / detS, S[0][0] / detS]
        ];
        
        // K = P * H' * inv(S)
        const K = [
            [predictedP[0][0] * invS[0][0] + predictedP[0][1] * invS[1][0], predictedP[0][0] * invS[0][1] + predictedP[0][1] * invS[1][1]],
            [predictedP[1][0] * invS[0][0] + predictedP[1][1] * invS[1][0], predictedP[1][0] * invS[0][1] + predictedP[1][1] * invS[1][1]],
            [predictedP[2][0] * invS[0][0] + predictedP[2][1] * invS[1][0], predictedP[2][0] * invS[0][1] + predictedP[2][1] * invS[1][1]],
            [predictedP[3][0] * invS[0][0] + predictedP[3][1] * invS[1][0], predictedP[3][0] * invS[0][1] + predictedP[3][1] * invS[1][1]]
        ];
        
        // x = x + K * y
        this.x = predictedX + K[0][0] * measurementResidualX + K[0][1] * measurementResidualY;
        this.y = predictedY + K[1][0] * measurementResidualX + K[1][1] * measurementResidualY;
        
        // In stationary mode, keep velocity at zero
        if (this.stationaryMode) {
            this.vx = 0;
            this.vy = 0;
        } else {
            this.vx = predictedVx + K[2][0] * measurementResidualX + K[2][1] * measurementResidualY;
            this.vy = predictedVy + K[3][0] * measurementResidualX + K[3][1] * measurementResidualY;
        }
        
        // P = (I - K * H) * P 
        this.P = [ 
            [predictedP[0][0] - (K[0][0] * predictedP[0][0] + K[0][1] * predictedP[1][0]), 
             predictedP[0][1] - (K[0][0] * predictedP[0][1] + K[0][1] * predictedP[1][1]), 
             predictedP[0][2] - (K[0][0] * predictedP[0][2] + K[0][1] * predictedP[1][2]), 
             predictedP[0][3] - (K[0][0] * predictedP[0][3] + K[0][1] * predictedP[1][3])], 
            
            [predictedP[1][0] - (K[1][0] * predictedP[0][0] + K[1][1] * predictedP[1][0]), 
             predictedP[1][1] - (K[1][0] * predictedP[0][1] + K[1][1] * predictedP[1][1]), 
             predictedP[1][2] - (K[1][0] * predictedP[0][2] + K[1][1] * predictedP[1][2]), 
             predictedP[1][3] - (K[1][0] * predictedP[0][3] + K[1][1] * predictedP[1][3])], 
            
            [predictedP[2][0] - (K[2][0] * predictedP[0][0] + K[2][1] * predictedP[1][0]), 
             predictedP[2][1] - (K[2][0] * predictedP[0][1] + K[2][1] * predictedP[1][1]), 
             predictedP[2][2] - (K[2][0] * predictedP  + K[2][1] * predictedP[1][1]), 
             predictedP[2][2] - (K[2][0] * predictedP[0][2] + K[2][1] * predictedP[1][2]), 
             predictedP[2][3] - (K[2][0] * predictedP[0][3] + K[2][1] * predictedP[1][3])], 
            
            [predictedP[3][0] - (K[3][0] * predictedP[0][0] + K[3][1] * predictedP[1][0]), 
             predictedP[3][1] - (K[3][0] * predictedP[0][1] + K[3][1] * predictedP[1][1]), 
             predictedP[3][2] - (K[3][0] * predictedP[0][2] + K[3][1] * predictedP[1][2]), 
             predictedP[3][3] - (K[3][0] * predictedP[0][3] + K[3][1] * predictedP[1][3])]
        ];
        
        // Process heading data with enhanced smoothing
        let smoothedHeading = position.heading;
        if (position.heading !== null && position.heading !== undefined) {
            if (this.lastHeading !== null) {
                // Normalize headings to 0-360
                const normalizedCurrent = ((position.heading % 360) + 360) % 360;
                const normalizedLast = ((this.lastHeading % 360) + 360) % 360;
                
                // Calculate the smallest angle between the two headings
                let diff = normalizedCurrent - normalizedLast;
                if (diff > 180) diff -= 360;
                if (diff < -180) diff += 360;
                
                // Apply stronger smoothing when stationary, more responsive when moving
                // This is a key improvement for icon movement
                const headingWeight = this.stationaryMode ? 
                    0.005 : // Extremely stable when stationary
                    (motionDetected ? 
                        (Math.abs(diff) > 30 ? 0.4 : 0.2) : // More responsive to large changes when in motion
                        0.1); // Default smoothing
                
                smoothedHeading = normalizedLast + diff * headingWeight;
                
                // Normalize back to 0-360
                smoothedHeading = ((smoothedHeading % 360) + 360) % 360;
                
                // Increase confidence with consistent headings
                if (Math.abs(diff) < 12) {
                    this.headingConfidence = Math.min(1.0, this.headingConfidence + 0.1);
                } else {
                    this.headingConfidence = Math.max(0.1, this.headingConfidence - 0.2);
                }
            }
            this.lastHeading = smoothedHeading;
        }
        
        // Calculate speed from velocity components
        const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
        
        // Create filtered position
        const filteredPosition = {
            lat: this.y,
            lng: this.x,
            accuracy: position.accuracy,
            heading: smoothedHeading,
            timestamp: position.timestamp,
            speedMPS: this.stationaryMode ? 0 : speed * 111000 // Convert from degrees/second to meters/second (approximate)
        };
        
        // If we're in stationary mode and don't have a locked position yet,
        // check if we should lock the position
        if (this.stationaryMode && !this.stationaryLocked) {
            // If we've been stationary for a while, lock the position
            if (Date.now() - stationaryStartTime > 3000) {
                this.lockStationaryPosition(filteredPosition);
            }
        }
        
        return filteredPosition;
    }
}

// Position interpolator for smooth transitions
class PositionInterpolator {
    constructor() {
        this.startPosition = null;
        this.targetPosition = null;
        this.startTime = null;
        this.duration = 0;
        this.isActive = false;
        this.lastInterpolatedPosition = null; // Track last interpolated position
    }
    
    start(startPos, targetPos, duration) {
        if (!startPos || !targetPos) return;
        
        // If already interpolating, use current interpolated position as start
        if (this.isActive && this.lastInterpolatedPosition) {
            startPos = this.lastInterpolatedPosition;
        }
        
        this.startPosition = { ...startPos };
        this.targetPosition = { ...targetPos };
        this.startTime = performance.now();
        this.duration = duration;
        this.isActive = true;
    }
    
    update() {
        if (!this.isActive) return null;
        
        const now = performance.now();
        const elapsed = now - this.startTime;
        
        if (elapsed >= this.duration) {
            this.isActive = false;
            this.lastInterpolatedPosition = this.targetPosition;
            return this.targetPosition;
        }
        
        // Calculate progress with improved easing
        const t = elapsed / this.duration;
        const easedT = this.easeOutCubic(t);
        
        // Interpolate position
        const interpolatedPosition = {
            lat: this.startPosition.lat + (this.targetPosition.lat - this.startPosition.lat) * easedT,
            lng: this.startPosition.lng + (this.targetPosition.lng - this.startPosition.lng) * easedT,
            accuracy: this.targetPosition.accuracy,
            heading: this.interpolateHeading(this.startPosition.heading, this.targetPosition.heading, easedT),
            timestamp: now,
            speedMPS: this.targetPosition.speedMPS
        };
        
        this.lastInterpolatedPosition = interpolatedPosition;
        return interpolatedPosition;
    }
    
    // Improved heading interpolation that handles the 0/360 boundary
    interpolateHeading(start, end, t) {
        if (start === undefined || end === undefined || start === null || end === null) {
            return end;
        }
        
        // Normalize headings to 0-360
        start = ((start % 360) + 360) % 360;
        end = ((end % 360) + 360) % 360;
        
        // Find the shortest path
        let diff = end - start;
        if (diff > 180) diff -= 360;
        if (diff < -180) diff += 360;
        
        // Calculate interpolated heading
        let result = start + diff * t;
        
        // Normalize result
        return ((result % 360) + 360) % 360;
    }
    
    // Improved cubic easing function for smoother motion
    easeOutCubic(t) {
        return 1 - Math.pow(1 - t, 3);
    }
    
    isInterpolating() {
        return this.isActive;
    }
    
    cancel() {
        this.isActive = false;
    }
}

// Create Kalman filter instance
const kalmanFilter = new KalmanFilter();

// Create position interpolator
positionInterpolator = new PositionInterpolator();

const domUpdateManager = {
    updates: new Map(),
    scheduled: false,
    maxUpdates: 100, // Limit the number of updates to prevent memory bloat

    // Schedule a DOM update with optional priority
    schedule(id, updateFn, priority = 0) {
        // Enforce size limit
        if (this.updates.size >= this.maxUpdates) {
            console.warn("DOM update limit reached, skipping update for:", id);
            return;
        }

        // Store the update with its priority
        this.updates.set(id, { updateFn, priority });

        // Schedule a flush if not already scheduled
        if (!this.scheduled) {
            this.scheduled = true;
            requestAnimationFrame(() => this.flush());
        }
    },

    // Flush all scheduled DOM updates
    flush() {
        try {
            // Convert updates to an array and sort by priority (higher priority first)
            const sortedUpdates = Array.from(this.updates.values())
                .sort((a, b) => b.priority - a.priority);

            // Execute updates
            sortedUpdates.forEach(({ updateFn }) => {
                try {
                    updateFn();
                } catch (error) {
                    console.error("Error executing DOM update:", error);
                }
            });
        } catch (error) {
            console.error("Error during DOM update flush:", error);
        } finally {
            // Clear updates and reset state
            this.updates.clear();
            this.scheduled = false;
        }
    },

    // Cancel a scheduled update by ID
    cancel(id) {
        this.updates.delete(id);
    },

    // Clear all pending updates
    clear() {
        this.updates.clear();
        this.scheduled = false;
    }
};
        
// Update the calculateZoomLevel function to make zoom level dynamic based on speed
function calculateZoomLevel(speedMPS) {
   // Update current speed for global access
   currentSpeed = speedMPS;
   
   // When the user is stationary or at walking speed, use maximum zoom (18)
   if (isStationary || speedMPS < WALKING_SPEED_THRESHOLD) {
       return MAX_ZOOM_LEVEL; // 18
   } 
   
   // For speeds between walking and driving, smoothly interpolate between zoom levels
   if (speedMPS < DRIVING_SPEED_THRESHOLD) {
       // Linear interpolation between MAX_ZOOM_LEVEL (18) and MIN_ZOOM_LEVEL (14)
       const t = (speedMPS - WALKING_SPEED_THRESHOLD) / (DRIVING_SPEED_THRESHOLD - WALKING_SPEED_THRESHOLD);
       return MAX_ZOOM_LEVEL - t * (MAX_ZOOM_LEVEL - MIN_ZOOM_LEVEL);
   }
   
   // For high speeds (driving), use minimum zoom (14)
   return MIN_ZOOM_LEVEL;
}

// Enhanced stationary position calculation
function calculateStationaryPosition(buffer) {
    if (!buffer || buffer.length === 0) {
        return null;
    }
    
    // Sort by accuracy (best first)
    const sortedBuffer = [...buffer].sort((a, b) => a.accuracy - b.accuracy);
    
    // Take weighted average of best positions
    const topPositions = sortedBuffer.slice(0, Math.ceil(buffer.length / 2));
    
    const weights = topPositions.map(pos => 1 / Math.max(1, pos.accuracy));
    const totalWeight = weights.reduce((sum, w) => sum + w, 0);
    
    if (totalWeight === 0) {
        return sortedBuffer[0];
    }
    
    // Calculate weighted average
    const avgPosition = {
        lat: topPositions.reduce((sum, pos, i) => sum + pos.lat * weights[i], 0) / totalWeight,
        lng: topPositions.reduce((sum, pos, i) => sum + pos.lng * weights[i], 0) / totalWeight,
        accuracy: topPositions[0].accuracy,
        heading: topPositions[0].heading,
        timestamp: Date.now(),
        speedMPS: 0
    };
    
    // If we have a previous stationary position, blend with it for stability
    if (lastStationaryPosition) {
        // Increased to 99% previous, 1% new for extreme stability when stationary
        const blendFactor = 0.99; 
        return {
            lat: lastStationaryPosition.lat * blendFactor + avgPosition.lat * (1 - blendFactor),
            lng: lastStationaryPosition.lng * blendFactor + avgPosition.lng * (1 - blendFactor),
            accuracy: avgPosition.accuracy,
            heading: avgPosition.heading,
            timestamp: avgPosition.timestamp,
            speedMPS: 0
        };
    }
    
    return avgPosition;
}

// Update stationary position history
function updateStationaryHistory(position) {
    // Add new position to history
    stationaryPositionHistory.push(position);
    
    // Keep history at maximum size
    while (stationaryPositionHistory.length > STATIONARY_POSITION_HISTORY_SIZE) {
        stationaryPositionHistory.shift();
    }
    
    // Calculate weighted average of positions
    let totalWeight = 0;
    let weightedLat = 0;
    let weightedLng = 0;
    
    // Newer positions have higher weight
    for (let i = 0; i < stationaryPositionHistory.length; i++) {
        const pos = stationaryPositionHistory[i];
        const weight = Math.pow(STATIONARY_POSITION_WEIGHT_DECAY, stationaryPositionHistory.length - i - 1);
        totalWeight += weight;
        weightedLat += pos.lat * weight;
        weightedLng += pos.lng * weight;
    }
    
    return {
        lat: weightedLat / totalWeight,
        lng: weightedLng / totalWeight,
        accuracy: position.accuracy,
        heading: position.heading,
        timestamp: position.timestamp,
        speedMPS: 0
    };
}

// Check if device is in motion based on motion sensors
function isDeviceInMotion() {
    if (!motionSamples || motionSamples.length < 3) {
        return false;
    }
    
    // Calculate average motion magnitude
    const avgMotion = motionSamples.reduce((sum, sample) => {
        return sum + Math.sqrt(
            sample.x * sample.x + 
            sample.y * sample.y + 
            sample.z * sample.z
        );
    }, 0) / motionSamples.length;
    
    return avgMotion > MOTION_THRESHOLD;
}

// Process device motion data
function handleDeviceMotion(event) {
    if (!event || !event.acceleration) return;
    
    const motion = {
        x: event.acceleration.x || 0,
        y: event.acceleration.y || 0,
        z: event.acceleration.z || 0,
        timestamp: Date.now()
    };
    
    // Add to motion samples
    motionSamples.push(motion);
    
    // Keep only recent samples
    while (motionSamples.length > MOTION_SAMPLE_SIZE) {
        motionSamples.shift();
    }
    
    // Update device motion state
    deviceMotion = motion;
    
    // Check if device is stationary based on motion
    const inMotion = isDeviceInMotion();
    
    if (!inMotion) {
        deviceStationaryTime += MOTION_CHECK_INTERVAL;
    } else {
        deviceStationaryTime = 0;
    }
}

// Process device orientation data
function handleDeviceOrientation(event) {
    if (!event || event.alpha === null) return;
    
    deviceOrientation = {
        alpha: event.alpha, // z-axis rotation [0,360)
        beta: event.beta,   // x-axis rotation [-180,180)
        gamma: event.gamma, // y-axis rotation [-90,90)
        timestamp: Date.now()
    };
    
    // Update heading buffer if we have a compass heading
    if (event.webkitCompassHeading !== undefined) {
        const heading = event.webkitCompassHeading;
        
        // Add to heading buffer
        headingBuffer.push(heading);
        
        // Keep only recent headings
        while (headingBuffer.length > 5) {
            headingBuffer.shift();
        }
        
        // Calculate median heading to filter outliers
        if (headingBuffer.length >= 3) {
            const sortedHeadings = [...headingBuffer].sort((a, b) => a - b);
            lastHeadingValue = sortedHeadings[Math.floor(sortedHeadings.length / 2)];
        }
    }
}

// Request device motion and orientation permissions
function requestMotionPermission() {
    if (typeof DeviceMotionEvent !== 'undefined' && 
        typeof DeviceMotionEvent.requestPermission === 'function') {
        
        DeviceMotionEvent.requestPermission()
            .then(response => {
                if (response === 'granted') {
                    window.addEventListener('devicemotion', handleDeviceMotion, true);
                }
            })
            .catch(console.error);
    } else {
        window.addEventListener('devicemotion', handleDeviceMotion, true);
    }
    
    if (typeof DeviceOrientationEvent !== 'undefined' && 
        typeof DeviceOrientationEvent.requestPermission === 'function') {
        
        DeviceOrientationEvent.requestPermission()
            .then(response => {
                if (response === 'granted') {
                    orientationPermissionGranted = true;
                    window.addEventListener('deviceorientation', handleDeviceOrientation, true);
                }
            })
            .catch(console.error);
    } else {
        window.addEventListener('deviceorientation', handleDeviceOrientation, true);
        orientationPermissionGranted = true;
    }
}

// Image preloading function with improved batching
function preloadImages(locationsData) {
    return new Promise((resolve) => {
        if (!locationsData || locationsData.length === 0) {
            resolve();
            return;
        }
        
        const totalImages = locationsData.length;
        let loadedImages = 0;
        const progressBar = document.getElementById('preloaderProgress');
        
        // Create preload queue
        let imagePreloadQueue = locationsData.filter(location => location.image && !preloadedImages.has(location.image))
            .map(location => location.image);
        
        // Also queue audio files
        let audioPreloadQueue = locationsData.filter(location => location.audio && !preloadedAudio.has(location.audio))
            .map(location => location.audio);
        
        // Start preloading
        let preloadStartTime = Date.now();
        let isPreloading = true;
        let preloadBatchSize = 5;
        
        // Process next batch
        function processNextBatch() {
            if (imagePreloadQueue.length === 0 && audioPreloadQueue.length === 0) {
                isPreloading = false;
                resolve();
                return;
            }
            
            // Process image batch
            const imageBatch = imagePreloadQueue.splice(0, preloadBatchSize);
            
            // Load images in batch
            Promise.all(imageBatch.map(imageUrl => {
                return new Promise((resolveImage) => {
                    const img = new Image();
                    img.crossOrigin = "anonymous"; // Set crossOrigin for canvas operations
                    
                    img.onload = function() {
                        preloadedImages.set(imageUrl, img);
                        loadedImages++;
                        updateProgress();
                        resolveImage();
                    };
                    
                    img.onerror = function() {
                        console.warn(`Failed to load image: ${imageUrl}`);
                        loadedImages++;
                        updateProgress();
                        resolveImage();
                    };
                    
                    img.src = imageUrl;
                });
            })).then(() => {
                // Process audio batch
                const audioBatch = audioPreloadQueue.splice(0, preloadBatchSize);
                
                // Load audio in batch
                return Promise.all(audioBatch.map(audioUrl => {
                    return new Promise((resolveAudio) => {
                        const audio = new Audio();
                        audio.preload = 'auto';
                        
                        audio.oncanplaythrough = () => {
                            preloadedAudio.set(audioUrl, audio);
                            resolveAudio();
                        };
                        
                        audio.onerror = () => {
                            console.warn(`Failed to load audio: ${audioUrl}`);
                            resolveAudio();
                        };
                        
                        audio.src = audioUrl;
                    });
                }));
            }).then(() => {
                // Continue with next batch after a small delay to prevent UI blocking
                setTimeout(processNextBatch, 10);
            }).catch(error => {
                console.error("Error preloading batch:", error);
                setTimeout(processNextBatch, 10);
            });
        }
        
        function updateProgress() {
            const percent = (loadedImages / totalImages) * 100;
            domUpdateManager.schedule('preloaderProgress', () => {
                progressBar.style.width = `${percent}%`;
            });
        }
        
        // Start processing batches
        processNextBatch();
    });
}

// Detect sudden movements or position jumps
function detectSuddenMovement(newPosition, lastPosition) {
    if (!lastPosition || !newPosition) return false;
    
    const distance = calculateDistance(lastPosition, newPosition);
    const timeDelta = (newPosition.timestamp - lastPosition.timestamp) / 1000; // seconds
    
    // If time delta is too small, consider it a valid update
    if (timeDelta < 0.05) return false;
    
    // Calculate speed in meters per second
    const speed = distance / timeDelta;
    
    // Check for unrealistic speeds (teleportation)
    if (speed > 50) { // 50 m/s is about 112 mph
        console.log(`Position jump detected: ${distance.toFixed(2)}m in ${timeDelta.toFixed(2)}s (${speed.toFixed(2)} m/s)`);
        return true;
    }
    
    // Check for sudden movements when stationary
    if (isStationary && distance > POSITION_JUMP_THRESHOLD) {
        console.log(`Sudden movement detected while stationary: ${distance.toFixed(2)}m`);
        return true;
    }
    
    // Check for small sudden movements (jitter)
    if (isStationary && distance > SUDDEN_MOVEMENT_THRESHOLD) {
        suddenMovementCount++;
        if (suddenMovementCount >= 2) {
            console.log(`Multiple sudden movements detected: ${distance.toFixed(2)}m`);
            return true;
        }
    } else {
        suddenMovementCount = 0;
    }
    
    return false;
}

// Check proximity to locations and adjust zoom accordingly
function checkLocationProximity() {
    const now = Date.now();
    
    // Don't check too frequently
    if (now - lastProximityCheck < 1000) return;
    lastProximityCheck = now;
    
    // Don't check if zoom was recently changed
    if (now - lastZoomChangeTime < ZOOM_CHANGE_COOLDOWN) return;
    
    if (!userMarker || !gameLocations || gameLocations.length === 0) return;
    
    const userLatLng = userMarker.getLatLng();
    const userPos = { lat: userLatLng.lat, lng: userLatLng.lng };
    
    // Find closest location
    let closestDistance = Infinity;
    let closestLocation = null;
    
    for (const location of gameLocations) {
        if (!location || typeof location.lat !== 'number' || typeof location.lng !== 'number') continue;
        
        const locationPos = { lat: location.lat, lng: location.lng };
        const distance = calculateDistance(userPos, locationPos);
        
        if (isFinite(distance) && distance < closestDistance) {
            closestDistance = distance;
            closestLocation = location;
        }
    }
    
    // Convert to feet for threshold comparison
    const distanceFeet = Math.round(closestDistance * 3.28084);

    // Constants for hysteresis and thresholds
    const HYSTERESIS_FACTOR = 1.1; // 10% buffer to prevent rapid toggling
    const ZOOM_IN_THRESHOLD = PROXIMITY_THRESHOLD * 0.9; // 90% of PROXIMITY_THRESHOLD
    const ZOOM_OUT_THRESHOLD = PROXIMITY_THRESHOLD * 1.1; // 110% of PROXIMITY_THRESHOLD

    // Check if we need to adjust zoom based on proximity
    if (distanceFeet <= ZOOM_IN_THRESHOLD) {
        // If we weren't near a location before, zoom in
        if (!isNearLocation && Math.abs(lastProximityDistance - closestDistance) > 1) {
            console.log(`User is now within ${ZOOM_IN_THRESHOLD.toFixed(1)} feet of a location, zooming in`);
            isNearLocation = true;
            lastZoomChangeTime = now;

            // Calculate new zoom level (clamped to MAX_ZOOM_LEVEL)
            const currentZoom = map.getZoom();
            const newZoom = Math.min(currentZoom + 1, MAX_ZOOM_LEVEL);

            // Apply zoom change with smooth animation
            map.setZoom(newZoom, {
                animate: true,
                duration: ZOOM_TRANSITION_DURATION
            });
        }
    } else if (distanceFeet >= ZOOM_OUT_THRESHOLD && isNearLocation) {
        // If we were near a location but now we're not, zoom out
        console.log(`User is now outside ${ZOOM_OUT_THRESHOLD.toFixed(1)} feet of a location, zooming out`);
        isNearLocation = false;
        lastZoomChangeTime = now;

        // Calculate new zoom level (clamped to MIN_ZOOM_LEVEL)
        const currentZoom = map.getZoom();
        const newZoom = Math.max(currentZoom - 1, MIN_ZOOM_LEVEL);

        // Apply zoom change with smooth animation
        map.setZoom(newZoom, {
            animate: true,
            duration: ZOOM_TRANSITION_DURATION
        });
    }
    
    // Update last proximity distance
    lastProximityDistance = closestDistance;
}

// Enhance the shouldRecenter function to ensure user icon stays on screen
function shouldRecenter(map, marker) {
  const now = Date.now();
  if (now - lastRecenterTime < RECENTER_COOLDOWN) {
      return { needsRecenter: false };
  }
  
  if (!map || !marker) return { needsRecenter: false };
  
  const edgeInfo = isMarkerNearEdge(map, marker);
  const proximities = edgeInfo.proximities;
  
  // Check for critical edge proximity (very close to edge)
  const isCritical = Object.values(proximities).some(
      proximity => proximity < CRITICAL_EDGE_THRESHOLD
  );
  
  if (isCritical) {
      lastRecenterTime = now;
      return {
          needsRecenter: true,
          isEmergency: true,
          edgeInfo: edgeInfo
      };
  }
  
  // Check for normal edge proximity
  if (edgeInfo.isNearEdge) {
      lastRecenterTime = now;
      return {
          needsRecenter: true,
          isEmergency: false,
          edgeInfo: edgeInfo
      };
  }
  
  return {
      needsRecenter: false,
      isEmergency: false,
      edgeInfo: edgeInfo
  };
}

// Check if marker is near the edge of the map viewport
function isMarkerNearEdge(map, marker) {
  const mapBounds = map.getBounds();
  const markerLatLng = marker.getLatLng();
  
  // Get map bounds
  const northLat = mapBounds.getNorth();
  const southLat = mapBounds.getSouth();
  const eastLng = mapBounds.getEast();
  const westLng = mapBounds.getWest();
  
  // Calculate total lat/lng span
  const latSpan = northLat - southLat;
  const lngSpan = eastLng - westLng;
  
  // Calculate edge thresholds
  const northThreshold = northLat - (latSpan * EDGE_THRESHOLD_PERCENTAGE);
  const southThreshold = southLat + (latSpan * EDGE_THRESHOLD_PERCENTAGE);
  const eastThreshold = eastLng - (lngSpan * EDGE_THRESHOLD_PERCENTAGE);
  const westThreshold = westLng + (lngSpan * EDGE_THRESHOLD_PERCENTAGE);
  
  // Check if marker is near any edge
  const isNearNorth = markerLatLng.lat > northThreshold;
  const isNearSouth = markerLatLng.lat < southThreshold;
  const isNearEast = markerLatLng.lng > eastThreshold;
  const isNearWest = markerLatLng.lng < westThreshold;
  
  // Calculate proximity to each edge (0-1, where 0 is at the edge)
  const northProximity = (northLat - markerLatLng.lat) / (latSpan * EDGE_THRESHOLD_PERCENTAGE);
  const southProximity = (markerLatLng.lat - southLat) / (latSpan * EDGE_THRESHOLD_PERCENTAGE);
  const eastProximity = (eastLng - markerLatLng.lng) / (lngSpan * EDGE_THRESHOLD_PERCENTAGE);
  const westProximity = (markerLatLng.lng - westLng) / (lngSpan * EDGE_THRESHOLD_PERCENTAGE);
  
  return {
      isNearEdge: isNearNorth || isNearSouth || isNearEast || isNearWest,
      isNearNorth,
      isNearSouth,
      isNearEast,
      isNearWest,
      proximities: {
          north: isNearNorth ? northProximity : 1,
          south: isNearSouth ? southProximity : 1,
          east: isNearEast ? eastProximity : 1,
          west: isNearWest ? westProximity : 1
      }
  };
}

// Optimize the performEdgeRecenter function to center the user icon properly
function performEdgeRecenter(recenterInfo) {
  edgeRecenterInProgress = true;
  
  // Get current position
  const position = userMarker.getLatLng();
  
  // Calculate appropriate zoom level based on speed
  const dynamicZoom = calculateZoomLevel(lastPosition?.speedMPS || 0);
  
  // Calculate optimal center point that keeps the user icon in the center of the screen
  const optimalCenter = calculateOptimalCenter(map, position, recenterInfo.edgeInfo);
  
  // Set view with animation
  map.setView([optimalCenter.lat, optimalCenter.lng], dynamicZoom, {
      animate: true,
      duration: recenterInfo.isEmergency ? 0.2 : ZOOM_TRANSITION_DURATION,
      noMoveStart: true,
      easeLinearity: 0.5
  });
  
  // Reset edge recenter flag after animation completes
  setTimeout(() => {
      edgeRecenterInProgress = false;
  }, recenterInfo.isEmergency ? 300 : ZOOM_TRANSITION_DURATION * 1000);
}

// Calculate optimal center point to keep user icon away from edges
function calculateOptimalCenter(map, position, edgeInfo) {
  if (!map || !position || !edgeInfo) {
    return position;
  }
  
  // Get current map bounds and center
  const bounds = map.getBounds();
  const currentCenter = map.getCenter();
  
  // Get viewport dimensions
  const viewportWidth = mapViewportWidth || map._container.clientWidth;
  const viewportHeight = mapViewportHeight || map._container.clientHeight;
  
  // Calculate lat/lng per pixel
  const latPerPixel = (bounds.getNorth() - bounds.getSouth()) / viewportHeight;
  const lngPerPixel = (bounds.getEast() - bounds.getWest()) / viewportWidth;
  
  // Calculate target center position (center of the screen)
  const targetLat = position.lat;
  const targetLng = position.lng;
  
  // Return the optimal center point
  return {
    lat: targetLat,
    lng: targetLng
  };
}

function showLoadingMessage() {
    const loadingMessage = document.createElement('div');
    loadingMessage.id = 'loadingMessage';
    loadingMessage.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: rgba(255, 255, 255, 0.9);
        padding: 20px;
        border-radius: 10px;
        z-index: 1000;
        text-align: center;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    `;
    loadingMessage.innerHTML = `
        <div style="margin-bottom: 15px;">
            <div style="width: 40px; height: 40px; border: 4px solid rgba(255, 0, 0, 0.2); border-top: 4px solid #ff0000; border-radius: 50%; margin: 0 auto 15px; animation: spin 1s linear infinite;"></div>
        </div>
        <p style="font-weight: 500; color: #333;">Searching for your location...</p>
    `;
    document.body.appendChild(loadingMessage);
}

function hideLoadingMessage() {
    const loadingMessage = document.getElementById('loadingMessage');
    if (loadingMessage) {
        document.body.removeChild(loadingMessage);
    }
}

function showStabilizingModal() {
    const modal = document.createElement('div');
    modal.id = 'stabilizingModal';
    modal.className = 'stabilizing-modal';
    modal.innerHTML = `
        <div class="spinner"></div>
        <h3>Stabilizing Your Location</h3>
        <p>Please wait while we fine-tune your position.</p>
    `;
    document.body.appendChild(modal);
    
    // Auto-dismiss after 5 seconds
    setTimeout(() => {
        const stabilizingModal = document.getElementById('stabilizingModal');
        if (stabilizingModal) {
            stabilizingModal.style.opacity = '0';
            stabilizingModal.style.transition = 'opacity 0.5s ease';
            setTimeout(() => {
                if (stabilizingModal && stabilizingModal.parentNode) {
                    stabilizingModal.parentNode.removeChild(stabilizingModal);
                }
                isStabilizing = false;
            }, 500);
        }
    }, 5000);
}

function initializeUserLocation(position) {
    console.log("Initial position data:", JSON.stringify(position));

    if (!position || !position.coords) {
        console.error("Invalid initial position object");
        handleLocationError(new Error("Invalid initial position"));
        return;
    }

    const { latitude: userLat, longitude: userLng, accuracy } = position.coords;

    if (isNaN(userLat) || isNaN(userLng)) {
        console.error("Invalid initial coordinates:", { userLat, userLng });
        handleLocationError(new Error("Invalid initial coordinates"));
        return;
    }

    console.log("Valid initial position:", { userLat, userLng, accuracy });

    try {
        userMarker.setLatLng([userLat, userLng]);
        map.setView([userLat, userLng], 18);
        
        // Initialize Kalman filter with first position
        kalmanFilter.reset({
            lat: userLat,
            lng: userLng,
            accuracy: accuracy,
            heading: position.coords.heading,
            timestamp: Date.now()
        });
        
        // Initialize stationary position
        lastStationaryPosition = {
            lat: userLat,
            lng: userLng,
            accuracy: accuracy,
            heading: position.coords.heading,
            timestamp: Date.now(),
            speedMPS: 0
        };
        
        // Initialize last render position
        lastRenderPosition = {
            lat: userLat,
            lng: userLng,
            accuracy: accuracy,
            heading: position.coords.heading,
            timestamp: Date.now(),
            speedMPS: 0
        };
        
        // Initialize last valid position
        lastValidPosition = {
            lat: userLat,
            lng: userLng,
            accuracy: accuracy,
            heading: position.coords.heading,
            timestamp: Date.now(),
            speedMPS: 0
        };
        
        // Show stabilizing modal
        hideLoadingMessage();
        showStabilizingModal();
        
        // Start position updates
        startPositionUpdates();
        startHunt();
        
        // Reset location error count
        locationErrorCount = 0;
        isLocationAvailable = true;
    } catch (error) {
        console.error("Error setting initial user location:", error);
        handleLocationError(error);
    }
}

function startPositionUpdates() {
    // If already using GeolocationSensor API, don't start again
    if (usingGeolocationSensorAPI) {
        console.log('Position updates already using GeolocationSensor API');
        return;
    }
    
    // Use standard Geolocation API
    locationWatchId = navigator.geolocation.watchPosition(
        handlePositionUpdate,
        handleLocationError,
        {
            enableHighAccuracy: true,
            maximumAge: 1000,
            timeout: 10000
        }
    );
    console.log('Position updates using standard Geolocation API');
}

function handlePositionUpdate(position) {
    if (!position?.coords?.latitude || !position?.coords?.longitude) {
        console.warn("Invalid position data received");
        return;
    }
    
    // Reset error counters on successful update
    locationErrorCount = 0;
    isLocationAvailable = true;
    
    // Update GPS confidence score
    if (position.coords.accuracy) {
        const newScore = calculateGpsConfidenceScore(position.coords.accuracy);
        confidenceScoreHistory.push(newScore);
        
        // Keep history at reasonable size
        while (confidenceScoreHistory.length > 5) {
            confidenceScoreHistory.shift();
        }
        
        // Calculate average confidence score
        gpsConfidenceScore = confidenceScoreHistory.reduce((sum, score) => sum + score, 0) / 
                            confidenceScoreHistory.length;
    }
    
    updateUserLocation(position, true);
}

function handleVisibilityChange() {
    if (document.hidden) {
        lastHiddenTime = Date.now();
        lastKnownPosition = userMarker ? userMarker.getLatLng() : null;
        
        // Cancel any active interpolation
        if (positionInterpolator) {
            positionInterpolator.cancel();
        }
        
        // Cancel animation frame
        if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
        }
        
        // Stop GeolocationSensor if using it
        if (usingGeolocationSensorAPI && geolocationSensor) {
            geolocationSensor.stop();
        }
    } else {
        const hiddenDuration = Date.now() - lastHiddenTime;
        if (hiddenDuration > BACKGROUND_THRESHOLD) {
            updateLocationAfterBackground();
        } else {
            map.invalidateSize();
            
            // Restart animation loop
            if (!animationFrameId) {
                startAnimationLoop();
            }
            
            // Restart GeolocationSensor if using it
            if (usingGeolocationSensorAPI && geolocationSensor) {
                geolocationSensor.start();
            }
            
            // If returning from exhibit, ensure movement resumes properly
            if (isReturningFromExhibit) {
                isReturningFromExhibit = false;
                // Force a position update to resume tracking
                if (lastValidPosition) {
                    updateUserLocation({
                        coords: {
                            latitude: lastValidPosition.lat,
                            longitude: lastValidPosition.lng,
                            accuracy: lastValidPosition.accuracy,
                            heading: lastValidPosition.heading,
                            speed: lastValidPosition.speedMPS
                        },
                        timestamp: Date.now()
                    }, true);
                }
            }
        }
    }
    resetInactivityTimer();
}

function updateLocationAfterBackground() {
    if ("geolocation" in navigator) {
        navigator.geolocation.getCurrentPosition(
            (position) => {
                console.log("Background update raw position:", JSON.stringify(position));
                if (!position || !position.coords) {
                    console.warn("Invalid position object in background update");
                    return;
                }
                const { latitude, longitude, accuracy } = position.coords;
                if (isNaN(latitude) || isNaN(longitude)) {
                    console.warn("Invalid coordinates in background update:", { latitude, longitude });
                    return;
                }
                
                console.log("Valid background position update:", { lat: latitude, lng: longitude });
                try {
                    updateUserLocation(position, true);
                } catch (error) {
                    console.error("Error in updateUserLocation during background update:", error);
                }
                
                // Reset tracking variables
                lastPosition = null;
                positionBuffer = [];
                velocity = { lat: 0, lng: 0 };
                lastVelocity = { lat: 0, lng: 0 };
                isStationary = false;
                stationaryStartTime = null;
                stationaryCount = 0;
                stationaryPositionHistory = [];
                lastStationaryPosition = null;
                stationaryPositionLocked = false;
                positionHistory = [];
                suddenMovementCount = 0;
                isJumpDetected = false;
                
                // Reset Kalman filter
                kalmanFilter.reset({
                    lat: latitude,
                    lng: longitude,
                    accuracy: accuracy,
                    heading: position.coords.heading,
                    timestamp: Date.now()
                });
                
                // Restart animation loop
                if (!animationFrameId) {
                    startAnimationLoop();
                }
                
                // Restart GeolocationSensor if using it
                if (usingGeolocationSensorAPI && geolocationSensor) {
                    geolocationSensor.start();
                }
                
                updateDistanceBox();
                followUser = true;
                map.invalidateSize();
            },
            (error) => {
                console.error("Error getting location after background:", error);
                handleLocationError(error);
            },
            {
                enableHighAccuracy: true,
                timeout: 10000,
                maximumAge: 0
            }
        );
    } else {
        console.warn("Geolocation is not available");
        showErrorMessage("Unable to update your location after background. Please reload the app.");
    }
}

// Helper function to validate position data
function isValidPosition(pos) {
    return pos && 
           typeof pos.lat === 'number' && !isNaN(pos.lat) &&
           typeof pos.lng === 'number' && !isNaN(pos.lng) &&
           typeof pos.accuracy === 'number' && !isNaN(pos.accuracy);
}

// Calculate distance between two points using Haversine formula
function calculateDistance(pos1, pos2) {
    if (!pos1 || !pos2 || 
        typeof pos1.lat !== 'number' || typeof pos1.lng !== 'number' || 
        typeof pos2.lat !== 'number' || typeof pos2.lng !== 'number') {
        return Infinity;
    }
    
    const R = 6371000; // Earth's radius in meters
    const lat1 = pos1.lat * Math.PI / 180;
    const lat2 = pos2.lat * Math.PI / 180;
    const deltaLat = (pos2.lat - pos1.lat) * Math.PI / 180;
    const deltaLng = (pos2.lng - pos1.lng) * Math.PI / 180;

    const a = Math.sin(deltaLat/2) * Math.sin(deltaLat/2) +
            Math.cos(lat1) * Math.cos(lat2) *
            Math.sin(deltaLng/2) * Math.sin(deltaLng/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

    return R * c;
}

// Linear interpolation helper
function lerp(a, b, t) {
    if (typeof a !== 'number' || typeof b !== 'number' || typeof t !== 'number') {
        return a;
    }
    
    return a + (b - a) * Math.max(0, Math.min(1, t));
}

// Update position buffer with new position
function updatePositionBuffer(position) {
    if (!isValidPosition(position)) {
        return;
    }
    
    // Add new position to buffer
    positionBuffer.push({
        lat: position.lat,
        lng: position.lng,
        accuracy: position.accuracy,
        heading: position.heading,
        timestamp: position.timestamp,
        speedMPS: position.speedMPS
    });

    // Remove old positions if buffer exceeds maxSize
    while (positionBuffer.length > MAX_BUFFER_SIZE) {
        positionBuffer.shift();
    }
}

// Update position history for jump detection
function updatePositionHistory(position) {
    if (!isValidPosition(position)) {
        return;
    }
    
    // Add new position to history
    positionHistory.push({
        lat: position.lat,
        lng: position.lng,
        accuracy: position.accuracy,
        heading: position.heading,
        timestamp: position.timestamp,
        speedMPS: position.speedMPS
    });
    
    // Keep only recent positions
    while (positionHistory.length > 10) {
        positionHistory.shift();
    }
}

function initializeFirstPosition(newPosition) {
    lastPosition = newPosition;
    lastValidPosition = newPosition;
    userMarker.setLatLng([newPosition.lat, newPosition.lng]);
    kalmanFilter.reset(newPosition);
    lastUpdateTime = newPosition.timestamp;
    stationaryStartTime = newPosition.timestamp;
    positionBuffer = [newPosition];
    positionHistory = [newPosition];
    lastStationaryPosition = newPosition;
    lastRenderPosition = newPosition;

    // Set initial zoom based on stationary state
    const initialZoom = calculateZoomLevel(0);
    map.setView([newPosition.lat, newPosition.lng], initialZoom, { animate: false });
    updateDistanceBox();
}

function handlePositionJump(newPosition) {
    if (isStationary && stationaryPositionLocked) {
        console.log("Position jump detected while stationary, ignoring update");
        isJumpDetected = true;
        return;
    }
}

function handleLargePositionChange(newPosition) {
    resetStationaryState();
    userMarker.setLatLng([newPosition.lat, newPosition.lng]);
    lastPosition = newPosition;
    lastValidPosition = newPosition;
    lastRenderPosition = newPosition;
    positionBuffer = [newPosition];
    positionHistory = [newPosition];
    kalmanFilter.reset(newPosition);
    kalmanFilter.setStationaryMode(false);
    lastVelocity = { lat: 0, lng: 0 };
    lastSmoothedPosition = null;

    if (positionInterpolator) {
        positionInterpolator.cancel();
    }

    const zoomLevel = calculateZoomLevel(newPosition.speedMPS);
    map.setView([newPosition.lat, newPosition.lng], zoomLevel, {
        animate: true,
        duration: 0.3,
        noMoveStart: true
    });

    lastUpdateTime = newPosition.timestamp;
    lastUpdateTimestamp = newPosition.timestamp;
    updateDistanceBox();

    if (map._container) {
        map._onResize();
    }
}

function resetStationaryState() {
    if (stationaryCheckTimeout) {
        clearTimeout(stationaryCheckTimeout);
        stationaryCheckTimeout = null;
    }
    
    if (stationaryLockTimeout) {
        clearTimeout(stationaryLockTimeout);
        stationaryLockTimeout = null;
    }
    
    isStationary = false;
    stationaryStartTime = null;
    stationaryCount = 0;
    stationaryPositionHistory = [];
    lastStationaryPosition = null;

    stationaryPositionLocked = false;
    isJumpDetected = false;
}

function updateStationaryState(newPosition, motionDetected) {
    // Validate input 
    if (!newPosition || !lastPosition) return;

    // Calculate distance from last position 
    const distance = calculateDistance(lastPosition, newPosition);

    // Calculate confidence score for stationary state 
    const accuracyScore = Math.max(0, 1 - (newPosition.accuracy / MAX_ACCEPTABLE_ACCURACY)); // Higher accuracy = higher score 
    const motionScore = motionDetected ? 0 : 1; // No motion = higher score 
    const historyScore = stationaryPositionHistory.length > 5 ? 1 : 0.5; // More history = higher score

    // Combine scores to get overall confidence 
    const stationaryConfidence = (accuracyScore + motionScore + historyScore) / 3;

    // Check if the user is likely stationary 
    if (distance < MICRO_MOVEMENT_THRESHOLD && stationaryConfidence > 0.8) { 
        stationaryCount++;

        // Transition to stationary state if confidence is high and threshold is met 
        if (!isStationary && stationaryCount >= STATIONARY_THRESHOLD) { 
            setStationary(newPosition); 
        } 
    } else { 
        // Decrease stationary count if movement is detected 
        stationaryCount = Math.max(0, stationaryCount - 1);

        // Transition to moving state if confidence drops below a threshold 
        if (isStationary && stationaryCount < STATIONARY_THRESHOLD / 2) { 
            setMoving(); 
        } 
    }

    // Update stationary position history for averaging 
    if (isStationary) { 
        stationaryPositionHistory.push(newPosition); 
        if (stationaryPositionHistory.length > STATIONARY_POSITION_HISTORY_SIZE) { 
            stationaryPositionHistory.shift(); 
        } 
    }
}

function setStationary(newPosition) {
    isStationary = true;
    console.log("User is now stationary");

    // Enable stationary mode in Kalman filter
    kalmanFilter.setStationaryMode(true);
    stationaryStartTime = newPosition.timestamp;

    // Add new position to stationary history
    updateStationaryPositionHistory(newPosition);

    // Calculate stable position using weighted average
    const stablePosition = calculateStationaryWeightedAverage() || newPosition;

    if (stablePosition) {
        // Update position queue and state
        positionUpdateQueue.push(stablePosition);
        lastPosition = stablePosition;
        lastValidPosition = stablePosition;
        lastStationaryPosition = stablePosition;

        // Lock the stationary position after a short delay
        stationaryLockTimeout = setTimeout(() => {
            stationaryPositionLocked = true;
            stationaryPositionLockTime = Date.now();
            console.log("Stationary position locked after delay");

            // Lock the position in the Kalman filter
            kalmanFilter.lockStationaryPosition(lastStationaryPosition);
        }, 3000); // 3-second delay before locking
    }

    // Adjust map zoom if following the user
    if (followUser && !isMapInteracting) {
        const stationaryZoom = calculateZoomLevel(0);
        map.setZoom(stationaryZoom, {
            animate: true,
            duration: ZOOM_TRANSITION_DURATION
        });
    }

    // Update the distance box
    updateDistanceBox();
}

function updateStationaryPositionHistory(newPosition) {
    stationaryPositionHistory.push(newPosition);
    if (stationaryPositionHistory.length > STATIONARY_POSITION_HISTORY_SIZE) {
        stationaryPositionHistory.shift();
    }
}

function calculateStationaryWeightedAverage() {
    if (stationaryPositionHistory.length === 0) return null;

    let totalWeight = 0;
    let weightedLat = 0;
    let weightedLng = 0;

    // Calculate weighted average
    stationaryPositionHistory.forEach((pos, index) => {
        const weight = Math.pow(0.8, stationaryPositionHistory.length - index); // Exponential decay
        totalWeight += weight;
        weightedLat += pos.lat * weight;
        weightedLng += pos.lng * weight;
    });

    return {
        lat: weightedLat / totalWeight,
        lng: weightedLng / totalWeight,
        accuracy: stationaryPositionHistory[stationaryPositionHistory.length - 1].accuracy, // Use latest accuracy
        timestamp: Date.now(),
    };
}
        
function setMoving() {
    isStationary = false;
    stationaryPositionLocked = false;
    kalmanFilter.setStationaryMode(false);

    if (stationaryLockTimeout) {
        clearTimeout(stationaryLockTimeout);
        stationaryLockTimeout = null;
    }

    console.log("User is moving again");
    
    // Update zoom level based on current speed if following user
    if (followUser && !isMapInteracting && lastPosition) {
        const dynamicZoom = calculateZoomLevel(lastPosition.speedMPS);
        if (Math.abs(map.getZoom() - dynamicZoom) > 0.5) {
            map.setZoom(dynamicZoom, {
                animate: true,
                duration: ZOOM_TRANSITION_DURATION
            });
        }
    }
}

function checkStationaryState(newPosition) {
  if (!lastPosition) return;
  
  // Calculate distance between current and last position
  const distance = calculateDistance(lastPosition, newPosition);
  
  // Check if device motion sensors indicate movement
  const motionDetected = isDeviceInMotion();
  
  // If significant movement is detected or motion sensors indicate activity
  if (distance >= MICRO_MOVEMENT_THRESHOLD || motionDetected) {
    if (isStationary) {
      console.debug("Movement detected, transitioning to moving state");
      setMoving();
    }
    
    // Clear the stationary check timeout
    if (stationaryCheckTimeout) {
      clearTimeout(stationaryCheckTimeout);
      stationaryCheckTimeout = null;
    }
  } else {
    // If no significant movement, increment stationary count
    stationaryCount++;
    
    // If stationary count exceeds threshold, transition to stationary state
    if (!isStationary && stationaryCount >= STATIONARY_THRESHOLD) {
      setStationary(newPosition);
    }
    
    // Schedule the next stationary check
    if (isStationary && !stationaryCheckTimeout) {
      stationaryCheckTimeout = setTimeout(() => {
        stationaryCheckTimeout = null;
        checkStationaryState(newPosition);
      }, STATIONARY_CHECK_INTERVAL);
    }
  }
}

// Calculate GPS confidence score based on accuracy
function calculateGpsConfidenceScore(accuracy) {
    if (!accuracy || accuracy <= 0) return 0.5;
    
    // Higher accuracy (lower value) = higher confidence
    if (accuracy <= GPS_CONFIDENCE_THRESHOLD_HIGH) {
        return 1.0; // High confidence
    } else if (accuracy <= GPS_CONFIDENCE_THRESHOLD_MEDIUM) {
        // Linear interpolation between high and medium thresholds
        return 0.7 + 0.3 * (GPS_CONFIDENCE_THRESHOLD_MEDIUM - accuracy) / 
                          (GPS_CONFIDENCE_THRESHOLD_MEDIUM - GPS_CONFIDENCE_THRESHOLD_HIGH);
    } else {
        // Exponential decay for low confidence
        return Math.max(0.1, 0.7 * Math.exp(-0.05 * (accuracy - GPS_CONFIDENCE_THRESHOLD_MEDIUM)));
    }
}

// Start animation loop for smooth rendering
function startAnimationLoop() {
    if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
    }
    
    function animate(timestamp) {
        // Store render timestamp
        renderTimestamp = timestamp;
        
        // Process position update queue
        while (positionUpdateQueue.length > 0) {
            const position = positionUpdateQueue.shift();
            renderPosition(position);
        }
        
        // Update position interpolation if active
        if (positionInterpolator && positionInterpolator.isInterpolating()) {
            const interpolatedPosition = positionInterpolator.update();
            if (interpolatedPosition) {
                renderPosition(interpolatedPosition, true);
            }
        }
        
        // Check if we need to recenter the map
        if (followUser && !isMapInteracting && !edgeRecenterInProgress) {
            const now = Date.now();
            
            // Only check edge proximity periodically to reduce CPU usage
            if (now - lastEdgeCheck > edgeCheckInterval) {
                lastEdgeCheck = now;
                
                const recenterInfo = shouldRecenter(map, userMarker);
                if (recenterInfo.needsRecenter) {
                    performEdgeRecenter(recenterInfo);
                }
            }
        }
        
        // Check proximity to locations
        checkLocationProximity();
        
        // Schedule next frame
        animationFrameId = requestAnimationFrame(animate);
    }
    
    // Start animation loop
    animationFrameId = requestAnimationFrame(animate);
}

// Render position update
function renderPosition(position, isInterpolated = false) {
    if (!position || !isValidPosition(position)) {
        return;
    }
    
    // Update user marker position
    userMarker.setLatLng([position.lat, position.lng]);
    
    // Update marker rotation if heading is available
    if (position.heading !== null && position.heading !== undefined) {
        const markerIcon = userMarker._icon;
        if (markerIcon) {
            const iconContainer = markerIcon.querySelector('.user-marker-icon');
            if (iconContainer) {
                iconContainer.style.transform = `rotate(${position.heading}deg)`;
            }
        }
    }
    
    // If following user and not interpolated, update map center
    if (followUser && !isMapInteracting && !isInterpolated && !edgeRecenterInProgress) {
        // Only update map if position has changed significantly
        const mapCenter = map.getCenter();
        const distance = calculateDistance(
            { lat: mapCenter.lat, lng: mapCenter.lng },
            { lat: position.lat, lng: position.lng }
        );
        
        // Throttle map updates to improve performance
        const now = Date.now();
        if (distance > 1 && now - lastMapUpdate > mapUpdateThrottleInterval) {
            lastMapUpdate = now;
            
            // Use panTo for smoother movement
            map.panTo([position.lat, position.lng], {
                animate: true,
                duration: 0.25,
                easeLinearity: 0.5,
                noMoveStart: true
            });
        }
    }
    
    // Store last render position
    lastRenderPosition = position;
}

// Show error message
function showErrorMessage(message) {
    // Remove any existing error messages
    const existingErrors = document.querySelectorAll('.error-message');
    existingErrors.forEach(error => {
        if (error.parentNode) {
            error.parentNode.removeChild(error);
        }
    });
    
    // Create new error message
    const errorMessage = document.createElement('div');
    errorMessage.className = 'error-message';
    errorMessage.textContent = message;
    document.body.appendChild(errorMessage);
    
    // Auto-remove after animation completes
    setTimeout(() => {
        if (errorMessage.parentNode) {
            errorMessage.parentNode.removeChild(errorMessage);
        }
    }, 5000);
}

const MAX_RETRIES = 3;
const RETRY_DELAY = 1000;

function getGeolocationOptions(retryNumber) {
    return {
        enableHighAccuracy: retryNumber < 2,
        timeout: 10000 + (retryNumber * 5000),
        maximumAge: retryNumber * 5000
    };
}

function handleLocationError(error) {
    console.warn("Error getting user location:", error);
    locationErrorCount++;
    
    // Check if we've reached the maximum number of retries
    if (retryCount < MAX_RETRIES) {
        retryCount++;
        console.log(`Retrying to get location (Attempt ${retryCount} of ${MAX_RETRIES})`);
        
        setTimeout(() => {
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    console.log("Location retrieved successfully after retry");
                    hideLoadingMessage();
                    updateUserLocation(position, true);
                    retryCount = 0;
                    locationErrorCount = 0;
                },
                handleLocationError,
                getGeolocationOptions(retryCount)
            );
        }, RETRY_DELAY);
        return;
    }
    
    retryCount = 0;
    hideLoadingMessage();
    
    // If we've had multiple errors, mark location as unavailable
    if (locationErrorCount > 3) {
        isLocationAvailable = false;
    }
    
    let errorMessage = "An error occurred while getting your location.";
    if (error && error.code) {
        switch(error.code) {
            case PERMISSION_DENIED_ERROR:
                errorMessage = "Please allow access to your location to use this feature.";
                permissionDenied = true;
                handleLocationPermissionDenied();
                break;
            case POSITION_UNAVAILABLE_ERROR:
                errorMessage = "Your location is currently unavailable. Please check your GPS signal and try again.";
                showErrorMessage(errorMessage);
                
                // Update GPS signal indicator
                domUpdateManager.schedule('accuracyIndicator', () => {
                    const indicator = document.getElementById('accuracyIndicator');
                    const dot = indicator.querySelector('.accuracy-dot');
                    const text = document.getElementById('accuracyText');
                    
                    dot.classList.remove('accuracy-high', 'accuracy-medium');
                    dot.classList.add('accuracy-low');
                    text.textContent = 'GPS: Signal Lost';
                });
                break;
            case TIMEOUT_ERROR:
                errorMessage = "Getting your location took too long. Please check your GPS signal and try again.";
                showErrorMessage(errorMessage);
                break;
            default:
                showErrorMessage(errorMessage);
                break;
        }
    } else {
        showErrorMessage(errorMessage);
    }
    
    // Try to continue with last known position if available
    if (lastValidPosition) {
        console.log("Using last valid position due to location error");
        userMarker.setLatLng([lastValidPosition.lat, lastValidPosition.lng]);
        updateDistanceBox();
    }
}   

function showPopup(title, message, type = 'info', callback = null) {
    const popup = document.createElement('div');
    popup.classList.add('popup');
    popup.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: white;
        padding: 20px;
        border-radius: 10px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        z-index: 2000;
        text-align: center;
        max-width: 80%;
    `;

    const titleElement = document.createElement('h3');
    titleElement.textContent = title;
    titleElement.style.cssText = `
        margin-bottom: 10px;
        font-size: 18px;
        font-weight: bold;
    `;

    const messageElement = document.createElement('p');
    messageElement.textContent = message;
    messageElement.style.cssText = `
        margin-bottom: 20px;
        font-size: 16px;
    `;

    const buttonContainer = document.createElement('div');
    buttonContainer.style.cssText = `
        display: flex;
        justify-content: center;
        gap: 10px;
    `;

    const okButton = document.createElement('button');
    okButton.textContent = 'OK';
    okButton.style.cssText = `
        padding: 10px 20px;
        background-color: #0f2bab;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
    `;

    okButton.addEventListener('click', () => {
        document.body.removeChild(popup);
        if (callback) callback();
    });

    buttonContainer.appendChild(okButton);

    if (type === 'info') {
        const cancelButton = document.createElement('button');
        cancelButton.textContent = 'Cancel';
        cancelButton.style.cssText = `
            padding: 10px 20px;
            background-color: #ccc;
            color: black;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        `;

        cancelButton.addEventListener('click', () => {
            document.body.removeChild(popup);
        });

        buttonContainer.appendChild(cancelButton);
    }

    popup.appendChild(titleElement);
    popup.appendChild(messageElement);
    popup.appendChild(buttonContainer);
    document.body.appendChild(popup);
}

function recenterMap() {
    const recenterButton = document.getElementById('recenterButton');
    recenterButton.style.backgroundColor = '#0f2bab';
    recenterButton.style.color = 'white';
    
    // Force map to center on user marker immediately
    if (userMarker && userMarker.getLatLng()) {
        map.closePopup();
        
        // Get dynamic zoom level based on current speed
        const dynamicZoom = calculateZoomLevel(currentSpeed);
        
        // Use flyTo instead of setView for smoother animation
        map.flyTo(userMarker.getLatLng(), dynamicZoom, {
            duration: 0.5
        });
        
        followUser = true;
        
        // Make sure any other code knows the map has been recentered
        if (typeof onMapRecentered === 'function') {
            onMapRecentered();
        }
    }
    
    setTimeout(() => {
        recenterButton.style.backgroundColor = 'white';
        recenterButton.style.color = '#0f2bab';
    }, 500);
}

function addUIEventListeners() {
    document.getElementById('recenterButton').addEventListener('click', () => {
        recenterMap();
        resetInactivityTimer();
    });
    document.getElementById('returnButton').addEventListener('click', () => {
        returnToIndex();
        resetInactivityTimer();
    });
    document.getElementById('tipsButton').addEventListener('click', () => {
        toggleNavigationTips();
        resetInactivityTimer();
    });
    document.querySelector('.navigation-tips .close-button').addEventListener('click', () => {
        closeNavigationTips();
        resetInactivityTimer();
    });
}

function addMapEventListeners() {
    const startInteraction = () => {
        isMapInteracting = true;
        userIsInteracting = true;
        followUser = false;
        resetInactivityTimer();
    };

    map.on('movestart zoomstart dragstart', startInteraction);
}

function resetInactivityTimer() {
    clearTimeout(window.inactivityTimer);
    window.inactivityTimer = setTimeout(checkInactivity, INACTIVITY_TIMEOUT);
}

function checkInactivity() {
    console.log('Inactivity timer triggered');
    isMapInteracting = false;
    userIsInteracting = false;
    
    // Close any open popups
    map.closePopup();
    map.eachLayer((layer) => {
        if (layer.getPopup && layer.getPopup()?.isOpen()) {
            layer.closePopup();
        }
    });
    
    if (!isMapInteracting && !userIsInteracting) {
        recenterMap();
    }
}

function closeAllPopups() {
    if (map) {
        map.closePopup();
    }
}

let lastVisitTime = 0;
const cooldownPeriod = 3 * 60 * 1000;
        
function showLocationHunt(location) {
    const now = performance.now();
    if (location.id === lastVisitedLocationId && now - lastVisitTime < cooldownPeriod) {
        console.log(`Location ${location.id} is on cooldown. Skipping.`);
        return;
    }
    
    lastVisitedLocationId = location.id;
    lastVisitTime = now;
    isLocationHuntVisible = true;

    // Use DOM batch updates for better performance
    domUpdateManager.schedule('locationHunt', () => {
        const lochuntContainer = document.querySelector('.lochunt-container');
        lochuntContainer.innerHTML = '';
        lochuntContainer.style.cssText = `
            display: flex;
            flex-direction: column;
            height: 100%;
            overflow: hidden;
            background-color: #fff;
            max-width: 1200px;
            margin: 0 auto;
            box-shadow: 0 2px 20px rgba(0,0,0,0.025);
            will-change: transform;
        `;
        
        // Add transition class
        lochuntContainer.classList.add('location-transition');
        
        // Trigger reflow to ensure transition works
        void lochuntContainer.offsetWidth;
        
        // Make visible with transition
        lochuntContainer.classList.add('visible');

        const scrollableContent = document.createElement('div');
        scrollableContent.style.cssText = `
            flex: 1;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            scroll-behavior: smooth;
            will-change: scroll-position;
        `;

        // Use preloaded image if available
        const locationImage = document.createElement('img');
        if (preloadedImages.has(location.image)) {
            locationImage.src = location.image;
        } else {
            locationImage.src = location.image;
            // Preload for next time
            const img = new Image();
            img.crossOrigin = "anonymous"; // Set crossOrigin for canvas operations
            img.src = location.image;
            preloadedImages.set(location.image, img);
        }
        locationImage.alt = location.name;
        locationImage.style.cssText = `
            width: 100%;
            height: 45vh;
            object-fit: cover;
            object-position: center;
        `;

        scrollableContent.appendChild(locationImage);
     
        const contentContainer = document.createElement('div');
        contentContainer.classList.add('lochunt-content');
        contentContainer.style.cssText = `
            padding: 24px;
            display: flex;
            flex-direction: column;
            align-items: center;
            max-width: 800px;
            margin: 0 auto;
        `;
        const locationInfo = document.createElement('div');
        locationInfo.classList.add('lochunt-info');
        locationInfo.style.cssText = `
            text-align: center;
            width: 100%;
            margin-bottom: 15px;
        `;
        const locationName = document.createElement('h1');
        locationName.textContent = location.name;
        locationName.style.cssText = `
            font-size: clamp(1.8rem, 4vw, 2.5rem);
            font-weight: 700;
            color: #1a1a1a;
            margin-bottom: 8px;
            line-height: 1.2;
        `;
        const locationCity = document.createElement('p');
        locationCity.textContent = `${location.city}`;
        locationCity.style.cssText = `
           font-size: clamp(1.1rem, 2vw, 1.3rem);
            color: #ff0000;
            font-weight: 600;
            margin-bottom: 4px;
        `;
        const locationCreator = document.createElement('p');
        locationCreator.textContent = `Created by: ${location.creator}`;
        locationCreator.style.cssText = `
            font-size: calc(0.9rem + 0.4vw);
            color: #666666;
            font-weight: 500;
        `;
        locationInfo.appendChild(locationName);
        locationInfo.appendChild(locationCity);
        locationInfo.appendChild(locationCreator);
        contentContainer.appendChild(locationInfo);
        const audioPlayerContainer = createAudioPlayer(location.audio);
        contentContainer.appendChild(audioPlayerContainer);
        scrollableContent.appendChild(contentContainer);
        lochuntContainer.appendChild(scrollableContent);
        const blueBar = createBlueBar(location);
        blueBar.style.cssText += `
            position: sticky;
            bottom: 0;
            width: 100%;
        `;
        lochuntContainer.appendChild(blueBar);
        
        // Initialize audio player after DOM is updated
        requestAnimationFrame(initAudioPlayer);
    });
}

function createAudioPlayer(audioSrc) {
    const audioPlayerContainer = document.createElement('div');
    audioPlayerContainer.classList.add('audio-player');
    audioPlayerContainer.style.cssText = `
        width: 100%;
        max-width: 400px;
        margin-bottom: 15px;
    `;

    const audio = document.createElement('audio');
    audio.id = 'locationAudio';
    
    // Use preloaded audio if available
    if (preloadedAudio.has(audioSrc)) {
        audio.src = audioSrc;
    } else {
        audio.src = audioSrc;
        // Preload for next time
        const audioPreload = new Audio();
        audioPreload.preload = 'auto';
        audioPreload.src = audioSrc;
        preloadedAudio.set(audioSrc, audioPreload);
    }

    const audioProgress = document.createElement('div');
    audioProgress.classList.add('audio-progress');
    audioProgress.style.cssText = `
        width: 100%;
        margin-bottom: 15px;
    `;

    const progressContainer = document.createElement('div');
    progressContainer.classList.add('progress');
    progressContainer.style.cssText = `
        height: 8px;
        background-color: #e2e8f0;
        border-radius: 4px;
        cursor: pointer;
        margin-bottom: 12px;
        overflow: hidden;
    `;

    const progressBar = document.createElement('div');
    progressBar.id = 'progressBar';
    progressBar.classList.add('progress-bar');
    progressBar.style.cssText = `
        height: 100%;
        background-color: #ff0000;
        width: 0%;
        transition: width 0.1s linear;
    `;

    progressContainer.appendChild(progressBar);
    audioProgress.appendChild(progressContainer);

    const timeInfo = document.createElement('div');
    timeInfo.classList.add('audio-time');
    timeInfo.style.cssText = `
        display: flex;
        justify-content: space-between;
        color: #4a5568;
        font-size: 0.875rem;
        margin-bottom: 16px;
        font-weight: 500;
    `;

    const currentTimeSpan = document.createElement('span');
    currentTimeSpan.id = 'currentTime';
    currentTimeSpan.textContent = '0:00';

    const durationSpan = document.createElement('span');
    durationSpan.id = 'duration';
    durationSpan.textContent = '0:00';

    timeInfo.appendChild(currentTimeSpan);
    timeInfo.appendChild(durationSpan);

    const audioControls = document.createElement('div');
    audioControls.classList.add('audio-controls');
    audioControls.style.cssText = `
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 24px;
    `;

    const rewindBtn = createAudioButton('skip-backward', 'rewindBtn');
    const playPauseBtn = createAudioButton('play', 'playPauseBtn');
    const forwardBtn = createAudioButton('skip-forward', 'forwardBtn');

    audioControls.appendChild(rewindBtn);
    audioControls.appendChild(playPauseBtn);
    audioControls.appendChild(forwardBtn);

    audioPlayerContainer.appendChild(audio);
    audioPlayerContainer.appendChild(audioProgress);
    audioPlayerContainer.appendChild(timeInfo);
    audioPlayerContainer.appendChild(audioControls);

    return audioPlayerContainer;
}

function createAudioButton(iconName, id) {
    const button = document.createElement('button');
    button.id = id;
    button.classList.add('audio-button');
    button.innerHTML = `<i class="bi bi-${iconName}"></i>`;
    button.style.cssText = `
background-color: white;
color: #0000ff;
border: 2px solid #0000ff;
border-radius: 50%;
width: 55px;
height: 55px;
display: flex;
align-items: center;
justify-content: center;
cursor: pointer;
transition: all 0.3s ease;
    `;

    button.addEventListener('mouseover', () => {
        button.style.backgroundColor = 'rgba(0, 0, 255, 0.1)';
    });

    button.addEventListener('mouseout', () => {
        button.style.backgroundColor = 'white';
    });

    button.addEventListener('click', () => {
        button.style.backgroundColor = '#0000ff';
        button.style.color = 'white';
        button.style.transform = 'scale(0.95)';
        
        setTimeout(() => {
            button.style.backgroundColor = 'white';
            button.style.color = '#0000ff';
            button.style.transform = 'scale(1)';
        }, 200);
    });

    return button;
}

function createBlueBar(location) {
    const blueBar = document.createElement('div');
    blueBar.style.cssText = `
        width: 100%;
        height: 60px;
        background: linear-gradient(to right, #0a1f80, #0f2bab);
        margin-top: auto;
        box-shadow: 0 -2px 10px rgba(0,0,0,0.025);
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0 24px;
        position: sticky;
        bottom: 0;
    `;
    
    const infoButton = document.createElement('button');
    infoButton.innerHTML = '<i class="bi bi-info-circle-fill text-white" style="font-size: 1.5rem; z-index: 2500;"></i>';
    infoButton.classList.add('btn', 'btn-sm', 'me-2');
    infoButton.onclick = () => {
        if (location && location.imageSource) {
            showPopup('Image Source', location.imageSource);
        } else {
            showPopup('Image Source', 'Image source information is not available');
        }
    };

    const feedbackButton = document.createElement('a');
    feedbackButton.href = 'mailto:mattreicher@protonmail.com?subject=Feedback';
    feedbackButton.target = '_blank';
    feedbackButton.rel = 'noopener noreferrer';
    feedbackButton.innerHTML = '<i class="bi bi-envelope-fill text-white" style="font-size: 1.5rem;"></i>';
    feedbackButton.classList.add('btn', 'btn-sm');

    blueBar.appendChild(infoButton);
    blueBar.appendChild(feedbackButton);
    return blueBar;
}        

function initAudioPlayer() {
    const audio = document.getElementById('locationAudio');
    const playPauseBtn = document.getElementById('playPauseBtn');
    const rewindBtn = document.getElementById('rewindBtn');
    const forwardBtn = document.getElementById('forwardBtn');
    const progressBar = document.getElementById('progressBar');
    const progressContainer = document.querySelector('.progress');
    const currentTimeSpan = document.getElementById('currentTime');
    const durationSpan = document.getElementById('duration');

    if (!audio || !playPauseBtn || !rewindBtn || !forwardBtn || !progressBar || !progressContainer || !currentTimeSpan || !durationSpan) {
        console.warn('Audio player elements not found, retrying...');
        requestAnimationFrame(initAudioPlayer);
        
        return;
    }

    // Debounce progress updates to reduce DOM operations
    let lastProgressUpdate = 0;
    const PROGRESS_UPDATE_INTERVAL = 250; // ms

    playPauseBtn.addEventListener('click', togglePlay);
    rewindBtn.addEventListener('click', () => seek(-10));
    forwardBtn.addEventListener('click', () => seek(10));
    
    // Use throttled event listener for timeupdate
    audio.addEventListener('timeupdate', () => {
        const now = Date.now();
        if (now - lastProgressUpdate > PROGRESS_UPDATE_INTERVAL) {
            lastProgressUpdate = now;
            updateProgress();
        }
    });
    
    audio.addEventListener('loadedmetadata', setDuration);
    audio.addEventListener('ended', () => {
        domUpdateManager.schedule('playPauseBtn', () => {
            playPauseBtn.innerHTML = '<i class="bi bi-play"></i>';
        });
        showAdditionalInfo();
    });
    
    // Handle audio loading errors
    audio.addEventListener('error', (e) => {
        console.error('Audio loading error:', e);
        showErrorMessage('Error loading audio. Please check your connection and try again.');
    });
    
    // Use event delegation for progress container clicks
    progressContainer.addEventListener('click', setProgress);

    function togglePlay() {
        if (audio.paused) {
            const playPromise = audio.play();
            if (playPromise !== undefined) {
                playPromise.then(() => {
                    domUpdateManager.schedule('playPauseBtn', () => {
                        playPauseBtn.innerHTML = '<i class="bi bi-pause"></i>';
                    });
                }).catch(error => {
                    console.error('Audio playback failed:', error);
                    showErrorMessage('Audio playback failed. Please try again.');
                });
            }
        } else {
            audio.pause();
            domUpdateManager.schedule('playPauseBtn', () => {
                playPauseBtn.innerHTML = '<i class="bi bi-play"></i>';
            });
        }
    }

    function seek(seconds) {
        audio.currentTime = Math.max(0, Math.min(audio.currentTime + seconds, audio.duration));
    }

    function updateProgress() {
        const percent = (audio.currentTime / audio.duration) * 100;
        domUpdateManager.schedule('audioProgress', () => {
            progressBar.style.width = `${percent}%`;
            currentTimeSpan.textContent = formatTime(audio.currentTime);
        });
    }

    function setProgress(e) {
        const width = this.clientWidth;
        const clickX = e.offsetX;
        const duration = audio.duration;
        audio.currentTime = (clickX / width) * duration;
    }

    function setDuration() {
        domUpdateManager.schedule('audioDuration', () => {
            durationSpan.textContent = formatTime(audio.duration);
        });
    }

    function formatTime(time) {
        const minutes = Math.floor(time / 60);
        const seconds = Math.floor(time % 60);
        return `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }
}

function showAdditionalInfo() {
    // Find the location using lastVisitedLocationId
    const location = gameLocations.find(loc => loc.id === lastVisitedLocationId);
    console.log('Current location:', location);
    
    // Set flag to indicate we're returning from exhibit
    isReturningFromExhibit = true;
    
    domUpdateManager.schedule('additionalInfo', () => {
        const additionalInfoContainer = document.querySelector('.additional-info-container');
        additionalInfoContainer.style.display = 'block';
        
        // Add transition class
        additionalInfoContainer.classList.add('location-transition');
        
        // Trigger reflow to ensure transition works
        void additionalInfoContainer.offsetWidth;
        
        // Make visible with transition
        additionalInfoContainer.classList.add('visible');
        
        document.getElementById('additionalInfo').textContent = location.additionalInfo;

        const continueButton = document.getElementById('continueButton');
        continueButton.onclick = () => {
            // Fade out with transition
            additionalInfoContainer.classList.remove('visible');
            
            // Hide after transition completes
            setTimeout(() => {
                additionalInfoContainer.style.display = 'none';
                
                // Also hide location hunt container with transition
                const lochuntContainer = document.querySelector('.lochunt-container');
                lochuntContainer.classList.remove('visible');
                
                setTimeout(() => {
                    lochuntContainer.style.display = 'none';
                    isLocationHuntVisible = false;
                    updateDistanceBox();
                }, 500);
            }, 500);
        };
    });
}

function showDirectionsModal(lat, lng) {
    const modal = document.getElementById('directionsModal');
    modal.style.display = 'block';

    const mapBtn = document.getElementById('mapButton');
    const cancelBtn = document.getElementById('cancelButton');

    mapBtn.onclick = () => {
        window.open(`https://www.google.com/maps/dir/?api=1&destination=${lat},${lng}`, '_blank');
        modal.style.display = 'none';
    };

    cancelBtn.onclick = () => {
        modal.style.display = 'none';
    };

    window.onclick = (event) => {
        if (event.target == modal) {
            modal.style.display = 'none';
        }
    };
}

function showLocationSummary(locationId) {
    console.log("Showing summary for location ID:", locationId);
    console.log("All locations:", gameLocations);
    console.log("Location IDs:", gameLocations.map(loc => loc.id));
    console.log("Location ID type:", typeof locationId);
    console.log("Location ID type:", typeof gameLocations[0].id);
    const location = gameLocations.find(loc => loc.id === locationId);
    console.log("Found location:", location);
    if (location && location.summary) {
        domUpdateManager.schedule('summaryModal', () => {
            const modal = document.getElementById('summaryModal');
            const summaryContent = document.getElementById('summaryContent');
            modal.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
            modal.style.display = 'flex';
            modal.style.justifyContent = 'center';
            modal.style.alignItems = 'center';
            const modalContent = modal.querySelector('.modal-content');
            modalContent.style.cssText = `
                background-color: white;
                padding: 30px;
                border-radius: 10px;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.025);
                max-width: 500px;
                width: 90%;
                max-height: 80vh;
                overflow-y: auto;
            `;
            const closeBtn = modal.querySelector('.close');
            if (closeBtn) {
                closeBtn.remove();
            }
            summaryContent.style.textAlign = 'left';
            summaryContent.innerHTML = `
               <h3 class="summary-heading" style="font-size: 22px; margin-bottom: 15px; text-align: center;">${location.name}</h3>
                <p style="line-height: 1.6; margin-bottom: 15px;">
                    ${location.summary}
                </p>
                <p style="line-height: 1.6; margin-bottom: 15px;">
                    <strong>Location:</strong> ${location.today}
                </p>
            `;
            
            const continueButton = document.createElement('button');
            continueButton.textContent = 'Continue';
            continueButton.className = 'summary-button';
            continueButton.style.cssText = `
                display: block;
                width: auto;
                padding: 12px 20px;
                color: white;
                border: none;
                border-radius: 10px;
                cursor: pointer;
                font-size: 18px;
                font-weight: bold;
                transition: background-color 0.3s ease;
                margin: 10px auto -15px;
            `;
            continueButton.onclick = function() {
                modal.style.display = 'none';
            };
            summaryContent.appendChild(continueButton);
            modal.style.display = 'flex';
            window.onclick = function(event) {
                if (event.target === modal) {
                    modal.style.display = 'none';
                }
            };
        });
    } else {
        console.log("Location or summary not found. Location ID:", locationId);
        console.log("Available IDs:", gameLocations.map(loc => loc.id));
        showPopup("Error", "Summary not available for this location.");
    }
}
        
function startHunt() {
    // Check network status before starting
    if (!navigator.onLine) {
        showErrorMessage("No internet connection. Please connect to the internet and try again.");
        
        // Set a timeout to retry
        setTimeout(() => {
            if (navigator.onLine) {
                startHunt();
            }
        }, 5000);
        
        return;
    }
    
    try {
        gameLocations = locations.sort((a, b) => a.id - b.id);
        currentLocationIndex = 0;
        locationCooldowns = {};
        lastVisitedLocationId = null;
        
        // Preload all location images before starting
        preloadImages(gameLocations).then(() => {
            // Hide preloader when images are loaded
            const preloader = document.getElementById('preloader');
            if (preloader) {
                preloader.style.opacity = '0';
                preloader.style.transition = 'opacity 0.5s ease';
                setTimeout(() => {
                    if (preloader && preloader.parentNode) {
                        preloader.parentNode.removeChild(preloader);
                    }
                }, 500);
            }
            
            loadAllLocations();
        }).catch(error => {
            console.error("Error preloading images:", error);
            showErrorMessage("Error loading resources. Please check your connection and try again.");
            
            // Try to continue anyway after a delay
            setTimeout(() => {
                loadAllLocations();
            }, 3000);
        });
    } catch (error) {
        console.error("Error starting hunt:", error);
        showErrorMessage("Error starting the experience. Please reload the page.");
    }
}

function getMarkerColor(tours) {
    switch (tours.toLowerCase()) {
        case 'person':
            return '#FFA500';
        case 'gangster':
            return '#3f9b0b';
        case 'event':
            return '#8B0000';
        case 'place':
            return '#0f2bab';
        default:
            return '#0f2bab';
    }
}

const showAlert = (message) => {
   const alertEl = document.createElement('div');
   alertEl.className = 'modal';
   alertEl.innerHTML = `
       <div class="modal-content">
           <p>${message}</p>
           <button class="modal-button">OK</button>
       </div>
   `;
   document.body.appendChild(alertEl);
   alertEl.querySelector('button').onclick = () => {
       alertEl.remove();
       // Show directions modal again
       routeButton.click();
   };
};
        
function loadAllLocations() {
    try {
        gameLocations.forEach((location, index) => {
            const markerColor = getMarkerColor(location.tours);
            
            const locationMarker = L.marker([location.lat, location.lng], {
                icon: L.divIcon({
                    className: 'custom-pin-icon',
                    html: `<div class="pin-head" style="background-color: ${markerColor};">
                           </div>`,
                    iconSize: [30, 30],
                    iconAnchor: [15, 30],
                })
            });
                    
            const popupContent = `
                <div class="popup-content">
                    <img src="${location.image}" alt="${location.name}" class="location-image">
                    <h4 class="location-name">
                        <a href="${location.link}" target="_blank" rel="noopener noreferrer" style="text-decoration: none; color: inherit;">${location.name}</a>
                    </h4>
                    <div class="popup-buttons">
                        <button class="button route-button" data-lat="${location.lat}" data-lng="${location.lng}">Directions</button>
                        <button class="button summary-button" data-location-id="${location.id}">Summary</button>
                    </div>
                </div>
            `;
            locationMarker.bindPopup(popupContent, {
                offset: L.point(0, -25),
                className: 'custom-popup'
            });
            
            locationMarker.on('popupopen', function(e) {
                const popup = e.popup._contentNode;
                const routeButton = popup.querySelector('.route-button');
                const summaryButton = popup.querySelector('.summary-button');
                
                if (routeButton) {
                    routeButton.addEventListener('click', function(event) {
                        event.preventDefault();
                        const lat = this.getAttribute('data-lat');
                        const lng = this.getAttribute('data-lng');
                        
// Create and show the modal
const modal = document.createElement('div');
modal.className = 'modal';
modal.innerHTML = `
    <div class="modal-content">
        <h3>Choose your preferred navigation app:</h3>
        <div class="navigation-options">
            <button id="googleMapsBtn" class="nav-button" style="background-color: #4285F4; color: white;">
                <i class="bi bi-map"></i> Google Maps
            </button>
            <button id="appleMapsBtn" class="nav-button" style="background-color: #007AFF; color: white;">
                <i class="bi bi-map-fill"></i> Apple Maps
            </button>
            <button id="wazeBtn" class="nav-button" style="background-color: #66BD47; color: white;">
                <i class="bi bi-signpost-2"></i> Waze
            </button>
            <button id="cancelNavBtn" class="nav-button cancel">
                <i class="bi bi-x-circle"></i> Cancel
            </button>
        </div>
    </div>
`;
modal.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 2000;
`;
document.body.appendChild(modal);
                        
                        const modalContent = modal.querySelector('.modal-content');
                        modalContent.style.cssText = `
                            background-color: white;
                            padding: 20px;
                            border-radius: 10px;
                            max-width: 90%;
                            width: 350px;
                            text-align: center;
                        `;
                        
                        const navigationOptions = modal.querySelector('.navigation-options');
                        navigationOptions.style.cssText = `
                            display: flex;
                            flex-direction: column;
                            gap: 10px;
                            margin-top: 15px;
                        `;
                        
                        const navButtons = modal.querySelectorAll('.nav-button');
                        navButtons.forEach(button => {
                            button.style.cssText = `
                                padding: 12px;
                                border: none;
                                border-radius: 8px;
                                background-color: #0f2bab;
                                color: white;
                                font-size: 16px;
                                cursor: pointer;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                gap: 10px;
                            `;
                        });
                        
                        const cancelBtn = modal.querySelector('.cancel');
                        cancelBtn.style.backgroundColor = '#ccc';
                        cancelBtn.style.color = '#333';
                        
                        // Add event listeners
                        modal.querySelector('#googleMapsBtn').addEventListener('click', () => {
                            window.open(`https://www.google.com/maps/dir/?api=1&destination=${lat},${lng}`, '_blank');
                            document.body.removeChild(modal);
                        });
                        
                        modal.querySelector('#appleMapsBtn').addEventListener('click', () => {
                            window.open(`https://maps.apple.com/?daddr=${lat},${lng}`, '_blank');
                            document.body.removeChild(modal);
                        });
                        
                        modal.querySelector('#wazeBtn').addEventListener('click', () => {
                            window.open(`https://waze.com/ul?ll=${lat},${lng}&navigate=yes`, '_blank');
                            document.body.removeChild(modal);
                        });
                        
                        modal.querySelector('#cancelNavBtn').addEventListener('click', () => {
                            document.body.removeChild(modal);
                        });
                        
                        // Close modal when clicking outside
                        modal.addEventListener('click', (e) => {
                            if (e.target === modal) {
                                document.body.removeChild(modal);
                            }
                        });
                    });
                }
                
                if (summaryButton) {
                    summaryButton.addEventListener('click', function(event) {
                        event.preventDefault();
                        const locationId = this.getAttribute('data-location-id');
                        showLocationSummary(locationId);
                    });
                }
            });
            
            markerClusterGroup.addLayer(locationMarker);
        });
        
        // Add UI event listeners
        addUIEventListeners();
        addMapEventListeners();
        
        // Start inactivity timer
        resetInactivityTimer();
        
        // Update distance box
        updateDistanceBox();
        
    } catch (error) {
        console.error("Error loading locations:", error);
        showErrorMessage("Error loading locations. Please try again later.");
    }
}

function toggleNavigationTips() {
    const tips = document.querySelector('.navigation-tips');
    tips.style.display = tips.style.display === 'block' ? 'none' : 'block';
}

function closeNavigationTips() {
    document.querySelector('.navigation-tips').style.display = 'none';
}

function returnToIndex() {
    showPopup("Confirm", "Are you ready to exit?", 'info', () => {
        window.location= "index.html";
    });
}

// Initialize the map
document.addEventListener('DOMContentLoaded', initMap);

// The function below was incomplete in the original code. Here's the complete version:

function updateDistanceBox() {
  // Initial validation
  if (!userMarker || !gameLocations || gameLocations.length === 0) {
      document.getElementById("distanceBox").innerText = "Initializing...";
      return;
  }

  // Get user coordinates
  const userLatLng = userMarker.getLatLng();
  let userLat = userLatLng.lat;
  let userLng = userLatLng.lng;

  // Coordinate validation
  if (!isFinite(userLat) || !isFinite(userLng)) {
      console.warn("Invalid user coordinates:", userLat, userLng);
      document.getElementById("distanceBox").innerText = "Initializing...";
      return;
  }

  // Use map center if at origin
  if (userLat === 0 && userLng === 0) {
      const center = map.getCenter();
      userLat = center.lat;
      userLng = center.lng;
  }

  // Find closest location
  let closestDistance = Infinity;
  let closestLocation = null;
  const userPos = { lat: userLat, lng: userLng };

  for (const location of gameLocations) {
      if (!location || typeof location.lat !== "number" || typeof location.lng !== "number") {
          console.warn("Invalid location data:", location);
          continue;
      }

      const locationPos = { lat: location.lat, lng: location.lng };
      const distance = calculateDistance(userPos, locationPos);

      if (isFinite(distance) && distance < closestDistance) {
          closestDistance = distance;
          closestLocation = location;
      }
  }

  // Validate final distance calculation
  if (!isFinite(closestDistance) || closestDistance === Infinity) {
      console.warn("Invalid distance calculation:", closestDistance);
      document.getElementById("distanceBox").innerText = "Initializing...";
      return;
  }

  // Calculate and display distance
  const distanceFeet = Math.round(closestDistance * 3.28084);
  const distanceText = distanceFeet < 5280 
      ? `${distanceFeet.toLocaleString()} feet` 
      : `${(distanceFeet / 5280).toFixed(2)} miles`;
  
  document.getElementById("distanceBox").innerText = `Closest Stop: ${distanceText}`;

  // Check if we should show location hunt
  if (distanceFeet <= DISTANCE_THRESHOLD && !isLocationHuntVisible && closestLocation) {
      console.log(`User is within threshold distance (${distanceFeet} feet). Opening location page.`);
      showLocationHunt(closestLocation);
  }
}

// Function to handle location permission denied
function handleLocationPermissionDenied() {
  // Create permission denied modal
  const modal = document.createElement('div');
  modal.className = 'permission-modal';
  modal.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 2000;
  `;
  
  const modalContent = document.createElement('div');
  modalContent.style.cssText = `
      background-color: white;
      padding: 30px;
      border-radius: 10px;
      max-width: 90%;
      width: 400px;
      text-align: center;
  `;
  
  const title = document.createElement('h2');
  title.textContent = 'Location Access Required';
  title.style.cssText = `
      margin-bottom: 15px;
      color: #333;
  `;
  
  const message = document.createElement('p');
  message.innerHTML = `
      This app requires access to your location to function properly.<br><br>
      Please enable location services for this website in your browser settings and refresh the page.
  `;
  message.style.cssText = `
      margin-bottom: 20px;
      line-height: 1.5;
      color: #555;
  `;
  
  const instructionsTitle = document.createElement('h3');
  instructionsTitle.textContent = 'How to enable location:';
  instructionsTitle.style.cssText = `
      margin-bottom: 10px;
      color: #333;
      font-size: 16px;
  `;
  
  const instructions = document.createElement('ul');
  instructions.style.cssText = `
      text-align: left;
      margin-bottom: 20px;
      padding-left: 20px;
  `;
  
  const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
  const isAndroid = /Android/.test(navigator.userAgent);
  
  if (isIOS) {
      instructions.innerHTML = `
          <li>Open Settings</li>
          <li>Scroll down and tap Safari</li>
          <li>Tap Location</li>
          <li>Select "Allow" for this website</li>
      `;
  } else if (isAndroid) {
      instructions.innerHTML = `
          <li>Open Chrome settings (three dots)</li>
          <li>Tap Site settings</li>
          <li>Tap Location</li>
          <li>Enable location access</li>
      `;
  } else {
      instructions.innerHTML = `
          <li>Click the lock/info icon in your address bar</li>
          <li>Find location permissions</li>
          <li>Allow access for this site</li>
          <li>Refresh the page</li>
      `;
  }
  
  const refreshButton = document.createElement('button');
  refreshButton.textContent = 'Refresh Page';
  refreshButton.style.cssText = `
      background-color: #0f2bab;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 5px;
      font-size: 16px;
      cursor: pointer;
      transition: background-color 0.3s;
  `;
  
  refreshButton.addEventListener('mouseover', () => {
      refreshButton.style.backgroundColor = '#0a1f80';
  });
  
  refreshButton.addEventListener('mouseout', () => {
      refreshButton.style.backgroundColor = '#0f2bab';
  });
  
  refreshButton.addEventListener('click', () => {
      window.location.reload();
  });
  
  modalContent.appendChild(title);
  modalContent.appendChild(message);
  modalContent.appendChild(instructionsTitle);
  modalContent.appendChild(instructions);
  modalContent.appendChild(refreshButton);
  modal.appendChild(modalContent);
  
  document.body.appendChild(modal);
}

// Function to initialize the map
function initMap() {
  // Create map container if it doesn't exist
  if (!document.getElementById('map')) {
      const mapContainer = document.createElement('div');
      mapContainer.id = 'map';
      mapContainer.style.cssText = `
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          z-index: 1;
      `;
      document.body.appendChild(mapContainer);
  }
  
  // Create UI elements
  createUIElements();
  
  // Initialize map
  map = L.map('map', {
      zoomControl: false,
      attributionControl: false,
      maxZoom: 19,
      minZoom: 10,
      zoomSnap: 0.1,
      zoomDelta: 0.5,
      wheelPxPerZoomLevel: 120,
      bounceAtZoomLimits: false,
      maxBoundsViscosity: 1.0,
      tap: true,
      tapTolerance: 15,
      touchZoom: 'center',
      doubleClickZoom: 'center'
  }).setView([40.7128, -74.0060], 18);
  
  // Add tile layer
  L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', {
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
      subdomains: 'abcd',
      maxZoom: 19
  }).addTo(map);
  
  // Create marker cluster group
  markerClusterGroup = L.markerClusterGroup({
      showCoverageOnHover: false,
      maxClusterRadius: 50,
      spiderfyOnMaxZoom: true,
      disableClusteringAtZoom: 18,
      iconCreateFunction: function(cluster) {
          const count = cluster.getChildCount();
          return L.divIcon({
              html: `<div class="cluster-icon">${count}</div>`,
              className: 'custom-cluster-icon',
              iconSize: L.point(40, 40)
          });
      }
  });
  
  map.addLayer(markerClusterGroup);
  
  // Create user marker
  userMarker = L.marker([40.7128, -74.0060], {
      icon: L.divIcon({
          className: 'user-marker',
          html: `<div class="user-marker-icon"></div>`,
          iconSize: [24, 24],
          iconAnchor: [12, 12]
      }),
      zIndexOffset: 1000
  }).addTo(map);
  
  // Store map viewport dimensions
  mapViewportWidth = map._container.clientWidth;
  mapViewportHeight = map._container.clientHeight;
  
  // Add resize listener
  window.addEventListener('resize', () => {
      mapViewportWidth = map._container.clientWidth;
      mapViewportHeight = map._container.clientHeight;
      map.invalidateSize();
  });
  
  // Add visibility change listener
  document.addEventListener('visibilitychange', handleVisibilityChange);
  
  // Add online/offline listeners
  window.addEventListener('online', () => {
      isOnline = true;
      console.log('Network connection restored');
  });
  
  window.addEventListener('offline', () => {
      isOnline = false;
      console.log('Network connection lost');
      showErrorMessage('Network connection lost. Some features may not work properly.');
  });
  
  // Request motion permissions
  requestMotionPermission();
  
  // Show loading message
  showLoadingMessage();
  
  // Get initial user location
  if ("geolocation" in navigator) {
      navigator.geolocation.getCurrentPosition(
          initializeUserLocation,
          handleLocationError,
          {
              enableHighAccuracy: true,
              timeout: 10000,
              maximumAge: 0
          }
      );
  } else {
      hideLoadingMessage();
      showErrorMessage("Geolocation is not supported by your browser");
  }
  
  // Start animation loop
  startAnimationLoop();
}

// Create UI elements
function createUIElements() {
  // Create distance box
  const distanceBox = document.createElement('div');
  distanceBox.id = 'distanceBox';
  distanceBox.style.cssText = `
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background-color: rgba(255, 255, 255, 0.9);
      padding: 10px 15px;
      border-radius: 20px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      z-index: 1000;
      font-weight: 500;
      font-size: 16px;
      text-align: center;
      min-width: 200px;
  `;
  distanceBox.textContent = 'Initializing...';
  document.body.appendChild(distanceBox);
  
  // Create recenter button
  const recenterButton = document.createElement('button');
  recenterButton.id = 'recenterButton';
  recenterButton.innerHTML = '<i class="bi bi-geo-alt-fill"></i>';
  recenterButton.style.cssText = `
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background-color: white;
      color: #0f2bab;
      border: none;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      font-size: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 1000;
      transition: background-color 0.3s, transform 0.3s;
  `;
  document.body.appendChild(recenterButton);
  
  // Create return button
  const returnButton = document.createElement('button');
  returnButton.id = 'returnButton';
  returnButton.innerHTML = '<i class="bi bi-arrow-left"></i>';
  returnButton.style.cssText = `
      position: fixed;
      bottom: 20px;
      left: 20px;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background-color: white;
      color: #0f2bab;
      border: none;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      font-size: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 1000;
      transition: background-color 0.3s, transform 0.3s;
  `;
  document.body.appendChild(returnButton);
  
  // Create tips button
  const tipsButton = document.createElement('button');
  tipsButton.id = 'tipsButton';
  tipsButton.innerHTML = '<i class="bi bi-info-circle"></i>';
  tipsButton.style.cssText = `
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background-color: white;
      color: #0f2bab;
      border: none;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      font-size: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 1000;
      transition: background-color 0.3s, transform 0.3s;
  `;
  document.body.appendChild(tipsButton);
  
  // Create navigation tips
  const navigationTips = document.createElement('div');
  navigationTips.className = 'navigation-tips';
  navigationTips.style.cssText = `
      position: fixed;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      background-color: white;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      z-index: 1000;
      max-width: 90%;
      width: 300px;
      display: none;
  `;
  navigationTips.innerHTML = `
      <div class="close-button" style="position: absolute; top: 10px; right: 10px; cursor: pointer;">
          <i class="bi bi-x" style="font-size: 20px;"></i>
      </div>
      <h3 style="margin-top: 0; margin-bottom: 10px; color: #0f2bab;">Navigation Tips</h3>
      <ul style="padding-left: 20px; margin-bottom: 0;">
          <li style="margin-bottom: 8px;">Tap on markers to see location details</li>
          <li style="margin-bottom: 8px;">Use the recenter button to focus on your location</li>
          <li style="margin-bottom: 8px;">Get directions to any location with the Directions button</li>
          <li style="margin-bottom: 8px;">Approach locations to hear their stories</li>
      </ul>
  `;
  document.body.appendChild(navigationTips);
  
  // Create location hunt container
  const lochuntContainer = document.createElement('div');
  lochuntContainer.className = 'lochunt-container';
  lochuntContainer.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: white;
      z-index: 1500;
      display: none;
      overflow: hidden;
  `;
  document.body.appendChild(lochuntContainer);
  
  // Create additional info container
  const additionalInfoContainer = document.createElement('div');
  additionalInfoContainer.className = 'additional-info-container';
  additionalInfoContainer.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      z-index: 1600;
      display: none;
      justify-content: center;
      align-items: center;
      padding: 20px;
  `;
  
  const additionalInfoContent = document.createElement('div');
  additionalInfoContent.style.cssText = `
      background-color: white;
      padding: 30px;
      border-radius: 10px;
      max-width: 600px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      text-align: center;
  `;
  
  const additionalInfoTitle = document.createElement('h2');
  additionalInfoTitle.textContent = 'Additional Information';
  additionalInfoTitle.style.cssText = `
      margin-top: 0;
      margin-bottom: 20px;
      color: #0f2bab;
  `;
  
  const additionalInfo = document.createElement('p');
  additionalInfo.id = 'additionalInfo';
  additionalInfo.style.cssText = `
      margin-bottom: 20px;
      line-height: 1.6;
      text-align: left;
  `;
  
  const continueButton = document.createElement('button');
  continueButton.id = 'continueButton';
  continueButton.textContent = 'Continue';
  continueButton.style.cssText = `
      background-color: #0f2bab;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 5px;
      font-size: 16px;
      cursor: pointer;
      transition: background-color 0.3s;
  `;
  
  additionalInfoContent.appendChild(additionalInfoTitle);
  additionalInfoContent.appendChild(additionalInfo);
  additionalInfoContent.appendChild(continueButton);
  additionalInfoContainer.appendChild(additionalInfoContent);
  document.body.appendChild(additionalInfoContainer);
  
  // Create summary modal
  const summaryModal = document.createElement('div');
  summaryModal.id = 'summaryModal';
  summaryModal.className = 'modal';
  summaryModal.style.cssText = `
      display: none;
      position: fixed;
      z-index: 2000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: auto;
      background-color: rgba(0, 0, 0, 0.4);
  `;
  
  const summaryModalContent = document.createElement('div');
  summaryModalContent.className = 'modal-content';
  summaryModalContent.style.cssText = `
      background-color: #fefefe;
      margin: 15% auto;
      padding: 20px;
      border: 1px solid #888;
      width: 80%;
      max-width: 500px;
      border-radius: 10px;
  `;
  
  const summaryCloseBtn = document.createElement('span');
  summaryCloseBtn.className = 'close';
  summaryCloseBtn.innerHTML = '&times;';
  summaryCloseBtn.style.cssText = `
      color: #aaa;
      float: right;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
  `;
  
  const summaryContent = document.createElement('div');
  summaryContent.id = 'summaryContent';
  
  summaryModalContent.appendChild(summaryCloseBtn);
  summaryModalContent.appendChild(summaryContent);
  summaryModal.appendChild(summaryModalContent);
  document.body.appendChild(summaryModal);
  
  // Create directions modal
  const directionsModal = document.createElement('div');
  directionsModal.id = 'directionsModal';
  directionsModal.className = 'modal';
  directionsModal.style.cssText = `
      display: none;
      position: fixed;
      z-index: 2000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: auto;
      background-color: rgba(0, 0, 0, 0.4);
  `;
  
  const directionsModalContent = document.createElement('div');
  directionsModalContent.className = 'modal-content';
  directionsModalContent.style.cssText = `
      background-color: #fefefe;
      margin: 15% auto;
      padding: 20px;
      border: 1px solid #888;
      width: 80%;
      max-width: 500px;
      border-radius: 10px;
      text-align: center;
  `;
  
  const directionsTitle = document.createElement('h2');
  directionsTitle.textContent = 'Get Directions';
  directionsTitle.style.cssText = `
      margin-top: 0;
      margin-bottom: 20px;
  `;
  
  const directionsText = document.createElement('p');
  directionsText.textContent = 'Would you like to open this location in your maps app?';
  directionsText.style.cssText = `
      margin-bottom: 20px;
  `;
  
  const directionsButtons = document.createElement('div');
  directionsButtons.style.cssText = `
      display: flex;
      justify-content: center;
      gap: 10px;
  `;
  
  const mapButton = document.createElement('button');
  mapButton.id = 'mapButton';
  mapButton.textContent = 'Open Maps';
  mapButton.style.cssText = `
      background-color: #0f2bab;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 5px;
      cursor: pointer;
  `;
  
  const cancelButton = document.createElement('button');
  cancelButton.id = 'cancelButton';
  cancelButton.textContent = 'Cancel';
  cancelButton.style.cssText = `
      background-color: #ccc;
      color: black;
      border: none;
      padding: 10px 20px;
      border-radius: 5px;
      cursor: pointer;
  `;
  
  directionsButtons.appendChild(mapButton);
  directionsButtons.appendChild(cancelButton);
  directionsModalContent.appendChild(directionsTitle);
  directionsModalContent.appendChild(directionsText);
  directionsModalContent.appendChild(directionsButtons);
  directionsModal.appendChild(directionsModalContent);
  document.body.appendChild(directionsModal);
  
  // Create accuracy indicator
  const accuracyIndicator = document.createElement('div');
  accuracyIndicator.id = 'accuracyIndicator';
  accuracyIndicator.style.cssText = `
      position: fixed;
      top: 70px;
      left: 50%;
      transform: translateX(-50%);
      background-color: rgba(255, 255, 255, 0.9);
      padding: 5px 10px;
      border-radius: 15px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      z-index: 1000;
      font-size: 12px;
      display: flex;
      align-items: center;
      gap: 5px;
  `;
  
  const accuracyDot = document.createElement('div');
  accuracyDot.className = 'accuracy-dot accuracy-medium';
  accuracyDot.style.cssText = `
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background-color: #FFA500;
  `;
  
  const accuracyText = document.createElement('span');
  accuracyText.id = 'accuracyText';
  accuracyText.textContent = 'GPS: Initializing';
  
  accuracyIndicator.appendChild(accuracyDot);
  accuracyIndicator.appendChild(accuracyText);
  document.body.appendChild(accuracyIndicator);
  
  // Create preloader
  const preloader = document.createElement('div');
  preloader.id = 'preloader';
  preloader.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: white;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 2000;
  `;
  
  const preloaderLogo = document.createElement('div');
  preloaderLogo.style.cssText = `
      width: 100px;
      height: 100px;
      background-color: #0f2bab;
      border-radius: 50%;
      margin-bottom: 20px;
      display: flex;
      justify-content: center;
      align-items: center;
      color: white;
      font-size: 24px;
      font-weight: bold;
  `;
  preloaderLogo.textContent = 'MAP';
  
  const preloaderText = document.createElement('h2');
  preloaderText.textContent = 'Loading Experience';
  preloaderText.style.cssText = `
      margin-bottom: 20px;
      color: #0f2bab;
  `;
  
  const preloaderProgressContainer = document.createElement('div');
  preloaderProgressContainer.style.cssText = `
      width: 80%;
      max-width: 300px;
      height: 10px;
      background-color: #f0f0f0;
      border-radius: 5px;
      overflow: hidden;
  `;
  
  const preloaderProgress = document.createElement('div');
  preloaderProgress.id = 'preloaderProgress';
  preloaderProgress.style.cssText = `
      height: 100%;
      width: 0%;
      background-color: #0f2bab;
      transition: width 0.3s ease;
  `;
  
  preloaderProgressContainer.appendChild(preloaderProgress);
  preloader.appendChild(preloaderLogo);
  preloader.appendChild(preloaderText);
  preloader.appendChild(preloaderProgressContainer);
  document.body.appendChild(preloader);
  
  // Add CSS for transitions
  const style = document.createElement('style');
  style.textContent = `
      .location-transition {
          opacity: 0;
          transform: translateY(20px);
          transition: opacity 0.5s ease, transform 0.5s ease;
      }
      
      .location-transition.visible {
          opacity: 1;
          transform: translateY(0);
      }
      
      .accuracy-dot.accuracy-high {
          background-color: #4CAF50;
      }
      
      .accuracy-dot.accuracy-medium {
          background-color: #FFA500;
      }
      
      .accuracy-dot.accuracy-low {
          background-color: #F44336;
      }
      
      .error-message {
          position: fixed;
          top: 20px;
          left: 50%;
          transform: translateX(-50%);
          background-color: #F44336;
          color: white;
          padding: 10px 20px;
          border-radius: 5px;
          z-index: 2000;
          animation: fadeInOut 5s forwards;
      }
      
      @keyframes fadeInOut {
          0% { opacity: 0; transform: translateX(-50%) translateY(-20px); }
          10% { opacity: 1; transform: translateX(-50%) translateY(0); }
          90% { opacity: 1; transform: translateX(-50%) translateY(0); }
          100% { opacity: 0; transform: translateX(-50%) translateY(-20px); }
      }
      
      @keyframes spin {
          0% { transform: rotate(0deg); }
          100% { transform: rotate(360deg); }
      }
      
      .stabilizing-modal {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-color: rgba(255, 255, 255, 0.9);
          display: flex;
          flex-direction: column;
          justify-content: center;
          align-items: center;
          z-index: 2000;
      }
      
      .spinner {
          width: 50px;
          height: 50px;
          border: 5px solid rgba(15, 43, 171, 0.2);
          border-top: 5px solid #0f2bab;
          border-radius: 50%;
          animation: spin 1s linear infinite;
          margin-bottom: 20px;
      }
      
      .custom-pin-icon {
          display: flex;
          justify-content: center;
          align-items: center;
      }
      
      .pin-head {
          width: 20px;
          height: 20px;
          border-radius: 50% 50% 50% 0;
          transform: rotate(-45deg);
          display: flex;
          justify-content: center;
          align-items: center;
          box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      }
      
      .custom-popup {
          margin-bottom: 15px;
      }
      
      .custom-popup .leaflet-popup-content-wrapper {
          border-radius: 10px;
          padding: 0;
          overflow: hidden;
      }
      
      .custom-popup .leaflet-popup-content {
          margin: 0;
          width: 250px !important;
      }
      
      .popup-content {
          padding: 0;
      }
      
      .location-image {
          width: 100%;
          height: 150px;
          object-fit: cover;
      }
      
      .location-name {
          padding: 10px 15px;
          margin: 0;
          font-size: 16px;
          font-weight: 600;
          color: #333;
      }
      
      .popup-buttons {
          display: flex;
          border-top: 1px solid #eee;
      }
      
      .popup-buttons .button {
          flex: 1;
          padding: 10px;
          background: none;
          border: none;
          cursor: pointer;
          font-size: 14px;
          color: #0f2bab;
          transition: background-color 0.3s;
      }
      
      .popup-buttons .button:hover {
          background-color: #f5f5f5;
      }
      
      .popup-buttons .button:first-child {
          border-right: 1px solid #eee;
      }
      
      .user-marker-icon {
          width: 24px;
          height: 24px;
          background-color: #0f2bab;
          border-radius: 50%;
          border: 3px solid white;
          box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
          position: relative;
          transform-origin: center;
      }
      
      .user-marker-icon::after {
          content: '';
          position: absolute;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          width: 0;
          height: 0;
          border-left: 6px solid transparent;
          border-right: 6px solid transparent;
          border-bottom: 10px solid white;
          transform-origin: center;
      }
      
      .cluster-icon {
          width: 100%;
          height: 100%;
          display: flex;
          justify-content: center;
          align-items: center;
          background-color: #0f2bab;
          color: white;
          border-radius: 50%;
          font-weight: bold;
          box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      }
  `;
  
  document.head.appendChild(style);
}

// Update user location
function updateUserLocation(position, forceUpdate = false) {
    // Validate position data
    if (!position || !position.coords) {
        console.warn("Invalid position object");
        return;
    }
    
    const { latitude, longitude, accuracy, heading, speed } = position.coords;
    
    if (isNaN(latitude) || isNaN(longitude)) {
        console.warn("Invalid coordinates:", { latitude, longitude });
        return;
    }
    
    // Create position object
    const newPosition = {
        lat: latitude,
        lng: longitude,
        accuracy: accuracy || 20,
        heading: heading !== null ? heading : (lastPosition?.heading || 0),
        timestamp: position.timestamp || Date.now(),
        speedMPS: speed !== null ? speed : (lastPosition?.speedMPS || 0)
    };
    
    // If this is the first position update, initialize
    if (isFirstPositionUpdate) {
        isFirstPositionUpdate = false;
        initializeFirstPosition(newPosition);
        return;
    }
    
    // Skip if position hasn't changed significantly and not forced
    if (lastPosition && !forceUpdate) {
        const distance = calculateDistance(lastPosition, newPosition);
        const timeDelta = (newPosition.timestamp - lastPosition.timestamp) / 1000;
        
        // Skip if position hasn't changed and time delta is small
        if (distance < MIN_DISTANCE_THRESHOLD && timeDelta < 1.0) {
            return;
        }
    }
    
    // Check for sudden movements or position jumps
    if (lastPosition) {
        const isJump = detectSuddenMovement(newPosition, lastPosition);
        if (isJump) {
            handlePositionJump(newPosition);
            return;
        }
        
        // Check for large position changes
        const distance = calculateDistance(lastPosition, newPosition);
        if (distance > EXTENDED_DISTANCE_THRESHOLD) {
            handleLargePositionChange(newPosition);
            return;
        }
    }
    
    // Apply Kalman filter
    const motionDetected = isDeviceInMotion();
    const filteredPosition = kalmanFilter.update(newPosition, motionDetected);
    
    // Update position buffer
    updatePositionBuffer(filteredPosition);
    
    // Update position history for jump detection
    updatePositionHistory(filteredPosition);
    
    // Update stationary state
    updateStationaryState(filteredPosition, motionDetected);
    
    // Update last position
    lastPosition = filteredPosition;
    lastValidPosition = filteredPosition;
    lastUpdateTime = filteredPosition.timestamp;
    
    // If we're following the user and not in the middle of a transition
    if (followUser && !isTransitioning && !isMapInteracting) {
        // Start position interpolation
        if (positionInterpolator && lastRenderPosition) {
            positionInterpolator.start(
                lastRenderPosition,
                filteredPosition,
                ANIMATION_DURATION
            );
        } else {
            // Add to position update queue
            positionUpdateQueue.push(filteredPosition);
        }
    } else {
        // Just update marker position without animation
        userMarker.setLatLng([filteredPosition.lat, filteredPosition.lng]);
    }
    
    // Update distance box
    updateDistanceBox();
    
    // Update GPS accuracy indicator
    const now = Date.now();
    if (now - lastAccuracyUpdate > 2000) { // Update every 2 seconds
        lastAccuracyUpdate = now;
        
        domUpdateManager.schedule('accuracyIndicator', () => {
            const indicator = document.getElementById('accuracyIndicator');
            const dot = indicator.querySelector('.accuracy-dot');
            const text = document.getElementById('accuracyText');
            
            // Update based on accuracy
            if (filteredPosition.accuracy <= 10) {
                dot.className = 'accuracy-dot accuracy-high';
                text.textContent = 'GPS: High Accuracy';
            } else if (filteredPosition.accuracy <= 30) {
                dot.className = 'accuracy-dot accuracy-medium';
                text.textContent = 'GPS: Medium Accuracy';
            } else {
                dot.className = 'accuracy-dot accuracy-low';
                text.textContent = 'GPS: Low Accuracy';
            }
        });
    }
}

// Initialize the map
document.addEventListener('DOMContentLoaded', initMap);
    </script>
</body>
</html>
