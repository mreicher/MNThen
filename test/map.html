<!DOCTYPE html>
<html lang="en">
<head> 
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, viewport-fit=cover">
    <title>Ultra-Smooth Minnesota Then - Single Page App</title>
    <link rel="shortcut icon" type="image/x-icon" href="https://www.mnthen.com/images/mnthenfav.ico">
    
    <!-- Resource hints for faster connections -->
    <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
    <link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
    <link rel="preconnect" href="https://unpkg.com" crossorigin>
    <link rel="preconnect" href="https://www.mnthen.com" crossorigin>
    <link rel="dns-prefetch" href="https://tile.openstreetmap.org">

    <!-- Optimized CSS loading with preload -->
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css"></noscript>
    
    <!-- Other stylesheets with preload for critical resources -->
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <noscript>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.css">
    </noscript>
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css">
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css" />
    <link rel="stylesheet" href="https://www.mnthen.com/css/mainmap.css">
    <link rel="stylesheet" href="https://www.mnthen.com/css/mnthen_main_map2.css">

    <style>
        /* Critical CSS inlined for faster rendering */
        :root {
            --primary-color: #0066cc;
            --hover-color: #e6f0ff;
            --dark-blue: #1a3a8a;
            --dark-blue-hover: #0d2c6e;
        }

        /* FOUC Prevention - Hide main content initially */
        body:not(.loading-complete) #mainContent {
            opacity: 0;
            visibility: hidden;
        }

        body.loading-complete #mainContent {
            opacity: 1;
            visibility: visible;
            transition: opacity 0.5s ease;
        }

        /* Loading screen will be created by JavaScript */
        body.loading-complete #loadingMessage {
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.4s ease;
        }

        #map {
            touch-action: manipulation;
            -webkit-user-select: none;
            user-select: none;
            height: 100vh;
            width: 100vw;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            will-change: transform;
            transform: translateZ(0);
            backface-visibility: hidden;
        }

        /* Fix for iOS Safari 100vh issue */
        @supports (-webkit-touch-callout: none) {
            #map, .lochunt-container {
                height: -webkit-fill-available;
            }
        }
        
        /* Optimized user marker with hardware acceleration */
        .user-marker {
            will-change: transform;
            transform: translateZ(0);
            backface-visibility: hidden;
        }
        
        .user-marker-icon {
            width: 16px;
            height: 16px;
            background: radial-gradient(circle, #007bff 40%, rgba(0, 123, 255, 0.3) 70%);
            border: 2px solid white;
            border-radius: 50%;
            box-shadow: 0 0 8px rgba(0, 123, 255, 0.6);
            will-change: transform;
            transform: translateZ(0);
            animation: pulse-location 2s infinite ease-in-out;
        }
        
        @keyframes pulse-location {
            0%, 100% { 
                opacity: 1;
                transform: scale(1) translateZ(0);
            }
            50% { 
                opacity: 0.7;
                transform: scale(1.1) translateZ(0);
            }
        }
        
        /* Responsive loading message */
        @media (max-width: 500px) {
            #loadingMessage > div {
                width: 85% !important;
                height: auto !important;
                min-height: 480px !important;
                padding: 25px 20px !important;
            }
        }

        /* Enhanced animations with hardware acceleration */
        @keyframes pulse {
            0%, 100% { 
                opacity: 0.8; 
                transform: translateZ(0);
            }
            50% { 
                opacity: 1; 
                transform: translateZ(0);
            }
        }
        
        @keyframes gradientShift {
            0% { 
                background-position: 0% 50%; 
                transform: translateZ(0);
            }
            50% { 
                background-position: 100% 50%; 
                transform: translateZ(0);
            }
            100% { 
                background-position: 0% 50%; 
                transform: translateZ(0);
            }
        }

        /* Optimized fade animations */
        .fade-in {
            animation: fadeIn 0.25s ease forwards;
        }
        
        .fade-out {
            animation: fadeOut 0.25s ease forwards;
        }
        
        @keyframes fadeIn {
            from { 
                opacity: 0; 
                transform: translateZ(0);
            }
            to { 
                opacity: 1; 
                transform: translateZ(0);
            }
        }
        
        @keyframes fadeOut {
            from { 
                opacity: 1; 
                transform: translateZ(0);
            }
            to { 
                opacity: 0; 
                transform: translateZ(0);
            }
        }

        /* Navigation reminder modal styles */
        .navigation-reminder-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10001;
            opacity: 0;
            transition: opacity 0.3s ease;
            will-change: opacity;
        }

        .navigation-reminder-content {
            background-color: white;
            border-radius: 16px;
            padding: 30px;
            width: 90%;
            max-width: 400px;
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.3);
            text-align: center;
            transform: translateY(20px) translateZ(0);
            transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            will-change: transform;
        }

        .navigation-reminder-modal.show {
            opacity: 1;
        }

        .navigation-reminder-modal.show .navigation-reminder-content {
            transform: translateY(0) translateZ(0);
        }
        
        /* Hardware acceleration for all interactive elements */
        .map-button, .audio-button, button {
            will-change: transform;
            transform: translateZ(0);
            backface-visibility: hidden;
        }
        
        /* Optimized marker clusters */
        .marker-cluster-custom {
            will-change: transform;
            transform: translateZ(0);
            backface-visibility: hidden;
        }
        
        /* Smooth scrolling optimization */
        * {
            -webkit-overflow-scrolling: touch;
            scroll-behavior: smooth;
        }
    </style>
</head>
<body>
    <!-- Main Content - Hidden initially -->
    <div id="mainContent">
        <!-- Map container -->
        <div id="map"></div>
        <div id="distanceBox">Initializing...</div>

        <!-- Location Hunt Container -->
        <div class="lochunt-container">
            <img id="locationImage" src="/placeholder.svg" alt="Location Image">
            <div class="lochunt-content">
                <div class="lochunt-info">
                    <h2 id="locationTitle" class="mb-2 text-primary"></h2>
                    <p id="locationCity" class="text-muted mb-1"></p>
                    <p id="locationCreator" class="text-muted mb-3"></p>
                </div>
                <div class="audio-player">
                    <div class="audio-progress">
                        <div class="progress">
                            <div id="progressBar" class="progress-bar" role="progressbar" style="width: 0%"></div>
                        </div>
                    </div>
                    <div class="audio-time">
                        <span id="currentTime">0:00</span>
                        <span id="duration">0:00</span>
                    </div>
                    <div class="audio-controls">
                        <button id="rewindBtn" class="audio-button" aria-label="Rewind 10 seconds"><i class="fas fa-backward"></i></button>
                        <button id="playPauseBtn" class="audio-button" aria-label="Play"><i class="fas fa-play"></i></button>
                        <button id="forwardBtn" class="audio-button" aria-label="Forward 10 seconds"><i class="fas fa-forward"></i></button>
                    </div>
                    <audio id="locationAudio" src="/placeholder.svg" preload="auto"></audio>
                </div>
            </div>
        </div>

        <!-- Additional Info Container -->
        <div class="additional-info-container">
            <h3 class="mb-3 text-primary text-center">Did You Know?</h3>
            <p id="additionalInfo" class="mb-3 fs-6"></p>
            <div class="d-flex justify-content-center">
                <button id="continueButton" class="btn btn-primary">Continue</button>
            </div>
        </div>
        
        <!-- Map Buttons -->
        <div class="map-buttons">
            <button id="recenterButton" class="map-button" aria-label="Recenter map"><i class="fas fa-crosshairs"></i></button>
            <button id="returnButton" class="map-button" aria-label="Return to main page"><i class="fas fa-sign-out-alt"></i></button>
            <button id="tipsButton" class="map-button" aria-label="Show navigation tips"><i class="fas fa-question-circle"></i></button>
        </div>

        <!-- Summary Modal -->
        <div id="summaryModal" class="modal" style="display: none;">
            <div class="modal-content">
                <p id="summaryContent"></p>
            </div>
        </div>
    </div>

    <!-- Load scripts with defer to improve page load performance -->
    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js" defer></script>
    <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js" defer></script>

    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>

    <script>
    // Firebase Configuration
    const firebaseConfig = {
        apiKey: "AIzaSyBDUAF3qJGhLYQJPHyWwY0JzonN5l8ERzE",
        authDomain: "mnthen-3151d.firebaseapp.com",
        databaseURL: "https://mnthen-3151d-default-rtdb.firebaseio.com",
        projectId: "mnthen-3151d",
        storageBucket: "mnthen-3151d.appspot.com",
        messagingSenderId: "416231360428",
        appId: "1:416231360428:web:36f69cc231be2d84a8dc09"
    };

    // Ultra-optimized configuration for maximum smoothness
    const CONFIG = {
        // Ultra-responsive distance thresholds
        DISTANCE_THRESHOLD: 20,
        EXTENDED_DISTANCE_THRESHOLD: 100,
        MIN_DISTANCE_THRESHOLD: 1.5, // More sensitive
        PROXIMITY_THRESHOLD: 50,
        JITTER_THRESHOLD: 3, // More sensitive to movement
        MICRO_MOVEMENT_THRESHOLD: 0.2, // Ultra-sensitive
        
        // Ultra-responsive timing for 60fps smoothness
        BACKGROUND_THRESHOLD: 15000,
        INACTIVITY_TIMEOUT: 20000,
        UPDATE_INTERVAL: 16, // 60fps
        MIN_CENTERING_INTERVAL: 500, // More responsive
        STATIONARY_TIME_THRESHOLD: 3000,
        STATIONARY_CHECK_INTERVAL: 1500,
        SIGNIFICANT_MOVEMENT_COOLDOWN: 1000,
        RETRY_DELAY: 600,
        ZOOM_COOLDOWN: 2000,
        MIN_RECENTER_INTERVAL: 1000, // More responsive
        
        // Optimized buffer sizes
        MAX_BUFFER_SIZE: 3, // Smaller for more responsiveness
        STATIONARY_BUFFER_SIZE: 6,
        
        // Enhanced accuracy thresholds
        MAX_ACCEPTABLE_ACCURACY: 30,
        STATIONARY_ACCURACY_MULTIPLIER: 1.02,
        STATIONARY_ACCURACY_WEIGHT: 0.8,
        MAX_ACCURACY_THRESHOLD: 2000,
        TARGET_ACCURACY_THRESHOLD: 70,
        
        // Ultra-smooth movement parameters
        MAX_SPEED: 50,
        VELOCITY_DECAY: 0.88, // More responsive
        BEARING_WEIGHT: 0.3,
        SMOOTHING_FACTOR: 0.4, // More responsive
        STATIONARY_THRESHOLD: 1.5,
        STATIONARY_SMOOTHING: 0.94,
        STATIONARY_THRESHOLDB: 2.0,
        MAX_ALPHA: 0.22, // More responsive
        MIN_ALPHA: 0.015,
        MAX_RETRIES: 2,
        
        // Enhanced edge detection for smoother centering
        EDGE_THRESHOLD_PERCENTAGE: 0.20,
        STRICT_EDGE_THRESHOLD_PERCENTAGE: 0.10,
        CRITICAL_EDGE_THRESHOLD_PERCENTAGE: 0.05,
        
        // Zoom levels
        BASE_ZOOM: 17,
        CLOSE_ZOOM: 18,
        
        // Ultra-responsive Kalman filter
        BASE_PROCESS_NOISE: 0.006,
        
        // Enhanced speed-based zoom
        SPEED_ZOOM_THRESHOLDS: [
            { speed: 35, zoom: 16 },
            { speed: 25, zoom: 16 },
            { speed: 15, zoom: 17 },
            { speed: 0, zoom: 17 }
        ]
    };
    
    // State variables with enhanced initialization
    let map, userMarker, markerClusterGroup;
    let tracking = false;
    let currentLocationIndex = 0;
    let visitedLocations = [];
    let gameLocations = [];
    let isLocationHuntVisible = false;
    let lastPosition = null;
    let positionBuffer = [];
    let filteredPosition = null;
    let followUser = true;
    let locationCooldowns = new Map();
    let lastVisitedLocationId = null;
    let lastKnownPosition = null;
    let isTransitioning = false;
    let lastVelocity = { lat: 0, lng: 0 };
    let isMapInteracting = false;
    let isStationary = false;
    let stationaryStartTime = null;
    let stationaryCheckTimeout = null;
    let lastUpdateTime = null;
    let lastUpdateTimestamp = null;
    let stationaryBuffer = [];
    let stationaryPosition = null;
    let stationaryCount = 0;
    let lastSmoothedPosition = null;
    let lastHiddenTime = 0;
    let retryCount = 0;
    let inactivityTimer;
    let animationFrameId = null;
    let loadingMessageMinDisplayTime = 0;
    let lastCenteringTime = 0;
    let lastZoomChangeTime = 0;
    let isNearLocation = false;
    let lastMapUpdateTime = 0;
    let lastVisitTime = 0;
    let lastSignificantMovement = Date.now();
    let lastPositionForJitter = null;
    
    // Firebase variables
    let firebaseApp;
    let database;
    let locationsRef;
    let locationsLoaded = false;
    
    // Ultra-smooth performance optimization variables
    let performanceMode = 'ultra-smooth';
    let frameSkipCounter = 0;
    let lastPerformanceCheck = Date.now();
    let smoothingQueue = [];
    let interpolationBuffer = [];
    
    // Navigation state tracking
    let isReturningFromNavigation = false;
    let lastNavigationTime = 0;

    // Function to show main content after loading
    function showMainContent() {
        document.body.classList.add('loading-complete');
    }

    // Function to show navigation reminder modal
    function showNavigationReminderModal(appName, redirectUrl) {
        const modal = document.createElement('div');
        modal.className = 'navigation-reminder-modal';
        
        modal.innerHTML = `
            <div class="navigation-reminder-content">
                <div style="margin-bottom: 20px;">
                    <i class="fas fa-route" style="font-size: 48px; color: var(--primary-color); margin-bottom: 15px;"></i>
                </div>
                <h3 style="margin: 0 0 15px 0; color: var(--dark-blue); font-size: 1.4rem; font-weight: 600;">
                    Opening ${appName}
                </h3>
                <p style="margin: 0 0 25px 0; color: #666; line-height: 1.5; font-size: 1rem;">
                    Return to the app after reaching your destination.
                </p>
                <div style="display: flex; justify-content: center; gap: 15px;">
                    <button id="proceedBtn" style="
                        padding: 12px 24px;
                        background-color: var(--primary-color);
                        color: white;
                        border: none;
                        border-radius: 8px;
                        cursor: pointer;
                        font-size: 1rem;
                        font-weight: 600;
                        transition: background-color 0.2s ease;
                    ">Continue</button>
                    <button id="cancelBtn" style="
                        padding: 12px 24px;
                        background-color: transparent;
                        color: var(--primary-color);
                        border: 2px solid var(--primary-color);
                        border-radius: 8px;
                        cursor: pointer;
                        font-size: 1rem;
                        font-weight: 600;
                        transition: all 0.2s ease;
                    ">Cancel</button>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
        
        // Show modal with animation
        setTimeout(() => {
            modal.classList.add('show');
        }, 10);
        
        // Handle proceed button
        modal.querySelector('#proceedBtn').addEventListener('click', () => {
            lastNavigationTime = Date.now();
            modal.classList.remove('show');
            setTimeout(() => {
                document.body.removeChild(modal);
                window.open(redirectUrl, '_blank');
            }, 300);
        });
        
        // Handle cancel button
        modal.querySelector('#cancelBtn').addEventListener('click', () => {
            modal.classList.remove('show');
            setTimeout(() => {
                document.body.removeChild(modal);
            }, 300);
        });
        
        // Handle click outside modal
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                modal.classList.remove('show');
                setTimeout(() => {
                    document.body.removeChild(modal);
                }, 300);
            }
        });
    }
    
    // Initialize Firebase with optimized error handling
    function initFirebase() {
        try {
            firebaseApp = firebase.initializeApp(firebaseConfig);
            database = firebase.database();
            locationsRef = database.ref('locations');
            console.log("Firebase initialized successfully");
            return true;
        } catch (error) {
            console.error("Error initializing Firebase:", error);
            showPopup("Firebase Error", "Unable to connect to the database. Please check your internet connection and try again.");
            return false;
        }
    }

    // Optimized location loading from Firebase
    function loadLocationsFromFirebase() {
        return new Promise((resolve, reject) => {
            if (!locationsRef) {
                reject(new Error("Firebase not initialized"));
                return;
            }

            console.log("Loading locations from Firebase...");
            
            locationsRef.once('value')
                .then(snapshot => {
                    if (!snapshot.exists()) {
                        console.warn("No locations found in Firebase");
                        resolve([]);
                        return;
                    }
                    
                    const firebaseLocations = [];
                    const startTime = performance.now();
                    
                    snapshot.forEach(childSnapshot => {
                        const location = childSnapshot.val();
                        
                        const lat = parseFloat(location.lat);
                        const lng = parseFloat(location.lng);
                        
                        if (!isFinite(lat) || !isFinite(lng)) {
                            console.warn("Invalid coordinates for location:", location.id);
                            return;
                        }
                        
                        firebaseLocations.push({
                            id: location.id,
                            lat: lat,
                            lng: lng,
                            name: location.name || location.title,
                            title: location.title || location.name,
                            image: location.image,
                            creator: location.creator,
                            city: location.city,
                            audio: location.audio,
                            tours: location.tours,
                            summary: location.summary,
                            today: location.today,
                            link: location.link,
                            imageSource: location.imageSource,
                            additionalInfo: location.additionalInfo
                        });
                    });
                    
                    const loadTime = performance.now() - startTime;
                    console.log(`Loaded ${firebaseLocations.length} locations from Firebase in ${loadTime.toFixed(2)}ms`);
                    resolve(firebaseLocations);
                })
                .catch(error => {
                    console.error("Error loading locations from Firebase:", error);
                    reject(error);
                });
        });
    }
    
    // Ultra-smooth Kalman filter with enhanced performance
    const kalmanFilter = {
        x: { estimate: 0, error: 1 },
        y: { estimate: 0, error: 1 },
        q: CONFIG.BASE_PROCESS_NOISE,
        r: 1,
        lastTimestamp: null,
        velocityX: 0,
        velocityY: 0,
        
        update: function(measurement) {
            if (this.x.estimate === 0 && this.y.estimate === 0) {
                this.x.estimate = measurement.lng;
                this.y.estimate = measurement.lat;
                this.velocityX = 0;
                this.velocityY = 0;
                return { ...measurement };
            }
            
            const r = this.r * (measurement.accuracy ? (measurement.accuracy * 0.08) : 1); // More responsive
            
            // Enhanced velocity tracking
            if (measurement.timestamp && this.lastTimestamp) {
                const dt = (measurement.timestamp - this.lastTimestamp) * 0.001;
                if (dt > 0) {
                    const newVelX = (measurement.lng - this.x.estimate) / dt;
                    const newVelY = (measurement.lat - this.y.estimate) / dt;
                    
                    this.velocityX = this.velocityX * 0.7 + newVelX * 0.3;
                    this.velocityY = this.velocityY * 0.7 + newVelY * 0.3;
                }
            }
            
            // X coordinate with velocity prediction
            const predX = this.x.estimate + (this.velocityX * 0.1);
            const predErrX = this.x.error + this.q;
            const gainX = predErrX / (predErrX + r);
            this.x.estimate = predX + gainX * (measurement.lng - predX);
            this.x.error = (1 - gainX) * predErrX;
            
            // Y coordinate with velocity prediction
            const predY = this.y.estimate + (this.velocityY * 0.1);
            const predErrY = this.y.error + this.q;
            const gainY = predErrY / (predErrY + r);
            this.y.estimate = predY + gainY * (measurement.lat - predY);
            this.y.error = (1 - gainY) * predErrY;
            
            // Dynamic noise adjustment
            if (measurement.speedMPS && measurement.timestamp && this.lastTimestamp) {
                const dt = (measurement.timestamp - this.lastTimestamp) * 0.001;
                if (dt > 0 && measurement.speedMPS > 0.3) {
                    this.q = Math.min(0.02, CONFIG.BASE_PROCESS_NOISE + (measurement.speedMPS * 0.001));
                }
            }
            this.lastTimestamp = measurement.timestamp;
            
            return {
                lat: this.y.estimate,
                lng: this.x.estimate,
                accuracy: measurement.accuracy,
                timestamp: measurement.timestamp,
                heading: measurement.heading,
                speedMPS: measurement.speedMPS
            };
        },
        
        reset: function(measurement) {
            this.x.estimate = measurement.lng;
            this.y.estimate = measurement.lat;
            this.x.error = 1;
            this.y.error = 1;
            this.velocityX = 0;
            this.velocityY = 0;
            this.lastTimestamp = measurement.timestamp;
        }
    };

    // Ultra-smooth position validation
    function isValidPosition(pos) {
        return pos && 
               typeof pos.lat === 'number' && 
               typeof pos.lng === 'number' && 
               isFinite(pos.lat) && 
               isFinite(pos.lng) &&
               Math.abs(pos.lat) <= 90 &&
               Math.abs(pos.lng) <= 180;
    }

    // Enhanced memory management for ultra-smooth performance
    function setupMemoryManagement() {
        const cleanupTasks = [];
        
        const registerCleanupTask = (task) => {
            cleanupTasks.push(task);
        };
        
        const cleanupAudioResources = () => {
            const audioElements = document.querySelectorAll('audio');
            audioElements.forEach(audio => {
                audio.pause();
                audio.src = '';
                audio.load();
            });
        };
        
        const cleanupMapResources = () => {
            if (markerClusterGroup) {
                markerClusterGroup.clearLayers();
            }
            
            if (animationFrameId !== null) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            
            clearTimeout(stationaryCheckTimeout);
            clearTimeout(inactivityTimer);
            
            // Clear smoothing buffers
            smoothingQueue = [];
            interpolationBuffer = [];
        };
        
        registerCleanupTask(cleanupAudioResources);
        registerCleanupTask(cleanupMapResources);
        
        const executeCleanup = () => {
            cleanupTasks.forEach(task => {
                try {
                    task();
                } catch (e) {
                    console.error('Error during cleanup:', e);
                }
            });
        };
        
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                cleanupAudioResources();
            } else {
                const now = Date.now();
                if (now - lastNavigationTime < 30000) {
                    isReturningFromNavigation = true;
                    console.log("Detected return from navigation app");
                }
            }
        });
        
        window.addEventListener('beforeunload', executeCleanup);
        window.performCleanup = executeCleanup;
        
        return { registerCleanupTask, executeCleanup };
    }

    // Initialize memory management
    const memoryManager = setupMemoryManagement();
        
    // Ultra-optimized map initialization
    function initMap() {
        console.log("Leaflet version:", L.version);
        
        map = L.map('map', {
            zoomControl: false,
            attributionControl: false,
            zoomSnap: 0.05, // Ultra-smooth zoom
            zoomDelta: 0.3,
            wheelDebounceTime: 40,
            tapTolerance: 10,
            bounceAtZoomLimits: false,
            preferCanvas: true,
            renderer: L.canvas({ padding: 0.1 }),
            touchZoom: true,
            dragging: true,
            tap: true,
            maxBoundsViscosity: 0.9,
            inertia: true,
            inertiaDeceleration: 3000,
            inertiaMaxSpeed: 2000,
            worldCopyJump: false
        }).fitWorld();
        
        // Ultra-optimized tile layer
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            minZoom: 7,
            maxZoom: 18,
            attribution: '',
            updateWhenIdle: false, // More responsive
            updateWhenZooming: true, // Smoother
            keepBuffer: 2,
            maxNativeZoom: 18,
            tileSize: 256,
            crossOrigin: true,
            opacity: 1
        }).addTo(map);
        
        // Ultra-smooth marker cluster
        markerClusterGroup = L.markerClusterGroup({
            showCoverageOnHover: false,
            zoomToBoundsOnClick: true,
            spiderfyOnMaxZoom: true,
            animate: true,
            chunkedLoading: true,
            chunkProgress: updateLoadingStatus,
            chunkDelay: 8, // Faster for smoother loading
            maxClusterRadius: (zoom) => zoom > 16 ? 30 : 70,
            iconCreateFunction: (cluster) => L.divIcon({
                html: `<div><span>${cluster.getChildCount()}</span></div>`,
                className: 'marker-cluster-custom',
                iconSize: L.point(32, 32)
            })
        });
        map.addLayer(markerClusterGroup);
        
        // Ultra-smooth user marker
        userMarker = L.marker([0, 0], {
            icon: L.divIcon({
                className: 'user-marker',
                html: '<div class="user-marker-icon"></div>',
                iconSize: [16, 16],
                iconAnchor: [8, 8]
            }),
            zIndexOffset: 1000
        }).addTo(map);
        
        // Initialize Firebase and load locations
        if (initFirebase()) {
            loadLocationsFromFirebase()
                .then(locations => {
                    if (locations && locations.length > 0) {
                        gameLocations = locations.sort((a, b) => a.id - b.id);
                        locationsLoaded = true;
                        console.log("Locations loaded successfully");
                        
                        showLoadingMessage();
                        if ("geolocation" in navigator) {
                            navigator.geolocation.getCurrentPosition(
                                initializeUserLocation,
                                (error) => {
                                    navigator.geolocation.getCurrentPosition(
                                        initializeUserLocation,
                                        handleLocationError,
                                        { enableHighAccuracy: true, timeout: 30000, maximumAge: 0 }
                                    );
                                },
                                { enableHighAccuracy: true, timeout: 30000, maximumAge: 0 }
                            );
                        } else {
                            showPopup("Geolocation Error", "Geolocation is not supported by your browser");
                            map.setView([44.9778, -93.2650], 17);
                            hideLoadingMessage();
                        }
                    } else {
                        showPopup("Error", "No locations found in the database. Please try again later.");
                        hideLoadingMessage();
                    }
                })
                .catch(error => {
                    console.error("Error loading locations:", error);
                    showPopup("Database Error", "Unable to load location data. Please check your internet connection and try again.");
                    hideLoadingMessage();
                });
        } else {
            hideLoadingMessage();
        }
    }

    // Optimized loading status update
    function updateLoadingStatus(processed, total, elapsed) {
        if (processed === total) {
            console.log(`Loaded ${processed} markers in ${elapsed.toFixed(2)}ms`);
        }
    }

    // Enhanced loading message with ultra-smooth animation
    function showLoadingMessage() {
        const existingMessage = document.getElementById('loadingMessage');
        if (existingMessage) return;
        
        loadingMessageMinDisplayTime = Date.now() + 10000;
        
        const loadingMessage = document.createElement('div');
        loadingMessage.id = 'loadingMessage';
        loadingMessage.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            background-image: url('https://raw.githubusercontent.com/mreicher/MNThen/refs/heads/main/images/splash_screen.webp');
            background-size: cover;
            background-position: center;
            z-index: 10000;
            font-family: 'Montserrat', 'Segoe UI', 'Roboto', sans-serif;
            transition: opacity 0.4s ease;
            will-change: opacity;
            transform: translateZ(0);
        `;
        
        const contentContainer = document.createElement('div');
        contentContainer.style.cssText = `
            display: grid;
            grid-template-rows: auto auto 1fr auto auto;
            background-color: white;
            padding: 30px 25px;
            border-radius: 18px;
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.3), 0 2px 8px rgba(0, 0, 0, 0.15);
            width: 420px;
            height: 480px;
            text-align: center;
            backdrop-filter: blur(4px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            will-change: transform;
            transform: translateZ(0);
        `;
        
        const logoImage = document.createElement('img');
        logoImage.src = 'https://mnthen.com/images/logo.webp';
        logoImage.alt = 'Minnesota Then Logo';
        logoImage.style.cssText = `
            width: 160px;
            height: auto;
            margin: 0 auto 20px;
            border-radius: 10px;
            object-fit: contain;
            filter: drop-shadow(0 3px 6px rgba(0, 40, 85, 0.15));
            will-change: transform;
            transform: translateZ(0);
        `;
        
        const mainTitle = document.createElement('h1');
        mainTitle.style.cssText = `
            margin: 0 0 6px 0;
            font-size: 20px;
            font-weight: 700;
            color: #002855;
            text-align: center;
            line-height: 1.2;
            letter-spacing: -0.01em;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.04);
        `;
        mainTitle.textContent = 'The Museum Without Walls';
        
        const welcomeMessage = document.createElement('h2');
        welcomeMessage.style.cssText = `
            margin: 0 0 35px 0;
            font-size: 16px;
            font-weight: 500;
            color: #0066cc;
            text-align: center;
            line-height: 1.3;
            letter-spacing: 0.01em;
            opacity: 0.9;
        `;
        welcomeMessage.textContent = 'Where Every Step Tells A Story';
        
        const statusTextContainer = document.createElement('div');
        statusTextContainer.style.cssText = `
            min-height: 55px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 18px;
        `;
        
        const statusText = document.createElement('p');
        statusText.id = 'loadingStatusText';
        statusText.style.cssText = `
            margin: 0;
            font-size: 16px;
            font-weight: 500;
            text-align: center;
            color: #0077dd;
            line-height: 1.4;
            animation: pulse 2s infinite;
            letter-spacing: 0.005em;
        `;
        statusText.textContent = 'Loading location data from Firebase...';
        statusTextContainer.appendChild(statusText);
        
        const progressContainer = document.createElement('div');
        progressContainer.style.cssText = `
            width: 100%;
            height: 8px;
            background-color: rgba(0, 51, 102, 0.06);
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 10px;
            box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.1);
        `;
        
        const progressBar = document.createElement('div');
        progressBar.id = 'loadingProgressBar';
        progressBar.style.cssText = `
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #0066cc, #0099ff, #00aaff, #0099ff, #0066cc);
            background-size: 200% auto;
            border-radius: 8px;
            transition: width 0.1s cubic-bezier(0.4, 0.0, 0.2, 1);
            box-shadow: 0 0 8px rgba(0, 120, 255, 0.5);
            animation: gradientShift 2.5s ease infinite;
            will-change: width, background-position;
            transform: translateZ(0);
        `;
        
        progressContainer.appendChild(progressBar);
        
        const noteContainer = document.createElement('div');
        noteContainer.style.cssText = `
            min-height: 45px;
            display: flex;
            align-items: center;
            justify-content: center;
        `;
        
        const loadingNote = document.createElement('p');
        loadingNote.style.cssText = `
            margin: 0;
            font-size: 14px;
            color: #555;
            font-weight: 500;
            opacity: 0.8;
        `;
        loadingNote.textContent = 'Preparing your ultra-smooth experience.';
        noteContainer.appendChild(loadingNote);
        
        contentContainer.appendChild(logoImage);
        contentContainer.appendChild(mainTitle);
        contentContainer.appendChild(welcomeMessage);
        contentContainer.appendChild(statusTextContainer);
        contentContainer.appendChild(progressContainer);
        contentContainer.appendChild(noteContainer);
        
        loadingMessage.appendChild(contentContainer);
        document.body.appendChild(loadingMessage);
        
        // Ultra-smooth 10-second animation
        const totalDuration = 10000;
        const updateInterval = 60; // Ultra-smooth 16.67fps for loading
        const steps = totalDuration / updateInterval;
        let progress = 0;
        
        const animations = [
            "Connecting to Firebase...",
            "Loading location database...",
            "Processing coordinates...",
            "Preparing exhibit data...",
            "Loading points of interest...",
            "Optimizing for ultra-smooth movement...",
            "Finalizing experience..."
        ];
        
        const progressInterval = setInterval(() => {
            progress += (100 / steps);
            
            if (progressBar) {
                progressBar.style.width = `${Math.min(progress, 100)}%`;
            }
            
            if (statusText) {
                const animationIndex = Math.min(
                    Math.floor(progress / (100 / animations.length)),
                    animations.length - 1
                );
                statusText.textContent = animations[animationIndex];
            }
            
            if (progress >= 100) {
                clearInterval(progressInterval);
                tryHideLoadingMessage();
            }
        }, updateInterval);
        
        loadingMessage.dataset.progressInterval = progressInterval;
    }

    function tryHideLoadingMessage() {
        if (Date.now() >= loadingMessageMinDisplayTime) {
            fadeOutLoadingMessage();
        } else {
            const timeRemaining = loadingMessageMinDisplayTime - Date.now();
            setTimeout(fadeOutLoadingMessage, timeRemaining + 50);
        }
    }

    function fadeOutLoadingMessage() {
        const loadingMessage = document.getElementById('loadingMessage');
        if (!loadingMessage) return;
        
        if (loadingMessage.dataset.progressInterval) {
            clearInterval(parseInt(loadingMessage.dataset.progressInterval));
        }
        
        const progressBar = document.getElementById('loadingProgressBar');
        if (progressBar) {
            progressBar.style.width = '100%';
        }
        
        showMainContent();
        
        setTimeout(() => {
            if (loadingMessage && loadingMessage.parentNode) {
                loadingMessage.parentNode.removeChild(loadingMessage);
            }
        }, 400);
    }

    function hideLoadingMessage() {
        tryHideLoadingMessage();
    }

    // Ultra-smooth user location initialization
    function initializeUserLocation(position) {
        console.log("Initial position data:", JSON.stringify(position));

        if (!position?.coords) {
            console.error("Invalid initial position object");
            handleLocationError(new Error("Invalid initial position"));
            return;
        }

        const { latitude: userLat, longitude: userLng, accuracy } = position.coords;

        if (!isFinite(userLat) || !isFinite(userLng)) {
            console.error("Invalid initial coordinates:", { userLat, userLng });
            handleLocationError(new Error("Invalid initial coordinates"));
            return;
        }

        console.log("Valid initial position:", { userLat, userLng, accuracy });

        try {
            userMarker.setLatLng([userLat, userLng]);
            map.setView([userLat, userLng], 18);
            
            kalmanFilter.reset({
                lat: userLat,
                lng: userLng,
                accuracy: accuracy || 20,
                timestamp: Date.now()
            });
            
            hideLoadingMessage();
            startPositionUpdates();
            startHunt();
            
            const distanceBox = document.getElementById('distanceBox');
            distanceBox.classList.add('pulse');
            setTimeout(() => distanceBox.classList.remove('pulse'), 2500);
        } catch (error) {
            console.error("Error setting initial user location:", error);
            handleLocationError(error);
        }
    }

    // Ultra-smooth position updates
    function startPositionUpdates() {
        const watchId = navigator.geolocation.watchPosition(
            handlePositionUpdate,
            handleLocationError,
            {
                enableHighAccuracy: true,
                maximumAge: 500, // More responsive
                timeout: 6000
            }
        );
        
        window.positionWatchId = watchId;
        
        window.addEventListener('online', () => {
            if (window.positionWatchId) {
                navigator.geolocation.clearWatch(window.positionWatchId);
                window.positionWatchId = navigator.geolocation.watchPosition(
                    handlePositionUpdate,
                    handleLocationError,
                    {
                        enableHighAccuracy: true,
                        maximumAge: 500,
                        timeout: 6000
                    }
                );
            }
        });
        
        return watchId;
    }

    // Ultra-smooth position update handling
    function handlePositionUpdate(position) {
        if (!position?.coords || 
            !isFinite(position.coords.latitude) || 
            !isFinite(position.coords.longitude)) {
            console.warn("Invalid position data received");
            return;
        }
        
        const positionTimestamp = position.timestamp || Date.now();
        const currentTime = Date.now();
        const maxAgeMs = 20000; // More responsive
        
        if (currentTime - positionTimestamp > maxAgeMs) {
            console.warn("Position data too old, ignoring");
            return;
        }
        
        const accuracy = position.coords.accuracy || 0;
        window.lastPositionAccuracy = accuracy;
        
        window.lastValidPosition = {
            lat: position.coords.latitude,
            lng: position.coords.longitude,
            timestamp: positionTimestamp,
            accuracy: accuracy
        };
        
        updateUserLocation(position);
    }
        
    function handleVisibilityChange() {
        if (document.hidden) {
            lastHiddenTime = Date.now();
            lastKnownPosition = userMarker ? userMarker.getLatLng() : null;
        } else {
            const hiddenDuration = Date.now() - lastHiddenTime;
            
            if (isReturningFromNavigation) {
                console.log("Handling return from navigation - maintaining current state");
                isReturningFromNavigation = false;
                map.invalidateSize();
                return;
            }
            
            if (hiddenDuration > CONFIG.BACKGROUND_THRESHOLD) {
                updateLocationAfterBackground();
            } else {
                map.invalidateSize();
            }
        }
        resetInactivityTimer();
    }

    // Ultra-smooth background location update
    function updateLocationAfterBackground() {
        if (!("geolocation" in navigator)) {
            console.warn("Geolocation is not available");
            return;
        }
        
        const quickOptions = {
            enableHighAccuracy: false,
            timeout: 3000,
            maximumAge: 40000,
        };
        
        const accurateOptions = {
            enableHighAccuracy: true,
            timeout: 10000,
            maximumAge: 20000,
        };
        
        const fallbackOptions = {
            enableHighAccuracy: false,
            timeout: 15000,
            maximumAge: 80000,
        };

        const handleSuccess = (position) => {
            console.log("Background update raw position:", JSON.stringify(position));
            
            if (!position?.coords) {
                console.warn("Invalid position object in background update");
                return;
            }
            const { latitude, longitude, accuracy } = position.coords;
            if (!isFinite(latitude) || !isFinite(longitude)) {
                console.warn("Invalid coordinates in background update:", { latitude, longitude });
                return;
            }
            console.log("Valid background position update:", { lat: latitude, lng: longitude });
            
            try {
                updateUserLocation(position, true);
                
                // Reset all smoothing state for ultra-smooth restart
                lastPosition = null;
                positionBuffer = [];
                smoothingQueue = [];
                interpolationBuffer = [];
                lastVelocity = { lat: 0, lng: 0 };
                isStationary = false;
                stationaryStartTime = null;
                stationaryCount = 0;
                
                kalmanFilter.reset({
                    lat: latitude,
                    lng: longitude,
                    accuracy: accuracy,
                    heading: position.coords.heading || 0,
                    timestamp: Date.now(),
                });
                
                updateDistanceBox();
                followUser = true;
                map.invalidateSize();
            } catch (error) {
                console.error("Error in updateUserLocation during background update:", error);
            }
        };
        
        const handleError = (error, stage) => {
            console.error(`Error getting location during ${stage} attempt:`, error);
            
            switch (error.code) {
                case 1:
                    console.warn("User denied geolocation access");
                    break;
                    
                case 2:
                    if (stage === "quick") {
                        console.log("Quick position unavailable, trying accurate position...");
                        navigator.geolocation.getCurrentPosition(
                            handleSuccess,
                            (err) => handleError(err, "accurate"),
                            accurateOptions
                        );
                    } else if (stage === "accurate") {
                        console.log("Accurate position unavailable, trying fallback...");
                        navigator.geolocation.getCurrentPosition(
                            handleSuccess,
                            (err) => handleError(err, "fallback"),
                            fallbackOptions
                        );
                    } else {
                        console.warn("All position attempts failed - location unavailable");
                    }
                    break;
                    
                case 3:
                    if (stage === "quick") {
                        console.log("Quick position timed out, trying accurate position...");
                        navigator.geolocation.getCurrentPosition(
                            handleSuccess,
                            (err) => handleError(err, "accurate"),
                            accurateOptions
                        );
                    } else if (stage === "accurate") {
                        console.log("Accurate position timed out, trying fallback...");
                        navigator.geolocation.getCurrentPosition(
                            handleSuccess,
                            (err) => handleError(err, "fallback"),
                            fallbackOptions
                        );
                    } else {
                        console.warn("All position attempts timed out");
                    }
                    break;
                    
                default:
                    if (stage !== "fallback") {
                        console.log("Unknown error, trying fallback options...");
                        navigator.geolocation.getCurrentPosition(
                            handleSuccess,
                            (err) => handleError(err, "fallback"),
                            fallbackOptions
                        );
                    } else {
                        console.warn("All position attempts failed with unknown error");
                    }
            }
        };

        navigator.geolocation.getCurrentPosition(
            handleSuccess,
            (error) => handleError(error, "quick"),
            quickOptions
        );
    }
        
    // Enhanced position buffer for ultra-smooth movement
    function updatePositionBuffer(position) {
        positionBuffer.push({
            lat: position.lat,
            lng: position.lng,
            accuracy: position.accuracy,
            timestamp: position.timestamp,
            heading: position.heading,
            speedMPS: position.speedMPS
        });

        while (positionBuffer.length > CONFIG.MAX_BUFFER_SIZE) {
            positionBuffer.shift();
        }
        
        // Add to smoothing queue for ultra-smooth processing
        smoothingQueue.push(position);
        while (smoothingQueue.length > 5) {
            smoothingQueue.shift();
        }
    }

    // Ultra-smooth weighted position calculation
    function calculateWeightedPosition(positions, smoothingFactor = 0.85) {
        if (!Array.isArray(positions) || positions.length === 0) {
            return null;
        }

        const validPositions = positions.filter(pos => 
            pos && isFinite(pos.lat) && isFinite(pos.lng)
        );

        if (validPositions.length === 0) {
            return null;
        }

        let sumLat = 0, sumLng = 0, totalWeight = 0;

        for (let i = 0; i < validPositions.length; i++) {
            const position = validPositions[i];
            const weight = Math.pow(smoothingFactor, validPositions.length - i - 1);
            sumLat += position.lat * weight;
            sumLng += position.lng * weight;
            totalWeight += weight;
        }

        return {
            lat: sumLat / totalWeight,
            lng: sumLng / totalWeight,
            accuracy: Math.min(...validPositions.map(p => p.accuracy || 20)),
            timestamp: validPositions[validPositions.length - 1].timestamp,
            heading: validPositions[validPositions.length - 1].heading,
            speedMPS: validPositions[validPositions.length - 1].speedMPS
        };
    }

    // Ultra-smooth proximity checking
    function checkProximityForZoom() {
        const now = Date.now();
        if (!window.lastProximityCheck) window.lastProximityCheck = 0;
        if (now - window.lastProximityCheck < 100) return; // More responsive
        window.lastProximityCheck = now;
        
        if (!userMarker || !gameLocations?.length) return;
        
        const userPos = userMarker.getLatLng();
        if (!userPos || !isFinite(userPos.lat)) return;
        
        let closestDistance = Infinity;
        for (const loc of gameLocations) {
            if (!loc?.lat) continue;
            const dist = calculateDistance(userPos, loc);
            if (dist < closestDistance) closestDistance = dist;
        }
        
        const distanceFeet = closestDistance * 3.28084;
        
        const ZOOM_IN_THRESHOLD = CONFIG.PROXIMITY_THRESHOLD;
        const ZOOM_OUT_THRESHOLD = CONFIG.PROXIMITY_THRESHOLD * 1.2; // Less hysteresis for smoother transitions
        
        const currentTime = Date.now();
        
        if (typeof window.zoomedInState === 'undefined') {
            window.zoomedInState = false;
        }
        
        const previousState = window.zoomedInState;
        
        if (!window.zoomedInState && distanceFeet <= ZOOM_IN_THRESHOLD) {
            if (currentTime - lastZoomChangeTime >= CONFIG.ZOOM_COOLDOWN) {
                window.zoomedInState = true;
                isNearLocation = true;
                lastZoomChangeTime = currentTime;
                
                window.blockSpeedZoom = true;
                setTimeout(() => window.blockSpeedZoom = false, 3000);
                
                if (!isMapInteracting) {
                    map.flyTo(userPos, CONFIG.CLOSE_ZOOM, {
                        duration: 0.8, // Ultra-smooth duration
                        easeLinearity: 0.2
                    });
                }
            }
        } 
        else if (window.zoomedInState && distanceFeet >= ZOOM_OUT_THRESHOLD) {
            if (currentTime - lastZoomChangeTime >= CONFIG.ZOOM_COOLDOWN) {
                window.zoomedInState = false;
                isNearLocation = false;
                lastZoomChangeTime = currentTime;
                
                window.blockSpeedZoom = true;
                setTimeout(() => window.blockSpeedZoom = false, 3000);
                
                if (!isMapInteracting) {
                    map.flyTo(userPos, CONFIG.BASE_ZOOM, {
                        duration: 0.8,
                        easeLinearity: 0.2
                    });
                }
            }
        }
        
        if (previousState !== window.zoomedInState) {
            window.lastProximityZoomTime = currentTime;
        }
    }

    // Ultra-smooth speed-based zoom
    function getSpeedBasedZoom(speedMPS) {
        if (window.blockSpeedZoom || isNearLocation) {
            return -1;
        }
        
        if (typeof window.speedTrackingState === 'undefined') {
            window.speedTrackingState = {
                lowSpeedStartTime: null,
                isInTransit: false,
                lastSignificantMove: Date.now(),
                destinationArrivalTime: null,
                previousZoom: null,
                speedBuffer: [],
                lastSpeedMPH: 0,
                stationaryConfidence: 0,
                lastZoomUpdate: Date.now(),
                suddenJumpDetected: false,
                currentInterpolatedZoom: 17
            };
        }
        
        const state = window.speedTrackingState;
        const speedMPH = speedMPS * 2.23694;
        
        // Enhanced thresholds for ultra-smooth transitions
        const WALKING_THRESHOLD = 2.8;
        const SIGNIFICANT_TRAVEL_THRESHOLD = 9.0;
        const TEMPORARY_STOP_MAX = 60000;
        const ARRIVAL_DELAY = 12000;
        const SPEED_BUFFER_SIZE = 3; // Smaller for more responsiveness
        const MAX_SPEED_JUMP = 15;
        const STATIONARY_CONFIDENCE_MAX = 6;
        const MIN_ZOOM_UPDATE_INTERVAL = 1200;
        const ZOOM_INTERPOLATION_SPEED = 0.25; // More responsive
        
        state.speedBuffer.push(speedMPH);
        if (state.speedBuffer.length > SPEED_BUFFER_SIZE) {
            state.speedBuffer.shift();
        }
        
        const sortedSpeeds = [...state.speedBuffer].sort((a, b) => a - b);
        const medianSpeed = sortedSpeeds[Math.floor(sortedSpeeds.length / 2)];
        
        const speedDelta = Math.abs(medianSpeed - state.lastSpeedMPH);
        if (speedDelta > MAX_SPEED_JUMP) {
            console.debug("Sudden speed jump detected, ignoring:", 
                         {current: medianSpeed, previous: state.lastSpeedMPH});
            state.suddenJumpDetected = true;
            return state.currentInterpolatedZoom;
        } else {
            state.suddenJumpDetected = false;
        }
        
        state.lastSpeedMPH = medianSpeed;
        
        if (medianSpeed < 0.8) {
            state.stationaryConfidence = Math.min(STATIONARY_CONFIDENCE_MAX, 
                                               state.stationaryConfidence + 1);
        } else if (medianSpeed > WALKING_THRESHOLD) {
            state.stationaryConfidence = 0;
        } else {
            state.stationaryConfidence = Math.max(0, state.stationaryConfidence - 0.3);
        }
        
        if (medianSpeed >= SIGNIFICANT_TRAVEL_THRESHOLD && !state.suddenJumpDetected) {
            state.isInTransit = true;
            state.lastSignificantMove = Date.now();
            state.destinationArrivalTime = null;
        }
        
        let targetZoom;
        const now = Date.now();
        
        if (medianSpeed <= WALKING_THRESHOLD || state.stationaryConfidence > 2) {
            if (!state.lowSpeedStartTime) {
                state.lowSpeedStartTime = now;
            }
            
            const lowSpeedDuration = now - state.lowSpeedStartTime;
            
            if (state.isInTransit && lowSpeedDuration >= ARRIVAL_DELAY) {
                if (!state.destinationArrivalTime) {
                    state.destinationArrivalTime = now;
                }
                
                if (now - state.destinationArrivalTime >= 3000) {
                    state.isInTransit = false;
                    targetZoom = 17;
                } else {
                    targetZoom = state.previousZoom || 17;
                }
            } else if (state.isInTransit && now - state.lastSignificantMove < TEMPORARY_STOP_MAX) {
                targetZoom = state.previousZoom || 17;
            } else {
                targetZoom = 17;
            }
        } else {
            state.lowSpeedStartTime = null;
            state.destinationArrivalTime = null;
            
            for (const threshold of CONFIG.SPEED_ZOOM_THRESHOLDS) {
                if (medianSpeed >= threshold.speed) {
                    targetZoom = threshold.zoom;
                    break;
                }
            }
            
            if (typeof targetZoom === 'undefined') {
                targetZoom = 17;
            }
        }
        
        state.previousZoom = targetZoom;
        
        // Ultra-smooth interpolation
        if (state.currentInterpolatedZoom !== targetZoom) {
            state.currentInterpolatedZoom += (targetZoom - state.currentInterpolatedZoom) * ZOOM_INTERPOLATION_SPEED;
            
            if (Math.abs(state.currentInterpolatedZoom - targetZoom) < 0.02) {
                state.currentInterpolatedZoom = targetZoom;
            }
        }
        
        state.lastZoomUpdate = now;
        return state.currentInterpolatedZoom;
    }
        
    // Ultra-smooth exponential smoothing
    function applyExponentialSmoothing(newPosition, lastPosition, baseAlpha = 0.3) {
        if (!isValidPosition(newPosition) || !isValidPosition(lastPosition)) {
            return newPosition;
        }

        if (!lastSmoothedPosition) {
            lastSmoothedPosition = lastPosition;
        }

        const distance = calculateDistance(newPosition, lastSmoothedPosition);
        
        if (distance < CONFIG.MIN_DISTANCE_THRESHOLD) {
            stationaryCount = Math.min(stationaryCount + 1, CONFIG.STATIONARY_THRESHOLD);
        } else {
            stationaryCount = Math.max(stationaryCount - 1, 0);
        }

        let alpha = baseAlpha;

        if (stationaryCount >= CONFIG.STATIONARY_THRESHOLD) {
            alpha = CONFIG.MIN_ALPHA;
        } else {
            alpha = CONFIG.MAX_ALPHA - (stationaryCount / CONFIG.STATIONARY_THRESHOLD) * (CONFIG.MAX_ALPHA - CONFIG.MIN_ALPHA);
        }

        const accuracyRatio = Math.max(0, Math.min(1, 1 - (newPosition.accuracy / CONFIG.MAX_ACCEPTABLE_ACCURACY)));
        alpha = alpha * (0.6 + 0.4 * accuracyRatio); // More responsive

        if (newPosition.speedMPS !== undefined && newPosition.speedMPS < 0.4) {
            alpha *= 0.3; // More aggressive smoothing for stationary
        } else if (newPosition.speedMPS > 8) {
            alpha = Math.min(0.7, alpha * 1.8); // More responsive for movement
        }

        const timeDelta = newPosition.timestamp - lastPosition.timestamp;
        if (timeDelta < 800) {
            alpha *= 0.6;
        } else if (timeDelta > 4000) {
            alpha = Math.min(0.9, alpha * 2.2);
        }

        const smoothedPosition = {
            lat: lastSmoothedPosition.lat + alpha * (newPosition.lat - lastSmoothedPosition.lat),
            lng: lastSmoothedPosition.lng + alpha * (newPosition.lng - lastSmoothedPosition.lng),
            accuracy: Math.min(newPosition.accuracy, lastSmoothedPosition.accuracy),
            heading: newPosition.heading,
            timestamp: newPosition.timestamp,
            speedMPS: newPosition.speedMPS ? 
                      lastSmoothedPosition.speedMPS * 0.6 + newPosition.speedMPS * 0.4 :
                      newPosition.speedMPS
        };

        if (stationaryCount >= CONFIG.STATIONARY_THRESHOLD && lastSmoothedPosition.heading !== undefined) {
            smoothedPosition.heading = alpha * newPosition.heading + (1 - alpha) * lastSmoothedPosition.heading;
        }

        if (distance < CONFIG.MIN_DISTANCE_THRESHOLD * 0.3) {
            smoothedPosition.lat = lastSmoothedPosition.lat * 0.97 + smoothedPosition.lat * 0.03;
            smoothedPosition.lng = lastSmoothedPosition.lng * 0.97 + smoothedPosition.lng * 0.03;
        }

        lastSmoothedPosition = smoothedPosition;
        return smoothedPosition;
    }

    // Ultra-smooth velocity filter
    function calculateVelocityFilter(newPos, lastPos) {
        if (!lastVelocity) {
            lastVelocity = { lat: 0, lng: 0 };
        }

        if (!newPos || !lastPos || 
            !isFinite(newPos.lat) || !isFinite(newPos.lng) || 
            !isFinite(lastPos.lat) || !isFinite(lastPos.lng)) {
            return newPos;
        }

        const dt = (newPos.timestamp - lastPos.timestamp) / 1000;
        if (dt <= 0 || dt > 8) {
            return newPos;
        }

        const currentVelocity = {
            lat: (newPos.lat - lastPos.lat) / dt,
            lng: (newPos.lng - lastPos.lng) / dt
        };

        const velocityChangeMagnitude = Math.sqrt(
            Math.pow(currentVelocity.lat - lastVelocity.lat, 2) +
            Math.pow(currentVelocity.lng - lastVelocity.lng, 2)
        );
        
        const adaptiveDecay = velocityChangeMagnitude > 0.00008 ? 
            Math.max(0.6, Math.min(0.92, CONFIG.VELOCITY_DECAY * (1 - velocityChangeMagnitude * 800))) : 
            CONFIG.VELOCITY_DECAY;

        lastVelocity = {
            lat: lastVelocity.lat * adaptiveDecay + currentVelocity.lat * (1 - adaptiveDecay),
            lng: lastVelocity.lng * adaptiveDecay + currentVelocity.lng * (1 - adaptiveDecay)
        };

        const predictedPosition = {
            lat: lastPos.lat + lastVelocity.lat * dt,
            lng: lastPos.lng + lastVelocity.lng * dt,
            accuracy: newPos.accuracy,
            timestamp: newPos.timestamp,
            heading: newPos.heading,
            speedMPS: newPos.speedMPS
        };
        
        const blendFactor = newPos.speedMPS ? Math.min(0.8, newPos.speedMPS * 0.06) : 0.4;
        
        return {
            lat: predictedPosition.lat * blendFactor + newPos.lat * (1 - blendFactor),
            lng: predictedPosition.lng * blendFactor + newPos.lng * (1 - blendFactor),
            accuracy: newPos.accuracy,
            timestamp: newPos.timestamp,
            heading: newPos.heading,
            speedMPS: newPos.speedMPS
        };
    }

    // Ultra-smooth enhanced velocity filter
    function calculateEnhancedVelocityFilter(currentPosition, lastPosition, timeDelta, speed) {
        if (!timeDelta || timeDelta <= 0) {
            return currentPosition;
        }
        
        const currentVelocity = {
            lat: (currentPosition.lat - lastPosition.lat) / timeDelta,
            lng: (currentPosition.lng - lastPosition.lng) / timeDelta
        };
        
        if (!lastVelocity) {
            lastVelocity = currentVelocity;
        }
        
        const acceleration = {
            lat: (currentVelocity.lat - lastVelocity.lat) / timeDelta,
            lng: (currentVelocity.lng - lastVelocity.lng) / timeDelta
        };
        
        const accelerationDamping = Math.min(1, Math.max(0.15, 1 - (speed / 18)));
        const dampedAcceleration = {
            lat: acceleration.lat * accelerationDamping,
            lng: acceleration.lng * accelerationDamping
        };
        
        lastVelocity = currentVelocity;
        
        const predictionTimeFactor = Math.min(0.3, Math.max(0.08, timeDelta));
        
        return {
            lat: currentPosition.lat + (currentVelocity.lat * predictionTimeFactor) + (0.5 * dampedAcceleration.lat * predictionTimeFactor * predictionTimeFactor),
            lng: currentPosition.lng + (currentVelocity.lng * predictionTimeFactor) + (0.5 * dampedAcceleration.lng * predictionTimeFactor * predictionTimeFactor),
            accuracy: currentPosition.accuracy,
            heading: currentPosition.heading,
            timestamp: currentPosition.timestamp,
            speedMPS: speed
        };
    }

    function checkStationaryState(newPosition) {
        if (!lastPosition) return;
        
        const distance = calculateDistance(lastPosition, newPosition);
        
        if (distance >= CONFIG.MICRO_MOVEMENT_THRESHOLD) {
            isStationary = false;
            stationaryStartTime = null;
            console.debug("Movement detected, resuming normal updates");
        }
        
        if (stationaryCheckTimeout) {
            clearTimeout(stationaryCheckTimeout);
            stationaryCheckTimeout = null;
        }
        
        if (isStationary) {
            stationaryCheckTimeout = setTimeout(() => checkStationaryState(newPosition), CONFIG.STATIONARY_CHECK_INTERVAL);
        }
    }

    function calculateFinalPosition() {
        if (positionBuffer.length === 0) {
            return null;
        }
        
        if (positionBuffer.length === 1) {
            return positionBuffer[0];
        }
        
        return calculateWeightedPosition(positionBuffer);
    }

    // Ultra-smooth throttle function
    function throttle(func, limit) {
      let inThrottle;
      return function() {
        const args = arguments;
        const context = this;
        if (!inThrottle) {
          func.apply(context, args);
          inThrottle = true;
          setTimeout(() => inThrottle = false, limit);
        }
      };
    }

    // Ultra-smooth edge proximity calculation
    function calculateEdgeProximity(map, point) {
        const bounds = map.getBounds();
        const latSpan = bounds.getNorth() - bounds.getSouth();
        const lngSpan = bounds.getEast() - bounds.getWest();
        
        return {
            north: Math.abs(point.lat - bounds.getNorth()) / latSpan,
            south: Math.abs(point.lat - bounds.getSouth()) / latSpan,
            east: Math.abs(point.lng - bounds.getEast()) / lngSpan,
            west: Math.abs(point.lng - bounds.getWest()) / lngSpan
        };
    }

    // Ultra-smooth edge detection
    function isMarkerNearEdge(map, marker, isStrict = false) {
        if (isMapInteracting) {
            return {
                isNearEdge: false,
                edges: { north: false, south: false, east: false, west: false },
                proximities: { north: 1, south: 1, east: 1, west: 1 }
            };
        }
        
        if (!followUser) {
            return {
                isNearEdge: false,
                edges: { north: false, south: false, east: false, west: false },
                proximities: { north: 1, south: 1, east: 1, west: 1 }
            };
        }
        
        const bounds = map.getBounds();
        const point = marker.getLatLng();
        const proximities = calculateEdgeProximity(map, point);
        
        const thresholdPercentage = isStrict ? 
            CONFIG.STRICT_EDGE_THRESHOLD_PERCENTAGE : 
            CONFIG.EDGE_THRESHOLD_PERCENTAGE;
        
        const edges = {
            north: proximities.north < thresholdPercentage,
            south: proximities.south < thresholdPercentage,
            east: proximities.east < thresholdPercentage,
            west: proximities.west < thresholdPercentage
        };
        
        return {
            isNearEdge: Object.values(edges).some(edge => edge),
            edges: edges,
            proximities: proximities
        };
    }   
           
    function calculateOptimalCenter(map, markerPosition, edgeInfo) {
        const bounds = map.getBounds();
        
        let latOffset = 0;
        let lngOffset = 0;
        
        // More responsive centering offsets
        if (edgeInfo.edges.north) latOffset = -1 * (bounds.getNorth() - bounds.getSouth()) * 0.15;
        if (edgeInfo.edges.south) latOffset = (bounds.getNorth() - bounds.getSouth()) * 0.15;
        if (edgeInfo.edges.east) lngOffset = -1 * (bounds.getEast() - bounds.getWest()) * 0.15;
        if (edgeInfo.edges.west) lngOffset = (bounds.getEast() - bounds.getWest()) * 0.15;
        
        return {
            lat: markerPosition.lat + latOffset,
            lng: markerPosition.lng + lngOffset
        };
    }

    function shouldRecenter(map, marker) {
        const now = Date.now();
        if (now - lastCenteringTime < CONFIG.MIN_RECENTER_INTERVAL) {
            return { needsRecenter: false };
        }
        
        const edgeInfo = isMarkerNearEdge(map, marker);
        const proximities = edgeInfo.proximities;
        
        const isCritical = Object.values(proximities).some(
            proximity => proximity < CONFIG.CRITICAL_EDGE_THRESHOLD_PERCENTAGE
        );
        
        if (isCritical) {
            lastCenteringTime = now;
            return {
                needsRecenter: true,
                isEmergency: true,
                edgeInfo: edgeInfo
            };
        }
        
        if (edgeInfo.isNearEdge) {
            lastCenteringTime = now;
            return {
                needsRecenter: true,
                isEmergency: false,
                edgeInfo: edgeInfo
            };
        }
        
        return {
            needsRecenter: false,
            isEmergency: false,
            edgeInfo: edgeInfo
        };
    }

    // Ultra-smooth marker and map update function
    function updateMarkerAndMap(position, speedMPS) {
        if (!position || !isFinite(position.lat) || !isFinite(position.lng)) {
            console.warn("Invalid position for marker update");
            return;
        }
        
        // Ultra-smooth marker animation
        userMarker.setLatLng([position.lat, position.lng], { animate: true, duration: 0.2 });
        
        const updateDelay = speedMPS > 8 ? 100 : (speedMPS > 3 ? 300 : 600);
        
        if (!window.throttledMapUpdate) {
            window.throttledMapUpdate = throttle(function(pos, speed) {
                if (followUser && !isMapInteracting) {
                    checkProximityForZoom();
                    
                    const now = Date.now();
                    if (now - lastCenteringTime >= CONFIG.MIN_CENTERING_INTERVAL) {
                        const rec = shouldRecenter(map, userMarker);
                        if (rec.needsRecenter) {
                            const center = calculateOptimalCenter(map, pos, rec.edgeInfo);
                            map.panTo(center, {
                                animate: true,
                                duration: rec.isEmergency ? 0.2 : 0.5, // Ultra-smooth durations
                                easeLinearity: 0.4,
                                noZoom: true
                            });
                            lastCenteringTime = now;
                        }
                    }
                    
                    if (!isNearLocation) {
                        const zoomLevel = getSpeedBasedZoom(speed);
                        if (zoomLevel !== -1 && Math.abs(map.getZoom() - zoomLevel) > 0.3) {
                            map.setZoom(zoomLevel, { animate: true, duration: 0.6 });
                        }
                    }
                }
            }, updateDelay);
        }
        
        window.throttledMapUpdate(position, speedMPS);
        updateDistanceBox();
    }

    // Ultra-smooth marker visibility function
    function ensureMarkerVisible() {
        if (!userMarker || !map) return;
        
        const userPos = userMarker.getLatLng();
        if (!userPos || !isFinite(userPos.lat) || !isFinite(userPos.lng)) return;
        
        const bounds = map.getBounds();
        if (!bounds) return;
        
        const mapWidth = bounds.getEast() - bounds.getWest();
        const mapHeight = bounds.getNorth() - bounds.getSouth();
        
        const edgePaddingLng = mapWidth * 0.20;
        const edgePaddingLat = mapHeight * 0.20;
        
        const isNearEdge = 
            userPos.lat > (bounds.getNorth() - edgePaddingLat) ||
            userPos.lat < (bounds.getSouth() + edgePaddingLat) ||
            userPos.lng > (bounds.getEast() - edgePaddingLng) ||
            userPos.lng < (bounds.getWest() + edgePaddingLng);
            
        const isOutsideBounds = !bounds.contains(userPos);
        
        if (isOutsideBounds || (isNearEdge && followUser)) {
            const now = Date.now();
            if (now - lastCenteringTime > CONFIG.MIN_CENTERING_INTERVAL) {
                map.panTo(userPos, {
                    animate: true,
                    duration: 0.3, // Ultra-smooth duration
                    easeLinearity: 0.4,
                    noZoom: true
                });
                
                lastCenteringTime = now;
            }
        }
    }
    
    // Ultra-smooth user location update function - THE CORE OF SMOOTHNESS
    function updateUserLocation(position, forceUpdate = false) {
        if (!position?.coords?.latitude || !position?.coords?.longitude) {
            console.warn("Invalid position data received");
            return;
        }

        if (animationFrameId !== null) {
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
        }

        const currentTime = Date.now();
        const timeDelta = lastUpdateTime ? (currentTime - lastUpdateTime) / 1000 : 0;

        const newPosition = {
            lat: position.coords.latitude,
            lng: position.coords.longitude,
            accuracy: position.coords.accuracy || 20,
            heading: position.coords.heading ?? null,
            timestamp: currentTime,
            speedMPS: position.coords.speed || 0
        };

        if (!lastPosition) {
            lastPosition = newPosition;
            userMarker.setLatLng([newPosition.lat, newPosition.lng]);
            kalmanFilter.reset(newPosition);
            lastUpdateTime = currentTime;
            stationaryStartTime = currentTime;
            positionBuffer = [newPosition];
            
            const zoomLevel = getSpeedBasedZoom(newPosition.speedMPS);
            if (zoomLevel !== -1) {
                map.setZoom(zoomLevel, { animate: false });
            }
            map.setView([newPosition.lat, newPosition.lng], map.getZoom(), { animate: false });
            updateDistanceBox();
            return;
        }

        const distance = calculateDistance(lastPosition, newPosition);

        // Ultra-responsive Kalman filter adjustment
        const speedFactor = Math.min(1, Math.max(0.05, newPosition.speedMPS / 8));
        kalmanFilter.q = CONFIG.BASE_PROCESS_NOISE * speedFactor;
        kalmanFilter.r = newPosition.accuracy / (120 * (1 + speedFactor));

        if (distance > CONFIG.EXTENDED_DISTANCE_THRESHOLD || forceUpdate) {
            if (stationaryCheckTimeout) {
                clearTimeout(stationaryCheckTimeout);
                stationaryCheckTimeout = null;
            }
            isStationary = false;
            stationaryStartTime = null;

            const transitionPosition = {
                lat: newPosition.lat,
                lng: newPosition.lng,
                accuracy: newPosition.accuracy,
                heading: newPosition.heading,
                timestamp: currentTime,
                speedMPS: newPosition.speedMPS
            };

            userMarker.setLatLng([transitionPosition.lat, transitionPosition.lng], { animate: false });
            lastPosition = transitionPosition;
            positionBuffer = [transitionPosition];
            smoothingQueue = [transitionPosition];
            interpolationBuffer = [];
            kalmanFilter.reset(transitionPosition);
            lastVelocity = { lat: 0, lng: 0 };

            const zoomLevel = getSpeedBasedZoom(newPosition.speedMPS);
            if (zoomLevel !== -1) {
                map.setZoom(zoomLevel, { animate: false });
            }
            map.setView([transitionPosition.lat, transitionPosition.lng], map.getZoom(), { 
                animate: false, 
                duration: 0,
                noMoveStart: true
            });
            
            lastUpdateTime = currentTime;
            lastUpdateTimestamp = currentTime;

            if (isSignificantMovement(transitionPosition)) {
                resetInactivityTimer(false);
            }
                
            updateDistanceBox();
            
            if (map._container) {
                map._onResize();
            }
            return;
        }

        // Ultra-sensitive micro-movement detection
        if (distance < CONFIG.MICRO_MOVEMENT_THRESHOLD && !forceUpdate) {
            if (!isStationary) {
                if (!stationaryStartTime) {
                    stationaryStartTime = currentTime;
                } else if (currentTime - stationaryStartTime >= CONFIG.STATIONARY_TIME_THRESHOLD) {
                    isStationary = true;
                    
                    kalmanFilter.r = Math.min(newPosition.accuracy, lastPosition.accuracy) / 250;
                    kalmanFilter.q = CONFIG.BASE_PROCESS_NOISE * 0.05;
                    
                    const stationaryPosition = kalmanFilter.update({
                        lat: newPosition.lat,
                        lng: newPosition.lng,
                        accuracy: Math.min(lastPosition.accuracy, newPosition.accuracy) * CONFIG.STATIONARY_ACCURACY_MULTIPLIER,
                        heading: newPosition.heading,
                        timestamp: newPosition.timestamp,
                        speedMPS: 0
                    });
                    
                    userMarker.setLatLng([stationaryPosition.lat, stationaryPosition.lng], { animate: false });
                    lastPosition = stationaryPosition;
                    positionBuffer = [stationaryPosition];
                    
                    if (stationaryCheckTimeout) clearTimeout(stationaryCheckTimeout);
                    stationaryCheckTimeout = setTimeout(() => checkStationaryState(newPosition), CONFIG.STATIONARY_CHECK_INTERVAL);
                    
                    updateDistanceBox();
                    return;
                }
            }
            
            if (isStationary) {
                if (newPosition.accuracy < lastPosition.accuracy * 0.85) {
                    kalmanFilter.r = newPosition.accuracy / 500;
                    kalmanFilter.q = CONFIG.BASE_PROCESS_NOISE * 0.03;
                    
                    const refinedPosition = kalmanFilter.update({
                        lat: newPosition.lat,
                        lng: newPosition.lng,
                        accuracy: newPosition.accuracy,
                        heading: newPosition.heading,
                        timestamp: newPosition.timestamp,
                        speedMPS: 0
                    });
                    
                    if (calculateDistance(lastPosition, refinedPosition) < CONFIG.MICRO_MOVEMENT_THRESHOLD / 3) {
                        userMarker.setLatLng([refinedPosition.lat, refinedPosition.lng], { animate: false });
                        lastPosition = refinedPosition;
                        updateDistanceBox();
                    }
                }
                return;
            }
        } else {
            isStationary = false;
            stationaryStartTime = null;
            if (stationaryCheckTimeout) {
                clearTimeout(stationaryCheckTimeout);
                stationaryCheckTimeout = null;
            }
        }

        if (!forceUpdate && (
            newPosition.accuracy > CONFIG.MAX_ACCEPTABLE_ACCURACY ||
            distance < CONFIG.MIN_DISTANCE_THRESHOLD ||
            (timeDelta > 0 && distance / timeDelta > CONFIG.MAX_SPEED)
        )) {
            return;
        }

        try {
            const filteredPosition = kalmanFilter.update({
                lat: newPosition.lat,
                lng: newPosition.lng,
                accuracy: newPosition.accuracy,
                heading: newPosition.heading,
                timestamp: newPosition.timestamp,
                speedMPS: newPosition.speedMPS
            });

            updatePositionBuffer(filteredPosition);
            
            const finalPosition = calculateFinalPosition();
            if (!finalPosition) throw new Error("Final position calculation failed");

            const predictedPosition = calculateEnhancedVelocityFilter(finalPosition, lastPosition, timeDelta, newPosition.speedMPS);
            
            const smoothingFactor = Math.min(0.85, Math.max(0.15, 0.25 + (speedFactor * 0.6)));
            const smoothedPosition = {
                lat: lastPosition.lat * (1 - smoothingFactor) + predictedPosition.lat * smoothingFactor,
                lng: lastPosition.lng * (1 - smoothingFactor) + predictedPosition.lng * smoothingFactor,
                accuracy: predictedPosition.accuracy,
                heading: predictedPosition.heading,
                timestamp: currentTime,
                speedMPS: predictedPosition.speedMPS
            };

            // Ultra-smooth animation with optimized duration
            const animDuration = Math.min(0.2, Math.max(0.05, 0.12 / (1 + speedFactor)));
            
            userMarker.setLatLng([smoothedPosition.lat, smoothedPosition.lng], {
                animate: true,
                duration: animDuration
            });
            
            // More responsive map updates
            if (currentTime - lastMapUpdateTime > 300 || distance > 12) {
                checkProximityForZoom();
                
                const lookAheadFactor = Math.min(0.3, speedFactor * 0.2);
                const lookAheadPosition = {
                    lat: smoothedPosition.lat + (predictedPosition.lat - lastPosition.lat) * lookAheadFactor,
                    lng: smoothedPosition.lng + (predictedPosition.lng - lastPosition.lng) * lookAheadFactor
                };
                
                animationFrameId = requestAnimationFrame(() => {
                    if (followUser && !isMapInteracting) {
                        map.panTo([lookAheadPosition.lat, lookAheadPosition.lng], {
                            animate: true,
                            duration: 0.3, // Ultra-smooth duration
                            easeLinearity: 0.4
                        });
                        
                        const zoomLevel = getSpeedBasedZoom(newPosition.speedMPS);
                        if (zoomLevel !== -1 && Math.abs(map.getZoom() - zoomLevel) >= 0.6) {
                            map.setZoom(zoomLevel, { animate: true, duration: 0.6 });
                        }
                    }
                    
                    animationFrameId = null;
                });
                
                lastMapUpdateTime = currentTime;
            }

            lastPosition = smoothedPosition;
            lastUpdateTime = currentTime;
            lastUpdateTimestamp = currentTime;
            updateDistanceBox();

        } catch (error) {
            console.error("Location update error:", error);
            if (animationFrameId !== null) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            
            kalmanFilter.r = newPosition.accuracy / 60;
            const fallbackPosition = kalmanFilter.update(newPosition);
            userMarker.setLatLng([fallbackPosition.lat, fallbackPosition.lng], { animate: true, duration: 0.2 });
            lastPosition = fallbackPosition;
            positionBuffer = [fallbackPosition];
            updateDistanceBox();
        }
    }

    // Ultra-smooth distance box update
    function updateDistanceBox() {
        const distanceBox = document.getElementById('distanceBox');
        
        if (!userMarker || !gameLocations || gameLocations.length === 0) {
            distanceBox.innerText = 'Loading locations...';
            return;
        }

        const userLatLng = userMarker.getLatLng();
        let userLat = userLatLng.lat;
        let userLng = userLatLng.lng;

        if (!isFinite(userLat) || !isFinite(userLng)) {
            console.warn('Invalid user coordinates:', userLat, userLng);
            distanceBox.innerText = 'Loading locations...';
            return;
        }

        if (userLat === 0 && userLng === 0) {
            const center = map.getCenter();
            userLat = center.lat;
            userLng = center.lng;
        }

        let closestDistance = Infinity;
        let closestLocation = null;
        const userPos = { lat: userLat, lng: userLng };

        for (const location of gameLocations) {
            if (!location || !isFinite(location.lat) || !isFinite(location.lng)) {
                console.warn('Invalid location data:', location);
                continue;
            }

            const locationPos = { lat: location.lat, lng: location.lng };
            const distance = calculateDistance(userPos, locationPos);

            if (isFinite(distance) && distance < closestDistance) {
                closestDistance = distance;
                closestLocation = location;
            }
        }

        if (!isFinite(closestDistance) || closestDistance === Infinity) {
            console.warn('Invalid distance calculation:', closestDistance);
            distanceBox.innerText = 'Loading locations...';
            return;
        }

        const distanceFeet = Math.round(closestDistance * 3.28084);
        const distanceText = distanceFeet < 5280 
            ? `${distanceFeet.toLocaleString()} feet` 
            : `${(distanceFeet / 5280).toFixed(2)} miles`;
        
        distanceBox.innerText = `Closest Stop: ${distanceText}`;

        if (distanceFeet <= CONFIG.DISTANCE_THRESHOLD && !isLocationHuntVisible && closestLocation) {
            showLocationHunt(closestLocation);
        }
    }

    // Ultra-optimized distance calculation using Haversine formula
    function calculateDistance(pos1, pos2) {
        if (!pos1 || !pos2 || 
            !isFinite(pos1.lat) || !isFinite(pos1.lng) || 
            !isFinite(pos2.lat) || !isFinite(pos2.lng)) {
            return Infinity;
        }
        
        const R = 6371000;
        const lat1 = pos1.lat * Math.PI / 180;
        const lat2 = pos2.lat * Math.PI / 180;
        const deltaLat = (pos2.lat - pos1.lat) * Math.PI / 180;
        const deltaLng = (pos2.lng - pos1.lng) * Math.PI / 180;

        const a = Math.sin(deltaLat/2) * Math.sin(deltaLat/2) +
                Math.cos(lat1) * Math.cos(lat2) *
                Math.sin(deltaLng/2) * Math.sin(deltaLng/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

        return R * c;
    }

    // Ultra-smooth geolocation options
    function getGeolocationOptions(retryNumber) {
        return {
            enableHighAccuracy: retryNumber < 2,
            timeout: 6000 + (retryNumber * 3000),
            maximumAge: retryNumber * 3000
        };
    }

    // Ultra-smooth location error handling
    function handleLocationError(error) {
        console.warn("Error getting user location:", error);
        
        if (retryCount < CONFIG.MAX_RETRIES) {
            retryCount++;
            console.log(`Retrying to get location (Attempt ${retryCount} of ${CONFIG.MAX_RETRIES})`);
            
            const currentRetryDelay = CONFIG.RETRY_DELAY * retryCount;
            
            setTimeout(() => {
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        console.log("Location retrieved successfully after retry");
                        hideLoadingMessage();
                        updateUserLocation(position, true);
                        retryCount = 0;
                    }, 
                    handleLocationError, 
                    getGeolocationOptions(retryCount) 
                );
            }, currentRetryDelay);
            return;
        }
        
        retryCount = 0;
        hideLoadingMessage();
        
        let errorMessage = "An error occurred while getting your location.";
        if (error && error.code) {
            switch(error.code) {
                case 1:
                    errorMessage = "Please allow access to your location to use this feature.";
                    break;
                case 2:
                    errorMessage = "Your location is currently unavailable. Please try again later.";
                    break;
                case 3:
                    errorMessage = "Getting your location took too long. Please try again.";
                    break;
            }
        }
        
        showPopup("Location Error", errorMessage);
        
        if (typeof onLocationFailure === 'function') {
            onLocationFailure(error);
        }
    }

    // Optimized popup function
    function showPopup(title, message, type = "info", callback = null) {
        console.log("showPopup called with:", title, message);
        
        const existingPopups = document.querySelectorAll(".popup-overlay");
        existingPopups.forEach(popup => {
            document.body.removeChild(popup);
        });

        const overlay = document.createElement("div");
        overlay.className = "popup-overlay";
        overlay.style.cssText = `
            position: fixed;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 9999;
            display: flex;
            justify-content: center;
            align-items: center;
        `;
        
        const popupContainer = document.createElement("div");
        popupContainer.className = "popup-container";
        popupContainer.style.cssText = `
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            width: 300px;
            max-width: 90%;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            text-align: center;
        `;
        
        const titleElement = document.createElement("h3");
        titleElement.textContent = title;
        titleElement.style.cssText = `
            margin: 0 0 15px 0;
            color: #333;
            font-size: 1.3rem;
        `;
        
        const messageElement = document.createElement("p");
        messageElement.textContent = message;
        messageElement.style.cssText = `
            margin: 0 0 20px 0;
            color: #555;
            line-height: 1.4;
        `;
        
        const button = document.createElement("button");
        button.textContent = "OK";
        button.style.cssText = `
            padding: 8px 20px;
            background-color: #2c5282;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
        `;
        
        button.addEventListener("click", function() {
            document.body.removeChild(overlay);
            if (callback && typeof callback === "function") {
                callback();
            }
        });
        
        overlay.addEventListener("click", function(e) {
            if (e.target === overlay) {
                document.body.removeChild(overlay);
            }
        });
        
        popupContainer.appendChild(titleElement);
        popupContainer.appendChild(messageElement);
        popupContainer.appendChild(button);
        overlay.appendChild(popupContainer);
        document.body.appendChild(overlay);
        
        button.focus();
    }

    // Ultra-smooth recenter map function
    function recenterMap() {
        const recenterButton = document.getElementById('recenterButton');
        recenterButton.style.backgroundColor = 'var(--primary-color)';
        recenterButton.style.color = 'white';
        
        if (userMarker && userMarker.getLatLng()) {
            map.closePopup();
            
            map.panTo(userMarker.getLatLng(), {
                animate: true,
                duration: 0.3, // Ultra-smooth duration
                easeLinearity: 0.2,
                noZoom: true
            });
            
            followUser = true;
        }
        
        setTimeout(() => {
            recenterButton.style.backgroundColor = 'white';
            recenterButton.style.color = 'var(--primary-color)';
        }, 300);
    }

    const cooldownPeriod = 2.5 * 60 * 1000; // 2.5 minutes

    // Ultra-smooth location hunt display
    function showLocationHunt(location) {
        const now = performance.now();
        if (location.id === lastVisitedLocationId && now - lastVisitTime < cooldownPeriod) {
            console.log(`Location ${location.id} is on cooldown. Skipping.`);
            return;
        }
        
        lastVisitedLocationId = location.id;
        lastVisitTime = now;
        isLocationHuntVisible = true;

        const lochuntContainer = document.querySelector('.lochunt-container');
        lochuntContainer.innerHTML = '';
        lochuntContainer.style.display = 'flex';
        lochuntContainer.classList.add('fade-in');

        const scrollableContent = document.createElement('div');
        scrollableContent.style.cssText = `
            flex: 1;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            scroll-behavior: smooth;
            will-change: scroll-position;
        `;

        const locationImage = document.createElement('img');
        locationImage.src = location.image;
        locationImage.alt = location.name;
        locationImage.style.cssText = `
            width: 100%;
            height: 45vh;
            object-fit: cover;
            object-position: center;
        `;
        locationImage.loading = "eager";

        scrollableContent.appendChild(locationImage);

        const contentContainer = document.createElement('div');
        contentContainer.classList.add('lochunt-content');
        contentContainer.style.cssText = `
            padding: 24px;
            display: flex;
            flex-direction: column;
            align-items: center;
            max-width: 800px;
            margin: 0 auto;
        `;
        
        const locationInfo = document.createElement('div');
        locationInfo.classList.add('lochunt-info');
        locationInfo.style.cssText = `
            text-align: center;
            width: 100%;
            margin-bottom: 15px;
        `;
        
        const locationName = document.createElement('h1');
        locationName.textContent = location.name;
        locationName.style.cssText = `
            font-size: clamp(1.8rem, 4vw, 2.5rem);
            font-weight: 700;
            color: #1a1a1a;
            margin-bottom: 8px;
            line-height: 1.2;
        `;
        
        const locationCity = document.createElement('p');
        locationCity.textContent = `${location.city}`;
        locationCity.style.cssText = `
            font-size: clamp(1.1rem, 2vw, 1.3rem);
            color: #2c5282;
            font-weight: 600;
            margin-bottom: 4px;
        `;
        
        const locationCreator = document.createElement('p');
        locationCreator.textContent = `Created by: ${location.creator}`;
        locationCreator.style.cssText = `
            font-size: calc(0.9rem + 0.4vw);
            color: #666666;
            font-weight: 500;
        `;
        
        locationInfo.appendChild(locationName);
        locationInfo.appendChild(locationCity);
        locationInfo.appendChild(locationCreator);
        contentContainer.appendChild(locationInfo);
        
        const audioPlayerContainer = createAudioPlayer(location.audio);
        contentContainer.appendChild(audioPlayerContainer);
        scrollableContent.appendChild(contentContainer);
        lochuntContainer.appendChild(scrollableContent);
        
        const bottomActionBar = createBottomActionBar(location);
        bottomActionBar.style.cssText += `
            position: sticky;
            bottom: 0;
            width: 100%;
        `;
        lochuntContainer.appendChild(bottomActionBar);
        
        setTimeout(() => {
            initAudioPlayer();
        }, 30); // Ultra-responsive
    }

    function createAudioPlayer(audioSrc) {
        const audioPlayerContainer = document.createElement('div');
        audioPlayerContainer.classList.add('audio-player');
        audioPlayerContainer.style.cssText = `
            width: 100%;
            max-width: 400px;
            margin-bottom: 15px;
        `;

        const audio = document.createElement('audio');
        audio.id = 'locationAudio';
        audio.src = audioSrc;
        audio.preload = "auto";

        const audioProgress = document.createElement('div');
        audioProgress.classList.add('audio-progress');
        audioProgress.style.cssText = `
            width: 100%;
            margin-bottom: 15px;
        `;

        const progressContainer = document.createElement('div');
        progressContainer.classList.add('progress');
        progressContainer.style.cssText = `
            height: 8px;
            background-color: #e2e8f0;
            border-radius: 4px;
            cursor: pointer;
            margin-bottom: 12px;
            overflow: hidden;
        `;

        const progressBar = document.createElement('div');
        progressBar.id = 'progressBar';
        progressBar.classList.add('progress-bar');
        progressBar.style.cssText = `
            height: 100%;
            background-color: #2c5282;
            width: 0%;
            transition: width 0.05s linear;
        `;

        progressContainer.appendChild(progressBar);
        audioProgress.appendChild(progressContainer);

        const timeInfo = document.createElement('div');
        timeInfo.classList.add('audio-time');
        timeInfo.style.cssText = `
            display: flex;
            justify-content: space-between;
            color: #4a5568;
            font-size: 0.875rem;
            margin-bottom: 16px;
            font-weight: 500;
        `;

        const currentTimeSpan = document.createElement('span');
        currentTimeSpan.id = 'currentTime';
        currentTimeSpan.textContent = '0:00';

        const durationSpan = document.createElement('span');
        durationSpan.id = 'duration';
        durationSpan.textContent = '0:00';

        timeInfo.appendChild(currentTimeSpan);
        timeInfo.appendChild(durationSpan);

        const audioControls = document.createElement('div');
        audioControls.classList.add('audio-controls');
        audioControls.style.cssText = `
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 24px;
        `;

        const rewindBtn = createAudioButton('skip-backward', 'rewindBtn', 'Rewind 10 seconds');
        const playPauseBtn = createAudioButton('play', 'playPauseBtn', 'Play');
        const forwardBtn = createAudioButton('skip-forward', 'forwardBtn', 'Forward 10 seconds');

        audioControls.appendChild(rewindBtn);
        audioControls.appendChild(playPauseBtn);
        audioControls.appendChild(forwardBtn);

        audioPlayerContainer.appendChild(audio);
        audioPlayerContainer.appendChild(audioProgress);
        audioPlayerContainer.appendChild(timeInfo);
        audioPlayerContainer.appendChild(audioControls);

        return audioPlayerContainer;
    }

    function createAudioButton(iconName, id, ariaLabel) {
        const button = document.createElement('button');
        button.id = id;
        button.classList.add('audio-button');
        button.setAttribute('aria-label', ariaLabel);
        button.innerHTML = `<i class="bi bi-${iconName}"></i>`;
        button.style.cssText = `
            background-color: white;
            color: var(--primary-color);
            border: 2px solid var(--primary-color);
            border-radius: 50%;
            width: 55px;
            height: 55px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
        `;

        button.addEventListener('mouseover', () => {
            button.style.backgroundColor = 'var(--hover-color)';
        });

        button.addEventListener('mouseout', () => {
            button.style.backgroundColor = 'white';
        });

        button.addEventListener('click', () => {
            button.style.backgroundColor = 'var(--primary-color)';
            button.style.color = 'white';
            button.style.transform = 'scale(0.95)';
            
            setTimeout(() => {
                button.style.backgroundColor = 'white';
                button.style.color = 'var(--primary-color)';
                button.style.transform = 'scale(1)';
            }, 100); // Ultra-responsive
        });

        return button;
    }

    function createBottomActionBar(location) {
        const actionBar = document.createElement('div');
        actionBar.classList.add('location-action-bar');
        actionBar.style.cssText = `
            width: 100%;
            height: 60px;
            background: linear-gradient(to right, #2c5282, #2b6cb0);
            margin-top: auto;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.025);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 24px;
            position: sticky;
            bottom: 0;
        `;
        
        const imgSourceBtn = document.createElement('button');
        imgSourceBtn.classList.add('source-info-button', 'btn', 'btn-sm', 'me-2');
        imgSourceBtn.innerHTML = '<i class="bi bi-info-circle-fill text-white" style="font-size: 1.5rem;"></i>';
        imgSourceBtn.setAttribute('aria-label', 'Image source information');
        imgSourceBtn.onclick = () => {
            if (location && location.imageSource) {
                showSourcePopup('Image Source', location.imageSource);
            } else {
                showSourcePopup('Image Source', 'Image source information is not available');
            }
        };

        const feedbackButton = document.createElement('a');
        feedbackButton.href = 'mailto:mattreicher@protonmail.com?subject=Feedback';
        feedbackButton.target = '_blank';
        feedbackButton.rel = 'noopener noreferrer';
        feedbackButton.setAttribute('aria-label', 'Send feedback email');
        feedbackButton.innerHTML = '<i class="bi bi-envelope-fill text-white" style="font-size: 1.5rem;"></i>';
        feedbackButton.classList.add('feedback-email-button', 'btn', 'btn-sm');

        actionBar.appendChild(imgSourceBtn);
        actionBar.appendChild(feedbackButton);
        return actionBar;
    }

    function showSourcePopup(title, content) {
        const existingPopup = document.getElementById('sourceInfoPopup');
        if (existingPopup) {
            document.body.removeChild(existingPopup);
        }
        
        const overlay = document.createElement('div');
        overlay.id = 'sourceInfoPopup';
        overlay.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            backdrop-filter: blur(3px);
        `;

        const popup = document.createElement('div');
        popup.classList.add('source-info-content');
        popup.style.cssText = `
            background-color: white;
            border-radius: 8px;
            padding: 24px;
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            display: flex;
            flex-direction: column;
        `;

        const popupTitle = document.createElement('h3');
        popupTitle.textContent = title;
        popupTitle.style.cssText = `
            font-size: 1.5rem;
            font-weight: 600;
            color: #2c5282;
            margin-bottom: 16px;
            border-bottom: 1px solid #e2e8f0;
            padding-bottom: 12px;
        `;

        const popupContent = document.createElement('div');
        popupContent.style.cssText = `
            margin-bottom: 20px;
            line-height: 1.6;
            font-size: 1rem;
        `;
        popupContent.textContent = content;

        const closeButton = document.createElement('button');
        closeButton.textContent = 'Close';
        closeButton.classList.add('source-close-button', 'btn');
        closeButton.style.cssText = `
            background: linear-gradient(to right, #2c5282, #2b6cb0);
            border: none;
            color: white;
            padding: 8px 24px;
            border-radius: 4px;
            font-weight: 500;
            cursor: pointer;
            align-self: flex-end;
            transition: all 0.2s ease;
        `;
        
        closeButton.addEventListener('mouseover', () => {
            closeButton.style.opacity = '0.9';
        });
        
        closeButton.addEventListener('mouseout', () => {
            closeButton.style.opacity = '1';
        });
        
        closeButton.addEventListener('click', () => {
            document.body.removeChild(overlay);
        });

        overlay.addEventListener('click', (e) => {
            if (e.target === overlay) {
                document.body.removeChild(overlay);
            }
        });

        popup.appendChild(popupTitle);
        popup.appendChild(popupContent);
        popup.appendChild(closeButton);
        overlay.appendChild(popup);
        document.body.appendChild(overlay);

        overlay.style.opacity = '0';
        popup.style.transform = 'translateY(20px)';
        popup.style.transition = 'transform 0.3s ease, opacity 0.3s ease';
        overlay.style.transition = 'opacity 0.3s ease';
        
        setTimeout(() => {
            overlay.style.opacity = '1';
            popup.style.transform = 'translateY(0)';
        }, 10);
    }

    function initAudioPlayer() {
        const audio = document.getElementById('locationAudio');
        const playPauseBtn = document.getElementById('playPauseBtn');
        const rewindBtn = document.getElementById('rewindBtn');
        const forwardBtn = document.getElementById('forwardBtn');
        const progressBar = document.getElementById('progressBar');
        const progressContainer = document.querySelector('.progress');
        const currentTimeSpan = document.getElementById('currentTime');
        const durationSpan = document.getElementById('duration');

        if (!audio || !playPauseBtn || !progressBar) {
            console.error("Audio player elements not found");
            return;
        }

        playPauseBtn.addEventListener('click', togglePlay);
        rewindBtn.addEventListener('click', () => seek(-10));
        forwardBtn.addEventListener('click', () => seek(10));
        audio.addEventListener('timeupdate', updateProgress);
        audio.addEventListener('loadedmetadata', setDuration);
        audio.addEventListener('ended', () => {
            playPauseBtn.innerHTML = '<i class="bi bi-play"></i>';
            playPauseBtn.setAttribute('aria-label', 'Play');
            showAdditionalInfo();
        });
        if (progressContainer) {
            progressContainer.addEventListener('click', setProgress);
        }

        audio.load();

        function togglePlay() {
            if (audio.paused) {
                const playPromise = audio.play();
                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        playPauseBtn.innerHTML = '<i class="bi bi-pause"></i>';
                        playPauseBtn.setAttribute('aria-label', 'Pause');
                    }).catch(error => {
                        console.error("Audio play error:", error);
                        showSourcePopup("Audio Error", "There was a problem playing the audio. Please try again.");
                    });
                }
            } else {
                audio.pause();
                playPauseBtn.innerHTML = '<i class="bi bi-play"></i>';
                playPauseBtn.setAttribute('aria-label', 'Play');
            }
        }

        function seek(seconds) {
            audio.currentTime = Math.max(0, Math.min(audio.currentTime + seconds, audio.duration));
        }

        function updateProgress() {
            if (!isFinite(audio.duration)) return;
            
            const percent = (audio.currentTime / audio.duration) * 100;
            progressBar.style.width = `${percent}%`;
            currentTimeSpan.textContent = formatTime(audio.currentTime);
        }

        function setProgress(e) {
            const width = this.clientWidth;
            const clickX = e.offsetX;
            const duration = audio.duration;
            
            if (isFinite(duration) && width > 0) {
                audio.currentTime = (clickX / width) * duration;
            }
        }

        function setDuration() {
            if (isFinite(audio.duration)) {
                durationSpan.textContent = formatTime(audio.duration);
            }
        }

        function formatTime(time) {
            if (!isFinite(time)) return "0:00";
            
            const minutes = Math.floor(time / 60);
            const seconds = Math.floor(time % 60);
            return `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }
    }

    function showAdditionalInfo() {
        const location = gameLocations.find(loc => loc.id === lastVisitedLocationId);
        if (!location) {
            console.error('Location not found for ID:', lastVisitedLocationId);
            return;
        }
        
        const additionalInfoContainer = document.querySelector('.additional-info-container');
        additionalInfoContainer.style.display = 'block';
        additionalInfoContainer.classList.add('fade-in');
        
        document.getElementById('additionalInfo').textContent = location.additionalInfo || 
            "No additional information available for this location.";

        const continueButton = document.getElementById('continueButton');
        continueButton.onclick = () => {
            additionalInfoContainer.classList.add('fade-out');
            setTimeout(() => {
                additionalInfoContainer.style.display = 'none';
                additionalInfoContainer.classList.remove('fade-out');
                
                document.querySelector('.lochunt-container').classList.add('fade-out');
                setTimeout(() => {
                    document.querySelector('.lochunt-container').style.display = 'none';
                    document.querySelector('.lochunt-container').classList.remove('fade-out');
                    isLocationHuntVisible = false;
                    updateDistanceBox();
                }, 200); // Ultra-smooth
            }, 200); // Ultra-smooth
        };
    }

    function showLocationSummary(locationId) {
        const location = gameLocations.find(loc => String(loc.id) === String(locationId));
        
        if (location && location.summary) {
            const popupDiv = document.createElement("div");
            popupDiv.id = 'summaryModal';
            popupDiv.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0,0,0,0.6);
                backdrop-filter: blur(4px);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 1000;
                opacity: 0;
                transition: opacity 0.3s ease;
            `;
            
            const darkBlue = "#1a3a8a";
            const darkBlueHover = "#0d2c6e";
            
            popupDiv.innerHTML = `
                <div class="modal-container" style="
                    background-color: white;
                    border-radius: 16px;
                    overflow: hidden;
                    width: 90%;
                    max-width: 420px;
                    max-height: 80vh;
                    box-shadow: 0 15px 40px rgba(0,0,0,0.2);
                    margin: auto;
                    transform: translateY(20px);
                    transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
                    display: flex;
                    flex-direction: column;
                ">
                    <div style="
                        background-color: ${darkBlue};
                        padding: 18px 28px;
                        color: white;
                        text-align: center;
                    ">
                        <h3 style="
                            margin: 0;
                            font-size: 1.5rem;
                            font-weight: 600;
                        ">${location.name}</h3>
                    </div>
                    
                    <div style="
                        flex-grow: 1;
                        overflow-y: auto;
                        padding: 28px;
                    ">
                        <div id="summaryContent" style="
                            color: #5c6c7c;
                            line-height: 1.6;
                            font-size: 1rem;
                            margin-bottom: 25px;
                        ">
                            <p>${location.summary}</p>
                        </div>
                        
                        <div style="
                            border: 2px solid ${darkBlue};
                            border-radius: 12px;
                            padding: 16px;
                            background-color: rgba(26, 58, 138, 0.05);
                            margin-bottom: 25px;
                            display: flex;
                            align-items: center;
                        ">
                            <div style="
                                font-weight: 600;
                                color: #2c3e50;
                                padding-right: 15px;
                                min-width: 80px;
                            ">Location:</div>
                            <div style="
                                flex: 1;
                                color: #2c3e50;
                                font-weight: normal;
                                border-left: 1px solid rgba(26, 58, 138, 0.2);
                                padding-left: 15px;
                                line-height: 1.4;
                            ">${location.today || "Information not available"}</div>
                        </div>
                        
                        <div style="
                            display: flex;
                            justify-content: center;
                        ">
                            <button class="continue-btn" style="
                                padding: 14px 24px;
                                background-color: ${darkBlue};
                                color: white;
                                border: none;
                                border-radius: 10px;
                                cursor: pointer;
                                font-size: 1rem;
                                font-weight: 600;
                                min-width: 130px;
                                transition: all 0.2s ease;
                            ">Continue</button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(popupDiv);
            
            setTimeout(() => {
                popupDiv.style.opacity = "1";
                popupDiv.querySelector(".modal-container").style.transform = "translateY(0)";
            }, 10);
            
            const continueBtn = popupDiv.querySelector(".continue-btn");
            continueBtn.addEventListener("mouseover", function() {
                this.style.backgroundColor = darkBlueHover;
            });
            continueBtn.addEventListener("mouseout", function() {
                this.style.backgroundColor = darkBlue;
            });
            
            continueBtn.addEventListener("click", function() {
                popupDiv.style.opacity = "0";
                popupDiv.querySelector(".modal-container").style.transform = "translateY(20px)";
                setTimeout(() => {
                    document.body.removeChild(popupDiv);
                }, 300);
            });

            popupDiv.addEventListener("click", function(event) {
                if (event.target === popupDiv) {
                    popupDiv.style.opacity = "0";
                    popupDiv.querySelector(".modal-container").style.transform = "translateY(20px)";
                    setTimeout(() => {
                        document.body.removeChild(popupDiv);
                    }, 300);
                }
            });
        } else {
            console.log("Location or summary not found. Location ID:", locationId);
            showPopup("Error", "Summary not available for this location.");
        }
    }

    function showNavigationTips() {
        const modalOverlay = document.createElement("div");
        modalOverlay.className = "navigation-tips-overlay";
        modalOverlay.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(4px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease;
        `;
        
        const darkBlue = "var(--dark-blue)";
        const darkBlueHover = "var(--dark-blue-hover)";
        
        const modalContent = document.createElement("div");
        modalContent.className = "navigation-tips-content";
        modalContent.style.cssText = `
            background-color: white;
            border-radius: 16px;
            width: 90%;
            max-width: 450px;
            max-height: 95vh;
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.25);
            transform: translateY(20px);
            transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            overflow: hidden;
            display: flex !important;
            flex-direction: column !important;
            position: relative;
        `;
        
        const header = document.createElement("div");
        header.style.cssText = `
            text-align: center;
            padding: 20px 28px 0;
        `;
        
        header.innerHTML = `
            <h3 style="
                margin: 0 0 10px 0;
                color: ${darkBlue};
                font-size: 1.5rem;
                font-weight: 600;
            ">Navigation Tips</h3>
        `;
        
        const contentArea = document.createElement("div");
        contentArea.style.cssText = `
            padding: 0 28px;
            color: #5c6c7c;
            line-height: 1.4;
            font-size: 0.9rem;
        `;
        
        contentArea.innerHTML = `
            <ul style="
                list-style-type: none;
                padding: 0;
                margin: 0 0 10px 0;
            ">
                <li style="margin-bottom: 8px; display: flex; align-items: flex-start;">
                    <span style="color: ${darkBlue}; margin-right: 10px; font-size: 1.1rem;">•</span>
                    <span>Use the map to navigate to the marked locations.</span>
                </li>
                <li style="margin-bottom: 8px; display: flex; align-items: flex-start;">
                    <span style="color: ${darkBlue}; margin-right: 10px; font-size: 1.1rem;">•</span>
                    <span>Tap the recenter button to focus on your current position.</span>
                </li>
                <li style="margin-bottom: 8px; display: flex; align-items: flex-start;">
                    <span style="color: ${darkBlue}; margin-right: 10px; font-size: 1.1rem;">•</span>
                    <span>The distance box shows how far you are from the closest location.</span>
                </li>
                <li style="margin-bottom: 8px; display: flex; align-items: flex-start;">
                    <span style="color: ${darkBlue}; margin-right: 10px; font-size: 1.1rem;">•</span>
                    <span>When you're within 20 feet of a location, you'll be able to interact with it.</span>
                </li>
                <li style="margin-bottom: 8px; display: flex; align-items: flex-start;">
                    <span style="color: ${darkBlue}; margin-right: 10px; font-size: 1.1rem;">•</span>
                    <span>Listen to the audio information for each location.</span>
                </li>
                <li style="margin-bottom: 0; display: flex; align-items: flex-start;">
                    <span style="color: ${darkBlue}; margin-right: 10px; font-size: 1.1rem;">•</span>
                    <span>After the audio, you'll see additional information about the location.</span>
                </li>
            </ul>
        `;
        
        const footer = document.createElement("div");
        footer.style.cssText = `
            padding: 15px 28px 20px !important;
            text-align: center !important;
            border-top: 1px solid rgba(0, 0, 0, 0.05);
            margin-top: 10px !important;
            display: flex !important;
            justify-content: center !important;
            align-items: center !important;
            position: relative !important;
            bottom: 0 !important;
            width: 100% !important;
            box-sizing: border-box !important;
        `;
        
        const closeButton = document.createElement("button");
        closeButton.className = "close-button";
        closeButton.textContent = "Close";
        closeButton.style.cssText = `
            padding: 10px 24px !important;
            background-color: ${darkBlue};
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            width: 100% !important;
            max-width: 200px !important;
            transition: all 0.2s ease;
            margin: 0 auto !important;
            display: block !important;
            position: relative !important;
            left: 0 !important;
            right: 0 !important;
        `;
        
        footer.appendChild(closeButton);
        
        modalContent.appendChild(header);
        modalContent.appendChild(contentArea);
        modalContent.appendChild(footer);
        modalOverlay.appendChild(modalContent);
        document.body.appendChild(modalOverlay);
        
        setTimeout(() => {
            modalOverlay.style.opacity = "1";
            modalContent.style.transform = "translateY(0)";
        }, 10);
        
        closeButton.addEventListener("mouseover", function() {
            this.style.backgroundColor = darkBlueHover;
        });
        
        
        closeButton.addEventListener("mouseout", function() {
            this.style.backgroundColor = darkBlue;
        });
        
        closeButton.addEventListener("click", function() {
            modalOverlay.style.opacity = "0";
            modalContent.style.transform = "translateY(20px)";
            setTimeout(() => {
                document.body.removeChild(modalOverlay);
            }, 300);
        });
        
        modalOverlay.addEventListener("click", function(e) {
            if (e.target === modalOverlay) {
                modalOverlay.style.opacity = "0";
                modalContent.style.transform = "translateY(20px)";
                setTimeout(() => {
                    document.body.removeChild(modalOverlay);
                }, 300);
            }
        });
    }

    function startHunt() {
        if (!locationsLoaded || !gameLocations || gameLocations.length === 0) {
            console.error("Cannot start hunt: locations not loaded");
            showPopup("Error", "Location data is not available. Please refresh the page and try again.");
            return;
        }
        
        currentLocationIndex = 0;
        locationCooldowns = new Map();
        lastVisitedLocationId = null;
        loadAllLocations();
    }

    function getMarkerColor(tours) {
        if (!tours) return '#0f2bab';
        
        switch (tours.toLowerCase()) {
            case 'person':
                return '#FFA500';
            case 'gangster':
                return '#3f9b0b';
            case 'event':
                return '#8B0000';
            case 'place':
                return '#800080';
            default:
                return '#0f2bab';
        }
    }

    let markersCreated = false;
    let activePopups = new Set();

    function recenterOnUser() {
        if (userMarker && map) {
            map.setView(userMarker.getLatLng(), map.getZoom(), {
                animate: true,
                duration: 0.3 // Ultra-smooth
            });
        }
    }

    // Ultra-smooth marker creation
    function createMarkersOnly() {
        if (!gameLocations || !Array.isArray(gameLocations) || gameLocations.length === 0) {
            console.warn("No game locations available");
            return;
        }

        if (markerClusterGroup) {
            markerClusterGroup.clearLayers();
        }

        activePopups.clear();

        gameLocations.forEach((location) => {
            if (!location || !isFinite(location.lat) || !isFinite(location.lng)) {
                console.warn("Invalid location data:", location);
                return;
            }

            const markerColor = getMarkerColor(location.tours);
            
            const locationMarker = L.marker([location.lat, location.lng], {
                icon: L.divIcon({
                    className: 'custom-pin-icon',
                    html: `<div class="pin-head" style="background-color: ${markerColor};"></div>`,
                    iconSize: [26, 26], // Slightly smaller for better performance
                    iconAnchor: [13, 26],
                })
            });

            const popupContent = `
                <div class="popup-content">
                    <img loading="lazy" src="${location.image}" alt="${location.name}" class="location-image">
                    <h4 class="location-name">
                        <a href="${location.link}" target="_blank" rel="noopener noreferrer" style="text-decoration: none; color: inherit;">${location.name}</a>
                    </h4>
                    <div class="popup-buttons">
                        <button class="button route-button" data-lat="${location.lat}" data-lng="${location.lng}" data-location-id="${location.id}">Directions</button>
                        <button class="button summary-button" data-location-id="${location.id}">Summary</button>
                    </div>
                </div>
            `;

            locationMarker.bindPopup(popupContent, {
                offset: L.point(0, -20),
                className: 'custom-popup',
                maxWidth: 270,
                closeButton: true,
                autoClose: true,
                closeOnClick: true
            });

            locationMarker.on('popupopen', function(e) {
                activePopups.add(locationMarker);
                attachPopupEventListeners(e.popup._contentNode, location);
            });

            locationMarker.on('popupclose', function(e) {
                activePopups.delete(locationMarker);
            });

            markerClusterGroup.addLayer(locationMarker);
        });

        if (!map.hasLayer(markerClusterGroup)) {
            map.addLayer(markerClusterGroup);
        }
        
        markersCreated = true;
    }

    function attachPopupEventListeners(popupElement, location) {
        const routeButton = popupElement.querySelector('.route-button');
        const summaryButton = popupElement.querySelector('.summary-button');

        if (routeButton && !routeButton.hasAttribute('data-listener-attached')) {
            routeButton.setAttribute('data-listener-attached', 'true');
            routeButton.addEventListener('click', function(event) {
                event.preventDefault();
                event.stopPropagation();
                showNavigationModal(location.lat, location.lng);
            });
        }

        if (summaryButton && !summaryButton.hasAttribute('data-listener-attached')) {
            summaryButton.setAttribute('data-listener-attached', 'true');
            summaryButton.addEventListener('click', function(event) {
                event.preventDefault();
                event.stopPropagation();
                showLocationSummary(location.id);
            });
        }
    }

    function closeAllPopups() {
        activePopups.forEach(marker => {
            if (marker.isPopupOpen()) {
                marker.closePopup();
            }
        });
        activePopups.clear();
    }

    // Updated navigation modal function with reminder modal
    function showNavigationModal(lat, lng) {
        closeAllPopups();
        
        const existingModals = document.querySelectorAll('.modal');
        existingModals.forEach(modal => modal.remove());
        
        const modal = document.createElement("div");
        modal.className = "modal";
        modal.style.display = "flex";
        modal.style.zIndex = "10000";
        modal.classList.add("fade-in");
        modal.innerHTML = `
            <div class="modal-content">
                <h3>Choose your preferred navigation app:</h3>
                <div class="modal-buttons" style="display: flex; flex-direction: column; gap: 10px; width: 100%;">
                    <button class="modal-button google-maps">Google Maps</button>
                    <button class="modal-button waze">Waze</button>
                    <button class="modal-button apple-maps">Apple Maps</button>
                    <button class="modal-button cancel">Cancel</button>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
        
        const closeModal = () => {
            modal.classList.add('fade-out');
            setTimeout(() => {
                if (modal.parentNode) {
                    modal.remove();
                }
            }, 200); // Ultra-smooth
        };
        
        modal.querySelector('.google-maps').addEventListener('click', () => {
            closeModal();
            showNavigationReminderModal('Google Maps', `https://www.google.com/maps/dir/?api=1&destination=${lat},${lng}`);
        });
        
        modal.querySelector('.waze').addEventListener('click', () => {
            closeModal();
            showNavigationReminderModal('Waze', `https://www.waze.com/ul?ll=${lat}%2C${lng}&navigate=yes`);
        });
        
        modal.querySelector('.apple-maps').addEventListener('click', () => {
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
            if (isIOS) {
                closeModal();
                showNavigationReminderModal('Apple Maps', `maps://maps.apple.com/?daddr=${lat},${lng}`);
            } else {
                closeModal();
                showPopup('Info', 'Apple Maps is only available on iOS devices');
            }
        });
        
        modal.querySelector('.cancel').addEventListener('click', closeModal);
        
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                closeModal();
            }
        });
    }

    function loadAllLocations() {
        if (!gameLocations || !Array.isArray(gameLocations) || gameLocations.length === 0) {
            console.error("No locations available to load");
            showPopup("Error", "No locations available. Please try reloading the page.");
            return;
        }
        
        createMarkersOnly();
        updateDistanceBox();
        resetInactivityTimer();
    }

    let visibilityTimeout;
    document.addEventListener('visibilitychange', function() {
        if (!document.hidden) {
            if (visibilityTimeout) {
                clearTimeout(visibilityTimeout);
            }
            
            if (!isReturningFromNavigation) {
                visibilityTimeout = setTimeout(() => {
                    recenterOnUser();
                    if (markerClusterGroup && markerClusterGroup.getLayers().length === 0) {
                        createMarkersOnly();
                    }
                }, 150); // Ultra-responsive
            } else {
                if (markerClusterGroup && markerClusterGroup.getLayers().length === 0) {
                    createMarkersOnly();
                }
            }
        }
    });

    window.addEventListener('focus', function() {
        if (!isReturningFromNavigation) {
            recenterOnUser();
        }
    });

    function recenterMapAndClosePopups() {
        closeAllPopups();
        recenterOnUser();
    }
        
    function returnToIndex() {
        const popupDiv = document.createElement("div");
        popupDiv.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.6);
            backdrop-filter: blur(4px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease;
        `;
        const darkBlue = "var(--dark-blue)";
        const darkBlueHover = "var(--dark-blue-hover)";
        popupDiv.innerHTML = `
            <div class="modal-container" style="
            background-color: white;
            border-radius: 16px;
            padding: 28px;
            width: 90%;
            max-width: 420px;
            max-height: 90vh;
            box-shadow: 0 15px 40px rgba(0,0,0,0.2);
            margin: auto;
            transform: translateY(20px);
            transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            ">
            <div style="
                text-align: center;
                margin-bottom: 25px;
            ">
                                <svg width="50" height="50" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <circle cx="12" cy="12" r="10" stroke="${darkBlue}" stroke-width="1.5"/>
                <path d="M12 8V13" stroke="${darkBlue}" stroke-width="2" stroke-linecap="round"/>
                <circle cx="12" cy="16" r="1" fill="${darkBlue}"/>
                </svg>
            </div>
            <h3 style="
                text-align: center;
                margin: 0 0 15px 0;
                color: #2c3e50;
                font-size: 1.5rem;
                font-weight: 600;
            ">Ready to Leave?</h3>
            <div style="flex-grow: 1; overflow-y: auto; padding: 0 10px;">
                <p style="
                text-align: center;
                margin: 0 0 30px 0;
                color: #5c6c7c;
                line-height: 1.5;
                font-size: 1rem;
                ">Are you sure you want to return to the main page?</p>
            </div>
            <div style="
                display: flex;
                justify-content: center;
                gap: 15px;
                margin-bottom: 15px;
            ">
                <button class="confirm-btn" style="
                padding: 14px 24px;
                background-color: ${darkBlue};
                color: white;
                border: none;
                border-radius: 10px;
                cursor: pointer;
                font-size: 1rem;
                font-weight: 600;
                min-width: 130px;
                transition: all 0.2s ease;
                ">Yes, Exit</button>
                <button class="cancel-btn" style="
                padding: 14px 24px;
                background-color: transparent;
                color: ${darkBlue};
                border: 1.5px solid ${darkBlue};
                border-radius: 10px;
                cursor: pointer;
                font-size: 1rem;
                font-weight: 600;
                min-width: 130px;
                transition: all 0.2s ease;
                ">Stay Here</button>
            </div>
            <div style="text-align: center; margin-top: 15px;">
                <a href="#" class="credits-link" style="
                display: inline-block;
                text-align: center;
                color: #64748b;
                text-decoration: none;
                font-size: 0.9rem;
                padding: 8px 20px;
                border-radius: 100px;
                border: 1px solid rgba(100, 116, 139, 0.2);
                background-color: rgba(100, 116, 139, 0.05);
                transition: all 0.2s ease;
                ">View Acknowledgements</a>
            </div>
            </div>
        `;
        document.body.appendChild(popupDiv);
        setTimeout(() => {
            popupDiv.style.opacity = "1";
            popupDiv.querySelector(".modal-container").style.transform = "translateY(0)";
        }, 10);
        const confirmBtn = popupDiv.querySelector(".confirm-btn");
        confirmBtn.addEventListener("mouseover", function() {
            this.style.backgroundColor = darkBlueHover;
        });
        confirmBtn.addEventListener("mouseout", function() {
            this.style.backgroundColor = darkBlue;
        });
        const cancelBtn = popupDiv.querySelector(".cancel-btn");
        cancelBtn.addEventListener("mouseover", function() {
            this.style.backgroundColor = "rgba(26, 58, 138, 0.05)";
        });
        cancelBtn.addEventListener("mouseout", function() {
            this.style.backgroundColor = "transparent";
        });
        const creditsLink = popupDiv.querySelector(".credits-link");
        creditsLink.addEventListener("mouseover", function() {
            this.style.backgroundColor = "rgba(100, 116, 139, 0.1)";
            this.style.borderColor = "rgba(100, 116, 139, 0.3)";
        });
        creditsLink.addEventListener("mouseout", function() {
            this.style.backgroundColor = "rgba(100, 116, 139, 0.05)";
            this.style.borderColor = "rgba(100, 116, 139, 0.2)";
        });
        confirmBtn.addEventListener("click", function() {
            popupDiv.style.opacity = "0";
            popupDiv.querySelector(".modal-container").style.transform = "translateY(20px)";
            setTimeout(() => {
                document.body.removeChild(popupDiv);
                window.location.href = "/index.html";
            }, 300);
        });
        cancelBtn.addEventListener("click", function() {
            popupDiv.style.opacity = "0";
            popupDiv.querySelector(".modal-container").style.transform = "translateY(20px)";
            setTimeout(() => {
                document.body.removeChild(popupDiv);
            }, 300);
        });
        creditsLink.addEventListener("click", function(e) {
            e.preventDefault();
            const creditsPopup = document.createElement("div");
            creditsPopup.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0,0,0,0.7);
                backdrop-filter: blur(6px);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 1001;
                opacity: 0;
                transition: opacity 0.3s ease;
            `;
            creditsPopup.innerHTML = `
                <div class="credits-container" style="
                    background-color: white;
                    border-radius: 16px;
                    width: 92%;
                    max-width: 450px;
                    max-height: 80vh;
                    box-shadow: 0 20px 50px rgba(0,0,0,0.25);
                    margin: auto;
                    transform: translateY(20px);
                    transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
                    overflow: hidden;
                    display: flex;
                    flex-direction: column;
                ">
                    <div style="
                        background-color: ${darkBlue};
                        padding: 20px;
                        color: white;
                        text-align: center;
                    ">
                        <h3 style="margin: 0; font-size: 1.5rem; font-weight: 600;">Acknowledgements</h3>
                    </div>
                    <div style="
                        padding: 20px;
                        flex-grow: 1;
                        overflow-y: auto;
                    ">
                        <ul style="list-style-type: none; padding: 0; margin: 0;">
                            <li style="margin-bottom: 20px;">
                                <strong style="color: #1e293b; font-size: 1.05rem;">OpenStreetMap</strong>
                                <p style="color: #64748b; margin: 5px 0 0 0; font-size: 0.9rem; line-height: 1.5;">
                                    Providing the map data and tiles for this interactive experience.
                                </p>
                            </li>
                            <li style="margin-bottom: 20px;">
                                <strong style="color: #1e293b; font-size: 1.05rem;">Minnesota Historical Society</strong>
                                <p style="color: #64748b; margin: 5px 0 0 0; font-size: 0.9rem; line-height: 1.5;">
                                    For their invaluable historical data, photographs, and archive materials.
                                </p>
                            </li>
                            <li style="margin-bottom: 20px;">
                                <strong style="color: #1e293b; font-size: 1.05rem;">Metropolitan State University</strong>
                                <p style="color: #64748b; margin: 5px 0 0 0; font-size: 0.9rem; line-height: 1.5;">
                                    For fostering a passion for history and research methodology.
                                </p>
                            </li>
                            <li style="margin-bottom: 20px;">
                                <strong style="color: #1e293b; font-size: 1.05rem;">Leaflet.js</strong>
                                <p style="color: #64748b; margin: 5px 0 0 0; font-size: 0.9rem; line-height: 1.5;">
                                    The open-source JavaScript library that powers the mapping features.
                                </p>
                            </li>
                            <li>
                                <strong style="color: #1e293b; font-size: 1.05rem;">All Contributors</strong>
                                <p style="color: #64748b; margin: 5px 0 0 0; font-size: 0.9rem; line-height: 1.5;">
                                    Researchers, testers, and developers who made this project possible.
                                </p>
                            </li>
                        </ul>
                    </div>
                    <div style="padding: 15px; text-align: center; border-top: 1px solid #eee;">
                        <button class="close-credits-btn" style="
                            padding: 12px 30px;
                            background-color: ${darkBlue};
                            color: white;
                            border: none;
                            border-radius: 10px;
                            cursor: pointer;
                            font-size: 0.95rem;
                            font-weight: 600;
                            transition: background-color 0.2s ease;
                        ">Close</button>
                    </div>
                </div>
            `;
            document.body.appendChild(creditsPopup);
            setTimeout(() => {
                creditsPopup.style.opacity = "1";
                creditsPopup.querySelector(".credits-container").style.transform = "translateY(0)";
            }, 10);
            const closeBtn = creditsPopup.querySelector(".close-credits-btn");
            closeBtn.addEventListener("mouseover", function() {
                this.style.backgroundColor = darkBlueHover;
            });
            closeBtn.addEventListener("mouseout", function() {
                this.style.backgroundColor = darkBlue;
            });
            closeBtn.addEventListener("click", function() {
                creditsPopup.style.opacity = "0";
                creditsPopup.querySelector(".credits-container").style.transform = "translateY(20px)";
                setTimeout(() => {
                    document.body.removeChild(creditsPopup);
                }, 300);
            });
            creditsPopup.addEventListener("click", function(e) {
                if (e.target === creditsPopup) {
                    creditsPopup.style.opacity = "0";
                    creditsPopup.querySelector(".credits-container").style.transform = "translateY(20px)";
                    setTimeout(() => {
                        document.body.removeChild(creditsPopup);
                    }, 300);
                }
            });
        });
        popupDiv.addEventListener("click", function(e) {
            if (e.target === popupDiv) {
                popupDiv.style.opacity = "0";
                popupDiv.querySelector(".modal-container").style.transform = "translateY(20px)";
                setTimeout(() => {
                    document.body.removeChild(popupDiv);
                }, 300);
            }
        });
    }

    function isSignificantMovement(newPosition) {
        if (!lastPositionForJitter) {
            lastPositionForJitter = newPosition;
            lastSignificantMovement = Date.now();
            return true;
        }
        
        const distance = calculateDistance(lastPositionForJitter, newPosition);
        const timeSinceLastMovement = Date.now() - lastSignificantMovement;
        
        if (distance > CONFIG.JITTER_THRESHOLD && timeSinceLastMovement > CONFIG.SIGNIFICANT_MOVEMENT_COOLDOWN) {
            lastPositionForJitter = newPosition;
            lastSignificantMovement = Date.now();
            return true;
        }
        
        return false;
    }

    // Ultra-smooth inactivity timer
    function resetInactivityTimer(isExplicitInteraction = true) {
        if (inactivityTimer) {
            clearTimeout(inactivityTimer);
            inactivityTimer = null;
        }
        
        inactivityTimer = setTimeout(() => {
            if (!isMapInteracting && userMarker) {
                followUser = true;
                
                const userPos = userMarker.getLatLng();
                if (userPos && isFinite(userPos.lat) && isFinite(userPos.lng)) {
                    map.flyTo(userPos, map.getZoom(), {
                        animate: true,
                        duration: 0.6, // Ultra-smooth duration
                        easeLinearity: 0.2
                    });
                }
            }
        }, CONFIG.INACTIVITY_TIMEOUT);
        
        if (isExplicitInteraction) {
            isMapInteracting = false;
        }
    }

    // Ultra-smooth image loading
    function optimizeImages() {
        const images = document.querySelectorAll('img:not([loading])');
        images.forEach(img => {
            img.loading = 'lazy';
            
            if (img.src && !img.width && !img.height) {
                img.onload = function() {
                    img.setAttribute('width', img.naturalWidth);
                    img.setAttribute('height', img.naturalHeight);
                };
            }
        });
    }

    // Ultra-smooth event listeners setup
    function setupEventListeners() {
        map.on('dragstart', () => {
            followUser = false;
            isMapInteracting = true;
            if (inactivityTimer) {
                clearTimeout(inactivityTimer);
                inactivityTimer = null;
            }
        });
        
        map.on('dragend', () => {
            isMapInteracting = false;
            resetInactivityTimer();
        });
        
        map.on('zoomstart', () => {
            isMapInteracting = true;
            if (inactivityTimer) {
                clearTimeout(inactivityTimer);
                inactivityTimer = null;
            }
        });
        
        map.on('zoomend', () => {
            isMapInteracting = false;
            resetInactivityTimer();
        });
        
        // Ultra-smooth touch event handling
        let touchStartTime = 0;
        let touchStartPos = null;
        let isTouchMoving = false;
        
        document.addEventListener('touchstart', (e) => {
            touchStartTime = Date.now();
            touchStartPos = {
                x: e.touches[0].clientX,
                y: e.touches[0].clientY
            };
            isTouchMoving = false;
        }, { passive: true });
        
        document.addEventListener('touchmove', (e) => {
            if (!touchStartPos) return;
            
            const touchCurrentPos = {
                x: e.touches[0].clientX,
                y: e.touches[0].clientY
            };
            
            const dx = touchCurrentPos.x - touchStartPos.x;
            const dy = touchCurrentPos.y - touchStartPos.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance > 6) { // More sensitive
                isTouchMoving = true;
                isMapInteracting = true;
                followUser = false;
                
                if (inactivityTimer) {
                    clearTimeout(inactivityTimer);
                    inactivityTimer = null;
                }
            }
        }, { passive: true });
        
        document.addEventListener('touchend', (e) => {
            const touchEndTime = Date.now();
            const touchDuration = touchEndTime - touchStartTime;
            
            touchStartPos = null;
            
            if (touchDuration < 200 && !isTouchMoving) { // More responsive
                return;
            }
            
            isMapInteracting = false;
            resetInactivityTimer();
        }, { passive: true });
        
        document.getElementById('recenterButton').addEventListener('click', recenterMap);
        document.getElementById('returnButton').addEventListener('click', returnToIndex);
        
        const tipsButton = document.getElementById('tipsButton');
        tipsButton.addEventListener('click', showNavigationTips);
 
        document.addEventListener('visibilitychange', handleVisibilityChange);
        
        window.addEventListener('resize', () => {
            if (map) {
                map.invalidateSize();
                updateDistanceBox();
            }
        });
        
        // Ultra-smooth pinch-zoom handling
        let initialPinchDistance = 0;
        let initialZoom = 0;
        let isPinching = false;
        
        document.addEventListener('touchstart', (e) => {
            if (e.touches.length === 2) {
                isPinching = true;
                isMapInteracting = true;
                followUser = false;
                
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                initialPinchDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                initialZoom = map.getZoom();
                
                e.preventDefault();
            }
        }, { passive: false });
        
        document.addEventListener('touchmove', (e) => {
            if (isPinching && e.touches.length === 2) {
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                const currentPinchDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                
                const pinchRatio = currentPinchDistance / initialPinchDistance;
                const zoomDelta = Math.log2(pinchRatio) * 2.2; // More responsive
                const newZoom = Math.max(7, Math.min(18, initialZoom + zoomDelta));
                
                const centerX = (touch1.clientX + touch2.clientX) / 2;
                const centerY = (touch1.clientY + touch2.clientY) / 2;
                const centerPoint = L.point(centerX, centerY);
                const centerLatLng = map.containerPointToLatLng(centerPoint);
                
                map.setView(centerLatLng, newZoom, { animate: false });
                
                e.preventDefault();
            }
        }, { passive: false });
        
        document.addEventListener('touchend', (e) => {
            if (isPinching) {
                isPinching = false;
                isMapInteracting = false;
                resetInactivityTimer();
                
                if (e.touches.length < 2) {
                    e.preventDefault();
                }
            }
        }, { passive: false });
    }

    // Ultra-smooth application initialization
    document.addEventListener('DOMContentLoaded', () => {
        initMap();
        setupEventListeners();
        optimizeImages();
        
        const additionalInfoContainer = document.querySelector('.additional-info-container');
        if (additionalInfoContainer) {
            additionalInfoContainer.style.display = 'none';
        }
        
        const lochuntContainer = document.querySelector('.lochunt-container');
        if (lochuntContainer) {
            lochuntContainer.style.display = 'none';
        }
    });
    </script>

</body>
</html>
