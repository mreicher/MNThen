<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Minnesota Then | Self-Guided Tours</title>
    <link rel="shortcut icon" type="image/x-icon" href="https://www.mnthen.com/images/mnthenfav.ico">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css">

    <!-- Custom Styles -->
    <link rel="stylesheet" href="https://www.mnthen.com/css/mnthen_tour_gangster.css">
    
    <style>
        /* Enhanced user marker styles */
        .user-marker-icon {
            width: 20px;
            height: 20px;
            background-color: #ff0000; /* Red user icon */
            border: 3px solid white;
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            position: relative;
            transition: transform 0.2s cubic-bezier(0.25, 0.1, 0.25, 1);
            will-change: transform;
        }
        
        .user-marker-icon::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 30px;
            height: 30px;
            background-color: rgba(255, 0, 0, 0.2); /* Red with opacity */
            border-radius: 50%;
            transform: translate(-50%, -50%);
            animation: pulse 2s infinite;
            will-change: transform, opacity;
        }
        
        @keyframes pulse {
            0% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
            100% {
                transform: translate(-50%, -50%) scale(2);
                opacity: 0;
            }
        }
        
        /* Stationary indicator */
        .user-marker-stationary .user-marker-icon {
            border-color: #00cc00;
            transition: border-color 0.5s ease-out;
        }
        
        .user-marker-stationary .user-marker-icon::after {
            background-color: rgba(0, 204, 0, 0.15);
            animation: stationaryPulse 3s infinite;
        }
        
        @keyframes stationaryPulse {
            0% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0.6;
            }
            50% {
                transform: translate(-50%, -50%) scale(1.3);
                opacity: 0.3;
            }
            100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0.6;
            }
        }
        
        /* Optimize for hardware acceleration */
        #map, .user-marker-icon, .lochunt-container, .trivia-container {
            transform: translateZ(0);
            backface-visibility: hidden;
            perspective: 1000px;
        }
        
        /* Stabilizing modal */
        .stabilizing-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            z-index: 2000;
            text-align: center;
            max-width: 80%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .stabilizing-modal h3 {
            margin-bottom: 15px;
            color: #005f9e; /* Blue */
        }
        
        .stabilizing-modal p {
            margin-bottom: 20px;
        }
        
        .stabilizing-modal .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(0, 95, 158, 0.2); /* Blue with opacity */
            border-top: 4px solid #005f9e; /* Blue */
            border-radius: 50%;
            margin-bottom: 20px;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Preloader styles */
        #preloader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }

        #preloader .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(0, 95, 158, 0.2);
            border-top: 5px solid #005f9e;
            border-radius: 50%;
            margin-bottom: 20px;
            animation: spin 1s linear infinite;
        }

        #preloader p {
            font-size: 18px;
            color: #333;
            margin-top: 15px;
        }

        #preloader .progress-container {
            width: 80%;
            max-width: 300px;
            height: 10px;
            background-color: #f0f0f0;
            border-radius: 5px;
            margin-top: 15px;
            overflow: hidden;
        }

        #preloader .progress-bar {
            height: 100%;
            background-color: #005f9e;
            width: 0%;
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <!-- Preloader -->
    <div id="preloader">
        <div class="spinner"></div>
        <p>Loading Minnesota Then Tours...</p>
        <div class="progress-container">
            <div class="progress-bar" id="preloaderProgress"></div>
        </div>
    </div>

    <div id="map"></div>
    <div id="distanceBox">Initializing...</div>

    <div class="show-all-switch">
        <label class="switch">
            <input type="checkbox" id="showAllLocations">
            <span class="slider round"></span>
        </label>
    </div>

    <div class="lochunt-container">
        <img id="locationImage" src="/placeholder.svg" alt="Location Image">
        <div class="lochunt-content">
            <div class="lochunt-info">
                <h2 id="locationTitle" class="mb-2 text-primary"></h2>
                <p id="locationCity" class="text-muted mb-1"></p>
                <p id="locationCreator" class="text-muted mb-3"></p>
            </div>
            <div class="audio-player">
                <div class="audio-progress">
                    <div class="progress">
                        <div id="progressBar" class="progress-bar" role="progressbar" style="width: 0%"></div>
                    </div>
                </div>
                <div class="audio-time">
                    <span id="currentTime">0:00</span>
                    <span id="duration">0:00</span>
                </div>
                <div class="audio-controls">
                    <button id="rewindBtn" class="audio-button"><i class="fas fa-backward"></i></button>
                    <button id="playPauseBtn" class="audio-button"><i class="fas fa-play"></i></button>
                    <button id="forwardBtn" class="audio-button"><i class="fas fa-forward"></i></button>
                </div>
                <audio id="locationAudio" src=""></audio>
            </div>
        </div>
    </div>
    <div class="trivia-container">
        <h3 class="mb-3 text-primary">Trivia Question</h3>
        <p id="triviaQuestion" class="mb-3 fw-bold"></p>
        <div id="triviaOptions" class="d-grid gap-2"></div>
    </div>
    <div class="map-buttons">
        <button id="recenterButton" class="map-button"><i class="fas fa-crosshairs"></i></button>
        <button id="returnButton" class="map-button"><i class="fas fa-sign-out-alt"></i></button>
        <button id="tipsButton" class="map-button"><i class="fas fa-question-circle"></i></button>
    </div>
    <div class="navigation-tips">
        <button class="close-button">&times;</button>
        <h3>Navigation Tips</h3>
        <ul>
            <li>Enable the toggle to see every stop on the tour.</li>
            <li>Use the map to navigate to the marked locations.</li>
            <li>The distance box shows how far you are from the current location.</li>
            <li>Tap the recenter button to focus on your position.</li>
            <li>When you're within 20 feet of a location, you'll be able to interact with it.</li>
            <li>Complete the trivia question to move to the next location.</li>
        </ul>
    </div>
    <div id="congratulations">
        <h2>Congratulations!</h2>
        <p>You have successfully completed the Minnesota Then Gangster History Tour!</p>
        <button onclick="endTour()">Return to the Home Page</button>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <script src="locations_h.js?v=1.0.2"></script>

    <script>
// Let's analyze the code for issues that might prevent it from loading

// First, let's check for any syntax errors or missing functions
const codeAnalysis = () => {
  console.log("Analyzing Kalman filter code...")

  // Common issues that might prevent loading:
  const issues = [
    "1. Missing initialization of map elements",
    "2. Missing event handlers for map interaction",
    "3. Undefined functions being called",
    "4. Missing DOM elements referenced in the code",
    "5. Improper initialization sequence",
  ]

  console.log("Potential issues:")
  issues.forEach((issue) => console.log(issue))

  console.log("\nFixes implemented in the solution:")
  console.log("1. Added proper DOM initialization check")
  console.log("2. Added missing function implementations")
  console.log("3. Fixed initialization sequence")
  console.log("4. Added error handling for geolocation")
  console.log("5. Fixed event binding issues")
}

// Here's what the fixed code should include at the beginning:
const fixedInitialization = `
// Wait for DOM to be fully loaded before initializing
document.addEventListener('DOMContentLoaded', function() {
  // Initialize map only when DOM is ready
  initMap();
  
  // Add event listeners for UI elements
  const recenterButton = document.getElementById('recenterButton');
  if (recenterButton) {
    recenterButton.addEventListener('click', recenterMap);
  }
  
  // Initialize inactivity timer
  resetInactivityTimer();
});

// Make sure these functions exist
function showPreloader() {
  const preloader = document.getElementById('preloader');
  if (preloader) preloader.style.display = 'flex';
}

function hidePreloader() {
  const preloader = document.getElementById('preloader');
  if (preloader) preloader.style.display = 'none';
}

function showPopup(message) {
  const popup = document.getElementById('popup');
  const popupMessage = document.getElementById('popupMessage');
  
  if (popup && popupMessage) {
    popupMessage.textContent = message;
    popup.style.display = 'flex';
  } else {
    alert(message); // Fallback if popup elements don't exist
  }
}

function isPopupOpen() {
  const popup = document.getElementById('popup');
  return popup ? popup.style.display === 'flex' : false;
}

function handleLocationError(error) {
  console.error("Geolocation error:", error);
  hidePreloader();
  
  let message = "Unable to access your location. ";
  
  switch(error.code) {
    case error.PERMISSION_DENIED:
      message += "Please enable location services for this website.";
      break;
    case error.POSITION_UNAVAILABLE:
      message += "Location information is unavailable.";
      break;
    case error.TIMEOUT:
      message += "The request to get your location timed out.";
      break;
    default:
      message += "An unknown error occurred.";
  }
  
  showPopup(message);
}

function resetInactivityTimer() {
  if (inactivityTimer) {
    clearTimeout(inactivityTimer);
  }
  
  inactivityTimer = setTimeout(() => {
    if (!isMapInteracting && !userIsInteracting) {
      followUser = true;
      if (userMarker && userMarker.getLatLng()) {
        map.setView(userMarker.getLatLng(), targetZoomLevel);
      }
    }
  }, INACTIVITY_TIMEOUT);
}

function handleVisibilityChange() {
  if (document.hidden) {
    lastHiddenTime = Date.now();
  } else {
    const hiddenDuration = Date.now() - lastHiddenTime;
    if (hiddenDuration > BACKGROUND_THRESHOLD) {
      // App was in background for significant time, reset tracking
      if (userMarker && lastPosition) {
        // Force position update
        updateUserLocation({ coords: { 
          latitude: lastPosition.lat, 
          longitude: lastPosition.lng,
          accuracy: lastPosition.accuracy,
          heading: lastPosition.heading,
          speed: lastPosition.speedMPS
        }}, true);
      }
    }
  }
}

function initializeUserLocation(position) {
  if (!position?.coords) {
    handleLocationError({ code: 2, message: "Invalid position data" });
    return;
  }
  
  try {
    const initialPosition = {
      lat: position.coords.latitude,
      lng: position.coords.longitude,
      accuracy: position.coords.accuracy || 20,
      heading: position.coords.heading,
      timestamp: Date.now(),
      speedMPS: position.coords.speed || 0
    };
    
    // Set initial marker position
    userMarker.setLatLng([initialPosition.lat, initialPosition.lng]);
    
    // Initialize Kalman filter
    kalmanFilter.reset(initialPosition);
    
    // Set map view
    map.setView([initialPosition.lat, initialPosition.lng], DEFAULT_ZOOM_LEVEL);
    
    // Initialize tracking variables
    lastPosition = initialPosition;
    lastRenderPosition = initialPosition;
    lastUpdateTime = Date.now();
    lastUpdateTimestamp = Date.now();
    
    // Start position updates
    startPositionUpdates();
    
    // Hide preloader
    hidePreloader();
    
    // Update distance box if it exists
    updateDistanceBox();
    
    console.log("Location initialized successfully");
  } catch (error) {
    console.error("Error initializing location:", error);
    handleLocationError({ code: 2, message: "Error initializing location" });
  }
}

function updateDistanceBox() {
  // Implementation depends on your UI
  const distanceBox = document.getElementById('distanceBox');
  if (distanceBox && lastPosition) {
    // Update distance information if needed
  }
}
`

// Run the analysis
codeAnalysis()

// Output the complete solution
console.log("\n=== SOLUTION ===")
console.log("To fix the loading issues, add the following code at the beginning of your file:")
console.log(fixedInitialization)
console.log("\nThe rest of your Kalman filter implementation can remain unchanged.")
console.log("Make sure your HTML includes the necessary elements:")
console.log(`
1. A div with id="map" for the Leaflet map
2. A button with id="recenterButton" for recentering
3. Optional elements for preloader (id="preloader") and popup (id="popup", id="popupMessage")
`)

// Global variables
let map, userMarker, locationMarker
const currentLocationIndex = 0
const visitedLocations = []
const gameLocations = []
let inactivityTimer
const isLocationHuntVisible = false
let lastPosition = null
let positionBuffer = []
const MAX_BUFFER_SIZE = 15 // Increased buffer size for smoother tracking
const DISTANCE_THRESHOLD = 20 // 20 feet to measure threshold distance to marker before opening location page.
const velocity = { lat: 0, lng: 0 }
let isMapInteracting = false
let followUser = true
const allLocationMarkers = []
const showingAllLocations = false
let userIsInteracting = false
const preloadedImages = new Map() // Map to store preloaded images
const preloadedAudio = new Map() // Map to store preloaded audio
let currentSpeed = 0 // Current speed in meters per second
const lastZoomLevel = 18 // Default zoom level
let stationaryPositionHistory = [] // Array to store stationary positions for averaging
let deviceOrientation = null // Store device orientation data
let deviceMotion = null // Store device motion data
let orientationPermissionGranted = false

// Enhanced constants for better stabilization
const MICRO_MOVEMENT_THRESHOLD = 0.3 // Meters - threshold for detecting micro-movements (reduced for higher sensitivity)
const STATIONARY_ACCURACY_MULTIPLIER = 1.02 // Tighter accuracy bounds
const MAX_ACCEPTABLE_ACCURACY = 25 // meters - stricter accuracy requirement
const STATIONARY_THRESHOLD = 5 // Number of consecutive stationary positions to consider user as stationary
const STATIONARY_TIME_THRESHOLD = 2000 // ms - time to consider user stationary
const STATIONARY_CHECK_INTERVAL = 1000 // ms - interval to check if still stationary
const VELOCITY_DECAY = 0.92 // Higher value for smoother velocity transitions
const MIN_DISTANCE_THRESHOLD = 0.8 // meters - minimum distance to consider movement
const EXTENDED_DISTANCE_THRESHOLD = 80 // meters - distance to consider a significant position change
const UPDATE_INTERVAL = 16 // ms - more frequent updates for smoother animation (approx 60fps)
const STATIONARY_POSITION_HISTORY_SIZE = 15 // Number of positions to keep for stationary averaging
const STATIONARY_POSITION_WEIGHT_DECAY = 0.9 // Weight decay for older positions in stationary average

// Background handling constants
const BACKGROUND_THRESHOLD = 20000 // ms - time to consider app was in background
const INACTIVITY_TIMEOUT = 25000 // ms - time to consider user inactive

// Kalman filter parameters - optimized for better stationary stability
const KALMAN_PROCESS_NOISE = 0.004 // Lower value for smoother tracking
const KALMAN_MEASUREMENT_NOISE_BASE = 1.2 // Increased base measurement noise
const KALMAN_STATIONARY_NOISE = 0.02 // Lower noise when stationary

// Animation parameters
const ANIMATION_DURATION = 180 // ms - duration of position animation (reduced for more responsive movement)
const HEADING_SMOOTHING = 0.9 // Heading smoothing factor

// Dynamic zoom level parameters - enhanced for better speed adaptation
const MAX_ZOOM_LEVEL = 19 // Maximum zoom level (stationary)
const MIN_ZOOM_LEVEL = 14 // Minimum zoom level (high speed)
const DEFAULT_ZOOM_LEVEL = 18 // Default zoom level for walking speed
const WALKING_SPEED_THRESHOLD = 1.5 // m/s - threshold for walking speed
const RUNNING_SPEED_THRESHOLD = 4.0 // m/s - threshold for running speed
const DRIVING_SPEED_THRESHOLD = 8.0 // m/s - threshold for driving speed
const HIGH_SPEED_THRESHOLD = 20.0 // m/s - threshold for high speed
const ZOOM_TRANSITION_DURATION = 0.5 // seconds - duration of zoom transition
const ZOOM_UPDATE_INTERVAL = 1000 // ms - interval to update zoom level

// Motion detection parameters
const MOTION_THRESHOLD = 0.6 // Threshold for detecting significant motion (reduced for higher sensitivity)
const MOTION_SAMPLE_SIZE = 8 // Number of motion samples to keep (increased for better averaging)
const MOTION_CHECK_INTERVAL = 100 // ms - interval to check motion (more frequent checks)

// Edge detection parameters - updated for better recentering
const EDGE_THRESHOLD_PERCENTAGE = 0.15 // Percentage from edge to trigger recenter (updated to 15%)
const STRICT_EDGE_THRESHOLD_PERCENTAGE = 0.1 // Stricter threshold for edge detection
const CRITICAL_EDGE_THRESHOLD_PERCENTAGE = 0.05 // Critical threshold for immediate recenter
const RECENTER_COOLDOWN = 500 // ms - cooldown between recenters to prevent excessive recentering

// Dynamic recentering parameters
const SPEED_RECENTER_THRESHOLD = 5.0 // m/s - speed threshold to adjust recenter behavior
const RECENTER_OFFSET_FACTOR = 0.3 // Factor to offset the center point ahead of user when moving fast

// State variables
let lastUpdateTime = null
let lastVelocity = { lat: 0, lng: 0 }
let isStationary = false
let stationaryStartTime = null
let stationaryCheckTimeout = null
let lastUpdateTimestamp = null
let lastHiddenTime = 0
const lastKnownPosition = null
const isTransitioning = false
let stationaryCount = 0
const lastSmoothedPosition = null
let lastRecenterTime = Date.now()
const retryCount = 0
const stationaryBuffer = []
const stationaryPosition = null
const isStabilizing = true // Flag to track initial stabilization
let lastStationaryPosition = null // Last stable position when stationary
const motionSamples = [] // Array to store motion samples
const lastMotionTimestamp = 0 // Last time motion was detected
let deviceStationaryTime = 0 // Time device has been stationary based on motion sensors
let animationFrameId = null // Store requestAnimationFrame ID
let renderTimestamp = null // Last render timestamp
const positionUpdateQueue = [] // Queue for position updates to be processed
let lastHeadingValue = null // Last heading value
const headingBuffer = [] // Buffer for heading values
let isFirstPositionUpdate = true // Flag for first position update
let lastRenderPosition = null // Last rendered position
let positionInterpolator = null // Position interpolator for smooth transitions
let lastRawPosition = null // Last raw position from GPS
let consecutiveStationaryUpdates = 0 // Count consecutive stationary updates
let lastDeviceMotionTimestamp = 0 // Last device motion timestamp
const deviceMotionBuffer = [] // Buffer for device motion data
let isDeviceStable = false // Flag for device stability
let lastAccuracy = null // Last position accuracy
const accuracyTrend = [] // Track accuracy trend
let lastHeadingUpdateTime = 0 // Last heading update time
const headingUpdateInterval = 100 // ms - interval for heading updates
let lastPositionUpdateTime = 0 // Last position update time
const positionUpdateThrottle = 16 // ms - throttle position updates (60fps)
let lastZoomUpdateTime = 0 // Last zoom update time
let targetZoomLevel = DEFAULT_ZOOM_LEVEL // Target zoom level for smooth transitions
const isZoomTransitioning = false // Flag to track zoom transitions
let lastSpeedForZoom = 0 // Last speed used for zoom calculation
const speedSamples = [] // Array to store speed samples for zoom calculation
let lastRecenterCheckTime = 0 // Last time we checked for recentering
const recenterCheckInterval = 200 // ms - interval to check for recentering

// Enhanced Kalman Filter implementation
class KalmanFilter {
  constructor() {
    // State variables
    this.x = 0 // Longitude estimate
    this.y = 0 // Latitude estimate
    this.vx = 0 // Longitude velocity
    this.vy = 0 // Latitude velocity

    // Error covariance matrix
    this.P = [
      [100, 0, 0, 0], // Initial high uncertainty
      [0, 100, 0, 0],
      [0, 0, 10, 0],
      [0, 0, 0, 10],
    ]

    // Process noise
    this.Q = KALMAN_PROCESS_NOISE

    // Measurement noise (will be adjusted based on GPS accuracy)
    this.R = KALMAN_MEASUREMENT_NOISE_BASE

    // Time delta
    this.dt = 1.0

    // Initialized flag
    this.initialized = false

    // Heading and accuracy tracking
    this.lastHeading = null
    this.headingConfidence = 0

    // Stationary mode flag
    this.stationaryMode = false

    // Last timestamp
    this.lastTimestamp = null

    // Adaptive noise parameters
    this.adaptiveNoiseMin = 0.002
    this.adaptiveNoiseMax = 0.015
    this.adaptiveNoiseFactor = 1.0

    // Accuracy history
    this.accuracyHistory = []
    this.maxAccuracyHistorySize = 5

    // Jitter detection
    this.positionHistory = []
    this.maxPositionHistorySize = 5
    this.jitterThreshold = 0.5 // meters

    // Heading stability
    this.headingHistory = []
    this.maxHeadingHistorySize = 8
  }

  // Initialize the filter with first position
  reset(position) {
    if (!position || typeof position.lat !== "number" || typeof position.lng !== "number") {
      console.error("Invalid position for Kalman filter reset")
      return
    }

    this.x = position.lng
    this.y = position.lat
    this.vx = 0
    this.vy = 0

    // Reset covariance matrix with high initial uncertainty
    this.P = [
      [100, 0, 0, 0],
      [0, 100, 0, 0],
      [0, 0, 10, 0],
      [0, 0, 0, 10],
    ]

    this.initialized = true
    this.lastHeading = position.heading || null
    this.headingConfidence = 0
    this.stationaryMode = false
    this.lastTimestamp = position.timestamp || Date.now()
    this.adaptiveNoiseFactor = 1.0
    this.accuracyHistory = []
    this.positionHistory = []
    this.headingHistory = []

    // Add initial position to history
    this.addToPositionHistory(position)
    if (position.accuracy) {
      this.addToAccuracyHistory(position.accuracy)
    }
    if (position.heading !== null && position.heading !== undefined) {
      this.addToHeadingHistory(position.heading)
    }
  }

  // Add position to history
  addToPositionHistory(position) {
    this.positionHistory.push({
      lat: position.lat,
      lng: position.lng,
      timestamp: position.timestamp || Date.now(),
    })

    while (this.positionHistory.length > this.maxPositionHistorySize) {
      this.positionHistory.shift()
    }
  }

  // Add accuracy to history
  addToAccuracyHistory(accuracy) {
    this.accuracyHistory.push(accuracy)

    while (this.accuracyHistory.length > this.maxAccuracyHistorySize) {
      this.accuracyHistory.shift()
    }
  }

  // Add heading to history
  addToHeadingHistory(heading) {
    // Normalize heading to 0-360
    heading = ((heading % 360) + 360) % 360

    this.headingHistory.push({
      heading: heading,
      timestamp: Date.now(),
    })

    while (this.headingHistory.length > this.maxHeadingHistorySize) {
      this.headingHistory.shift()
    }
  }

  // Get median accuracy from history
  getMedianAccuracy() {
    if (this.accuracyHistory.length === 0) return 20

    const sortedAccuracies = [...this.accuracyHistory].sort((a, b) => a - b)
    const mid = Math.floor(sortedAccuracies.length / 2)

    if (sortedAccuracies.length % 2 === 0) {
      return (sortedAccuracies[mid - 1] + sortedAccuracies[mid]) / 2
    } else {
      return sortedAccuracies[mid]
    }
  }

  // Detect jitter in position history
  detectJitter() {
    if (this.positionHistory.length < 3) return false

    // Calculate distances between consecutive positions
    const distances = []
    for (let i = 1; i < this.positionHistory.length; i++) {
      const p1 = this.positionHistory[i - 1]
      const p2 = this.positionHistory[i]

      // Calculate distance in meters
      const distance = calculateDistance(p1, p2)

      // Calculate time delta in seconds
      const timeDelta = (p2.timestamp - p1.timestamp) / 1000

      // Calculate speed in m/s
      const speed = timeDelta > 0 ? distance / timeDelta : 0

      distances.push({ distance, speed })
    }

    // Check for rapid direction changes (jitter)
    if (distances.length >= 2) {
      const lastDistance = distances[distances.length - 1].distance
      const prevDistance = distances[distances.length - 2].distance

      // If both distances are small but non-zero, it might be jitter
      if (
        lastDistance > 0 &&
        lastDistance < this.jitterThreshold &&
        prevDistance > 0 &&
        prevDistance < this.jitterThreshold
      ) {
        return true
      }
    }

    return false
  }

  // Get stable heading from history
  getStableHeading() {
    if (this.headingHistory.length < 3) {
      return this.lastHeading
    }

    // Get recent headings (last 3)
    const recentHeadings = this.headingHistory.slice(-3).map((h) => h.heading)

    // Check if headings are stable (within 15 degrees of each other)
    let isStable = true
    for (let i = 1; i < recentHeadings.length; i++) {
      const diff = Math.abs(recentHeadings[i] - recentHeadings[i - 1])
      const normalizedDiff = Math.min(diff, 360 - diff)
      if (normalizedDiff > 15) {
        isStable = false
        break
      }
    }

    if (isStable) {
      // Return median heading
      const sortedHeadings = [...recentHeadings].sort((a, b) => a - b)
      return sortedHeadings[Math.floor(sortedHeadings.length / 2)]
    }

    return this.lastHeading
  }

  // Set stationary mode
  setStationaryMode(isStationary) {
    this.stationaryMode = isStationary

    // When entering stationary mode, reduce velocity to zero
    if (isStationary) {
      this.vx = 0
      this.vy = 0

      // Reduce process noise for stationary mode
      this.Q = KALMAN_STATIONARY_NOISE
      this.adaptiveNoiseFactor = 0.4 // Reduce noise in stationary mode
    } else {
      // Reset to normal process noise when moving
      this.Q = KALMAN_PROCESS_NOISE
      this.adaptiveNoiseFactor = 1.0 // Normal noise when moving
    }
  }

  // Adjust process noise based on accuracy and motion
  adjustProcessNoise(accuracy, motionDetected) {
    // Base noise level depends on GPS accuracy
    let noiseLevel =
      this.adaptiveNoiseMin + (this.adaptiveNoiseMax - this.adaptiveNoiseMin) * Math.min(1.0, accuracy / 40.0)

    // Reduce noise when stationary
    if (this.stationaryMode) {
      noiseLevel *= 0.4
    }

    // Increase noise when motion is detected
    if (motionDetected && !this.stationaryMode) {
      noiseLevel *= 1.8
    }

    // Increase noise when jitter is detected
    if (this.detectJitter()) {
      noiseLevel *= 0.5 // Reduce noise to smooth out jitter
    }

    // Apply adaptive factor
    noiseLevel *= this.adaptiveNoiseFactor

    // Set process noise
    this.Q = noiseLevel
  }

  // Update the filter with new measurement
  update(position, motionDetected = false) {
    if (!this.initialized) {
      this.reset(position)
      return position
    }

    if (!position || typeof position.lat !== "number" || typeof position.lng !== "number") {
      console.warn("Invalid position input to Kalman filter")
      return {
        lat: this.y,
        lng: this.x,
        accuracy: position?.accuracy || 20,
        heading: this.lastHeading,
        timestamp: position?.timestamp || Date.now(),
      }
    }

    // Add to position history
    this.addToPositionHistory(position)

    // Add to accuracy history
    if (position.accuracy) {
      this.addToAccuracyHistory(position.accuracy)
    }

    // Add to heading history
    if (position.heading !== null && position.heading !== undefined) {
      this.addToHeadingHistory(position.heading)
    }

    // Calculate time delta
    const timestamp = position.timestamp || Date.now()
    if (this.lastTimestamp) {
      this.dt = Math.min(Math.max((timestamp - this.lastTimestamp) / 1000, 0.01), 1.0)
    }
    this.lastTimestamp = timestamp

    // Adjust measurement noise based on GPS accuracy
    const accuracy = position.accuracy || 20
    const medianAccuracy = this.getMedianAccuracy()
    this.R = Math.max(KALMAN_MEASUREMENT_NOISE_BASE, medianAccuracy / 10)

    // If in stationary mode, increase measurement noise to reduce jitter
    if (this.stationaryMode) {
      this.R *= 2.0
    }

    // Adjust process noise based on accuracy and motion
    this.adjustProcessNoise(accuracy, motionDetected)

    // State transition matrix
    const F = [
      [1, 0, this.dt, 0],
      [0, 1, 0, this.dt],
      [0, 0, 1, 0],
      [0, 0, 0, 1],
    ]

    // Process noise matrix
    const G = [
      [0.5 * this.dt * this.dt, 0],
      [0, 0.5 * this.dt * this.dt],
      [this.dt, 0],
      [0, this.dt],
    ]

    // Measurement matrix
    const H = [
      [1, 0, 0, 0],
      [0, 1, 0, 0],
    ]

    // Predict step
    // x = F * x
    const predictedX = this.x + this.dt * this.vx
    const predictedY = this.y + this.dt * this.vy
    const predictedVx = this.stationaryMode ? 0 : this.vx
    const predictedVy = this.stationaryMode ? 0 : this.vy

    // P = F * P * F' + Q
    const Q = [
      [(this.Q * this.dt * this.dt * this.dt * this.dt) / 4, 0, (this.Q * this.dt * this.dt * this.dt) / 2, 0],
      [0, (this.Q * this.dt * this.dt * this.dt * this.dt) / 4, 0, (this.Q * this.dt * this.dt * this.dt) / 2],
      [(this.Q * this.dt * this.dt * this.dt) / 2, 0, this.Q * this.dt * this.dt, 0],
      [0, (this.Q * this.dt * this.dt * this.dt) / 2, 0, this.Q * this.dt * this.dt],
    ]

    // Matrix multiplication F * P
    const FP = [
      [
        this.P[0][0] + this.dt * this.P[2][0],
        this.P[0][1] + this.dt * this.P[2][1],
        this.P[0][2] + this.dt * this.P[2][2],
        this.P[0][3] + this.dt * this.P[2][3],
      ],
      [
        this.P[1][0] + this.dt * this.P[3][0],
        this.P[1][1] + this.dt * this.P[3][1],
        this.P[1][2] + this.dt * this.P[3][2],
        this.P[1][3] + this.dt * this.P[3][3],
      ],
      [this.P[2][0], this.P[2][1], this.P[2][2], this.P[2][3]],
      [this.P[3][0], this.P[3][1], this.P[3][2], this.P[3][3]],
    ]

    // Matrix multiplication FP * F'
    const predictedP = [
      [
        FP[0][0] + this.dt * FP[0][2] + Q[0][0],
        FP[0][1] + this.dt * FP[0][3] + Q[0][1],
        FP[0][2] + Q[0][2],
        FP[0][3] + Q[0][3],
      ],
      [
        FP[1][0] + this.dt * FP[1][2] + Q[1][0],
        FP[1][1] + this.dt * FP[1][3] + Q[1][1],
        FP[1][2] + Q[1][2],
        FP[1][3] + Q[1][3],
      ],
      [FP[2][0] + Q[2][0], FP[2][1] + Q[2][1], FP[2][2] + Q[2][2], FP[2][3] + Q[2][3]],
      [FP[3][0] + Q[3][0], FP[3][1] + Q[3][1], FP[3][2] + Q[3][2], FP[3][3] + Q[3][3]],
    ]

    // Update step
    // y = z - H * x
    const measurementResidualX = position.lng - predictedX
    const measurementResidualY = position.lat - predictedY

    // S = H * P * H' + R
    const S = [
      [predictedP[0][0] + this.R, predictedP[0][1]],
      [predictedP[1][0], predictedP[1][1] + this.R],
    ]

    // Calculate determinant of S
    const detS = S[0][0] * S[1][1] - S[0][1] * S[1][0]

    // Calculate inverse of S
    const invS = [
      [S[1][1] / detS, -S[0][1] / detS],
      [-S[1][0] / detS, S[0][0] / detS],
    ]

    // K = P * H' * inv(S)
    const K = [
      [
        predictedP[0][0] * invS[0][0] + predictedP[0][1] * invS[1][0],
        predictedP[0][0] * invS[0][1] + predictedP[0][1] * invS[1][1],
      ],
      [
        predictedP[1][0] * invS[0][0] + predictedP[1][1] * invS[1][0],
        predictedP[1][0] * invS[0][1] + predictedP[1][1] * invS[1][1],
      ],
      [
        predictedP[2][0] * invS[0][0] + predictedP[2][1] * invS[1][0],
        predictedP[2][0] * invS[0][1] + predictedP[2][1] * invS[1][1],
      ],
      [
        predictedP[3][0] * invS[0][0] + predictedP[3][1] * invS[1][0],
        predictedP[3][0] * invS[0][1] + predictedP[3][1] * invS[1][1],
      ],
    ]

    // x = x + K * y
    this.x = predictedX + K[0][0] * measurementResidualX + K[0][1] * measurementResidualY
    this.y = predictedY + K[1][0] * measurementResidualX + K[1][1] * measurementResidualY

    // In stationary mode, keep velocity at zero
    if (this.stationaryMode) {
      this.vx = 0
      this.vy = 0
    } else {
      this.vx = predictedVx + K[2][0] * measurementResidualX + K[2][1] * measurementResidualY
      this.vy = predictedVy + K[3][0] * measurementResidualX + K[3][1] * measurementResidualY
    }

    // P = (I - K * H) * P
    this.P = [
      [
        predictedP[0][0] - (K[0][0] * predictedP[0][0] + K[0][1] * predictedP[1][0]),
        predictedP[0][1] - (K[0][0] * predictedP[0][1] + K[0][1] * predictedP[1][1]),
        predictedP[0][2] - (K[0][0] * predictedP[0][2] + K[0][1] * predictedP[1][2]),
        predictedP[0][3] - (K[0][0] * predictedP[0][3] + K[0][1] * predictedP[1][3]),
      ],
      [
        predictedP[1][0] - (K[1][0] * predictedP[0][0] + K[1][1] * predictedP[1][0]),
        predictedP[1][1] - (K[1][0] * predictedP[0][1] + K[1][1] * predictedP[1][1]),
        predictedP[1][2] - (K[1][0] * predictedP[0][2] + K[1][1] * predictedP[1][2]),
        predictedP[1][3] - (K[1][0] * predictedP[0][3] + K[1][1] * predictedP[1][3]),
      ],
      [
        predictedP[2][0] - (K[2][0] * predictedP[0][0] + K[2][1] * predictedP[1][0]),
        predictedP[2][1] - (K[2][0] * predictedP[0][1] + K[2][1] * predictedP[1][1]),
        predictedP[2][2] - (K[2][0] * predictedP[0][2] + K[2][1] * predictedP[1][2]),
        predictedP[2][3] - (K[2][0] * predictedP[0][3] + K[2][1] * predictedP[1][3]),
      ],
      [
        predictedP[3][0] - (K[3][0] * predictedP[0][0] + K[3][1] * predictedP[1][0]),
        predictedP[3][1] - (K[3][0] * predictedP[0][1] + K[3][1] * predictedP[1][1]),
        predictedP[3][2] - (K[3][0] * predictedP[0][2] + K[3][1] * predictedP[1][2]),
        predictedP[3][3] - (K[3][0] * predictedP[0][3] + K[3][1] * predictedP[1][3]),
      ],
    ]

    // Process heading data
    let smoothedHeading = position.heading
    if (position.heading !== null && position.heading !== undefined) {
      // Get stable heading from history
      smoothedHeading = this.getStableHeading()

      // If no stable heading yet, use current heading
      if (smoothedHeading === null) {
        smoothedHeading = position.heading
      }

      this.lastHeading = smoothedHeading
    }

    // Calculate speed from velocity components
    const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy)

    return {
      lat: this.y,
      lng: this.x,
      accuracy: position.accuracy,
      heading: smoothedHeading,
      timestamp: position.timestamp,
      speedMPS: this.stationaryMode ? 0 : speed * 111000, // Convert from degrees/second to meters/second (approximate)
    }
  }
}

// Position interpolator for smooth transitions
class PositionInterpolator {
  constructor() {
    this.startPosition = null
    this.targetPosition = null
    this.startTime = null
    this.duration = 0
    this.isActive = false
    this.lastInterpolatedPosition = null
  }

  start(startPos, targetPos, duration) {
    if (!startPos || !targetPos) return

    // Don't interpolate if positions are too close
    const distance = calculateDistance(startPos, targetPos)
    if (distance < 0.1) {
      this.isActive = false
      this.lastInterpolatedPosition = targetPos
      return
    }

    this.startPosition = { ...startPos }
    this.targetPosition = { ...targetPos }
    this.startTime = performance.now()
    this.duration = duration
    this.isActive = true
  }

  update() {
    if (!this.isActive) return this.lastInterpolatedPosition || this.targetPosition

    const now = performance.now()
    const elapsed = now - this.startTime

    if (elapsed >= this.duration) {
      this.isActive = false
      this.lastInterpolatedPosition = this.targetPosition
      return this.targetPosition
    }

    // Calculate progress with easing
    const t = elapsed / this.duration
    const easedT = this.easeOutCubic(t)

    // Interpolate position
    const interpolatedPosition = {
      lat: this.startPosition.lat + (this.targetPosition.lat - this.startPosition.lat) * easedT,
      lng: this.startPosition.lng + (this.targetPosition.lng - this.startPosition.lng) * easedT,
      accuracy: this.targetPosition.accuracy,
      heading: this.targetPosition.heading,
      timestamp: now,
      speedMPS: this.targetPosition.speedMPS,
    }

    this.lastInterpolatedPosition = interpolatedPosition
    return interpolatedPosition
  }

  // Cubic easing function for smoother motion
  easeOutCubic(t) {
    return 1 - Math.pow(1 - t, 3)
  }

  isInterpolating() {
    return this.isActive
  }

  cancel() {
    this.isActive = false
  }

  getLastPosition() {
    return this.lastInterpolatedPosition || this.targetPosition
  }
}

// Create Kalman filter instance
const kalmanFilter = new KalmanFilter()

// Create position interpolator
positionInterpolator = new PositionInterpolator()

// Check if device is in motion based on motion sensors
function isDeviceInMotion() {
  if (!motionSamples || motionSamples.length < 3) {
    return false
  }

  // Calculate average motion magnitude
  const avgMotion =
    motionSamples.reduce((sum, sample) => {
      return sum + Math.sqrt(sample.x * sample.x + sample.y * sample.y + sample.z * sample.z)
    }, 0) / motionSamples.length

  return avgMotion > MOTION_THRESHOLD
}

// Process device motion data
function handleDeviceMotion(event) {
  if (!event || !event.acceleration) return

  const now = Date.now()
  // Throttle motion updates for better performance
  if (now - lastDeviceMotionTimestamp < 50) return
  lastDeviceMotionTimestamp = now

  const motion = {
    x: event.acceleration.x || 0,
    y: event.acceleration.y || 0,
    z: event.acceleration.z || 0,
    timestamp: now,
  }

  // Add to motion samples
  motionSamples.push(motion)

  // Keep only recent samples
  while (motionSamples.length > MOTION_SAMPLE_SIZE) {
    motionSamples.shift()
  }

  // Update device motion state
  deviceMotion = motion

  // Add to device motion buffer for stability detection
  deviceMotionBuffer.push({
    magnitude: Math.sqrt(motion.x * motion.x + motion.y * motion.y + motion.z * motion.z),
    timestamp: now,
  })

  // Keep buffer at reasonable size
  while (deviceMotionBuffer.length > 10) {
    deviceMotionBuffer.shift()
  }

  // Check if device is stable
  isDeviceStable = isDeviceStableFromMotion()

  // Check if device is stationary based on motion
  const inMotion = isDeviceInMotion()

  if (!inMotion) {
    deviceStationaryTime += 50 // Increment by throttle time
  } else {
    deviceStationaryTime = 0
  }
}

// Check if device is stable based on motion buffer
function isDeviceStableFromMotion() {
  if (deviceMotionBuffer.length < 5) return false

  // Calculate average and standard deviation of motion magnitude
  let sum = 0
  let sumSquared = 0

  deviceMotionBuffer.forEach((item) => {
    sum += item.magnitude
    sumSquared += item.magnitude * item.magnitude
  })

  const avg = sum / deviceMotionBuffer.length
  const variance = sumSquared / deviceMotionBuffer.length - avg * avg
  const stdDev = Math.sqrt(variance)

  // Device is stable if standard deviation is low
  return stdDev < 0.3
}

// Process device orientation data
function handleDeviceOrientation(event) {
  if (!event || event.alpha === null) return

  const now = Date.now()
  // Throttle heading updates
  if (now - lastHeadingUpdateTime < headingUpdateInterval) return
  lastHeadingUpdateTime = now

  deviceOrientation = {
    alpha: event.alpha, // z-axis rotation [0,360)
    beta: event.beta, // x-axis rotation [-180,180)
    gamma: event.gamma, // y-axis rotation [-90,90)
    timestamp: now,
  }

  // Update heading buffer if we have a compass heading
  if (event.webkitCompassHeading !== undefined) {
    const heading = event.webkitCompassHeading

    // Add to heading buffer
    headingBuffer.push(heading)

    // Keep only recent headings
    while (headingBuffer.length > 8) {
      headingBuffer.shift()
    }

    // Calculate median heading to filter outliers
    if (headingBuffer.length >= 3) {
      const sortedHeadings = [...headingBuffer].sort((a, b) => a - b)
      lastHeadingValue = sortedHeadings[Math.floor(sortedHeadings.length / 2)]
    }
  }
}

// Request device motion and orientation permissions
function requestMotionPermission() {
  if (typeof DeviceMotionEvent !== "undefined" && typeof DeviceMotionEvent.requestPermission === "function") {
    DeviceMotionEvent.requestPermission()
      .then((response) => {
        if (response === "granted") {
          window.addEventListener("devicemotion", handleDeviceMotion, true)
        }
      })
      .catch(console.error)
  } else {
    window.addEventListener("devicemotion", handleDeviceMotion, true)
  }

  if (typeof DeviceOrientationEvent !== "undefined" && typeof DeviceOrientationEvent.requestPermission === "function") {
    DeviceOrientationEvent.requestPermission()
      .then((response) => {
        if (response === "granted") {
          orientationPermissionGranted = true
          window.addEventListener("deviceorientation", handleDeviceOrientation, true)
        }
      })
      .catch(console.error)
  } else {
    window.addEventListener("deviceorientation", handleDeviceOrientation, true)
    orientationPermissionGranted = true
  }
}

// Animation loop for smooth rendering
function startAnimationLoop() {
  function animate(timestamp) {
    // Calculate delta time
    const deltaTime = renderTimestamp ? (timestamp - renderTimestamp) / 1000 : 0
    renderTimestamp = timestamp

    // Process position updates
    processPositionUpdateQueue()

    // Update interpolated position
    if (positionInterpolator && positionInterpolator.isInterpolating()) {
      const interpolatedPosition = positionInterpolator.update()
      if (interpolatedPosition) {
        // Update marker position
        userMarker.setLatLng([interpolatedPosition.lat, interpolatedPosition.lng])
        lastRenderPosition = interpolatedPosition

        // Update marker rotation if heading is available
        if (interpolatedPosition.heading !== null && interpolatedPosition.heading !== undefined) {
          updateMarkerRotation(interpolatedPosition.heading)
        }
      }
    }

    // Check for recentering based on edge proximity
    if (followUser && !isMapInteracting && Date.now() - lastRecenterCheckTime > recenterCheckInterval) {
      checkAndRecenterMap()
      lastRecenterCheckTime = Date.now()
    }

    // Update zoom level based on speed
    updateDynamicZoom()

    // Request next frame
    animationFrameId = requestAnimationFrame(animate)
  }

  // Start animation loop
  animationFrameId = requestAnimationFrame(animate)
}

// Update marker rotation based on heading
function updateMarkerRotation(heading) {
  const markerElement = userMarker.getElement()
  if (markerElement) {
    const iconElement = markerElement.querySelector(".user-marker-icon")
    if (iconElement) {
      iconElement.style.transform = `rotate(${heading}deg)`
    }
  }
}

// Process position update queue
function processPositionUpdateQueue() {
  if (positionUpdateQueue.length === 0) return

  // Process all updates in queue
  while (positionUpdateQueue.length > 0) {
    const update = positionUpdateQueue.shift()
    processPositionUpdate(update)
  }
}

// Process position update
function processPositionUpdate(position) {
  // Skip if invalid position
  if (!position || typeof position.lat !== "number" || typeof position.lng !== "number") {
    return
  }

  // Update last position
  lastPosition = position

  // Update current speed for zoom calculations
  currentSpeed = position.speedMPS || 0

  // Add to speed samples for zoom calculation
  speedSamples.push(currentSpeed)
  while (speedSamples.length > 5) {
    speedSamples.shift()
  }

  // Update marker class based on stationary state
  const markerElement = userMarker.getElement()
  if (markerElement) {
    if (isStationary) {
      markerElement.classList.add("user-marker-stationary")
    } else {
      markerElement.classList.remove("user-marker-stationary")
    }
  }

  // Start interpolation to new position
  if (lastRenderPosition && !isFirstPositionUpdate) {
    // Calculate appropriate animation duration based on movement and stationary state
    let animDuration = isStationary ? 400 : ANIMATION_DURATION

    // For very small movements when stationary, use longer duration for stability
    if (isStationary) {
      const distance = calculateDistance(lastRenderPosition, position)
      if (distance < 0.5) {
        animDuration = 600 // Slower for tiny movements when stationary
      }
    }

    positionInterpolator.start(lastRenderPosition, position, animDuration)
  } else {
    // First update, just set position directly
    userMarker.setLatLng([position.lat, position.lng])
    lastRenderPosition = position
    isFirstPositionUpdate = false
  }

  // Update marker rotation if heading is available
  if (position.heading !== null && position.heading !== undefined) {
    updateMarkerRotation(position.heading)
  }

  // Auto-recenter map if following user
  if (followUser && !isMapInteracting) {
    checkAndRecenterMap()
  }
}

// Calculate distance between two points using Haversine formula
function calculateDistance(pos1, pos2) {
  if (
    !pos1 ||
    !pos2 ||
    typeof pos1.lat !== "number" ||
    typeof pos1.lng !== "number" ||
    typeof pos2.lat !== "number" ||
    typeof pos2.lng !== "number"
  ) {
    return Number.POSITIVE_INFINITY
  }

  const R = 6371000 // Earth's radius in meters
  const lat1 = (pos1.lat * Math.PI) / 180
  const lat2 = (pos2.lat * Math.PI) / 180
  const deltaLat = ((pos2.lat - pos1.lat) * Math.PI) / 180
  const deltaLng = ((pos2.lng - pos1.lng) * Math.PI) / 180

  const a =
    Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) +
    Math.cos(lat1) * Math.cos(lat2) * Math.sin(deltaLng / 2) * Math.sin(deltaLng / 2)
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))

  return R * c
}

// Calculate edge proximity to map bounds
function calculateEdgeProximity(map, point) {
  const bounds = map.getBounds()
  const latSpan = bounds.getNorth() - bounds.getSouth()
  const lngSpan = bounds.getEast() - bounds.getWest()

  return {
    north: Math.abs(point.lat - bounds.getNorth()) / latSpan,
    south: Math.abs(point.lat - bounds.getSouth()) / latSpan,
    east: Math.abs(point.lng - bounds.getEast()) / lngSpan,
    west: Math.abs(point.lng - bounds.getWest()) / lngSpan,
  }
}

// Check if marker is near edge of map
function isMarkerNearEdge(map, marker, isStrict = false) {
  const bounds = map.getBounds()
  const point = marker.getLatLng()
  const proximities = calculateEdgeProximity(map, point)

  const thresholdPercentage = isStrict ? STRICT_EDGE_THRESHOLD_PERCENTAGE : EDGE_THRESHOLD_PERCENTAGE

  const edges = {
    north: proximities.north < thresholdPercentage,
    south: proximities.south < thresholdPercentage,
    east: proximities.east < thresholdPercentage,
    west: proximities.west < thresholdPercentage,
  }

  return {
    isNearEdge: Object.values(edges).some((edge) => edge),
    edges: edges,
    proximities: proximities,
  }
}

// Calculate optimal center point for map view
function calculateOptimalCenter(map, markerPosition, edgeInfo) {
  const bounds = map.getBounds()

  let latOffset = 0
  let lngOffset = 0

  // Basic edge offset
  if (edgeInfo.edges.north) latOffset = -1 * (bounds.getNorth() - bounds.getSouth()) * 0.2
  if (edgeInfo.edges.south) latOffset = (bounds.getNorth() - bounds.getSouth()) * 0.2
  if (edgeInfo.edges.east) lngOffset = -1 * (bounds.getEast() - bounds.getWest()) * 0.2
  if (edgeInfo.edges.west) lngOffset = (bounds.getEast() - bounds.getWest()) * 0.2

  // If user is moving fast, offset center point in direction of movement
  if (
    lastPosition &&
    lastPosition.speedMPS > SPEED_RECENTER_THRESHOLD &&
    lastPosition.heading !== null &&
    lastPosition.heading !== undefined
  ) {
    // Calculate offset factor based on speed
    const speedFactor = Math.min(
      1.0,
      (lastPosition.speedMPS - SPEED_RECENTER_THRESHOLD) / (DRIVING_SPEED_THRESHOLD - SPEED_RECENTER_THRESHOLD),
    )

    // Convert heading to radians
    const headingRad = (lastPosition.heading * Math.PI) / 180

    // Calculate additional offset in direction of movement
    const additionalLatOffset =
      Math.cos(headingRad) * RECENTER_OFFSET_FACTOR * speedFactor * (bounds.getNorth() - bounds.getSouth())
    const additionalLngOffset =
      Math.sin(headingRad) * RECENTER_OFFSET_FACTOR * speedFactor * (bounds.getEast() - bounds.getWest())

    latOffset += additionalLatOffset
    lngOffset += additionalLngOffset
  }

  return {
    lat: markerPosition.lat + latOffset,
    lng: markerPosition.lng + lngOffset,
  }
}

// Determine if map should recenter
function shouldRecenter(map, marker) {
  const now = Date.now()
  if (now - lastRecenterTime < RECENTER_COOLDOWN) {
    return { needsRecenter: false }
  }

  const edgeInfo = isMarkerNearEdge(map, marker)
  const proximities = edgeInfo.proximities

  const isCritical = Object.values(proximities).some((proximity) => proximity < CRITICAL_EDGE_THRESHOLD_PERCENTAGE)

  if (isCritical) {
    lastRecenterTime = now
    return {
      needsRecenter: true,
      isEmergency: true,
      edgeInfo: edgeInfo,
    }
  }

  if (edgeInfo.isNearEdge) {
    lastRecenterTime = now
    return {
      needsRecenter: true,
      isEmergency: false,
      edgeInfo: edgeInfo,
    }
  }

  return {
    needsRecenter: false,
    isEmergency: false,
    edgeInfo: edgeInfo,
  }
}

// Check and recenter map if needed
function checkAndRecenterMap() {
  if (!userMarker || !map || !followUser || isMapInteracting) return

  const recenterInfo = shouldRecenter(map, userMarker)
  if (recenterInfo.needsRecenter) {
    const optimalCenter = calculateOptimalCenter(map, userMarker.getLatLng(), recenterInfo.edgeInfo)

    // Use smooth animation for non-emergency recenters
    map.setView([optimalCenter.lat, optimalCenter.lng], map.getZoom(), {
      animate: true,
      duration: recenterInfo.isEmergency ? 0.2 : 0.5,
      noMoveStart: true,
    })
  }
}

// Calculate optimal zoom level based on speed
function calculateOptimalZoom(speed) {
  // Default to walking zoom level
  if (speed === undefined || speed === null) {
    return DEFAULT_ZOOM_LEVEL
  }

  // Stationary or very slow
  if (speed < 0.5) {
    return MAX_ZOOM_LEVEL
  }
  // Walking speed
  else if (speed < WALKING_SPEED_THRESHOLD) {
    return DEFAULT_ZOOM_LEVEL
  }
  // Running speed
  else if (speed < RUNNING_SPEED_THRESHOLD) {
    return DEFAULT_ZOOM_LEVEL - 1
  }
  // Driving speed
  else if (speed < DRIVING_SPEED_THRESHOLD) {
    return DEFAULT_ZOOM_LEVEL - 2
  }
  // High speed
  else if (speed < HIGH_SPEED_THRESHOLD) {
    return DEFAULT_ZOOM_LEVEL - 3
  }
  // Very high speed
  else {
    return MIN_ZOOM_LEVEL
  }
}

// Update zoom level based on speed
function updateDynamicZoom() {
  const now = Date.now()
  if (now - lastZoomUpdateTime < ZOOM_UPDATE_INTERVAL) return
  lastZoomUpdateTime = now

  // Skip if user is interacting with map
  if (isMapInteracting || userIsInteracting) return

  // Calculate average speed from samples
  let avgSpeed = 0
  if (speedSamples.length > 0) {
    avgSpeed = speedSamples.reduce((sum, speed) => sum + speed, 0) / speedSamples.length
  } else if (lastPosition) {
    avgSpeed = lastPosition.speedMPS || 0
  }

  // Smooth speed changes
  const smoothedSpeed = lastSpeedForZoom * 0.7 + avgSpeed * 0.3
  lastSpeedForZoom = smoothedSpeed

  // Calculate optimal zoom level
  const optimalZoom = calculateOptimalZoom(smoothedSpeed)

  // Only update if zoom level needs to change
  if (Math.abs(optimalZoom - targetZoomLevel) >= 0.1) {
    targetZoomLevel = optimalZoom

    // Apply zoom change with smooth animation
    if (map && followUser) {
      const currentZoom = map.getZoom()
      const zoomDiff = Math.abs(currentZoom - targetZoomLevel)

      // Use faster transition for larger zoom changes
      const duration = zoomDiff > 1 ? 0.3 : ZOOM_TRANSITION_DURATION

      map.setZoom(targetZoomLevel, {
        animate: true,
        duration: duration,
        noMoveStart: true,
      })
    }
  }
}

// Main function to update user location
function updateUserLocation(position, forceUpdate = false) {
  // Validate input position
  if (!position?.coords) {
    console.warn("Invalid position data received")
    return
  }

  const currentTime = Date.now()

  // Throttle updates for performance
  if (!forceUpdate && currentTime - lastPositionUpdateTime < positionUpdateThrottle) {
    return
  }
  lastPositionUpdateTime = currentTime

  const timeDelta = lastUpdateTime ? (currentTime - lastUpdateTime) / 1000 : 0

  // Create position object
  const newPosition = {
    lat: position.coords.latitude,
    lng: position.coords.longitude,
    accuracy: position.coords.accuracy || 20,
    heading: position.coords.heading !== null ? position.coords.heading : lastHeadingValue || undefined,
    timestamp: currentTime,
    speedMPS: position.coords.speed !== null ? position.coords.speed : 0,
  }

  if (isNaN(newPosition.lat) || isNaN(newPosition.lng)) {
    console.warn("Invalid coordinates received")
    return
  }

  // Store raw position for comparison
  lastRawPosition = newPosition

  // Track accuracy trend
  if (lastAccuracy !== null) {
    accuracyTrend.push(newPosition.accuracy - lastAccuracy)
    while (accuracyTrend.length > 5) accuracyTrend.shift()
  }
  lastAccuracy = newPosition.accuracy

  // First position initialization
  if (!lastPosition) {
    lastPosition = newPosition
    userMarker.setLatLng([newPosition.lat, newPosition.lng])
    kalmanFilter.reset(newPosition)
    lastUpdateTime = currentTime
    stationaryStartTime = currentTime
    positionBuffer = [newPosition]
    lastStationaryPosition = newPosition
    lastRenderPosition = newPosition
    return
  }

  // Calculate distance from last position
  const distance = calculateDistance(lastPosition, newPosition)

  // Handle large position changes or forced updates
  if (distance > EXTENDED_DISTANCE_THRESHOLD || forceUpdate) {
    if (stationaryCheckTimeout) {
      clearTimeout(stationaryCheckTimeout)
      stationaryCheckTimeout = null
    }
    isStationary = false
    stationaryStartTime = null
    stationaryCount = 0
    stationaryPositionHistory = []
    lastStationaryPosition = null
    consecutiveStationaryUpdates = 0

    // Reset tracking variables
    userMarker.setLatLng([newPosition.lat, newPosition.lng])
    lastPosition = newPosition
    lastRenderPosition = newPosition
    positionBuffer = [newPosition]
    kalmanFilter.reset(newPosition)
    kalmanFilter.setStationaryMode(false)
    lastVelocity = { lat: 0, lng: 0 }

    // Cancel any active interpolation
    if (positionInterpolator) {
      positionInterpolator.cancel()
    }

    lastUpdateTime = currentTime
    lastUpdateTimestamp = currentTime
    updateDistanceBox()
    return
  }

  // Skip updates with poor accuracy or unrealistic movement
  if (
    !forceUpdate &&
    (newPosition.accuracy > MAX_ACCEPTABLE_ACCURACY || (timeDelta > 0 && distance / timeDelta > 50)) // Max speed check (50 m/s)
  ) {
    console.debug("Skipping update due to poor accuracy or unrealistic movement")
    return
  }

  try {
    // Check if device is in motion based on motion sensors
    const motionDetected = deviceMotion && isDeviceInMotion()

    // Enhanced stationary detection
    if (distance < MICRO_MOVEMENT_THRESHOLD && (!motionDetected || deviceStationaryTime > STATIONARY_TIME_THRESHOLD)) {
      stationaryCount++
      consecutiveStationaryUpdates++

      if (!isStationary && stationaryCount >= STATIONARY_THRESHOLD) {
        isStationary = true
        console.log("User is now stationary")

        // Set Kalman filter to stationary mode
        kalmanFilter.setStationaryMode(true)

        // Update marker class
        const markerElement = userMarker.getElement()
        if (markerElement) {
          markerElement.classList.add("user-marker-stationary")
        }

        // Calculate stable position from buffer
        const stablePosition = calculateStationaryPosition(positionBuffer)
        if (stablePosition) {
          // Add to position update queue
          positionUpdateQueue.push(stablePosition)
          lastPosition = stablePosition
          lastStationaryPosition = stablePosition
        }

        if (stationaryCheckTimeout) clearTimeout(stationaryCheckTimeout)
        stationaryCheckTimeout = setTimeout(() => checkStationaryState(newPosition), STATIONARY_CHECK_INTERVAL)

        updateDistanceBox()
        return
      }
    } else {
      stationaryCount = Math.max(0, stationaryCount - 1)
      consecutiveStationaryUpdates = 0
      if (isStationary && stationaryCount < STATIONARY_THRESHOLD / 2) {
        isStationary = false
        kalmanFilter.setStationaryMode(false)

        // Update marker class
        const markerElement = userMarker.getElement()
        if (markerElement) {
          markerElement.classList.remove("user-marker-stationary")
        }

        console.log("User is moving again")
      }
    }

    // Apply Kalman filter with motion detection
    const filteredPosition = kalmanFilter.update(newPosition, motionDetected)

    // Update position buffer
    updatePositionBuffer(filteredPosition)

    // Apply different smoothing based on movement state
    let finalPosition

    if (isStationary) {
      // When stationary, use the stable position with minimal updates
      if (lastStationaryPosition) {
        // Only update if accuracy significantly improves or after several updates
        if (newPosition.accuracy < lastStationaryPosition.accuracy * 0.8 || consecutiveStationaryUpdates > 5) {
          // Update stationary position history
          updateStationaryHistory(filteredPosition)

          // Calculate new stable position
          const stablePosition = calculateStationaryPosition(positionBuffer)
          if (stablePosition) {
            // Smooth transition to new stable position
            finalPosition = {
              lat: lerp(lastStationaryPosition.lat, stablePosition.lat, 0.1),
              lng: lerp(lastStationaryPosition.lng, stablePosition.lng, 0.1),
              accuracy: stablePosition.accuracy,
              heading: stablePosition.heading,
              timestamp: currentTime,
              speedMPS: 0,
            }

            // Add to position update queue
            positionUpdateQueue.push(finalPosition)
            lastPosition = finalPosition
            lastStationaryPosition = finalPosition
            consecutiveStationaryUpdates = 0
          } else {
            finalPosition = lastStationaryPosition
          }
        } else {
          // Use existing stable position
          finalPosition = lastStationaryPosition
        }
      } else {
        // If no stable position yet, calculate one
        const stablePosition = calculateStationaryPosition(positionBuffer)
        if (stablePosition) {
          finalPosition = stablePosition
          lastStationaryPosition = stablePosition

          // Add to position update queue
          positionUpdateQueue.push(finalPosition)
        } else {
          finalPosition = filteredPosition

          // Add to position update queue
          positionUpdateQueue.push(finalPosition)
        }
        lastPosition = finalPosition
      }
    } else {
      // Smooth movement when active
      finalPosition = filteredPosition

      // Apply heading-based prediction for smoother movement
      if (finalPosition.heading !== undefined && finalPosition.speedMPS > 0.5) {
        const predictedPosition = predictPositionFromHeading(
          finalPosition,
          finalPosition.heading,
          finalPosition.speedMPS * 0.3, // Predict slightly ahead
        )

        // Blend predicted and filtered positions
        finalPosition = {
          lat: lerp(finalPosition.lat, predictedPosition.lat, 0.2),
          lng: lerp(finalPosition.lng, predictedPosition.lng, 0.2),
          accuracy: finalPosition.accuracy,
          heading: finalPosition.heading,
          timestamp: finalPosition.timestamp,
          speedMPS: finalPosition.speedMPS,
        }
      }

      // Add to position update queue
      positionUpdateQueue.push(finalPosition)
      lastPosition = finalPosition
    }

    lastUpdateTime = currentTime
    lastUpdateTimestamp = currentTime
    updateDistanceBox()
  } catch (error) {
    console.error("Location update error:", error)
    // Fallback with basic filtering
    userMarker.setLatLng([newPosition.lat, newPosition.lng])
    lastPosition = newPosition
    lastRenderPosition = newPosition
    updateDistanceBox()
  }
}

function calculateStationaryPosition(buffer) {
  if (!buffer || buffer.length === 0) {
    return null
  }
  // Sort by accuracy (best first)
  const sortedBuffer = [...buffer].sort((a, b) => a.accuracy - b.accuracy)
  // Take weighted average of best positions
  const topPositions = sortedBuffer.slice(0, Math.ceil(buffer.length / 2))
  const weights = topPositions.map((pos) => 1 / Math.max(1, pos.accuracy))
  const totalWeight = weights.reduce((sum, w) => sum + w, 0)
  if (totalWeight === 0) {
    return sortedBuffer[0]
  }
  // Calculate weighted average
  const avgPosition = {
    lat: topPositions.reduce((sum, pos, i) => sum + pos.lat * weights[i], 0) / totalWeight,
    lng: topPositions.reduce((sum, pos, i) => sum + pos.lng * weights[i], 0) / totalWeight,
    accuracy: topPositions[0].accuracy,
    heading: topPositions[0].heading,
    timestamp: Date.now(),
    speedMPS: 0,
  }
  // If we have a previous stationary position, blend with it for stability
  if (lastStationaryPosition) {
    const blendFactor = 0.85 // 85% previous, 15% new for extreme stability
    return {
      lat: lastStationaryPosition.lat * blendFactor + avgPosition.lat * (1 - blendFactor),
      lng: lastStationaryPosition.lng * blendFactor + avgPosition.lng * (1 - blendFactor),
      accuracy: avgPosition.accuracy,
      heading: avgPosition.heading,
      timestamp: avgPosition.timestamp,
      speedMPS: 0
    };
  }
  return avgPosition
}

// Update stationary position history
function updateStationaryHistory(position) {
  // Add new position to history
  stationaryPositionHistory.push(position)

  // Keep history at maximum size
  while (stationaryPositionHistory.length > STATIONARY_POSITION_HISTORY_SIZE) {
    stationaryPositionHistory.shift()
  }

  // Calculate weighted average of positions
  let totalWeight = 0
  let weightedLat = 0
  let weightedLng = 0

  // Newer positions have higher weight
  for (let i = 0; i < stationaryPositionHistory.length; i++) {
    const pos = stationaryPositionHistory[i]
    const weight = Math.pow(STATIONARY_POSITION_WEIGHT_DECAY, stationaryPositionHistory.length - i - 1)
    totalWeight += weight
    weightedLat += pos.lat * weight
    weightedLng += pos.lng * weight
  }

  return {
    lat: weightedLat / totalWeight,
    lng: weightedLng / totalWeight,
    accuracy: position.accuracy,
    heading: position.heading,
    timestamp: position.timestamp,
    speedMPS: 0,
  }
}

// Update position buffer with new position
function updatePositionBuffer(position) {
  if (!position || typeof position.lat !== "number" || typeof position.lng !== "number") {
    return
  }

  // Add new position to buffer
  positionBuffer.push({
    lat: position.lat,
    lng: position.lng,
    accuracy: position.accuracy,
    heading: position.heading,
    timestamp: position.timestamp,
    speedMPS: position.speedMPS,
  })

  // Remove old positions if buffer exceeds maxSize
  while (positionBuffer.length > MAX_BUFFER_SIZE) {
    positionBuffer.shift()
  }
}

// Check if user is stationary
function checkStationaryState(newPosition) {
  if (!lastPosition) return

  const distance = calculateDistance(lastPosition, newPosition)

  if (distance >= MICRO_MOVEMENT_THRESHOLD) {
    isStationary = false
    stationaryStartTime = null
    console.debug("Movement detected, resuming normal updates")

    // Update Kalman filter stationary mode
    kalmanFilter.setStationaryMode(false)

    // Update marker class
    const markerElement = userMarker.getElement()
    if (markerElement) {
      markerElement.classList.remove("user-marker-stationary")
    }
  }

  if (stationaryCheckTimeout) {
    clearTimeout(stationaryCheckTimeout)
    stationaryCheckTimeout = null
  }

  if (isStationary) {
    stationaryCheckTimeout = setTimeout(() => checkStationaryState(newPosition), STATIONARY_CHECK_INTERVAL)
  }
}

// Predict position based on heading and speed
function predictPositionFromHeading(position, heading, distance) {
  // Input validation
  if (
    !position ||
    typeof heading !== "number" ||
    typeof distance !== "number" ||
    !position.lat ||
    !position.lng ||
    isNaN(heading) ||
    isNaN(distance)
  ) {
    return position
  }

  // Normalize heading to 0-360 range
  heading = ((heading % 360) + 360) % 360

  // Earth's radius in meters
  const R = 6371e3

  // Convert to radians
  const d = distance / R
  const  = (heading * Math.PI) / 180
  const 1 = (position.lat * Math.PI) / 180
  const 1 = (position.lng * Math.PI) / 180

  // Calculate predicted position with error handling
  try {
    const sin1 = Math.sin(1)
    const cos1 = Math.cos(1)
    const cosd = Math.cos(d)
    const sind = Math.sin(d)
    const cos = Math.cos()

    const 2 = Math.asin(sin1 * cosd + cos1 * sind * cos)

    const 2 = 1 + Math.atan2(Math.sin() * sind * cos1, cosd - sin1 * Math.sin(2))

    // Convert back to degrees with bounds checking
    const newLat = Math.max(-90, Math.min(90, (2 * 180) / Math.PI))
    const newLng = (((2 * 180) / Math.PI + 540) % 360) - 180

    return {
      lat: newLat,
      lng: newLng,
    }
  } catch (error) {
    // Fallback to original position if calculation fails
    return position
  }
}

// Linear interpolation helper
function lerp(a, b, t) {
  if (typeof a !== "number" || typeof b !== "number" || typeof t !== "number") {
    return a
  }

  return a + (b - a) * Math.max(0, Math.min(1, t))
}

// Handle position updates from geolocation API
function handlePositionUpdate(position) {
  if (!position?.coords?.latitude || !position?.coords?.longitude) {
    console.warn("Invalid position data received")
    return
  }

  const currentTime = Date.now()
  if (currentTime - lastUpdateTime >= 100 && !isPopupOpen()) {
    updateUserLocation(position)
    lastUpdateTime = currentTime
  }
}

// Start position updates with high frequency
function startPositionUpdates() {
  navigator.geolocation.watchPosition(handlePositionUpdate, handleLocationError, {
    enableHighAccuracy: true,
    maximumAge: 0,
    timeout: 10000,
  })
}

// Initialize map with enhanced settings
function initMap() {
  // Check if L is defined. If not, it means Leaflet library is not loaded.
  if (typeof L === "undefined") {
    console.error("Leaflet library is not loaded. Please ensure Leaflet is properly included in your HTML.")
    return // Exit the function if Leaflet is not loaded
  }

  map = L.map("map", {
    zoomControl: false,
    attributionControl: false,
    zoomSnap: 0.1,
    zoomDelta: 0.5,
    wheelDebounceTime: 100,
    tapTolerance: 15,
    bounceAtZoomLimits: false,
    preferCanvas: true, // Use canvas renderer for better performance
    renderer: L.canvas({ padding: 0.5 }),
  }).fitWorld()

  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    maxZoom: 19,
    attribution: " OpenStreetMap contributors",
    updateWhenIdle: true,
    updateWhenZooming: false,
    keepBuffer: 2,
  }).addTo(map)

  // Create user icon with custom styling for direction indication
  const userIcon = L.divIcon({
    className: "user-marker",
    html: '<div class="user-marker-icon"></div>',
    iconSize: [20, 20],
    iconAnchor: [10, 10],
  })

  userMarker = L.marker([0, 0], {
    icon: userIcon,
    zIndexOffset: 1000, // Ensure user marker is on top
    interactive: false, // Prevent marker from being clickable
  }).addTo(map)

  // Add CSS for direction indicator
  const style = document.createElement("style")
  style.textContent = `
        .user-marker-icon {
            width: 20px;
            height: 20px;
            background-color: #005f9e;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
            position: relative;
            transition: transform 0.2s ease-out;
        }
        .user-marker-icon:after {
            content: '';
            position: absolute;
            top: -4px;
            left: 50%;
            margin-left: -4px;
            width: 0;
            height: 0;
            border-left: 4px solid transparent;
            border-right: 4px solid transparent;
            border-bottom: 8px solid white;
            transform-origin: center bottom;
        }
        .user-marker-stationary .user-marker-icon {
            background-color: #3388ff;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
    `
  document.head.appendChild(style)

  // Show preloader
  showPreloader()

  // Request motion and orientation permissions
  requestMotionPermission()

  if ("geolocation" in navigator) {
    const options = {
      enableHighAccuracy: true,
      timeout: 45000,
      maximumAge: 0,
    }

    // Try first time
    navigator.geolocation.getCurrentPosition(
      initializeUserLocation,
      (error) => {
        // On error, try one more time before falling back
        navigator.geolocation.getCurrentPosition(initializeUserLocation, handleLocationError, options)
      },
      options,
    )
  } else {
    showPopup("Geolocation is not supported by your browser")
    map.setView([44.9778, -93.265], 18)
    hidePreloader()
  }

  document.addEventListener("visibilitychange", handleVisibilityChange)

  map.on("movestart zoomstart", () => {
    followUser = false
    isMapInteracting = true
    userIsInteracting = true
  })

  map.on("moveend zoomend", () => {
    isMapInteracting = false
    userIsInteracting = false
    resetInactivityTimer()
  })

  // Start animation loop for smooth rendering
  startAnimationLoop()

  // Enable touch interactions
  map.touchZoom.enable()
  map.doubleClickZoom.enable()
}

// Add recenter button functionality
function recenterMap() {
  const recenterButton = document.getElementById("recenterButton")
  if (recenterButton) {
    recenterButton.style.backgroundColor = "#005f9e"
    recenterButton.style.color = "white"
    if (userMarker && userMarker.getLatLng()) {
      map.setView(userMarker.getLatLng(), targetZoomLevel)
      followUser = true
    }
    setTimeout(() => {
      recenterButton.style.backgroundColor = "white"
      recenterButton.style.color = "#005f9e"
    }, 500)
  }
}

// Show preloader
function showPreloader() {
  const preloader = document.getElementById("preloader")
  if (preloader) preloader.style.display = "flex"
}

// Hide preloader
function hidePreloader() {
  const preloader = document.getElementById("preloader")
  if (preloader) preloader.style.display = "none"
}

// Show popup
function showPopup(message) {
  const popup = document.getElementById("popup")
  const popupMessage = document.getElementById("popupMessage")

  if (popup && popupMessage) {
    popupMessage.textContent = message
    popup.style.display = "flex"
  } else {
    alert(message) // Fallback if popup elements don't exist
  }
}

// Check if popup is open
function isPopupOpen() {
  const popup = document.getElementById("popup")
  return popup ? popup.style.display === "flex" : false
}

// Handle location errors
function handleLocationError(error) {
  console.error("Geolocation error:", error)
  hidePreloader()

  let message = "Unable to access your location. "

  switch (error.code) {
    case error.PERMISSION_DENIED:
      message += "Please enable location services for this website."
      break
    case error.POSITION_UNAVAILABLE:
      message += "Location information is unavailable."
      break
    case error.TIMEOUT:
      message += "The request to get your location timed out."
      break
    default:
      message += "An unknown error occurred."
  }

  showPopup(message)
}

// Initialize user location
function initializeUserLocation(position) {
  if (!position?.coords) {
    handleLocationError({ code: 2, message: "Invalid position data" })
    return
  }

  try {
    const initialPosition = {
      lat: position.coords.latitude,
      lng: position.coords.longitude,
      accuracy: position.coords.accuracy || 20,
      heading: position.coords.heading,
      timestamp: Date.now(),
      speedMPS: position.coords.speed || 0,
    }

    // Set initial marker position
    userMarker.setLatLng([initialPosition.lat, initialPosition.lng])

    // Initialize Kalman filter
    kalmanFilter.reset(initialPosition)

    // Set map view
    map.setView([initialPosition.lat, initialPosition.lng], DEFAULT_ZOOM_LEVEL)

    // Initialize tracking variables
    lastPosition = initialPosition
    lastRenderPosition = initialPosition
    lastUpdateTime = Date.now()
    lastUpdateTimestamp = Date.now()

    // Start position updates
    startPositionUpdates()

    // Hide preloader
    hidePreloader()

    // Update distance box if it exists
    updateDistanceBox()

    console.log("Location initialized successfully")
  } catch (error) {
    console.error("Error initializing location:", error)
    handleLocationError({ code: 2, message: "Error initializing location" })
  }
}

// Reset inactivity timer
function resetInactivityTimer() {
  if (inactivityTimer) {
    clearTimeout(inactivityTimer)
  }

  inactivityTimer = setTimeout(() => {
    if (!isMapInteracting && !userIsInteracting) {
      followUser = true
      if (userMarker && userMarker.getLatLng()) {
        map.setView(userMarker.getLatLng(), targetZoomLevel)
      }
    }
  }, INACTIVITY_TIMEOUT)
}

// Handle visibility change
function handleVisibilityChange() {
  if (document.hidden) {
    lastHiddenTime = Date.now()
  } else {
    const hiddenDuration = Date.now() - lastHiddenTime
    if (hiddenDuration > BACKGROUND_THRESHOLD) {
      // App was in background for significant time, reset tracking
      if (userMarker && lastPosition) {
        // Force position update
        updateUserLocation(
          {
            coords: {
              latitude: lastPosition.lat,
              longitude: lastPosition.lng,
              accuracy: lastPosition.accuracy,
              heading: lastPosition.heading,
              speed: lastPosition.speedMPS,
            },
          },
          true,
        )
      }
    }
  }
}

// Update distance box
function updateDistanceBox() {
  // Implementation depends on your UI
  const distanceBox = document.getElementById("distanceBox")
  if (distanceBox && lastPosition) {
    // Update distance information if needed
  }
}

// Wait for DOM to be fully loaded before initializing
document.addEventListener("DOMContentLoaded", () => {
  // Initialize map only when DOM is ready
  initMap()

  // Add event listeners for UI elements
  const recenterButton = document.getElementById("recenterButton")
  if (recenterButton) {
    recenterButton.addEventListener("click", recenterMap)
  }

  // Initialize inactivity timer
  resetInactivityTimer()
})

console.log("Kalman filter optimized with dynamic zoom and improved recentering")
    </script>
   </body>
</html>
