<!DOCTYPE html>
<html lang="en">
<head> 
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Minnesota Then | Museum Without Walls</title>
    <link rel="shortcut icon" type="image/x-icon" href="https://www.mnthen.com/images/mnthenfav.ico">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css">
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css" />

    <link rel="stylesheet" href="https://www.mnthen.com/css/mainmap.css">
    <link rel="stylesheet" href="https://www.mnthen.com/css/mnthen_main_map2.css">
    
</head>
<body>
        <!-- Map -->
        <div id="map"></div>
        <div id="distanceBox">Initializing...</div>

        <!-- Location Hunt Container -->
        <div class="lochunt-container">
            <img id="locationImage" src="/placeholder.svg" alt="Location Image">
            <div class="lochunt-content">
                <div class="lochunt-info">
                    <h2 id="locationTitle" class="mb-2 text-primary"></h2>
                    <p id="locationCity" class="text-muted mb-1"></p>
                    <p id="locationCreator" class="text-muted mb-3"></p>
                </div>
                <div class="audio-player">
                    <div class="audio-progress">
                        <div class="progress">
                            <div id="progressBar" class="progress-bar" role="progressbar" style="width: 0%"></div>
                        </div>
                    </div>
                    <div class="audio-time">
                        <span id="currentTime">0:00</span>
                        <span id="duration">0:00</span>
                    </div>
                    <div class="audio-controls">
                        <button id="rewindBtn" class="audio-button"><i class="fas fa-backward"></i></button>
                        <button id="playPauseBtn" class="audio-button"><i class="fas fa-play"></i></button>
                        <button id="forwardBtn" class="audio-button"><i class="fas fa-forward"></i></button>
                    </div>
                    <audio id="locationAudio" src="/placeholder.svg"></audio>
                </div>
            </div>
        </div>

        <!-- Additional Info Container -->
        <div class="additional-info-container">
            <h3 class="mb-3 text-primary text-center">Did You Know?</h3>
            <p id="additionalInfo" class="mb-3 fs-6"></p>
            <div class="d-flex justify-content-center">
                <button id="continueButton" class="btn btn-primary">Continue</button>
            </div>
        </div>
        
        <!-- Map Buttons -->
        <div class="map-buttons">
            <button id="recenterButton" class="map-button"><i class="fas fa-crosshairs"></i></button>
            <button id="returnButton" class="map-button"><i class="fas fa-sign-out-alt"></i></button>
            <button id="tipsButton" class="map-button"><i class="fas fa-question-circle"></i></button>
        </div>

        <!-- Navigation Tips -->
        <div class="navigation-tips">
            <button class="close-button">&times;</button>
            <h3 style="color: darkblue; text-align: center;">Navigation Tips</h3>
            <ul>
                <li>Use the map to navigate to the marked locations.</li>
                <li>Tap the recenter button to focus on your current position.</li>
                <li>The distance box shows how far you are from the closest location.</li>
                <li>When you're within 20 feet of a location, you'll be able to interact with it.</li>
                <li>Listen to the audio information for each location.</li>
                <li>After the audio, you'll see additional information about the location.</li>
            </ul>
        </div>

        <!-- Summary Modal -->
        <div id="summaryModal" class="modal">
            <div class="modal-content">
                <p id="summaryContent"></p>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"></script>
    <script src="/locations_test.js?v=1.0.4"></script>

    <script>
    // Global variables
    let map, userMarker, markerClusterGroup;
    let tracking;
    let currentLocationIndex = 0;
    let visitedLocations = [];
    let gameLocations = [];
    let isLocationHuntVisible = false;
    let lastPosition = null;
    let positionBuffer = [];
    let filteredPosition = null;
    let followUser = true;
    let locationCooldowns = {};
    let lastVisitedLocationId = null;
    let lastKnownPosition = null;
    let isTransitioning = false;
    let lastVelocity = { lat: 0, lng: 0 };
    let isMapInteracting = false;
    let isStationary = false;
    let stationaryStartTime = null;
    let stationaryCheckTimeout = null;
    let lastUpdateTime = null;
    let lastUpdateTimestamp = null;
    let stationaryBuffer = [];
    let stationaryPosition = null;
    let stationaryCount = 0;
    let lastSmoothedPosition = null;
    let lastHiddenTime = 0;
    let retryCount = 0;
    let inactivityTimer;
    let animationFrameId = null;
    let proximityState = {
        isNearLocation: false,
        lastZoomChangeTime: 0,
        lastProximityCheck: 0,
        zoomTransitionInProgress: false
    };
    let speedZoomState = {
        lowSpeedStartTime: null,
        isInTransit: false,
        lastSignificantMove: Date.now(),
        destinationArrivalTime: null,
        previousZoom: null,
        lastSpeedBasedZoom: 17,
        lastZoomUpdateTime: 0
    };

    // Configuration constants
    const DISTANCE_THRESHOLD = 20; // should be 20 feet
    const MAX_BUFFER_SIZE = 5;
    const MAX_ACCEPTABLE_ACCURACY = 39; // meters
    const BACKGROUND_THRESHOLD = 25000; // ms
    const INACTIVITY_TIMEOUT = 29000; // ms
    const UPDATE_INTERVAL = 50; // ms
    const MICRO_MOVEMENT_THRESHOLD = 0.3; // meters
    const STATIONARY_ACCURACY_MULTIPLIER = 1.1;
    const MAX_SPEED = 50; // m/s
    const MIN_DISTANCE_THRESHOLD = 2; // meters
    const VELOCITY_DECAY = 0.8;
    const BEARING_WEIGHT = 0.3;
    const SMOOTHING_FACTOR = 0.3;
    const EXTENDED_DISTANCE_THRESHOLD = 100; // meters
    const STATIONARY_THRESHOLD = 2;
    const STATIONARY_TIME_THRESHOLD = 5000; // ms
    const STATIONARY_CHECK_INTERVAL = 2500; // ms
    const STATIONARY_SMOOTHING = 0.95;
    const STATIONARY_BUFFER_SIZE = 10;
    const STATIONARY_ACCURACY_WEIGHT = 0.7;
    const STATIONARY_THRESHOLDB = 3;
    const MAX_ALPHA = 0.2;
    const MIN_ALPHA = 0.025;
    const MAX_RETRIES = 3;
    const RETRY_DELAY = 1000; // ms
    const EDGE_THRESHOLD_PERCENTAGE = 0.25;
    const STRICT_EDGE_THRESHOLD_PERCENTAGE = 0.15;
    const CRITICAL_EDGE_THRESHOLD_PERCENTAGE = 0.07;
    const MAX_ACCURACY_THRESHOLD = 2500;
    const TARGET_ACCURACY_THRESHOLD = 100;
    const MIN_RECENTER_INTERVAL = 2000; // ms

    const SPEED_ZOOM_THRESHOLDS = [
        { speed: 35, zoom: 14 }, // Highway speeds
        { speed: 25, zoom: 15 }, // Major roads
        { speed: 15, zoom: 16 }, // Urban driving
        { speed: 0, zoom: 17 }   // Walking speed or stationary
    ];
        
    const BASE_PROCESS_NOISE = 0.01; // Base process noise for Kalman filter
    const MAP_UPDATE_INTERVAL = 500; // Milliseconds between map view updates
    const POSITION_UPDATE_THRESHOLD = 20; // Meters of movement that triggers a map update
    let lastMapUpdateTime = 0; // Track when we last updated the map view

    // Proximity zoom constants - optimized for better performance
    const PROXIMITY_THRESHOLD = 50; // 50 feet trigger
    const PROXIMITY_EXIT_THRESHOLD = 65; // 65 feet to exit (hysteresis)
    const BASE_ZOOM = 17;           // Default zoom level 
    const CLOSE_ZOOM = 18;          // Zoom when within threshold
    const ZOOM_COOLDOWN = 2000;     // 2 seconds between zoom changes (reduced from 3s)
    const PROXIMITY_CHECK_INTERVAL = 1000; // Check proximity every 1 second

    // Initialize map and core functionality
    function initMap() {
        // Create map with optimized settings
        map = L.map('map', {
            zoomControl: false,
            attributionControl: false,
            zoomSnap: 0.1,
            zoomDelta: 0.5,
            wheelDebounceTime: 100,
            tapTolerance: 15,
            bounceAtZoomLimits: false,
            preferCanvas: true, // Better performance for many markers
            renderer: L.canvas()
        }).fitWorld();

        // Add tile layer with performance optimizations
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 18,
            attribution: 'Â© OpenStreetMap contributors',
            updateWhenIdle: true,
            updateWhenZooming: false,
            keepBuffer: 2
        }).addTo(map);

        // Initialize marker cluster group with custom styling
        markerClusterGroup = L.markerClusterGroup({
            showCoverageOnHover: false,
            zoomToBoundsOnClick: true,
            spiderfyOnMaxZoom: true,
            animate: true,
            animateAddingMarkers: true,
            chunkedLoading: true,
            chunkProgress: updateLoadingStatus,
            maxClusterRadius: function(zoom) {
                return zoom > 16 ? 40 : 80; // Adaptive clustering based on zoom
            },
            iconCreateFunction: function(cluster) {
                return L.divIcon({
                    html: '<div><span>' + cluster.getChildCount() + '</span></div>',
                    className: 'marker-cluster-custom',
                    iconSize: L.point(40, 40)
                });
            }
        });
        map.addLayer(markerClusterGroup);

        // Create user location marker
        const userIcon = L.divIcon({
            className: 'user-marker',
            html: '<div class="user-marker-icon"></div>',
            iconSize: [20, 20],
            iconAnchor: [10, 10]
        });
        userMarker = L.marker([0, 0], { icon: userIcon, zIndexOffset: 1000 }).addTo(map);
        
        showLoadingMessage();

        // Initialize geolocation with fallback
        if ("geolocation" in navigator) {
            const options = {
                enableHighAccuracy: true,
                timeout: 45000,
                maximumAge: 0
            };

            // Try to get initial position with retry
            navigator.geolocation.getCurrentPosition(
                initializeUserLocation,
                (error) => {
                    // On error, try one more time before falling back
                    navigator.geolocation.getCurrentPosition(
                        initializeUserLocation,
                        handleLocationError,
                        options
                    );
                },
                options
            );
        } else {
            showPopup("Geolocation Error", "Geolocation is not supported by your browser");
            map.setView([44.9778, -93.2650], 17); // Default to Minneapolis
            hideLoadingMessage();
        }
        
        // Set up event listeners
        document.addEventListener('visibilitychange', handleVisibilityChange);

        map.on('movestart zoomstart', () => {
            followUser = false;
            isMapInteracting = true;
        });

        map.on('moveend zoomend', () => {
            isMapInteracting = false;
            resetInactivityTimer();
        });

        // Enable touch interactions
        map.touchZoom.enable();
        map.doubleClickZoom.enable();
    }

function updateLoadingStatus(processed, total, elapsed) {
        if (processed === total) {
            // All markers loaded
            console.log(`Loaded ${processed} markers in ${elapsed.toFixed(2)}ms`);
        }
    }

// Global variable to prevent premature dismissal
let loadingMessageMinDisplayTime = 0;

function showLoadingMessage() {
    const existingMessage = document.getElementById('loadingMessage');
    if (existingMessage) return;
    
    // Set the minimum display time to 8 seconds from now
    loadingMessageMinDisplayTime = Date.now() + 8000;
    
    // Create main container with background image
    const loadingMessage = document.createElement('div');
    loadingMessage.id = 'loadingMessage';
    loadingMessage.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        background-image: url('https://raw.githubusercontent.com/mreicher/MNThen/refs/heads/main/images/splash_screen.webp');
        background-size: cover;
        background-position: center;
        z-index: 1000;
        font-family: 'Segoe UI', 'Roboto', 'Arial', sans-serif;
        transition: opacity 0.5s ease;
    `;
    
    // Create content container with improved contrast against the background
    const contentContainer = document.createElement('div');
    contentContainer.style.cssText = `
        display: flex;
        flex-direction: column;
        align-items: center;
        background-color: white;
        padding: clamp(20px, 5vw, 40px);
        border-radius: 16px;
        box-shadow: 0 15px 40px rgba(0, 0, 0, 0.25);
        width: clamp(280px, 85%, 500px);
        text-align: center;
    `;
    
    // Create image with responsive sizing
    const logoImage = document.createElement('img');
    logoImage.src = 'https://mnthen.com/images/logo.webp';
    logoImage.style.cssText = `
        width: clamp(120px, 60%, 250px);
        height: auto;
        margin-bottom: clamp(15px, 4vw, 25px);
        border-radius: 8px;
        object-fit: contain;
    `;
    
    // Create welcome message with improved typography
    const welcomeMessage = document.createElement('h2');
    welcomeMessage.style.cssText = `
        margin: 0 0 clamp(8px, 2vw, 15px) 0;
        font-size: clamp(20px, 5vw, 26px);
        font-weight: 600;
        color: #002855;
        text-align: center;
        line-height: 1.3;
        letter-spacing: -0.01em;
    `;
    welcomeMessage.textContent = 'Every Step Tells A Story';
    
    // Create status text with improved styling
    const statusText = document.createElement('p');
    statusText.id = 'loadingStatusText';
    statusText.style.cssText = `
        margin: 0 0 clamp(15px, 4vw, 25px) 0;
        font-size: clamp(14px, 4vw, 16px);
        font-weight: 400;
        text-align: center;
        color: #0066cc;
        line-height: 1.5;
    `;
    statusText.textContent = 'Location found, proceeding to stabilization...';
    
    // Create progress bar container with improved styling
    const progressContainer = document.createElement('div');
    progressContainer.style.cssText = `
        width: 100%;
        height: 6px;
        background-color: rgba(0, 51, 102, 0.1);
        border-radius: 8px;
        overflow: hidden;
        margin-top: 5px;
    `;
    
    // Improved progress bar with animation
    const progressBar = document.createElement('div');
    progressBar.id = 'loadingProgressBar';
    progressBar.style.cssText = `
        height: 100%;
        width: 0%;
        background: linear-gradient(90deg, #0066cc, #0099ff);
        border-radius: 8px;
        transition: width 0.2s ease-out;
        box-shadow: 0 0 8px rgba(0, 102, 204, 0.5);
    `;
    
    progressContainer.appendChild(progressBar);
    
    // Assemble and add to document
    contentContainer.appendChild(logoImage);
    contentContainer.appendChild(welcomeMessage);
    contentContainer.appendChild(statusText);
    contentContainer.appendChild(progressContainer);
    loadingMessage.appendChild(contentContainer);
    document.body.appendChild(loadingMessage);
    
    // Set animation parameters
    const totalDuration = 10000;
    const updateInterval = 100;
    const steps = totalDuration / updateInterval;
    let progress = 0;
    
    // Text animations to improve perceived performance
    const animations = [
        "Initializing map data...",
        "Processing location coordinates...",
        "Preparing exhibit data...",
        "Calibrating view perspective...",
        "Loading nearby points of interest...",
        "Finalizing your experience..."
    ];
    
    // Animate progress bar over 10 seconds with status text updates
    const progressInterval = setInterval(() => {
        progress += (100 / steps);
        
        if (progressBar) {
            progressBar.style.width = `${Math.min(progress, 100)}%`;
        }
        
        // Update status text periodically
        if (statusText) {
            const animationIndex = Math.min(
                Math.floor(progress / (100 / animations.length)),
                animations.length - 1
            );
            statusText.textContent = animations[animationIndex];
        }
        
        if (progress >= 100) {
            clearInterval(progressInterval);
            tryHideLoadingMessage();
        }
    }, updateInterval);
    
    // Store the interval ID
    loadingMessage.dataset.progressInterval = progressInterval;
}

function tryHideLoadingMessage() {
    // Only fade out if minimum display time has been reached
    if (Date.now() >= loadingMessageMinDisplayTime) {
        fadeOutLoadingMessage();
    } else {
        // Schedule another check for when the minimum time is reached
        const timeRemaining = loadingMessageMinDisplayTime - Date.now();
        setTimeout(fadeOutLoadingMessage, timeRemaining + 100); // Add a small buffer
    }
}

function fadeOutLoadingMessage() {
    const loadingMessage = document.getElementById('loadingMessage');
    if (!loadingMessage) return;
    
    // Clear any ongoing timers
    if (loadingMessage.dataset.progressInterval) {
        clearInterval(parseInt(loadingMessage.dataset.progressInterval));
    }
    
    // Complete progress bar if not already complete
    const progressBar = document.getElementById('loadingProgressBar');
    if (progressBar) {
        progressBar.style.width = '100%';
    }
    
    // Fade out and remove
    loadingMessage.style.opacity = '0';
    setTimeout(() => {
        if (loadingMessage && loadingMessage.parentNode) {
            loadingMessage.parentNode.removeChild(loadingMessage);
        }
    }, 500); // 500ms fade-out transition
}

// Public API function to hide loading message (respects minimum display time)
function hideLoadingMessage() {
    tryHideLoadingMessage();
}

function initializeUserLocation(position) {
    console.log("Initial position data:", JSON.stringify(position));

    if (!position || !position.coords) {
        console.error("Invalid initial position object");
        handleLocationError(new Error("Invalid initial position"));
        return;
    }

    const { latitude: userLat, longitude: userLng, accuracy } = position.coords;

    if (isNaN(userLat) || isNaN(userLng)) {
        console.error("Invalid initial coordinates:", { userLat, userLng });
        handleLocationError(new Error("Invalid initial coordinates"));
        return;
    }

    console.log("Valid initial position:", { userLat, userLng, accuracy });

    try {
        userMarker.setLatLng([userLat, userLng]);
        map.setView([userLat, userLng], 19);
        
        // Initialize Kalman filter with first position
        kalmanFilter.reset({
            lat: userLat,
            lng: userLng,
            accuracy: accuracy || 20
        });
        
        hideLoadingMessage();
        startPositionUpdates();
        startHunt();
        
        // Pulse the distance box to draw attention
        const distanceBox = document.getElementById('distanceBox');
        distanceBox.classList.add('pulse');
        setTimeout(() => distanceBox.classList.remove('pulse'), 3000);
    } catch (error) {
        console.error("Error setting initial user location:", error);
        handleLocationError(error);
    }
}

function startPositionUpdates() {
    // Store the watch ID to allow stopping if needed
    const watchId = navigator.geolocation.watchPosition(
        handlePositionUpdate,
        handleLocationError,
        {
            enableHighAccuracy: true,
            maximumAge: 1000,
            timeout: 10000
        }
    );
    
    // Optional: Store watchId for later use (to stop tracking)
    window.positionWatchId = watchId;
    
    // Add error recovery mechanism
    window.addEventListener('online', () => {
        // If connection was lost and restored, restart position tracking
        if (window.positionWatchId) {
            navigator.geolocation.clearWatch(window.positionWatchId);
            window.positionWatchId = navigator.geolocation.watchPosition(
                handlePositionUpdate,
                handleLocationError,
                {
                    enableHighAccuracy: true,
                    maximumAge: 1000,
                    timeout: 10000
                }
            );
        }
    });
    
    // Start periodic proximity checks
    startProximityChecks();
    
    // Return the watchId for external use
    return watchId;
}

function startProximityChecks() {
    // Clear any existing interval
    if (window.proximityCheckInterval) {
        clearInterval(window.proximityCheckInterval);
    }
    
    // Set up periodic proximity checks
    window.proximityCheckInterval = setInterval(() => {
        if (!isMapInteracting && followUser) {
            checkProximityForZoom();
        }
    }, PROXIMITY_CHECK_INTERVAL);
}

function handlePositionUpdate(position) {
    // Validate position data
    if (!position || !position.coords || 
        isNaN(position.coords.latitude) || 
        isNaN(position.coords.longitude)) {
        console.warn("Invalid position data received");
        return;
    }
    
    // Add timestamp validation to prevent processing outdated positions
    const positionTimestamp = position.timestamp || new Date().getTime();
    const currentTime = new Date().getTime();
    const maxAgeMs = 30000; // 30 seconds
    
    if (currentTime - positionTimestamp > maxAgeMs) {
        console.warn("Position data too old, ignoring");
        return;
    }
    
    // Update accuracy information
    const accuracy = position.coords.accuracy || 0;
    window.lastPositionAccuracy = accuracy;
    
    // Store last valid position for recovery purposes
    window.lastValidPosition = {
        lat: position.coords.latitude,
        lng: position.coords.longitude,
        timestamp: positionTimestamp,
        accuracy: accuracy
    };
    
    // Process valid position update (keeping original functionality)
    updateUserLocation(position);
}
        
    function handleVisibilityChange() {
        if (document.hidden) {
            lastHiddenTime = Date.now();
            lastKnownPosition = userMarker ? userMarker.getLatLng() : null;
        } else {
            const hiddenDuration = Date.now() - lastHiddenTime;
            if (hiddenDuration > BACKGROUND_THRESHOLD) {
                updateLocationAfterBackground();
            } else {
                // Just refresh the map size
                map.invalidateSize();
            }
        }
        resetInactivityTimer();
    }

function updateLocationAfterBackground() {
    if (!("geolocation" in navigator)) {
        console.warn("Geolocation is not available");
        return;
    }
    
    // First try with cached position to get quick response
    const quickOptions = {
        enableHighAccuracy: false,
        timeout: 5000,
        maximumAge: 60000,  // Use a position from last minute if available
    };
    
    // Then try with high accuracy
    const accurateOptions = {
        enableHighAccuracy: true,
        timeout: 15000,
        maximumAge: 30000,
    };
    
    // Final fallback with very permissive settings
    const fallbackOptions = {
        enableHighAccuracy: false,
        timeout: 25000,
        maximumAge: 120000, // Accept positions up to 2 minutes old
    };

    const handleSuccess = (position) => {
        console.log("Background update raw position:", JSON.stringify(position));
        
        if (!position?.coords) {
            console.warn("Invalid position object in background update");
            return;
        }
        const { latitude, longitude, accuracy } = position.coords;
        if (isNaN(latitude) || isNaN(longitude)) {
            console.warn("Invalid coordinates in background update:", { latitude, longitude });
            return;
        }
        console.log("Valid background position update:", { lat: latitude, lng: longitude });
        
        try {
            updateUserLocation(position, true);
            
            // Reset tracking state
            lastPosition = null;
            positionBuffer = [];
            velocity = { lat: 0, lng: 0 };
            lastVelocity = { lat: 0, lng: 0 };
            isStationary = false;
            stationaryStartTime = null;
            stationaryCount = 0;
            stationaryPositionHistory = [];
            lastStationaryPosition = null;
            stationaryPositionLocked = false;
            positionHistory = [];
            suddenMovementCount = 0;
            isJumpDetected = false;
            // Reset Kalman filter
            kalmanFilter.reset({
                lat: latitude,
                lng: longitude,
                accuracy: accuracy,
                heading: position.coords.heading || 0,
                timestamp: Date.now(),
            });
            // Restart animation if needed
            if (!animationFrameId) {
                startAnimationLoop();
            }
            // Restart GeolocationSensor if using it
            if (usingGeolocationSensorAPI && geolocationSensor) {
                geolocationSensor.start();
            }
            updateDistanceBox();
            followUser = true;
            map.invalidateSize();
        } catch (error) {
            console.error("Error in updateUserLocation during background update:", error);
        }
    };
    
    const handleError = (error, stage) => {
        console.error(`Error getting location during ${stage} attempt:`, error);
        
        switch (error.code) {
            case error.PERMISSION_DENIED:
                console.warn("User denied geolocation access");
                break;
                
            case error.POSITION_UNAVAILABLE:
                if (stage === "quick") {
                    console.log("Quick position unavailable, trying accurate position...");
                    navigator.geolocation.getCurrentPosition(
                        handleSuccess,
                        (err) => handleError(err, "accurate"),
                        accurateOptions
                    );
                } else if (stage === "accurate") {
                    console.log("Accurate position unavailable, trying fallback...");
                    navigator.geolocation.getCurrentPosition(
                        handleSuccess,
                        (err) => handleError(err, "fallback"),
                        fallbackOptions
                    );
                } else {
                    console.warn("All position attempts failed - location unavailable");
                }
                break;
                
            case error.TIMEOUT:
                if (stage === "quick") {
                    console.log("Quick position timed out, trying accurate position...");
                    navigator.geolocation.getCurrentPosition(
                        handleSuccess,
                        (err) => handleError(err, "accurate"),
                        accurateOptions
                    );
                } else if (stage === "accurate") {
                    console.log("Accurate position timed out, trying fallback...");
                    navigator.geolocation.getCurrentPosition(
                        handleSuccess,
                        (err) => handleError(err, "fallback"),
                        fallbackOptions
                    );
                } else {
                    console.warn("All position attempts timed out");
                }
                break;
                
            default:
                if (stage !== "fallback") {
                    console.log("Unknown error, trying fallback options...");
                    navigator.geolocation.getCurrentPosition(
                        handleSuccess,
                        (err) => handleError(err, "fallback"),
                        fallbackOptions
                    );
                } else {
                    console.warn("All position attempts failed with unknown error");
                }
        }
    };

    // Start with quick attempt to get position
    navigator.geolocation.getCurrentPosition(
        handleSuccess,
        (error) => handleError(error, "quick"),
        quickOptions
    );
}

    // Kalman filter implementation for position smoothing
    const kalmanFilter = {
        x: { estimate: 0, error: 1 },
        y: { estimate: 0, error: 1 },
        q: 0.015, // Process noise
        r: 1,     // Measurement noise
        
        update: function(measurement) {
            // Initialize if first measurement
            if (this.x.estimate === 0 && this.y.estimate === 0) {
                this.x.estimate = measurement.lng;
                this.y.estimate = measurement.lat;
                return measurement;
            }
            
            // X coordinate (longitude)
            const predX = this.x.estimate;
            const predErrX = this.x.error + this.q;
            const gainX = predErrX / (predErrX + this.r);
            this.x.estimate = predX + gainX * (measurement.lng - predX);
            this.x.error = (1 - gainX) * predErrX;
            
            // Y coordinate (latitude)
            const predY = this.y.estimate;
            const predErrY = this.y.error + this.q;
            const gainY = predErrY / (predErrY + this.r);
            this.y.estimate = predY + gainY * (measurement.lat - predY);
            this.y.error = (1 - gainY) * predErrY;
            
            return {
                lat: this.y.estimate,
                lng: this.x.estimate,
                accuracy: measurement.accuracy,
                timestamp: measurement.timestamp,
                heading: measurement.heading,
                speedMPS: measurement.speedMPS
            };
        },
        
        reset: function(measurement) {
            this.x.estimate = measurement.lng;
            this.y.estimate = measurement.lat;
            this.x.error = 1;
            this.y.error = 1;
        }
    };

    function updatePositionBuffer(position) {
        // Add new position to buffer
        positionBuffer.push({
            lat: position.lat,
            lng: position.lng,
            accuracy: position.accuracy,
            timestamp: position.timestamp,
            heading: position.heading,
            speedMPS: position.speedMPS
        });

        // Remove old positions if buffer exceeds maxSize
        while (positionBuffer.length > MAX_BUFFER_SIZE) {
            positionBuffer.shift();
        }
    }

    function calculateWeightedPosition(positions, smoothingFactor = 0.8) {
        if (!Array.isArray(positions) || positions.length === 0) {
            return null;
        }

        // Filter out invalid positions
        const validPositions = positions.filter(pos => 
            pos && typeof pos.lat === 'number' && typeof pos.lng === 'number' && 
            !isNaN(pos.lat) && !isNaN(pos.lng)
        );

        if (validPositions.length === 0) {
            return null;
        }

        let sumLat = 0, sumLng = 0, totalWeight = 0;

        for (let i = 0; i < validPositions.length; i++) {
            const position = validPositions[i];
            const weight = Math.pow(smoothingFactor, validPositions.length - i - 1);
            sumLat += position.lat * weight;
            sumLng += position.lng * weight;
            totalWeight += weight;
        }

        const result = {
            lat: sumLat / totalWeight,
            lng: sumLng / totalWeight,
            accuracy: Math.min(...validPositions.map(p => p.accuracy || 20)),
            timestamp: validPositions[validPositions.length - 1].timestamp,
            heading: validPositions[validPositions.length - 1].heading,
            speedMPS: validPositions[validPositions.length - 1].speedMPS
        };

        return result;
    }

// OPTIMIZED: Completely rewritten proximity zoom function with better performance
function checkProximityForZoom() {
    // Ensure we have all required objects and values
    if (!userMarker || !map || !gameLocations || !Array.isArray(gameLocations) || gameLocations.length === 0) {
        return;
    }
    
    // Initialize proximityState if needed
    if (!proximityState) {
        proximityState = {
            lastProximityCheck: 0,
            lastZoomChangeTime: 0,
            isNearLocation: false,
            zoomTransitionInProgress: false
        };
    }
    
    // Rate limit checks
    const now = Date.now();
    if (now - (proximityState.lastProximityCheck || 0) < 500) {
        return;
    }
    proximityState.lastProximityCheck = now;
    
    // Don't run during user interactions or transitions
    if (isMapInteracting || proximityState.zoomTransitionInProgress) {
        return;
    }
    
    // Get and validate user position
    const userPos = userMarker.getLatLng();
    if (!userPos || typeof userPos.lat !== 'number' || typeof userPos.lng !== 'number') {
        return;
    }
    
    // Find closest location efficiently
    let closestDistance = Infinity;
    
    for (let i = 0; i < gameLocations.length; i++) {
        const loc = gameLocations[i];
        if (!loc || typeof loc.lat !== 'number' || typeof loc.lng !== 'number') {
            continue;
        }
        
        // Fast approximate distance check first
        const latDiff = userPos.lat - loc.lat;
        const lngDiff = userPos.lng - loc.lng;
        const quickDistSquared = latDiff * latDiff + lngDiff * lngDiff;
        
        // If potentially closer than current best, do accurate calculation
        if (quickDistSquared < closestDistance / 69000) {
            const dist = calculateDistance(userPos, loc);
            if (dist < closestDistance) {
                closestDistance = dist;
            }
        }
    }
    
    // Convert to feet for threshold comparison
    const distanceFeet = closestDistance * 3.28084;
    
    // Handle entering proximity zone
    if (!proximityState.isNearLocation && distanceFeet <= PROXIMITY_THRESHOLD) {
        if (now - (proximityState.lastZoomChangeTime || 0) >= ZOOM_COOLDOWN) {
            proximityState.isNearLocation = true;
            proximityState.lastZoomChangeTime = now;
            
            if (followUser !== false) {
                proximityState.zoomTransitionInProgress = true;
                
                // Use setView instead of flyTo to avoid rubber banding
                map.setView([userPos.lat, userPos.lng], CLOSE_ZOOM, {
                    animate: true,
                    duration: 0.8,
                    noMoveStart: true
                });
                
                setTimeout(() => {
                    proximityState.zoomTransitionInProgress = false;
                }, 1000);
            }
        }
    } 
    // Handle exiting proximity zone
    else if (proximityState.isNearLocation && distanceFeet >= PROXIMITY_EXIT_THRESHOLD) {
        if (now - (proximityState.lastZoomChangeTime || 0) >= ZOOM_COOLDOWN) {
            proximityState.isNearLocation = false;
            proximityState.lastZoomChangeTime = now;
            
            if (followUser !== false) {
                proximityState.zoomTransitionInProgress = true;
                
                // Use setView instead of flyTo to avoid rubber banding
                map.setView([userPos.lat, userPos.lng], BASE_ZOOM, {
                    animate: true,
                    duration: 0.8,
                    noMoveStart: true
                });
                
                setTimeout(() => {
                    proximityState.zoomTransitionInProgress = false;
                }, 1000);
            }
        }
    }
}
        
// OPTIMIZED: Completely rewritten speed-based zoom function with better performance
function getSpeedBasedZoom(speedMPS) {
    // Get current time for time-based calculations
    const now = Date.now();
    
    // Convert speed to mph for easier human-readable thresholds
    const speedMPH = speedMPS * 2.23694;
    
    // Constants
    const WALKING_THRESHOLD = 3.0;  // mph
    const SIGNIFICANT_TRAVEL_THRESHOLD = 10.0; // mph
    const TEMPORARY_STOP_MAX = 90000; // 90 seconds
    const ARRIVAL_DELAY = 20000; // 20 seconds
    const ZOOM_UPDATE_THRESHOLD = 1000; // ms between zoom updates
    
    // State tracking
    const state = speedZoomState;
    
    // Throttle updates to avoid excessive zoom changes
    if (now - state.lastZoomUpdateTime < ZOOM_UPDATE_THRESHOLD) {
        return state.lastSpeedBasedZoom;
    }
    
    // Update state tracking time
    state.lastZoomUpdateTime = now;
    
    // Detect when we're truly in transit vs. just temporary stops
    if (speedMPH >= SIGNIFICANT_TRAVEL_THRESHOLD) {
        state.isInTransit = true;
        state.lastSignificantMove = now;
        state.destinationArrivalTime = null;
        state.lowSpeedStartTime = null;
    }
    
    // Handle low speed/walking/stopping with improved logic
    if (speedMPH <= WALKING_THRESHOLD) {
        if (!state.lowSpeedStartTime) {
            state.lowSpeedStartTime = now;
        }
        
        const lowSpeedDuration = now - state.lowSpeedStartTime;
        
        // Have we been in transit and now stopping for more than the arrival delay?
        if (state.isInTransit && lowSpeedDuration >= ARRIVAL_DELAY) {
            // If we've been stopped long enough, consider it a destination arrival
            if (!state.destinationArrivalTime) {
                state.destinationArrivalTime = now;
            }
            
            // We've arrived at destination - set zoom to 17
            if (now - state.destinationArrivalTime >= 5000) {
                state.isInTransit = false; // Reset transit state
                state.lastSpeedBasedZoom = 17;
                return 17;
            }
        }
        
        // For temporary stops during active travel, maintain previous zoom
        if (state.isInTransit && now - state.lastSignificantMove < TEMPORARY_STOP_MAX) {
            return state.lastSpeedBasedZoom || 17;
        }
        
        // Walking or stationary gets zoom level 17
        state.lastSpeedBasedZoom = 17;
        return 17;
    } else {
        // Reset low speed tracking when moving faster than walking
        state.lowSpeedStartTime = null;
        state.destinationArrivalTime = null;
    }
    
    // Optimized speed-based zoom logic with binary search for larger threshold arrays
    let zoom = 17; // Default zoom
    
    // For our small array, a simple loop is still efficient
    for (const threshold of SPEED_ZOOM_THRESHOLDS) {
        if (speedMPH >= threshold.speed) {
            zoom = threshold.zoom;
            break;
        }
    }
    
    state.lastSpeedBasedZoom = zoom;
    return zoom;
}
        
// Validates if a position object contains valid coordinates and accuracy data
function isValidPosition(position) {
    // Check basic structure
    if (!position || typeof position !== 'object') return false;
    
    // Determine which format we're dealing with
    const isGeolocationFormat = position.coords && typeof position.coords === 'object';
    const coords = isGeolocationFormat ? position.coords : position;
    
    // Get lat/lng values depending on format
    const lat = isGeolocationFormat ? coords.latitude : coords.lat;
    const lng = isGeolocationFormat ? coords.longitude : coords.lng;
    const accuracy = coords.accuracy;
    
    // Validate essential coordinates
    const hasValidCoordinates = 
        Number.isFinite(lat) && 
        Number.isFinite(lng) &&
        lat >= -90 && lat <= 90 && 
        lng >= -180 && lng <= 180;
        
    if (!hasValidCoordinates) return false;
    
    // If accuracy is provided, validate it
    if ('accuracy' in coords && !Number.isFinite(accuracy)) return false;
    
    // If timestamp is provided, validate it's a reasonable value
    if ('timestamp' in position) {
        const timestamp = Number(position.timestamp);
        if (!Number.isFinite(timestamp) || timestamp <= 0) return false;
    }
    
    return true;
}

    function applyExponentialSmoothing(newPosition, lastPosition, baseAlpha = 0.25) {
        // Validate inputs
        if (!isValidPosition(newPosition) || !isValidPosition(lastPosition)) {
            return newPosition;
        }

        // Initialize lastSmoothedPosition if it doesn't exist
        if (!lastSmoothedPosition) {
            lastSmoothedPosition = lastPosition;
        }

        const distance = calculateDistance(newPosition, lastSmoothedPosition);
        
        // Enhanced stationary detection
        if (distance < MIN_DISTANCE_THRESHOLD) {
            stationaryCount = Math.min(stationaryCount + 1, STATIONARY_THRESHOLD);
        } else {
            stationaryCount = Math.max(stationaryCount - 1, 0);
        }

        // Calculate adaptive alpha
        let alpha = baseAlpha;

        // Adjust alpha based on movement state
        if (stationaryCount >= STATIONARY_THRESHOLD) {
            alpha = MIN_ALPHA;
        } else {
            // Gradually reduce alpha as we approach stationary state
            alpha = MAX_ALPHA - (stationaryCount / STATIONARY_THRESHOLD) * (MAX_ALPHA - MIN_ALPHA);
        }

        // Accuracy-based adjustment
        const accuracyRatio = Math.max(0, Math.min(1, 1 - (newPosition.accuracy / MAX_ACCEPTABLE_ACCURACY)));
        alpha = alpha * (0.5 + 0.5 * accuracyRatio);

        // Speed-based adjustment
        if (newPosition.speedMPS !== undefined && newPosition.speedMPS < 0.5) {
            alpha *= 0.4; // Extra smoothing at very low speeds
        }

        // Time-based adjustment to handle GPS jitter
        const timeDelta = newPosition.timestamp - lastPosition.timestamp;
        if (timeDelta < 1000) { // If updates are very frequent
            alpha *= 0.7; // Reduce impact of rapid updates
        }

        // Apply smoothing with weighted factors
        const smoothedPosition = {
            lat: lastSmoothedPosition.lat + alpha * (newPosition.lat - lastSmoothedPosition.lat),
            lng: lastSmoothedPosition.lng + alpha * (newPosition.lng - lastSmoothedPosition.lng),
            accuracy: Math.min(newPosition.accuracy, lastSmoothedPosition.accuracy),
            heading: newPosition.heading,
            timestamp: newPosition.timestamp,
            speedMPS: newPosition.speedMPS ? 
                      lastSmoothedPosition.speedMPS * 0.7 + newPosition.speedMPS * 0.3 : // Smooth speed changes
                      newPosition.speedMPS
        };

        // Apply additional smoothing to heading when stationary
        if (stationaryCount >= STATIONARY_THRESHOLD && lastSmoothedPosition.heading !== undefined) {
            smoothedPosition.heading = alpha * newPosition.heading + (1 - alpha) * lastSmoothedPosition.heading;
        }

        // Additional stabilization for very small movements
        if (distance < MIN_DISTANCE_THRESHOLD * 0.5) {
            smoothedPosition.lat = lastSmoothedPosition.lat * 0.95 + smoothedPosition.lat * 0.05;
            smoothedPosition.lng = lastSmoothedPosition.lng * 0.95 + smoothedPosition.lng * 0.05;
        }

        // Update last smoothed position
        lastSmoothedPosition = smoothedPosition;

        return smoothedPosition;
    }

    function calculateVelocityFilter(newPos, lastPos) {
        if (!lastVelocity) {
            lastVelocity = { lat: 0, lng: 0 };
        }

        if (!newPos || !lastPos || 
            typeof newPos.lat !== 'number' || typeof newPos.lng !== 'number' || 
            typeof lastPos.lat !== 'number' || typeof lastPos.lng !== 'number') {
            return newPos;
        }

        const dt = (newPos.timestamp - lastPos.timestamp) / 1000;
        if (dt <= 0 || dt > 10) {
            return newPos;
        }

        const currentVelocity = {
            lat: (newPos.lat - lastPos.lat) / dt,
            lng: (newPos.lng - lastPos.lng) / dt
        };

        lastVelocity = {
            lat: lastVelocity.lat * VELOCITY_DECAY + currentVelocity.lat * (1 - VELOCITY_DECAY),
            lng: lastVelocity.lng * VELOCITY_DECAY + currentVelocity.lng * (1 - VELOCITY_DECAY)
        };

        // Apply velocity prediction
        return {
            lat: lastPos.lat + lastVelocity.lat * dt,
            lng: lastPos.lng + lastVelocity.lng * dt,
            accuracy: newPos.accuracy,
            timestamp: newPos.timestamp,
            heading: newPos.heading,
            speedMPS: newPos.speedMPS
        };
    }

    function checkStationaryState(newPosition) {
        if (!lastPosition) return;
        
        const distance = calculateDistance(lastPosition, newPosition);
        
        if (distance >= MICRO_MOVEMENT_THRESHOLD) {
            isStationary = false;
            stationaryStartTime = null;
            console.debug("Movement detected, resuming normal updates");
        }
        
        if (stationaryCheckTimeout) {
            clearTimeout(stationaryCheckTimeout);
            stationaryCheckTimeout = null;
        }
        
        if (isStationary) {
            stationaryCheckTimeout = setTimeout(() => checkStationaryState(newPosition), STATIONARY_CHECK_INTERVAL);
        }
    }

    function calculateFinalPosition() {
        // If buffer is empty, return null
        if (positionBuffer.length === 0) {
            return null;
        }
        
        // If only one position in buffer, return it
        if (positionBuffer.length === 1) {
            return positionBuffer[0];
        }
        
        // Calculate weighted average of positions in buffer
        return calculateWeightedPosition(positionBuffer);
    }

    function updateMarkerAndMap(position, speedMPS) {
        if (!position || typeof position.lat !== 'number' || typeof position.lng !== 'number') {
            console.warn("Invalid position for marker update");
            return;
        }
        
        // Update marker position with animation
        userMarker.setLatLng([position.lat, position.lng], { animate: true, duration: 0.3 });
        
        // Check if we need to recenter map based on user position
        if (followUser && !isMapInteracting) {
            const recenterInfo = shouldRecenter(map, userMarker);
            
            if (recenterInfo.needsRecenter) {
                const newCenter = recenterInfo.isEmergency ? 
                    [position.lat, position.lng] : 
                    calculateOptimalCenter(map, position, recenterInfo.edgeInfo);
                    
                map.panTo(newCenter, {
                    animate: true,
                    duration: recenterInfo.isEmergency ? 0.1 : 0.5,
                    easeLinearity: 0.5
                });
            }
            
            // Adjust zoom based on speed if needed
            const zoomLevel = getSpeedBasedZoom(speedMPS);
            if (zoomLevel !== -1 && Math.abs(map.getZoom() - zoomLevel) > 0.5) {
                map.setZoom(zoomLevel, { animate: true, duration: 1 });
            }
        }
        
        // Update distance box
        updateDistanceBox();
    }

function updateUserLocation(position, forceUpdate = false) {
  // Validate input position
  if (!position?.coords?.latitude || !position?.coords?.longitude) {
    console.warn("Invalid position data received");
    return;
  }

  // Cancel any pending animation frame
  if (animationFrameId !== null) {
    cancelAnimationFrame(animationFrameId);
    animationFrameId = null;
  }

  const currentTime = Date.now();
  const timeDelta = lastUpdateTime ? (currentTime - lastUpdateTime) / 1000 : 0;

  const newPosition = {
    lat: position.coords.latitude,
    lng: position.coords.longitude,
    accuracy: position.coords.accuracy || 20,
    heading: position.coords.heading ?? null,
    timestamp: currentTime,
    speedMPS: position.coords.speed || 0
  };

  // First position initialization
  if (!lastPosition) {
    lastPosition = newPosition;
    userMarker.setLatLng([newPosition.lat, newPosition.lng]);
    kalmanFilter.reset(newPosition);
    lastUpdateTime = currentTime;
    stationaryStartTime = currentTime;
    positionBuffer = [newPosition];
    
    const zoomLevel = getSpeedBasedZoom(newPosition.speedMPS);
    if (zoomLevel !== -1) {
      map.setZoom(zoomLevel, { animate: false });
    }
    map.setView([newPosition.lat, newPosition.lng], map.getZoom(), { animate: false });
    updateDistanceBox();
    return;
  }

  const distance = calculateDistance(lastPosition, newPosition);

  // Enhanced adaptive filtering based on speed
  const speedFactor = Math.min(1, Math.max(0.1, newPosition.speedMPS / 10));
  kalmanFilter.q = BASE_PROCESS_NOISE * speedFactor;
  kalmanFilter.r = newPosition.accuracy / (100 * (1 + speedFactor));

  // Extended distance handling with improved smoothing
  if (distance > EXTENDED_DISTANCE_THRESHOLD || forceUpdate) {
    if (stationaryCheckTimeout) {
      clearTimeout(stationaryCheckTimeout);
      stationaryCheckTimeout = null;
    }
    isStationary = false;
    stationaryStartTime = null;

    const transitionPosition = {
      lat: newPosition.lat,
      lng: newPosition.lng,
      accuracy: newPosition.accuracy,
      heading: newPosition.heading,
      timestamp: currentTime,
      speedMPS: newPosition.speedMPS
    };

    userMarker.setLatLng([transitionPosition.lat, transitionPosition.lng], { animate: false });
    lastPosition = transitionPosition;
    positionBuffer = [transitionPosition];
    kalmanFilter.reset(transitionPosition);
    lastVelocity = { lat: 0, lng: 0 };

    const zoomLevel = getSpeedBasedZoom(newPosition.speedMPS);
    if (zoomLevel !== -1) {
      map.setZoom(zoomLevel, { animate: false });
    }
    map.setView([transitionPosition.lat, transitionPosition.lng], map.getZoom(), { 
      animate: false, 
      duration: 0,
      noMoveStart: true
    });
    
    lastUpdateTime = currentTime;
    lastUpdateTimestamp = currentTime;
    updateDistanceBox();
    
    if (map._container) {
      map._onResize();
    }
    return;
  }

  // Enhanced stationary detection with improved filtering
  if (distance < MICRO_MOVEMENT_THRESHOLD && !forceUpdate) {
    if (!isStationary) {
      if (!stationaryStartTime) {
        stationaryStartTime = currentTime;
      } else if (currentTime - stationaryStartTime >= STATIONARY_TIME_THRESHOLD) {
        isStationary = true;
        
        kalmanFilter.r = Math.min(newPosition.accuracy, lastPosition.accuracy) / 200;
        kalmanFilter.q = BASE_PROCESS_NOISE * 0.1;
        
        const stationaryPosition = kalmanFilter.update({
          lat: newPosition.lat,
          lng: newPosition.lng,
          accuracy: Math.min(lastPosition.accuracy, newPosition.accuracy) * STATIONARY_ACCURACY_MULTIPLIER,
          heading: newPosition.heading,
          timestamp: newPosition.timestamp,
          speedMPS: 0
        });
        
        userMarker.setLatLng([stationaryPosition.lat, stationaryPosition.lng], { animate: false });
        lastPosition = stationaryPosition;
        positionBuffer = [stationaryPosition];
        
        if (stationaryCheckTimeout) clearTimeout(stationaryCheckTimeout);
        stationaryCheckTimeout = setTimeout(() => checkStationaryState(newPosition), STATIONARY_CHECK_INTERVAL);
        
        updateDistanceBox();
        return;
      }
    }
    
    if (isStationary) {
      if (newPosition.accuracy < lastPosition.accuracy * 0.9) {
        kalmanFilter.r = newPosition.accuracy / 400;
        kalmanFilter.q = BASE_PROCESS_NOISE * 0.05;
        
        const refinedPosition = kalmanFilter.update({
          lat: newPosition.lat,
          lng: newPosition.lng,
          accuracy: newPosition.accuracy,
          heading: newPosition.heading,
          timestamp: newPosition.timestamp,
          speedMPS: 0
        });
        
        if (calculateDistance(lastPosition, refinedPosition) < MICRO_MOVEMENT_THRESHOLD / 2) {
          userMarker.setLatLng([refinedPosition.lat, refinedPosition.lng], { animate: false });
          lastPosition = refinedPosition;
          updateDistanceBox();
        }
      }
      return;
    }
  } else {
    isStationary = false;
    stationaryStartTime = null;
    if (stationaryCheckTimeout) {
      clearTimeout(stationaryCheckTimeout);
      stationaryCheckTimeout = null;
    }
  }

  // Skip updates with poor accuracy or unrealistic movement
  if (!forceUpdate && (
    newPosition.accuracy > MAX_ACCEPTABLE_ACCURACY ||
    distance < MIN_DISTANCE_THRESHOLD ||
    (timeDelta > 0 && distance / timeDelta > MAX_SPEED)
  )) {
    return;
  }

  try {
    // Apply Kalman filter with adaptive parameters
    const filteredPosition = kalmanFilter.update({
      lat: newPosition.lat,
      lng: newPosition.lng,
      accuracy: newPosition.accuracy,
      heading: newPosition.heading,
      timestamp: newPosition.timestamp,
      speedMPS: newPosition.speedMPS
    });

    updatePositionBuffer(filteredPosition);
    
    const finalPosition = calculateFinalPosition();
    if (!finalPosition) throw new Error("Final position calculation failed");

    const predictedPosition = calculateEnhancedVelocityFilter(finalPosition, lastPosition, timeDelta, newPosition.speedMPS);
    
    const smoothingFactor = Math.min(0.8, Math.max(0.2, 0.3 + (speedFactor * 0.5)));
    const smoothedPosition = {
      lat: lastPosition.lat * (1 - smoothingFactor) + predictedPosition.lat * smoothingFactor,
      lng: lastPosition.lng * (1 - smoothingFactor) + predictedPosition.lng * smoothingFactor,
      accuracy: predictedPosition.accuracy,
      heading: predictedPosition.heading,
      timestamp: currentTime,
      speedMPS: predictedPosition.speedMPS
    };

    const animDuration = Math.min(0.3, Math.max(0.1, 0.2 / (1 + speedFactor)));
    
    userMarker.setLatLng([smoothedPosition.lat, smoothedPosition.lng], {
      animate: true,
      duration: animDuration
    });
    
    if (currentTime - lastMapUpdateTime > MAP_UPDATE_INTERVAL || distance > POSITION_UPDATE_THRESHOLD) {
      // Call your existing proximity check function here
      checkProximityForZoom();
      
      const lookAheadFactor = Math.min(0.5, speedFactor * 0.3);
      
        const lookAheadPosition = {
        lat: smoothedPosition.lat + (predictedPosition.lat - lastPosition.lat) * lookAheadFactor,
        lng: smoothedPosition.lng + (predictedPosition.lng - lastPosition.lng) * lookAheadFactor
      };
      
      // Use requestAnimationFrame for smoother panning
      animationFrameId = requestAnimationFrame(() => {
        map.panTo([lookAheadPosition.lat, lookAheadPosition.lng], {
          animate: true,
          duration: 0.5,
          easeLinearity: 0.5
        });
        
        const zoomLevel = getSpeedBasedZoom(newPosition.speedMPS);
        if (zoomLevel !== -1 && Math.abs(map.getZoom() - zoomLevel) >= 1) {
          map.setZoom(zoomLevel, { animate: true, duration: 1 });
        }
        
        animationFrameId = null;
      });
      
      lastMapUpdateTime = currentTime;
    }

    lastPosition = smoothedPosition;
    lastUpdateTime = currentTime;
    lastUpdateTimestamp = currentTime;
    updateDistanceBox();

  } catch (error) {
    console.error("Location update error:", error);
    // Cancel any pending animation frame on error
    if (animationFrameId !== null) {
      cancelAnimationFrame(animationFrameId);
      animationFrameId = null;
    }
    
    kalmanFilter.r = newPosition.accuracy / 50;
    const fallbackPosition = kalmanFilter.update(newPosition);
    userMarker.setLatLng([fallbackPosition.lat, fallbackPosition.lng], { animate: true, duration: 0.3 });
    lastPosition = fallbackPosition;
    positionBuffer = [fallbackPosition];
    updateDistanceBox();
  }
}

// New helper function for enhanced velocity prediction with acceleration
function calculateEnhancedVelocityFilter (currentPosition, lastPosition, timeDelta, speed) {
    if (!timeDelta || timeDelta <= 0) {
        return currentPosition;
    }
    
    // Calculate current velocity components
    const currentVelocity = {
        lat: (currentPosition.lat - lastPosition.lat) / timeDelta,
        lng: (currentPosition.lng - lastPosition.lng) / timeDelta
    };
    
    // If no last velocity, initialize it
    if (!lastVelocity) {
        lastVelocity = currentVelocity;
    }
    
    // Calculate acceleration (change in velocity)
    const acceleration = {
        lat: (currentVelocity.lat - lastVelocity.lat) / timeDelta,
        lng: (currentVelocity.lng - lastVelocity.lng) / timeDelta
    };
    
    // Apply acceleration damping at higher speeds to prevent oscillation
    const accelerationDamping = Math.min(1, Math.max(0.2, 1 - (speed / 20)));
    const dampedAcceleration = {
        lat: acceleration.lat * accelerationDamping,
        lng: acceleration.lng * accelerationDamping
    };
    
    // Store current velocity for next update
    lastVelocity = currentVelocity;
    
    // Calculate predicted position using velocity and damped acceleration
    const predictionTimeFactor = Math.min(0.5, Math.max(0.1, timeDelta)); // Limit prediction time
    
    const predictedPosition = {
        lat: currentPosition.lat + (currentVelocity.lat * predictionTimeFactor) + (0.5 * dampedAcceleration.lat * predictionTimeFactor * predictionTimeFactor),
        lng: currentPosition.lng + (currentVelocity.lng * predictionTimeFactor) + (0.5 * dampedAcceleration.lng * predictionTimeFactor * predictionTimeFactor),
        accuracy: currentPosition.accuracy,
        heading: currentPosition.heading,
        timestamp: currentPosition.timestamp,
        speedMPS: speed
    };
    
    return predictedPosition;
}

    function calculateEdgeProximity(map, point) {
        const bounds = map.getBounds();
        const latSpan = bounds.getNorth() - bounds.getSouth();
        const lngSpan = bounds.getEast() - bounds.getWest();
        
        return {
            north: Math.abs(point.lat - bounds.getNorth()) / latSpan,
            south: Math.abs(point.lat - bounds.getSouth()) / latSpan,
            east: Math.abs(point.lng - bounds.getEast()) / lngSpan,
            west: Math.abs(point.lng - bounds.getWest()) / lngSpan
        };
    }

    function isMarkerNearEdge(map, marker, isStrict = false) {
        const bounds = map.getBounds();
        const point = marker.getLatLng();
        const proximities = calculateEdgeProximity(map, point);
        
        const thresholdPercentage = isStrict ? 
            STRICT_EDGE_THRESHOLD_PERCENTAGE : 
            EDGE_THRESHOLD_PERCENTAGE;
        
        const edges = {
            north: proximities.north < thresholdPercentage,
            south: proximities.south < thresholdPercentage,
            east: proximities.east < thresholdPercentage,
            west: proximities.west < thresholdPercentage
        };
        
        return {
            isNearEdge: Object.values(edges).some(edge => edge),
            edges: edges,
            proximities: proximities
        };
    }

    function calculateOptimalCenter(map, markerPosition, edgeInfo) {
        const bounds = map.getBounds();
        
        let latOffset = 0;
        let lngOffset = 0;
        
        if (edgeInfo.edges.north) latOffset = -1 * (bounds.getNorth() - bounds.getSouth()) * 0.2;
        if (edgeInfo.edges.south) latOffset = (bounds.getNorth() - bounds.getSouth()) * 0.2;
        if (edgeInfo.edges.east) lngOffset = -1 * (bounds.getEast() - bounds.getWest()) * 0.2;
        if (edgeInfo.edges.west) lngOffset = (bounds.getEast() - bounds.getWest()) * 0.2;
        
        return {
            lat: markerPosition.lat + latOffset,
            lng: markerPosition.lng + lngOffset
        };
    }

    let lastRecenterTime = Date.now();

    function shouldRecenter(map, marker) {
        const now = Date.now();
        if (now - lastRecenterTime < MIN_RECENTER_INTERVAL) {
            return { needsRecenter: false };
        }
        
        const edgeInfo = isMarkerNearEdge(map, marker);
        const proximities = edgeInfo.proximities;
        
        const isCritical = Object.values(proximities).some(
            proximity => proximity < CRITICAL_EDGE_THRESHOLD_PERCENTAGE
        );
        
        if (isCritical) {
            lastRecenterTime = now;
            return {
                needsRecenter: true,
                isEmergency: true,
                edgeInfo: edgeInfo
            };
        }
        
        if (edgeInfo.isNearEdge) {
            lastRecenterTime = now;
            return {
                needsRecenter: true,
                isEmergency: false,
                edgeInfo: edgeInfo
            };
        }
        
        return {
            needsRecenter: false,
            isEmergency: false,
            edgeInfo: edgeInfo
        };
    }

    function updateDistanceBox() {
        const distanceBox = document.getElementById('distanceBox');
        
        // Initial validation
        if (!userMarker || !gameLocations || gameLocations.length === 0) {
            distanceBox.innerText = 'Initializing...';
            return;
        }

        // Get user coordinates
        const userLatLng = userMarker.getLatLng();
        let userLat = userLatLng.lat;
        let userLng = userLatLng.lng;

        // Coordinate validation
        if (!isFinite(userLat) || !isFinite(userLng)) {
            console.warn('Invalid user coordinates:', userLat, userLng);
            distanceBox.innerText = 'Initializing...';
            return;
        }

        // Use map center if at origin
        if (userLat === 0 && userLng === 0) {
            const center = map.getCenter();
            userLat = center.lat;
            userLng = center.lng;
        }

        // Find closest location
        let closestDistance = Infinity;
        let closestLocation = null;
        const userPos = { lat: userLat, lng: userLng };

        for (const location of gameLocations) {
            if (!location || typeof location.lat !== 'number' || typeof location.lng !== 'number') {
                console.warn('Invalid location data:', location);
                continue;
            }

            const locationPos = { lat: location.lat, lng: location.lng };
            const distance = calculateDistance(userPos, locationPos);

            if (isFinite(distance) && distance < closestDistance) {
                closestDistance = distance;
                closestLocation = location;
            }
        }

        // Validate final distance calculation
        if (!isFinite(closestDistance) || closestDistance === Infinity) {
            console.warn('Invalid distance calculation:', closestDistance);
            distanceBox.innerText = 'Initializing...';
            return;
        }

        // Calculate and display distance
        const distanceFeet = Math.round(closestDistance * 3.28084);
        const distanceText = distanceFeet < 5280 
            ? `${distanceFeet.toLocaleString()} feet` 
            : `${(distanceFeet / 5280).toFixed(2)} miles`;
        
        distanceBox.innerText = `Closest Stop: ${distanceText}`;

        // Check if we should show location hunt
        if (distanceFeet <= DISTANCE_THRESHOLD && !isLocationHuntVisible && closestLocation) {
            showLocationHunt(closestLocation);
        }
    }

    function getGeolocationOptions(retryNumber) {
        return {
            enableHighAccuracy: retryNumber < 2,
            timeout: 10000 + (retryNumber * 5000),
            maximumAge: retryNumber * 5000
        };
    }

function handleLocationError(error) {
    console.warn("Error getting user location:", error);
    
    if (retryCount < MAX_RETRIES) {
        retryCount++;
        console.log(`Retrying to get location (Attempt ${retryCount} of ${MAX_RETRIES})`);
        
        // Use increasing timeout for subsequent retries
        const currentRetryDelay = RETRY_DELAY * retryCount;
        
        setTimeout(() => {
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    console.log("Location retrieved successfully after retry");
                    hideLoadingMessage();
                    updateUserLocation(position, true);
                    retryCount = 0;
                }, 
                handleLocationError, 
                getGeolocationOptions(retryCount) 
            );
        }, currentRetryDelay);
        return;
    }
    
    retryCount = 0;
    hideLoadingMessage();
    
    let errorMessage = "An error occurred while getting your location.";
    if (error && error.code) {
        switch(error.code) {
            case 1: // PERMISSION_DENIED
                errorMessage = "Please allow access to your location to use this feature.";
                break;
            case 2: // POSITION_UNAVAILABLE
                errorMessage = "Your location is currently unavailable. Please try again later.";
                break;
            case 3: // TIMEOUT
                errorMessage = "Getting your location took too long. Please try again.";
                break;
        }
    }
    
    showPopup("Location Error", errorMessage);
    
    // Signal that the location request failed
    if (typeof onLocationFailure === 'function') {
        onLocationFailure(error);
    }
}

function showPopup(title, message, type = 'info', callback = null) {
    // Remove any existing popups
    const existingPopups = document.querySelectorAll('.popup');
    existingPopups.forEach(popup => {
        document.body.removeChild(popup);
    });
    
    const popup = document.createElement('div');
    popup.classList.add('popup', 'fade-in');
    popup.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        z-index: 3000;
        display: flex;
        justify-content: center;
        align-items: center;
    `;

    const popupContent = document.createElement('div');
    popupContent.style.cssText = `
        background-color: white;
        padding: 25px;
        border-radius: 12px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
        max-width: 85%;
        width: 350px;
        text-align: center;
        position: relative;
        left: 0;
        transform: none;
        margin: 0 auto;
    `;

    const titleElement = document.createElement('h3');
    titleElement.textContent = title;
    titleElement.style.cssText = `
        margin-bottom: 15px;
        font-size: 20px;
        font-weight: 600;
        color: var(--primary-color);
    `;

    const messageElement = document.createElement('p');
    messageElement.textContent = message;
    messageElement.style.cssText = `
        margin-bottom: 25px;
        font-size: 16px;
        line-height: 1.5;
        color: #333;
    `;

    const buttonContainer = document.createElement('div');
    buttonContainer.style.cssText = `
        display: flex;
        justify-content: center;
        gap: 15px;
    `;

    const okButton = document.createElement('button');
    okButton.textContent = 'OK';
    okButton.style.cssText = `
        padding: 10px 25px;
        background-color: var(--primary-color);
        color: white;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-size: 16px;
        font-weight: 500;
        transition: background-color 0.2s;
    `;
    okButton.onmouseover = () => { okButton.style.backgroundColor = '#004b7d'; };
    okButton.onmouseout = () => { okButton.style.backgroundColor = 'var(--primary-color)'; };

    okButton.addEventListener('click', () => {
        popup.classList.add('fade-out');
        setTimeout(() => {
            if (document.body.contains(popup)) {
                document.body.removeChild(popup);
            }
            if (callback) callback();
        }, 300);
    });

    buttonContainer.appendChild(okButton);

    if (type === 'info') {
        const cancelButton = document.createElement('button');
        cancelButton.textContent = 'Cancel';
        cancelButton.style.cssText = `
            padding: 10px 25px;
            background-color: #f2f2f2;
            color: #333;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            transition: background-color 0.2s;
        `;
        cancelButton.onmouseover = () => { cancelButton.style.backgroundColor = '#e0e0e0'; };
        cancelButton.onmouseout = () => { cancelButton.style.backgroundColor = '#f2f2f2'; };

        cancelButton.addEventListener('click', () => {
            popup.classList.add('fade-out');
            setTimeout(() => {
                if (document.body.contains(popup)) {
                    document.body.removeChild(popup);
                }
            }, 300);
        });

        buttonContainer.appendChild(cancelButton);
    }

    popupContent.appendChild(titleElement);
    popupContent.appendChild(messageElement);
    popupContent.appendChild(buttonContainer);
    popup.appendChild(popupContent);
    document.body.appendChild(popup);
}

let lastVisitTime = 0;
const cooldownPeriod = 3 * 60 * 1000; // 3 minutes

function showLocationHunt(location) {
    const now = performance.now();
    if (location.id === lastVisitedLocationId && now - lastVisitTime < cooldownPeriod) {
        console.log(`Location ${location.id} is on cooldown. Skipping.`);
        return;
    }
    
    lastVisitedLocationId = location.id;
    lastVisitTime = now;
    isLocationHuntVisible = true;

    const lochuntContainer = document.querySelector('.lochunt-container');
    lochuntContainer.innerHTML = '';
    lochuntContainer.style.display = 'flex';
    lochuntContainer.classList.add('fade-in');

    const scrollableContent = document.createElement('div');
    scrollableContent.style.cssText = `
        flex: 1;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
        scroll-behavior: smooth;
        will-change: scroll-position;
    `;

    const locationImage = document.createElement('img');
    locationImage.src = location.image;
    locationImage.alt = location.name;
    locationImage.style.cssText = `
        width: 100%;
        height: 45vh;
        object-fit: cover;
        object-position: center;
    `;
    locationImage.loading = "eager"; // Prioritize image loading

    scrollableContent.appendChild(locationImage);

    const contentContainer = document.createElement('div');
    contentContainer.classList.add('lochunt-content');
    contentContainer.style.cssText = `
        padding: 24px;
        display: flex;
        flex-direction: column;
        align-items: center;
        max-width: 800px;
        margin: 0 auto;
    `;
    
    const locationInfo = document.createElement('div');
    locationInfo.classList.add('lochunt-info');
    locationInfo.style.cssText = `
        text-align: center;
        width: 100%;
        margin-bottom: 15px;
    `;
    
    const locationName = document.createElement('h1');
    locationName.textContent = location.name;
    locationName.style.cssText = `
        font-size: clamp(1.8rem, 4vw, 2.5rem);
        font-weight: 700;
        color: #1a1a1a;
        margin-bottom: 8px;
        line-height: 1.2;
    `;
    
    const locationCity = document.createElement('p');
    locationCity.textContent = `${location.city}`;
    locationCity.style.cssText = `
        font-size: clamp(1.1rem, 2vw, 1.3rem);
        color: #2c5282;
        font-weight: 600;
        margin-bottom: 4px;
    `;
    
    const locationCreator = document.createElement('p');
    locationCreator.textContent = `Created by: ${location.creator}`;
    locationCreator.style.cssText = `
        font-size: calc(0.9rem + 0.4vw);
        color: #666666;
        font-weight: 500;
    `;
    
    locationInfo.appendChild(locationName);
    locationInfo.appendChild(locationCity);
    locationInfo.appendChild(locationCreator);
    contentContainer.appendChild(locationInfo);
    
    const audioPlayerContainer = createAudioPlayer(location.audio);
    contentContainer.appendChild(audioPlayerContainer);
    scrollableContent.appendChild(contentContainer);
    lochuntContainer.appendChild(scrollableContent);
    
    const bottomActionBar = createBottomActionBar(location);
    bottomActionBar.style.cssText += `
        position: sticky;
        bottom: 0;
        width: 100%;
    `;
    lochuntContainer.appendChild(bottomActionBar);
    
    // Initialize audio player after DOM is updated
    setTimeout(() => {
        initAudioPlayer();
    }, 100);
}

function createAudioPlayer(audioSrc) {
    const audioPlayerContainer = document.createElement('div');
    audioPlayerContainer.classList.add('audio-player');
    audioPlayerContainer.style.cssText = `
        width: 100%;
        max-width: 400px;
        margin-bottom: 15px;
    `;

    const audio = document.createElement('audio');
    audio.id = 'locationAudio';
    audio.src = audioSrc;
    audio.preload = "auto";

    const audioProgress = document.createElement('div');
    audioProgress.classList.add('audio-progress');
    audioProgress.style.cssText = `
        width: 100%;
        margin-bottom: 15px;
    `;

    const progressContainer = document.createElement('div');
    progressContainer.classList.add('progress');
    progressContainer.style.cssText = `
        height: 8px;
        background-color: #e2e8f0;
        border-radius: 4px;
        cursor: pointer;
        margin-bottom: 12px;
        overflow: hidden;
    `;

    const progressBar = document.createElement('div');
    progressBar.id = 'progressBar';
    progressBar.classList.add('progress-bar');
    progressBar.style.cssText = `
        height: 100%;
        background-color: #2c5282;
        width: 0%;
        transition: width 0.1s linear;
    `;

    progressContainer.appendChild(progressBar);
    audioProgress.appendChild(progressContainer);

    const timeInfo = document.createElement('div');
    timeInfo.classList.add('audio-time');
    timeInfo.style.cssText = `
        display: flex;
        justify-content: space-between;
        color: #4a5568;
        font-size: 0.875rem;
        margin-bottom: 16px;
        font-weight: 500;
    `;

    const currentTimeSpan = document.createElement('span');
    currentTimeSpan.id = 'currentTime';
    currentTimeSpan.textContent = '0:00';

    const durationSpan = document.createElement('span');
    durationSpan.id = 'duration';
    durationSpan.textContent = '0:00';

    timeInfo.appendChild(currentTimeSpan);
    timeInfo.appendChild(durationSpan);

    const audioControls = document.createElement('div');
    audioControls.classList.add('audio-controls');
    audioControls.style.cssText = `
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 24px;
    `;

    const rewindBtn = createAudioButton('skip-backward', 'rewindBtn', 'Rewind 10 seconds');
    const playPauseBtn = createAudioButton('play', 'playPauseBtn', 'Play');
    const forwardBtn = createAudioButton('skip-forward', 'forwardBtn', 'Forward 10 seconds');

    audioControls.appendChild(rewindBtn);
    audioControls.appendChild(playPauseBtn);
    audioControls.appendChild(forwardBtn);

    audioPlayerContainer.appendChild(audio);
    audioPlayerContainer.appendChild(audioProgress);
    audioPlayerContainer.appendChild(timeInfo);
    audioPlayerContainer.appendChild(audioControls);

    return audioPlayerContainer;
}

function createAudioButton(iconName, id, ariaLabel) {
    const button = document.createElement('button');
    button.id = id;
    button.classList.add('audio-button');
    button.setAttribute('aria-label', ariaLabel);
    button.innerHTML = `<i class="bi bi-${iconName}"></i>`;
    button.style.cssText = `
        background-color: white;
        color: var(--primary-color);
        border: 2px solid var(--primary-color);
        border-radius: 50%;
        width: 55px;
        height: 55px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.3s ease;
    `;

    button.addEventListener('mouseover', () => {
        button.style.backgroundColor = 'var(--hover-color)';
    });

    button.addEventListener('mouseout', () => {
        button.style.backgroundColor = 'white';
    });

    button.addEventListener('click', () => {
        button.style.backgroundColor = 'var(--primary-color)';
        button.style.color = 'white';
        button.style.transform = 'scale(0.95)';
        
        setTimeout(() => {
            button.style.backgroundColor = 'white';
            button.style.color = 'var(--primary-color)';
            button.style.transform = 'scale(1)';
        }, 200);
    });

    return button;
}

function createBottomActionBar(location) {
    const actionBar = document.createElement('div');
    actionBar.classList.add('location-action-bar');
    actionBar.style.cssText = `
        width: 100%;
        height: 60px;
        background: linear-gradient(to right, #2c5282, #2b6cb0);
        margin-top: auto;
        box-shadow: 0 -2px 10px rgba(0,0,0,0.025);
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0 24px;
        position: sticky;
        bottom: 0;
    `;
    
    const imgSourceBtn = document.createElement('button');
    imgSourceBtn.classList.add('source-info-button', 'btn', 'btn-sm', 'me-2');
    imgSourceBtn.innerHTML = '<i class="bi bi-info-circle-fill text-white" style="font-size: 1.5rem;"></i>';
    imgSourceBtn.setAttribute('aria-label', 'Image source information');
    imgSourceBtn.onclick = () => {
        if (location && location.imageSource) {
            showSourcePopup('Image Source', location.imageSource);
        } else {
            showSourcePopup('Image Source', 'Image source information is not available');
        }
    };

    const feedbackButton = document.createElement('a');
    feedbackButton.href = 'mailto:mattreicher@protonmail.com?subject=Feedback';
    feedbackButton.target = '_blank';
    feedbackButton.rel = 'noopener noreferrer';
    feedbackButton.setAttribute('aria-label', 'Send feedback email');
    feedbackButton.innerHTML = '<i class="bi bi-envelope-fill text-white" style="font-size: 1.5rem;"></i>';
    feedbackButton.classList.add('feedback-email-button', 'btn', 'btn-sm');

    actionBar.appendChild(imgSourceBtn);
    actionBar.appendChild(feedbackButton);
    return actionBar;
}

// Completely new implementation of showPopup focused on image source
function showSourcePopup(title, content) {
    // Remove any existing popups first
    const existingPopup = document.getElementById('sourceInfoPopup');
    if (existingPopup) {
        document.body.removeChild(existingPopup);
    }
    
    // Create overlay container that covers the entire screen
    const overlay = document.createElement('div');
    overlay.id = 'sourceInfoPopup';
    overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 9999;
        backdrop-filter: blur(3px);
    `;

    // Create the popup content box
    const popup = document.createElement('div');
    popup.classList.add('source-info-content');
    popup.style.cssText = `
        background-color: white;
        border-radius: 8px;
        padding: 24px;
        width: 90%;
        max-width: 500px;
        max-height: 80vh;
        overflow-y: auto;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
        display: flex;
        flex-direction: column;
    `;

    // Create title
    const popupTitle = document.createElement('h3');
    popupTitle.textContent = title;
    popupTitle.style.cssText = `
        font-size: 1.5rem;
        font-weight: 600;
        color: #2c5282;
        margin-bottom: 16px;
        border-bottom: 1px solid #e2e8f0;
        padding-bottom: 12px;
    `;

    // Create content
    const popupContent = document.createElement('div');
    popupContent.style.cssText = `
        margin-bottom: 20px;
        line-height: 1.6;
        font-size: 1rem;
    `;
    popupContent.textContent = content;

    // Create close button
    const closeButton = document.createElement('button');
    closeButton.textContent = 'Close';
    closeButton.classList.add('source-close-button', 'btn');
    closeButton.style.cssText = `
        background: linear-gradient(to right, #2c5282, #2b6cb0);
        border: none;
        color: white;
        padding: 8px 24px;
        border-radius: 4px;
        font-weight: 500;
        cursor: pointer;
        align-self: flex-end;
        transition: all 0.2s ease;
    `;
    
    closeButton.addEventListener('mouseover', () => {
        closeButton.style.opacity = '0.9';
    });
    
    closeButton.addEventListener('mouseout', () => {
        closeButton.style.opacity = '1';
    });
    
    closeButton.addEventListener('click', () => {
        document.body.removeChild(overlay);
    });

    // Add click event to close when clicking outside the popup
    overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
            document.body.removeChild(overlay);
        }
    });

    // Assemble popup
    popup.appendChild(popupTitle);
    popup.appendChild(popupContent);
    popup.appendChild(closeButton);
    overlay.appendChild(popup);
    document.body.appendChild(overlay);

    // Add animation
    overlay.style.opacity = '0';
    popup.style.transform = 'translateY(20px)';
    popup.style.transition = 'transform 0.3s ease, opacity 0.3s ease';
    overlay.style.transition = 'opacity 0.3s ease';
    
    // Trigger animation
    setTimeout(() => {
        overlay.style.opacity = '1';
        popup.style.transform = 'translateY(0)';
    }, 10);
}

function initAudioPlayer() {
    const audio = document.getElementById('locationAudio');
    const playPauseBtn = document.getElementById('playPauseBtn');
    const rewindBtn = document.getElementById('rewindBtn');
    const forwardBtn = document.getElementById('forwardBtn');
    const progressBar = document.getElementById('progressBar');
    const progressContainer = document.querySelector('.progress');
    const currentTimeSpan = document.getElementById('currentTime');
    const durationSpan = document.getElementById('duration');

    if (!audio || !playPauseBtn || !progressBar) {
        console.error("Audio player elements not found");
        return;
    }

    // Set up event listeners
    playPauseBtn.addEventListener('click', togglePlay);
    rewindBtn.addEventListener('click', () => seek(-10));
    forwardBtn.addEventListener('click', () => seek(10));
    audio.addEventListener('timeupdate', updateProgress);
    audio.addEventListener('loadedmetadata', setDuration);
    audio.addEventListener('ended', () => {
        playPauseBtn.innerHTML = '<i class="bi bi-play"></i>';
        playPauseBtn.setAttribute('aria-label', 'Play');
        showAdditionalInfo();
    });
    
    if (progressContainer) {
        progressContainer.addEventListener('click', setProgress);
    }

    // Preload audio
    audio.load();

    function togglePlay() {
        if (audio.paused) {
            const playPromise = audio.play();
            if (playPromise !== undefined) {
                playPromise.then(() => {
                    playPauseBtn.innerHTML = '<i class="bi bi-pause"></i>';
                    playPauseBtn.setAttribute('aria-label', 'Pause');
                }).catch(error => {
                    console.error("Audio play error:", error);
                    showSourcePopup("Audio Error", "There was a problem playing the audio. Please try again.");
                });
            }
        } else {
            audio.pause();
            playPauseBtn.innerHTML = '<i class="bi bi-play"></i>';
            playPauseBtn.setAttribute('aria-label', 'Play');
        }
    }

    function seek(seconds) {
        audio.currentTime = Math.max(0, Math.min(audio.currentTime + seconds, audio.duration));  {
        audio.currentTime = Math.max(0, Math.min(audio.currentTime + seconds, audio.duration));
    }

    function updateProgress() {
        if (!isFinite(audio.duration)) return;
        
        const percent = (audio.currentTime / audio.duration) * 100;
        progressBar.style.width = `${percent}%`;
        currentTimeSpan.textContent = formatTime(audio.currentTime);
    }

    function setProgress(e) {
        const width = this.clientWidth;
        const clickX = e.offsetX;
        const duration = audio.duration;
        
        if (isFinite(duration) && width > 0) {
            audio.currentTime = (clickX / width) * duration;
        }
    }

    function setDuration() {
        if (isFinite(audio.duration)) {
            durationSpan.textContent = formatTime(audio.duration);
        }
    }

    function formatTime(time) {
        if (!isFinite(time)) return "0:00";
        
        const minutes = Math.floor(time / 60);
        const seconds = Math.floor(time % 60);
        return `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }
}

function showAdditionalInfo() {
    // Find the location using lastVisitedLocationId
    const location = gameLocations.find(loc => loc.id === lastVisitedLocationId);
    if (!location) {
        console.error('Location not found for ID:', lastVisitedLocationId);
        return;
    }
    
    const additionalInfoContainer = document.querySelector('.additional-info-container');
    additionalInfoContainer.style.display = 'block';
    additionalInfoContainer.classList.add('fade-in');
    
    document.getElementById('additionalInfo').textContent = location.additionalInfo || 
        "No additional information available for this location.";

    const continueButton = document.getElementById('continueButton');
    continueButton.onclick = () => {
        additionalInfoContainer.classList.add('fade-out');
        setTimeout(() => {
            additionalInfoContainer.style.display = 'none';
            additionalInfoContainer.classList.remove('fade-out');
            
            document.querySelector('.lochunt-container').classList.add('fade-out');
            setTimeout(() => {
                document.querySelector('.lochunt-container').style.display = 'none';
                document.querySelector('.lochunt-container').classList.remove('fade-out');
                isLocationHuntVisible = false;
                updateDistanceBox();
            }, 300);
        }, 300);
    };
}

function showLocationSummary(locationId) {
    const location = locations.find(loc => String(loc.id) === String(locationId));
    
    if (location && location.summary) {
        // Create popup modal from scratch to match returnToIndex style
        const popupDiv = document.createElement("div");
        popupDiv.id = 'summaryModal';
        popupDiv.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.6);
            backdrop-filter: blur(4px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease;
        `;
        
        // Using the same dark blue color
        const darkBlue = "#1a3a8a";
        const darkBlueHover = "#0d2c6e";
        
        popupDiv.innerHTML = `
            <div class="modal-container" style="
                background-color: white;
                border-radius: 16px;
                overflow: hidden;
                width: 90%;
                max-width: 420px;
                max-height: 80vh;
                box-shadow: 0 15px 40px rgba(0,0,0,0.2);
                margin: auto;
                transform: translateY(20px);
                transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
                display: flex;
                flex-direction: column;
            ">
                <!-- Dark blue title bar with white text -->
                <div style="
                    background-color: ${darkBlue};
                    padding: 18px 28px;
                    color: white;
                    text-align: center;
                ">
                    <h3 style="
                        margin: 0;
                        font-size: 1.5rem;
                        font-weight: 600;
                    ">${location.name}</h3>
                </div>
                
                <!-- Content area -->
                <div style="
                    flex-grow: 1;
                    overflow-y: auto;
                    padding: 28px;
                ">
                    <!-- Summary content -->
                    <div id="summaryContent" style="
                        color: #5c6c7c;
                        line-height: 1.6;
                        font-size: 1rem;
                        margin-bottom: 25px;
                    ">
                        <p>${location.summary}</p>
                    </div>
                    
                    <!-- Location today in styled box with left-right layout -->
                    <div style="
                        border: 2px solid ${darkBlue};
                        border-radius: 12px;
                        padding: 16px;
                        background-color: rgba(26, 58, 138, 0.05);
                        margin-bottom: 25px;
                        display: flex;
                        align-items: center;
                    ">
                        <div style="
                            font-weight: 600;
                            color: #2c3e50;
                            padding-right: 15px;
                            min-width: 80px;
                        ">Location:</div>
                        <div style="
                            flex: 1;
                            color: #2c3e50;
                            font-weight: normal;
                            border-left: 1px solid rgba(26, 58, 138, 0.2);
                            padding-left: 15px;
                            line-height: 1.4;
                        ">${location.today || "Information not available"}</div>
                    </div>
                    
                    <!-- Continue button -->
                    <div style="
                        display: flex;
                        justify-content: center;
                    ">
                        <button class="continue-btn" style="
                            padding: 14px 24px;
                            background-color: ${darkBlue};
                            color: white;
                            border: none;
                            border-radius: 10px;
                            cursor: pointer;
                            font-size: 1rem;
                            font-weight: 600;
                            min-width: 130px;
                            transition: all 0.2s ease;
                        ">Continue</button>
                    </div>
                </div>
            </div>
        `;
        
        document.body.appendChild(popupDiv);
        
        // Trigger animation
        setTimeout(() => {
            popupDiv.style.opacity = "1";
            popupDiv.querySelector(".modal-container").style.transform = "translateY(0)";
        }, 10);
        
        // Button hover effects
        const continueBtn = popupDiv.querySelector(".continue-btn");
        continueBtn.addEventListener("mouseover", function() {
            this.style.backgroundColor = darkBlueHover;
        });
        continueBtn.addEventListener("mouseout", function() {
            this.style.backgroundColor = darkBlue;
        });
        
        // Close button event
        continueBtn.addEventListener("click", function() {
            popupDiv.style.opacity = "0";
            popupDiv.querySelector(".modal-container").style.transform = "translateY(20px)";
            setTimeout(() => {
                document.body.removeChild(popupDiv);
            }, 300);
        });
        
        // Close modal when clicking outside
        popupDiv.addEventListener("click", function(event) {
            if (event.target === popupDiv) {
                popupDiv.style.opacity = "0";
                popupDiv.querySelector(".modal-container").style.transform = "translateY(20px)";
                setTimeout(() => {
                    document.body.removeChild(popupDiv);
                }, 300);
            }
        });
    } else {
        console.log("Location or summary not found. Location ID:", locationId);
        showPopup("Error", "Summary not available for this location.");
    }
}
       
    function startHunt() {
        gameLocations = locations.sort((a, b) => a.id - b.id);
        currentLocationIndex = 0;
        locationCooldowns = {};
        lastVisitedLocationId = null;
        loadAllLocations();
    }

    function getMarkerColor(tours) {
        if (!tours) return '#0f2bab'; // Default color
        
        switch (tours.toLowerCase()) {
            case 'person':
                return '#FFA500'; // Orange
            case 'gangster':
                return '#3f9b0b'; // Green
            case 'event':
                return '#8B0000'; // Dark red
            case 'place':
                return '#0f2bab'; // Blue
            default:
                return '#0f2bab'; // Default blue
        }
    }

    function loadAllLocations() {
        if (!gameLocations || !Array.isArray(gameLocations) || gameLocations.length === 0) {
            console.error("No locations available to load");
            showPopup("Error", "No locations available. Please try reloading the page.");
            return;
        }

        // Clear existing markers if any
        markerClusterGroup.clearLayers();

        // Create markers for each location
        gameLocations.forEach((location) => {
            if (!location || typeof location.lat !== 'number' || typeof location.lng !== 'number') {
                console.warn("Invalid location data:", location);
                return;
            }

            const markerColor = getMarkerColor(location.tours);
            
            const locationMarker = L.marker([location.lat, location.lng], {
                icon: L.divIcon({
                    className: 'custom-pin-icon',
                    html: `<div class="pin-head" style="background-color: ${markerColor};"></div>`,
                    iconSize: [30, 30],
                    iconAnchor: [15, 30],
                })
            });
                    
            const popupContent = `
                <div class="popup-content">
                    <img src="${location.image}" alt="${location.name}" class="location-image">
                    <h4 class="location-name">
                        <a href="${location.link}" target="_blank" rel="noopener noreferrer" style="text-decoration: none; color: inherit;">${location.name}</a>
                    </h4>
                    <div class="popup-buttons">
                        <button class="button route-button" data-lat="${location.lat}" data-lng="${location.lng}">Directions</button>
                        <button class="button summary-button" data-location-id="${location.id}">Summary</button>
                    </div>
                </div>
            `;
            
            locationMarker.bindPopup(popupContent, {
                offset: L.point(0, -25),
                className: 'custom-popup',
                maxWidth: 300
            });
            
            locationMarker.on('popupopen', function(e) {
                const popup = e.popup._contentNode;
                const routeButton = popup.querySelector('.route-button');
                const summaryButton = popup.querySelector('.summary-button');
                
                if (routeButton) {
                    routeButton.addEventListener('click', function(event) {
                        event.preventDefault();
                        const lat = this.getAttribute('data-lat');
                        const lng = this.getAttribute('data-lng');
                        
                        // Create and show the modal
                        const modal = document.createElement('div');
                        modal.className = 'modal';
                        modal.style.display = 'flex';
                        modal.classList.add('fade-in');
                        modal.innerHTML = `
                            <div class="modal-content">
                                <h3>Choose your preferred navigation app:</h3>
                                <div class="modal-buttons">
                                    <button class="modal-button google-maps">
                                        Google Maps
                                    </button>
                                    <button class="modal-button waze">
                                        Waze
                                    </button>
                                    <button class="modal-button apple-maps">
                                        Apple Maps
                                    </button>
                                    <button class="modal-button cancel">Cancel</button>
                                </div>
                            </div>
                        `;

                        // Add modal styles if not already present
                        if (!document.querySelector('#modal-styles')) {
                            const style = document.createElement('style');
                            style.id = 'modal-styles';
                            style.textContent = `
                                .modal {
                                    position: fixed;
                                    top: 0;
                                    left: 0;
                                    width: 100%;
                                    height: 100%;
                                    background: rgba(0, 0, 0, 0.75);
                                    display: flex;
                                    justify-content: center;
                                    align-items: center;
                                    z-index: 3000;
                                    padding: 16px;
                                    backdrop-filter: blur(4px);
                                }
                                .modal-content {
                                    background: white;
                                    padding: 24px 16px;
                                    border-radius: 16px;
                                    width: 100%;
                                    max-width: 320px;
                                    text-align: center;
                                    box-shadow: 0 20px 40px rgba(0,0,0,0.2);
                                }
                                .modal-buttons {
                                    margin-top: 20px;
                                    display: flex;
                                    flex-direction: column;
                                    gap: 12px;
                                    align-items: center;
                                }
                                .modal-button {
                                    padding: 16px;
                                    border-radius: 12px;
                                    width: 100%;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    font-size: 16px;
                                    font-weight: 500;
                                    border: none;
                                    cursor: pointer;
                                    transition: transform 0.15s ease;
                                }
                                .modal-button:active {
                                    transform: scale(0.98);
                                }
                                .google-maps {
                                    background: #4285F4;
                                    color: white;
                                    box-shadow: 0 2px 8px rgba(66,133,244,0.3);
                                }
                                .waze {
                                    background: #33ccff;
                                    color: white;
                                    box-shadow: 0 2px 8px rgba(51,204,255,0.3);
                                }
                                .apple-maps {
                                    background: #000000;
                                    color: white;
                                    box-shadow: 0 2px 8px rgba(0,0,0,0.2);
                                }
                                .cancel {
                                    background: #f2f2f2;
                                    color: #666;
                                }
                            `;
                            document.head.appendChild(style);
                        }

                        document.body.appendChild(modal);

                        // Handle button clicks
                        modal.querySelector('.google-maps').addEventListener('click', () => {
                            window.location.href = `https://www.google.com/maps/dir/?api=1&destination=${lat},${lng}`;
                            modal.classList.add('fade-out');
                            setTimeout(() => modal.remove(), 300);
                        });

                        modal.querySelector('.waze').addEventListener('click', () => {
                            window.location.href = `https://www.waze.com/ul?ll=${lat}%2C${lng}&navigate=yes`;
                            modal.classList.add('fade-out');
                            setTimeout(() => modal.remove(), 300);
                        });

                        modal.querySelector('.apple-maps').addEventListener('click', () => {
                            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
                            if (isIOS) {
                                window.location.href = `maps://maps.apple.com/?daddr=${lat},${lng}`;
                                modal.classList.add('fade-out');
                                setTimeout(() => modal.remove(), 300);
                            } else {
                                const alertEl = document.createElement('div');
                                alertEl.className = 'modal';
                                alertEl.style.zIndex = '4000';
                                alertEl.innerHTML = `
                                    <div class="modal-content">
                                        <p>Apple Maps is only available on iOS devices</p>
                                        <button class="modal-button">OK</button>
                                    </div>
                                `;
                                document.body.appendChild(alertEl);
                                alertEl.querySelector('button').onclick = () => {
                                    alertEl .remove();
                                };
                            }
                        });
                        
                        modal.querySelector('.cancel').addEventListener('click', () => {
                            modal.classList.add('fade-out');
                            setTimeout(() => modal.remove(), 300);
                        });

                        // Close modal if clicking outside
                        modal.addEventListener('click', (e) => {
                            if (e.target === modal) {
                                modal.classList.add('fade-out');
                                setTimeout(() => modal.remove(), 300);
                            }
                        });
                    });
                }
                
                if (summaryButton) {
                    summaryButton.addEventListener('click', function(event) {
                        event.preventDefault();
                        const locationId = this.getAttribute('data-location-id');
                        showLocationSummary(locationId);
                    });
                }
            });
            
            markerClusterGroup.addLayer(locationMarker);
        });
        
        map.addLayer(markerClusterGroup);
        updateDistanceBox();
        resetInactivityTimer();
    }

function returnToIndex() {
  // Create popup with proper centering and animation
  const popupDiv = document.createElement("div");
  popupDiv.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,0.6);
    backdrop-filter: blur(4px);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
    opacity: 0;
    transition: opacity 0.3s ease;
  `;
  // Using #1a3a8a as the dark blue color
  const darkBlue = "#1a3a8a";
  const darkBlueHover = "#0d2c6e";
  popupDiv.innerHTML = `
    <div class="modal-container" style="
      background-color: white;
      border-radius: 16px;
      padding: 28px;
      width: 90%;
      max-width: 420px;
      max-height: 90vh;
      box-shadow: 0 15px 40px rgba(0,0,0,0.2);
      margin: auto;
      transform: translateY(20px);
      transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      overflow: hidden;
      display: flex;
      flex-direction: column;
    ">
      <div style="
        text-align: center;
        margin-bottom: 25px;
      ">
        <svg width="50" height="50" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <circle cx="12" cy="12" r="10" stroke="${darkBlue}" stroke-width="1.5"/>
          <path d="M12 8V13" stroke="${darkBlue}" stroke-width="2" stroke-linecap="round"/>
          <circle cx="12" cy="16" r="1" fill="${darkBlue}"/>
        </svg>
      </div>
      <h3 style="
        text-align: center;
        margin: 0 0 15px 0;
        color: #2c3e50;
        font-size: 1.5rem;
        font-weight: 600;
      ">Ready to Leave?</h3>
      <div style="flex-grow: 1; overflow-y: auto; padding: 0 10px;">
        <p style="
          text-align: center;
          margin: 0 0 30px 0;
          color: #5c6c7c;
          line-height: 1.5;
          font-size: 1rem;
        ">Are you sure you want to return to the main page?</p>
      </div>
      <div style="
        display: flex;
        justify-content: center;
        gap: 15px;
        margin-bottom: 15px;
      ">
        <button class="confirm-btn" style="
          padding: 14px 24px;
          background-color: ${darkBlue};
          color: white;
          border: none;
          border-radius: 10px;
          cursor: pointer;
          font-size: 1rem;
          font-weight: 600;
          min-width: 130px;
          transition: all 0.2s ease;
        ">Yes, Exit</button>
        <button class="cancel-btn" style="
          padding: 14px 24px;
          background-color: transparent;
          color: ${darkBlue};
          border: 1.5px solid ${darkBlue};
          border-radius: 10px;
          cursor: pointer;
          font-size: 1rem;
          font-weight: 600;
          min-width: 130px;
          transition: all 0.2s ease;
        ">Stay Here</button>
      </div>
      <div style="text-align: center; margin-top: 15px;">
        <a href="#" class="credits-link" style="
          display: inline-block;
          text-align: center;
          color: #64748b;
          text-decoration: none;
          font-size: 0.9rem;
          padding: 8px 20px;
          border-radius: 100px;
          border: 1px solid rgba(100, 116, 139, 0.2);
          background-color: rgba(100, 116, 139, 0.05);
          transition: all 0.2s ease;
        ">View Acknowledgements</a>
      </div>
    </div>
  `;
  document.body.appendChild(popupDiv);
  // Trigger animation
  setTimeout(() => {
    popupDiv.style.opacity = "1";
    popupDiv.querySelector(".modal-container").style.transform = "translateY(0)";
  }, 10);
  // Button hover effects
  const confirmBtn = popupDiv.querySelector(".confirm-btn");
  confirmBtn.addEventListener("mouseover", function() {
    this.style.backgroundColor = darkBlueHover;
  });
  confirmBtn.addEventListener("mouseout", function() {
    this.style.backgroundColor = darkBlue;
  });
  const cancelBtn = popupDiv.querySelector(".cancel-btn");
  cancelBtn.addEventListener("mouseover", function() {
    this.style.backgroundColor = "rgba(26, 58, 138, 0.05)";
  });
  cancelBtn.addEventListener("mouseout", function() {
    this.style.backgroundColor = "transparent";
  });
  const creditsLink = popupDiv.querySelector(".credits-link");
  creditsLink.addEventListener("mouseover", function() {
    this.style.backgroundColor = "rgba(100, 116, 139, 0.1)";
    this.style.borderColor = "rgba(100, 116, 139, 0.3)";
  });
  creditsLink.addEventListener("mouseout", function() {
    this.style.backgroundColor = "rgba(100, 116, 139, 0.05)";
    this.style.borderColor = "rgba(100, 116, 139, 0.2)";
  });
  // Event listeners
  confirmBtn.addEventListener("click", function() {
    popupDiv.style.opacity = "0";
    popupDiv.querySelector(".modal-container").style.transform = "translateY(20px)";
    setTimeout(() => {
      document.body.removeChild(popupDiv);
      window.location.href = "/index.html";
    }, 300);
  });
  cancelBtn.addEventListener("click", function() {
    popupDiv.style.opacity = "0";
    popupDiv.querySelector(".modal-container").style.transform = "translateY(20px)";
    setTimeout(() => {
      document.body.removeChild(popupDiv);
    }, 300);
  });
  creditsLink.addEventListener("click", function(e) {
    e.preventDefault();
    // Simplified credits popup with dark blue
    const creditsPopup = document.createElement("div");
    creditsPopup.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.7);
      backdrop-filter: blur(6px);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1001;
      opacity: 0;
      transition: opacity 0.3s ease;
    `;
    creditsPopup.innerHTML = `
      <div class="credits-container" style="
        background-color: white;
        border-radius: 16px;
        width: 92%;
        max-width: 450px;
        max-height: 80vh;
        box-shadow: 0 20px 50px rgba(0,0,0,0.25);
        margin: auto;
        transform: translateY(20px);
        transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        overflow: hidden;
        display: flex;
        flex-direction: column;
      ">
        <div style="
          background-color: ${darkBlue};
          padding: 20px;
          color: white;
          text-align: center;
        ">
          <h3 style="margin: 0; font-size: 1.5rem; font-weight: 600;">Acknowledgements</h3>
        </div>
        <div style="
          padding: 20px;
          flex-grow: 1;
          overflow-y: auto;
        ">
          <ul style="list-style-type: none; padding: 0; margin: 0;">
            <li style="margin-bottom: 20px;">
              <strong style="color: #1e293b; font-size: 1.05rem;">OpenStreetMap</strong>
              <p style="color: #64748b; margin: 5px 0 0 0; font-size: 0.9rem; line-height: 1.5;">
                Providing the map data and tiles for this interactive experience.
              </p>
            </li>
            <li style="margin-bottom: 20px;">
              <strong style="color: #1e293b; font-size: 1.05rem;">Minnesota Historical Society</strong>
              <p style="color: #64748b; margin: 5px 0 0 0; font-size: 0.9rem; line-height: 1.5;">
                For their invaluable historical data, photographs, and archive materials.
              </p>
            </li>
            <li style="margin-bottom: 20px;">
              <strong style="color: #1e293b; font-size: 1.05rem;">Metropolitan State University</strong>
              <p style="color: #64748b; margin: 5px 0 0 0; font-size: 0.9rem; line-height: 1.5;">
                For fostering a passion for history and research methodology.
              </p>
            </li>
            <li style="margin-bottom: 20px;">
              <strong style="color: #1e293b; font-size: 1.05rem;">Leaflet.js</strong>
              <p style="color: #64748b; margin: 5px 0 0 0; font-size: 0.9rem; line-height: 1.5;">
                The open-source JavaScript library that powers the mapping features.
              </p>
            </li>
            <li>
              <strong style="color: #1e293b; font-size: 1.05rem;">All Contributors</strong>
              <p style="color: #64748b; margin: 5px 0 0 0; font-size: 0.9rem; line-height: 1.5;">
                Researchers, testers, and developers who made this project possible.
              </p>
            </li>
          </ul>
        </div>
        <div style="padding: 15px; text-align: center; border-top: 1px solid #eee;">
          <button class="close-credits-btn" style="
            padding: 12px 30px;
            background-color: ${darkBlue};
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 0.95rem;
            font-weight: 600;
            transition: background-color 0.2s ease;
          ">Close</button>
        </div>
      </div>
    `;
    document.body.appendChild(creditsPopup);
    // Trigger animation
    setTimeout(() => {
      creditsPopup.style.opacity = "1";
      creditsPopup.querySelector(".credits-container").style.transform = "translateY(0)";
    }, 10);
    // Close button interaction
    const closeBtn = creditsPopup.querySelector(".close-credits-btn");
        closeBtn.addEventListener("mouseover", function() {
      this.style.backgroundColor = darkBlueHover;
    });
    closeBtn.addEventListener("mouseout", function() {
      this.style.backgroundColor = darkBlue;
    });
    closeBtn.addEventListener("click", function() {
      creditsPopup.style.opacity = "0";
      creditsPopup.querySelector(".credits-container").style.transform = "translateY(20px)";
      setTimeout(() => {
        document.body.removeChild(creditsPopup);
      }, 300);
    });
  });
  document.getElementById("returnButton").classList.remove("active");
}
  
    function toggleNavigationTips() {
        const tipsElement = document.querySelector('.navigation-tips');
        const computedStyle = window.getComputedStyle(tipsElement);

        if (computedStyle.display === 'none') {
            tipsElement.style.display = 'block';
            tipsElement.classList.add('fade-in');
        } else {
            tipsElement.classList.add('fade-out');
            setTimeout(() => {
                tipsElement.style.display = 'none';
                tipsElement.classList.remove('fade-out');
            }, 300);
        }

        document.getElementById('tipsButton').classList.toggle('active');
    }
        
    function closeNavigationTips() {
        const tipsElement = document.querySelector('.navigation-tips');
        tipsElement.classList.add('fade-out');
        setTimeout(() => {
            tipsElement.style.display = 'none';
            tipsElement.classList.remove('fade-out');
        }, 300);
        document.getElementById('tips-button').classList.remove('active');
    }

const JITTER_THRESHOLD = .5; // meters - adjust based on testing
let lastRecordedPosition = null;
let isUserMoving = false;
let userMovementTimer;

function addUIEventListeners() {
    document.getElementById('recenterButton').addEventListener('click', () => {
        recenterMap();
        resetInactivityTimer();
    });
    
    document.getElementById('returnButton').addEventListener('click', () => {
        returnToIndex();
        resetInactivityTimer();
    });
    
    document.getElementById('tipsButton').addEventListener('click', () => {
        toggleNavigationTips();
        resetInactivityTimer();
    });
    
    document.querySelector('.navigation-tips .close-button').addEventListener('click', () => {
        closeNavigationTips();
        resetInactivityTimer();
    });
}

function addMapEventListeners() {
    const startInteraction = () => {
        isMapInteracting = true;
        followUser = false;
        resetInactivityTimer();
    };
    map.on('movestart zoomstart dragstart', startInteraction);
    
    // Enhanced touch event listeners for pinch/zoom/pan
    const container = map.getContainer();
    container.addEventListener('touchstart', startInteraction);
    
    // Handle touch moves for pinch/zoom
    container.addEventListener('touchmove', () => {
        resetInactivityTimer();
    });
    
    // Handle interaction end events
    map.on('moveend zoomend dragend touchend', () => {
        resetInactivityTimer();
    });
}

function resetInactivityTimer() {
    clearTimeout(inactivityTimer);
    inactivityTimer = setTimeout(checkInactivity, INACTIVITY_TIMEOUT);
}

function checkInactivity() {
    console.log('Inactivity timer triggered');
    isMapInteracting = false;
    
    // Close any open popups
    map.closePopup();
    map.eachLayer((layer) => {
        if (layer.getPopup && layer.getPopup()?.isOpen()) {
            layer.closePopup();
        }
    });
    
    // Only recenter if not in location hunt and not at an edge case
    if (!isLocationHuntVisible && !isUserMoving) {
        followUser = true;
        recenterMap();
    }
}

// Update to handle location updates and filter jitter
function handleLocationUpdate(position) {
    const newPosition = {
        lat: position.coords.latitude,
        lng: position.coords.longitude
    };
    
    lastPosition = newPosition;
    
    // Filter jitter movements
    if (lastRecordedPosition) {
        const distance = calculateDistance(lastRecordedPosition, newPosition);
        
        if (distance > JITTER_THRESHOLD) {
            // Real movement detected
            isUserMoving = true;
            lastRecordedPosition = newPosition;
            
            // Reset movement detection timer
            clearTimeout(userMovementTimer);
            userMovementTimer = setTimeout(() => {
                isUserMoving = false;
            }, 5000); // Consider user stopped after 5 seconds without significant movement
        }
    } else {
        // First position update
        lastRecordedPosition = newPosition;
    }
    
    // Update map if following user
    if (followUser && !isMapInteracting) {
        updateUserPosition(newPosition);
    }
}

// Calculate distance between two points in meters
function calculateDistance(pos1, pos2) {
    // Haversine formula for distance calculation
    const R = 6371000; // Earth's radius in meters
    const Ï1 = pos1.lat * Math.PI/180;
    const Ï2 = pos2.lat * Math.PI/180;
    const ÎÏ = (pos2.lat - pos1.lat) * Math.PI/180;
    const ÎÎ» = (pos2.lng - pos1.lng) * Math.PI/180;

    const a = Math.sin(ÎÏ/2) * Math.sin(ÎÏ/2) +
              Math.cos(Ï1) * Math.cos(Ï2) *
              Math.sin(ÎÎ»/2) * Math.sin(ÎÎ»/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return R * c;
}

function recenterMap() {
    const recenterButton = document.getElementById('recenterButton');
    recenterButton.style.backgroundColor = 'var(--primary-color)';
    recenterButton.style.color = 'white';
    
    if (userMarker && userMarker.getLatLng()) {
        map.closePopup();
        
        // Simply maintain the current zoom level
        const currentZoom = map.getZoom();
        
        // Use panTo for smoother experience
        map.panTo(userMarker.getLatLng(), {
            animate: true,
            duration: 0.5,
            easeLinearity: 0.25,
            noZoom: true // Ensures zoom level doesn't change
        });
        
        followUser = true;
        isMapInteracting = false;
    }
    
    setTimeout(() => {
        recenterButton.style.backgroundColor = 'white';
        recenterButton.style.color = 'var(--primary-color)';
    }, 500);
}

// Update user position with smooth animation
function updateUserPosition(position) {
    if (userMarker) {
        userMarker.setLatLng([position.lat, position.lng]);
        
        if (followUser && !isMapInteracting) {
            map.panTo([position.lat, position.lng], {
                animate: true,
                duration: 0.5,
                easeLinearity: 0.25,
                noMoveStart: true,
                noZoom: true
            });
        }
    }
}

// Periodic update for smooth following
setInterval(() => {
    if (lastPosition && followUser && !isMapInteracting) {
        map.panTo([lastPosition.lat, lastPosition.lng], {
            animate: true,
            duration: 0.5,
            easeLinearity: 0.25,
            noMoveStart: true,
            noZoom: true
        });
    }
}, UPDATE_INTERVAL);
        
    // Initialize the application
    document.addEventListener('DOMContentLoaded', function() {
        initMap();
        addUIEventListeners();
        addMapEventListeners();
        resetInactivityTimer();
    });
    </script>
</body>
</html>
