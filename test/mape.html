<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, viewport-fit=cover">
    <title>Minnesota Then | Self-Guided Tours</title>
    <link rel="shortcut icon" type="image/x-icon" href="https://www.mnthen.com/images/mnthenfav.ico">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css">
    
 <style>
 /* Base styles */
 :root {
 --primary-color: #2c5282;
 --primary-light: #3182ce;
 --primary-dark: #1a365d;
 --secondary-color: #e53e3e;
 --secondary-light: #fc8181;
 --secondary-dark: #c53030;
 --accent-color: #38a169;
 --accent-light: #68d391;
 --accent-dark: #276749;
 --text-color: #2d3748;
 --text-light: #4a5568;
 --text-lighter: #718096;
 --bg-color: #ffffff;
 --bg-light: #f7fafc;
 --bg-dark: #edf2f7;
 --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
 --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
 --shadow-md: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
 --shadow-lg: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
 --radius-sm: 0.125rem;
 --radius: 0.25rem;
 --radius-md: 0.375rem;
 --radius-lg: 0.5rem;
 --radius-xl: 1rem;
 --radius-2xl: 1.5rem;
 --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
 --transition-fast: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
 --transition-slow: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
 --font-sans: 'Segoe UI', -apple-system, BlinkMacSystemFont, 'Helvetica Neue', Arial, sans-serif;
 }

 * {
 margin: 0;
 padding: 0;
 box-sizing: border-box;
 }
 
 body {
 margin: 0;
 padding: 0;
 font-family: var(--font-sans);
 overflow: hidden;
 height: 100vh;
 width: 100vw;
 position: relative;
 color: var(--text-color);
 background-color: var(--bg-color);
 -webkit-font-smoothing: antialiased;
 -moz-osx-font-smoothing: grayscale;
 touch-action: manipulation;
 }
 
 #map {
 height: 100vh;
 width: 100%;
 z-index: 1;
 }

/* Aggressive overrides to remove any unwanted padding or margins */
.leaflet-popup-content-wrapper,
.leaflet-popup-content {
  padding: 0 !important;
  margin: 0 !important;
  width: 100% !important;
  overflow: hidden !important;
  box-sizing: border-box !important;
}

/* Target the exact container structure */
.custom-popup .leaflet-popup-content-wrapper .leaflet-popup-content {
  width: 300px !important;
  margin: 0 !important;
}

/* Make sure marker-popup takes full width */
.marker-popup {
  width: 100%;
  display: block;
}

/* Remove any potential right-side spacing */
.leaflet-popup-content-wrapper {
  padding-right: 0 !important;
}

/* If the white bar is due to a scrollbar */
.leaflet-popup-content-wrapper,
.leaflet-popup-content,
.marker-popup {
  overflow-x: hidden !important;
  max-width: 100% !important;
}
     
 /* Enhanced Distance box */
 #distanceBox {
 position: absolute;
 top: 16px;
 left: 16px;
 background-color: rgba(255, 255, 255, 0.98);
 padding: 16px 20px;
 border-radius: var(--radius-lg);
 box-shadow: var(--shadow-md);
 z-index: 1000;
 font-size: 20px;
 font-weight: 600;
 color: var(--text-color);
 min-width: 200px;
 max-width: 320px;
 transition: var(--transition);
 border-left: 6px solid var(--primary-color);
 display: flex;
 align-items: center;
 backdrop-filter: blur(5px);
 transform: translateZ(0);
 }

 #distanceBox .location-icon {
 margin-right: 15px;
 color: var(--primary-color);
 font-size: 24px;
 }

 #distanceBox .distance-info {
 display: flex;
 flex-direction: column;
 font-size: 20px;
 }

 #distanceBox .location-name {
 font-weight: 700;
 margin-bottom: 4px;
 color: var(--primary-color);
 font-size: 20px;
 }

 #distanceBox .distance-value {
 font-size: 18px; /* Increased from 16px for better readability on mobile */
 color: var(--text-light);
 font-weight: 500;
 }

 /* Location hunt container */
 .lochunt-container {
 position: fixed;
 bottom: 0;
 left: 0;
 width: 100%;
 height: 80%;
 background-color: var(--bg-color);
 z-index: 1500;
 border-radius: var(--radius-2xl) var(--radius-2xl) 0 0;
 box-shadow: var(--shadow-lg);
 transform: translateY(100%);
 transition: transform 0.5s cubic-bezier(0.16, 1, 0.3, 1);
 overflow: hidden;
 display: none;
 will-change: transform;
 }
 
 .lochunt-container.active {
 transform: translateY(0);
 display: block;
 }
 
 .lochunt-content {
 padding: 24px;
 overflow-y: auto;
 height: calc(100% - 200px);
 }
 
 #locationImage {
 width: 100%;
 height: 200px;
 object-fit: cover;
 object-position: center;
 }
 
 .lochunt-info {
 margin-bottom: 24px;
 }
 
 .lochunt-info h2 {
 color: var(--primary-color);
 margin-bottom: 8px;
 font-weight: 700;
 }
 
 .lochunt-info p {
 line-height: 1.6;
 margin-bottom: 16px;
 }
 
 .text-muted {
 color: var(--text-lighter);
 font-size: 14px;
 }
 
 /* Audio player */
 .audio-player {
 margin-top: 24px;
 padding: 20px;
 background-color: var(--bg-light);
 border-radius: var(--radius-lg);
 box-shadow: var(--shadow-sm);
 }
 
 .audio-progress {
 margin-bottom: 12px;
 }
 
 .progress {
 height: 6px;
 background-color: var(--bg-dark);
 border-radius: var(--radius-xl);
 overflow: hidden;
 }
 
 .progress-bar {
 background-color: var(--primary-color);
 height: 100%;
 border-radius: var(--radius-xl);
 transition: width 0.1s linear;
 }
 
 .audio-time {
 display: flex;
 justify-content: space-between;
 font-size: 12px;
 color: var(--text-lighter);
 margin-bottom: 12px;
 }
 
 .audio-controls {
 display: flex;
 justify-content: space-between;
 align-items: center;
 max-width: 200px;
 margin: 0 auto;
 }
 
 .audio-button {
 background-color: var(--bg-color);
 border: 2px solid var(--primary-color);
 color: var(--primary-color);
 width: 44px;
 height: 44px;
 border-radius: 50%;
 display: flex;
 align-items: center;
 justify-content: center;
 cursor: pointer;
 transition: var(--transition-fast);
 -webkit-tap-highlight-color: transparent;
 }
 
 .audio-button:hover, .audio-button:active {
 background-color: var(--primary-color);
 color: var(--bg-color);
 transform: translateY(-2px);
 }
 
 /* Trivia container */
 .trivia-container {
 position: fixed;
 bottom: 0;
 left: 0;
 width: 100%;
 background-color: var(--bg-color);
 z-index: 1500;
 border-radius: var(--radius-2xl) var(--radius-2xl) 0 0;
 box-shadow: var(--shadow-lg);
 padding: 24px;
 transform: translateY(100%);
 transition: transform 0.5s cubic-bezier(0.16, 1, 0.3, 1);
 display: none;
 will-change: transform;
 }
 
 .trivia-container.active {
 transform: translateY(0);
 display: block;
 }
 
 .trivia-container h3 {
 color: var(--primary-color);
 margin-bottom: 16px;
 font-weight: 700;
 }
 
 .trivia-option {
 background-color: var(--bg-light);
 border: 2px solid var(--bg-dark);
 border-radius: var(--radius-lg);
 padding: 16px;
 margin-bottom: 12px;
 cursor: pointer;
 transition: var(--transition-fast);
 font-weight: 500;
 text-align: left;
 width: 100%;
 color: var(--text-color);
 }
 
 .trivia-option:hover, .trivia-option:active {
 background-color: var(--bg-dark);
 transform: translateY(-2px);
 }
 
 .trivia-option.correct {
 background-color: var(--accent-light);
 border-color: var(--accent-color);
 color: var(--accent-dark);
 }
 
 .trivia-option.incorrect {
 background-color: var(--secondary-light);
 border-color: var(--secondary-color);
 color: var(--secondary-dark);
 }
 
 /* Map buttons: horizontal and centered at bottom */
 .map-buttons {
 position: fixed; 
 bottom: 40px; 
 left: 50%;
 transform: translateX(-50%);
 display: flex;
 flex-direction: row;
 gap: 16px;
 z-index: 1000;
 background-color: rgba(255, 255, 255, 0.9);
 padding: 12px 16px;
 border-radius: var(--radius-xl);
 box-shadow: var(--shadow-md);
 backdrop-filter: blur(5px);
 width: auto; /* Ensure width is based on content */
 max-width: 90%; /* Prevent overflow on very small screens */
 }
 
 .map-button {
 width: 60px;
 height: 60px;
 border-radius: 50%;
 background-color: var(--bg-color);
 border: none;
 box-shadow: var(--shadow);
 display: flex;
 align-items: center;
 justify-content: center;
 font-size: 22px;
 color: var(--primary-color);
 cursor: pointer;
 transition: var(--transition-fast);
 -webkit-tap-highlight-color: transparent;
 }
 
 .map-button:hover, .map-button:active {
 background-color: var(--primary-color);
 color: var(--bg-color);
 transform: scale(1.05);
 box-shadow: var(--shadow-md);
 }
 
 .map-button.active {
 background-color: var(--primary-color);
 color: var(--bg-color);
 }
 
 /* Navigation tips */
 .navigation-tips {
 position: fixed;
 top: 50%;
 left: 50%;
 transform: translate(-50%, -50%);
 background-color: var(--bg-color);
 border-radius: var(--radius-lg);
 box-shadow: var(--shadow-lg);
 padding: 24px;
 z-index: 2000;
 max-width: 90%;
 width: 350px;
 display: none;
 }
 
 .navigation-tips h3 {
 margin-bottom: 16px;
 color: var(--primary-color);
 font-weight: 700;
 }
 
 .navigation-tips ul {
 padding-left: 20px;
 }
 
 .navigation-tips li {
 margin-bottom: 12px;
 line-height: 1.5;
 }
 
 .close-button {
 position: absolute;
 top: 12px;
 right: 12px;
 background: none;
 border: none;
 font-size: 20px;
 cursor: pointer;
 color: var(--text-lighter);
 transition: var(--transition-fast);
 -webkit-tap-highlight-color: transparent;
 }
 
 .close-button:hover, .close-button:active {
 color: var(--text-color);
 }
 
 /* Congratulations */
 #congratulations {
 position: fixed;
 top: 0;
 left: 0;
 width: 100%;
 height: 100%;
 background-color: rgba(0, 0, 0, 0.85);
 display: flex;
 flex-direction: column;
 align-items: center;
 justify-content: center;
 z-index: 3000;
 color: var(--bg-color);
 text-align: center;
 padding: 24px;
 display: none;
 backdrop-filter: blur(5px);
 }
 
 #congratulations h2 {
 font-size: 36px;
 margin-bottom: 24px;
 font-weight: 800;
 }
 
 #congratulations p {
 font-size: 18px;
 margin-bottom: 32px;
 max-width: 600px;
 line-height: 1.6;
 }
 
 #congratulations button {
 background-color: var(--primary-color);
 color: var(--bg-color);
 border: none;
 padding: 16px 32px;
 border-radius: var(--radius-xl);
 font-size: 18px;
 font-weight: 600;
 cursor: pointer;
 transition: var(--transition);
 box-shadow: var(--shadow);
 }
 
 #congratulations button:hover, #congratulations button:active {
 background-color: var(--primary-dark);
 transform: translateY(-3px);
 box-shadow: var(--shadow-md);
 }
 
 /* Enhanced user marker styles */
 .user-marker-icon {
 width: 20px;
 height: 20px;
 background-color: var(--secondary-color);
 border: 3px solid white;
 border-radius: 50%;
 box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
 position: relative;
 will-change: transform;
 transform-origin: center center;
 }
 
 .user-marker-icon::after {
 content: '';
 position: absolute;
 top: 50%;
 left: 50%;
 width: 36px;
 height: 36px;
 background-color: rgba(229, 62, 62, 0.2);
 border-radius: 50%;
 transform: translate(-50%, -50%);
 animation: pulse 2s infinite;
 will-change: transform, opacity;
 }
 
 @keyframes pulse {
 0% {
 transform: translate(-50%, -50%) scale(1);
 opacity: 1;
 }
 100% {
 transform: translate(-50%, -50%) scale(2);
 opacity: 0;
 }
 }
 
 /* Stationary indicator - improved to eliminate jitter */
 .user-marker-stationary .user-marker-icon {
 border-color: var(--accent-color);
 transition: border-color 0.5s ease-out;
 }
 
 .user-marker-stationary .user-marker-icon::after {
 background-color: rgba(56, 161, 105, 0.15);
 animation: stationaryPulse 3s infinite;
 }
 
 @keyframes stationaryPulse {
 0% {
 transform: translate(-50%, -50%) scale(1);
 opacity: 0.6;
 }
 50% {
 transform: translate(-50%, -50%) scale(1.3);
 opacity: 0.3;
 }
 100% {
 transform: translate(-50%, -50%) scale(1);
 opacity: 0.6;
 }
 }
 
 /* Optimize for hardware acceleration */
 #map, .user-marker-icon, .lochunt-container, .trivia-container {
 transform: translateZ(0);
 backface-visibility: hidden;
 perspective: 1000px;
 }
 
 /* Stabilizing modal */
 .stabilizing-modal {
 position: fixed;
 top: 50%;
 left: 50%;
 transform: translate(-50%, -50%);
 background-color: var(--bg-color);
 padding: 24px;
 border-radius: var(--radius-lg);
 box-shadow: var(--shadow-lg);
 z-index: 2000;
 text-align: center;
 max-width: 80%;
 display: flex;
 flex-direction: column;
 align-items: center;
 }
 
 .stabilizing-modal h3 {
 margin-bottom: 16px;
 color: var(--primary-color);
 font-weight: 700;
 }
 
 .stabilizing-modal p {
 margin-bottom: 20px;
 line-height: 1.5;
 }
 
 .stabilizing-modal .spinner {
 width: 48px;
 height: 48px;
 border: 4px solid rgba(44, 82, 130, 0.2);
 border-top: 4px solid var(--primary-color);
 border-radius: 50%;
 margin-bottom: 24px;
 animation: spin 1s linear infinite;
 }
 
 @keyframes spin {
 0% { transform: rotate(0deg); }
 100% { transform: rotate(360deg); }
 }
 
/* Enhanced Preloader styles with overlay and dark green accents */
#preloader {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 9999;
}

#preloader .background {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: url('https://www.mnthen.com/images/splash_screen.webp') center/cover no-repeat;
    z-index: -2;
}

#preloader .overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    z-index: -1;
}

#preloader .content-container {
    background-color: rgba(255, 255, 255, 0.98);
    padding: 40px;
    border-radius: 10px;
    width: 90%;
    max-width: 450px;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
    position: relative;
    z-index: 1;
}

#preloader .logo-container {
    width: 180px;
    height: 180px;
    margin: 0 auto 25px;
    display: flex;
    align-items: center;
    justify-content: center;
}

#preloader .logo-container img {
    width: 100%;
    height: 100%;
    object-fit: contain;
}

#preloader .loading-text {
    font-size: 24px;
    color: #115740; /* Dark green color */
    text-align: center;
    font-weight: 700;
    margin-bottom: 5px;
    letter-spacing: 1.2px;
    text-transform: uppercase;
}

#preloader .tagline {
    font-size: 16px;
    color: #115740; /* Dark green color */
    text-align: center;
    font-style: italic;
    margin-bottom: 25px;
}

#preloader .progress-container {
    width: 100%;
    height: 10px;
    background-color: #e0e0e0;
    border-radius: 5px;
    overflow: hidden;
    box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.2);
}

#preloader .progress-bar {
    height: 100%;
    background: linear-gradient(90deg, #115740 0%, #1e7d5b 100%); /* Dark green gradient */
    width: 0%;
    transition: width 0.3s ease;
    border-radius: 5px;
}

#preloader .status-text {
    font-size: 14px;
    color: #444444;
    margin-top: 15px;
    font-weight: 400;
    text-align: center;
    height: 20px; /* Fixed height to prevent layout shift */
}

#preloader .percentage {
    font-size: 16px;
    color: #115740; /* Dark green color */
    font-weight: 600;
    text-align: right;
    margin-top: 8px;
}

.custom-popup .leaflet-popup-close-button {
    display: none;
}

.custom-popup .leaflet-popup-content-wrapper {
    padding-right: 14px; /* Remove extra padding that would normally accommodate the close button */
}

.custom-popup .leaflet-popup-content {
    margin: 13px;
    text-align: center; /* This will center your content */
}
     
/* Base popup overlay */
#popup {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 3000;
  display: none;
  backdrop-filter: blur(3px);
}

/* Popup container */
.popup-content {
  background-color: var(--bg-color);
  border-radius: var(--radius-lg);
  max-width: 90%;
  width: 350px;
  box-shadow: var(--shadow-lg);
  overflow: hidden;
  padding: 0;
  position: relative;
}

/* General popup button */
.popup-button {
  background-color: var(--primary-color);
  color: var(--bg-color);
  border: none;
  padding: 12px 24px;
  border-radius: var(--radius-lg);
  font-weight: 600;
  cursor: pointer;
  transition: var(--transition);
}

.popup-button:hover, .popup-button:active {
  background-color: var(--primary-dark);
  transform: translateY(-2px);
}

/* ===== LOCATION POPUP STYLES ===== */

/* Image - full width, touching top edge */
.marker-popup-image {
  width: 100%;
  height: 200px;
  object-fit: cover;
  display: block;
  margin: 0;
  padding: 0;
}

/* Content container */
.marker-popup-content {
  padding: 16px;
}

/* Location title - centered */
.marker-popup-title {
  text-align: center;
  font-weight: 700;
  font-size: 18px;
  margin: 0 0 12px 0;
  color: var(--text-color);
}

/* Location description - left justified */
.marker-popup-description {
  text-align: left;
  line-height: 1.5;
  margin: 0 0 16px 0;
  color: var(--text-color);
  font-size: 14px;
}

/* Button container */
.marker-popup-actions {
  display: flex;
  justify-content: center;
  gap: 10px;
  margin-top: 16px;
}

/* Location popup buttons */
.popup-btn {
  background-color: var(--primary-color);
  color: white;
  border: none;
  padding: 10px 18px;
  border-radius: var(--radius-md);
  font-weight: 600;
  font-size: 14px;
  cursor: pointer;
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  gap: 6px;
}

.popup-btn:hover, .popup-btn:active {
  background-color: var(--primary-dark);
  transform: translateY(-2px);
}

/* Style for skip button */
.popup-btn.skip {
  background-color: transparent;
  color: var(--primary-color);
  border: 1px solid var(--primary-color);
}

.popup-btn.skip:hover {
  background-color: rgba(var(--primary-color-rgb), 0.1);
}

/* Style for directions button */
.popup-btn.directions {
  min-width: 110px;
}

/* Generic message popup */
#popupMessage {
  margin-bottom: 24px;
  line-height: 1.5;
  text-align: left;
  padding: 0 24px;
}

/* ===== OVERRIDE MAP LIBRARY DEFAULT STYLES ===== */

/* Remove any close buttons */
.leaflet-popup-close-button,
.mapboxgl-popup-close-button {
  display: none !important;
}

/* Reset leaflet/mapbox default popup padding */
.leaflet-popup-content-wrapper,
.leaflet-popup-content,
.mapboxgl-popup-content {
  padding: 0 !important;
  margin: 0 !important;
  overflow: hidden !important;
  border-radius: var(--radius-lg) !important;
  box-shadow: var(--shadow-lg) !important;
}

/* Custom popup class overrides */
.custom-popup .leaflet-popup-content-wrapper,
.custom-popup .mapboxgl-popup-content {
  padding: 0 !important;
  background-color: var(--bg-color) !important;
}

/* Tip/arrow styling */
.leaflet-popup-tip,
.mapboxgl-popup-tip {
  background-color: var(--bg-color) !important;
}

/* For a popup that has padding (like your generic popup) */
.padded-popup-content {
  padding: 24px;
  text-align: center;
}
     
 /* Enhanced Location marker styles with numbering */
 .location-marker-icon {
 width: 40px;
 height: 40px;
 background-color: #006400;
 border: 3px solid white;
 border-radius: 50%;
 box-shadow: var(--shadow);
 position: relative;
 transition: var(--transition);
 display: flex;
 align-items: center;
 justify-content: center;
 color: white;
 font-weight: bold;
 font-size: 16px;
 }
 
 .location-marker-icon:hover {
 transform: scale(1.1);
 background-color: var(--primary-dark);
 }
 
 /* Enhanced Marker popup styles */
 .marker-popup {
 max-width: 300px;
 padding: 0;
 }
 
 .marker-popup-image {
 width: 100%;
 height: 150px;
 object-fit: cover;
 border-radius: var(--radius-lg) var(--radius-lg) 0 0;
 margin-bottom: 0;
 }
 
 .marker-popup-content {
 padding: 16px;
 }
 
 .marker-popup-title {
 font-size: 18px;
 font-weight: bold;
 margin-bottom: 8px;
 color: var(--primary-color);
 }
 
 .marker-popup-description {
 font-size: 14px;
 margin-bottom: 16px;
 color: var(--text-light);
 line-height: 1.5;
 }
 
 .marker-popup-actions {
 display: flex;
 justify-content: space-between;
 gap: 12px;
 }
 
 .popup-btn {
 padding: 10px 16px;
 border-radius: var(--radius);
 font-size: 14px;
 font-weight: 600;
 cursor: pointer;
 text-align: center;
 transition: var(--transition-fast);
 display: flex;
 align-items: center;
 justify-content: center;
 gap: 8px;
 flex: 1;
 }
 
 .popup-btn.directions {
 background-color: var(--primary-color);
 color: white;
 border: none;
 }
 
 .popup-btn.directions:hover, .popup-btn.directions:active {
 background-color: var(--primary-dark);
 transform: translateY(-2px);
 }
 
 .popup-btn.skip {
 background-color: var(--bg-light);
 color: var(--text-light);
 border: 1px solid var(--bg-dark);
 }
 
 .popup-btn.skip:hover, .popup-btn.skip:active {
 background-color: var(--bg-dark);
 transform: translateY(-2px);
 }
 
 /* Directions modal */
 #directionsModal {
 position: fixed;
 top: 0;
 left: 0;
 width: 100%;
 height: 100%;
 background-color: rgba(0, 0, 0, 0.5);
 display: flex;
 align-items: center;
 justify-content: center;
 z-index: 3000;
 display: none;
 backdrop-filter: blur(3px);
 }
 
 .directions-modal-content {
 background-color: var(--bg-color);
 border-radius: var(--radius-lg);
 padding: 24px;
 max-width: 90%;
 width: 320px;
 box-shadow: var(--shadow-lg);
 }
 
 .directions-modal-title {
 font-size: 18px;
 font-weight: 700;
 margin-bottom: 20px;
 color: var(--text-color);
 text-align: center;
 }
 
 .directions-buttons {
 display: flex;
 flex-direction: column;
 gap: 12px;
 margin-bottom: 20px;
 }
 
 .direction-btn {
 padding: 14px;
 border-radius: var(--radius);
 font-size: 16px;
 font-weight: 600;
 cursor: pointer;
 text-align: center;
 transition: var(--transition-fast);
 display: flex;
 align-items: center;
 justify-content: center;
 gap: 12px;
 text-decoration: none;
 }
 
 .direction-btn.google {
 background-color: #4285F4;
 color: white;
 border: none;
 }
 
 .direction-btn.apple {
 background-color: #000000;
 color: white;
 border: none;
 }
 
 .direction-btn.waze {
 background-color: #33CCFF;
 color: white;
 border: none;
 }
 
 .direction-btn:hover, .direction-btn:active {
 transform: translateY(-2px);
 box-shadow: var(--shadow);
 }
 
 .cancel-btn {
 background-color: var(--bg-light);
 color: var(--text-light);
 border: 1px solid var(--bg-dark);
 padding: 12px;
 border-radius: var(--radius);
 font-size: 16px;
 font-weight: 600;
 cursor: pointer;
 text-align: center;
 transition: var(--transition-fast);
 width: 100%;
 }
 
 .cancel-btn:hover, .cancel-btn:active {
 background-color: var(--bg-dark);
 }
 
 /* Leaflet popup customization */
 .leaflet-popup-content-wrapper {
 padding: 0;
 overflow: hidden;
 border-radius: var(--radius-lg);
 box-shadow: var(--shadow-md);
 }
 
 .leaflet-popup-content {
 margin: 0;
 width: 280px !important;
 }
 
 .leaflet-popup-tip-container {
 margin-top: -1px;
 }
 
 .leaflet-popup-close-button {
 color: white !important;
 top: 5px !important;
 right: 5px !important;
 font-size: 20px !important;
 text-shadow: 0 0 3px rgba(0, 0, 0, 0.5);
 }
 
 /* Enhanced popup animations */
.leaflet-popup {
    transition: opacity 0.3s ease, transform 0.3s ease;
}

.leaflet-popup.leaflet-popup-closing {
    opacity: 0;
    transform: scale(0.9);
    pointer-events: none;
}
 
 /* Navigation buttons */
 .marker-popup-navigation {
 display: flex;
 flex-direction: column;
 gap: 10px;
 margin-top: 16px;
 }
 
 .nav-button {
 display: flex;
 align-items: center;
 justify-content: center;
 gap: 8px;
 padding: 10px;
 border-radius: var(--radius);
 text-decoration: none;
 font-weight: 600;
 font-size: 14px;
 transition: var(--transition-fast);
 }
 
 .nav-button.google {
 background-color: #4285F4;
 color: white;
 }
 
 .nav-button.apple {
 background-color: #000000;
 color: white;
 }
 
 .nav-button.waze {
 background-color: #33CCFF;
 color: white;
 }
 
 .nav-button:hover, .nav-button:active {
 transform: translateY(-2px);
 box-shadow: var(--shadow);
 }
 
 /* Responsive adjustments */
 @media (max-width: 768px) {
 .map-buttons {
 bottom: 30px; /* Adjust for medium screens */
 padding: 10px 14px;
 gap: 12px;
 }
 
 .map-button {
 width: 46px;
 height: 46px;
 font-size: 20px;
 }
 
 #distanceBox {
 max-width: 280px;
 padding: 14px 16px;
 }
 }
 
 @media (max-width: 480px) {
 .map-buttons {
 bottom: 25px; /* Increase from 20px to 25px for small screens */
 padding: 8px 12px;
 gap: 10px;
 }
 
 .map-button {
 width: 40px; /* Slightly smaller buttons on very small screens */
 height: 40px;
 font-size: 16px;
 }
 
 #distanceBox {
 max-width: 260px;
 padding: 12px 14px;
 left: 12px;
 top: 12px;
 font-size: 18px;
 }
 
 #distanceBox .location-icon {
 font-size: 20px;
 margin-right: 10px;
 }
 
 #distanceBox .location-name {
 font-size: 18px;
 }
 
 #distanceBox .distance-value {
 font-size: 16px;
 }
 
 .marker-popup {
 max-width: 260px;
 }
 
 .marker-popup-image {
 height: 130px;
 }
 }

 /* Add a new media query for very small screens or devices with unusual interfaces */
 @media (max-height: 600px), (max-width: 360px) {
 .map-buttons {
 bottom: 15px; /* Even more compact for very small screens */
 }
 
 .map-button {
 width: 36px;
 height: 36px;
 font-size: 14px;
 }
 }

 /* Add a safe area inset for iOS devices with notches */
 @supports (padding-bottom: env(safe-area-inset-bottom)) {
 .map-buttons {
 bottom: calc(25px + env(safe-area-inset-bottom));
 }
 }
 </style>

</head>
<body>
<!-- Enhanced Preloader -->
<div id="preloader">
    <div class="background"></div>
    <div class="overlay"></div>
    <div class="content-container">
        <div class="logo-container">
            <img src="https://www.mnthen.com/images/logo.webp" alt="Minnesota Then Logo">
        </div>
        <div class="loading-text">Minnesota Then Tours</div>
        <div class="tagline">Experience the Gangster Era of St. Paul</div>
        <div class="progress-container">
            <div class="progress-bar" id="preloaderProgress"></div>
        </div>
        <div class="percentage" id="loadingPercentage">0%</div>
        <div class="status-text" id="loadingStatus">Initializing map...</div>
    </div>
</div>

    <div id="map"></div>
    
    <!-- Enhanced Distance Box -->
    <div id="distanceBox">
        <div class="location-icon">
            <i class="fas fa-map-marker-alt"></i>
        </div>
        <div class="distance-info">
            <div class="location-name">Initializing...</div>
            <div class="distance-value">Finding your location</div>
        </div>
    </div>
    
    <div class="lochunt-container">
        <img id="locationImage" src="/placeholder.svg?height=200&width=400" alt="Location Image">
        <div class="lochunt-content">
            <div class="lochunt-info">
                <h2 id="locationTitle" class="mb-2"></h2>
                <p id="locationCity" class="text-muted mb-1"></p>
                <p id="locationCreator" class="text-muted mb-3"></p>
                <p id="locationDescription" class="mb-3"></p>
                
                <div class="marker-popup-navigation">
                    <a href="#" id="googleMapsLink" class="nav-button google" target="_blank">
                        <i class="fab fa-google"></i> Google Maps
                    </a>
                    <a href="#" id="appleMapsLink" class="nav-button apple" target="_blank">
                        <i class="fab fa-apple"></i> Apple Maps
                    </a>
                    <a href="#" id="wazeLink" class="nav-button waze" target="_blank">
                        <i class="fab fa-waze"></i> Waze
                    </a>
                </div>
            </div>
            <div class="audio-player">
                <div class="audio-progress">
                    <div class="progress">
                        <div id="progressBar" class="progress-bar" role="progressbar" style="width: 0%"></div>
                    </div>
                </div>
                <div class="audio-time">
                    <span id="currentTime">0:00</span>
                    <span id="duration">0:00</span>
                </div>
                <div class="audio-controls">
                    <button id="rewindBtn" class="audio-button"><i class="fas fa-backward"></i></button>
                    <button id="playPauseBtn" class="audio-button"><i class="fas fa-play"></i></button>
                    <button id="forwardBtn" class="audio-button"><i class="fas fa-forward"></i></button>
                </div>
                <audio id="locationAudio" src="/placeholder.svg"></audio>
            </div>
        </div>
    </div>
    
    <div class="trivia-container">
        <h3 class="mb-3">Trivia Question</h3>
        <p id="triviaQuestion" class="mb-3 fw-bold"></p>
        <div id="triviaOptions" class="d-grid gap-2"></div>
    </div>
    
    <!-- Enhanced Map Buttons: Horizontal and centered at bottom -->
    <div class="map-buttons">
        <button id="recenterButton" class="map-button" aria-label="Recenter map"><i class="fas fa-crosshairs"></i></button>
        <button id="endTourButton" class="map-button" aria-label="End tour"><i class="fas fa-sign-out-alt"></i></button>
        <button id="tipsButton" class="map-button" aria-label="Show tips"><i class="fas fa-question-circle"></i></button>
    </div>
    
    <div class="navigation-tips">
        <button class="close-button" aria-label="Close tips">&times;</button>
        <h3>Navigation Tips</h3>
        <ul>
            <li>Numbered markers show your tour stops in sequence.</li>
            <li>After visiting a location, the next stop will appear.</li>
            <li>Tap on a marker to see details and navigation options.</li>
            <li>The distance box shows how far you are from the current location.</li>
            <li>Tap the recenter button to focus on your position.</li>
            <li>When you're within 20 feet of a location, you'll be able to interact with it.</li>
            <li>Complete the trivia question to move to the next location.</li>
            <li>You can freely pinch, pan and zoom the map - it will recenter after 29 seconds of inactivity.</li>
        </ul>
    </div>
    
    <div id="congratulations">
        <h2>Congratulations!</h2>
        <p>You have successfully completed the Minnesota Then Gangster History Tour!</p>
        <button onclick="endTour()">Return to the Home Page</button>
    </div>
    
    <div id="popup">
        <div class="popup-content">
            <p id="popupMessage"></p>
            <button class="popup-button" onclick="closePopup()">OK</button>
        </div>
    </div>
    
    <!-- Directions Modal -->
    <div id="directionsModal">
        <div class="directions-modal-content">
            <div class="directions-modal-title">Choose Navigation App</div>
            <div class="directions-buttons">
                <a href="#" id="googleMapsBtn" class="direction-btn google" target="_blank">
                    <i class="fab fa-google"></i> Google Maps
                </a>
                <a href="#" id="appleMapsBtn" class="direction-btn apple" target="_blank">
                    <i class="fab fa-apple"></i> Apple Maps
                </a>
                <a href="#" id="wazeBtn" class="direction-btn waze" target="_blank">
                    <i class="fab fa-waze"></i> Waze
                </a>
            </div>
            <button class="cancel-btn" onclick="closeDirectionsModal()">Cancel</button>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    
    <script>
        // Sample locations data (replace with your actual data)
        const locations = [
            {
                id: 1,
                name: "Landmark Center",
                city: "St. Paul",
                creator: "Minnesota Historical Society",
                lat: 44.9448,
                lng: -93.0962,
                image: "https://www.mnthen.com/images/gangster/landmark.jpg",
                audio: "https://www.mnthen.com/audio/landmark-center.mp3",
                description: "The Landmark Center, completed in 1902, originally served as the Federal Court House and Post Office for the Upper Midwest. This Richardsonian Romanesque building was where many famous gangsters were tried during the 1930s.",
                trivia: {
                    question: "What was the Landmark Center originally built as?",
                    options: [
                        "A hotel",
                        "A federal courthouse and post office",
                        "A train station",
                        "A department store"
                    ],
                    answer: 1
                }
            },
            {
                id: 2,
                name: "Wabasha Street Caves",
                city: "St. Paul",
                creator: "Minnesota Historical Society",
                lat: 44.9338,
                lng: -93.1059,
                image: "https://www.mnthen.com/images/wabasha-caves.jpg",
                audio: "https://www.mnthen.com/audio/wabasha-caves.mp3",
                description: "The Wabasha Street Caves were originally mined for silica in the 1840s. During Prohibition, the caves became a speakeasy known as the Castle Royal. Gangsters like John Dillinger and Ma Barker were rumored to frequent the establishment.",
                trivia: {
                    question: "What illegal activity took place in the Wabasha Street Caves during Prohibition?",
                    options: [
                        "Counterfeiting money",
                        "Illegal gambling",
                        "Speakeasy and nightclub",
                        "All of the above"
                    ],
                    answer: 3
                }
            },
            {
                id: 3,
                name: "Nina's Coffee Cafe",
                city: "St. Paul",
                creator: "Minnesota Historical Society",
                lat: 44.9463,
                lng: -93.1032,
                image: "https://www.mnthen.com/images/ninas-cafe.jpg",
                audio: "https://www.mnthen.com/audio/ninas-cafe.mp3",
                description: "Nina's Coffee Cafe is located in the historic Blair Flats building. The building is rumored to have been a hideout for Al Capone during his visits to St. Paul. The cafe now serves as a popular community gathering spot.",
                trivia: {
                    question: "Which famous gangster was rumored to have a hideout above what is now Nina's Coffee Cafe?",
                    options: [
                        "Al Capone",
                        "John Dillinger",
                        "Ma Barker",
                        "Baby Face Nelson"
                    ],
                    answer: 0
                }
            }
        ];

        // Global variables
        let map, userMarker;
        let currentLocationIndex = 0;
        let visitedLocations = [];
        let gameLocations = [];
        let inactivityTimer;
        let isLocationHuntVisible = false;
        let lastPosition = null;
        let positionBuffer = [];
        const MAX_BUFFER_SIZE = 15; // Increased buffer size for smoother tracking
        const DISTANCE_THRESHOLD = 20; // 20 feet to measure threshold distance to marker before opening location page
        const PROXIMITY_THRESHOLD = 100; // 100 feet to trigger zoom level change
        const velocity = { lat: 0, lng: 0 };
        let isMapInteracting = false;
        let followUser = true; // Always true to keep user centered
        let allLocationMarkers = [];
        let showingAllLocations = false;
        let userIsInteracting = false;
        const preloadedImages = new Map(); // Map to store preloaded images
        const preloadedAudio = new Map(); // Map to store preloaded audio
        let currentSpeed = 0; // Current speed in meters per second
        let lastZoomLevel = 17; // Default zoom level
        let stationaryPositionHistory = []; // Array to store stationary positions for averaging
        let deviceOrientation = null; // Store device orientation data
        let deviceMotion = null; // Store device motion data
        let orientationPermissionGranted = false;
        let activeMarkers = []; // Track currently visible markers
        let currentDirectionsLocation = null; // Store current location for directions modal
        let lastProximityState = null; // Track last proximity state for zoom changes
        let isWithinProximity = false; // Flag to track if user is within proximity of a location

        // Enhanced constants for better stabilization
        const MICRO_MOVEMENT_THRESHOLD = 0.3; // Meters - threshold for detecting micro-movements
        const STATIONARY_ACCURACY_MULTIPLIER = 1.02; // Tighter accuracy bounds
        const MAX_ACCEPTABLE_ACCURACY = 25; // meters - stricter accuracy requirement
        const STATIONARY_THRESHOLD = 5; // Number of consecutive stationary positions to consider user as stationary
        const STATIONARY_TIME_THRESHOLD = 2000; // ms - time to consider user stationary
        const STATIONARY_CHECK_INTERVAL = 1000; // ms - interval to check if still stationary
        const VELOCITY_DECAY = 0.92; // Higher value for smoother velocity transitions
        const MIN_DISTANCE_THRESHOLD = 0.8; // meters - minimum distance to consider movement
        const EXTENDED_DISTANCE_THRESHOLD = 80; // meters - distance to consider a significant position change
        const UPDATE_INTERVAL = 16; // ms - more frequent updates for smoother animation (approx 60fps)
        const STATIONARY_POSITION_HISTORY_SIZE = 15; // Number of positions to keep for stationary averaging
        const STATIONARY_POSITION_WEIGHT_DECAY = 0.9; // Weight decay for older positions in stationary average

        // Background handling constants
        const BACKGROUND_THRESHOLD = 20000; // ms - time to consider app was in background
        const INACTIVITY_TIMEOUT = 29000; // ms - time to consider user inactive (changed to 29 seconds)

        // Kalman filter parameters - optimized for better stationary stability
        const KALMAN_PROCESS_NOISE = 0.004; // Lower value for smoother tracking
        const KALMAN_MEASUREMENT_NOISE_BASE = 1.2; // Increased base measurement noise
        const KALMAN_STATIONARY_NOISE = 0.02; // Lower noise when stationary

        // Animation parameters
        const ANIMATION_DURATION = 180; // ms - duration of position animation
        const HEADING_SMOOTHING = 0.9; // Heading smoothing factor

        // Dynamic zoom level parameters - enhanced for better speed adaptation
        const MAX_ZOOM_LEVEL = 17; // Maximum zoom level (stationary)
        const MIN_ZOOM_LEVEL = 13; // Minimum zoom level (high speed)
        const DEFAULT_ZOOM_LEVEL = 17; // Default zoom level for walking speed
        const PROXIMITY_ZOOM_LEVEL = 18; // Zoom level when in proximity to a location
        const WALKING_SPEED_THRESHOLD = 1.5; // m/s - threshold for walking speed
        const RUNNING_SPEED_THRESHOLD = 4.0; // m/s - threshold for running speed
        const DRIVING_SPEED_THRESHOLD = 8.0; // m/s - threshold for driving speed
        const HIGH_SPEED_THRESHOLD = 20.0; // m/s - threshold for high speed
        const ZOOM_TRANSITION_DURATION = 0.5; // seconds - duration of zoom transition
        const ZOOM_UPDATE_INTERVAL = 1000; // ms - interval to update zoom level

        // Motion detection parameters
        const MOTION_THRESHOLD = 0.6; // Threshold for detecting significant motion
        const MOTION_SAMPLE_SIZE = 8; // Number of motion samples to keep
        const MOTION_CHECK_INTERVAL = 100; // ms - interval to check motion

        // Edge detection parameters - updated for better recentering
        const EDGE_THRESHOLD_PERCENTAGE = 0.15; // Percentage from edge to trigger recenter
        const STRICT_EDGE_THRESHOLD_PERCENTAGE = 0.1; // Stricter threshold for edge detection
        const CRITICAL_EDGE_THRESHOLD_PERCENTAGE = 0.05; // Critical threshold for immediate recenter
        const RECENTER_COOLDOWN = 500; // ms - cooldown between recenters to prevent excessive recentering

        // Dynamic recentering parameters
        const SPEED_RECENTER_THRESHOLD = 5.0; // m/s - speed threshold to adjust recenter behavior
        const RECENTER_OFFSET_FACTOR = 0.3; // Factor to offset the center point ahead of user when moving fast

        // State variables
        let lastUpdateTime = null;
        let lastVelocity = { lat: 0, lng: 0 };
        let isStationary = false;
        let stationaryStartTime = null;
        let stationaryCheckTimeout = null;
        let lastUpdateTimestamp = null;
        let lastHiddenTime = 0;
        let stationaryCount = 0;
        let lastRecenterTime = Date.now();
        let stationaryBuffer = [];
        let isStabilizing = true; // Flag to track initial stabilization
        let lastStationaryPosition = null; // Last stable position when stationary
        let motionSamples = []; // Array to store motion samples
        let deviceStationaryTime = 0; // Time device has been stationary based on motion sensors
        let animationFrameId = null; // Store requestAnimationFrame ID
        let renderTimestamp = null; // Last render timestamp
        let positionUpdateQueue = []; // Queue for position updates to be processed
        let lastHeadingValue = null; // Last heading value
        let headingBuffer = []; // Buffer for heading values
        let isFirstPositionUpdate = true; // Flag for first position update
        let lastRenderPosition = null; // Last rendered position
        let positionInterpolator = null; // Position interpolator for smooth transitions
        let lastRawPosition = null; // Last raw position from GPS
        let consecutiveStationaryUpdates = 0; // Count consecutive stationary updates
        let lastDeviceMotionTimestamp = 0; // Last device motion timestamp
        let deviceMotionBuffer = []; // Buffer for device motion data
        let isDeviceStable = false; // Flag for device stability
        let lastAccuracy = null; // Last position accuracy
        let accuracyTrend = []; // Track accuracy trend
        let lastHeadingUpdateTime = 0; // Last heading update time
        let lastPositionUpdateTime = 0; // Last position update time
        let lastZoomUpdateTime = 0; // Last zoom update time
        let targetZoomLevel = DEFAULT_ZOOM_LEVEL; // Target zoom level for smooth transitions
        let lastSpeedForZoom = 0; // Last speed used for zoom calculation
        let speedSamples = []; // Array to store speed samples for zoom calculation
        let lastRecenterCheckTime = 0; // Last time we checked for recentering
        let lastProximityCheckTime = 0; // Last time we checked for proximity
        let proximityZoomActive = false; // Flag to track if proximity zoom is active
        let forceCenteringActive = false; // Flag to force centering regardless of other conditions
        let centeringPriority = 0; // Priority level for centering (0-10)
        let userInteractionTime = Date.now(); // Track when user last interacted with the map
        let smoothTransitionActive = false; // Flag to track if a smooth transition is active

        // Enhanced Kalman Filter implementation
        class KalmanFilter {
            constructor() {
                // State variables
                this.x = 0; // Longitude estimate
                this.y = 0; // Latitude estimate
                this.vx = 0; // Longitude velocity
                this.vy = 0; // Latitude velocity

                // Error covariance matrix
                this.P = [
                    [100, 0, 0, 0], // Initial high uncertainty
                    [0, 100, 0, 0],
                    [0, 0, 10, 0],
                    [0, 0, 0, 10],
                ];

                // Process noise
                this.Q = KALMAN_PROCESS_NOISE;

                // Measurement noise (will be adjusted based on GPS accuracy)
                this.R = KALMAN_MEASUREMENT_NOISE_BASE;

                // Time delta
                this.dt = 1.0;

                // Initialized flag
                this.initialized = false;

                // Heading and accuracy tracking
                this.lastHeading = null;
                this.headingConfidence = 0;

                // Stationary mode flag
                this.stationaryMode = false;

                // Last timestamp
                this.lastTimestamp = null;

                // Adaptive noise parameters
                this.adaptiveNoiseMin = 0.002;
                this.adaptiveNoiseMax = 0.015;
                this.adaptiveNoiseFactor = 1.0;

                // Accuracy history
                this.accuracyHistory = [];
                this.maxAccuracyHistorySize = 5;

                // Jitter detection
                this.positionHistory = [];
                this.maxPositionHistorySize = 5;
                this.jitterThreshold = 0.5; // meters

                // Heading stability
                this.headingHistory = [];
                this.maxHeadingHistorySize = 8;
            }

            // Initialize the filter with first position
            reset(position) {
                if (!position || typeof position.lat !== "number" || typeof position.lng !== "number") {
                    console.error("Invalid position for Kalman filter reset");
                    return;
                }

                this.x = position.lng;
                this.y = position.lat;
                this.vx = 0;
                this.vy = 0;

                // Reset covariance matrix with high initial uncertainty
                this.P = [
                    [100, 0, 0, 0],
                    [0, 100, 0, 0],
                    [0, 0, 10, 0],
                    [0, 0, 0, 10],
                ];

                this.initialized = true;
                this.lastHeading = position.heading || null;
                this.headingConfidence = 0;
                this.stationaryMode = false;
                this.lastTimestamp = position.timestamp || Date.now();
                this.adaptiveNoiseFactor = 1.0;
                this.accuracyHistory = [];
                this.positionHistory = [];
                this.headingHistory = [];

                // Add initial position to history
                this.addToPositionHistory(position);
                if (position.accuracy) {
                    this.addToAccuracyHistory(position.accuracy);
                }
                if (position.heading !== null && position.heading !== undefined) {
                    this.addToHeadingHistory(position.heading);
                }
            }

            // Add position to history
            addToPositionHistory(position) {
                this.positionHistory.push({
                    lat: position.lat,
                    lng: position.lng,
                    timestamp: position.timestamp || Date.now(),
                });

                while (this.positionHistory.length > this.maxPositionHistorySize) {
                    this.positionHistory.shift();
                }
            }

            // Add accuracy to history
            addToAccuracyHistory(accuracy) {
                this.accuracyHistory.push(accuracy);

                while (this.accuracyHistory.length > this.maxAccuracyHistorySize) {
                    this.accuracyHistory.shift();
                }
            }

            // Add heading to history
            addToHeadingHistory(heading) {
                // Normalize heading to 0-360 range
                heading = ((heading % 360) + 360) % 360;

                this.headingHistory.push({
                    heading: heading,
                    timestamp: Date.now(),
                });

                while (this.headingHistory.length > this.maxHeadingHistorySize) {
                    this.headingHistory.shift();
                }
            }

            // Get median accuracy from history
            getMedianAccuracy() {
                if (this.accuracyHistory.length === 0) return 20;

                const sortedAccuracies = [...this.accuracyHistory].sort((a, b) => a - b);
                const mid = Math.floor(sortedAccuracies.length / 2);

                if (sortedAccuracies.length % 2 === 0) {
                    return (sortedAccuracies[mid - 1] + sortedAccuracies[mid]) / 2;
                } else {
                    return sortedAccuracies[mid];
                }
            }

            // Detect jitter in position history
            detectJitter() {
                if (this.positionHistory.length < 3) return false;

                // Calculate distances between consecutive positions
                const distances = [];
                for (let i = 1; i < this.positionHistory.length; i++) {
                    const p1 = this.positionHistory[i - 1];
                    const p2 = this.positionHistory[i];

                    // Calculate distance in meters
                    const distance = calculateDistance(p1, p2);

                    // Calculate time delta in seconds
                    const timeDelta = (p2.timestamp - p1.timestamp) / 1000;

                    // Calculate speed in m/s
                    const speed = timeDelta > 0 ? distance / timeDelta : 0;

                    distances.push({ distance, speed });
                }

                // Check for rapid direction changes (jitter)
                if (distances.length >= 2) {
                    const lastDistance = distances[distances.length - 1].distance;
                    const prevDistance = distances[distances.length - 2].distance;

                    // If both distances are small but non-zero, it might be jitter
                    if (
                        lastDistance > 0 &&
                        lastDistance < this.jitterThreshold &&
                        prevDistance > 0 &&
                        prevDistance < this.jitterThreshold
                    ) {
                        return true;
                    }
                }

                return false;
            }

            // Get stable heading from history
            getStableHeading() {
                if (this.headingHistory.length < 3) {
                    return this.lastHeading;
                }

                // Get recent headings (last 3)
                const recentHeadings = this.headingHistory.slice(-3).map((h) => h.heading);

                // Check if headings are stable (within 15 degrees of each other)
                let isStable = true;
                for (let i = 1; i < recentHeadings.length; i++) {
                    const diff = Math.abs(recentHeadings[i] - recentHeadings[i - 1]);
                    const normalizedDiff = Math.min(diff, 360 - diff);
                    if (normalizedDiff > 15) {
                        isStable = false;
                        break;
                    }
                }

                if (isStable) {
                    // Return median heading
                    const sortedHeadings = [...recentHeadings].sort((a, b) => a - b);
                    return sortedHeadings[Math.floor(sortedHeadings.length / 2)];
                }

                return this.lastHeading;
            }

            // Set stationary mode
            setStationaryMode(isStationary) {
                this.stationaryMode = isStationary;

                // When entering stationary mode, reduce velocity to zero
                if (isStationary) {
                    this.vx = 0;
                    this.vy = 0;

                    // Reduce process noise for stationary mode
                    this.Q = KALMAN_STATIONARY_NOISE;
                    this.adaptiveNoiseFactor = 0.4; // Reduce noise in stationary mode
                } else {
                    // Reset to normal process noise when moving
                    this.Q = KALMAN_PROCESS_NOISE;
                    this.adaptiveNoiseFactor = 1.0; // Normal noise when moving
                }
            }

            // Adjust process noise based on accuracy and motion
            adjustProcessNoise(accuracy, motionDetected) {
                // Base noise level depends on GPS accuracy
                let noiseLevel =
                    this.adaptiveNoiseMin + (this.adaptiveNoiseMax - this.adaptiveNoiseMin) * Math.min(1.0, accuracy / 40.0);

                // Reduce noise when stationary
                if (this.stationaryMode) {
                    noiseLevel *= 0.4;
                }

                // Increase noise when motion is detected
                if (motionDetected && !this.stationaryMode) {
                    noiseLevel *= 1.8;
                }

                // Increase noise when jitter is detected
                if (this.detectJitter()) {
                    noiseLevel *= 0.5; // Reduce noise to smooth out jitter
                }

                // Apply adaptive factor
                noiseLevel *= this.adaptiveNoiseFactor;

                // Set process noise
                this.Q = noiseLevel;
            }

            // Update the filter with new measurement
            update(position, motionDetected = false) {
                if (!this.initialized) {
                    this.reset(position);
                    return position;
                }

                if (!position || typeof position.lat !== "number" || typeof position.lng !== "number") {
                    console.warn("Invalid position input to Kalman filter");
                    return {
                        lat: this.y,
                        lng: this.x,
                        accuracy: position?.accuracy || 20,
                        heading: this.lastHeading,
                        timestamp: position?.timestamp || Date.now(),
                    };
                }

                // Add to position history
                this.addToPositionHistory(position);

                // Add to accuracy history
                if (position.accuracy) {
                    this.addToAccuracyHistory(position.accuracy);
                }

                // Add to heading history
                if (position.heading !== null && position.heading !== undefined) {
                    this.addToHeadingHistory(position.heading);
                }

                // Calculate time delta
                const timestamp = position.timestamp || Date.now();
                if (this.lastTimestamp) {
                    this.dt = Math.min(Math.max((timestamp - this.lastTimestamp) / 1000, 0.01), 1.0);
                }
                this.lastTimestamp = timestamp;

                // Adjust measurement noise based on GPS accuracy
                const accuracy = position.accuracy || 20;
                const medianAccuracy = this.getMedianAccuracy();
                this.R = Math.max(KALMAN_MEASUREMENT_NOISE_BASE, medianAccuracy / 10);

                // If in stationary mode, increase measurement noise to reduce jitter
                if (this.stationaryMode) {
                    this.R *= 2.0;
                }

                // Adjust process noise based on accuracy and motion
                this.adjustProcessNoise(accuracy, motionDetected);

                // State transition matrix
                const F = [
                    [1, 0, this.dt, 0],
                    [0, 1, 0, this.dt],
                    [0, 0, 1, 0],
                    [0, 0, 0, 1],
                ];

                // Predict step
                // x = F * x
                const predictedX = this.x + this.dt * this.vx;
                const predictedY = this.y + this.dt * this.vy;
                const predictedVx = this.stationaryMode ? 0 : this.vx;
                const predictedVy = this.stationaryMode ? 0 : this.vy;

                // P = F * P * F' + Q
                const Q = [
                    [(this.Q * this.dt * this.dt * this.dt * this.dt) / 4, 0, (this.Q * this.dt * this.dt * this.dt) / 2, 0],
                    [0, (this.Q * this.dt * this.dt * this.dt * this.dt) / 4, 0, (this.Q * this.dt * this.dt * this.dt) / 2],
                    [(this.Q * this.dt * this.dt * this.dt) / 2, 0, this.Q * this.dt * this.dt, 0],
                    [0, (this.Q * this.dt * this.dt * this.dt) / 2, 0, this.Q * this.dt * this.dt],
                ];

                // Matrix multiplication F * P
                const FP = [
                    [
                        this.P[0][0] + this.dt * this.P[2][0],
                        this.P[0][1] + this.dt * this.P[2][1],
                        this.P[0][2] + this.dt * this.P[2][2],
                        this.P[0][3] + this.dt * this.P[2][3],
                    ],
                    [
                        this.P[1][0] + this.dt * this.P[3][0],
                        this.P[1][1] + this.dt * this.P[3][1],
                        this.P[1][2] + this.dt * this.P[3][2],
                        this.P[1][3] + this.dt * this.P[3][3],
                    ],
                    [this.P[2][0], this.P[2][1], this.P[2][2], this.P[2][3]],
                    [this.P[3][0], this.P[3][1], this.P[3][2], this.P[3][3]],
                ];

                // Matrix multiplication FP * F'
                const predictedP = [
                    [
                        FP[0][0] + this.dt * FP[0][2] + Q[0][0],
                        FP[0][1] + this.dt * FP[0][3] + Q[0][1],
                        FP[0][2] + Q[0][2],
                        FP[0][3] + Q[0][3],
                    ],
                    [
                        FP[1][0] + this.dt * FP[1][2] + Q[1][0],
                        FP[1][1] + this.dt * FP[1][3] + Q[1][1],
                        FP[1][2] + Q[1][2],
                        FP[1][3] + Q[1][3],
                    ],
                    [FP[2][0] + Q[2][0], FP[2][1] + Q[2][1], FP[2][2] + Q[2][2], FP[2][3] + Q[2][3]],
                    [FP[3][0] + Q[3][0], FP[3][1] + Q[3][1], FP[3][2] + Q[3][2], FP[3][3] + Q[3][3]],
                ];

                // Update step
                // y = z - H * x
                const measurementResidualX = position.lng - predictedX;
                const measurementResidualY = position.lat - predictedY;

                // S = H * P * H' + R
                const S = [
                    [predictedP[0][0] + this.R, predictedP[0][1]],
                    [predictedP[1][0], predictedP[1][1] + this.R],
                ];

                // Calculate determinant of S
                const detS = S[0][0] * S[1][1] - S[0][1] * S[1][0];

                // Calculate inverse of S
                const invS = [
                    [S[1][1] / detS, -S[0][1] / detS],
                    [-S[1][0] / detS, S[0][0] / detS],
                ];

                // K = P * H' * inv(S)
                const K = [
                    [
                        predictedP[0][0] * invS[0][0] + predictedP[0][1] * invS[1][0],
                        predictedP[0][0] * invS[0][1] + predictedP[0][1] * invS[1][1],
                    ],
                    [
                        predictedP[1][0] * invS[0][0] + predictedP[1][1] * invS[1][0],
                        predictedP[1][0] * invS[0][1] + predictedP[1][1] * invS[1][1],
                    ],
                    [
                        predictedP[2][0] * invS[0][0] + predictedP[2][1] * invS[1][0],
                        predictedP[2][0] * invS[0][1] + predictedP[2][1] * invS[1][1],
                    ],
                    [
                        predictedP[3][0] * invS[0][0] + predictedP[3][1] * invS[1][0],
                        predictedP[3][0] * invS[0][1] + predictedP[3][1] * invS[1][1],
                    ],
                ];

                // x = x + K * y
                this.x = predictedX + K[0][0] * measurementResidualX + K[0][1] * measurementResidualY;
                this.y = predictedY + K[1][0] * measurementResidualX + K[1][1] * measurementResidualY;

                // In stationary mode, keep velocity at zero
                if (this.stationaryMode) {
                    this.vx = 0;
                    this.vy = 0;
                } else {
                    this.vx = predictedVx + K[2][0] * measurementResidualX + K[2][1] * measurementResidualY;
                    this.vy = predictedVy + K[3][0] * measurementResidualX + K[3][1] * measurementResidualY;
                }

                // P = (I - K * H) * P
                this.P = [
                    [
                        predictedP[0][0] - (K[0][0] * predictedP[0][0] + K[0][1] * predictedP[1][0]),
                        predictedP[0][1] - (K[0][0] * predictedP[0][1] + K[0][1] * predictedP[1][1]),
                        predictedP[0][2] - (K[0][0] * predictedP[0][2] + K[0][1] * predictedP[1][2]),
                        predictedP[0][3] - (K[0][0] * predictedP[0][3] + K[0][1] * predictedP[1][3]),
                    ],
                    [
                        predictedP[1][0] - (K[1][0] * predictedP[0][0] + K[1][1] * predictedP[1][0]),
                        predictedP[1][1] - (K[1][0] * predictedP[0][1] + K[1][1] * predictedP[1][1]),
                        predictedP[1][2] - (K[1][0] * predictedP[0][2] + K[1][1] * predictedP[1][2]),
                        predictedP[1][3] - (K[1][0] * predictedP[0][3] + K[1][1] * predictedP[1][3]),
                    ],
                    [
                        predictedP[2][0] - (K[2][0] * predictedP[0][0] + K[2][1] * predictedP[1][0]),
                        predictedP[2][1] - (K[2][0] * predictedP[0][1] + K[2][1] * predictedP[1][1]),
                        predictedP[2][2] - (K[2][0] * predictedP[0][2] + K[2][1] * predictedP[1][2]),
                        predictedP[2][3] - (K[2][0] * predictedP[0][3] + K[2][1] * predictedP[1][3]),
                    ],
                    [
                        predictedP[3][0] - (K[3][0] * predictedP[0][0] + K[3][1] * predictedP[1][0]),
                        predictedP[3][1] - (K[3][0] * predictedP[0][1] + K[3][1] * predictedP[1][1]),
                        predictedP[3][2] - (K[3][0] * predictedP[0][2] + K[3][1] * predictedP[1][2]),
                        predictedP[3][3] - (K[3][0] * predictedP[0][3] + K[3][1] * predictedP[1][3]),
                    ],
                ];

                // Process heading data
                let smoothedHeading = position.heading;
                if (position.heading !== null && position.heading !== undefined) {
                    // Get stable heading from history
                    smoothedHeading = this.getStableHeading();

                    // If no stable heading yet, use current heading
                    if (smoothedHeading === null) {
                        smoothedHeading = position.heading;
                    }

                    this.lastHeading = smoothedHeading;
                }

                // Calculate speed from velocity components
                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);

                return {
                    lat: this.y,
                    lng: this.x,
                    accuracy: position.accuracy,
                    heading: smoothedHeading,
                    timestamp: position.timestamp,
                    speedMPS: this.stationaryMode ? 0 : speed * 111000, // Convert from degrees/second to meters/second (approximate)
                };
            }
        }

        // Position interpolator for smooth transitions
        class PositionInterpolator {
            constructor() {
                this.startPosition = null;
                this.targetPosition = null;
                this.startTime = null;
                this.duration = 0;
                this.isActive = false;
                this.lastInterpolatedPosition = null;
            }

            start(startPos, targetPos, duration) {
                if (!startPos || !targetPos) return;

                // Don't interpolate if positions are too close
                const distance = calculateDistance(startPos, targetPos);
                if (distance < 0.1) {
                    this.isActive = false;
                    this.lastInterpolatedPosition = targetPos;
                    return;
                }

                this.startPosition = { ...startPos };
                this.targetPosition = { ...targetPos };
                this.startTime = performance.now();
                this.duration = duration;
                this.isActive = true;
            }

            update() {
                if (!this.isActive) return this.lastInterpolatedPosition || this.targetPosition;

                const now = performance.now();
                const elapsed = now - this.startTime;

                if (elapsed >= this.duration) {
                    this.isActive = false;
                    this.lastInterpolatedPosition = this.targetPosition;
                    return this.targetPosition;
                }

                // Calculate progress with easing
                const t = elapsed / this.duration;
                const easedT = this.easeOutCubic(t);

                // Interpolate position
                const interpolatedPosition = {
                    lat: this.startPosition.lat + (this.targetPosition.lat - this.startPosition.lat) * easedT,
                    lng: this.startPosition.lng + (this.targetPosition.lng - this.startPosition.lng) * easedT,
                    accuracy: this.targetPosition.accuracy,
                    heading: this.targetPosition.heading,
                    timestamp: now,
                    speedMPS: this.targetPosition.speedMPS,
                };

                this.lastInterpolatedPosition = interpolatedPosition;
                return interpolatedPosition;
            }

            // Cubic easing function for smoother motion
            easeOutCubic(t) {
                return 1 - Math.pow(1 - t, 3);
            }

            isInterpolating() {
                return this.isActive;
            }

            cancel() {
                this.isActive = false;
            }

            getLastPosition() {
                return this.lastInterpolatedPosition || this.targetPosition;
            }
        }

        // Create Kalman filter instance
        const kalmanFilter = new KalmanFilter();

        // Create position interpolator
        positionInterpolator = new PositionInterpolator();

        // Calculate distance between two points using Haversine formula
        function calculateDistance(pos1, pos2) {
            if (
                !pos1 ||
                !pos2 ||
                typeof pos1.lat !== "number" ||
                typeof pos1.lng !== "number" ||
                typeof pos2.lat !== "number" ||
                typeof pos2.lng !== "number"
            ) {
                return Number.POSITIVE_INFINITY;
            }

            const R = 6371000; // Earth's radius in meters
            const lat1 = (pos1.lat * Math.PI) / 180;
            const lat2 = (pos2.lat * Math.PI) / 180;
            const deltaLat = ((pos2.lat - pos1.lat) * Math.PI) / 180;
            const deltaLng = ((pos2.lng - pos1.lng) * Math.PI) / 180;

            const a =
                Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) +
                Math.cos(lat1) * Math.cos(lat2) * Math.sin(deltaLng / 2) * Math.sin(deltaLng / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

            return R * c;
        }

        // Check if device is in motion based on motion sensors
        function isDeviceInMotion() {
            if (!motionSamples || motionSamples.length < 3) {
                return false;
            }

            // Calculate average motion magnitude
            const avgMotion =
                motionSamples.reduce((sum, sample) => {
                    return sum + Math.sqrt(sample.x * sample.x + sample.y * sample.y + sample.z * sample.z);
                }, 0) / motionSamples.length;

            return avgMotion > MOTION_THRESHOLD;
        }

        // Process device motion data
        function handleDeviceMotion(event) {
            if (!event || !event.acceleration) return;

            const now = Date.now();
            // Throttle motion updates for better performance
            if (now - lastDeviceMotionTimestamp < 50) return;
            lastDeviceMotionTimestamp = now;

            const motion = {
                x: event.acceleration.x || 0,
                y: event.acceleration.y || 0,
                z: event.acceleration.z || 0,
                timestamp: now,
            };

            // Add to motion samples
            motionSamples.push(motion);

            // Keep only recent samples
            while (motionSamples.length > MOTION_SAMPLE_SIZE) {
                motionSamples.shift();
            }

            // Update device motion state
            deviceMotion = motion;

            // Add to device motion buffer for stability detection
            deviceMotionBuffer.push({
                magnitude: Math.sqrt(motion.x * motion.x + motion.y * motion.y + motion.z * motion.z),
                timestamp: now,
            });

            // Keep buffer at reasonable size
            while (deviceMotionBuffer.length > 10) {
                deviceMotionBuffer.shift();
            }

            // Check if device is stationary based on motion
            const inMotion = isDeviceInMotion();

            if (!inMotion) {
                deviceStationaryTime += 50; // Increment by throttle time
            } else {
                deviceStationaryTime = 0;
            }
        }

        // Process device orientation data
        function handleDeviceOrientation(event) {
            if (!event || event.alpha === null) return;

            const now = Date.now();
            // Throttle heading updates
            if (now - lastHeadingUpdateTime < 100) return;
            lastHeadingUpdateTime = now;

            deviceOrientation = {
                alpha: event.alpha, // z-axis rotation [0,360)
                beta: event.beta, // x-axis rotation [-180,180)
                gamma: event.gamma, // y-axis rotation [-90,90)
                timestamp: now,
            };

            // Update heading buffer if we have a compass heading
            if (event.webkitCompassHeading !== undefined) {
                const heading = event.webkitCompassHeading;

                // Add to heading buffer
                headingBuffer.push(heading);

                // Keep only recent headings
                while (headingBuffer.length > 8) {
                    headingBuffer.shift();
                }

                // Calculate median heading to filter outliers
                if (headingBuffer.length >= 3) {
                    const sortedHeadings = [...headingBuffer].sort((a, b) => a - b);
                    lastHeadingValue = sortedHeadings[Math.floor(sortedHeadings.length / 2)];
                }
            }
        }

        // Request device motion and orientation permissions
        function requestMotionPermission() {
            if (typeof DeviceMotionEvent !== "undefined" && typeof DeviceMotionEvent.requestPermission === "function") {
                DeviceMotionEvent.requestPermission()
                    .then((response) => {
                        if (response === "granted") {
                            window.addEventListener("devicemotion", handleDeviceMotion, true);
                        }
                    })
                    .catch(console.error);
            } else {
                window.addEventListener("devicemotion", handleDeviceMotion, true);
            }

            if (typeof DeviceOrientationEvent !== "undefined" && typeof DeviceOrientationEvent.requestPermission === "function") {
                DeviceOrientationEvent.requestPermission()
                    .then((response) => {
                        if (response === "granted") {
                            orientationPermissionGranted = true;
                            window.addEventListener("deviceorientation", handleDeviceOrientation, true);
                        }
                    })
                    .catch(console.error);
            } else {
                window.addEventListener("deviceorientation", handleDeviceOrientation, true);
                orientationPermissionGranted = true;
            }
        }

        // Animation loop for smooth rendering
        function startAnimationLoop() {
            function animate(timestamp) {
                // Calculate delta time
                const deltaTime = renderTimestamp ? (timestamp - renderTimestamp) / 1000 : 0;
                renderTimestamp = timestamp;

                // Process position updates
                processPositionUpdateQueue();

                // Update interpolated position
                if (positionInterpolator && positionInterpolator.isInterpolating()) {
                    const interpolatedPosition = positionInterpolator.update();
                    if (interpolatedPosition) {
                        // Update marker position
                        userMarker.setLatLng([interpolatedPosition.lat, interpolatedPosition.lng]);
                        lastRenderPosition = interpolatedPosition;

                        // Update marker rotation if heading is available
                        if (interpolatedPosition.heading !== null && interpolatedPosition.heading !== undefined) {
                            updateMarkerRotation(interpolatedPosition.heading);
                        }
                    }
                }

                // Only keep user centered if followUser is true and user is not interacting with map
                // This is the key change to allow free pinch/pan/zoom
                if (followUser && !isMapInteracting && !userIsInteracting) {
                    if (userMarker && userMarker.getLatLng()) {
                        map.setView(userMarker.getLatLng(), map.getZoom(), {
                            animate: true,
                            duration: 0.3,
                            noMoveStart: true
                        });
                    }
                }

                // Update zoom level based on speed and proximity
                updateDynamicZoom();

                // Check for proximity to locations
                if (Date.now() - lastProximityCheckTime > 500) {
                    checkProximityForZoom();
                    lastProximityCheckTime = Date.now();
                }

                // Request next frame
                animationFrameId = requestAnimationFrame(animate);
            }

            // Start animation loop
            animationFrameId = requestAnimationFrame(animate);
        }

        // Update marker rotation based on heading
        function updateMarkerRotation(heading) {
            const markerElement = userMarker.getElement();
            if (markerElement) {
                const iconElement = markerElement.querySelector(".user-marker-icon");
                if (iconElement) {
                    // Apply smooth rotation with CSS transform
                    iconElement.style.transform = `rotate(${heading}deg)`;
                }
            }
        }

        // Process position update queue
        function processPositionUpdateQueue() {
            if (positionUpdateQueue.length === 0) return;

            // Process all updates in queue
            while (positionUpdateQueue.length > 0) {
                const update = positionUpdateQueue.shift();
                processPositionUpdate(update);
            }
        }

        function processPositionUpdate(position) {
            // Validate position
            if (!position || typeof position.lat !== "number" || typeof position.lng !== "number") {
                return;
            }

            // Update tracking variables
            lastPosition = position;
            currentSpeed = position.speedMPS || 0;
            
            // Maintain speed samples (5-point buffer)
            speedSamples.push(currentSpeed);
            if (speedSamples.length > 5) speedSamples.shift();

            // Update marker stationary state
            const markerElement = userMarker.getElement();
            if (markerElement) {
                markerElement.classList.toggle("user-marker-stationary", isStationary);
            }

            // Calculate movement distance if we have previous position
            const distance = lastRenderPosition ? calculateDistance(lastRenderPosition, position) : 0;

            // Handle position update
            if (!lastRenderPosition || isFirstPositionUpdate) {
                // Initial position - set directly
                userMarker.setLatLng([position.lat, position.lng]);
                lastRenderPosition = position;
                isFirstPositionUpdate = false;
            } 
            else if (distance > EXTENDED_DISTANCE_THRESHOLD) {
                // Large movement - update immediately without animation
                userMarker.setLatLng([position.lat, position.lng]);
                lastRenderPosition = position;
                
                // Cancel any ongoing animation
                if (positionInterpolator) {
                    positionInterpolator.cancel();
                }
            }
            else {
                // Normal movement - apply smooth interpolation
                const animDuration = isStationary ? 
                    (distance < 0.5 ? 600 : 400) : // Longer duration for stationary micro-movements
                    ANIMATION_DURATION;
                
                positionInterpolator.start(lastRenderPosition, position, animDuration);
            }

            // Update marker rotation if heading available
            if (position.heading !== null && position.heading !== undefined) {
                updateMarkerRotation(position.heading);
            }

            // Only keep user centered if followUser is true and user is not interacting with map
            // This is the key change to allow free pinch/pan/zoom
            if (followUser && !isMapInteracting && !userIsInteracting) {
                map.setView([position.lat, position.lng], map.getZoom(), {
                    animate: true,
                    duration: 0.3
                });
            }
            
            // Check nearby points of interest
            checkNearbyLocations();
        }
        
        // Check for proximity to locations for zoom level adjustment
        function checkProximityForZoom() {
            if (!lastPosition || !gameLocations || gameLocations.length === 0) return;
            
            // Only check the current location
            const location = gameLocations[currentLocationIndex];
            if (!location) return;
            
            // Calculate distance to current location
            const distance = calculateDistance(
                { lat: lastPosition.lat, lng: lastPosition.lng },
                { lat: location.lat, lng: location.lng }
            );
            
            // Convert to feet
            const distanceFeet = Math.round(distance * 3.28084);
            
            // Check if user is within proximity threshold
            const withinProximity = distanceFeet <= PROXIMITY_THRESHOLD;
            
            // Only update if proximity state has changed
            if (withinProximity !== isWithinProximity) {
                isWithinProximity = withinProximity;
                
                // Adjust zoom level based on proximity
                if (isWithinProximity && !proximityZoomActive) {
                    // Zoom in when entering proximity
                    proximityZoomActive = true;
                    if (map && followUser) {
                        map.setZoom(PROXIMITY_ZOOM_LEVEL, {
                            animate: true,
                            duration: 1.0,
                            noMoveStart: true
                        });
                    }
                } else if (!isWithinProximity && proximityZoomActive) {
                    // Zoom out when leaving proximity
                    proximityZoomActive = false;
                    if (map && followUser) {
                        map.setZoom(DEFAULT_ZOOM_LEVEL, {
                            animate: true,
                            duration: 1.0,
                            noMoveStart: true
                        });
                    }
                }
            }
        }

        // Check for nearby locations
        function checkNearbyLocations() {
            if (!lastPosition || !gameLocations || isLocationHuntVisible) return;
            
            // Only check the current location (progressive display)
            const location = gameLocations[currentLocationIndex];
            if (!location) return;
            
            // Skip if already visited
            if (visitedLocations.includes(location.id)) return;
            
            const distance = calculateDistance(
                { lat: lastPosition.lat, lng: lastPosition.lng },
                { lat: location.lat, lng: location.lng }
            );
            
            // Convert to feet
            const distanceFeet = Math.round(distance * 3.28084);
            
            // Update distance box
            updateDistanceBox(location, distanceFeet);
            
            // Check if user is close enough to interact
            if (distanceFeet <= DISTANCE_THRESHOLD) {
                showLocationHunt(location);
            }
        }
        
        // Update distance box with location info
        function updateDistanceBox(location, distanceFeet) {
            const distanceBox = document.getElementById('distanceBox');
            if (distanceBox) {
                const locationNameElement = distanceBox.querySelector('.location-name');
                const distanceValueElement = distanceBox.querySelector('.distance-value');
                
                if (locationNameElement && distanceValueElement) {
                    locationNameElement.textContent = location.name;
                    
                    // Format distance based on value
                    let distanceText;
                    if (distanceFeet > 5280) {
                        // Convert to miles and round to 1 decimal place
                        const distanceMiles = (distanceFeet / 5280).toFixed(1);
                        distanceText = `${distanceMiles} miles away`;
                    } else if (distanceFeet === 5280) {
                        distanceText = "1 mile away";
                    } else {
                        distanceText = `${distanceFeet} feet away`;
                    }
                    
                    distanceValueElement.textContent = distanceText;
                }
            }
        }

        // Create navigation links for a location
        function createNavigationLinks(location) {
            // Google Maps
            const googleMapsLink = document.getElementById('googleMapsLink');
            if (googleMapsLink) {
                googleMapsLink.href = `https://www.google.com/maps/dir/?api=1&destination=${location.lat},${location.lng}&travelmode=walking`;
            }
            
            // Apple Maps (iOS only)
            const appleMapsLink = document.getElementById('appleMapsLink');
            if (appleMapsLink) {
                appleMapsLink.href = `maps://maps.apple.com/?daddr=${location.lat},${location.lng}&dirflg=w`;
                
                // Hide Apple Maps link on non-iOS devices
                const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
                appleMapsLink.style.display = isIOS ? 'flex' : 'none';
            }
            
            // Waze
            const wazeLink = document.getElementById('wazeLink');
            if (wazeLink) {
                wazeLink.href = `https://waze.com/ul?ll=${location.lat},${location.lng}&navigate=yes`;
            }
        }
        
        // Set up directions modal links
        function setupDirectionsModal(location) {
            currentDirectionsLocation = location;
            
            // Google Maps
            const googleMapsBtn = document.getElementById('googleMapsBtn');
            if (googleMapsBtn) {
                googleMapsBtn.href = `https://www.google.com/maps/dir/?api=1&destination=${location.lat},${location.lng}&travelmode=walking`;
            }
            
            // Apple Maps (iOS only)
            const appleMapsBtn = document.getElementById('appleMapsBtn');
            if (appleMapsBtn) {
                appleMapsBtn.href = `maps://maps.apple.com/?daddr=${location.lat},${location.lng}&dirflg=w`;
                
                // Hide Apple Maps button on non-iOS devices
                const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
                appleMapsBtn.style.display = isIOS ? 'flex' : 'none';
            }
            
            // Waze
            const wazeBtn = document.getElementById('wazeBtn');
            if (wazeBtn) {
                wazeBtn.href = `https://waze.com/ul?ll=${location.lat},${location.lng}&navigate=yes`;
            }
        }
        
        // Show directions modal
        function showDirectionsModal(location) {
            setupDirectionsModal(location);
            document.getElementById('directionsModal').style.display = 'flex';
        }
        
        // Close directions modal
        function closeDirectionsModal() {
            document.getElementById('directionsModal').style.display = 'none';
        }
        
        // Skip to next location
        function skipToNextLocation() {
            // Close any open popups
            map.closePopup();
            
            // Remove the current marker from the map
            if (currentLocationIndex < allLocationMarkers.length) {
                map.removeLayer(allLocationMarkers[currentLocationIndex]);
            }
            
            // Move to next location
            currentLocationIndex++;
            
            // Check if we've reached the end
            if (currentLocationIndex >= gameLocations.length) {
                showCongratulations();
            } else {
                // Update visible markers
                updateVisibleMarkers();
                
                // Update distance box for new location
                const location = gameLocations[currentLocationIndex];
                if (location && lastPosition) {
                    const distance = calculateDistance(
                        { lat: lastPosition.lat, lng: lastPosition.lng },
                        { lat: location.lat, lng: location.lng }
                    );
                    const distanceFeet = Math.round(distance * 3.28084);
                    updateDistanceBox(location, distanceFeet);
                }
                
                // Reset proximity state
                isWithinProximity = false;
                proximityZoomActive = false;
            }
        }

        // Calculate optimal zoom level based on speed
        function calculateOptimalZoom(speed) {
            // If proximity zoom is active, prioritize it
            if (proximityZoomActive) {
                return PROXIMITY_ZOOM_LEVEL;
            }
            
            // Default to walking zoom level
            if (speed === undefined || speed === null) {
                return DEFAULT_ZOOM_LEVEL;
            }

            // Stationary or very slow
            if (speed < 0.5) {
                return MAX_ZOOM_LEVEL;
            }
            // Walking speed
            else if (speed < WALKING_SPEED_THRESHOLD) {
                return DEFAULT_ZOOM_LEVEL;
            }
            // Running speed
            else if (speed < RUNNING_SPEED_THRESHOLD) {
                return DEFAULT_ZOOM_LEVEL - 1;
            }
            // Driving speed
            else if (speed < DRIVING_SPEED_THRESHOLD) {
                return DEFAULT_ZOOM_LEVEL - 2;
            }
            // High speed
            else if (speed < HIGH_SPEED_THRESHOLD) {
                return DEFAULT_ZOOM_LEVEL - 3;
            }
            // Very high speed
            else {
                return MIN_ZOOM_LEVEL;
            }
        }

        // Update zoom level based on speed
        function updateDynamicZoom() {
            const now = Date.now();
            if (now - lastZoomUpdateTime < ZOOM_UPDATE_INTERVAL) return;
            lastZoomUpdateTime = now;

            // Skip if user is interacting with map
            if (isMapInteracting || userIsInteracting) return;

            // Calculate average speed from samples
            let avgSpeed = 0;
            if (speedSamples.length > 0) {
                avgSpeed = speedSamples.reduce((sum, speed) => sum + speed, 0) / speedSamples.length;
            } else if (lastPosition) {
                avgSpeed = lastPosition.speedMPS || 0;
            }

            // Smooth speed changes
            const smoothedSpeed = lastSpeedForZoom * 0.7 + avgSpeed * 0.3;
            lastSpeedForZoom = smoothedSpeed;

            // Calculate optimal zoom level
            const optimalZoom = calculateOptimalZoom(smoothedSpeed);

            // Only update if zoom level needs to change
            if (Math.abs(optimalZoom - targetZoomLevel) >= 0.1) {
                targetZoomLevel = optimalZoom;

                // Apply zoom change with smooth animation
                if (map && followUser) {
                    const currentZoom = map.getZoom();
                    const zoomDiff = Math.abs(currentZoom - targetZoomLevel);

                    // Use faster transition for larger zoom changes
                    const duration = zoomDiff > 1 ? 0.3 : ZOOM_TRANSITION_DURATION;

                    map.setZoom(targetZoomLevel, {
                        animate: true,
                        duration: duration,
                        noMoveStart: true,
                    });
                }
            }
        }

        // Linear interpolation helper
        function lerp(a, b, t) {
            if (typeof a !== "number" || typeof b !== "number" || typeof t !== "number") {
                return a;
            }

            return a + (b - a) * Math.max(0, Math.min(1, t));
        }

        // Calculate stationary position
        function calculateStationaryPosition(buffer) {
            if (!buffer || buffer.length === 0) {
                return null;
            }
            // Sort by accuracy (best first)
            const sortedBuffer = [...buffer].sort((a, b) => a.accuracy - b.accuracy);
            // Take weighted average of best positions
            const topPositions = sortedBuffer.slice(0, Math.ceil(buffer.length / 2));
            const weights = topPositions.map((pos) => 1 / Math.max(1, pos.accuracy));
            const totalWeight = weights.reduce((sum, w) => sum + w, 0);
            if (totalWeight === 0) {
                return sortedBuffer[0];
            }
            // Calculate weighted average
            const avgPosition = {
                lat: topPositions.reduce((sum, pos, i) => sum + pos.lat * weights[i], 0) / totalWeight,
                lng: topPositions.reduce((sum, pos, i) => sum + pos.lng * weights[i], 0) / totalWeight,
                accuracy: topPositions[0].accuracy,
                heading: topPositions[0].heading,
                timestamp: Date.now(),
                speedMPS: 0,
            };
            // If we have a previous stationary position, blend with it for stability
            if (lastStationaryPosition) {
                const blendFactor = 0.85; // 85% previous, 15% new for extreme stability
                return {
                    lat: lastStationaryPosition.lat * blendFactor + avgPosition.lat * (1 - blendFactor),
                    lng: lastStationaryPosition.lng * blendFactor + avgPosition.lng * (1 - blendFactor),
                    accuracy: avgPosition.accuracy,
                    heading: avgPosition.heading,
                    timestamp: avgPosition.timestamp,
                    speedMPS: 0
                };
            }
            return avgPosition;
        }

        // Update stationary position history
        function updateStationaryHistory(position) {
            // Add new position to history
            stationaryPositionHistory.push(position);

            // Keep history at maximum size
            while (stationaryPositionHistory.length > STATIONARY_POSITION_HISTORY_SIZE) {
                stationaryPositionHistory.shift();
            }

            // Calculate weighted average of positions
            let totalWeight = 0;
            let weightedLat = 0;
            let weightedLng = 0;

            // Newer positions have higher weight
            for (let i = 0; i < stationaryPositionHistory.length; i++) {
                const pos = stationaryPositionHistory[i];
                const weight = Math.pow(STATIONARY_POSITION_WEIGHT_DECAY, stationaryPositionHistory.length - i - 1);
                totalWeight += weight;
                weightedLat += pos.lat * weight;
                weightedLng += pos.lng * weight;
            }

            return {
                lat: weightedLat / totalWeight,
                lng: weightedLng / totalWeight,
                accuracy: position.accuracy,
                heading: position.heading,
                timestamp: position.timestamp,
                speedMPS: 0,
            };
        }

        // Update position buffer with new position
        function updatePositionBuffer(position) {
            if (!position || typeof position.lat !== "number" || typeof position.lng !== "number") {
                return;
            }

            // Add new position to buffer
            positionBuffer.push({
                lat: position.lat,
                lng: position.lng,
                accuracy: position.accuracy,
                heading: position.heading,
                timestamp: position.timestamp,
                speedMPS: position.speedMPS,
            });

            // Remove old positions if buffer exceeds maxSize
            while (positionBuffer.length > MAX_BUFFER_SIZE) {
                positionBuffer.shift();
            }
        }

        // Check if user is stationary
        function checkStationaryState(newPosition) {
            if (!lastPosition) return;

            const distance = calculateDistance(lastPosition, newPosition);

            if (distance >= MICRO_MOVEMENT_THRESHOLD) {
                isStationary = false;
                stationaryStartTime = null;
                console.debug("Movement detected, resuming normal updates");

                // Update Kalman filter stationary mode
                kalmanFilter.setStationaryMode(false);

                // Update marker class
                const markerElement = userMarker.getElement();
                if (markerElement) {
                    markerElement.classList.remove("user-marker-stationary");
                }
            }

            if (stationaryCheckTimeout) {
                clearTimeout(stationaryCheckTimeout);
                stationaryCheckTimeout = null;
            }

            if (isStationary) {
                stationaryCheckTimeout = setTimeout(() => checkStationaryState(newPosition), STATIONARY_CHECK_INTERVAL);
            }
        }

        // Predict position based on heading and speed
        function predictPositionFromHeading(position, heading, distance) {
            // Input validation
            if (
                !position ||
                typeof heading !== "number" ||
                typeof distance !== "number" ||
                !position.lat ||
                !position.lng ||
                isNaN(heading) ||
                isNaN(distance)
            ) {
                return position;
            }

            // Normalize heading to 0-360 range
            heading = ((heading % 360) + 360) % 360;

            // Earth's radius in meters
            const R = 6371e3;

            // Convert to radians
            const d = distance / R;
            const  = (heading * Math.PI) / 180;
            const 1 = (position.lat * Math.PI) / 180;
            const 1 = (position.lng * Math.PI) / 180;

            // Calculate predicted position with error handling
            try {
                const sin1 = Math.sin(1);
                const cos1 = Math.cos(1);
                const cosd = Math.cos(d);
                const sind = Math.sin(d);
                const cos = Math.cos();

                const 2 = Math.asin(sin1 * cosd + cos1 * sind * cos);

                const 2 = 1 + Math.atan2(Math.sin() * sind * cos1, cosd - sin1 * Math.sin(2));

                // Convert back to degrees with bounds checking
                const newLat = Math.max(-90, Math.min(90, (2 * 180) / Math.PI));
                const newLng = (((2 * 180) / Math.PI + 540) % 360) - 180;

                return {
                    lat: newLat,
                    lng: newLng,
                };
            } catch (error) {
                // Fallback to original position if calculation fails
                return position;
            }
        }

        // Main function to update user location
        function updateUserLocation(position, forceUpdate = false) {
            // Validate input position
            if (!position?.coords) {
                console.warn("Invalid position data received");
                return;
            }

            const currentTime = Date.now();

            // Throttle updates for performance
            if (!forceUpdate && currentTime - lastPositionUpdateTime < 16) {
                return;
            }
            lastPositionUpdateTime = currentTime;

            const timeDelta = lastUpdateTime ? (currentTime - lastUpdateTime) / 1000 : 0;

            // Create position object
            const newPosition = {
                lat: position.coords.latitude,
                lng: position.coords.longitude,
                accuracy: position.coords.accuracy || 20,
                heading: position.coords.heading !== null ? position.coords.heading : lastHeadingValue || undefined,
                timestamp: currentTime,
                speedMPS: position.coords.speed !== null ? position.coords.speed : 0,
            };

            if (isNaN(newPosition.lat) || isNaN(newPosition.lng)) {
                console.warn("Invalid coordinates received");
                return;
            }

            // Store raw position for comparison
            lastRawPosition = newPosition;

            // Track accuracy trend
            if (lastAccuracy !== null) {
                accuracyTrend.push(newPosition.accuracy - lastAccuracy);
                while (accuracyTrend.length > 5) accuracyTrend.shift();
            }
            lastAccuracy = newPosition.accuracy;

            // First position initialization
            if (!lastPosition) {
                lastPosition = newPosition;
                userMarker.setLatLng([newPosition.lat, newPosition.lng]);
                kalmanFilter.reset(newPosition);
                lastUpdateTime = currentTime;
                stationaryStartTime = currentTime;
                positionBuffer = [newPosition];
                lastStationaryPosition = newPosition;
                lastRenderPosition = newPosition;
                return;
            }

            // Calculate distance from last position
            const distance = calculateDistance(lastPosition, newPosition);

            // Handle large position changes or forced updates
            if (distance > EXTENDED_DISTANCE_THRESHOLD || forceUpdate) {
                if (stationaryCheckTimeout) {
                    clearTimeout(stationaryCheckTimeout);
                    stationaryCheckTimeout = null;
                }
                isStationary = false;
                stationaryStartTime = null;
                stationaryCount = 0;
                stationaryPositionHistory = [];
                lastStationaryPosition = null;
                consecutiveStationaryUpdates = 0;

                // Immediate visual update - no animation
                userMarker.setLatLng([newPosition.lat, newPosition.lng]);
                
                // Only center map if followUser is true and user is not interacting
                if ((followUser && !isMapInteracting && !userIsInteracting) || forceCenteringActive) {
                    map.setView([newPosition.lat, newPosition.lng], map.getZoom(), {
                        animate: true,
                        duration: 0.3
                    });
                }

                // Reset tracking variables
                lastPosition = newPosition;
                lastRenderPosition = newPosition;
                positionBuffer = [newPosition];
                kalmanFilter.reset(newPosition);
                kalmanFilter.setStationaryMode(false);
                lastVelocity = { lat: 0, lng: 0 };

                // Cancel any active interpolation
                if (positionInterpolator) {
                    positionInterpolator.cancel();
                }

                // Clear any queued position updates
                positionUpdateQueue = [];

                lastUpdateTime = currentTime;
                lastUpdateTimestamp = currentTime;
                checkNearbyLocations();
                return;
            }

            // Skip updates with poor accuracy or unrealistic movement
            if (
                !forceUpdate &&
                (newPosition.accuracy > MAX_ACCEPTABLE_ACCURACY || (timeDelta > 0 && distance / timeDelta > 50))
            ) {
                console.debug("Skipping update due to poor accuracy or unrealistic movement");
                return;
            }

            try {
                // Check if device is in motion based on motion sensors
                const motionDetected = deviceMotion && isDeviceInMotion();

                // Enhanced stationary detection
                if (distance < MICRO_MOVEMENT_THRESHOLD && (!motionDetected || deviceStationaryTime > STATIONARY_TIME_THRESHOLD)) {
                    stationaryCount++;
                    consecutiveStationaryUpdates++;

                    if (!isStationary && stationaryCount >= STATIONARY_THRESHOLD) {
                        isStationary = true;
                        console.log("User is now stationary");

                        // Set Kalman filter to stationary mode
                        kalmanFilter.setStationaryMode(true);

                        // Update marker class
                        const markerElement = userMarker.getElement();
                        if (markerElement) {
                            markerElement.classList.add("user-marker-stationary");
                        }

                        // Calculate stable position from buffer
                        const stablePosition = calculateStationaryPosition(positionBuffer);
                        if (stablePosition) {
                            // Add to position update queue
                            positionUpdateQueue.push(stablePosition);
                            lastPosition = stablePosition;
                            lastStationaryPosition = stablePosition;
                        }

                        if (stationaryCheckTimeout) clearTimeout(stationaryCheckTimeout);
                        stationaryCheckTimeout = setTimeout(() => checkStationaryState(newPosition), STATIONARY_CHECK_INTERVAL);

                        checkNearbyLocations();
                        return;
                    }
                } else {
                    stationaryCount = Math.max(0, stationaryCount - 1);
                    consecutiveStationaryUpdates = 0;
                    if (isStationary && stationaryCount < STATIONARY_THRESHOLD / 2) {
                        isStationary = false;
                        kalmanFilter.setStationaryMode(false);

                        // Update marker class
                        const markerElement = userMarker.getElement();
                        if (markerElement) {
                            markerElement.classList.remove("user-marker-stationary");
                        }

                        console.log("User is moving again");
                    }
                }

                // Apply Kalman filter with motion detection
                const filteredPosition = kalmanFilter.update(newPosition, motionDetected);

                // Update position buffer
                updatePositionBuffer(filteredPosition);

                // Apply different smoothing based on movement state
                let finalPosition;

                if (isStationary) {
                    // When stationary, use the stable position with minimal updates
                    if (lastStationaryPosition) {
                        // Only update if accuracy significantly improves or after several updates
                        if (newPosition.accuracy < lastStationaryPosition.accuracy * 0.8 || consecutiveStationaryUpdates > 5) {
                            // Update stationary position history
                            updateStationaryHistory(filteredPosition);

                            // Calculate new stable position
                            const stablePosition = calculateStationaryPosition(positionBuffer);
                            if (stablePosition) {
                                // Smooth transition to new stable position
                                finalPosition = {
                                    lat: lerp(lastStationaryPosition.lat, stablePosition.lat, 0.1),
                                    lng: lerp(lastStationaryPosition.lng, stablePosition.lng, 0.1),
                                    accuracy: stablePosition.accuracy,
                                    heading: stablePosition.heading,
                                    timestamp: currentTime,
                                    speedMPS: 0,
                                };

                                // Add to position update queue
                                positionUpdateQueue.push(finalPosition);
                                lastPosition = finalPosition;
                                lastStationaryPosition = finalPosition;
                                consecutiveStationaryUpdates = 0;
                            } else {
                                finalPosition = lastStationaryPosition;
                            }
                        } else {
                            // Use existing stable position
                            finalPosition = lastStationaryPosition;
                        }
                    } else {
                        // If no stable position yet, calculate one
                        const stablePosition = calculateStationaryPosition(positionBuffer);
                        if (stablePosition) {
                            finalPosition = stablePosition;
                            lastStationaryPosition = stablePosition;

                            // Add to position update queue
                            positionUpdateQueue.push(finalPosition);
                        } else {
                            finalPosition = filteredPosition;

                            // Add to position update queue
                            positionUpdateQueue.push(finalPosition);
                        }
                        lastPosition = finalPosition;
                    }
                } else {
                    // Smooth movement when active
                    finalPosition = filteredPosition;

                    // Apply heading-based prediction for smoother movement
                    if (finalPosition.heading !== undefined && finalPosition.speedMPS > 0.5) {
                        const predictedPosition = predictPositionFromHeading(
                            finalPosition,
                            finalPosition.heading,
                            finalPosition.speedMPS * 0.3, // Predict slightly ahead
                        );

                        // Blend predicted and filtered positions
                        finalPosition = {
                            lat: lerp(finalPosition.lat, predictedPosition.lat, 0.2),
                            lng: lerp(finalPosition.lng, predictedPosition.lng, 0.2),
                            accuracy: finalPosition.accuracy,
                            heading: finalPosition.heading,
                            timestamp: currentTime,
                            speedMPS: finalPosition.speedMPS,
                        };
                    }

                    // Add to position update queue
                    positionUpdateQueue.push(finalPosition);
                    lastPosition = finalPosition;
                }

                lastUpdateTime = currentTime;
                lastUpdateTimestamp = currentTime;
                checkNearbyLocations();
            } catch (error) {
                console.error("Location update error:", error);
                // Fallback with basic filtering
                userMarker.setLatLng([newPosition.lat, newPosition.lng]);
                lastPosition = newPosition;
                lastRenderPosition = newPosition;
                checkNearbyLocations();
            }
        }

        // Handle position updates from geolocation API
        function handlePositionUpdate(position) {
            if (!position?.coords?.latitude || !position?.coords?.longitude) {
                console.warn("Invalid position data received");
                return;
            }

            const currentTime = Date.now();
            if (currentTime - lastUpdateTime >= 100 && !isPopupOpen()) {
                updateUserLocation(position);
                lastUpdateTime = currentTime;
            }
        }

        // Start position updates with high frequency
        function startPositionUpdates() {
            navigator.geolocation.watchPosition(handlePositionUpdate, handleLocationError, {
                enableHighAccuracy: true,
                maximumAge: 0,
                timeout: 10000,
            });
        }

        // Initialize map with enhanced settings
        function initMap() {
            map = L.map("map", {
                zoomControl: false,
                attributionControl: false,
                zoomSnap: 0.1,
                zoomDelta: 0.5,
                wheelDebounceTime: 100,
                tapTolerance: 15,
                bounceAtZoomLimits: false,
                preferCanvas: true, // Use canvas renderer for better performance
                renderer: L.canvas({ padding: 0.5 }),
            }).fitWorld();

            L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
                maxZoom: 18,
                attribution: " OpenStreetMap contributors",
                updateWhenIdle: true,
                updateWhenZooming: false,
                keepBuffer: 2,
            }).addTo(map);

            // Create user icon with custom styling for direction indication
            const userIcon = L.divIcon({
                className: "user-marker",
                html: '<div class="user-marker-icon"></div>',
                iconSize: [24, 24],
                iconAnchor: [12, 12],
            });

            userMarker = L.marker([0, 0], {
                icon: userIcon,
                zIndexOffset: 1000, // Ensure user marker is on top
                interactive: false, // Prevent marker from being clickable
            }).addTo(map);

            // Show preloader
            showPreloader();

            // Request motion and orientation permissions
            requestMotionPermission();

            if ("geolocation" in navigator) {
                const options = {
                    enableHighAccuracy: true,
                    timeout: 45000,
                    maximumAge: 0,
                };

                // Try first time
                navigator.geolocation.getCurrentPosition(
                    initializeUserLocation,
                    (error) => {
                        // On error, try one more time before falling back
                        navigator.geolocation.getCurrentPosition(initializeUserLocation, handleLocationError, options);
                    },
                    options
                );
            } else {
                showPopup("Geolocation is not supported by your browser");
                map.setView([44.9778, -93.265], 18);
                hidePreloader();
            }

            document.addEventListener("visibilitychange", handleVisibilityChange);

            // Track user interaction with the map
            map.on("movestart zoomstart", () => {
                isMapInteracting = true;
                userIsInteracting = true;
                userInteractionTime = Date.now();
                followUser = false; // Disable following when user interacts
            });

            map.on("moveend zoomend", () => {
                isMapInteracting = false;
                
                // Start inactivity timer to re-enable following after INACTIVITY_TIMEOUT
                resetInactivityTimer();
            });

            // Add this after the map.on("moveend zoomend"...) event handler:
            map.on("click", function() {
                // Close any open popups when the map is clicked
                map.closePopup();
            });

            // Start animation loop for smooth rendering
            startAnimationLoop();

            // Load tour locations
            loadLocations();
        }

        // Load tour locations
        function loadLocations() {
            gameLocations = locations;
            
            // Create markers for all locations
            gameLocations.forEach((location, index) => {
                // Create numbered marker icon
                const locationIcon = L.divIcon({
                    className: 'location-marker',
                    html: `<div class="location-marker-icon">${index + 1}</div>`,
                    iconSize: [40, 40],
                    iconAnchor: [20, 20]
                });
                
                const marker = L.marker([location.lat, location.lng], {
                    icon: locationIcon
                });
                
                // Add popup with location info
                const popupContent = `
                    <div class="marker-popup">
                        <img src="${location.image || '/placeholder.svg?height=150&width=280'}" class="marker-popup-image" alt="${location.name}">
                        <div class="marker-popup-content">
                            <div class="marker-popup-title">${location.name}</div>
                            <div class="marker-popup-description">${location.description.substring(0, 100)}...</div>
                            <div class="marker-popup-actions">
                                <button class="popup-btn directions" onclick="showDirectionsModal(gameLocations[${index}])">
                                    <i class="fas fa-directions"></i> Directions
                                </button>
                                <button class="popup-btn skip" onclick="skipToNextLocation()">
                                    <i class="fas fa-forward"></i> Skip
                                </button>
                            </div>
                        </div>
                    </div>
                `;
                
const popup = L.popup({
    closeButton: false,
    autoClose: true, 
    closeOnEscapeKey: true,
    closeOnClick: true,
    className: 'custom-popup',
    maxWidth: 300,
    minWidth: 300,  // Set a fixed width
    maxHeight: null,
    autoPan: true,
    autoPanPadding: [10, 10]
}).setContent(popupContent);
                
                marker.bindPopup(popup);
                
                // Add click event to marker
                marker.on('click', () => {
                    marker.openPopup();
                });
                
                allLocationMarkers.push(marker);
            });
            
            // Only show the first marker initially
            updateVisibleMarkers();
        }
        
        // Update visible markers based on current progress
        function updateVisibleMarkers() {
            // Remove all existing markers from map
            activeMarkers.forEach(marker => {
                map.removeLayer(marker);
            });
            activeMarkers = [];
            
            // Show only the current marker
            if (currentLocationIndex < allLocationMarkers.length) {
                allLocationMarkers[currentLocationIndex].addTo(map);
                activeMarkers.push(allLocationMarkers[currentLocationIndex]);
            }
        }

        // Initialize user location
        function initializeUserLocation(position) {
            if (!position?.coords) {
                handleLocationError({ code: 2, message: "Invalid position data" });
                return;
            }

            try {
                const initialPosition = {
                    lat: position.coords.latitude,
                    lng: position.coords.longitude,
                    accuracy: position.coords.accuracy || 20,
                    heading: position.coords.heading,
                    timestamp: Date.now(),
                    speedMPS: position.coords.speed || 0,
                };

                // Set initial marker position
                userMarker.setLatLng([initialPosition.lat, initialPosition.lng]);

                // Initialize Kalman filter
                kalmanFilter.reset(initialPosition);

                // Set map view
                map.setView([initialPosition.lat, initialPosition.lng], DEFAULT_ZOOM_LEVEL);

                // Initialize tracking variables
                lastPosition = initialPosition;
                lastRenderPosition = initialPosition;
                lastUpdateTime = Date.now();
                lastUpdateTimestamp = Date.now();

                // Start position updates
                startPositionUpdates();

                // Hide preloader
                hidePreloader();

                // Update distance box
                checkNearbyLocations();

                // Show stabilizing modal
                showStabilizingModal();

                console.log("Location initialized successfully");
            } catch (error) {
                console.error("Error initializing location:", error);
                handleLocationError({ code: 2, message: "Error initializing location" });
            }
        }

        // Show stabilizing modal
        function showStabilizingModal() {
            const modal = document.createElement('div');
            modal.className = 'stabilizing-modal';
            modal.innerHTML = `
                <div class="spinner"></div>
                <h3>Stabilizing Your Location</h3>
                <p>Please wait while we fine-tune your position.</p>
            `;
            document.body.appendChild(modal);
            
            // Auto-dismiss after 5 seconds
            setTimeout(() => {
                modal.style.opacity = '0';
                modal.style.transition = 'opacity 0.5s ease';
                setTimeout(() => {
                    if (modal.parentNode) {
                        modal.parentNode.removeChild(modal);
                    }
                    isStabilizing = false;
                }, 500);
            }, 5000);
        }

        // Show location hunt
        function showLocationHunt(location) {
            isLocationHuntVisible = true;
            
            // Set location information
            document.getElementById('locationTitle').textContent = location.name;
            document.getElementById('locationCity').textContent = location.city;
            document.getElementById('locationCreator').textContent = `Created by: ${location.creator}`;
            document.getElementById('locationImage').src = location.image || '/placeholder.svg?height=200&width=400';
            document.getElementById('locationAudio').src = location.audio;
            document.getElementById('locationDescription').textContent = location.description;
            
            // Create navigation links
            createNavigationLinks(location);
            
            // Show location hunt container
            const lochuntContainer = document.querySelector('.lochunt-container');
            lochuntContainer.classList.add('active');
            
            // Initialize audio player
            initAudioPlayer();
            
            // Add to visited locations if not already visited
            if (!visitedLocations.includes(location.id)) {
                visitedLocations.push(location.id);
            }
        }

        // Initialize audio player
        function initAudioPlayer() {
            const audio = document.getElementById('locationAudio');
            const playPauseBtn = document.getElementById('playPauseBtn');
            const rewindBtn = document.getElementById('rewindBtn');
            const forwardBtn = document.getElementById('forwardBtn');
            const progressBar = document.getElementById('progressBar');
            const currentTimeSpan = document.getElementById('currentTime');
            const durationSpan = document.getElementById('duration');
            
            // Set up event listeners
            playPauseBtn.addEventListener('click', togglePlay);
            rewindBtn.addEventListener('click', () => seek(-10));
            forwardBtn.addEventListener('click', () => seek(10));
            audio.addEventListener('timeupdate', updateProgress);
            audio.addEventListener('loadedmetadata', setDuration);
            audio.addEventListener('ended', showTrivia);
            
            // Play/pause function
            function togglePlay() {
                if (audio.paused) {
                    audio.play();
                    playPauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
                } else {
                    audio.pause();
                    playPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
                }
            }
            
            // Seek function
            function seek(seconds) {
                audio.currentTime = Math.max(0, Math.min(audio.currentTime + seconds, audio.duration));
            }
            
            // Update progress bar
            function updateProgress() {
                const percent = (audio.currentTime / audio.duration) * 100;
                progressBar.style.width = `${percent}%`;
                currentTimeSpan.textContent = formatTime(audio.currentTime);
            }
            
            // Set duration
            function setDuration() {
                durationSpan.textContent = formatTime(audio.duration);
            }
            
            // Format time (convert seconds to MM:SS format)
            function formatTime(time) {
                const minutes = Math.floor(time / 60);
                const seconds = Math.floor(time % 60);
                return `${minutes}:${seconds.toString().padStart(2, '0')}`;
            }
        }

        // Show trivia question
        function showTrivia() {
            // Hide location hunt container
            document.querySelector('.lochunt-container').classList.remove('active');
            
            // Get current location
            const currentLocation = gameLocations[currentLocationIndex];
            
            // Set trivia question
            document.getElementById('triviaQuestion').textContent = currentLocation.trivia.question;
            
            // Create trivia options
            const triviaOptions = document.getElementById('triviaOptions');
            triviaOptions.innerHTML = '';
            
            currentLocation.trivia.options.forEach((option, index) => {
                const button = document.createElement('button');
                button.className = 'trivia-option';
                button.textContent = option;
                button.dataset.index = index;
                button.addEventListener('click', checkAnswer);
                triviaOptions.appendChild(button);
            });
            
            // Show trivia container
            document.querySelector('.trivia-container').classList.add('active');
        }

        // Check trivia answer
        function checkAnswer(event) {
            const selectedIndex = parseInt(event.target.dataset.index);
            const currentLocation = gameLocations[currentLocationIndex];
            
            // Disable all buttons
            const buttons = document.querySelectorAll('.trivia-option');
            buttons.forEach(button => {
                button.disabled = true;
            });
            
            // Mark correct and incorrect answers
            buttons.forEach(button => {
                const index = parseInt(button.dataset.index);
                if (index === currentLocation.trivia.answer) {
                    button.classList.add('correct');
                } else if (index === selectedIndex) {
                    button.classList.add('incorrect');
                }
            });
            
            // Wait 2 seconds before proceeding
            setTimeout(() => {
                // Hide trivia container
                document.querySelector('.trivia-container').classList.remove('active');
                
                // Remove the current marker from the map
                if (currentLocationIndex < allLocationMarkers.length) {
                    map.removeLayer(allLocationMarkers[currentLocationIndex]);
                }
                
                // Move to next location or show congratulations
                currentLocationIndex++;
                isLocationHuntVisible = false;
                
                if (currentLocationIndex >= gameLocations.length) {
                    showCongratulations();
                } else {
                    // Update visible markers for the next location
                    updateVisibleMarkers();
                    
                    // Update distance box for new location
                    if (lastPosition) {
                        const location = gameLocations[currentLocationIndex];
                        const distance = calculateDistance(
                            { lat: lastPosition.lat, lng: lastPosition.lng },
                            { lat: location.lat, lng: location.lng }
                        );
                        const distanceFeet = Math.round(distance * 3.28084);
                        updateDistanceBox(location, distanceFeet);
                    }
                    
                    // Reset proximity state
                    isWithinProximity = false;
                    proximityZoomActive = false;
                }
            }, 2000);
        }

        // Show congratulations screen
        function showCongratulations() {
            document.getElementById('congratulations').style.display = 'flex';
        }

        // End tour function - consolidated into a single function
        function endTour() {
            // Show confirmation popup
            showPopup("Are you sure you want to end the tour and return to the home page?");
            
            // Replace the default OK button with Yes/No buttons
            const popupContent = document.querySelector('.popup-content');
            const okButton = popupContent.querySelector('.popup-button');
            
            if (okButton) {
                // Remove the default OK button
                okButton.remove();
                
                // Create button container
                const buttonContainer = document.createElement('div');
                buttonContainer.style.display = 'flex';
                buttonContainer.style.gap = '10px';
                buttonContainer.style.marginTop = '20px';
                
                // Create Yes button
                const yesButton = document.createElement('button');
                yesButton.className = 'popup-button';
                yesButton.textContent = 'Yes';
                yesButton.style.flex = '1';
                yesButton.style.backgroundColor = 'var(--secondary-color)';
                yesButton.addEventListener('click', () => {
                    // Navigate to home page
                    window.location.href = 'index.html';
                });
                
                // Create No button
                const noButton = document.createElement('button');
                noButton.className = 'popup-button';
                noButton.textContent = 'No';
                noButton.style.flex = '1';
                noButton.style.backgroundColor = 'var(--bg-dark)';
                noButton.style.color = 'var(--text-color)';
                noButton.addEventListener('click', closePopup);
                
                // Add buttons to container
                buttonContainer.appendChild(yesButton);
                buttonContainer.appendChild(noButton);
                
                // Add container to popup
                popupContent.appendChild(buttonContainer);
            }
        }
    
// Show enhanced preloader with guaranteed 10-second fill time
function showPreloader() {
    const preloader = document.getElementById('preloader');
    if (!preloader) {
        console.error('Preloader element not found');
        return;
    }
    
    // Make sure the preloader is visible and fully opaque
    preloader.style.display = 'flex';
    preloader.style.opacity = '1';
    
    // Set up elements
    const progressBar = document.getElementById('preloaderProgress');
    const loadingStatus = document.getElementById('loadingStatus');
    
    // Check if elements exist
    if (!progressBar) console.warn('Progress bar element not found');
    if (!loadingStatus) console.warn('Loading status element not found');
    
    // Create percentage element if it doesn't exist
    let loadingPercentage = document.getElementById('loadingPercentage');
    if (!loadingPercentage) {
        loadingPercentage = document.createElement('div');
        loadingPercentage.id = 'loadingPercentage';
        loadingPercentage.className = 'loading-percentage';
        // Insert after loading status if it exists, otherwise append to preloader
        if (loadingStatus && loadingStatus.parentNode) {
            loadingStatus.parentNode.insertBefore(loadingPercentage, loadingStatus.nextSibling);
        } else if (preloader) {
            preloader.appendChild(loadingPercentage);
        }
    }
    
    // Reset progress bar and text
    if (progressBar) progressBar.style.width = '0%';
    if (loadingPercentage) loadingPercentage.textContent = '0%';
    if (loadingStatus) loadingStatus.textContent = "Initializing map...";
    
    const statusMessages = [
        "Initializing map...",
        "Loading tour locations...",
        "Preparing navigation...",
        "Getting your location...",
        "Almost ready..."
    ];
    
    // Set animation parameters
    const DURATION = 10000; // Exactly 10 seconds
    
    // Cancel any existing animation
    if (window.preloaderAnimationId) {
        cancelAnimationFrame(window.preloaderAnimationId);
        window.preloaderAnimationId = null;
    }
    
    // Cancel any existing timeouts
    if (window.preloaderHideTimeout) {
        clearTimeout(window.preloaderHideTimeout);
        window.preloaderHideTimeout = null;
    }
    
    // Set a flag to prevent premature hiding
    window.preloaderActive = true;
    
    // Record start time
    const startTime = performance.now();
    
    // Animation function using requestAnimationFrame for smoother progress
    function animateProgress(currentTime) {
        // Calculate how much time has passed (capped at DURATION)
        const elapsedTime = Math.min(currentTime - startTime, DURATION);
        
        // Calculate progress percentage (0-100)
        const progressPercent = (elapsedTime / DURATION) * 100;
        
        // Update progress bar
        if (progressBar) {
            progressBar.style.width = `${progressPercent}%`;
        }
        
        // Update percentage text
        if (loadingPercentage) {
            loadingPercentage.textContent = `${Math.round(progressPercent)}%`;
        }
        
        // Update status message based on progress
        if (loadingStatus) {
            const messageIndex = Math.min(
                Math.floor(progressPercent / 20), // 5 messages, 20% each
                statusMessages.length - 1
            );
            loadingStatus.textContent = statusMessages[messageIndex];
        }
        
        // Continue animation if we haven't reached the end
        if (elapsedTime < DURATION) {
            window.preloaderAnimationId = requestAnimationFrame(animateProgress);
        } else {
            // We've reached exactly 10 seconds
            if (loadingStatus) loadingStatus.textContent = "Loading complete!";
            if (loadingPercentage) loadingPercentage.textContent = "100%";
            
            // Set a timeout to hide the preloader after a short delay
            window.preloaderHideTimeout = setTimeout(() => {
                // Only hide if preloaderActive is still true
                if (window.preloaderActive) {
                    preloader.style.opacity = '0';
                    preloader.style.transition = 'opacity 0.5s ease';
                    
                    setTimeout(() => {
                        preloader.style.display = 'none';
                        window.preloaderActive = false;
                    }, 500);
                }
            }, 300);
        }
    }
    
    // Start the animation
    window.preloaderAnimationId = requestAnimationFrame(animateProgress);
    
    // Set a guaranteed timeout to ensure we complete in exactly 10 seconds
    // This is a backup in case requestAnimationFrame has issues
    setTimeout(() => {
        // If animation is still running, cancel it
        if (window.preloaderAnimationId) {
            cancelAnimationFrame(window.preloaderAnimationId);
            window.preloaderAnimationId = null;
        }
        
        // Force progress to 100%
        if (progressBar) progressBar.style.width = '100%';
        if (loadingPercentage) loadingPercentage.textContent = '100%';
        if (loadingStatus) loadingStatus.textContent = "Loading complete!";
        
        // Set timeout to hide preloader
        if (!window.preloaderHideTimeout) {
            window.preloaderHideTimeout = setTimeout(() => {
                if (window.preloaderActive) {
                    preloader.style.opacity = '0';
                    preloader.style.transition = 'opacity 0.5s ease';
                    
                    setTimeout(() => {
                        preloader.style.display = 'none';
                        window.preloaderActive = false;
                    }, 500);
                }
            }, 300);
        }
    }, DURATION);
}

// Modified hidePreloader function that respects the 10-second minimum duration
function hidePreloader() {
    // Only hide if the preloader has been active for at least 10 seconds
    // or if it's not currently active
    if (!window.preloaderActive) {
        const preloader = document.getElementById('preloader');
        if (preloader) {
            preloader.style.opacity = '0';
            preloader.style.transition = 'opacity 0.5s ease';
            setTimeout(() => {
                preloader.style.display = 'none';
            }, 500);
        }
    }
    // Otherwise, do nothing - let the preloader complete its 10-second cycle
}

        // Show popup
        function showPopup(message) {
            const popup = document.getElementById('popup');
            const popupMessage = document.getElementById('popupMessage');
            
            if (popup && popupMessage) {
                popupMessage.textContent = message;
                popup.style.display = 'flex';
            } else {
                alert(message);
            }
        }

        // Close popup
        function closePopup() {
            const popup = document.getElementById('popup');
            if (popup) {
                popup.style.display = 'none';
            }
        }

        // Check if popup is open
        function isPopupOpen() {
            const popup = document.getElementById('popup');
            return popup ? popup.style.display === 'flex' : false;
        }

        // Handle location errors
        function handleLocationError(error) {
            console.error("Geolocation error:", error);
            hidePreloader();
            
            let message = "Unable to access your location. ";
            
            switch(error.code) {
                case 1:
                    message += "Please enable location services for this website.";
                    break;
                case 2:
                    message += "Location information is unavailable.";
                    break;
                case 3:
                    message += "The request to get your location timed out.";
                    break;
                default:
                    message += "An unknown error occurred.";
            }
            
            showPopup(message);
        }

        // Handle visibility change
        function handleVisibilityChange() {
            if (document.hidden) {
                lastHiddenTime = Date.now();
                
                // Pause any active animations when app goes to background
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
            } else {
                const hiddenDuration = Date.now() - lastHiddenTime;
                
                // Restart animation loop
                if (!animationFrameId) {
                    startAnimationLoop();
                }
                
                if (hiddenDuration > BACKGROUND_THRESHOLD) {
                    // App was in background for significant time, reset tracking
                    if (userMarker && lastPosition) {
                        // Force position update
                        updateUserLocation({
                            coords: {
                                latitude: lastPosition.lat,
                                longitude: lastPosition.lng,
                                accuracy: lastPosition.accuracy,
                                heading: lastPosition.heading,
                                speed: lastPosition.speedMPS
                            }
                        }, true);
                        
                        // Force recentering
                        forceCenteringActive = true;
                        setTimeout(() => {
                            forceCenteringActive = false;
                        }, 2000);
                    }
                }
            }
        }

        // Reset inactivity timer - key function for the 29-second recenter requirement
        function resetInactivityTimer() {
            if (inactivityTimer) {
                clearTimeout(inactivityTimer);
            }
            
            inactivityTimer = setTimeout(() => {
                if (!isMapInteracting) {
                    // Close any open popups first with animation
                    const openPopups = document.querySelectorAll('.leaflet-popup');
                    if (openPopups.length > 0) {
                        openPopups.forEach(popup => {
                            popup.classList.add('leaflet-popup-closing');
                        });
                        
                        // Delay the actual closing to allow animation to complete
                        setTimeout(() => {
                            map.closePopup();
                        }, 150);
                    }
                    
                    // Re-enable following after inactivity timeout
                    followUser = true;
                    
                    // Smooth transition back to user's position
                    if (userMarker && userMarker.getLatLng()) {
                        smoothTransitionActive = true;
                        
                        // Get current map center and user position
                        const currentCenter = map.getCenter();
                        const userPos = userMarker.getLatLng();
                        
                        // Calculate distance between current center and user position
                        const distance = calculateDistance(
                            { lat: currentCenter.lat, lng: currentCenter.lng },
                            { lat: userPos.lat, lng: userPos.lng }
                        );
                        
                        // Adjust duration based on distance (longer for greater distances)
                        const duration = Math.min(1.5, Math.max(0.8, distance / 500));
                        
                        // Smooth transition to user position
                        map.flyTo([userPos.lat, userPos.lng], targetZoomLevel, {
                            duration: duration,
                            easeLinearity: 0.25,
                            noMoveStart: true
                        });
                        
                        // Reset smooth transition flag after animation completes
                        setTimeout(() => {
                            smoothTransitionActive = false;
                        }, duration * 1000 + 100);
                    }
                }
            }, INACTIVITY_TIMEOUT); // 29 seconds as requested
        }

        // Recenter map
        function recenterMap() {
            const recenterButton = document.getElementById('recenterButton');
            if (recenterButton) {
                recenterButton.style.backgroundColor = "var(--primary-color)";
                recenterButton.style.color = "white";
            }
            
            if (userMarker && userMarker.getLatLng()) {
                // Use flyTo for smoother animation
                map.flyTo(userMarker.getLatLng(), targetZoomLevel, {
                    duration: 0.8,
                    easeLinearity: 0.25
                });
                
                followUser = true;
                
                // Force centering for a short period
                forceCenteringActive = true;
                setTimeout(() => {
                    forceCenteringActive = false;
                }, 2000);
            }
            
            setTimeout(() => {
                if (recenterButton) {
                    recenterButton.style.backgroundColor = "var(--bg-color)";
                    recenterButton.style.color = "var(--primary-color)";
                }
            }, 500);
        }

        // Toggle navigation tips
        function toggleNavigationTips() {
            const tipsElement = document.querySelector('.navigation-tips');
            tipsElement.style.display = tipsElement.style.display === 'none' || tipsElement.style.display === '' ? 'block' : 'none';
        }

        // Close navigation tips
        function closeNavigationTips() {
            document.querySelector('.navigation-tips').style.display = 'none';
        }

        // Make functions available globally for event handlers
        window.showDirectionsModal = showDirectionsModal;
        window.closeDirectionsModal = closeDirectionsModal;
        window.skipToNextLocation = skipToNextLocation;
        window.closePopup = closePopup;
        window.endTour = endTour;

        // Add event listeners when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize map
            initMap();
            
            // Add event listeners for UI elements
            document.getElementById('recenterButton').addEventListener('click', recenterMap);
            document.getElementById('endTourButton').addEventListener('click', endTour);
            document.getElementById('tipsButton').addEventListener('click', toggleNavigationTips);
            document.querySelector('.navigation-tips .close-button').addEventListener('click', closeNavigationTips);
            
            // Initialize inactivity timer
            resetInactivityTimer();

            // Setup touch to close popup
            setupTouchToClosePopup();
        });

function setupTouchToClosePopup() {
    // Track if we're in the process of closing a popup (for animation)
    let closePopupTimeout = null;

    // Use Leaflet's preclick event. This fires before other click handlers on the map.
    map.on('preclick', function(leafletEvent) {
        // If L.DomEvent.stop() was called on an event originating from within a popup (e.g., button click),
        // this preclick handler might still fire, but the key is that the button's action
        // will have already been handled, and the event stopped from causing map interactions.

        let clickedInsidePopup = false;
        if (leafletEvent.originalEvent && leafletEvent.originalEvent.target) {
            let target = leafletEvent.originalEvent.target;
            // Traverse up the DOM tree from the click target
            while (target && target !== document && target !== map.getContainer()) {
                if (target.classList &&
                    (target.classList.contains('leaflet-popup') || // The popup container itself
                     target.classList.contains('leaflet-popup-content-wrapper') || // Inner wrapper
                     target.classList.contains('leaflet-popup-pane'))) { // The pane containing popups
                    clickedInsidePopup = true;
                    break;
                }
                target = target.parentNode;
            }
        }

        // Only close popups if we didn't click inside one
        if (!clickedInsidePopup) {
            // Check if there are any open popups.
            // A more Leaflet-idiomatic way to check for an open popup is map.getPane('popupPane').firstChild
            // or by checking if map.hasLayer(someOpenPopupInstance) if you track it.
            // document.querySelectorAll might be okay but relies on Leaflet's DOM structure.
            const openPopups = document.querySelectorAll('.leaflet-popup.custom-popup'); // Be more specific if possible

            if (openPopups.length > 0) {
                openPopups.forEach(popupNode => {
                    // Ensure 'leaflet-popup-closing' CSS class is defined for your animation
                    popupNode.classList.add('leaflet-popup-closing');
                });

                if (closePopupTimeout) {
                    clearTimeout(closePopupTimeout);
                }

                // Set a small delay before actually closing the popup to allow animation
                closePopupTimeout = setTimeout(() => {
                    map.closePopup(); // This closes any popup currently open on the map
                    closePopupTimeout = null;
                    // Remove closing class if popups might be reused or if CSS depends on its absence
                    openPopups.forEach(popupNode => {
                         popupNode.classList.remove('leaflet-popup-closing');
                    });
                }, 150); // 150ms delay, adjust as needed for your animation
            }
        }
        // If clickedInsidePopup is true, this handler does nothing further, which is correct.
        // Clicks inside the popup (including on buttons) are handled by their own listeners
        // which should use L.DomEvent.stop() to prevent this preclick from having unintended effects.
    });

    // The global 'document.addEventListener('click', ...)' for buttons has been REMOVED from here.
    // Button clicks are now handled via marker.on('popupopen', ...) in loadLocations.
}
    </script>
</body>
</html>
