<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, viewport-fit=cover">
    <title>Minnesota Then | Self-Guided Tours</title>
    <link rel="shortcut icon" type="image/x-icon" href="https://www.mnthen.com/images/mnthenfav.ico">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css">
    
    <style>
    /* Base styles */
    :root {
        --primary-color: #2c5282;
        --primary-light: #3182ce;
        --primary-dark: #1a365d;
        --secondary-color: #e53e3e;
        --secondary-light: #fc8181;
        --secondary-dark: #c53030;
        --accent-color: #38a169;
        --accent-light: #68d391;
        --accent-dark: #276749;
        --text-color: #2d3748;
        --text-light: #4a5568;
        --text-lighter: #718096;
        --bg-color: #ffffff;
        --bg-light: #f7fafc;
        --bg-dark: #edf2f7;
        --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        --shadow-md: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        --shadow-lg: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
        --radius-sm: 0.125rem;
        --radius: 0.25rem;
        --radius-md: 0.375rem;
        --radius-lg: 0.5rem;
        --radius-xl: 1rem;
        --radius-2xl: 1.5rem;
        --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        --transition-fast: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
        --transition-slow: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        --font-sans: 'Segoe UI', -apple-system, BlinkMacSystemFont, 'Helvetica Neue', Arial, sans-serif;
    }

    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }
    
    body {
        margin: 0;
        padding: 0;
        font-family: var(--font-sans);
        overflow: hidden;
        height: 100vh;
        width: 100vw;
        position: relative;
        color: var(--text-color);
        background-color: var(--bg-color);
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
        touch-action: manipulation;
    }
    
    #map {
        height: 100vh;
        width: 100%;
        z-index: 1;
        will-change: transform;
    }
    
    /* Enhanced Distance box */
    #distanceBox {
        position: absolute;
        top: 16px;
        left: 16px;
        background-color: rgba(255, 255, 255, 0.98);
        padding: 16px 20px;
        border-radius: var(--radius-lg);
        box-shadow: var(--shadow-md);
        z-index: 1000;
        font-size: 20px;
        font-weight: 600;
        color: var(--text-color);
        min-width: 200px;
        max-width: 320px;
        transition: var(--transition);
        border-left: 6px solid var(--primary-color);
        display: flex;
        align-items: center;
        backdrop-filter: blur(5px);
        transform: translateZ(0);
        will-change: transform;
    }

    #distanceBox .location-icon {
        margin-right: 15px;
        color: var(--primary-color);
        font-size: 24px;
    }

    #distanceBox .distance-info {
        display: flex;
        flex-direction: column;
        font-size: 20px;
    }

    #distanceBox .location-name {
        font-weight: 700;
        margin-bottom: 4px;
        color: var(--primary-color);
        font-size: 20px;
    }

    #distanceBox .distance-value {
        font-size: 18px;
        color: var(--text-light);
        font-weight: 500;
    }

    /* Location hunt container */
    .lochunt-container {
        position: fixed;
        bottom: 0;
        left: 0;
        width: 100%;
        height: 80%;
        background-color: var(--bg-color);
        z-index: 1500;
        border-radius: var(--radius-2xl) var(--radius-2xl) 0 0;
        box-shadow: var(--shadow-lg);
        transform: translateY(100%);
        transition: transform 0.5s cubic-bezier(0.16, 1, 0.3, 1);
        overflow: hidden;
        display: none;
        will-change: transform;
    }
    
    .lochunt-container.active {
        transform: translateY(0);
        display: block;
    }
    
    .lochunt-content {
        padding: 24px;
        overflow-y: auto;
        height: calc(100% - 200px);
        overscroll-behavior: contain;
        -webkit-overflow-scrolling: touch;
    }
    
    #locationImage {
        width: 100%;
        height: 200px;
        object-fit: cover;
        object-position: center;
        will-change: transform;
    }
    
    .lochunt-info {
        margin-bottom: 24px;
    }
    
    .lochunt-info h2 {
        color: var(--primary-color);
        margin-bottom: 8px;
        font-weight: 700;
    }
    
    .lochunt-info p {
        line-height: 1.6;
        margin-bottom: 16px;
    }
    
    .text-muted {
        color: var(--text-lighter);
        font-size: 14px;
    }
    
    /* Audio player */
    .audio-player {
        margin-top: 24px;
        padding: 20px;
        background-color: var(--bg-light);
        border-radius: var(--radius-lg);
        box-shadow: var(--shadow-sm);
    }
    
    .audio-progress {
        margin-bottom: 12px;
    }
    
    .progress {
        height: 6px;
        background-color: var(--bg-dark);
        border-radius: var(--radius-xl);
        overflow: hidden;
    }
    
    .progress-bar {
        background-color: var(--primary-color);
        height: 100%;
        border-radius: var(--radius-xl);
        transition: width 0.1s linear;
        will-change: width;
    }
    
    .audio-time {
        display: flex;
        justify-content: space-between;
        font-size: 12px;
        color: var(--text-lighter);
        margin-bottom: 12px;
    }
    
    .audio-controls {
        display: flex;
        justify-content: space-between;
        align-items: center;
        max-width: 200px;
        margin: 0 auto;
    }
    
    .audio-button {
        background-color: var(--bg-color);
        border: 2px solid var(--primary-color);
        color: var(--primary-color);
        width: 44px;
        height: 44px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: var(--transition-fast);
        -webkit-tap-highlight-color: transparent;
    }
    
    .audio-button:hover, .audio-button:active {
        background-color: var(--primary-color);
        color: var(--bg-color);
        transform: translateY(-2px);
    }
    
    /* Trivia container */
    .trivia-container {
        position: fixed;
        bottom: 0;
        left: 0;
        width: 100%;
        background-color: var(--bg-color);
        z-index: 1500;
        border-radius: var(--radius-2xl) var(--radius-2xl) 0 0;
        box-shadow: var(--shadow-lg);
        padding: 24px;
        transform: translateY(100%);
        transition: transform 0.5s cubic-bezier(0.16, 1, 0.3, 1);
        display: none;
        will-change: transform;
    }
    
    .trivia-container.active {
        transform: translateY(0);
        display: block;
    }
    
    .trivia-container h3 {
        color: var(--primary-color);
        margin-bottom: 16px;
        font-weight: 700;
    }
    
    .trivia-option {
        background-color: var(--bg-light);
        border: 2px solid var(--bg-dark);
        border-radius: var(--radius-lg);
        padding: 16px;
        margin-bottom: 12px;
        cursor: pointer;
        transition: var(--transition-fast);
        font-weight: 500;
        text-align: left;
        width: 100%;
        color: var(--text-color);
    }
    
    .trivia-option:hover, .trivia-option:active {
        background-color: var(--bg-dark);
        transform: translateY(-2px);
    }
    
    .trivia-option.correct {
        background-color: var(--accent-light);
        border-color: var(--accent-color);
        color: var(--accent-dark);
    }
    
    .trivia-option.incorrect {
        background-color: var(--secondary-light);
        border-color: var(--secondary-color);
        color: var(--secondary-dark);
    }
    
    /* Map buttons: horizontal and centered at bottom */
    .map-buttons {
        position: fixed; 
        bottom: 40px; 
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        flex-direction: row;
        gap: 16px;
        z-index: 1000;
        background-color: rgba(255, 255, 255, 0.9);
        padding: 12px 16px;
        border-radius: var(--radius-xl);
        box-shadow: var(--shadow-md);
        backdrop-filter: blur(5px);
        width: auto;
        max-width: 90%;
        will-change: transform;
    }
    
    .map-button {
        width: 60px;
        height: 60px;
        border-radius: 50%;
        background-color: var(--bg-color);
        border: none;
        box-shadow: var(--shadow);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 22px;
        color: var(--primary-color);
        cursor: pointer;
        transition: var(--transition-fast);
        -webkit-tap-highlight-color: transparent;
        will-change: transform;
    }
    
    .map-button:hover, .map-button:active {
        background-color: var(--primary-color);
        color: var(--bg-color);
        transform: scale(1.05);
        box-shadow: var(--shadow-md);
    }
    
    .map-button.active {
        background-color: var(--primary-color);
        color: var(--bg-color);
    }
    
    /* Navigation tips */
    .navigation-tips {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: var(--bg-color);
        border-radius: var(--radius-lg);
        box-shadow: var(--shadow-lg);
        padding: 24px;
        z-index: 2000;
        max-width: 90%;
        width: 350px;
        display: none;
    }
    
    .navigation-tips h3 {
        margin-bottom: 16px;
        color: var(--primary-color);
        font-weight: 700;
    }
    
    .navigation-tips ul {
        padding-left: 20px;
    }
    
    .navigation-tips li {
        margin-bottom: 12px;
        line-height: 1.5;
    }
    
    .close-button {
        position: absolute;
        top: 12px;
        right: 12px;
        background: none;
        border: none;
        font-size: 20px;
        cursor: pointer;
        color: var(--text-lighter);
        transition: var(--transition-fast);
        -webkit-tap-highlight-color: transparent;
    }
    
    .close-button:hover, .close-button:active {
        color: var(--text-color);
    }
    
    /* Congratulations */
    #congratulations {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.85);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 3000;
        color: var(--bg-color);
        text-align: center;
        padding: 24px;
        display: none;
        backdrop-filter: blur(5px);
    }
    
    #congratulations h2 {
        font-size: 36px;
        margin-bottom: 24px;
        font-weight: 800;
    }
    
    #congratulations p {
        font-size: 18px;
        margin-bottom: 32px;
        max-width: 600px;
        line-height: 1.6;
    }
    
    #congratulations button {
        background-color: var(--primary-color);
        color: var(--bg-color);
        border: none;
        padding: 16px 32px;
        border-radius: var(--radius-xl);
        font-size: 18px;
        font-weight: 600;
        cursor: pointer;
        transition: var(--transition);
        box-shadow: var(--shadow);
    }
    
    #congratulations button:hover, #congratulations button:active {
        background-color: var(--primary-dark);
        transform: translateY(-3px);
        box-shadow: var(--shadow-md);
    }
    
    /* Enhanced user marker styles */
    .user-marker-icon {
        width: 20px;
        height: 20px;
        background-color: var(--secondary-color);
        border: 3px solid white;
        border-radius: 50%;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        position: relative;
        will-change: transform;
        transform-origin: center center;
    }
    
    .user-marker-icon::after {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        width: 36px;
        height: 36px;
        background-color: rgba(229, 62, 62, 0.2);
        border-radius: 50%;
        transform: translate(-50%, -50%);
        animation: pulse 2s infinite;
        will-change: transform, opacity;
    }
    
    @keyframes pulse {
        0% {
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
        }
        100% {
            transform: translate(-50%, -50%) scale(2);
            opacity: 0;
        }
    }
    
    /* Stationary indicator - improved to eliminate jitter */
    .user-marker-stationary .user-marker-icon {
        border-color: var(--accent-color);
        transition: border-color 0.5s ease-out;
    }
    
    .user-marker-stationary .user-marker-icon::after {
        background-color: rgba(56, 161, 105, 0.15);
        animation: stationaryPulse 3s infinite;
    }
    
    @keyframes stationaryPulse {
        0% {
            transform: translate(-50%, -50%) scale(1);
            opacity: 0.6;
        }
        50% {
            transform: translate(-50%, -50%) scale(1.3);
            opacity: 0.3;
        }
        100% {
            transform: translate(-50%, -50%) scale(1);
            opacity: 0.6;
        }
    }
    
    /* Optimize for hardware acceleration */
    #map, .user-marker-icon, .lochunt-container, .trivia-container {
        transform: translateZ(0);
        backface-visibility: hidden;
        perspective: 1000px;
    }
    
    /* Stabilizing modal */
    .stabilizing-modal {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: var(--bg-color);
        padding: 24px;
        border-radius: var(--radius-lg);
        box-shadow: var(--shadow-lg);
        z-index: 2000;
        text-align: center;
        max-width: 80%;
        display: flex;
        flex-direction: column;
        align-items: center;
    }
    
    .stabilizing-modal h3 {
        margin-bottom: 16px;
        color: var(--primary-color);
        font-weight: 700;
    }
    
    .stabilizing-modal p {
        margin-bottom: 20px;
        line-height: 1.5;
    }
    
    .stabilizing-modal .spinner {
        width: 48px;
        height: 48px;
        border: 4px solid rgba(44, 82, 130, 0.2);
        border-top: 4px solid var(--primary-color);
        border-radius: 50%;
        margin-bottom: 24px;
        animation: spin 1s linear infinite;
        will-change: transform;
    }
    
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    
    /* Enhanced Preloader styles with overlay and dark green accents */
    #preloader {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 9999;
    }

    #preloader .background {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: url('https://www.mnthen.com/images/splash_screen.webp') center/cover no-repeat;
        z-index: -2;
    }

    #preloader .overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        z-index: -1;
    }

    #preloader .content-container {
        background-color: rgba(255, 255, 255, 0.98);
        padding: 40px;
        border-radius: 10px;
        width: 90%;
        max-width: 450px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
        position: relative;
        z-index: 1;
    }

    #preloader .logo-container {
        width: 180px;
        height: 180px;
        margin: 0 auto 25px;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    #preloader .logo-container img {
        width: 100%;
        height: 100%;
        object-fit: contain;
    }

    #preloader .loading-text {
        font-size: 24px;
        color: #115740; /* Dark green color */
        text-align: center;
        font-weight: 700;
        margin-bottom: 5px;
        letter-spacing: 1.2px;
        text-transform: uppercase;
    }

    #preloader .tagline {
        font-size: 16px;
        color: #115740; /* Dark green color */
        text-align: center;
        font-style: italic;
        margin-bottom: 25px;
    }

    #preloader .progress-container {
        width: 100%;
        height: 10px;
        background-color: #e0e0e0;
        border-radius: 5px;
        overflow: hidden;
        box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.2);
    }

    #preloader .progress-bar {
        height: 100%;
        background: linear-gradient(90deg, #115740 0%, #1e7d5b 100%); /* Dark green gradient */
        width: 0%;
        transition: width 0.3s ease;
        border-radius: 5px;
        will-change: width;
    }

    #preloader .status-text {
        font-size: 14px;
        color: #444444;
        margin-top: 15px;
        font-weight: 400;
        text-align: center;
        height: 20px; /* Fixed height to prevent layout shift */
    }

    #preloader .percentage {
        font-size: 16px;
        color: #115740; /* Dark green color */
        font-weight: 600;
        text-align: right;
        margin-top: 8px;
    }
    
    /* Popup styles */
    #popup {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 3000;
        display: none;
        backdrop-filter: blur(3px);
    }
    
    .popup-content {
        background-color: var(--bg-color);
        border-radius: var(--radius-lg);
        padding: 24px;
        max-width: 90%;
        width: 350px;
        text-align: center;
        box-shadow: var(--shadow-lg);
    }
    
    #popupMessage {
        margin-bottom: 24px;
        line-height: 1.5;
    }
    
    .popup-button {
        background-color: var(--primary-color);
        color: var(--bg-color);
        border: none;
        padding: 12px 24px;
        border-radius: var(--radius-lg);
        font-weight: 600;
        cursor: pointer;
        transition: var(--transition);
    }
    
    .popup-button:hover, .popup-button:active {
        background-color: var(--primary-dark);
        transform: translateY(-2px);
    }
    
    /* Enhanced Location marker styles with numbering */
    .location-marker-icon {
        width: 40px;
        height: 40px;
        background-color: #006400;
        border: 3px solid white;
        border-radius: 50%;
        box-shadow: var(--shadow);
        position: relative;
        transition: var(--transition);
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-weight: bold;
        font-size: 16px;
        will-change: transform;
    }
    
    .location-marker-icon:hover {
        transform: scale(1.1);
        background-color: var(--primary-dark);
    }
    
    /* Enhanced Marker popup styles */
    .marker-popup {
        max-width: 300px;
        padding: 0;
    }
    
    .marker-popup-image {
        width: 100%;
        height: 150px;
        object-fit: cover;
        border-radius: var(--radius-lg) var(--radius-lg) 0 0;
        margin-bottom: 0;
    }
    
    .marker-popup-content {
        padding: 16px;
    }
    
    .marker-popup-title {
        font-size: 18px;
        font-weight: bold;
        margin-bottom: 8px;
        color: var(--primary-color);
    }
    
    .marker-popup-description {
        font-size: 14px;
        margin-bottom: 16px;
        color: var(--text-light);
        line-height: 1.5;
    }
    
    .marker-popup-actions {
        display: flex;
        justify-content: space-between;
        gap: 12px;
    }
    
    .popup-btn {
        padding: 10px 16px;
        border-radius: var(--radius);
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        text-align: center;
        transition: var(--transition-fast);
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        flex: 1;
    }
    
    .popup-btn.directions {
        background-color: var(--primary-color);
        color: white;
        border: none;
    }
    
    .popup-btn.directions:hover, .popup-btn.directions:active {
        background-color: var(--primary-dark);
        transform: translateY(-2px);
    }
    
    .popup-btn.skip {
        background-color: var(--bg-light);
        color: var(--text-light);
        border: 1px solid var(--bg-dark);
    }
    
    .popup-btn.skip:hover, .popup-btn.skip:active {
        background-color: var(--bg-dark);
        transform: translateY(-2px);
    }
    
    /* Directions modal */
    #directionsModal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 3000;
        display: none;
        backdrop-filter: blur(3px);
    }
    
    .directions-modal-content {
        background-color: var(--bg-color);
        border-radius: var(--radius-lg);
        padding: 24px;
        max-width: 90%;
        width: 320px;
        box-shadow: var(--shadow-lg);
    }
    
    .directions-modal-title {
        font-size: 18px;
        font-weight: 700;
        margin-bottom: 20px;
        color: var(--text-color);
        text-align: center;
    }
    
    .directions-buttons {
        display: flex;
        flex-direction: column;
        gap: 12px;
        margin-bottom: 20px;
    }
    
    .direction-btn {
        padding: 14px;
        border-radius: var(--radius);
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        text-align: center;
        transition: var(--transition-fast);
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 12px;
        text-decoration: none;
    }
    
    .direction-btn.google {
        background-color: #4285F4;
        color: white;
        border: none;
    }
    
    .direction-btn.apple {
        background-color: #000000;
        color: white;
        border: none;
    }
    
    .direction-btn.waze {
        background-color: #33CCFF;
        color: white;
        border: none;
    }
    
    .direction-btn:hover, .direction-btn:active {
        transform: translateY(-2px);
        box-shadow: var(--shadow);
    }
    
    .cancel-btn {
        background-color: var(--bg-light);
        color: var(--text-light);
        border: 1px solid var(--bg-dark);
        padding: 12px;
        border-radius: var(--radius);
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        text-align: center;
        transition: var(--transition-fast);
        width: 100%;
    }
    
    .cancel-btn:hover, .cancel-btn:active {
        background-color: var(--bg-dark);
    }
    
    /* Leaflet popup customization */
    .leaflet-popup-content-wrapper {
        padding: 0;
        overflow: hidden;
        border-radius: var(--radius-lg);
        box-shadow: var(--shadow-md);
    }
    
    .leaflet-popup-content {
        margin: 0;
        width: 280px !important;
    }
    
    .leaflet-popup-tip-container {
        margin-top: -1px;
    }
    
    .leaflet-popup-close-button {
        color: white !important;
        top: 5px !important;
        right: 5px !important;
        font-size: 20px !important;
        text-shadow: 0 0 3px rgba(0, 0, 0, 0.5);
    }
    
    /* Enhanced popup animations */
    .leaflet-popup {
        transition: opacity 0.3s ease, transform 0.3s ease;
        will-change: transform, opacity;
    }

    .leaflet-popup.leaflet-popup-closing {
        opacity: 0;
        transform: scale(0.9);
        pointer-events: none;
    }
    
    /* Navigation buttons */
    .marker-popup-navigation {
        display: flex;
        flex-direction: column;
        gap: 10px;
        margin-top: 16px;
    }
    
    .nav-button {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        padding: 10px;
        border-radius: var(--radius);
        text-decoration: none;
        font-weight: 600;
        font-size: 14px;
        transition: var(--transition-fast);
    }
    
    .nav-button.google {
        background-color: #4285F4;
        color: white;
    }
    
    .nav-button.apple {
        background-color: #000000;
        color: white;
    }
    
    .nav-button.waze {
        background-color: #33CCFF;
        color: white;
    }
    
    .nav-button:hover, .nav-button:active {
        transform: translateY(-2px);
        box-shadow: var(--shadow);
    }
    
    /* Responsive adjustments */
    @media (max-width: 768px) {
        .map-buttons {
            bottom: 30px;
            padding: 10px 14px;
            gap: 12px;
        }
        
        .map-button {
            width: 46px;
            height: 46px;
            font-size: 20px;
        }
        
        #distanceBox {
            max-width: 280px;
            padding: 14px 16px;
        }
    }
    
    @media (max-width: 480px) {
        .map-buttons {
            bottom: 25px;
            padding: 8px 12px;
            gap: 10px;
        }
        
        .map-button {
            width: 40px;
            height: 40px;
            font-size: 16px;
        }
        
        #distanceBox {
            max-width: 260px;
            padding: 12px 14px;
            left: 12px;
            top: 12px;
            font-size: 18px;
        }
        
        #distanceBox .location-icon {
            font-size: 20px;
            margin-right: 10px;
        }
        
        #distanceBox .location-name {
            font-size: 18px;
        }
        
        #distanceBox .distance-value {
            font-size: 16px;
        }
        
        .marker-popup {
            max-width: 260px;
        }
        
        .marker-popup-image {
            height: 130px;
        }
    }

    /* Add a new media query for very small screens or devices with unusual interfaces */
    @media (max-height: 600px), (max-width: 360px) {
        .map-buttons {
            bottom: 15px;
        }
        
        .map-button {
            width: 36px;
            height: 36px;
            font-size: 14px;
        }
    }

    /* Add a safe area inset for iOS devices with notches */
    @supports (padding-bottom: env(safe-area-inset-bottom)) {
        .map-buttons {
            bottom: calc(25px + env(safe-area-inset-bottom));
        }
    }
    </style>
</head>
<body>
    <!-- Enhanced Preloader -->
    <div id="preloader">
        <div class="background"></div>
        <div class="overlay"></div>
        <div class="content-container">
            <div class="logo-container">
                <img src="https://www.mnthen.com/images/logo.webp" alt="Minnesota Then Logo">
            </div>
            <div class="loading-text">Minnesota Then Tours</div>
            <div class="tagline">Experience the Gangster Era of St. Paul</div>
            <div class="progress-container">
                <div class="progress-bar" id="preloaderProgress"></div>
            </div>
            <div class="percentage" id="loadingPercentage">0%</div>
            <div class="status-text" id="loadingStatus">Initializing map...</div>
        </div>
    </div>

    <div id="map"></div>
    
    <!-- Enhanced Distance Box -->
    <div id="distanceBox">
        <div class="location-icon">
            <i class="fas fa-map-marker-alt"></i>
        </div>
        <div class="distance-info">
            <div class="location-name">Initializing...</div>
            <div class="distance-value">Finding your location</div>
        </div>
    </div>
    
    <div class="lochunt-container">
        <img id="locationImage" src="/placeholder.svg?height=200&width=400" alt="Location Image">
        <div class="lochunt-content">
            <div class="lochunt-info">
                <h2 id="locationTitle" class="mb-2"></h2>
                <p id="locationCity" class="text-muted mb-1"></p>
                <p id="locationCreator" class="text-muted mb-3"></p>
                <p id="locationDescription" class="mb-3"></p>
                
                <div class="marker-popup-navigation">
                    <a href="#" id="googleMapsLink" class="nav-button google" target="_blank">
                        <i class="fab fa-google"></i> Google Maps
                    </a>
                    <a href="#" id="appleMapsLink" class="nav-button apple" target="_blank">
                        <i class="fab fa-apple"></i> Apple Maps
                    </a>
                    <a href="#" id="wazeLink" class="nav-button waze" target="_blank">
                        <i class="fab fa-waze"></i> Waze
                    </a>
                </div>
            </div>
            <div class="audio-player">
                <div class="audio-progress">
                    <div class="progress">
                        <div id="progressBar" class="progress-bar" role="progressbar" style="width: 0%"></div>
                    </div>
                </div>
                <div class="audio-time">
                    <span id="currentTime">0:00</span>
                    <span id="duration">0:00</span>
                </div>
                <div class="audio-controls">
                    <button id="rewindBtn" class="audio-button"><i class="fas fa-backward"></i></button>
                    <button id="playPauseBtn" class="audio-button"><i class="fas fa-play"></i></button>
                    <button id="forwardBtn" class="audio-button"><i class="fas fa-forward"></i></button>
                </div>
                <audio id="locationAudio" src="/placeholder.svg" preload="none"></audio>
            </div>
        </div>
    </div>
    
    <div class="trivia-container">
        <h3 class="mb-3">Trivia Question</h3>
        <p id="triviaQuestion" class="mb-3 fw-bold"></p>
        <div id="triviaOptions" class="d-grid gap-2"></div>
    </div>
    
    <!-- Enhanced Map Buttons: Horizontal and centered at bottom -->
    <div class="map-buttons">
        <button id="recenterButton" class="map-button" aria-label="Recenter map"><i class="fas fa-crosshairs"></i></button>
        <button id="endTourButton" class="map-button" aria-label="End tour"><i class="fas fa-sign-out-alt"></i></button>
        <button id="tipsButton" class="map-button" aria-label="Show tips"><i class="fas fa-question-circle"></i></button>
    </div>
    
    <div class="navigation-tips">
        <button class="close-button" aria-label="Close tips">&times;</button>
        <h3>Navigation Tips</h3>
        <ul>
            <li>Numbered markers show your tour stops in sequence.</li>
            <li>After visiting a location, the next stop will appear.</li>
            <li>Tap on a marker to see details and navigation options.</li>
            <li>The distance box shows how far you are from the current location.</li>
            <li>Tap the recenter button to focus on your position.</li>
            <li>When you're within 20 feet of a location, you'll be able to interact with it.</li>
            <li>Complete the trivia question to move to the next location.</li>
            <li>You can freely pinch, pan and zoom the map - it will recenter after 29 seconds of inactivity.</li>
        </ul>
    </div>
    
    <div id="congratulations">
        <h2>Congratulations!</h2>
        <p>You have successfully completed the Minnesota Then Gangster History Tour!</p>
        <button onclick="endTour()">Return to the Home Page</button>
    </div>
    
    <div id="popup">
        <div class="popup-content">
            <p id="popupMessage"></p>
            <button class="popup-button" onclick="closePopup()">OK</button>
        </div>
    </div>
    
    <!-- Directions Modal -->
    <div id="directionsModal">
        <div class="directions-modal-content">
            <div class="directions-modal-title">Choose Navigation App</div>
            <div class="directions-buttons">
                <a href="#" id="googleMapsBtn" class="direction-btn google" target="_blank">
                    <i class="fab fa-google"></i> Google Maps
                </a>
                <a href="#" id="appleMapsBtn" class="direction-btn apple" target="_blank">
                    <i class="fab fa-apple"></i> Apple Maps
                </a>
                <a href="#" id="wazeBtn" class="direction-btn waze" target="_blank">
                    <i class="fab fa-waze"></i> Waze
                </a>
            </div>
            <button class="cancel-btn" onclick="closeDirectionsModal()">Cancel</button>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    
    <script>
    (() => {
        'use strict';
        
        // Sample locations data (replace with your actual data)
        const locations = [
            {
                id: 1,
                name: "Landmark Center",
                city: "St. Paul",
                creator: "Minnesota Historical Society",
                lat: 44.9448,
                lng: -93.0962,
                image: "https://www.mnthen.com/images/landmark-center.jpg",
                audio: "https://www.mnthen.com/audio/landmark-center.mp3",
                description: "The Landmark Center, completed in 1902, originally served as the Federal Court House and Post Office for the Upper Midwest. This Richardsonian Romanesque building was where many famous gangsters were tried during the 1930s.",
                trivia: {
                    question: "What was the Landmark Center originally built as?",
                    options: [
                        "A hotel",
                        "A federal courthouse and post office",
                        "A train station",
                        "A department store"
                    ],
                    answer: 1
                }
            },
            {
                id: 2,
                name: "Wabasha Street Caves",
                city: "St. Paul",
                creator: "Minnesota Historical Society",
                lat: 44.9338,
                lng: -93.1059,
                image: "https://www.mnthen.com/images/wabasha-caves.jpg",
                audio: "https://www.mnthen.com/audio/wabasha-caves.mp3",
                description: "The Wabasha Street Caves were originally mined for silica in the 1840s. During Prohibition, the caves became a speakeasy known as the Castle Royal. Gangsters like John Dillinger and Ma Barker were rumored to frequent the establishment.",
                trivia: {
                    question: "What illegal activity took place in the Wabasha Street Caves during Prohibition?",
                    options: [
                        "Counterfeiting money",
                        "Illegal gambling",
                        "Speakeasy and nightclub",
                        "All of the above"
                    ],
                    answer: 3
                }
            },
            {
                id: 3,
                name: "Nina's Coffee Cafe",
                city: "St. Paul",
                creator: "Minnesota Historical Society",
                lat: 44.9463,
                lng: -93.1032,
                image: "https://www.mnthen.com/images/ninas-cafe.jpg",
                audio: "https://www.mnthen.com/audio/ninas-cafe.mp3",
                description: "Nina's Coffee Cafe is located in the historic Blair Flats building. The building is rumored to have been a hideout for Al Capone during his visits to St. Paul. The cafe now serves as a popular community gathering spot.",
                trivia: {
                    question: "Which famous gangster was rumored to have a hideout above what is now Nina's Coffee Cafe?",
                    options: [
                        "Al Capone",
                        "John Dillinger",
                        "Ma Barker",
                        "Baby Face Nelson"
                    ],
                    answer: 0
                }
            }
        ];

        // Create a shared object pool to reduce garbage collection
        const ObjectPool = {
            // Reusable objects
            vector2D: { x: 0, y: 0 },
            position: { lat: 0, lng: 0 },
            latLng: L.latLng(0, 0),
            point: L.point(0, 0),
            bounds: L.latLngBounds([0, 0], [0, 0]),
            
            // Get a reusable vector2D object
            getVector2D(x = 0, y = 0) {
                this.vector2D.x = x;
                this.vector2D.y = y;
                return this.vector2D;
            },
            
            // Get a reusable position object
            getPosition(lat = 0, lng = 0) {
                this.position.lat = lat;
                this.position.lng = lng;
                return this.position;
            },
            
            // Get a reusable L.latLng object
            getLatLng(lat = 0, lng = 0) {
                this.latLng.lat = lat;
                this.latLng.lng = lng;
                return this.latLng;
            },
            
            // Get a reusable L.point object
            getPoint(x = 0, y = 0) {
                this.point.x = x;
                this.point.y = y;
                return this.point;
            },
            
            // Get a reusable L.latLngBounds object
            getBounds(southWest, northEast) {
                this.bounds.setSouthWest(southWest);
                this.bounds.setNorthEast(northEast);
                return this.bounds;
            }
        };

        // Constants
        const CONSTANTS = {
            // Thresholds
            MICRO_MOVEMENT_THRESHOLD: 0.3, // meters
            STATIONARY_ACCURACY_MULTIPLIER: 1.02,
            MAX_ACCEPTABLE_ACCURACY: 25, // meters
            STATIONARY_THRESHOLD: 5, // consecutive positions
            STATIONARY_TIME_THRESHOLD: 2000, // ms
            STATIONARY_CHECK_INTERVAL: 1000, // ms
            VELOCITY_DECAY: 0.92,
            MIN_DISTANCE_THRESHOLD: 0.8, // meters
            EXTENDED_DISTANCE_THRESHOLD: 80, // meters
            UPDATE_INTERVAL: 16, // ms
            STATIONARY_POSITION_HISTORY_SIZE: 15,
            STATIONARY_POSITION_WEIGHT_DECAY: 0.9,
            BACKGROUND_THRESHOLD: 20000, // ms
            INACTIVITY_TIMEOUT: 29000, // ms
            
            // Kalman filter parameters
            KALMAN_PROCESS_NOISE: 0.004,
            KALMAN_MEASUREMENT_NOISE_BASE: 1.2,
            KALMAN_STATIONARY_NOISE: 0.02,
            
            // Animation parameters
            ANIMATION_DURATION: 180, // ms
            HEADING_SMOOTHING: 0.9,
            
            // Zoom levels
            MAX_ZOOM_LEVEL: 17,
            MIN_ZOOM_LEVEL: 13,
            DEFAULT_ZOOM_LEVEL: 17,
            PROXIMITY_ZOOM_LEVEL: 18,
            
            // Speed thresholds
            WALKING_SPEED_THRESHOLD: 1.5, // m/s
            RUNNING_SPEED_THRESHOLD: 4.0, // m/s
            DRIVING_SPEED_THRESHOLD: 8.0, // m/s
            HIGH_SPEED_THRESHOLD: 20.0, // m/s
            
            // Zoom transition
            ZOOM_TRANSITION_DURATION: 0.5, // seconds
            ZOOM_UPDATE_INTERVAL: 1000, // ms
            
            // Motion detection
            MOTION_THRESHOLD: 0.6,
            MOTION_SAMPLE_SIZE: 8,
            MOTION_CHECK_INTERVAL: 100, // ms
            
            // Edge detection
            EDGE_THRESHOLD_PERCENTAGE: 0.15,
            STRICT_EDGE_THRESHOLD_PERCENTAGE: 0.1,
            CRITICAL_EDGE_THRESHOLD_PERCENTAGE: 0.05,
            RECENTER_COOLDOWN: 500, // ms
            
            // Dynamic recentering
            SPEED_RECENTER_THRESHOLD: 5.0, // m/s
            RECENTER_OFFSET_FACTOR: 0.3,
            
            // Location thresholds
            DISTANCE_THRESHOLD: 20, // feet
            PROXIMITY_THRESHOLD: 100, // feet
            
            // Buffer sizes
            MAX_BUFFER_SIZE: 15,
            
            // Earth radius in meters
            EARTH_RADIUS: 6371000
        };

        // Global state
        const state = {
            map: null,
            userMarker: null,
            currentLocationIndex: 0,
            visitedLocations: [],
            gameLocations: [],
            inactivityTimer: null,
            isLocationHuntVisible: false,
            lastPosition: null,
            positionBuffer: [],
            velocity: { lat: 0, lng: 0 },
            isMapInteracting: false,
            followUser: true,
            allLocationMarkers: [],
            showingAllLocations: false,
            userIsInteracting: false,
            preloadedImages: new Map(),
            preloadedAudio: new Map(),
            currentSpeed: 0,
            lastZoomLevel: CONSTANTS.DEFAULT_ZOOM_LEVEL,
            stationaryPositionHistory: [],
            deviceOrientation: null,
            deviceMotion: null,
            orientationPermissionGranted: false,
            activeMarkers: [],
            currentDirectionsLocation: null,
            lastProximityState: null,
            isWithinProximity: false,
            lastUpdateTime: null,
            lastVelocity: { lat: 0, lng: 0 },
            isStationary: false,
            stationaryStartTime: null,
            stationaryCheckTimeout: null,
            lastUpdateTimestamp: null,
            lastHiddenTime: 0,
            stationaryCount: 0,
            lastRecenterTime: Date.now(),
            stationaryBuffer: [],
            isStabilizing: true,
            lastStationaryPosition: null,
            motionSamples: [],
            deviceStationaryTime: 0,
            animationFrameId: null,
            renderTimestamp: null,
            positionUpdateQueue: [],
            lastHeadingValue: null,
            headingBuffer: [],
            isFirstPositionUpdate: true,
            lastRenderPosition: null,
            positionInterpolator: null,
            lastRawPosition: null,
            consecutiveStationaryUpdates: 0,
            lastDeviceMotionTimestamp: 0,
            deviceMotionBuffer: [],
            isDeviceStable: false,
            lastAccuracy: null,
            accuracyTrend: [],
            lastHeadingUpdateTime: 0,
            lastPositionUpdateTime: 0,
            lastZoomUpdateTime: 0,
            targetZoomLevel: CONSTANTS.DEFAULT_ZOOM_LEVEL,
            lastSpeedForZoom: 0,
            speedSamples: [],
            lastRecenterCheckTime: 0,
            lastProximityCheckTime: 0,
            proximityZoomActive: false,
            forceCenteringActive: false,
            centeringPriority: 0,
            userInteractionTime: Date.now(),
            smoothTransitionActive: false,
            kalmanFilter: null,
            
            // Reset state for testing or restarting
            reset() {
                this.currentLocationIndex = 0;
                this.visitedLocations = [];
                this.isLocationHuntVisible = false;
                this.lastPosition = null;
                this.positionBuffer = [];
                this.velocity = { lat: 0, lng: 0 };
                this.isMapInteracting = false;
                this.followUser = true;
                this.showingAllLocations = false;
                this.userIsInteracting = false;
                this.currentSpeed = 0;
                this.lastZoomLevel = CONSTANTS.DEFAULT_ZOOM_LEVEL;
                this.stationaryPositionHistory = [];
                this.activeMarkers = [];
                this.currentDirectionsLocation = null;
                this.lastProximityState = null;
                this.isWithinProximity = false;
                this.lastUpdateTime = null;
                this.lastVelocity = { lat: 0, lng: 0 };
                this.isStationary = false;
                this.stationaryStartTime = null;
                this.lastUpdateTimestamp = null;
                this.stationaryCount = 0;
                this.stationaryBuffer = [];
                this.isStabilizing = true;
                this.lastStationaryPosition = null;
                this.motionSamples = [];
                this.deviceStationaryTime = 0;
                this.renderTimestamp = null;
                this.positionUpdateQueue = [];
                this.isFirstPositionUpdate = true;
                this.lastRenderPosition = null;
                this.lastRawPosition = null;
                this.consecutiveStationaryUpdates = 0;
                this.deviceMotionBuffer = [];
                this.isDeviceStable = false;
                this.lastAccuracy = null;
                this.accuracyTrend = [];
                this.targetZoomLevel = CONSTANTS.DEFAULT_ZOOM_LEVEL;
                this.lastSpeedForZoom = 0;
                this.speedSamples = [];
                this.proximityZoomActive = false;
                this.forceCenteringActive = false;
                this.centeringPriority = 0;
                this.smoothTransitionActive = false;
                
                if (this.inactivityTimer) {
                    clearTimeout(this.inactivityTimer);
                    this.inactivityTimer = null;
                }
                
                if (this.stationaryCheckTimeout) {
                    clearTimeout(this.stationaryCheckTimeout);
                    this.stationaryCheckTimeout = null;
                }
                
                if (this.animationFrameId) {
                    cancelAnimationFrame(this.animationFrameId);
                    this.animationFrameId = null;
                }
                
                // Reset Kalman filter
                if (this.kalmanFilter) {
                    this.kalmanFilter = new KalmanFilter();
                }
                
                // Reset position interpolator
                if (this.positionInterpolator) {
                    this.positionInterpolator = new PositionInterpolator();
                }
            }
        };

        // Enhanced Kalman Filter implementation
        class KalmanFilter {
            constructor() {
                // State variables
                this.x = 0; // Longitude estimate
                this.y = 0; // Latitude estimate
                this.vx = 0; // Longitude velocity
                this.vy = 0; // Latitude velocity

                // Error covariance matrix - using a typed array for better performance
                this.P = new Float64Array(16);
                this.P[0] = 100; // Initial high uncertainty
                this.P[5] = 100;
                this.P[10] = 10;
                this.P[15] = 10;

                // Process noise
                this.Q = CONSTANTS.KALMAN_PROCESS_NOISE;

                // Measurement noise (will be adjusted based on GPS accuracy)
                this.R = CONSTANTS.KALMAN_MEASUREMENT_NOISE_BASE;

                // Time delta
                this.dt = 1.0;

                // Initialized flag
                this.initialized = false;

                // Heading and accuracy tracking
                this.lastHeading = null;
                this.headingConfidence = 0;

                // Stationary mode flag
                this.stationaryMode = false;

                // Last timestamp
                this.lastTimestamp = null;

                // Adaptive noise parameters
                this.adaptiveNoiseMin = 0.002;
                this.adaptiveNoiseMax = 0.015;
                this.adaptiveNoiseFactor = 1.0;

                // Accuracy history - using a circular buffer for better performance
                this.accuracyHistory = new Float64Array(5);
                this.accuracyHistoryIndex = 0;
                this.accuracyHistorySize = 0;
                this.maxAccuracyHistorySize = 5;

                // Jitter detection
                this.positionHistory = [];
                this.maxPositionHistorySize = 5;
                this.jitterThreshold = 0.5; // meters

                // Heading stability - using a circular buffer for better performance
                this.headingHistory = new Float64Array(8);
                this.headingTimestamps = new Float64Array(8);
                this.headingHistoryIndex = 0;
                this.headingHistorySize = 0;
                this.maxHeadingHistorySize = 8;
                
                // Reusable arrays for matrix operations
                this._tempMatrix1 = new Float64Array(16);
                this._tempMatrix2 = new Float64Array(16);
                this._tempVector = new Float64Array(4);
                this._K = new Float64Array(8); // Kalman gain matrix (4x2)
                this._S = new Float64Array(4); // Innovation covariance matrix (2x2)
                this._invS = new Float64Array(4); // Inverse of S (2x2)
            }

            // Initialize the filter with first position
            reset(position) {
                if (!position || typeof position.lat !== "number" || typeof position.lng !== "number") {
                    console.error("Invalid position for Kalman filter reset");
                    return;
                }

                this.x = position.lng;
                this.y = position.lat;
                this.vx = 0;
                this.vy = 0;

                // Reset covariance matrix with high initial uncertainty
                this.P.fill(0);
                this.P[0] = 100;
                this.P[5] = 100;
                this.P[10] = 10;
                this.P[15] = 10;

                this.initialized = true;
                this.lastHeading = position.heading || null;
                this.headingConfidence = 0;
                this.stationaryMode = false;
                this.lastTimestamp = position.timestamp || Date.now();
                this.adaptiveNoiseFactor = 1.0;
                
                // Reset history buffers
                this.accuracyHistoryIndex = 0;
                this.accuracyHistorySize = 0;
                this.headingHistoryIndex = 0;
                this.headingHistorySize = 0;
                this.positionHistory = [];

                // Add initial position to history
                this.addToPositionHistory(position);
                if (position.accuracy) {
                    this.addToAccuracyHistory(position.accuracy);
                }
                if (position.heading !== null && position.heading !== undefined) {
                    this.addToHeadingHistory(position.heading, position.timestamp || Date.now());
                }
            }

            // Add position to history
            addToPositionHistory(position) {
                this.positionHistory.push({
                    lat: position.lat,
                    lng: position.lng,
                    timestamp: position.timestamp || Date.now(),
                });

                while (this.positionHistory.length > this.maxPositionHistorySize) {
                    this.positionHistory.shift();
                }
            }

            // Add accuracy to history using a circular buffer
            addToAccuracyHistory(accuracy) {
                this.accuracyHistory[this.accuracyHistoryIndex] = accuracy;
                this.accuracyHistoryIndex = (this.accuracyHistoryIndex + 1) % this.maxAccuracyHistorySize;
                if (this.accuracyHistorySize < this.maxAccuracyHistorySize) {
                    this.accuracyHistorySize++;
                }
            }

            // Add heading to history using a circular buffer
            addToHeadingHistory(heading, timestamp) {
                // Normalize heading to 0-360 range
                heading = ((heading % 360) + 360) % 360;

                this.headingHistory[this.headingHistoryIndex] = heading;
                this.headingTimestamps[this.headingHistoryIndex] = timestamp;
                this.headingHistoryIndex = (this.headingHistoryIndex + 1) % this.maxHeadingHistorySize;
                if (this.headingHistorySize < this.maxHeadingHistorySize) {
                    this.headingHistorySize++;
                }
            }

            // Get median accuracy from history
            getMedianAccuracy() {
                if (this.accuracyHistorySize === 0) return 20;

                // Copy values to a temporary array for sorting
                const sortedAccuracies = new Float64Array(this.accuracyHistorySize);
                for (let i = 0; i < this.accuracyHistorySize; i++) {
                    sortedAccuracies[i] = this.accuracyHistory[i];
                }
                
                // Sort the array
                sortedAccuracies.sort();
                
                const mid = Math.floor(this.accuracyHistorySize / 2);
                if (this.accuracyHistorySize % 2 === 0) {
                    return (sortedAccuracies[mid - 1] + sortedAccuracies[mid]) / 2;
                } else {
                    return sortedAccuracies[mid];
                }
            }

            // Detect jitter in position history
            detectJitter() {
                if (this.positionHistory.length < 3) return false;

                // Calculate distances between consecutive positions
                const distances = [];
                for (let i = 1; i < this.positionHistory.length; i++) {
                    const p1 = this.positionHistory[i - 1];
                    const p2 = this.positionHistory[i];

                    // Calculate distance in meters
                    const distance = calculateDistance(p1, p2);

                    // Calculate time delta in seconds
                    const timeDelta = (p2.timestamp - p1.timestamp) / 1000;

                    // Calculate speed in m/s
                    const speed = timeDelta > 0 ? distance / timeDelta : 0;

                    distances.push({ distance, speed });
                }

                // Check for rapid direction changes (jitter)
                if (distances.length >= 2) {
                    const lastDistance = distances[distances.length - 1].distance;
                    const prevDistance = distances[distances.length - 2].distance;

                    // If both distances are small but non-zero, it might be jitter
                    if (
                        lastDistance > 0 &&
                        lastDistance < this.jitterThreshold &&
                        prevDistance > 0 &&
                        prevDistance < this.jitterThreshold
                    ) {
                        return true;
                    }
                }

                return false;
            }

            // Get stable heading from history
            getStableHeading() {
                if (this.headingHistorySize < 3) {
                    return this.lastHeading;
                }

                // Get recent headings (last 3)
                const recentHeadings = new Float64Array(3);
                for (let i = 0; i < 3; i++) {
                    const idx = (this.headingHistoryIndex - 1 - i + this.maxHeadingHistorySize) % this.maxHeadingHistorySize;
                    recentHeadings[i] = this.headingHistory[idx];
                }

                // Check if headings are stable (within 15 degrees of each other)
                let isStable = true;
                for (let i = 1; i < recentHeadings.length; i++) {
                    const diff = Math.abs(recentHeadings[i] - recentHeadings[i - 1]);
                    const normalizedDiff = Math.min(diff, 360 - diff);
                    if (normalizedDiff > 15) {
                        isStable = false;
                        break;
                    }
                }

                if (isStable) {
                    // Sort the array for median
                    recentHeadings.sort();
                    return recentHeadings[1]; // Middle value is the median of 3
                }

                return this.lastHeading;
            }

            // Set stationary mode
            setStationaryMode(isStationary) {
                this.stationaryMode = isStationary;

                // When entering stationary mode, reduce velocity to zero
                if (isStationary) {
                    this.vx = 0;
                    this.vy = 0;

                    // Reduce process noise for stationary mode
                    this.Q = CONSTANTS.KALMAN_STATIONARY_NOISE;
                    this.adaptiveNoiseFactor = 0.4; // Reduce noise in stationary mode
                } else {
                    // Reset to normal process noise when moving
                    this.Q = CONSTANTS.KALMAN_PROCESS_NOISE;
                    this.adaptiveNoiseFactor = 1.0; // Normal noise when moving
                }
            }

            // Adjust process noise based on accuracy and motion
            adjustProcessNoise(accuracy, motionDetected) {
                // Base noise level depends on GPS accuracy
                let noiseLevel =
                    this.adaptiveNoiseMin + (this.adaptiveNoiseMax - this.adaptiveNoiseMin) * Math.min(1.0, accuracy / 40.0);

                // Reduce noise when stationary
                if (this.stationaryMode) {
                    noiseLevel *= 0.4;
                }

                // Increase noise when motion is detected
                if (motionDetected && !this.stationaryMode) {
                    noiseLevel *= 1.8;
                }

                // Increase noise when jitter is detected
                if (this.detectJitter()) {
                    noiseLevel *= 0.5; // Reduce noise to smooth out jitter
                }

                // Apply adaptive factor
                noiseLevel *= this.adaptiveNoiseFactor;

                // Set process noise
                this.Q = noiseLevel;
            }

            // Update the filter with new measurement - optimized implementation
            update(position, motionDetected = false) {
                if (!this.initialized) {
                    this.reset(position);
                    return position;
                }

                if (!position || typeof position.lat !== "number" || typeof position.lng !== "number") {
                    console.warn("Invalid position input to Kalman filter");
                    return {
                        lat: this.y,
                        lng: this.x,
                        accuracy: position?.accuracy || 20,
                        heading: this.lastHeading,
                        timestamp: position?.timestamp || Date.now(),
                    };
                }

                // Add to position history
                this.addToPositionHistory(position);

                // Add to accuracy history
                if (position.accuracy) {
                    this.addToAccuracyHistory(position.accuracy);
                }

                // Add to heading history
                if (position.heading !== null && position.heading !== undefined) {
                    this.addToHeadingHistory(position.heading, position.timestamp || Date.now());
                }

                // Calculate time delta
                const timestamp = position.timestamp || Date.now();
                if (this.lastTimestamp) {
                    this.dt = Math.min(Math.max((timestamp - this.lastTimestamp) / 1000, 0.01), 1.0);
                }
                this.lastTimestamp = timestamp;

                // Adjust measurement noise based on GPS accuracy
                const accuracy = position.accuracy || 20;
                const medianAccuracy = this.getMedianAccuracy();
                this.R = Math.max(CONSTANTS.KALMAN_MEASUREMENT_NOISE_BASE, medianAccuracy / 10);

                // If in stationary mode, increase measurement noise to reduce jitter
                if (this.stationaryMode) {
                    this.R *= 2.0;
                }

                // Adjust process noise based on accuracy and motion
                this.adjustProcessNoise(accuracy, motionDetected);

                // Predict step
                // x = F * x
                const predictedX = this.x + this.dt * this.vx;
                const predictedY = this.y + this.dt * this.vy;
                const predictedVx = this.stationaryMode ? 0 : this.vx;
                const predictedVy = this.stationaryMode ? 0 : this.vy;

                // P = F * P * F' + Q
                // Optimized matrix multiplication using temporary arrays
                const dt = this.dt;
                const dt2 = dt * dt;
                const dt3 = dt2 * dt;
                const dt4 = dt3 * dt;
                const Q = this.Q;

                // Process noise matrix Q
                const Q00 = (Q * dt4) / 4;
                const Q02 = (Q * dt3) / 2;
                const Q20 = (Q * dt3) / 2;
                const Q22 = Q * dt2;

                // Compute F*P
                const FP = this._tempMatrix1;
                FP[0] = this.P[0] + dt * this.P[8];
                FP[1] = this.P[1] + dt * this.P[9];
                FP[2] = this.P[2] + dt * this.P[10];
                FP[3] = this.P[3] + dt * this.P[11];
                FP[4] = this.P[4] + dt * this.P[12];
                FP[5] = this.P[5] + dt * this.P[13];
                FP[6] = this.P[6] + dt * this.P[14];
                FP[7] = this.P[7] + dt * this.P[15];
                FP[8] = this.P[8];
                FP[9] = this.P[9];
                FP[10] = this.P[10];
                FP[11] = this.P[11];
                FP[12] = this.P[12];
                FP[13] = this.P[13];
                FP[14] = this.P[14];
                FP[15] = this.P[15];

                // Compute F*P*F' + Q
                const predictedP = this._tempMatrix2;
                predictedP[0] = FP[0] + dt * FP[8] + Q00;
                predictedP[1] = FP[1] + dt * FP[9];
                predictedP[2] = FP[2] + dt * FP[10];
                predictedP[3] = FP[3] + dt * FP[11];
                predictedP[4] = FP[4] + dt * FP[12];
                predictedP[5] = FP[5] + dt * FP[13] + Q00;
                predictedP[6] = FP[6] + dt * FP[14];
                predictedP[7] = FP[7] + dt * FP[15];
                predictedP[8] = FP[8] + Q20;
                predictedP[9] = FP[9];
                predictedP[10] = FP[10] + Q22;
                predictedP[11] = FP[11];
                predictedP[12] = FP[12];
                predictedP[13] = FP[13] + Q20;
                predictedP[14] = FP[14];
                predictedP[15] = FP[15] + Q22;

                // Update step
                // y = z - H * x
                const measurementResidualX = position.lng - predictedX;
                const measurementResidualY = position.lat - predictedY;

                // S = H * P * H' + R
                const S = this._S;
                S[0] = predictedP[0] + this.R;
                S[1] = predictedP[1];
                S[2] = predictedP[4];
                S[3] = predictedP[5] + this.R;

                // Calculate determinant of S
                const detS = S[0] * S[3] - S[1] * S[2];

                // Calculate inverse of S
                const invS = this._invS;
                invS[0] = S[3] / detS;
                invS[1] = -S[1] / detS;
                invS[2] = -S[2] / detS;
                invS[3] = S[0] / detS;

                // K = P * H' * inv(S)
                const K = this._K;
                K[0] = predictedP[0] * invS[0] + predictedP[1] * invS[2];
                K[1] = predictedP[0] * invS[1] + predictedP[1] * invS[3];
                K[2] = predictedP[4] * invS[0] + predictedP[5] * invS[2];
                K[3] = predictedP[4] * invS[1] + predictedP[5] * invS[3];
                K[4] = predictedP[8] * invS[0] + predictedP[9] * invS[2];
                K[5] = predictedP[8] * invS[1] + predictedP[9] * invS[3];
                K[6] = predictedP[12] * invS[0] + predictedP[13] * invS[2];
                K[7] = predictedP[12] * invS[1] + predictedP[13] * invS[3];

                // x = x + K * y
                this.x = predictedX + K[0] * measurementResidualX + K[1] * measurementResidualY;
                this.y = predictedY + K[2] * measurementResidualX + K[3] * measurementResidualY;

                // In stationary mode, keep velocity at zero
                if (this.stationaryMode) {
                    this.vx = 0;
                    this.vy = 0;
                } else {
                    this.vx = predictedVx + K[4] * measurementResidualX + K[5] * measurementResidualY;
                    this.vy = predictedVy + K[6] * measurementResidualX + K[7] * measurementResidualY;
                }

                // P = (I - K * H) * P
                // Optimized matrix multiplication
                this.P[0] = predictedP[0] - (K[0] * predictedP[0] + K[1] * predictedP[4]);
                this.P[1] = predictedP[1] - (K[0] * predictedP[1] + K[1] * predictedP[5]);
                this.P[2] = predictedP[2] - (K[0] * predictedP[2] + K[1] * predictedP[6]);
                this.P[3] = predictedP[3] - (K[0] * predictedP[3] + K[1] * predictedP[7]);
                this.P[4] = predictedP[4] - (K[2] * predictedP[0] + K[3] * predictedP[4]);
                this.P[5] = predictedP[5] - (K[2] * predictedP[1] + K[3] * predictedP[5]);
                this.P[6] = predictedP[6] - (K[2] * predictedP[2] + K[3] * predictedP[6]);
                this.P[7] = predictedP[7] - (K[2] * predictedP[3] + K[3] * predictedP[7]);
                this.P[8] = predictedP[8] - (K[4] * predictedP[0] + K[5] * predictedP[4]);
                this.P[9] = predictedP[9] - (K[4] * predictedP[1] + K[5] * predictedP[5]);
                this.P[10] = predictedP[10] - (K[4] * predictedP[2] + K[5] * predictedP[6]);
                this.P[11] = predictedP[11] - (K[4] * predictedP[3] + K[5] * predictedP[7]);
                this.P[12] = predictedP[12] - (K[6] * predictedP[0] + K[7] * predictedP[4]);
                this.P[13] = predictedP[13] - (K[6] * predictedP[1] + K[7] * predictedP[5]);
                this.P[14] = predictedP[14] - (K[6] * predictedP[2] + K[7] * predictedP[6]);
                this.P[15] = predictedP[15] - (K[6] * predictedP[3] + K[7] * predictedP[7]);

                // Process heading data
                let smoothedHeading = position.heading;
                if (position.heading !== null && position.heading !== undefined) {
                    // Get stable heading from history
                    smoothedHeading = this.getStableHeading();

                    // If no stable heading yet, use current heading
                    if (smoothedHeading === null) {
                        smoothedHeading = position.heading;
                    }

                    this.lastHeading = smoothedHeading;
                }

                // Calculate speed from velocity components
                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);

                return {
                    lat: this.y,
                    lng: this.x,
                    accuracy: position.accuracy,
                    heading: smoothedHeading,
                    timestamp: position.timestamp,
                    speedMPS: this.stationaryMode ? 0 : speed * 111000, // Convert from degrees/second to meters/second (approximate)
                };
            }
        }

        // Position interpolator for smooth transitions
        class PositionInterpolator {
            constructor() {
                this.startPosition = null;
                this.targetPosition = null;
                this.startTime = null;
                this.duration = 0;
                this.isActive = false;
                this.lastInterpolatedPosition = null;
            }

            start(startPos, targetPos, duration) {
                if (!startPos || !targetPos) return;

                // Don't interpolate if positions are too close
                const distance = calculateDistance(startPos, targetPos);
                if (distance < 0.1) {
                    this.isActive = false;
                    this.lastInterpolatedPosition = targetPos;
                    return;
                }

                this.startPosition = { 
                    lat: startPos.lat, 
                    lng: startPos.lng,
                    accuracy: startPos.accuracy,
                    heading: startPos.heading,
                    timestamp: startPos.timestamp,
                    speedMPS: startPos.speedMPS
                };
                
                this.targetPosition = { 
                    lat: targetPos.lat, 
                    lng: targetPos.lng,
                    accuracy: targetPos.accuracy,
                    heading: targetPos.heading,
                    timestamp: targetPos.timestamp,
                    speedMPS: targetPos.speedMPS
                };
                
                this.startTime = performance.now();
                this.duration = duration;
                this.isActive = true;
            }

            update() {
                if (!this.isActive) return this.lastInterpolatedPosition || this.targetPosition;

                const now = performance.now();
                const elapsed = now - this.startTime;

                if (elapsed >= this.duration) {
                    this.isActive = false;
                    this.lastInterpolatedPosition = this.targetPosition;
                    return this.targetPosition;
                }

                // Calculate progress with easing
                const t = elapsed / this.duration;
                const easedT = this.easeOutCubic(t);

                // Interpolate position
                const interpolatedPosition = {
                    lat: this.startPosition.lat + (this.targetPosition.lat - this.startPosition.lat) * easedT,
                    lng: this.startPosition.lng + (this.targetPosition.lng - this.startPosition.lng) * easedT,
                    accuracy: this.targetPosition.accuracy,
                    heading: this.targetPosition.heading,
                    timestamp: now,
                    speedMPS: this.targetPosition.speedMPS,
                };

                this.lastInterpolatedPosition = interpolatedPosition;
                return interpolatedPosition;
            }

            // Cubic easing function for smoother motion
            easeOutCubic(t) {
                return 1 - Math.pow(1 - t, 3);
            }

            isInterpolating() {
                return this.isActive;
            }

            cancel() {
                this.isActive = false;
            }

            getLastPosition() {
                return this.lastInterpolatedPosition || this.targetPosition;
            }
        }

        // Initialize Kalman filter and position interpolator
        state.kalmanFilter = new KalmanFilter();
        state.positionInterpolator = new PositionInterpolator();

        // Calculate distance between two points using Haversine formula
        function calculateDistance(pos1, pos2) {
            if (
                !pos1 ||
                !pos2 ||
                typeof pos1.lat !== "number" ||
                typeof pos1.lng !== "number" ||
                typeof pos2.lat !== "number" ||
                typeof pos2.lng !== "number"
            ) {
                return Number.POSITIVE_INFINITY;
            }

            const R = CONSTANTS.EARTH_RADIUS; // Earth's radius in meters
            const lat1 = (pos1.lat * Math.PI) / 180;
            const lat2 = (pos2.lat * Math.PI) / 180;
            const deltaLat = ((pos2.lat - pos1.lat) * Math.PI) / 180;
            const deltaLng = ((pos2.lng - pos1.lng) * Math.PI) / 180;

            const a =
                Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) +
                Math.cos(lat1) * Math.cos(lat2) * Math.sin(deltaLng / 2) * Math.sin(deltaLng / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

            return R * c;
        }

        // Check if device is in motion based on motion sensors
        function isDeviceInMotion() {
            if (!state.motionSamples || state.motionSamples.length < 3) {
                return false;
            }

            // Calculate average motion magnitude
            let sum = 0;
            for (let i = 0; i < state.motionSamples.length; i++) {
                const sample = state.motionSamples[i];
                sum += Math.sqrt(sample.x * sample.x + sample.y * sample.y + sample.z * sample.z);
            }
            const avgMotion = sum / state.motionSamples.length;

            return avgMotion > CONSTANTS.MOTION_THRESHOLD;
        }

        // Process device motion data
        function handleDeviceMotion(event) {
            if (!event || !event.acceleration) return;

            const now = Date.now();
            // Throttle motion updates for better performance
            if (now - state.lastDeviceMotionTimestamp < 50) return;
            state.lastDeviceMotionTimestamp = now;

            const motion = {
                x: event.acceleration.x || 0,
                y: event.acceleration.y || 0,
                z: event.acceleration.z || 0,
                timestamp: now,
            };

            // Add to motion samples
            state.motionSamples.push(motion);

            // Keep only recent samples
            while (state.motionSamples.length > CONSTANTS.MOTION_SAMPLE_SIZE) {
                state.motionSamples.shift();
            }

            // Update device motion state
            state.deviceMotion = motion;

            // Add to device motion buffer for stability detection
            state.deviceMotionBuffer.push({
                magnitude: Math.sqrt(motion.x * motion.x + motion.y * motion.y + motion.z * motion.z),
                timestamp: now,
            });

            // Keep buffer at reasonable size
            while (state.deviceMotionBuffer.length > 10) {
                state.deviceMotionBuffer.shift();
            }

            // Check if device is stationary based on motion
            const inMotion = isDeviceInMotion();

            if (!inMotion) {
                state.deviceStationaryTime += 50; // Increment by throttle time
            } else {
                state.deviceStationaryTime = 0;
            }
        }

        // Process device orientation data
        function handleDeviceOrientation(event) {
            if (!event || event.alpha === null) return;

            const now = Date.now();
            // Throttle heading updates
            if (now - state.lastHeadingUpdateTime < 100) return;
            state.lastHeadingUpdateTime = now;

            state.deviceOrientation = {
                alpha: event.alpha, // z-axis rotation [0,360)
                beta: event.beta, // x-axis rotation [-180,180)
                gamma: event.gamma, // y-axis rotation [-90,90)
                timestamp: now,
            };

            // Update heading buffer if we have a compass heading
            if (event.webkitCompassHeading !== undefined) {
                const heading = event.webkitCompassHeading;

                // Add to heading buffer
                state.headingBuffer.push(heading);

                // Keep only recent headings
                while (state.headingBuffer.length > 8) {
                    state.headingBuffer.shift();
                }

                // Calculate median heading to filter outliers
                if (state.headingBuffer.length >= 3) {
                    const sortedHeadings = [...state.headingBuffer].sort((a, b) => a - b);
                    state.lastHeadingValue = sortedHeadings[Math.floor(sortedHeadings.length / 2)];
                }
            }
        }

        // Request device motion and orientation permissions
        function requestMotionPermission() {
            if (typeof DeviceMotionEvent !== "undefined" && typeof DeviceMotionEvent.requestPermission === "function") {
                DeviceMotionEvent.requestPermission()
                    .then((response) => {
                        if (response === "granted") {
                            window.addEventListener("devicemotion", handleDeviceMotion, { passive: true });
                        }
                    })
                    .catch(console.error);
            } else {
                window.addEventListener("devicemotion", handleDeviceMotion, { passive: true });
            }

            if (typeof DeviceOrientationEvent !== "undefined" && typeof DeviceOrientationEvent.requestPermission === "function") {
                DeviceOrientationEvent.requestPermission()
                    .then((response) => {
                        if (response === "granted") {
                            state.orientationPermissionGranted = true;
                            window.addEventListener("deviceorientation", handleDeviceOrientation, { passive: true });
                        }
                    })
                    .catch(console.error);
            } else {
                window.addEventListener("deviceorientation", handleDeviceOrientation, { passive: true });
                state.orientationPermissionGranted = true;
            }
        }

        // Animation loop for smooth rendering
        function startAnimationLoop() {
            function animate(timestamp) {
                // Calculate delta time
                const deltaTime = state.renderTimestamp ? (timestamp - state.renderTimestamp) / 1000 : 0;
                state.renderTimestamp = timestamp;

                // Process position updates
                processPositionUpdateQueue();

                // Update interpolated position
                if (state.positionInterpolator && state.positionInterpolator.isInterpolating()) {
                    const interpolatedPosition = state.positionInterpolator.update();
                    if (interpolatedPosition) {
                        // Update marker position
                        state.userMarker.setLatLng([interpolatedPosition.lat, interpolatedPosition.lng]);
                        state.lastRenderPosition = interpolatedPosition;

                        // Update marker rotation if heading is available
                        if (interpolatedPosition.heading !== null && interpolatedPosition.heading !== undefined) {
                            updateMarkerRotation(interpolatedPosition.heading);
                        }
                    }
                }

                // Only keep user centered if followUser is true and user is not interacting with map
                if (state.followUser && !state.isMapInteracting && !state.userIsInteracting) {
                    if (state.userMarker && state.userMarker.getLatLng()) {
                        state.map.setView(state.userMarker.getLatLng(), state.map.getZoom(), {
                            animate: true,
                            duration: 0.3,
                            noMoveStart: true
                        });
                    }
                }

                // Update zoom level based on speed and proximity
                updateDynamicZoom();

                // Check for proximity to locations
                if (Date.now() - state.lastProximityCheckTime > 500) {
                    checkProximityForZoom();
                    state.lastProximityCheckTime = Date.now();
                }

                // Request next frame
                state.animationFrameId = requestAnimationFrame(animate);
            }

            // Start animation loop
            state.animationFrameId = requestAnimationFrame(animate);
        }

        // Update marker rotation based on heading
        function updateMarkerRotation(heading) {
            const markerElement = state.userMarker.getElement();
            if (markerElement) {
                const iconElement = markerElement.querySelector(".user-marker-icon");
                if (iconElement) {
                    // Apply smooth rotation with CSS transform
                    iconElement.style.transform = `rotate(${heading}deg)`;
                }
            }
        }

        // Process position update queue
        function processPositionUpdateQueue() {
            if (state.positionUpdateQueue.length === 0) return;

            // Process all updates in queue
            while (state.positionUpdateQueue.length > 0) {
                const update = state.positionUpdateQueue.shift();
                processPositionUpdate(update);
            }
        }

        function processPositionUpdate(position) {
            // Validate position
            if (!position || typeof position.lat !== "number" || typeof position.lng !== "number") {
                return;
            }

            // Update tracking variables
            state.lastPosition = position;
            state.currentSpeed = position.speedMPS || 0;
            
            // Maintain speed samples (5-point buffer)
            state.speedSamples.push(state.currentSpeed);
            if (state.speedSamples.length > 5) state.speedSamples.shift();

            // Update marker stationary state
            const markerElement = state.userMarker.getElement();
            if (markerElement) {
                markerElement.classList.toggle("user-marker-stationary", state.isStationary);
            }

            // Calculate movement distance if we have previous position
            const distance = state.lastRenderPosition ? calculateDistance(state.lastRenderPosition, position) : 0;

            // Handle position update
            if (!state.lastRenderPosition || state.isFirstPositionUpdate) {
                // Initial position - set directly
                state.userMarker.setLatLng([position.lat, position.lng]);
                state.lastRenderPosition = position;
                state.isFirstPositionUpdate = false;
            } 
            else if (distance > CONSTANTS.EXTENDED_DISTANCE_THRESHOLD) {
                // Large movement - update immediately without animation
                state.userMarker.setLatLng([position.lat, position.lng]);
                state.lastRenderPosition = position;
                
                // Cancel any ongoing animation
                if (state.positionInterpolator) {
                    state.positionInterpolator.cancel();
                }
            }
            else {
                // Normal movement - apply smooth interpolation
                const animDuration = state.isStationary ? 
                    (distance < 0.5 ? 600 : 400) : // Longer duration for stationary micro-movements
                    CONSTANTS.ANIMATION_DURATION;
                
                state.positionInterpolator.start(state.lastRenderPosition, position, animDuration);
            }

            // Update marker rotation if heading available
            if (position.heading !== null && position.heading !== undefined) {
                updateMarkerRotation(position.heading);
            }

            // Only keep user centered if followUser is true and user is not interacting with map
            if (state.followUser && !state.isMapInteracting && !state.userIsInteracting) {
                state.map.setView([position.lat, position.lng], state.map.getZoom(), {
                    animate: true,
                    duration: 0.3
                });
            }
            
            // Check nearby points of interest
            checkNearbyLocations();
        }
        
        // Check for proximity to locations for zoom level adjustment
        function checkProximityForZoom() {
            if (!state.lastPosition || !state.gameLocations || state.gameLocations.length === 0) return;
            
            // Only check the current location
            const location = state.gameLocations[state.currentLocationIndex];
            if (!location) return;
            
            // Calculate distance to current location
            const distance = calculateDistance(
                { lat: state.lastPosition.lat, lng: state.lastPosition.lng },
                { lat: location.lat, lng: location.lng }
            );
            
            // Convert to feet
            const distanceFeet = Math.round(distance * 3.28084);
            
            // Check if user is within proximity threshold
            const withinProximity = distanceFeet <= CONSTANTS.PROXIMITY_THRESHOLD;
            
            // Only update if proximity state has changed
            if (withinProximity !== state.isWithinProximity) {
                state.isWithinProximity = withinProximity;
                
                // Adjust zoom level based on proximity
                if (state.isWithinProximity && !state.proximityZoomActive) {
                    // Zoom in when entering proximity
                    state.proximityZoomActive = true;
                    if (state.map && state.followUser) {
                        state.map.setZoom(CONSTANTS.PROXIMITY_ZOOM_LEVEL, {
                            animate: true,
                            duration: 1.0,
                            noMoveStart: true
                        });
                    }
                } else if (!state.isWithinProximity && state.proximityZoomActive) {
                    // Zoom out when leaving proximity
                    state.proximityZoomActive = false;
                    if (state.map && state.followUser) {
                        state.map.setZoom(CONSTANTS.DEFAULT_ZOOM_LEVEL, {
                            animate: true,
                            duration: 1.0,
                            noMoveStart: true
                        });
                    }
                }
            }
        }

        // Check for nearby locations
        function checkNearbyLocations() {
            if (!state.lastPosition || !state.gameLocations || state.isLocationHuntVisible) return;
            
            // Only check the current location (progressive display)
            const location = state.gameLocations[state.currentLocationIndex];
            if (!location) return;
            
            // Skip if already visited
            if (state.visitedLocations.includes(location.id)) return;
            
            const distance = calculateDistance(
                { lat: state.lastPosition.lat, lng: state.lastPosition.lng },
                { lat: location.lat, lng: location.lng }
            );
            
            // Convert to feet
            const distanceFeet = Math.round(distance * 3.28084);
            
            // Update distance box
            updateDistanceBox(location, distanceFeet);
            
            // Check if user is close enough to interact
            if (distanceFeet <= CONSTANTS.DISTANCE_THRESHOLD) {
                showLocationHunt(location);
            }
        }
        
        // Update distance box with location info
        function updateDistanceBox(location, distanceFeet) {
            const distanceBox = document.getElementById('distanceBox');
            if (distanceBox) {
                const locationNameElement = distanceBox.querySelector('.location-name');
                const distanceValueElement = distanceBox.querySelector('.distance-value');
                
                if (locationNameElement && distanceValueElement) {
                    locationNameElement.textContent = location.name;
                    
                    // Format distance based on value
                    let distanceText;
                    if (distanceFeet > 5280) {
                        // Convert to miles and round to 1 decimal place
                        const distanceMiles = (distanceFeet / 5280).toFixed(1);
                        distanceText = `${distanceMiles} miles away`;
                    } else if (distanceFeet === 5280) {
                        distanceText = "1 mile away";
                    } else {
                        distanceText = `${distanceFeet} feet away`;
                    }
                    
                    distanceValueElement.textContent = distanceText;
                }
            }
        }

// Create navigation links for a location
function createNavigationLinks(location) {
    // Google Maps
    const googleMapsLink = document.getElementById('googleMapsLink');
    if (googleMapsLink) {
        googleMapsLink.href = `https://www.google.com/maps/dir/?api=1&destination=${location.lat},${location.lng}&travelmode=walking`;
    }
    
    // Apple Maps (iOS only)
    const appleMapsLink = document.getElementById('appleMapsLink');
    if (appleMapsLink) {
        appleMapsLink.href = `maps://maps.apple.com/?daddr=${location.lat},${location.lng}&dirflg=w`;
        
        // Hide Apple Maps link on non-iOS devices
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
        appleMapsLink.style.display = isIOS ? 'flex' : 'none';
    }
    
    // Waze
    const wazeLink = document.getElementById('wazeLink');
    if (wazeLink) {
        wazeLink.href = `https://waze.com/ul?ll=${location.lat},${location.lng}&navigate=yes`;
    }
}
        
// Set up directions modal links
function setupDirectionsModal(location) {
    state.currentDirectionsLocation = location;
    
    // Google Maps
    const googleMapsBtn = document.getElementById('googleMapsBtn');
    if (googleMapsBtn) {
        googleMapsBtn.href = `https://www.google.com/maps/dir/?api=1&destination=${location.lat},${location.lng}&travelmode=walking`;
    }
    
    // Apple Maps (iOS only)
    const appleMapsBtn = document.getElementById('appleMapsBtn');
    if (appleMapsBtn) {
        appleMapsBtn.href = `maps://maps.apple.com/?daddr=${location.lat},${location.lng}&dirflg=w`;
        
        // Hide Apple Maps button on non-iOS devices
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
        appleMapsBtn.style.display = isIOS ? 'flex' : 'none';
    }
    
    // Waze
    const wazeBtn = document.getElementById('wazeBtn');
    if (wazeBtn) {
        wazeBtn.href = `https://waze.com/ul?ll=${location.lat},${location.lng}&navigate=yes`;
    }
}
        
        // Show directions modal
        function showDirectionsModal(location) {
            setupDirectionsModal(location);
            document.getElementById('directionsModal').style.display = 'flex';
        }
        
        // Close directions modal
        function closeDirectionsModal() {
            document.getElementById('directionsModal').style.display = 'none';
        }
        
        // Skip to next location
        function skipToNextLocation() {
            // Close any open popups
            state.map.closePopup();
            
            // Remove the current marker from the map
            if (state.currentLocationIndex < state.allLocationMarkers.length) {
                state.map.removeLayer(state.allLocationMarkers[state.currentLocationIndex]);
            }
            
            // Move to next location
            state.currentLocationIndex++;
            
            // Check if we've reached the end
            if (state.currentLocationIndex >= state.gameLocations.length) {
                showCongratulations();
            } else {
                // Update visible markers
                updateVisibleMarkers();
                
                // Update distance box for new location
                const location = state.gameLocations[state.currentLocationIndex];
                if (location && state.lastPosition) {
                    const distance = calculateDistance(
                        { lat: state.lastPosition.lat, lng: state.lastPosition.lng },
                        { lat: location.lat, lng: location.lng }
                    );
                    const distanceFeet = Math.round(distance * 3.28084);
                    updateDistanceBox(location, distanceFeet);
                }
                
                // Reset proximity state
                state.isWithinProximity = false;
                state.proximityZoomActive = false;
            }
        }

        // Calculate optimal zoom level based on speed
        function calculateOptimalZoom(speed) {
            // If proximity zoom is active, prioritize it
            if (state.proximityZoomActive) {
                return CONSTANTS.PROXIMITY_ZOOM_LEVEL;
            }
            
            // Default to walking zoom level
            if (speed === undefined || speed === null) {
                return CONSTANTS.DEFAULT_ZOOM_LEVEL;
            }

            // Stationary or very slow
            if (speed < 0.5) {
                return CONSTANTS.MAX_ZOOM_LEVEL;
            }
            // Walking speed
            else if (speed < CONSTANTS.WALKING_SPEED_THRESHOLD) {
                return CONSTANTS.DEFAULT_ZOOM_LEVEL;
            }
            // Running speed
            else if (speed < CONSTANTS.RUNNING_SPEED_THRESHOLD) {
                return CONSTANTS.DEFAULT_ZOOM_LEVEL - 1;
            }
            // Driving speed
            else if (speed < CONSTANTS.DRIVING_SPEED_THRESHOLD) {
                return CONSTANTS.DEFAULT_ZOOM_LEVEL - 2;
            }
            // High speed
            else if (speed < CONSTANTS.HIGH_SPEED_THRESHOLD) {
                return CONSTANTS.DEFAULT_ZOOM_LEVEL - 3;
            }
            // Very high speed
            else {
                return CONSTANTS.MIN_ZOOM_LEVEL;
            }
        }

        // Update zoom level based on speed
        function updateDynamicZoom() {
            const now = Date.now();
            if (now - state.lastZoomUpdateTime < CONSTANTS.ZOOM_UPDATE_INTERVAL) return;
            state.lastZoomUpdateTime = now;

            // Skip if user is interacting with map
            if (state.isMapInteracting || state.userIsInteracting) return;

            // Calculate average speed from samples
            let avgSpeed = 0;
            if (state.speedSamples.length > 0) {
                let sum = 0;
                for (let i = 0; i < state.speedSamples.length; i++) {
                    sum += state.speedSamples[i];
                }
                avgSpeed = sum / state.speedSamples.length;
            } else if (state.lastPosition) {
                avgSpeed = state.lastPosition.speedMPS || 0;
            }

            // Smooth speed changes
            const smoothedSpeed = state.lastSpeedForZoom * 0.7 + avgSpeed * 0.3;
            state.lastSpeedForZoom = smoothedSpeed;

            // Calculate optimal zoom level
            const optimalZoom = calculateOptimalZoom(smoothedSpeed);

            // Only update if zoom level needs to change
            if (Math.abs(optimalZoom - state.targetZoomLevel) >= 0.1) {
                state.targetZoomLevel = optimalZoom;

                // Apply zoom change with smooth animation
                if (state.map && state.followUser) {
                    const currentZoom = state.map.getZoom();
                    const zoomDiff = Math.abs(currentZoom - state.targetZoomLevel);

                    // Use faster transition for larger zoom changes
                    const duration = zoomDiff > 1 ? 0.3 : CONSTANTS.ZOOM_TRANSITION_DURATION;

                    state.map.setZoom(state.targetZoomLevel, {
                        animate: true,
                        duration: duration,
                        noMoveStart: true,
                    });
                }
            }
        }

        // Linear interpolation helper
        function lerp(a, b, t) {
            if (typeof a !== "number" || typeof b !== "number" || typeof t !== "number") {
                return a;
            }

            return a + (b - a) * Math.max(0, Math.min(1, t));
        }

        // Calculate stationary position
        function calculateStationaryPosition(buffer) {
            if (!buffer || buffer.length === 0) {
                return null;
            }
            
            // Sort by accuracy (best first)
            buffer.sort((a, b) => a.accuracy - b.accuracy);
            
            // Take weighted average of best positions
            const topPositions = buffer.slice(0, Math.ceil(buffer.length / 2));
            const weights = new Float64Array(topPositions.length);
            let totalWeight = 0;
            
            for (let i = 0; i < topPositions.length; i++) {
                weights[i] = 1 / Math.max(1, topPositions[i].accuracy);
                totalWeight += weights[i];
            }
            
            if (totalWeight === 0) {
                return buffer[0];
            }
            
            // Calculate weighted average
            let weightedLat = 0;
            let weightedLng = 0;
            
            for (let i = 0; i < topPositions.length; i++) {
                weightedLat += topPositions[i].lat * weights[i];
                weightedLng += topPositions[i].lng * weights[i];
            }
            
            const avgPosition = {
                lat: weightedLat / totalWeight,
                lng: weightedLng / totalWeight,
                accuracy: topPositions[0].accuracy,
                heading: topPositions[0].heading,
                timestamp: Date.now(),
                speedMPS: 0,
            };
            
            // If we have a previous stationary position, blend with it for stability
            if (state.lastStationaryPosition) {
                const blendFactor = 0.85; // 85% previous, 15% new for extreme stability
                return {
                    lat: state.lastStationaryPosition.lat * blendFactor + avgPosition.lat * (1 - blendFactor),
                    lng: state.lastStationaryPosition.lng * blendFactor + avgPosition.lng * (1 - blendFactor),
                    accuracy: avgPosition.accuracy,
                    heading: avgPosition.heading,
                    timestamp: avgPosition.timestamp,
                    speedMPS: 0
                };
            }
            
            return avgPosition;
        }

        // Update stationary position history
        function updateStationaryHistory(position) {
            // Add new position to history
            state.stationaryPositionHistory.push(position);

            // Keep history at maximum size
            while (state.stationaryPositionHistory.length > CONSTANTS.STATIONARY_POSITION_HISTORY_SIZE) {
                state.stationaryPositionHistory.shift();
            }

            // Calculate weighted average of positions
            let totalWeight = 0;
            let weightedLat = 0;
            let weightedLng = 0;

            // Newer positions have higher weight
            for (let i = 0; i < state.stationaryPositionHistory.length; i++) {
                const pos = state.stationaryPositionHistory[i];
                const weight = Math.pow(CONSTANTS.STATIONARY_POSITION_WEIGHT_DECAY, state.stationaryPositionHistory.length - i - 1);
                totalWeight += weight;
                weightedLat += pos.lat * weight;
                weightedLng += pos.lng * weight;
            }

            return {
                lat: weightedLat / totalWeight,
                lng: weightedLng / totalWeight,
                accuracy: position.accuracy,
                heading: position.heading,
                timestamp: position.timestamp,
                speedMPS: 0,
            };
        }

        // Update position buffer with new position
        function updatePositionBuffer(position) {
            if (!position || typeof position.lat !== "number" || typeof position.lng !== "number") {
                return;
            }

            // Add new position to buffer
            state.positionBuffer.push({
                lat: position.lat,
                lng: position.lng,
                accuracy: position.accuracy,
                heading: position.heading,
                timestamp: position.timestamp,
                speedMPS: position.speedMPS,
            });

            // Remove old positions if buffer exceeds maxSize
            while (state.positionBuffer.length > CONSTANTS.MAX_BUFFER_SIZE) {
                state.positionBuffer.shift();
            }
        }

        // Check if user is stationary
        function checkStationaryState(newPosition) {
            if (!state.lastPosition) return;

            const distance = calculateDistance(state.lastPosition, newPosition);

            if (distance >= CONSTANTS.MICRO_MOVEMENT_THRESHOLD) {
                state.isStationary = false;
                state.stationaryStartTime = null;
                console.debug("Movement detected, resuming normal updates");

                // Update Kalman filter stationary mode
                state.kalmanFilter.setStationaryMode(false);

                // Update marker class
                const markerElement = state.userMarker.getElement();
                if (markerElement) {
                    markerElement.classList.remove("user-marker-stationary");
                }
            }

            if (state.stationaryCheckTimeout) {
                clearTimeout(state.stationaryCheckTimeout);
                state.stationaryCheckTimeout = null;
            }

            if (state.isStationary) {
                state.stationaryCheckTimeout = setTimeout(() => checkStationaryState(newPosition), CONSTANTS.STATIONARY_CHECK_INTERVAL);
            }
        }

        // Predict position based on heading and speed
        function predictPositionFromHeading(position, heading, distance) {
            // Input validation
            if (
                !position ||
                typeof heading !== "number" ||
                typeof distance !== "number" ||
                !position.lat ||
                !position.lng ||
                isNaN(heading) ||
                isNaN(distance)
            ) {
                return position;
            }

            // Normalize heading to 0-360 range
            heading = ((heading % 360) + 360) % 360;

            // Earth's radius in meters
            const R = CONSTANTS.EARTH_RADIUS;

            // Convert to radians
            const d = distance / R;
            const  = (heading * Math.PI) / 180;
            const 1 = (position.lat * Math.PI) / 180;
            const 1 = (position.lng * Math.PI) / 180;

            // Calculate predicted position with error handling
            try {
                const sin1 = Math.sin(1);
                const cos1 = Math.cos(1);
                const cosd = Math.cos(d);
                const sind = Math.sin(d);
                const cos = Math.cos();

                const 2 = Math.asin(sin1 * cosd + cos1 * sind * cos);

                const 2 = 1 + Math.atan2(Math.sin() * sind * cos1, cosd - sin1 * Math.sin(2));

                // Convert back to degrees with bounds checking
                const newLat = Math.max(-90, Math.min(90, (2 * 180) / Math.PI));
                const newLng = (((2 * 180) / Math.PI + 540) % 360) - 180;

                return {
                    lat: newLat,
                    lng: newLng,
                };
            } catch (error) {
                // Fallback to original position if calculation fails
                return position;
            }
        }

        // Main function to update user location
        function updateUserLocation(position, forceUpdate = false) {
            // Validate input position
            if (!position?.coords) {
                console.warn("Invalid position data received");
                return;
            }

            const currentTime = Date.now();

            // Throttle updates for performance
            if (!forceUpdate && currentTime - state.lastPositionUpdateTime < 16) {
                return;
            }
            state.lastPositionUpdateTime = currentTime;

            const timeDelta = state.lastUpdateTime ? (currentTime - state.lastUpdateTime) / 1000 : 0;

            // Create position object
            const newPosition = {
                lat: position.coords.latitude,
                lng: position.coords.longitude,
                accuracy: position.coords.accuracy || 20,
                heading: position.coords.heading !== null ? position.coords.heading : state.lastHeadingValue || undefined,
                timestamp: currentTime,
                speedMPS: position.coords.speed !== null ? position.coords.speed : 0,
            };

            if (isNaN(newPosition.lat) || isNaN(newPosition.lng)) {
                console.warn("Invalid coordinates received");
                return;
            }

            // Store raw position for comparison
            state.lastRawPosition = newPosition;

            // Track accuracy trend
            if (state.lastAccuracy !== null) {
                state.accuracyTrend.push(newPosition.accuracy - state.lastAccuracy);
                while (state.accuracyTrend.length > 5) state.accuracyTrend.shift();
            }
            state.lastAccuracy = newPosition.accuracy;

            // First position initialization
            if (!state.lastPosition) {
                state.lastPosition = newPosition;
                state.userMarker.setLatLng([newPosition.lat, newPosition.lng]);
                state.kalmanFilter.reset(newPosition);
                state.lastUpdateTime = currentTime;
                state.stationaryStartTime = currentTime;
                state.positionBuffer = [newPosition];
                state.lastStationaryPosition = newPosition;
                state.lastRenderPosition = newPosition;
                return;
            }

            // Calculate distance from last position
            const distance = calculateDistance(state.lastPosition, newPosition);

            // Handle large position changes or forced updates
            if (distance > CONSTANTS.EXTENDED_DISTANCE_THRESHOLD || forceUpdate) {
                if (state.stationaryCheckTimeout) {
                    clearTimeout(state.stationaryCheckTimeout);
                    state.stationaryCheckTimeout = null;
                }
                state.isStationary = false;
                state.stationaryStartTime = null;
                state.stationaryCount = 0;
                state.stationaryPositionHistory = [];
                state.lastStationaryPosition = null;
                state.consecutiveStationaryUpdates = 0;

                // Immediate visual update - no animation
                state.userMarker.setLatLng([newPosition.lat, newPosition.lng]);
                
                // Only center map if followUser is true and user is not interacting
                if ((state.followUser && !state.isMapInteracting && !state.userIsInteracting) || state.forceCenteringActive) {
                    state.map.setView([newPosition.lat, newPosition.lng], state.map.getZoom(), {
                        animate: true,
                        duration: 0.3
                    });
                }

                // Reset tracking variables
                state.lastPosition = newPosition;
                state.lastRenderPosition = newPosition;
                state.positionBuffer = [newPosition];
                state.kalmanFilter.reset(newPosition);
                state.kalmanFilter.setStationaryMode(false);
                state.lastVelocity = { lat: 0, lng: 0 };

                // Cancel any active interpolation
                if (state.positionInterpolator) {
                    state.positionInterpolator.cancel();
                }

                // Clear any queued position updates
                state.positionUpdateQueue = [];

                state.lastUpdateTime = currentTime;
                state.lastUpdateTimestamp = currentTime;
                checkNearbyLocations();
                return;
            }

            // Skip updates with poor accuracy or unrealistic movement
            if (
                !forceUpdate &&
                (newPosition.accuracy > CONSTANTS.MAX_ACCEPTABLE_ACCURACY || (timeDelta > 0 && distance / timeDelta > 50))
            ) {
                console.debug("Skipping update due to poor accuracy or unrealistic movement");
                return;
            }

            try {
                // Check if device is in motion based on motion sensors
                const motionDetected = state.deviceMotion && isDeviceInMotion();

                // Enhanced stationary detection
                if (distance < CONSTANTS.MICRO_MOVEMENT_THRESHOLD && (!motionDetected || state.deviceStationaryTime > CONSTANTS.STATIONARY_TIME_THRESHOLD)) {
                    state.stationaryCount++;
                    state.consecutiveStationaryUpdates++;

                    if (!state.isStationary && state.stationaryCount >= CONSTANTS.STATIONARY_THRESHOLD) {
                        state.isStationary = true;
                        console.log("User is now stationary");

                        // Set Kalman filter to stationary mode
                        state.kalmanFilter.setStationaryMode(true);

                        // Update marker class
                        const markerElement = state.userMarker.getElement();
                        if (markerElement) {
                            markerElement.classList.add("user-marker-stationary");
                        }

                        // Calculate stable position from buffer
                        const stablePosition = calculateStationaryPosition(state.positionBuffer);
                        if (stablePosition) {
                            // Add to position update queue
                            state.positionUpdateQueue.push(stablePosition);
                            state.lastPosition = stablePosition;
                            state.lastStationaryPosition = stablePosition;
                        }

                        if (state.stationaryCheckTimeout) clearTimeout(state.stationaryCheckTimeout);
                        state.stationaryCheckTimeout = setTimeout(() => checkStationaryState(newPosition), CONSTANTS.STATIONARY_CHECK_INTERVAL);

                        checkNearbyLocations();
                        return;
                    }
                } else {
                    state.stationaryCount = Math.max(0, state.stationaryCount - 1);
                    state.consecutiveStationaryUpdates = 0;
                    if (state.isStationary && state.stationaryCount < CONSTANTS.STATIONARY_THRESHOLD / 2) {
                        state.isStationary = false;
                        state.kalmanFilter.setStationaryMode(false);

                        // Update marker class
                        const markerElement = state.userMarker.getElement();
                        if (markerElement) {
                            markerElement.classList.remove("user-marker-stationary");
                        }

                        console.log("User is moving again");
                    }
                }

                // Apply Kalman filter with motion detection
                const filteredPosition = state.kalmanFilter.update(newPosition, motionDetected);

                // Update position buffer
                updatePositionBuffer(filteredPosition);

                // Apply different smoothing based on movement state
                let finalPosition;

                if (state.isStationary) {
                    // When stationary, use the stable position with minimal updates
                    if (state.lastStationaryPosition) {
                        // Only update if accuracy significantly improves or after several updates
                        if (newPosition.accuracy < state.lastStationaryPosition.accuracy * 0.8 || state.consecutiveStationaryUpdates > 5) {
                            // Update stationary position history
                            updateStationaryHistory(filteredPosition);

                            // Calculate new stable position
                            const stablePosition = calculateStationaryPosition(state.positionBuffer);
                            if (stablePosition) {
                                // Smooth transition to new stable position
                                finalPosition = {
                                    lat: lerp(state.lastStationaryPosition.lat, stablePosition.lat, 0.1),
                                    lng: lerp(state.lastStationaryPosition.lng, stablePosition.lng, 0.1),
                                    accuracy: stablePosition.accuracy,
                                    heading: stablePosition.heading,
                                    timestamp: currentTime,
                                    speedMPS: 0,
                                };

                                // Add to position update queue
                                state.positionUpdateQueue.push(finalPosition);
                                state.lastPosition = finalPosition;
                                state.lastStationaryPosition = finalPosition;
                                state.consecutiveStationaryUpdates = 0;
                            } else {
                                finalPosition = state.lastStationaryPosition;
                            }
                        } else {
                            // Use existing stable position
                            finalPosition = state.lastStationaryPosition;
                        }
                    } else {
                        // If no stable position yet, calculate one
                        const stablePosition = calculateStationaryPosition(state.positionBuffer);
                        if (stablePosition) {
                            finalPosition = stablePosition;
                            state.lastStationaryPosition = stablePosition;

                            // Add to position update queue
                            state.positionUpdateQueue.push(finalPosition);
                        } else {
                            finalPosition = filteredPosition;

                            // Add to position update queue
                            state.positionUpdateQueue.push(finalPosition);
                        }
                        state.lastPosition = finalPosition;
                    }
                } else {
                    // Smooth movement when active
                    finalPosition = filteredPosition;

                    // Apply heading-based prediction for smoother movement
                    if (finalPosition.heading !== undefined && finalPosition.speedMPS > 0.5) {
                        const predictedPosition = predictPositionFromHeading(
                            finalPosition,
                            finalPosition.heading,
                            finalPosition.speedMPS * 0.3, // Predict slightly ahead
                        );

                        // Blend predicted and filtered positions
                        finalPosition = {
                            lat: lerp(finalPosition.lat, predictedPosition.lat, 0.2),
                            lng: lerp(finalPosition.lng, predictedPosition.lng, 0.2),
                            accuracy: finalPosition.accuracy,
                            heading: finalPosition.heading,
                            timestamp: currentTime,
                            speedMPS: finalPosition.speedMPS,
                        };
                    }

                    // Add to position update queue
                    state.positionUpdateQueue.push(finalPosition);
                    state.lastPosition = finalPosition;
                }

                state.lastUpdateTime = currentTime;
                state.lastUpdateTimestamp = currentTime;
                checkNearbyLocations();
            } catch (error) {
                console.error("Location update error:", error);
                // Fallback with basic filtering
                state.userMarker.setLatLng([newPosition.lat, newPosition.lng]);
                state.lastPosition = newPosition;
                state.lastRenderPosition = newPosition;
                checkNearbyLocations();
            }
        }

        // Handle position updates from geolocation API
        function handlePositionUpdate(position) {
            if (!position?.coords?.latitude || !position?.coords?.longitude) {
                console.warn("Invalid position data received");
                return;
            }

            const currentTime = Date.now();
            if (currentTime - state.lastUpdateTime >= 100 && !isPopupOpen()) {
                updateUserLocation(position);
                state.lastUpdateTime = currentTime;
            }
        }

        // Start position updates with high frequency
        function startPositionUpdates() {
            navigator.geolocation.watchPosition(handlePositionUpdate, handleLocationError, {
                enableHighAccuracy: true,
                maximumAge: 0,
                timeout: 10000,
            });
        }

        // Initialize map with enhanced settings
        function initMap() {
            state.map = L.map("map", {
                zoomControl: false,
                attributionControl: false,
                zoomSnap: 0.1,
                zoomDelta: 0.5,
                wheelDebounceTime: 100,
                tapTolerance: 15,
                bounceAtZoomLimits: false,
                preferCanvas: true, // Use canvas renderer for better performance
                renderer: L.canvas({ padding: 0.5 }),
            }).fitWorld();

                        L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
                maxZoom: 18,
                attribution: " OpenStreetMap contributors",
                updateWhenIdle: true,
                updateWhenZooming: false,
                keepBuffer: 2,
            }).addTo(state.map);

            // Create user icon with custom styling for direction indication
            const userIcon = L.divIcon({
                className: "user-marker",
                html: '<div class="user-marker-icon"></div>',
                iconSize: [24, 24],
                iconAnchor: [12, 12],
            });

            state.userMarker = L.marker([0, 0], {
                icon: userIcon,
                zIndexOffset: 1000, // Ensure user marker is on top
                interactive: false, // Prevent marker from being clickable
            }).addTo(state.map);

            // Show preloader
            showPreloader();

            // Request motion and orientation permissions
            requestMotionPermission();

            if ("geolocation" in navigator) {
                const options = {
                    enableHighAccuracy: true,
                    timeout: 45000,
                    maximumAge: 0,
                };

                // Try first time
                navigator.geolocation.getCurrentPosition(
                    initializeUserLocation,
                    (error) => {
                        // On error, try one more time before falling back
                        navigator.geolocation.getCurrentPosition(initializeUserLocation, handleLocationError, options);
                    },
                    options
                );
            } else {
                showPopup("Geolocation is not supported by your browser");
                state.map.setView([44.9778, -93.265], 18);
                hidePreloader();
            }

            document.addEventListener("visibilitychange", handleVisibilityChange);

            // Track user interaction with the map
            state.map.on("movestart zoomstart", () => {
                state.isMapInteracting = true;
                state.userIsInteracting = true;
                state.userInteractionTime = Date.now();
                state.followUser = false; // Disable following when user interacts
            });

            state.map.on("moveend zoomend", () => {
                state.isMapInteracting = false;
                
                // Start inactivity timer to re-enable following after INACTIVITY_TIMEOUT
                resetInactivityTimer();
            });

            // Add this after the map.on("moveend zoomend"...) event handler:
            state.map.on("click", function() {
                // Close any open popups when the map is clicked
                state.map.closePopup();
            });

            // Start animation loop for smooth rendering
            startAnimationLoop();

            // Load tour locations
            loadLocations();
        }

// Load tour locations
function loadLocations() {
    state.gameLocations = locations;
    
    // Create markers for all locations
    state.gameLocations.forEach((location, index) => {
        // Create numbered marker icon
        const locationIcon = L.divIcon({
            className: 'location-marker',
            html: `<div class="location-marker-icon">${index + 1}</div>`,
            iconSize: [40, 40],
            iconAnchor: [20, 20]
        });
        
        const marker = L.marker([location.lat, location.lng], {
            icon: locationIcon
        });
        
        // Add popup with location info
        const popupContent = `
            <div class="marker-popup">
                <img src="${location.image || '/placeholder.svg?height=150&width=280'}" class="marker-popup-image" alt="${location.name}">
                <div class="marker-popup-content">
                    <div class="marker-popup-title">${location.name}</div>
                    <div class="marker-popup-description">${location.description.substring(0, 100)}...</div>
                    <div class="marker-popup-actions">
                        <button class="popup-btn directions" data-location-index="${index}">
                            <i class="fas fa-directions"></i> Directions
                        </button>
                        <button class="popup-btn skip">
                            <i class="fas fa-forward"></i> Skip
                        </button>
                    </div>
                </div>
            </div>
        `;
        
        const popup = L.popup({
            closeButton: true,
            autoClose: true,
            closeOnEscapeKey: true,
            closeOnClick: true,
            className: 'custom-popup',
            maxWidth: 300
        }).setContent(popupContent);
        
        marker.bindPopup(popup);
        
        // Add events after popup opens
        marker.on('popupopen', function() {
            // Find the directions button in this specific popup
            const directionsBtn = document.querySelector('.popup-btn.directions[data-location-index="' + index + '"]');
            if (directionsBtn) {
                directionsBtn.addEventListener('click', function() {
                    showDirectionsModal(state.gameLocations[index]);
                });
            }
            
            // Find the skip button in this specific popup
            const skipBtn = document.querySelector('.popup-btn.skip');
            if (skipBtn) {
                skipBtn.addEventListener('click', function() {
                    skipToNextLocation();
                });
            }
        });
        
        // Add click event to marker
        marker.on('click', () => {
            marker.openPopup();
        });
        
        state.allLocationMarkers.push(marker);
    });
    
    // Only show the first marker initially
    updateVisibleMarkers();
}
        
        // Update visible markers based on current progress
        function updateVisibleMarkers() {
            // Remove all existing markers from map
            state.activeMarkers.forEach(marker => {
                state.map.removeLayer(marker);
            });
            state.activeMarkers = [];
            
            // Show only the current marker
            if (state.currentLocationIndex < state.allLocationMarkers.length) {
                state.allLocationMarkers[state.currentLocationIndex].addTo(state.map);
                state.activeMarkers.push(state.allLocationMarkers[state.currentLocationIndex]);
            }
        }

        // Initialize user location
        function initializeUserLocation(position) {
            if (!position?.coords) {
                handleLocationError({ code: 2, message: "Invalid position data" });
                return;
            }

            try {
                const initialPosition = {
                    lat: position.coords.latitude,
                    lng: position.coords.longitude,
                    accuracy: position.coords.accuracy || 20,
                    heading: position.coords.heading,
                    timestamp: Date.now(),
                    speedMPS: position.coords.speed || 0,
                };

                // Set initial marker position
                state.userMarker.setLatLng([initialPosition.lat, initialPosition.lng]);

                // Initialize Kalman filter
                state.kalmanFilter.reset(initialPosition);

                // Set map view
                state.map.setView([initialPosition.lat, initialPosition.lng], CONSTANTS.DEFAULT_ZOOM_LEVEL);

                // Initialize tracking variables
                state.lastPosition = initialPosition;
                state.lastRenderPosition = initialPosition;
                state.lastUpdateTime = Date.now();
                state.lastUpdateTimestamp = Date.now();

                // Start position updates
                startPositionUpdates();

                // Hide preloader
                hidePreloader();

                // Update distance box
                checkNearbyLocations();

                // Show stabilizing modal
                showStabilizingModal();

                console.log("Location initialized successfully");
            } catch (error) {
                console.error("Error initializing location:", error);
                handleLocationError({ code: 2, message: "Error initializing location" });
            }
        }

        // Show stabilizing modal
        function showStabilizingModal() {
            const modal = document.createElement('div');
            modal.className = 'stabilizing-modal';
            modal.innerHTML = `
                <div class="spinner"></div>
                <h3>Stabilizing Your Location</h3>
                <p>Please wait while we fine-tune your position.</p>
            `;
            document.body.appendChild(modal);
            
            // Auto-dismiss after 5 seconds
            setTimeout(() => {
                modal.style.opacity = '0';
                modal.style.transition = 'opacity 0.5s ease';
                setTimeout(() => {
                    if (modal.parentNode) {
                        modal.parentNode.removeChild(modal);
                    }
                    state.isStabilizing = false;
                }, 500);
            }, 5000);
        }

        // Show location hunt
        function showLocationHunt(location) {
            state.isLocationHuntVisible = true;
            
            // Set location information
            document.getElementById('locationTitle').textContent = location.name;
            document.getElementById('locationCity').textContent = location.city;
            document.getElementById('locationCreator').textContent = `Created by: ${location.creator}`;
            document.getElementById('locationImage').src = location.image || '/placeholder.svg?height=200&width=400';
            document.getElementById('locationAudio').src = location.audio;
            document.getElementById('locationDescription').textContent = location.description;
            
            // Create navigation links
            createNavigationLinks(location);
            
            // Show location hunt container
            const lochuntContainer = document.querySelector('.lochunt-container');
            lochuntContainer.classList.add('active');
            
            // Initialize audio player
            initAudioPlayer();
            
            // Add to visited locations if not already visited
            if (!state.visitedLocations.includes(location.id)) {
                state.visitedLocations.push(location.id);
            }
        }

        // Initialize audio player
        function initAudioPlayer() {
            const audio = document.getElementById('locationAudio');
            const playPauseBtn = document.getElementById('playPauseBtn');
            const rewindBtn = document.getElementById('rewindBtn');
            const forwardBtn = document.getElementById('forwardBtn');
            const progressBar = document.getElementById('progressBar');
            const currentTimeSpan = document.getElementById('currentTime');
            const durationSpan = document.getElementById('duration');
            
            // Set up event listeners
            playPauseBtn.addEventListener('click', togglePlay);
            rewindBtn.addEventListener('click', () => seek(-10));
            forwardBtn.addEventListener('click', () => seek(10));
            audio.addEventListener('timeupdate', updateProgress);
            audio.addEventListener('loadedmetadata', setDuration);
            audio.addEventListener('ended', showTrivia);
            
            // Play/pause function
            function togglePlay() {
                if (audio.paused) {
                    audio.play().catch(e => console.error("Audio play error:", e));
                    playPauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
                } else {
                    audio.pause();
                    playPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
                }
            }
            
            // Seek function
            function seek(seconds) {
                audio.currentTime = Math.max(0, Math.min(audio.currentTime + seconds, audio.duration));
            }
            
            // Update progress bar
            function updateProgress() {
                const percent = (audio.currentTime / audio.duration) * 100;
                progressBar.style.width = `${percent}%`;
                currentTimeSpan.textContent = formatTime(audio.currentTime);
            }
            
            // Set duration
            function setDuration() {
                durationSpan.textContent = formatTime(audio.duration);
            }
            
            // Format time (convert seconds to MM:SS format)
            function formatTime(time) {
                const minutes = Math.floor(time / 60);
                const seconds = Math.floor(time % 60);
                return `${minutes}:${seconds.toString().padStart(2, '0')}`;
            }
        }

        // Show trivia question
        function showTrivia() {
            // Hide location hunt container
            document.querySelector('.lochunt-container').classList.remove('active');
            
            // Get current location
            const currentLocation = state.gameLocations[state.currentLocationIndex];
            
            // Set trivia question
            document.getElementById('triviaQuestion').textContent = currentLocation.trivia.question;
            
            // Create trivia options
            const triviaOptions = document.getElementById('triviaOptions');
            triviaOptions.innerHTML = '';
            
            // Create document fragment for better performance
            const fragment = document.createDocumentFragment();
            
            currentLocation.trivia.options.forEach((option, index) => {
                const button = document.createElement('button');
                button.className = 'trivia-option';
                button.textContent = option;
                button.dataset.index = index;
                button.addEventListener('click', checkAnswer);
                fragment.appendChild(button);
            });
            
            // Append all buttons at once
            triviaOptions.appendChild(fragment);
            
            // Show trivia container
            document.querySelector('.trivia-container').classList.add('active');
        }

        // Check trivia answer
        function checkAnswer(event) {
            const selectedIndex = parseInt(event.target.dataset.index);
            const currentLocation = state.gameLocations[state.currentLocationIndex];
            
            // Disable all buttons
            const buttons = document.querySelectorAll('.trivia-option');
            buttons.forEach(button => {
                button.disabled = true;
            });
            
            // Mark correct and incorrect answers
            buttons.forEach(button => {
                const index = parseInt(button.dataset.index);
                if (index === currentLocation.trivia.answer) {
                    button.classList.add('correct');
                } else if (index === selectedIndex) {
                    button.classList.add('incorrect');
                }
            });
            
            // Wait 2 seconds before proceeding
            setTimeout(() => {
                // Hide trivia container
                document.querySelector('.trivia-container').classList.remove('active');
                
                // Remove the current marker from the map
                if (state.currentLocationIndex < state.allLocationMarkers.length) {
                    state.map.removeLayer(state.allLocationMarkers[state.currentLocationIndex]);
                }
                
                // Move to next location or show congratulations
                state.currentLocationIndex++;
                state.isLocationHuntVisible = false;
                
                if (state.currentLocationIndex >= state.gameLocations.length) {
                    showCongratulations();
                } else {
                    // Update visible markers for the next location
                    updateVisibleMarkers();
                    
                    // Update distance box for new location
                    if (state.lastPosition) {
                        const location = state.gameLocations[state.currentLocationIndex];
                        const distance = calculateDistance(
                            { lat: state.lastPosition.lat, lng: state.lastPosition.lng },
                            { lat: location.lat, lng: location.lng }
                        );
                        const distanceFeet = Math.round(distance * 3.28084);
                        updateDistanceBox(location, distanceFeet);
                    }
                    
                    // Reset proximity state
                    state.isWithinProximity = false;
                    state.proximityZoomActive = false;
                }
            }, 2000);
        }

        // Show congratulations screen
        function showCongratulations() {
            document.getElementById('congratulations').style.display = 'flex';
        }

        // End tour function - consolidated into a single function
        function endTour() {
            // Show confirmation popup
            showPopup("Are you sure you want to end the tour and return to the home page?");
            
            // Replace the default OK button with Yes/No buttons
            const popupContent = document.querySelector('.popup-content');
            const okButton = popupContent.querySelector('.popup-button');
            
            if (okButton) {
                // Remove the default OK button
                okButton.remove();
                
                // Create button container
                const buttonContainer = document.createElement('div');
                buttonContainer.style.display = 'flex';
                buttonContainer.style.gap = '10px';
                buttonContainer.style.marginTop = '20px';
                
                // Create Yes button
                const yesButton = document.createElement('button');
                yesButton.className = 'popup-button';
                yesButton.textContent = 'Yes';
                yesButton.style.flex = '1';
                yesButton.style.backgroundColor = 'var(--secondary-color)';
                yesButton.addEventListener('click', () => {
                    // Navigate to home page
                    window.location.href = 'index.html';
                });
                
                // Create No button
                const noButton = document.createElement('button');
                noButton.className = 'popup-button';
                noButton.textContent = 'No';
                noButton.style.flex = '1';
                noButton.style.backgroundColor = 'var(--bg-dark)';
                noButton.style.color = 'var(--text-color)';
                noButton.addEventListener('click', closePopup);
                
                // Add buttons to container
                buttonContainer.appendChild(yesButton);
                buttonContainer.appendChild(noButton);
                
                // Add container to popup
                popupContent.appendChild(buttonContainer);
            }
        }
    
        // Show enhanced preloader with guaranteed 10-second fill time
        function showPreloader() {
            const preloader = document.getElementById('preloader');
            if (!preloader) {
                console.error('Preloader element not found');
                return;
            }
            
            // Make sure the preloader is visible and fully opaque
            preloader.style.display = 'flex';
            preloader.style.opacity = '1';
            
            // Set up elements
            const progressBar = document.getElementById('preloaderProgress');
            const loadingStatus = document.getElementById('loadingStatus');
            const loadingPercentage = document.getElementById('loadingPercentage');
            
            // Reset progress bar and text
            if (progressBar) progressBar.style.width = '0%';
            if (loadingPercentage) loadingPercentage.textContent = '0%';
            if (loadingStatus) loadingStatus.textContent = "Initializing map...";
            
            const statusMessages = [
                "Initializing map...",
                "Loading tour locations...",
                "Preparing navigation...",
                "Getting your location...",
                "Almost ready..."
            ];
            
            // Set animation parameters
            const DURATION = 10000; // Exactly 10 seconds
            
            // Cancel any existing animation
            if (window.preloaderAnimationId) {
                cancelAnimationFrame(window.preloaderAnimationId);
                window.preloaderAnimationId = null;
            }
            
            // Cancel any existing timeouts
            if (window.preloaderHideTimeout) {
                clearTimeout(window.preloaderHideTimeout);
                window.preloaderHideTimeout = null;
            }
            
            // Set a flag to prevent premature hiding
            window.preloaderActive = true;
            
            // Record start time
            const startTime = performance.now();
            
            // Animation function using requestAnimationFrame for smoother progress
            function animateProgress(currentTime) {
                // Calculate how much time has passed (capped at DURATION)
                const elapsedTime = Math.min(currentTime - startTime, DURATION);
                
                // Calculate progress percentage (0-100)
                const progressPercent = (elapsedTime / DURATION) * 100;
                
                // Update progress bar
                if (progressBar) {
                    progressBar.style.width = `${progressPercent}%`;
                }
                
                // Update percentage text
                if (loadingPercentage) {
                    loadingPercentage.textContent = `${Math.round(progressPercent)}%`;
                }
                
                // Update status message based on progress
                if (loadingStatus) {
                    const messageIndex = Math.min(
                        Math.floor(progressPercent / 20), // 5 messages, 20% each
                        statusMessages.length - 1
                    );
                    loadingStatus.textContent = statusMessages[messageIndex];
                }
                
                // Continue animation if we haven't reached the end
                if (elapsedTime < DURATION) {
                    window.preloaderAnimationId = requestAnimationFrame(animateProgress);
                } else {
                    // We've reached exactly 10 seconds
                    if (loadingStatus) loadingStatus.textContent = "Loading complete!";
                    if (loadingPercentage) loadingPercentage.textContent = "100%";
                    
                    // Set a timeout to hide the preloader after a short delay
                    window.preloaderHideTimeout = setTimeout(() => {
                        // Only hide if preloaderActive is still true
                        if (window.preloaderActive) {
                            preloader.style.opacity = '0';
                            preloader.style.transition = 'opacity 0.5s ease';
                            
                            setTimeout(() => {
                                preloader.style.display = 'none';
                                window.preloaderActive = false;
                            }, 500);
                        }
                    }, 300);
                }
            }
            
            // Start the animation
            window.preloaderAnimationId = requestAnimationFrame(animateProgress);
            
            // Set a guaranteed timeout to ensure we complete in exactly 10 seconds
            setTimeout(() => {
                // If animation is still running, cancel it
                if (window.preloaderAnimationId) {
                    cancelAnimationFrame(window.preloaderAnimationId);
                    window.preloaderAnimationId = null;
                }
                
                // Force progress to 100%
                if (progressBar) progressBar.style.width = '100%';
                if (loadingPercentage) loadingPercentage.textContent = '100%';
                if (loadingStatus) loadingStatus.textContent = "Loading complete!";
                
                // Set timeout to hide preloader
                if (!window.preloaderHideTimeout) {
                    window.preloaderHideTimeout = setTimeout(() => {
                        if (window.preloaderActive) {
                            preloader.style.opacity = '0';
                            preloader.style.transition = 'opacity 0.5s ease';
                            
                            setTimeout(() => {
                                preloader.style.display = 'none';
                                window.preloaderActive = false;
                            }, 500);
                        }
                    }, 300);
                }
            }, DURATION);
        }

        // Modified hidePreloader function that respects the 10-second minimum duration
        function hidePreloader() {
            // Only hide if the preloader has been active for at least 10 seconds
            // or if it's not currently active
            if (!window.preloaderActive) {
                const preloader = document.getElementById('preloader');
                if (preloader) {
                    preloader.style.opacity = '0';
                    preloader.style.transition = 'opacity 0.5s ease';
                    setTimeout(() => {
                        preloader.style.display = 'none';
                    }, 500);
                }
            }
            // Otherwise, do nothing - let the preloader complete its 10-second cycle
        }

        // Show popup
        function showPopup(message) {
            const popup = document.getElementById('popup');
            const popupMessage = document.getElementById('popupMessage');
            
            if (popup && popupMessage) {
                popupMessage.textContent = message;
                popup.style.display = 'flex';
            } else {
                alert(message);
            }
        }

        // Close popup
        function closePopup() {
            const popup = document.getElementById('popup');
            if (popup) {
                popup.style.display = 'none';
            }
        }

        // Check if popup is open
        function isPopupOpen() {
            const popup = document.getElementById('popup');
            return popup ? popup.style.display === 'flex' : false;
        }

        // Handle location errors
        function handleLocationError(error) {
            console.error("Geolocation error:", error);
            hidePreloader();
            
            let message = "Unable to access your location. ";
            
            switch(error.code) {
                case 1:
                    message += "Please enable location services for this website.";
                    break;
                case 2:
                    message += "Location information is unavailable.";
                    break;
                case 3:
                    message += "The request to get your location timed out.";
                    break;
                default:
                    message += "An unknown error occurred.";
            }
            
            showPopup(message);
        }

        // Handle visibility change
        function handleVisibilityChange() {
            if (document.hidden) {
                state.lastHiddenTime = Date.now();
                
                // Pause any active animations when app goes to background
                if (state.animationFrameId) {
                    cancelAnimationFrame(state.animationFrameId);
                    state.animationFrameId = null;
                }
            } else {
                const hiddenDuration = Date.now() - state.lastHiddenTime;
                
                // Restart animation loop
                if (!state.animationFrameId) {
                    startAnimationLoop();
                }
                
                if (hiddenDuration > CONSTANTS.BACKGROUND_THRESHOLD) {
                    // App was in background for significant time, reset tracking
                    if (state.userMarker && state.lastPosition) {
                        // Force position update
                        updateUserLocation({
                            coords: {
                                latitude: state.lastPosition.lat,
                                longitude: state.lastPosition.lng,
                                accuracy: state.lastPosition.accuracy,
                                heading: state.lastPosition.heading,
                                speed: state.lastPosition.speedMPS
                            }
                        }, true);
                        
                        // Force recentering
                        state.forceCenteringActive = true;
                        setTimeout(() => {
                            state.forceCenteringActive = false;
                        }, 2000);
                    }
                }
            }
        }

        // Reset inactivity timer - key function for the 29-second recenter requirement
        function resetInactivityTimer() {
            if (state.inactivityTimer) {
                clearTimeout(state.inactivityTimer);
            }
            
            state.inactivityTimer = setTimeout(() => {
                if (!state.isMapInteracting) {
                    // Close any open popups first with animation
                    const openPopups = document.querySelectorAll('.leaflet-popup');
                    if (openPopups.length > 0) {
                        openPopups.forEach(popup => {
                            popup.classList.add('leaflet-popup-closing');
                        });
                        
                        // Delay the actual closing to allow animation to complete
                        setTimeout(() => {
                            state.map.closePopup();
                        }, 150);
                    }
                    
                    // Re-enable following after inactivity timeout
                    state.followUser = true;
                    
                    // Smooth transition back to user's position
                    if (state.userMarker && state.userMarker.getLatLng()) {
                        state.smoothTransitionActive = true;
                        
                        // Get current map center and user position
                        const currentCenter = state.map.getCenter();
                        const userPos = state.userMarker.getLatLng();
                        
                        // Calculate distance between current center and user position
                        const distance = calculateDistance(
                            { lat: currentCenter.lat, lng: currentCenter.lng },
                            { lat: userPos.lat, lng: userPos.lng }
                        );
                        
                        // Adjust duration based on distance (longer for greater distances)
                        const duration = Math.min(1.5, Math.max(0.8, distance / 500));
                        
                        // Smooth transition to user position
                        state.map.flyTo([userPos.lat, userPos.lng], state.targetZoomLevel, {
                            duration: duration,
                            easeLinearity: 0.25,
                            noMoveStart: true
                        });
                        
                        // Reset smooth transition flag after animation completes
                        setTimeout(() => {
                            state.smoothTransitionActive = false;
                        }, duration * 1000 + 100);
                    }
                }
            }, CONSTANTS.INACTIVITY_TIMEOUT); // 29 seconds as requested
        }

        // Recenter map
        function recenterMap() {
            const recenterButton = document.getElementById('recenterButton');
            if (recenterButton) {
                recenterButton.style.backgroundColor = "var(--primary-color)";
                recenterButton.style.color = "white";
            }
            
            if (state.userMarker && state.userMarker.getLatLng()) {
                // Use flyTo for smoother animation
                state.map.flyTo(state.userMarker.getLatLng(), state.targetZoomLevel, {
                    duration: 0.8,
                    easeLinearity: 0.25
                });
                
                state.followUser = true;
                
                // Force centering for a short period
                state.forceCenteringActive = true;
                setTimeout(() => {
                    state.forceCenteringActive = false;
                }, 2000);
            }
            
            setTimeout(() => {
                if (recenterButton) {
                    recenterButton.style.backgroundColor = "var(--bg-color)";
                    recenterButton.style.color = "var(--primary-color)";
                }
            }, 500);
        }

        // Toggle navigation tips
        function toggleNavigationTips() {
            const tipsElement = document.querySelector('.navigation-tips');
            tipsElement.style.display = tipsElement.style.display === 'none' || tipsElement.style.display === '' ? 'block' : 'none';
        }

        // Close navigation tips
        function closeNavigationTips() {
            document.querySelector('.navigation-tips').style.display = 'none';
        }

        // Setup touch to close popup
        function setupTouchToClosePopup() {
            // Track if we're in the process of closing a popup
            let closePopupTimeout = null;
            
            // Add click event listener to the map
            state.map.on('click', function(e) {
                // Check if the click was on the map (not on a popup or marker)
                if (!e.originalEvent._stopped) {
                    // Get all open popups
                    const openPopups = document.querySelectorAll('.leaflet-popup');
                    
                    // If there are open popups, add the closing animation class
                    if (openPopups.length > 0) {
                        openPopups.forEach(popup => {
                            popup.classList.add('leaflet-popup-closing');
                        });
                        
                        // Clear any existing timeout
                        if (closePopupTimeout) {
                            clearTimeout(closePopupTimeout);
                        }
                        
                        // Set a small delay before actually closing the popup
                        closePopupTimeout = setTimeout(() => {
                            state.map.closePopup();
                            closePopupTimeout = null;
                        }, 150); // 150ms delay for a smooth animation
                    }
                }
            });
            
            // Prevent the event from propagating from popups to the map
            document.addEventListener('click', function(e) {
                const popupContent = document.querySelector('.leaflet-popup-content-wrapper');
                if (popupContent && popupContent.contains(e.target)) {
                    e.stopPropagation();
                }
            }, true);
        }

        // Make functions available globally for event handlers
        window.showDirectionsModal = showDirectionsModal;
        window.closeDirectionsModal = closeDirectionsModal;
        window.skipToNextLocation = skipToNextLocation;
        window.closePopup = closePopup;
        window.endTour = endTour;

        // Add event listeners when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize map
            initMap();
            
            // Add event listeners for UI elements
            document.getElementById('recenterButton').addEventListener('click', recenterMap);
            document.getElementById('endTourButton').addEventListener('click', endTour);
            document.getElementById('tipsButton').addEventListener('click', toggleNavigationTips);
            document.querySelector('.navigation-tips .close-button').addEventListener('click', closeNavigationTips);
            
            // Initialize inactivity timer
            resetInactivityTimer();

            // Setup touch to close popup
            setupTouchToClosePopup();
        });
    })();
    </script>
</body>
</html>
