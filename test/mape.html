<!doctype html>
<html lang="en">
<head> 
    <!-- Primary Meta Tags -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, minimum-scale=1.0, user-scalable=yes">
    <title>Minnesota Then | Museum Without Walls</title>
    <meta name="description"
      content="Explore Minnesota history on interactive maps‚ÄîGPS-guided, offline-ready tours with historic photos, audio, and spatial analysis.">
    <meta name="keywords"
      content="Minnesota history tours, interactive map, location-based museum, offline GIS, historical audio tours, mobile history app">
    
    <!-- Favicon -->
   <link rel="shortcut icon" type="image/x-icon"
      href="https://www.mnthen.com/images/mnthenfav.ico">
    
    <!-- Enhanced PWA Manifest -->
    <link rel="manifest" href="/manifest.json">
    <meta name="theme-color" content="#2c5282">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Minnesota Then">

    <!-- Enterprise Security Headers -->
    <meta http-equiv="X-Content-Type-Options" content="nosniff">
    <meta http-equiv="X-XSS-Protection" content="1; mode=block">
    <meta http-equiv="Referrer-Policy" content="strict-origin-when-cross-origin">
    <meta http-equiv="Permissions-Policy" content="geolocation=(self), camera=(), microphone=(), payment=(), usb=()">
    <meta http-equiv="Cross-Origin-Embedder-Policy" content="unsafe-none">
    <meta http-equiv="Cross-Origin-Opener-Policy" content="same-origin">
    
    <meta name="referrer" content="strict-origin-when-cross-origin">
    <meta name="color-scheme" content="light">
    
    <!-- Open Graph / Facebook Meta Tags -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://www.mnthen.com/">
    <meta property="og:title" content="Minnesota Then | Museum Without Walls">
    <meta property="og:description" content="Enterprise-grade historical GIS platform with advanced spatial analysis and offline capabilities.">
    <meta property="og:image" content="https://mnthen.com/images/index/index_1.jpg">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    
    <!-- Twitter Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@MinnesotaThen">
    <meta name="twitter:title" content="Minnesota Then | Museum Without Walls">
    <meta name="twitter:description" content="Enterprise-grade historical GIS platform with advanced spatial analysis capabilities.">
    <meta name="twitter:image" content="https://mnthen.com/images/index/index_1.jpg">
    
    <!-- Canonical URL -->
    <link rel="canonical" href="https://www.mnthen.com/">

    <!-- Resource hints for faster connections -->
    <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
    <link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
    <link rel="preconnect" href="https://unpkg.com" crossorigin>
    <link rel="preconnect" href="https://www.mnthen.com" crossorigin>

    <!-- DNS Prefetch for additional domains -->
    <link rel="dns-prefetch" href="//tile.openstreetmap.org">
    <link rel="dns-prefetch" href="//a.tile.openstreetmap.org">
    <link rel="dns-prefetch" href="//b.tile.openstreetmap.org">
    <link rel="dns-prefetch" href="//c.tile.openstreetmap.org">
    <link rel="dns-prefetch" href="//fonts.googleapis.com">
    <link rel="dns-prefetch" href="//fonts.gstatic.com">

    <!-- Critical CSS - Load synchronously to prevent FOUC -->
    <link rel="stylesheet" href="https://www.mnthen.com/css/mainmap.css">
    <link rel="stylesheet" href="https://www.mnthen.com/css/mnthen_main_map2.css">

    <!-- Framework CSS - Load synchronously -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" crossorigin>

    <!-- Icon fonts - Load synchronously -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css" crossorigin>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.css" crossorigin>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" crossorigin>
    
    <!-- Standard CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css">
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css">
    
    <!-- Structured Data -->
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "WebApplication",
  "name": "Minnesota Then",
  "alternateName": "Minnesota Then Enterprise GIS",
  "url": "https://www.mnthen.com",
  "description": "Enterprise-grade historical GIS platform for Minnesota with advanced spatial analysis and offline capabilities.",
  "applicationCategory": ["ProductivityApplication", "EducationApplication"],
  "operatingSystem": "Web",
  "browserRequirements": "Requires JavaScript. Compatible with modern browsers.",
  "softwareVersion": "2.0",
  "datePublished": "2024-01-01",
  "dateModified": "2025-07-05",
  "inLanguage": "en-US",
  "isAccessibleForFree": true,
  "offers": {
    "@type": "Offer",
    "price": "0",
    "priceCurrency": "USD",
    "availability": "https://schema.org/InStock"
  },
  "creator": {
    "@type": "Organization",
    "name": "Minnesota Then",
    "url": "https://www.mnthen.com"
  },
  "featureList": [
    "Interactive historical maps",
    "Location-based tours",
    "Offline map capabilities",
    "Spatial analysis tools",
    "Historical content exploration"
  ],
  "screenshot": "https://www.mnthen.com/images/social-share.jpg",
  "aggregateRating": {
    "@type": "AggregateRating",
    "ratingValue": "4.8",
    "ratingCount": "150"
  }
}
</script>

<!-- Geolocation Schema -->
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "TouristDestination",
  "name": "Minnesota Historical Sites",
  "description": "Explore historical locations across Minnesota with enterprise GIS capabilities",
  "geo": {
    "@type": "GeoCoordinates",
    "latitude": "46.7296",
    "longitude": "-94.6859"
  },
  "containedInPlace": {
    "@type": "State",
    "name": "Minnesota",
    "addressCountry": "US"
  },
  "touristType": [
    "History enthusiasts",
    "Educational groups",
    "Cultural tourists"
  ],
  "availableLanguage": "en-US"
}
</script>

<!-- Organization Schema -->
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "Organization",
  "name": "Minnesota Then",
  "url": "https://www.mnthen.com",
  "logo": "https://www.mnthen.com/images/mnthenfav.ico",
  "sameAs": [
    "https://twitter.com/MinnesotaThen"
  ],
  "foundingDate": "2024",
  "description": "Digital platform preserving and sharing Minnesota's historical heritage through interactive mapping technology.",
  "knowsAbout": [
    "Minnesota History",
    "Historical GIS",
    "Digital Heritage",
    "Interactive Maps"
  ]
}
</script>

<style>
/* ==========================================================================
   0. FOUC-PROOF RENDER LOCK (ENHANCED)
   ========================================================================== */
html {
  visibility: hidden !important;
  background-color: #f8f9fa !important;
  overflow: hidden !important;
}

/* Loading spinner that appears immediately */
html::before {
  content: "";
  position: fixed;
  top: 50%;
  left: 50%;
  width: 40px;
  height: 40px;
  margin: -20px 0 0 -20px;
  border: 3px solid #e1e5e9;
  border-top: 3px solid #0066cc;
  border-radius: 50%;
  animation: fouc-spin 1s linear infinite;
  z-index: 999999;
  pointer-events: none;
}

@keyframes fouc-spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

html.unlock {
  visibility: visible !important;
  overflow: visible !important;
}

html.unlock::before {
  display: none !important;
}

/* Prevent flash during unlock transition */
html.unlock * {
  animation-delay: 0s !important;
}

/* ==========================================================================
   1. DESIGN TOKENS
   ========================================================================== */
:root {
  --primary-color:       #0066cc;
  --hover-color:         #e6f0ff;
  --dark-blue:           #1a3a8a;
  --dark-blue-hover:     #0d2c6e;
  --success-color:       #28a745;
  --warning-color:       #ffc107;
  --error-color:         #dc3545;
}

/* ==========================================================================
   2. RESET & GLOBAL HELPERS
   ========================================================================== */
*,
*::before,
*::after { box-sizing: border-box; }

body {
  margin: 0;
  padding: 0;
  font-family: Inter, system-ui, Avenir, Helvetica, Arial, sans-serif;
  background-color: #f8f9fa;
}

/* ==========================================================================
   3. MAP CANVAS
   ========================================================================== */
#map {
  position: fixed;
  top: 0;
  left: 0;
  z-index: 1;
  width: 100vw;
  height: 100vh;       /* fallback */
  height: 100dvh;      /* modern dynamic viewport */
  touch-action: none;
  -webkit-user-select: none;
  user-select: none;
  will-change: transform;
}

/* iOS 100vh fix */
@supports (-webkit-touch-callout: none) {
  #map,
  .lochunt-container {
    height: -webkit-fill-available;
  }
}

/* dvh fallback */
@supports not (height: 100dvh) {
  #map { height: 100vh; }
}

/* ==========================================================================
   4. COMPONENTS
   ========================================================================== */

/* 4.1 Distance indicator */
#distanceBox {
  position: fixed;
  top: 20px;
  right: 20px;
  z-index: 1003;
  background: white;
  padding: 12px 24px;
  border-radius: 50px;
  font-weight: 600;
  font-size: 20px;
  text-align: center;
  min-width: 200px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
  border: 3px solid var(--dark-blue);
  transition: all 0.3s ease;
  opacity: 0;           /* hidden until hydrated */
  visibility: hidden;
}

#distanceBox.show {
  opacity: 1;
  visibility: visible;
}

#distanceBox.proximity-close {
  background: linear-gradient(135deg, #28a745, #20c997);
  color: white;
  animation: pulse 1.5s infinite;
}

#distanceBox.proximity-medium {
  background: linear-gradient(135deg, #ffc107, #fd7e14);
  color: white;
}

#distanceBox.proximity-far {
  background: white;
  color: var(--dark-blue);
  border-color: var(--dark-blue);
}

/* 4.2 Map action buttons */
.map-buttons {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  display: flex;
  justify-content: space-evenly;
  align-items: center;
  gap: 0.5rem;
  margin-bottom: 30px;
}

/* 4.3 Markers */
.user-marker-icon {
  width: 22px;
  height: 22px;
  background: radial-gradient(circle, #dc3545 0%, #a71e2a 70%);
  border: 3px solid white;
  border-radius: 50%;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
  transition: all 0.3s ease;
}

.user-marker-icon.moving {
  animation: pulse 2s infinite;
}

.marker-cluster-custom {
  background: rgba(44, 82, 130, 0.9);
  border-radius: 50%;
  color: white;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 600;
}

.marker-cluster-custom div {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
}

#accuracyIndicator {
    position: absolute;
    top: 10px;
    left: 10px;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    border: 2px solid rgba(255, 255, 255, 0.8);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    z-index: 1000;
    transition: background-color 0.3s ease;
}

/* hide the accuracy indicator on narrow screens */
@media (max-width: 360px) {
  #accuracyIndicator {
    display: none;
  }
}
    
/* ==========================================================================
   5. ANIMATIONS
   ========================================================================== */
@keyframes pulse {
  0%, 100% { opacity: 0.8; }
  50% { opacity: 1; }
}

@keyframes gradientShift {
  0% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes fadeOut {
  from { opacity: 1; }
  to { opacity: 0; }
}

.fade-in { animation: fadeIn 0.3s ease forwards; }
.fade-out { animation: fadeOut 0.3s ease forwards; }

/* ==========================================================================
   6. UTILITIES
   ========================================================================== */
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border: 0;
}

/* ==========================================================================
   7. RESPONSIVE LOADING MESSAGE
   ========================================================================== */
@media (max-width: 500px) {
  #loadingMessage > div {
    width: 85% !important;
    height: auto !important;
    min-height: 480px !important;
    padding: 25px 20px !important;
  }
}
</style>

<!-- COMPLETE FOUC-PROOF UNLOCK SCRIPT -->
<script>
(function() {
  'use strict';
  
  // Prevent multiple executions
  if (window.foucBusterActive) return;
  window.foucBusterActive = true;
  
  let isUnlocked = false;
  let emergencyTimeout;
  let fontCheckTimeout;
  
  // Perfect unlock function
  function unlock() {
    if (isUnlocked) return;
    isUnlocked = true;
    
    // Clear all safety timeouts
    clearTimeout(emergencyTimeout);
    clearTimeout(fontCheckTimeout);
    
    // Smooth unlock transition
    requestAnimationFrame(() => {
      document.documentElement.classList.add('unlock');
      
      // Accessibility announcement for screen readers
      setTimeout(() => {
        const announcement = document.createElement('div');
        announcement.setAttribute('aria-live', 'polite');
        announcement.setAttribute('aria-atomic', 'true');
        announcement.style.cssText = 'position:absolute;left:-10000px;width:1px;height:1px;overflow:hidden;';
        announcement.textContent = 'Application loaded and ready';
        document.body.appendChild(announcement);
        
        setTimeout(() => {
          if (announcement.parentNode) {
            announcement.parentNode.removeChild(announcement);
          }
        }, 1000);
      }, 100);
      
      // Dispatch unlock event for other scripts
      try {
        window.dispatchEvent(new CustomEvent('foucUnlocked', { detail: { timestamp: Date.now() } }));
      } catch (e) {
        // IE11 fallback
        const event = document.createEvent('CustomEvent');
        event.initCustomEvent('foucUnlocked', false, false, { timestamp: Date.now() });
        window.dispatchEvent(event);
      }
    });
  }
  
  // Font loading detection for critical fonts
  function checkCriticalFonts() {
    if (!document.fonts || !document.fonts.ready) {
      return Promise.resolve();
    }
    
    return new Promise((resolve) => {
      // Wait for Inter font (your main font) to load
      document.fonts.ready.then(() => {
        resolve();
      }).catch(() => {
        resolve(); // Don't block on font errors
      });
      
      // Font loading timeout (2 seconds max)
      fontCheckTimeout = setTimeout(resolve, 2000);
    });
  }
  
  // Check if critical CSS has loaded
  function verifyCSSLoaded() {
    return new Promise((resolve) => {
      // Test if our CSS variables are available
      const testDiv = document.createElement('div');
      testDiv.style.cssText = 'position:absolute;visibility:hidden;color:var(--primary-color);';
      document.body.appendChild(testDiv);
      
      const computedColor = window.getComputedStyle(testDiv).color;
      const hasCSS = computedColor && computedColor !== 'var(--primary-color)';
      
      if (testDiv.parentNode) {
        testDiv.parentNode.removeChild(testDiv);
      }
      
      if (hasCSS) {
        resolve();
      } else {
        // CSS not fully loaded, wait a bit more
        setTimeout(resolve, 100);
      }
    });
  }
  
  // Comprehensive unlock logic
  function initializeUnlock() {
    const checks = [verifyCSSLoaded()];
    
    // Add font check if fonts API is supported
    if (document.fonts) {
      checks.push(checkCriticalFonts());
    }
    
    Promise.all(checks).then(() => {
      // Ensure one more frame for rendering
      requestAnimationFrame(unlock);
    }).catch(() => {
      // Even if checks fail, unlock after short delay
      setTimeout(unlock, 150);
    });
  }
  
  // Emergency timeout - absolute maximum wait (4 seconds)
  emergencyTimeout = setTimeout(() => {
    console.warn('FOUC buster: Emergency unlock triggered after 4 seconds');
    unlock();
  }, 4000);
  
  // Smart initialization based on document state
  if (document.readyState === 'complete') {
    // Document fully loaded
    setTimeout(initializeUnlock, 0);
  } else if (document.readyState === 'interactive') {
    // DOM ready, resources may still be loading
    setTimeout(initializeUnlock, 100);
  } else {
    // Document still loading
    document.addEventListener('DOMContentLoaded', () => {
      setTimeout(initializeUnlock, 50);
    }, { once: true });
  }
  
  // Ultimate safety net
  window.addEventListener('load', () => {
    setTimeout(unlock, 100);
  }, { once: true });
  
  // Handle page visibility changes (back/forward navigation)
  document.addEventListener('visibilitychange', () => {
    if (!document.hidden && !isUnlocked) {
      setTimeout(unlock, 50);
    }
  }, { once: true });
  
  // Emergency user interaction unlock
  const emergencyEvents = ['click', 'touchstart', 'keydown'];
  emergencyEvents.forEach(eventType => {
    document.addEventListener(eventType, () => {
      if (!isUnlocked) {
        setTimeout(unlock, 0);
      }
    }, { once: true, passive: true });
  });
  
  // Handle cases where scripts load out of order
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      setTimeout(initializeUnlock, 50);
    }, { once: true });
  }
  
})();
</script>
</head>
<body>
     <noscript>
          <div style="padding:2rem;text-align:center;font-family:sans-serif">
            <h2>JavaScript Required</h2>
            <p>This map requires JavaScript to function. Please enable it in your browser.</p>
          </div>
    </noscript>
    
    <!-- Map container -->
    <div id="map"></div>

    <!-- GPS accuracy indicator, red, yellow, green 
    <div id="accuracyIndicator"></div>
    -->
    <!-- Enhanced Distance Box with Dark Blue Border -->
    <div id="distanceBox">Initializing...</div>

    <!-- Location Hunt Container -->
    <div class="lochunt-container">
        <img id="locationImage" src=" " alt="Location Image">
        <div class="lochunt-content">
            <div class="lochunt-info">
                <h2 id="locationTitle" class="mb-2 text-primary"></h2>
                <p id="locationCity" class="text-muted mb-1"></p>
                <p id="locationCreator" class="text-muted mb-3"></p>
            </div>
            <div class="audio-player">
                <div class="audio-progress">
                    <div class="progress">
                        <div id="progressBar" class="progress-bar" role="progressbar" style="width: 0%"></div>
                    </div>
                </div>
                <div class="audio-time">
                    <span id="currentTime">0:00</span>
                    <span id="duration">0:00</span>
                </div>
                <div class="audio-controls">
                    <button id="rewindBtn" class="audio-button" aria-label="Rewind 10 seconds"><i class="fas fa-backward"></i></button>
                    <button id="playPauseBtn" class="audio-button" aria-label="Play"><i class="fas fa-play"></i></button>
                    <button id="forwardBtn" class="audio-button" aria-label="Forward 10 seconds"><i class="fas fa-forward"></i></button>
                </div>
                <audio id="locationAudio" preload="auto" crossorigin="anonymous"></audio>
            </div>
        </div>
    </div>

    <!-- Additional Info Container -->
    <div class="additional-info-container">
        <h3 class="mb-3 text-primary text-center">Did You Know?</h3>
        <p id="additionalInfo" class="mb-3 fs-6"></p>
        <div class="d-flex justify-content-center">
            <button id="continueButton" class="btn btn-primary">Continue</button>
        </div>
    </div>
    
    <!-- Map Buttons -->
    <div class="map-buttons">
        <button id="recenterButton" class="map-button" aria-label="Recenter map"><i class="fas fa-crosshairs"></i></button>
        <button id="returnButton" class="map-button" aria-label="Return to main page"><i class="fas fa-sign-out-alt"></i></button>
        <button id="tipsButton" class="map-button" aria-label="Show navigation tips"><i class="fas fa-question-circle"></i></button>
    </div>

    <!-- Summary Modal -->
    <div id="summaryModal" class="modal" style="display: none;">
        <div class="modal-content">
            <p id="summaryContent"></p>
        </div>
    </div>

    <!-- Load scripts with defer to improve page load performance -->
    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js" defer></script>
    <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js" defer></script>
    <script src="/locations_main.js?v=1.0.3" defer></script>

    <script>
// MNThen - Complete JavaScript Application with Enhanced Cooldown and Smooth Movement

// ENTERPRISE ENHANCEMENT: Shared Core Utilities
class EnterpriseCore {
    static generateSecureId(prefix = '', length = 16) {
        try {
            if (window.crypto?.getRandomValues) {
                const array = new Uint8Array(length);
                window.crypto.getRandomValues(array);
                const token = Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
                return prefix ? `${prefix}_${token}` : token;
            }
        } catch (error) {
            console.warn('Secure ID generation failed, using fallback:', error);
        }
        
        // Fallback method
        const timestamp = Date.now().toString(36);
        const random = Math.random().toString(36).substring(2);
        return prefix ? `${prefix}_${timestamp}_${random}` : `${timestamp}_${random}`;
    }

    static createCircularBuffer(maxSize = 100) {
        return {
            items: [],
            maxSize,
            add(item) {
                this.items.push(item);
                if (this.items.length > this.maxSize) {
                    this.items.shift();
                }
                return this.items.length;
            },
            get size() { return this.items.length; },
            get all() { return [...this.items]; },
            clear() { this.items = []; }
        };
    }

    static async delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    static sanitizeInput(input, type = 'general') {
        if (typeof input !== 'string') return input;
        
        const sanitizers = {
            general: str => str.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, ''),
            url: str => encodeURIComponent(str),
            html: str => str.replace(/[<>&"']/g, match => ({
                '<': '&lt;', '>': '&gt;', '&': '&amp;', '"': '&quot;', "'": '&#x27;'
            })[match])
        };
        
        return (sanitizers[type] || sanitizers.general)(input);
    }

    static calculateDistance(pos1, pos2) {
        if (!pos1 || !pos2 || 
            typeof pos1.lat !== 'number' || typeof pos1.lng !== 'number' ||
            typeof pos2.lat !== 'number' || typeof pos2.lng !== 'number') {
            return Infinity;
        }
        
        const R = 6371000; // Earth's radius in meters
        const lat1 = pos1.lat * Math.PI / 180;
        const lat2 = pos2.lat * Math.PI / 180;
        const deltaLat = (pos2.lat - pos1.lat) * Math.PI / 180;
        const deltaLng = (pos2.lng - pos1.lng) * Math.PI / 180;

        const a = Math.sin(deltaLat/2) * Math.sin(deltaLat/2) +
                Math.cos(lat1) * Math.cos(lat2) *
                Math.sin(deltaLng/2) * Math.sin(deltaLng/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

        return R * c;
    }

    static formatBytes(bytes) {
        if (bytes === 0) return '0 B';
        const k = 1024;
        const sizes = ['B', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }
}

// ENTERPRISE ENHANCEMENT: Shared Event System
class EnterpriseEventManager {
    constructor() {
        this.listeners = new Map();
        this.eventHistory = EnterpriseCore.createCircularBuffer(50);
    }

    on(eventType, callback, options = {}) {
        if (!this.listeners.has(eventType)) {
            this.listeners.set(eventType, new Set());
        }
        
        const listener = { callback, options };
        this.listeners.get(eventType).add(listener);
        
        return () => this.off(eventType, listener);
    }

    off(eventType, listener) {
        const listeners = this.listeners.get(eventType);
        if (listeners) {
            listeners.delete(listener);
            if (listeners.size === 0) {
                this.listeners.delete(eventType);
            }
        }
    }

    emit(eventType, data = {}) {
        const event = {
            type: eventType,
            data,
            timestamp: Date.now(),
            id: EnterpriseCore.generateSecureId('evt')
        };

        this.eventHistory.add(event);

        const listeners = this.listeners.get(eventType);
        if (listeners) {
            listeners.forEach(listener => {
                try {
                    if (listener.options.once) {
                        this.off(eventType, listener);
                    }
                    listener.callback(event);
                } catch (error) {
                    console.error(`Event listener error for ${eventType}:`, error);
                }
            });
        }

        return event;
    }

    getEventHistory(eventType = null) {
        const events = this.eventHistory.all;
        return eventType ? events.filter(e => e.type === eventType) : events;
    }

    destroy() {
        this.listeners.clear();
        this.eventHistory.clear();
    }
}

// ENTERPRISE ENHANCEMENT: Shared Storage Management
class EnterpriseStorage {
    constructor(prefix = 'mnthen-enterprise') {
        this.prefix = prefix;
        this.encryptionKey = null;
        this.init();
    }

    async init() {
        await this.initializeEncryption();
    }

    async initializeEncryption() {
        if (!window.crypto?.subtle) return;
        
        try {
            const keyData = localStorage.getItem(`${this.prefix}-key`);
            if (keyData) {
                const keyBuffer = new Uint8Array(atob(keyData).split('').map(c => c.charCodeAt(0)));
                this.encryptionKey = await window.crypto.subtle.importKey(
                    'raw', keyBuffer, { name: 'AES-GCM' }, false, ['encrypt', 'decrypt']
                );
            } else {
                this.encryptionKey = await window.crypto.subtle.generateKey(
                    { name: 'AES-GCM', length: 256 }, true, ['encrypt', 'decrypt']
                );
                
                const keyBuffer = await window.crypto.subtle.exportKey('raw', this.encryptionKey);
                localStorage.setItem(`${this.prefix}-key`, btoa(String.fromCharCode(...new Uint8Array(keyBuffer))));
            }
        } catch (error) {
            console.warn('Encryption initialization failed:', error);
        }
    }

    async encrypt(data) {
        if (!window.crypto?.subtle || !this.encryptionKey) {
            return btoa(encodeURIComponent(JSON.stringify(data)));
        }
        
        try {
            const iv = window.crypto.getRandomValues(new Uint8Array(12));
            const encodedData = new TextEncoder().encode(JSON.stringify(data));
            
            const encrypted = await window.crypto.subtle.encrypt(
                { name: 'AES-GCM', iv }, this.encryptionKey, encodedData
            );
            
            const combined = new Uint8Array(iv.length + encrypted.byteLength);
            combined.set(iv);
            combined.set(new Uint8Array(encrypted), iv.length);
            
            return btoa(String.fromCharCode(...combined));
        } catch (error) {
            console.warn('Encryption failed, using base64:', error);
            return btoa(encodeURIComponent(JSON.stringify(data)));
        }
    }

    async decrypt(encryptedData) {
        if (!window.crypto?.subtle || !this.encryptionKey) {
            try {
                return JSON.parse(decodeURIComponent(atob(encryptedData)));
            } catch {
                return JSON.parse(atob(encryptedData));
            }
        }
        
        try {
            const combined = new Uint8Array(atob(encryptedData).split('').map(c => c.charCodeAt(0)));
            const iv = combined.slice(0, 12);
            const encrypted = combined.slice(12);
            
            const decrypted = await window.crypto.subtle.decrypt(
                { name: 'AES-GCM', iv }, this.encryptionKey, encrypted
            );
            
            return JSON.parse(new TextDecoder().decode(decrypted));
        } catch (error) {
            try {
                return JSON.parse(decodeURIComponent(atob(encryptedData)));
            } catch {
                return JSON.parse(atob(encryptedData));
            }
        }
    }

    async set(key, data, options = {}) {
        try {
            const item = {
                data,
                timestamp: Date.now(),
                expires: options.ttl ? Date.now() + options.ttl : null,
                version: '1.0'
            };
            
            const encrypted = await this.encrypt(item);
            localStorage.setItem(`${this.prefix}-${key}`, encrypted);
            return true;
        } catch (error) {
            console.warn('Storage set failed:', error);
            return false;
        }
    }

    async get(key) {
        try {
            const encrypted = localStorage.getItem(`${this.prefix}-${key}`);
            if (!encrypted) return null;
            
            const item = await this.decrypt(encrypted);
            
            // Check expiration
            if (item.expires && Date.now() > item.expires) {
                this.remove(key);
                return null;
            }
            
            return item.data;
        } catch (error) {
            console.warn('Storage get failed:', error);
            return null;
        }
    }

    remove(key) {
        localStorage.removeItem(`${this.prefix}-${key}`);
    }

    async cleanup(maxAge = 7 * 24 * 60 * 60 * 1000) {
        const now = Date.now();
        const keysToRemove = [];
        
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key?.startsWith(`${this.prefix}-`) && key !== `${this.prefix}-key`) {
                try {
                    const encrypted = localStorage.getItem(key);
                    const item = await this.decrypt(encrypted);
                    
                    if ((item.expires && now > item.expires) || 
                        (now - item.timestamp > maxAge) || 
                        !item.data || !item.timestamp) {
                        keysToRemove.push(key);
                    }
                } catch (error) {
                    keysToRemove.push(key);
                }
            }
        }
        
        keysToRemove.forEach(key => localStorage.removeItem(key));
        return keysToRemove.length;
    }

    getStats() {
        let totalSize = 0;
        let itemCount = 0;
        
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key?.startsWith(`${this.prefix}-`)) {
                const data = localStorage.getItem(key);
                totalSize += data ? data.length * 2 : 0;
                itemCount++;
            }
        }
        
        return { totalSize, itemCount, formattedSize: EnterpriseCore.formatBytes(totalSize) };
    }
}

// ENTERPRISE ENHANCEMENT: PWA Service Worker Manager
class EnterprisePWAManager {
    constructor() {
        this.eventManager = new EnterpriseEventManager();
        this.registration = null;
        this.updateInterval = null;
    }

    async init() {
        if (!('serviceWorker' in navigator)) {
            console.warn('Service Worker not supported');
            return false;
        }

        window.addEventListener('load', () => this.registerServiceWorker());
        return true;
    }

    async registerServiceWorker() {
        try {
            this.registration = await navigator.serviceWorker.register('/sw.js');
            console.log('Enterprise SW registered:', this.registration);
            
            this.setupEventListeners();
            this.setupUpdateChecking();
            this.eventManager.emit('sw-registered', { registration: this.registration });
            
        } catch (error) {
            console.error('SW registration failed:', error);
            this.eventManager.emit('sw-registration-failed', { error });
            
            // Retry once after delay
            setTimeout(async () => {
                try {
                    this.registration = await navigator.serviceWorker.register('/sw.js');
                    console.log('Enterprise SW registered on retry');
                    this.eventManager.emit('sw-registered-retry', { registration: this.registration });
                } catch (retryError) {
                    console.error('SW retry registration failed:', retryError);
                    this.eventManager.emit('sw-retry-failed', { error: retryError });
                }
            }, 5000);
        }
    }

    setupEventListeners() {
        // Service worker messages
        navigator.serviceWorker.addEventListener('message', event => {
            if (event.data?.type === 'SW_ACTIVATED') {
                console.log('Enterprise Service Worker activated, version:', event.data.version);
                this.eventManager.emit('sw-activated', event.data);
            }
        });

        // Update detection
        this.registration.addEventListener('updatefound', () => {
            const newWorker = this.registration.installing;
            if (newWorker) {
                newWorker.addEventListener('statechange', () => {
                    if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                        console.log('Enterprise SW update available');
                        this.eventManager.emit('sw-update-available', { registration: this.registration });
                    }
                });
            }
        });

        // Controller changes
        navigator.serviceWorker.addEventListener('controllerchange', () => {
            console.log('Enterprise SW controller changed - reloading for fresh cache');
            this.eventManager.emit('sw-controller-changed');
            window.location.reload();
        });

        // Cleanup on unload
        window.addEventListener('beforeunload', () => {
            if (this.updateInterval) {
                clearInterval(this.updateInterval);
            }
        });
    }

    setupUpdateChecking() {
        this.updateInterval = setInterval(() => {
            if (this.registration) {
                this.registration.update().catch(error => {
                    console.warn('SW update check failed:', error);
                    this.eventManager.emit('sw-update-check-failed', { error });
                });
            }
        }, 60 * 60 * 1000); // Every hour
    }

    destroy() {
        if (this.updateInterval) {
            clearInterval(this.updateInterval);
        }
        this.eventManager.destroy();
    }
}
        
// ENTERPRISE ENHANCEMENT: Security Manager
class EnterpriseSecurityManager {
    constructor() {
        this.sessionToken = EnterpriseCore.generateSecureId('session', 32);
        this.auditLog = EnterpriseCore.createCircularBuffer(100);
        this.cspViolations = EnterpriseCore.createCircularBuffer(50);
        this.eventManager = new EnterpriseEventManager();
        this.threatDetection = {
            suspiciousActivity: [],
            rateLimiting: new Map(),
            intrusionAttempts: 0
        };
        this.sessionStartTime = Date.now();
        this.isInitialized = false;
    }

    logSecurityEvent(event, details = {}) {
        if (!event || typeof event !== 'string') {
            console.warn('Invalid security event provided');
            return;
        }

        const logEntry = {
            timestamp: new Date().toISOString(),
            event,
            details,
            sessionToken: this.sessionToken,
            userAgent: navigator.userAgent || 'Unknown',
            url: window.location.href,
            sessionDuration: Date.now() - this.sessionStartTime,
            severity: this.calculateEventSeverity(event, details),
            id: EnterpriseCore.generateSecureId('audit')
        };
        
        this.auditLog.add(logEntry);
        
        // Log based on severity
        if (logEntry.severity === 'HIGH') {
            console.error('High Severity Security Event:', logEntry);
            this.handleHighSeverityEvent(logEntry);
        } else if (logEntry.severity === 'MEDIUM') {
            console.warn('Medium Severity Security Event:', logEntry);
        } else {
            console.log('Security Event:', logEntry);
        }

        this.eventManager.emit('security-event', logEntry);
    }

    calculateEventSeverity(event, details) {
        const highSeverityEvents = [
            'CSP_VIOLATION', 'XSS_ATTEMPT', 'SQL_INJECTION', 'UNAUTHORIZED_ACCESS',
            'MULTIPLE_FAILED_ATTEMPTS', 'SUSPICIOUS_ACTIVITY_DETECTED'
        ];
        
        const mediumSeverityEvents = [
            'UNUSUAL_NAVIGATION', 'RATE_LIMIT_EXCEEDED', 'INVALID_INPUT',
            'GEOLOCATION_DENIED', 'NOTIFICATION_BLOCKED'
        ];

        if (highSeverityEvents.includes(event)) return 'HIGH';
        if (mediumSeverityEvents.includes(event)) return 'MEDIUM';
        return 'LOW';
    }

    handleHighSeverityEvent(logEntry) {
        this.threatDetection.intrusionAttempts++;
        
        if (this.threatDetection.intrusionAttempts > 5) {
            this.logSecurityEvent('THREAT_THRESHOLD_EXCEEDED', {
                attempts: this.threatDetection.intrusionAttempts,
                timeframe: Date.now() - this.sessionStartTime
            });
            
            this.initiateLockdownProcedures();
        }
    }

    initiateLockdownProcedures() {
        console.warn('Security lockdown procedures initiated');
        
        try {
            // Clear sensitive data
            Object.keys(localStorage).forEach(key => {
                if (key.includes('sensitive') || key.includes('auth')) {
                    localStorage.removeItem(key);
                }
            });
            
            this.eventManager.emit('security-lockdown', { 
                reason: 'THREAT_THRESHOLD_EXCEEDED',
                timestamp: Date.now(),
                sessionToken: this.sessionToken
            });
            
        } catch (error) {
            console.error('Lockdown procedures failed:', error);
        }
    }

    implementRateLimit(action, maxAttempts = 5, timeWindow = 60000) {
        const now = Date.now();
        const key = `${action}_${this.sessionToken}`;
        
        if (!this.threatDetection.rateLimiting.has(key)) {
            this.threatDetection.rateLimiting.set(key, []);
        }
        
        const attempts = this.threatDetection.rateLimiting.get(key);
        const recentAttempts = attempts.filter(timestamp => now - timestamp < timeWindow);
        this.threatDetection.rateLimiting.set(key, recentAttempts);
        
        if (recentAttempts.length >= maxAttempts) {
            this.logSecurityEvent('RATE_LIMIT_EXCEEDED', {
                action, attempts: recentAttempts.length, timeWindow
            });
            return false;
        }
        
        recentAttempts.push(now);
        this.threatDetection.rateLimiting.set(key, recentAttempts);
        return true;
    }

    sanitizeInput(input, type = 'general') {
        const sanitized = EnterpriseCore.sanitizeInput(input, type);
        
        if (sanitized !== input) {
            this.logSecurityEvent('INPUT_SANITIZED', {
                type, originalLength: input.length, sanitizedLength: sanitized.length
            });
        }
        
        return sanitized;
    }

    init() {
        try {
            this.setupCSPMonitoring();
            this.setupSuspiciousActivityMonitoring();
            this.setupPeriodicHealthChecks();
            this.setupVisibilityMonitoring();
            
            this.logSecurityEvent('SESSION_START', { 
                timestamp: this.sessionStartTime,
                userAgent: navigator.userAgent || 'Unknown',
                language: navigator.language || 'Unknown',
                platform: navigator.platform || 'Unknown',
                cookieEnabled: navigator.cookieEnabled,
                onLine: navigator.onLine
            });
            
            this.isInitialized = true;
            console.log('EnterpriseSecurityManager initialized successfully');
            
        } catch (error) {
            console.error('Failed to initialize EnterpriseSecurityManager:', error);
            this.logSecurityEvent('INITIALIZATION_FAILED', { error: error.message });
        }
    }

    setupCSPMonitoring() {
        document.addEventListener('securitypolicyviolation', (e) => {
            const violation = {
                timestamp: new Date().toISOString(),
                violatedDirective: e.violatedDirective || 'unknown',
                blockedURI: e.blockedURI || 'unknown',
                documentURI: e.documentURI || window.location.href,
                sourceFile: e.sourceFile || 'unknown',
                lineNumber: e.lineNumber || 0,
                id: EnterpriseCore.generateSecureId('csp')
            };
            
            this.cspViolations.add(violation);
            
            const isKnownPattern = this.analyzeCSPViolation(violation);
            this.logSecurityEvent('CSP_VIOLATION', {
                directive: violation.violatedDirective,
                uri: violation.blockedURI,
                isKnownPattern,
                violationCount: this.cspViolations.size
            });
        });
    }

    analyzeCSPViolation(violation) {
        const commonFalsePositives = [
            'chrome-extension://', 'moz-extension://', 'safari-extension://',
            'about:blank', 'data:image/svg+xml'
        ];
        
        return commonFalsePositives.some(pattern => 
            violation.blockedURI.includes(pattern)
        );
    }

    setupSuspiciousActivityMonitoring() {
        let interactionCount = 0;
        const resetInterval = 10000;
        
        const trackInteraction = () => {
            interactionCount++;
            if (interactionCount > 50) {
                this.logSecurityEvent('SUSPICIOUS_ACTIVITY_DETECTED', {
                    type: 'RAPID_INTERACTIONS',
                    count: interactionCount,
                    timeframe: resetInterval
                });
            }
        };
        
        ['click', 'keydown', 'touchstart'].forEach(eventType => {
            document.addEventListener(eventType, trackInteraction, { passive: true });
        });
        
        setInterval(() => { interactionCount = 0; }, resetInterval);
    }

    setupPeriodicHealthChecks() {
        setInterval(() => {
            this.performSecurityHealthCheck();
        }, 300000); // Every 5 minutes
    }

    setupVisibilityMonitoring() {
        document.addEventListener('visibilitychange', () => {
            this.logSecurityEvent('VISIBILITY_CHANGE', {
                hidden: document.hidden,
                visibilityState: document.visibilityState
            });
        });
    }

    performSecurityHealthCheck() {
        const healthMetrics = {
            auditLogSize: this.auditLog.size,
            cspViolationCount: this.cspViolations.size,
            intrusionAttempts: this.threatDetection.intrusionAttempts,
            sessionDuration: Date.now() - this.sessionStartTime,
            memoryUsage: this.estimateMemoryUsage()
        };
        
        this.logSecurityEvent('SECURITY_HEALTH_CHECK', healthMetrics);
        
        if (healthMetrics.intrusionAttempts > 10) {
            this.logSecurityEvent('HIGH_INTRUSION_ATTEMPTS', {
                count: healthMetrics.intrusionAttempts
            });
        }
    }

    estimateMemoryUsage() {
        try {
            const auditSize = JSON.stringify(this.auditLog.all).length;
            const violationsSize = JSON.stringify(this.cspViolations.all).length;
            return Math.round((auditSize + violationsSize) / 1024); // KB
        } catch (error) {
            return 0;
        }
    }

    getSecuritySummary() {
        return {
            sessionToken: this.sessionToken,
            sessionDuration: Date.now() - this.sessionStartTime,
            totalEvents: this.auditLog.size,
            cspViolations: this.cspViolations.size,
            intrusionAttempts: this.threatDetection.intrusionAttempts,
            isInitialized: this.isInitialized,
            lastActivity: this.auditLog.size > 0 ? this.auditLog.all[this.auditLog.size - 1].timestamp : null,
            memoryUsageKB: this.estimateMemoryUsage()
        };
    }

    destroy() {
        this.logSecurityEvent('SESSION_END', {
            duration: Date.now() - this.sessionStartTime,
            totalEvents: this.auditLog.size
        });
        
        this.auditLog.clear();
        this.cspViolations.clear();
        this.threatDetection = { suspiciousActivity: [], rateLimiting: new Map(), intrusionAttempts: 0 };
        this.eventManager.destroy();
        this.isInitialized = false;
        
        console.log('EnterpriseSecurityManager destroyed');
    }
}

// ENTERPRISE ENHANCEMENT: Cache Manager
class EnterpriseCacheManager {
    constructor() {
        this.storage = new EnterpriseStorage('cache');
        this.eventManager = new EnterpriseEventManager();
        this.maxCacheSize = 50 * 1024 * 1024; // 50MB
        this.maxCacheAge = 7 * 24 * 60 * 60 * 1000; // 7 days
        this.proximityThreshold = 1000; // feet
        this.cleanupInterval = null;
    }

    async init() {
        try {
            await this.storage.init();
            await this.cleanupExpiredCache();
            this.startPeriodicCleanup();
            console.log('EnterpriseCacheManager initialized successfully');
            this.eventManager.emit('cache-initialized');
        } catch (error) {
            console.error('Failed to initialize EnterpriseCacheManager:', error);
            throw error;
        }
    }

    async cacheLocationData(location, userPosition) {
        if (!userPosition || !location || !location.id) return;
        
        try {
            const distance = EnterpriseCore.calculateDistance(userPosition, location);
            const distanceFeet = distance * 3.28084;
            
            if (distanceFeet <= this.proximityThreshold) {
                await this.enforceCacheSize();
                
                const cacheData = {
                    location,
                    timestamp: Date.now(),
                    userPosition,
                    distance: distanceFeet,
                    version: '1.0'
                };
                
                await this.storage.set(`location_${location.id}`, cacheData);
                
                console.log(`‚úì Cached location: ${location.name || location.id} (${distanceFeet.toFixed(0)} feet away)`);
                this.eventManager.emit('location-cached', { location, distance: distanceFeet });
            }
        } catch (error) {
            console.warn('Failed to cache location data:', error);
            this.eventManager.emit('cache-error', { error, location });
        }
    }

    async cleanupExpiredCache() {
        const cleaned = await this.storage.cleanup(this.maxCacheAge);
        
        if (cleaned > 0) {
            console.log(`üßπ Cleaned up ${cleaned} expired cache entries`);
            this.eventManager.emit('cache-cleaned', { itemsCleaned: cleaned });
        }
        
        return cleaned;
    }

    async enforceCacheSize() {
        const stats = this.storage.getStats();
        
        if (stats.totalSize > this.maxCacheSize) {
            // This is a simplified approach - in practice, you'd implement LRU eviction
            const cleaned = await this.storage.cleanup(this.maxCacheAge * 0.5); // More aggressive cleanup
            
            if (cleaned > 0) {
                console.log(`üóëÔ∏è Removed ${cleaned} entries to maintain size limit`);
                this.eventManager.emit('cache-size-enforced', { itemsRemoved: cleaned });
            }
        }
    }

    startPeriodicCleanup() {
        if (this.cleanupInterval) {
            clearInterval(this.cleanupInterval);
        }
        
        this.cleanupInterval = setInterval(() => {
            this.cleanupExpiredCache().catch(() => {
                // Silent failure for periodic cleanup
            });
        }, 60 * 60 * 1000); // Every hour
    }

    async getCacheStats() {
        const storageStats = this.storage.getStats();
        
        return {
            ...storageStats,
            maxSizeMB: (this.maxCacheSize / 1024 / 1024),
            utilizationPercent: Math.round((storageStats.totalSize / this.maxCacheSize) * 100),
            maxAgeHours: this.maxCacheAge / (60 * 60 * 1000),
            proximityThresholdFeet: this.proximityThreshold
        };
    }

    destroy() {
        if (this.cleanupInterval) {
            clearInterval(this.cleanupInterval);
            this.cleanupInterval = null;
        }
        this.eventManager.destroy();
        console.log('EnterpriseCacheManager destroyed');
    }
}

// ENTERPRISE ENHANCEMENT: Performance Monitor
class EnterprisePerformanceMonitor {
    constructor() {
        this.eventManager = new EnterpriseEventManager();
        this.metrics = {
            fps: 0, memory: 0, loadedLocations: 0,
            cacheHits: 0, networkRequests: 0
        };
        this.performanceHistory = EnterpriseCore.createCircularBuffer(60);
        this.thresholds = {
            lowFPS: 30, highMemory: 100, networkLatency: 1000, criticalMemory: 200
        };
        this.startTime = performance.now();
        this.isMonitoring = false;
        this.intervals = [];
        this.animationFrameId = null;
        this.lastFrameTime = performance.now();
        this.frameCount = 0;
    }

    startMonitoring() {
        if (this.isMonitoring) {
            console.warn('Performance monitoring already active');
            return;
        }

        try {
            this.monitorFPS();
            this.monitorMemory();
            this.monitorNetworkPerformance();const updateInterval = setInterval(() => {
               this.updateMetrics();
           }, 1000);
           this.intervals.push(updateInterval);
           
           this.isMonitoring = true;
           console.log('EnterprisePerformanceMonitor started successfully');
           this.eventManager.emit('monitoring-started');
       } catch (error) {
           console.error('Failed to start performance monitoring:', error);
           this.eventManager.emit('monitoring-error', { error });
       }
   }

   monitorFPS() {
       const measureFPS = (currentTime) => {
           if (!this.isMonitoring) return;
           
           this.frameCount++;
           if (currentTime - this.lastFrameTime >= 1000) {
               const calculatedFPS = Math.round((this.frameCount * 1000) / (currentTime - this.lastFrameTime));
               this.metrics.fps = Math.max(0, Math.min(240, calculatedFPS));
               this.frameCount = 0;
               this.lastFrameTime = currentTime;
               
               if (this.metrics.fps < 15) {
                   this.logPerformanceAlert('CRITICAL_FPS_DROP', {
                       fps: this.metrics.fps, severity: 'HIGH'
                   });
               }
           }
           this.animationFrameId = requestAnimationFrame(measureFPS);
       };
       
       this.animationFrameId = requestAnimationFrame(measureFPS);
   }

   monitorMemory() {
       if (!performance.memory) {
           console.warn('Memory monitoring not available in this browser');
           return;
       }

       const memoryInterval = setInterval(() => {
           if (!this.isMonitoring) return;
           
           try {
               const memoryInfo = performance.memory;
               const usedMB = Math.round(memoryInfo.usedJSHeapSize / 1024 / 1024);
               const totalMB = Math.round(memoryInfo.totalJSHeapSize / 1024 / 1024);
               const limitMB = Math.round(memoryInfo.jsHeapSizeLimit / 1024 / 1024);
               
               this.metrics.memory = usedMB;
               this.metrics.memoryDetails = {
                   used: usedMB, total: totalMB, limit: limitMB,
                   utilization: Math.round((usedMB / totalMB) * 100)
               };
               
               if (usedMB > this.thresholds.criticalMemory) {
                   this.logPerformanceAlert('CRITICAL_MEMORY_USAGE', {
                       memory: usedMB, limit: limitMB, severity: 'CRITICAL'
                   });
               }
               
               this.analyzeMemoryGrowth(usedMB);
               
           } catch (error) {
               console.warn('Memory monitoring error:', error);
           }
       }, 5000);
       
       this.intervals.push(memoryInterval);
   }

   analyzeMemoryGrowth(currentMemory) {
       const history = this.performanceHistory.all;
       if (history.length < 2) return;
       
       const recentHistory = history.slice(-5);
       if (recentHistory.length < 2) return;
       
       const growthRate = (currentMemory - recentHistory[0].memory) / recentHistory.length;
       
       if (growthRate > 5) {
           this.logPerformanceAlert('MEMORY_LEAK_SUSPECTED', {
               growthRate: growthRate.toFixed(2),
               currentMemory, severity: 'HIGH'
           });
       }
   }

   monitorNetworkPerformance() {
       if (!('PerformanceObserver' in window)) {
           console.warn('PerformanceObserver not available for network monitoring');
           return;
       }

       try {
           const networkObserver = new PerformanceObserver((list) => {
               const entries = list.getEntries();
               entries.forEach(entry => {
                   if (entry.entryType === 'navigation' || entry.entryType === 'resource') {
                       this.processNetworkEntry(entry);
                   }
               });
           });
           
           networkObserver.observe({ entryTypes: ['navigation', 'resource'] });
           
       } catch (error) {
           console.warn('Network performance monitoring setup failed:', error);
       }
   }

   processNetworkEntry(entry) {
       this.metrics.networkRequests++;
       
       const duration = entry.responseEnd - entry.requestStart;
       const size = entry.transferSize || entry.encodedBodySize || 0;
       
       if (duration > this.thresholds.networkLatency) {
           this.logPerformanceAlert('SLOW_NETWORK_REQUEST', {
               url: entry.name,
               duration: Math.round(duration),
               size: Math.round(size / 1024),
               severity: 'MEDIUM'
           });
       }
       
       if (!this.metrics.networkStats) {
           this.metrics.networkStats = {
               totalRequests: 0, averageLatency: 0, totalDataTransferred: 0
           };
       }
       
       this.metrics.networkStats.totalRequests++;
       this.metrics.networkStats.averageLatency = 
           (this.metrics.networkStats.averageLatency + duration) / 2;
       this.metrics.networkStats.totalDataTransferred += size;
   }

   updateMetrics() {
       if (!this.isMonitoring) return;
       
       try {
           if (window.gameLocations && Array.isArray(window.gameLocations)) {
               this.metrics.loadedLocations = window.gameLocations.length;
           }
           
           this.updateCacheMetrics();
           this.addToHistory();
           this.checkPerformanceThresholds();
           
           this.metrics.sessionDuration = Math.round((performance.now() - this.startTime) / 1000);
           
       } catch (error) {
           console.warn('Error updating metrics:', error);
       }
   }

   updateCacheMetrics() {
       // This would integrate with the cache manager
       this.metrics.cacheHits = 0; // Placeholder
   }

   addToHistory() {
       const snapshot = {
           timestamp: Date.now(),
           fps: this.metrics.fps,
           memory: this.metrics.memory,
           loadedLocations: this.metrics.loadedLocations,
           networkRequests: this.metrics.networkRequests
       };
       
       this.performanceHistory.add(snapshot);
   }

   checkPerformanceThresholds() {
       const alerts = [];
       
       if (this.metrics.fps > 0 && this.metrics.fps < this.thresholds.lowFPS) {
           alerts.push({ type: 'LOW_FPS', value: this.metrics.fps, threshold: this.thresholds.lowFPS });
       }
       
       if (this.metrics.memory > this.thresholds.highMemory) {
           alerts.push({ type: 'HIGH_MEMORY', value: this.metrics.memory, threshold: this.thresholds.highMemory });
       }
       
       if (alerts.length > 0) {
           console.warn('Performance Alert:', { alerts, metrics: this.metrics });
           this.eventManager.emit('performance-alert', { alerts, metrics: this.getMetrics() });
       }
   }

   logPerformanceAlert(type, details) {
       const alert = {
           timestamp: new Date().toISOString(),
           type, details,
           currentMetrics: { ...this.metrics },
           id: EnterpriseCore.generateSecureId('perf')
       };
       
       console.warn(`Performance Alert [${type}]:`, alert);
       this.eventManager.emit('performance-alert-logged', alert);
   }

   getMetrics() {
       return {
           ...this.metrics,
           isMonitoring: this.isMonitoring,
           sessionDuration: Math.round((performance.now() - this.startTime) / 1000),
           historyLength: this.performanceHistory.size,
           thresholds: { ...this.thresholds }
       };
   }

   getPerformanceTrends() {
       const history = this.performanceHistory.all;
       if (history.length < 2) {
           return { insufficient_data: true };
       }
       
       const recent = history.slice(-10);
       const avgFPS = recent.reduce((sum, entry) => sum + entry.fps, 0) / recent.length;
       const avgMemory = recent.reduce((sum, entry) => sum + entry.memory, 0) / recent.length;
       
       return {
           averageFPS: Math.round(avgFPS * 100) / 100,
           averageMemory: Math.round(avgMemory * 100) / 100,
           dataPoints: recent.length,
           timeSpan: recent.length > 0 ? recent[recent.length - 1].timestamp - recent[0].timestamp : 0
       };
   }

   stopMonitoring() {
       this.isMonitoring = false;
       
       this.intervals.forEach(interval => clearInterval(interval));
       this.intervals = [];
       
       if (this.animationFrameId) {
           cancelAnimationFrame(this.animationFrameId);
           this.animationFrameId = null;
       }
       
       console.log('EnterprisePerformanceMonitor stopped');
       this.eventManager.emit('monitoring-stopped');
   }

   destroy() {
       this.stopMonitoring();
       this.performanceHistory.clear();
       this.eventManager.destroy();
       console.log('EnterprisePerformanceMonitor destroyed');
   }
}

// ENTERPRISE ENHANCEMENT: Background Sync Manager
class EnterpriseBackgroundSync {
   constructor() {
       this.storage = new EnterpriseStorage('sync');
       this.eventManager = new EnterpriseEventManager();
       this.syncQueue = [];
       this.isOnline = navigator.onLine;
       this.maxRetries = 3;
       this.retryDelays = [1000, 5000, 15000];
       this.maxQueueSize = 100;
       this.syncInProgress = false;
       this.syncStats = {
           totalSynced: 0, totalFailed: 0, lastSyncTime: null, queueProcessingTime: 0
       };
       this.persistenceKey = 'sync-queue';
       this.init();
   }

   async init() {
       await this.storage.init();
       this.setupEventListeners();
       await this.loadPersistedQueue();
   }

   setupEventListeners() {
       window.addEventListener('online', () => {
           const wasOffline = !this.isOnline;
           this.isOnline = true;
           
           if (wasOffline) {
               console.log('Network connection restored, processing sync queue');
               this.eventManager.emit('network-restored', { queueSize: this.syncQueue.length });
               setTimeout(() => this.processSyncQueue(), 1000);
           }
       });

       window.addEventListener('offline', () => {
           this.isOnline = false;
           this.eventManager.emit('network-lost', { queueSize: this.syncQueue.length });
           console.warn('Network connection lost, queuing sync operations');
       });

       document.addEventListener('visibilitychange', () => {
           if (!document.hidden && this.isOnline && this.syncQueue.length > 0) {
               this.processSyncQueue();
           }
       });

       window.addEventListener('beforeunload', () => {
           this.persistQueue();
       });

       setInterval(() => this.performHealthCheck(), 30000);
   }

   async loadPersistedQueue() {
       try {
           const persistedData = await this.storage.get(this.persistenceKey);
           if (persistedData && Array.isArray(persistedData.queue)) {
               const now = Date.now();
               const validItems = persistedData.queue.filter(item => 
                   item.timestamp && (now - item.timestamp) < 24 * 60 * 60 * 1000
               );
               
               this.syncQueue = validItems;
               console.log(`Restored ${validItems.length} items from persisted sync queue`);
               
               if (persistedData.stats) {
                   this.syncStats = { ...this.syncStats, ...persistedData.stats };
               }
           }
       } catch (error) {
           console.warn('Failed to load persisted sync queue:', error);
       }
   }

   async persistQueue() {
       try {
           if (this.syncQueue.length > 0) {
               await this.storage.set(this.persistenceKey, {
                   queue: this.syncQueue,
                   stats: this.syncStats,
                   timestamp: Date.now()
               });
           }
       } catch (error) {
           console.warn('Failed to persist sync queue:', error);
       }
   }

   addToSyncQueue(data) {
       if (!data || typeof data !== 'object') {
           console.warn('Invalid data provided to sync queue');
           return false;
       }

       if (this.syncQueue.length >= this.maxQueueSize) {
           console.warn('Sync queue at maximum capacity, removing oldest item');
           this.syncQueue.shift();
       }

       const syncItem = {
           id: EnterpriseCore.generateSecureId('sync'),
           timestamp: Date.now(),
           data,
           retries: 0,
           priority: data.priority || 'normal',
           lastAttempt: null,
           errors: []
       };

       this.insertByPriority(syncItem);
       
       this.eventManager.emit('item-queued', { 
           id: syncItem.id, type: data.type, priority: syncItem.priority, queueSize: this.syncQueue.length 
       });

       if (this.isOnline && !this.syncInProgress) {
           setTimeout(() => this.processSyncQueue(), 100);
       }

       return syncItem.id;
   }

   insertByPriority(item) {
       const priorities = { high: 3, normal: 2, low: 1 };
       const itemPriority = priorities[item.priority] || 2;
       
       let insertIndex = this.syncQueue.length;
       for (let i = 0; i < this.syncQueue.length; i++) {
           const queuePriority = priorities[this.syncQueue[i].priority] || 2;
           if (itemPriority > queuePriority) {
               insertIndex = i;
               break;
           }
       }
       
       this.syncQueue.splice(insertIndex, 0, item);
   }

   async processSyncQueue() {
       if (this.syncInProgress || !this.isOnline || this.syncQueue.length === 0) {
           return;
       }

       this.syncInProgress = true;
       const startTime = performance.now();
       let processedCount = 0;
       let failedCount = 0;

       this.eventManager.emit('queue-processing-start', { queueSize: this.syncQueue.length });

       try {
           while (this.syncQueue.length > 0 && this.isOnline) {
               const item = this.syncQueue.shift();
               
               try {
                   if (item.lastAttempt && this.shouldDelayRetry(item)) {
                       this.syncQueue.push(item);
                       continue;
                   }

                   item.lastAttempt = Date.now();
                   await this.syncData(item.data);
                   
                   processedCount++;
                   this.syncStats.totalSynced++;
                   this.syncStats.lastSyncTime = Date.now();
                   
                   console.log(`Background sync completed for: ${item.data.type} (ID: ${item.id})`);
                   this.eventManager.emit('sync-success', { 
                       id: item.id, type: item.data.type, retries: item.retries 
                   });

               } catch (error) {
                   await this.handleSyncError(item, error);
                   failedCount++;
               }

               if (processedCount % 5 === 0) {
                   await EnterpriseCore.delay(10);
               }
           }
       } finally {
           this.syncInProgress = false;
           const processingTime = performance.now() - startTime;
           this.syncStats.queueProcessingTime = processingTime;

           this.eventManager.emit('queue-processing-complete', {
               processed: processedCount,
               failed: failedCount,
               remaining: this.syncQueue.length,
               processingTime: Math.round(processingTime)
           });

           if (this.syncQueue.length > 0) {
               this.persistQueue();
           }
       }
   }

   shouldDelayRetry(item) {
       if (item.retries === 0) return false;
       
       const delayIndex = Math.min(item.retries - 1, this.retryDelays.length - 1);
       const requiredDelay = this.retryDelays[delayIndex];
       const timeSinceLastAttempt = Date.now() - item.lastAttempt;
       
       return timeSinceLastAttempt < requiredDelay;
   }

   async handleSyncError(item, error) {
       item.retries++;
       item.errors.push({
           timestamp: Date.now(),
           message: error.message || 'Unknown error',
           stack: error.stack
       });

       this.syncStats.totalFailed++;

       if (item.retries < this.maxRetries) {
           this.syncQueue.push(item);
           
           this.eventManager.emit('sync-retry-queued', {
               id: item.id, type: item.data.type, attempt: item.retries,
               maxRetries: this.maxRetries,
               nextDelay: this.retryDelays[Math.min(item.retries - 1, this.retryDelays.length - 1)]
           });
       } else {
           this.eventManager.emit('sync-failed-permanently', {
               id: item.id, type: item.data.type, totalAttempts: item.retries, errors: item.errors
           });
           
           await this.storeFailed(item);
       }

       console.warn(`Background sync failed (attempt ${item.retries}/${this.maxRetries}):`, {
           id: item.id, type: item.data.type, error: error.message
       });
   }

   async storeFailed(item) {
       try {
           const existing = await this.storage.get('failed-items') || [];
           existing.push({ ...item, finalFailureTime: Date.now() });
           
           const trimmed = existing.slice(-20);
           await this.storage.set('failed-items', trimmed);
       } catch (error) {
           console.warn('Failed to store failed sync item:', error);
       }
   }

   async syncData(data) {
       if (!data || typeof data !== 'object') {
           throw new Error('Invalid sync data provided');
       }

       const networkDelay = this.simulateNetworkDelay();
       
       return new Promise((resolve, reject) => {
           setTimeout(() => {
               if (Math.random() < 0.05) {
                   reject(new Error(`Sync failed for ${data.type}: Network timeout`));
               } else {
                   resolve({
                       success: true, syncId: data.id || 'unknown', timestamp: Date.now()
                   });
               }
           }, networkDelay);
       });
   }

   simulateNetworkDelay() {
       const connection = navigator.connection;
       if (connection) {
           const delays = {
               'slow-2g': Math.random() * 2000 + 1000,
               '2g': Math.random() * 1000 + 500,
               '3g': Math.random() * 500 + 200,
               '4g': Math.random() * 200 + 50
           };
           return delays[connection.effectiveType] || 100;
       }
       return Math.random() * 300 + 100;
   }

   performHealthCheck() {
       const healthData = {
           queueSize: this.syncQueue.length,
           isOnline: this.isOnline,
           syncInProgress: this.syncInProgress,
           stats: this.syncStats,
           oldestItem: this.syncQueue.length > 0 ? 
               Date.now() - this.syncQueue[this.syncQueue.length - 1].timestamp : null
       };

       if (this.syncQueue.length > this.maxQueueSize * 0.8) {
           this.eventManager.emit('queue-size-warning', {
               currentSize: this.syncQueue.length, maxSize: this.maxQueueSize
           });
       }

       if (healthData.oldestItem && healthData.oldestItem > 60 * 60 * 1000) {
           this.eventManager.emit('stale-queue-items', {
               oldestAge: Math.round(healthData.oldestItem / 1000 / 60)
           });
       }

       return healthData;
   }

   getQueueStatus() {
       return {
           size: this.syncQueue.length,
           isProcessing: this.syncInProgress,
           isOnline: this.isOnline,
           stats: { ...this.syncStats },
           nextItem: this.syncQueue.length > 0 ? {
               id: this.syncQueue[0].id,
               type: this.syncQueue[0].data.type,
               priority: this.syncQueue[0].priority,
               retries: this.syncQueue[0].retries
           } : null
       };
   }

   async forceSync() {
       if (this.syncQueue.length === 0) {
           console.log('No items in sync queue');
           return Promise.resolve();
       }

       console.log('Forcing sync queue processing...');
       return this.processSyncQueue();
   }

   clearQueue() {
       const clearedCount = this.syncQueue.length;
       this.syncQueue = [];
       
       this.eventManager.emit('queue-cleared', { itemsCleared: clearedCount });
       console.log(`Cleared ${clearedCount} items from sync queue`);
       
       return clearedCount;
   }

   updateConfig(config) {
       if (config.maxRetries !== undefined) {
           this.maxRetries = Math.max(1, Math.min(10, config.maxRetries));
       }
       if (config.maxQueueSize !== undefined) {
           this.maxQueueSize = Math.max(10, Math.min(1000, config.maxQueueSize));
       }
       if (config.retryDelays && Array.isArray(config.retryDelays)) {
           this.retryDelays = config.retryDelays;
       }
       
       this.eventManager.emit('config-updated', config);
   }

   destroy() {
       this.persistQueue();
       this.syncQueue = [];
       this.syncInProgress = false;
       this.eventManager.destroy();
       console.log('EnterpriseBackgroundSync destroyed');
   }
}

// ENTERPRISE ENHANCEMENT: Main Application Manager
class EnterpriseApplication {
   constructor() {
       this.modules = {};
       this.eventManager = new EnterpriseEventManager();
       this.isInitialized = false;
   }

   async init() {
       try {
           console.log('Initializing Enterprise Application...');
           
           // Initialize core modules
           this.modules.pwa = new EnterprisePWAManager();
           this.modules.security = new EnterpriseSecurityManager();
           this.modules.cache = new EnterpriseCacheManager();
           this.modules.performance = new EnterprisePerformanceMonitor();
           this.modules.sync = new EnterpriseBackgroundSync();

           // Initialize modules in order
           await this.modules.pwa.init();
           this.modules.security.init();
           await this.modules.cache.init();
           this.modules.performance.startMonitoring();
           
           // Set up inter-module communication
           this.setupModuleCommunication();
           
           this.isInitialized = true;
           console.log('Enterprise Application initialized successfully');
           this.eventManager.emit('application-initialized');

       } catch (error) {
           console.error('Failed to initialize Enterprise Application:', error);
           this.eventManager.emit('application-initialization-failed', { error });
           throw error;
       }
   }

   setupModuleCommunication() {
       // Security events feed into performance monitoring
       this.modules.security.eventManager.on('security-event', (event) => {
           if (event.data.severity === 'HIGH') {
               this.modules.performance.logPerformanceAlert('SECURITY_THREAT_DETECTED', {
                   securityEvent: event.data.event,
                   severity: 'HIGH'
               });
           }
       });

       // Performance alerts feed into security logging
       this.modules.performance.eventManager.on('performance-alert', (event) => {
           this.modules.security.logSecurityEvent('PERFORMANCE_DEGRADATION', {
               alerts: event.data.alerts,
               timestamp: Date.now()
           });
       });

       // Cache events for diagnostics
       this.modules.cache.eventManager.on('cache-error', (event) => {
           this.modules.security.logSecurityEvent('CACHE_ERROR', {
               error: event.data.error,
               location: event.data.location
           });
       });

       // Sync events for monitoring
       this.modules.sync.eventManager.on('sync-failed-permanently', (event) => {
           this.modules.security.logSecurityEvent('SYNC_FAILURE', {
               syncId: event.data.id,
               type: event.data.type,
               attempts: event.data.totalAttempts
           });
       });
   }

   // Public API methods
async getStatus() {
    // Safely handle undefined modules
    const modules = this.modules || {};

    return {
        isInitialized: this.isInitialized,
        modules: {
            pwa: Boolean(modules.pwa),
            security: modules.security?.isInitialized,
            cache: Boolean(modules.cache),
            performance: Boolean(modules.performance?.isMonitoring),
            sync: Boolean(modules.sync)
        },
        stats: {
            security: modules.security?.getSecuritySummary?.(),
            cache: modules.cache ? await modules.cache.getCacheStats() : null,
            performance: modules.performance?.getMetrics?.(),
            sync: modules.sync?.getQueueStatus?.()
        }
    };
}

   async cacheLocation(location, userPosition) {
       if (this.modules.cache) {
           return this.modules.cache.cacheLocationData(location, userPosition);
       }
   }

   addToSyncQueue(data) {
       if (this.modules.sync) {
           return this.modules.sync.addToSyncQueue(data);
       }
   }

   checkRateLimit(action, maxAttempts, timeWindow) {
       if (this.modules.security) {
           return this.modules.security.implementRateLimit(action, maxAttempts, timeWindow);
       }
       return true; // Allow if security module not available
   }

   sanitizeInput(input, type) {
       if (this.modules.security) {
           return this.modules.security.sanitizeInput(input, type);
       }
       return EnterpriseCore.sanitizeInput(input, type);
   }

   async destroy() {
       console.log('Shutting down Enterprise Application...');
       
       // Destroy modules in reverse order
       if (this.modules.sync) this.modules.sync.destroy();
       if (this.modules.performance) this.modules.performance.destroy();
       if (this.modules.cache) this.modules.cache.destroy();
       if (this.modules.security) this.modules.security.destroy();
       if (this.modules.pwa) this.modules.pwa.destroy();
       
       this.eventManager.destroy();
       this.isInitialized = false;
       
       console.log('Enterprise Application shutdown complete');
   }
}

// ENTERPRISE ENHANCEMENT: Initialize Application
window.addEventListener('DOMContentLoaded', async () => {
   try {
       window.enterpriseApp = new EnterpriseApplication();
       await window.enterpriseApp.init();
       
       // Expose useful globals for debugging
       window.enterpriseCore = EnterpriseCore;
       window.enterpriseStorage = new EnterpriseStorage();
       
       console.log('üöÄ Enterprise Application ready');
       
   } catch (error) {
       console.error('Enterprise Application startup failed:', error);
   }
});

// Cleanup on page unload
window.addEventListener('beforeunload', () => {
   if (window.enterpriseApp) {
       window.enterpriseApp.destroy();
   }
});
        
// Initialize Enterprise Systems
const enterpriseCacheManager = new EnterpriseCacheManager();
const enterpriseSecurityManager = new EnterpriseSecurityManager();
const enterprisePerformanceMonitor = new EnterprisePerformanceMonitor();
const enterpriseBackgroundSync = new EnterpriseBackgroundSync();

// Initialize enterprise systems
document.addEventListener('DOMContentLoaded', () => {
    enterpriseCacheManager.init();
    enterpriseSecurityManager.init();
    enterprisePerformanceMonitor.startMonitoring();
});

// Global variables 
const CONFIG = {
    // Distance thresholds
    DISTANCE_THRESHOLD: 20, // 20 feet
    EXTENDED_DISTANCE_THRESHOLD: 100, // meters
    MIN_DISTANCE_THRESHOLD: 2, // meters
    PROXIMITY_THRESHOLD: 50, // 50 feet trigger
    JITTER_THRESHOLD: 5, // meters
    MICRO_MOVEMENT_THRESHOLD: 0.3, // meters
    
    // Time thresholds - ENHANCED for 2-minute cooldown
    BACKGROUND_THRESHOLD: 25000, // ms
    INACTIVITY_TIMEOUT: 29000, // ms
    UPDATE_INTERVAL: 50, // ms
    MIN_CENTERING_INTERVAL: 1000, // ms
    STATIONARY_TIME_THRESHOLD: 5000, // ms
    STATIONARY_CHECK_INTERVAL: 2500, // ms
    SIGNIFICANT_MOVEMENT_COOLDOWN: 2000, // ms
    RETRY_DELAY: 1000, // ms
    ZOOM_COOLDOWN: 10000, // 10 seconds between zoom changes
    MIN_RECENTER_INTERVAL: 2000, // ms
    
    // Buffer sizes
    MAX_BUFFER_SIZE: 5,
    STATIONARY_BUFFER_SIZE: 10,
    
    // Accuracy thresholds
    MAX_ACCEPTABLE_ACCURACY: 39, // meters
    STATIONARY_ACCURACY_MULTIPLIER: 1.1,
    STATIONARY_ACCURACY_WEIGHT: 0.7,
    MAX_ACCURACY_THRESHOLD: 2500,
    TARGET_ACCURACY_THRESHOLD: 100,
    
    // Movement thresholds 
    MAX_SPEED: 50, // m/s
    VELOCITY_DECAY: 0.85, 
    BEARING_WEIGHT: 0.3,
    SMOOTHING_FACTOR: 0.35, 
    STATIONARY_THRESHOLD: 2,
    STATIONARY_SMOOTHING: 0.97, 
    STATIONARY_THRESHOLDB: 3,
    MAX_ALPHA: 0.25, 
    MIN_ALPHA: 0.02, 
    MAX_RETRIES: 3,
    
    // Edge thresholds
    EDGE_THRESHOLD_PERCENTAGE: 0.25,
    STRICT_EDGE_THRESHOLD_PERCENTAGE: 0.15,
    CRITICAL_EDGE_THRESHOLD_PERCENTAGE: 0.07,
    
    // Intelligent Zoom Hierarchy
    OVERVIEW_ZOOM: 16, // For speeds > 10 mph
    EXPLORATION_ZOOM: 17, // For 3-10 mph
    DETAIL_ZOOM: 19, // Within 50 ft of POI
    BASE_ZOOM: 17,
    CLOSE_ZOOM: 19,
    
    // Kalman filter
    BASE_PROCESS_NOISE: 0.008, 
    
// Speed-based zoom thresholds with hysteresis
SPEED_ZOOM_THRESHOLDS: [
    { speed: 75, zoom: 14 }, // Very high speed - Wide overview
    { speed: 60, zoom: 15 }, // High speed - Highway overview  
    { speed: 45, zoom: 16 }, // Highway speeds - Overview
    { speed: 30, zoom: 16 }, // Major roads
    { speed: 15, zoom: 17 }, // Urban driving
    { speed: 10, zoom: 17 }, // Walking/slow - Exploration
    { speed: 0, zoom: 17 }   // Stationary
],
    
    // Dynamic Location Triggering
    BEARING_TOLERANCE: 30, // degrees
    DWELL_TIME: 1500, // 1.5 seconds
    LOCATION_COOLDOWN: 120000, // 2 minutes (120 seconds) 
    
    // Predictive Path Smoothing
    PREDICTION_ENABLED: true,
    VELOCITY_PREDICTION_FACTOR: 0.35, 
    ACCELERATION_DAMPING: 0.75
};

// State variables 
let map, userMarker, markerClusterGroup;
let tracking;
let currentLocationIndex = 0;
let visitedLocations = [];
let gameLocations = [];
let isLocationHuntVisible = false;
let lastPosition = null;
let positionBuffer = [];
let filteredPosition = null;
let followUser = true;
let lastVisitedLocationId = null;
let lastKnownPosition = null;
let isTransitioning = false;
let lastVelocity = { lat: 0, lng: 0 };
let isMapInteracting = false;
let isStationary = false;
let stationaryStartTime = null;
let stationaryCheckTimeout = null;
let lastUpdateTime = null;
let lastUpdateTimestamp = null;
let stationaryBuffer = [];
let stationaryPosition = null;
let stationaryCount = 0;
let lastSmoothedPosition = null;
let lastHiddenTime = 0;
let retryCount = 0;
let inactivityTimer;
let animationFrameId = null;
let loadingMessageMinDisplayTime = 0;
let lastCenteringTime = 0;
let lastZoomChangeTime = 0;
let isNearLocation = false;
let lastMapUpdateTime = 0;
let lastVisitTime = 0;
let lastSignificantMovement = Date.now();
let lastPositionForJitter = null;

// Enhanced tracking state for predictive smoothing
let enhancedTrackingState = {
    velocity: { lat: 0, lng: 0 },
    acceleration: { lat: 0, lng: 0 },
    lastVelocityUpdate: 0,
    speedMPS: 0,
    heading: null,
    isMoving: false,
    stationaryStartTime: null
};
      
// Zoom state management with hysteresis
let zoomState = {
    currentTier: 'exploration',
    lastTierChange: 0,
    hysteresisBuffer: [],
    proximityOverride: false
};

// Location triggering state with improved cooldown management
let locationTriggerState = {
    cooldowns: new Map(),
    dwellTimers: new Map(),
    lastBearing: null,
    approachingLocations: new Set(),
    lastVibrations: new Map() // Track vibration timing per location
};

// Accessibility state
let accessibilityState = {
    highContrast: localStorage.getItem('highContrast') === 'true',
    lastAnnouncement: '',
    proximityAlerts: new Set()
};

// Cached DOM elements for better performance
let cachedElements = {};

// Function to cache frequently used DOM elements
function cacheElements() {
    cachedElements = {
        distanceBox: document.getElementById('distanceBox'),
        recenterButton: document.getElementById('recenterButton'),
        returnButton: document.getElementById('returnButton'),
        tipsButton: document.getElementById('tipsButton'),
        lochuntContainer: document.querySelector('.lochunt-container'),
        additionalInfoContainer: document.querySelector('.additional-info-container'),
        accessibilityAnnouncements: document.getElementById('accessibility-announcements'),
        proximityAnnouncements: document.getElementById('proximity-announcements'),
        contrastToggle: document.getElementById('contrastToggle')
    };
}

// Kalman filter with ultra-smooth velocity prediction for stationary devices
const enhancedKalmanFilter = {
    x: { estimate: 0, error: 1, velocity: 0 },
    y: { estimate: 0, error: 1, velocity: 0 },
    q: CONFIG.BASE_PROCESS_NOISE,
    r: 1,
    lastTimestamp: null,
    stationaryDetector: { // New: dedicated stationary detection
        consecutiveStationaryReadings: 0,
        isStationary: false,
        stationaryThreshold: 8, // Number of consecutive readings to confirm stationary
        maxStationaryRadius: 0.5 // Maximum movement radius when stationary (meters)
    },
    
    update: function(measurement) {
        const currentTime = measurement.timestamp || Date.now();
        
        // Initialize if first measurement
        if (this.x.estimate === 0 && this.y.estimate === 0) {
            this.x.estimate = measurement.lng;
            this.y.estimate = measurement.lat;
            this.lastTimestamp = currentTime;
            return {...measurement};
        }
        
        // Calculate time delta
        const dt = this.lastTimestamp ? (currentTime - this.lastTimestamp) / 1000 : 0;
        
        if (dt > 0 && dt < 10) { // Reasonable time delta
            // Calculate movement distance for stationary detection
            const movementDistance = Math.sqrt(
                Math.pow((measurement.lng - this.x.estimate) * 111320 * Math.cos(measurement.lat * Math.PI / 180), 2) +
                Math.pow((measurement.lat - this.y.estimate) * 111320, 2)
            );
            
            // Enhanced stationary detection
            if (movementDistance < this.stationaryDetector.maxStationaryRadius) {
                this.stationaryDetector.consecutiveStationaryReadings++;
            } else {
                this.stationaryDetector.consecutiveStationaryReadings = 0;
                this.stationaryDetector.isStationary = false;
            }
            
            // Update stationary state
            if (this.stationaryDetector.consecutiveStationaryReadings >= this.stationaryDetector.stationaryThreshold) {
                this.stationaryDetector.isStationary = true;
            }
            
            // Velocity-based prediction
            const predictedX = this.x.estimate + (this.x.velocity * dt);
            const predictedY = this.y.estimate + (this.y.velocity * dt);
            
            // Update velocity estimates with enhanced smoothing for stationary devices
            if (this.lastTimestamp) {
                const rawVelX = (measurement.lng - this.x.estimate) / dt;
                const rawVelY = (measurement.lat - this.y.estimate) / dt;
                
                // Apply stronger velocity smoothing when stationary
                const velocityDecay = this.stationaryDetector.isStationary ? 0.95 : 0.85;
                
                this.x.velocity = this.x.velocity * velocityDecay + rawVelX * (1 - velocityDecay);
                this.y.velocity = this.y.velocity * velocityDecay + rawVelY * (1 - velocityDecay);
            }
            
            // Calculate magnitude of velocity
            const speed = Math.sqrt(this.x.velocity * this.x.velocity + this.y.velocity * this.y.velocity);
            const speedMPS = speed * 111320; // Convert to m/s approximately
            
            // Enhanced adaptive noise based on speed, accuracy, and stationary state
            let adaptiveQ = this.q;
            
            if (this.stationaryDetector.isStationary) {
                // Ultra-low process noise for stationary devices
                adaptiveQ = this.q * 0.05;
            } else if (speedMPS > 2.24) {
                // Reduce smoothing when speed > 5 mph
                adaptiveQ = this.q * (1 + speedMPS * 0.08);
            } else if (speedMPS < 0.13) {
                // More smoothing when nearly stationary
                adaptiveQ = this.q * 0.15;
            }
            
            // Enhanced measurement noise based on accuracy and stationary state
            let r = this.r * (measurement.accuracy ? (measurement.accuracy / 10) : 1);
            
            if (this.stationaryDetector.isStationary) {
                // Reduce measurement noise weight when stationary for ultra-smooth tracking
                r = r * 2.5; // Higher measurement noise = more smoothing
            }
            
            // X coordinate (longitude) with prediction
            const predErrX = this.x.error + adaptiveQ;
            const gainX = predErrX / (predErrX + r);
            this.x.estimate = predictedX + gainX * (measurement.lng - predictedX);
            this.x.error = (1 - gainX) * predErrX;
            
            // Y coordinate (latitude) with prediction
            const predErrY = this.y.error + adaptiveQ;
            const gainY = predErrY / (predErrY + r);
            this.y.estimate = predictedY + gainY * (measurement.lat - predictedY);
            this.y.error = (1 - gainY) * predErrY;
        } else {
            // Fallback for invalid time deltas
            this.x.estimate = measurement.lng;
            this.y.estimate = measurement.lat;
            this.x.velocity = 0;
            this.y.velocity = 0;
            this.stationaryDetector.consecutiveStationaryReadings = 0;
        }
        
        this.lastTimestamp = currentTime;
        
        return {
            lat: this.y.estimate,
            lng: this.x.estimate,
            accuracy: measurement.accuracy,
            timestamp: currentTime,
            heading: measurement.heading,
            speedMPS: measurement.speedMPS,
            isStationary: this.stationaryDetector.isStationary
        };
    },
    
    reset: function(measurement) {
        this.x.estimate = measurement.lng;
        this.y.estimate = measurement.lat;
        this.x.error = 1;
        this.y.error = 1;
        this.x.velocity = 0;
        this.y.velocity = 0;
        this.lastTimestamp = measurement.timestamp;
        this.stationaryDetector.consecutiveStationaryReadings = 0;
        this.stationaryDetector.isStationary = false;
    }
};

// Accessibility Functions
function announceToScreenReader(message, priority = 'polite') {
    const element = priority === 'assertive' ? 
        cachedElements.proximityAnnouncements : 
        cachedElements.accessibilityAnnouncements;
    
    if (element && message !== accessibilityState.lastAnnouncement) {
        element.textContent = message;
        accessibilityState.lastAnnouncement = message;
        
        // Clear after announcement to allow repeat announcements
        setTimeout(() => {
            if (element.textContent === message) {
                element.textContent = '';
            }
        }, 1000);
    }
}

function toggleHighContrast() {
    accessibilityState.highContrast = !accessibilityState.highContrast;
    localStorage.setItem('highContrast', accessibilityState.highContrast);
    
    if (accessibilityState.highContrast) {
        document.body.classList.add('high-contrast');
        announceToScreenReader('High contrast mode enabled');
    } else {
        document.body.classList.remove('high-contrast');
        announceToScreenReader('High contrast mode disabled');
    }
}

// Haptic feedback function
function triggerHapticFeedback(pattern = [100]) {
    if ('vibrate' in navigator) {
        navigator.vibrate(pattern);
    }
}

// Calculate bearing between two points
function calculateBearing(from, to) {
    const lat1 = from.lat * Math.PI / 180;
    const lat2 = to.lat * Math.PI / 180;
    const deltaLng = (to.lng - from.lng) * Math.PI / 180;
    
    const y = Math.sin(deltaLng) * Math.cos(lat2);
    const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(deltaLng);
    
    const bearing = Math.atan2(y, x) * 180 / Math.PI;
    return (bearing + 360) % 360; // Normalize to 0-360
}

// Check if user is approaching a location
function isApproachingLocation(userPos, userBearing, locationPos) {
    if (!userBearing) return true; // If no bearing data, allow trigger
    
    const bearingToLocation = calculateBearing(userPos, locationPos);
    const bearingDiff = Math.abs(userBearing - bearingToLocation);
    const normalizedDiff = Math.min(bearingDiff, 360 - bearingDiff);
    
    return normalizedDiff <= CONFIG.BEARING_TOLERANCE;
}

function calculateIntelligentZoom(speedMPS, distanceToClosestPOI) {
    // Simple wrapper - all the intelligence is now in getSpeedBasedZoom
    return getSpeedBasedZoom(speedMPS, distanceToClosestPOI);
}

// Helper function to validate position objects
function isValidPosition(pos) {
    return pos && 
           typeof pos.lat === 'number' && 
           typeof pos.lng === 'number' && 
           !isNaN(pos.lat) && 
           !isNaN(pos.lng);
}

// Clean up resources and prevent memory leaks
function setupMemoryManagement() {
    // Store references that need cleanup
    const cleanupTasks = [];
    
    // Add cleanup for map event listeners when changing views
    const registerCleanupTask = (task) => {
        cleanupTasks.push(task);
    };
    
    // Cleanup function for audio elements
    const cleanupAudioResources = () => {
        const audioElements = document.querySelectorAll('audio');
        audioElements.forEach(audio => {
            audio.pause();
            audio.src = '';
            audio.load();
        });
    };
    
    // Cleanup function for map resources
    const cleanupMapResources = () => {
        if (markerClusterGroup) {
            markerClusterGroup.clearLayers();
        }
        
        // Clear any pending animations
        if (animationFrameId !== null) {
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
        }
        
        // Clear all timeouts
        for (let i = setTimeout(function() {}, 0); i > 0; i--) {
            clearTimeout(i);
        }
    };
    
    // Register cleanup tasks
    registerCleanupTask(cleanupAudioResources);
    registerCleanupTask(cleanupMapResources);
    
    // Execute all cleanup tasks
    const executeCleanup = () => {
        cleanupTasks.forEach(task => {
            try {
                task();
            } catch (e) {
                console.error('Error during cleanup:', e);
            }
        });
    };
    
    // Add page visibility change handler to clean up when page is hidden
    document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
            cleanupAudioResources();
        }
    });
    
    // Add cleanup before unload
    window.addEventListener('beforeunload', executeCleanup);
    
    // Expose cleanup method
    window.performCleanup = executeCleanup;
    
    return {
        registerCleanupTask,
        executeCleanup
    };
}

// Initialize memory management
const memoryManager = setupMemoryManagement();

// Initialize map and core functionality
function initMap() {
  /* 1. Scoped storage cleanup */
  ['lastKnownPos', 'routeHistory', 'userPrefs'].forEach(k => {
    try { localStorage.removeItem(k); sessionStorage.removeItem(k); } catch (_) {}
  });

  /* 2. Non-blocking cache wipe */
  if ('caches' in window) {
    caches.keys()
      .then(keys => Promise.all(keys.map(k => caches.delete(k))))
      .catch(() => {});
  }

  /* 3. One-shot map creation ‚Äì Minnesota overview to start */
  map = L.map('map', {
    zoomControl: false,
    attributionControl: false,
    zoomSnap: 0.1,
    zoomDelta: 0.5,
    wheelDebounceTime: 100,
    tapTolerance: 15,
    bounceAtZoomLimits: false,
    preferCanvas: true,
    renderer: L.canvas(),
    fadeAnimation: false,
    zoomAnimationThreshold: 4,
    markerZoomAnimation: false
  }).setView([46.392410, -94.636230], 9);   // geographic center of Minnesota

  /* 4. Instant tile layer */
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    minZoom: 7,
    maxZoom: 17,
    attribution: '',
    updateWhenIdle: true,
    updateWhenZooming: false,
    keepBuffer: 2,
    className: 'map-tiles'
  }).addTo(map);

  /* 5. Cluster group (pre-allocated) */
  markerClusterGroup = L.markerClusterGroup({
    showCoverageOnHover: false,
    zoomToBoundsOnClick: true,
    spiderfyOnMaxZoom: true,
    animate: false,
    chunkedLoading: true,
    chunkProgress: updateLoadingStatus,
    maxClusterRadius: z => z > 16 ? 40 : 80,
    iconCreateFunction: c => L.divIcon({
      html: `<div><span>${c.getChildCount()}</span></div>`,
      className: 'marker-cluster-custom',
      iconSize: [40, 40]
    })
  }).addTo(map);

  /* 6. Single-DOM user marker */
  userMarker = L.marker([0, 0], {
    icon: L.divIcon({
      className: 'user-marker',
      html: '<div class="user-marker-icon"></div>',
      iconSize: [20, 20],
      iconAnchor: [10, 10]
    }),
    zIndexOffset: 1000
  }).addTo(map);

  /* 6a. Keep icon synced every frame (zoom/pan drift fix) */
  const keepMarkerSynced = () => {
    if (lastPosition) {
      userMarker.setLatLng([lastPosition.lat, lastPosition.lng], { animate: false });
    }
    requestAnimationFrame(keepMarkerSynced);
  };
  requestAnimationFrame(keepMarkerSynced);

  /* 7. Geolocation */
  showLoadingMessage();
  if ('geolocation' in navigator) {
    const opts = { enableHighAccuracy: true, timeout: 45_000, maximumAge: 0 };
    navigator.geolocation.getCurrentPosition(
      initializeUserLocation,
      () => navigator.geolocation.getCurrentPosition(initializeUserLocation, handleLocationError, opts),
      opts
    );
  } else {
    showPopup('Geolocation Error', 'Geolocation is not supported');
    map.flyTo([44.9778, -93.2650], 17); // fallback only if geo completely unavailable
    hideLoadingMessage();
  }
}

function updateLoadingStatus(processed, total, elapsed) {
    if (processed === total) {
        // All markers loaded
        console.log(`Loaded ${processed} markers in ${elapsed.toFixed(2)}ms`);
    }
}

function showLoadingMessage() {
    const existingMessage = document.getElementById('loadingMessage');
    if (existingMessage) return;
    
    // Set the minimum display time to 8 seconds from now
    loadingMessageMinDisplayTime = Date.now() + 8000;

  // Start geolocation *immediately* in the background
   Promise.allSettled([
    new Promise((resolve) => {
        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    initializeUserLocation(position);
                    resolve();
                },
                (error) => {
                    console.log("Background location failed:", error);
                    resolve(); // Still resolve to not block
                },
                {
                    timeout: 8000,
                    enableHighAccuracy: true
                }
            );
        } else {
            resolve();
        }
    })
]);
    
    // Create main container with background image
    const loadingMessage = document.createElement('div');
    loadingMessage.id = 'loadingMessage';
    loadingMessage.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        background-image: url('https://raw.githubusercontent.com/mreicher/MNThen/refs/heads/main/images/splash_screen.webp');
        background-size: cover;
        background-position: center;
        z-index: 1000;
        font-family: 'Montserrat', 'Segoe UI', 'Roboto', sans-serif;
        transition: opacity 0.5s ease;
    `;
    
    // Fixed-size content container with precise structure
    const contentContainer = document.createElement('div');
    contentContainer.style.cssText = `
        display: grid;
        grid-template-rows: auto auto 1fr auto auto;
        background-color: white;
        padding: 35px 30px;
        border-radius: 20px;
        box-shadow: 0 20px 50px rgba(0, 0, 0, 0.35), 0 2px 10px rgba(0, 0, 0, 0.2);
        width: 450px;
        height: 500px;
        text-align: center;
        backdrop-filter: blur(5px);
        border: 1px solid rgba(255, 255, 255, 0.18);
    `;
    
    // Enhanced logo
    const logoImage = document.createElement('img');
    logoImage.src = 'https://mnthen.com/images/logo.webp';
    logoImage.alt = 'Minnesota Then Logo';
    logoImage.style.cssText = `
        width: 180px;
        height: auto;
        margin: 0 auto 25px;
        border-radius: 12px;
        object-fit: contain;
        filter: drop-shadow(0 4px 8px rgba(0, 40, 85, 0.2));
    `;
    
    // Enhanced main title
    const mainTitle = document.createElement('h1');
    mainTitle.style.cssText = `
        margin: 0 0 8px 0;
        font-size: 22px;
        font-weight: 700;
        color: #002855;
        text-align: center;
        line-height: 1.2;
        letter-spacing: -0.02em;
        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
    `;
    mainTitle.textContent = 'The Museum Without Walls';
    
    // Enhanced tagline with MORE bottom margin
    const welcomeMessage = document.createElement('h2');
    welcomeMessage.style.cssText = `
        margin: 0 0 40px 0; /* Increased bottom margin as requested */
        font-size: 18px;
        font-weight: 500;
        color: #0066cc;
        text-align: center;
        line-height: 1.3;
        letter-spacing: 0.02em;
        opacity: 0.9;
    `;
    welcomeMessage.textContent = 'Where Every Step Tells A Story';
    
    // Status text container with fixed height
    const statusTextContainer = document.createElement('div');
    statusTextContainer.style.cssText = `
        min-height: 60px;
        display: flex;
        align-items: center;
        justify-content: center;
        margin-bottom: 20px;
    `;
    
    // Enhanced status text with pulse animation
    const statusText = document.createElement('p');
    statusText.id = 'loadingStatusText';
    statusText.style.cssText = `
        margin: 0;
        font-size: 18px;
        font-weight: 500;
        text-align: center;
        color: #0077dd;
        line-height: 1.4;
        animation: pulse 2s infinite;
        letter-spacing: 0.01em;
    `;
    statusText.textContent = 'Location found, proceeding to stabilization...';
    statusTextContainer.appendChild(statusText);
    
    // More professional progress bar container
    const progressContainer = document.createElement('div');
    progressContainer.style.cssText = `
        width: 100%;
        height: 10px;
        background-color: rgba(0, 51, 102, 0.08);
        border-radius: 10px;
        overflow: hidden;
        margin-bottom: 12px; /* REDUCED margin to bottom note */
        box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.12);
    `;
    
    // Enhanced animated progress bar
    const progressBar = document.createElement('div');
    progressBar.id = 'loadingProgressBar';
    progressBar.style.cssText = `
        height: 100%;
        width: 0%;
        background: linear-gradient(90deg, #0066cc, #0099ff, #00aaff, #0099ff, #0066cc);
        background-size: 200% auto;
        border-radius: 10px;
        transition: width 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
        box-shadow: 0 0 10px rgba(0, 120, 255, 0.6);
        animation: gradientShift 3s ease infinite;
    `;
    
    progressContainer.appendChild(progressBar);
    
    // Note container with fixed height
    const noteContainer = document.createElement('div');
    noteContainer.style.cssText = `
        min-height: 50px;
        display: flex;
        align-items: center;
        justify-content: center;
    `;
    
    // Note at the bottom
    const loadingNote = document.createElement('p');
    loadingNote.style.cssText = `
        margin: 0;
        font-size: 16px;
        color: #555;
        font-weight: 500;
        opacity: 0.8;
    `;
    loadingNote.textContent = 'Preparing your experience.';
    noteContainer.appendChild(loadingNote);
    
    // Assemble the container with precise spacing
    contentContainer.appendChild(logoImage);
    contentContainer.appendChild(mainTitle);
    contentContainer.appendChild(welcomeMessage);
    contentContainer.appendChild(statusTextContainer);
    contentContainer.appendChild(progressContainer);
    contentContainer.appendChild(noteContainer);
    
    loadingMessage.appendChild(contentContainer);
    document.body.appendChild(loadingMessage);
    
    // Set animation parameters
    const totalDuration = 10000;
    const updateInterval = 100;
    const steps = totalDuration / updateInterval;
    let progress = 0;
    
    // Enhanced text animations
    const animations = [
        "Initializing map data...",
        "Processing location coordinates...",
        "Preparing exhibit data...",
        "Calibrating view perspective...",
        "Loading nearby points of interest...",
        "Optimizing content for your location...",
        "Finalizing your experience..."
    ];
    
    // Animate progress bar over 10 seconds with status text updates
    const progressInterval = setInterval(() => {
        progress += (100 / steps);
        
        if (progressBar) {
            progressBar.style.width = `${Math.min(progress, 100)}%`;
        }
        
        // Update status text periodically
        if (statusText) {
            const animationIndex = Math.min(
                Math.floor(progress / (100 / animations.length)),
                animations.length - 1
            );
            statusText.textContent = animations[animationIndex];
        }
        
        if (progress >= 100) {
            clearInterval(progressInterval);
            tryHideLoadingMessage();
        }
    }, updateInterval);
    
    // Store the interval ID
    loadingMessage.dataset.progressInterval = progressInterval;
}
        
function tryHideLoadingMessage() {
    // Only fade out if minimum display time has been reached
    if (Date.now() >= loadingMessageMinDisplayTime) {
        fadeOutLoadingMessage();
    } else {
        // Schedule another check for when the minimum time is reached
        const timeRemaining = loadingMessageMinDisplayTime - Date.now();
        setTimeout(fadeOutLoadingMessage, timeRemaining + 100); // Add a small buffer
    }
}

function fadeOutLoadingMessage() {
    const loadingMessage = document.getElementById('loadingMessage');
    if (!loadingMessage) return;
    
    // Clear any ongoing timers
    if (loadingMessage.dataset.progressInterval) {
        clearInterval(parseInt(loadingMessage.dataset.progressInterval));
    }
    
    // Complete progress bar if not already complete
    const progressBar = document.getElementById('loadingProgressBar');
    if (progressBar) {
        progressBar.style.width = '100%';
    }
    
    // Show distance box simultaneously with loading message fade out
    const distanceBox = cachedElements.distanceBox || document.getElementById('distanceBox');
    if (distanceBox) {
        distanceBox.classList.add('show');
    }
    
    // Fade out and remove loading message
    loadingMessage.style.opacity = '0';
    setTimeout(() => {
        if (loadingMessage && loadingMessage.parentNode) {
            loadingMessage.parentNode.removeChild(loadingMessage);
        }
    }, 500); // 500ms fade-out transition
}

// Public API function to hide loading message (respects minimum display time)
function hideLoadingMessage() {
    tryHideLoadingMessage();
}

//add GPS strength indicator to the upper right of the screen
function updateAccuracyIndicator(accuracy) {
    const indicator = document.getElementById('accuracyIndicator');
    indicator.style.backgroundColor = accuracy < 20 ? '#4CAF50' : 
                                     accuracy < 50 ? '#FF9800' : 
                                     '#F44336';
}

function initializeUserLocation(position) {
    console.log("Initial position data:", JSON.stringify(position));

    if (!position || !position.coords) {
        console.error("Invalid initial position object");
        handleLocationError(new Error("Invalid initial position"));
        return;
    }

    const { latitude: userLat, longitude: userLng, accuracy } = position.coords;

    if (isNaN(userLat) || isNaN(userLng)) {
        console.error("Invalid initial coordinates:", { userLat, userLng });
        handleLocationError(new Error("Invalid initial coordinates"));
        return;
    }

    console.log("Valid initial position:", { userLat, userLng, accuracy });

    try {
        userMarker.setLatLng([userLat, userLng]);
        map.setView([userLat, userLng], 17);
        
        // Initialize enhanced Kalman filter with first position
        enhancedKalmanFilter.reset({
            lat: userLat,
            lng: userLng,
            accuracy: accuracy || 20,
            timestamp: Date.now()
        });
        
        // Announce successful location acquisition
        announceToScreenReader('Location acquired successfully. Map is ready for navigation.');
        
        hideLoadingMessage();
        startPositionUpdates();
        startHunt();
        
        // Pulse the distance box to draw attention
        const distanceBox = cachedElements.distanceBox || document.getElementById('distanceBox');
        distanceBox.classList.add('pulse');
        setTimeout(() => distanceBox.classList.remove('pulse'), 3000);
    } catch (error) {
        console.error("Error setting initial user location:", error);
        handleLocationError(error);
    }
}

function startPositionUpdates() {
    // Store the watch ID to allow stopping if needed
    const watchId = navigator.geolocation.watchPosition(
        handlePositionUpdate,
        handleLocationError,
        {
            enableHighAccuracy: true,
            maximumAge: 1000,
            timeout: 10000
        }
    );
    
    // Optional: Store watchId for later use (to stop tracking)
    window.positionWatchId = watchId;
    
    // Add error recovery mechanism
    window.addEventListener('online', () => {
        // If connection was lost and restored, restart position tracking
        if (window.positionWatchId) {
            navigator.geolocation.clearWatch(window.positionWatchId);
            window.positionWatchId = navigator.geolocation.watchPosition(
                handlePositionUpdate,
                handleLocationError,
                {
                    enableHighAccuracy: true,
                    maximumAge: 1000,
                    timeout: 10000
                }
            );
        }
    });
    
    // Return the watchId for external use
    return watchId;
}

function handlePositionUpdate(position) {
    // Validate position data with enhanced checks
    if (!position || !position.coords || 
        isNaN(position.coords.latitude) || 
        isNaN(position.coords.longitude) ||
        Math.abs(position.coords.latitude) > 90 ||
        Math.abs(position.coords.longitude) > 180) {
        console.warn("Invalid position data received");
        return;
    }
    
    // Enhanced timestamp validation
    const positionTimestamp = position.timestamp || Date.now();
    const currentTime = Date.now();
    const maxAgeMs = 30000; // 30 seconds
    
    if (currentTime - positionTimestamp > maxAgeMs) {
        console.warn("Position data too old, ignoring");
        return;
    }
    
    // Prevent duplicate processing of same position
    if (window.lastProcessedTimestamp === positionTimestamp) {
        return;
    }
    window.lastProcessedTimestamp = positionTimestamp;
    
    // Extract and validate accuracy
    const accuracy = Math.max(position.coords.accuracy || 0, 1); // Minimum 1m accuracy
    const speed = position.coords.speed || 0;
    const heading = position.coords.heading;
    
    // Calculate speed if coords.speed is not available
    let calculatedSpeedMPS = speed;
    if (!speed && window.lastValidPosition) {
        const timeDelta = (positionTimestamp - window.lastValidPosition.timestamp) / 1000;
        if (timeDelta > 0 && timeDelta < 10) { // Only calculate for reasonable time gaps
            const distance = perfectLocationTracker.calculateDistance(
                window.lastValidPosition,
                { lat: position.coords.latitude, lng: position.coords.longitude }
            );
            calculatedSpeedMPS = distance / timeDelta;
        }
    }
    
    // Update global state
    window.lastPositionAccuracy = accuracy;
    window.lastValidPosition = {
        lat: position.coords.latitude,
        lng: position.coords.longitude,
        timestamp: positionTimestamp,
        accuracy: accuracy,
        speed: calculatedSpeedMPS,
        heading: heading
    };
    
    // Update enhanced tracking state for other components
    if (typeof enhancedTrackingState !== 'undefined') {
        enhancedTrackingState.speedMPS = calculatedSpeedMPS;
        enhancedTrackingState.isMoving = calculatedSpeedMPS > 0.5;
        enhancedTrackingState.accuracy = accuracy;
        enhancedTrackingState.lastUpdate = positionTimestamp;
    }
    
    // **SINGLE SOURCE OF TRUTH** - Only call the perfect location tracker
    const success = updateUserLocation(position);
    
    if (success) {
        // Handle marker styling (visual effects only, NOT position)
        updateMarkerStylingOnly(calculatedSpeedMPS, heading);
        
        // Handle intelligent zoom based on movement
        handleIntelligentZoom(calculatedSpeedMPS, accuracy);
        
        // Update related UI components
        updateLocationDependentComponents(accuracy, calculatedSpeedMPS);
        
        // Trigger any location-based game logic
        triggerLocationBasedEvents(window.lastValidPosition);
    }
}

/**
 * Update marker styling only (NOT position - that's handled by perfect tracker)
 */
function updateMarkerStylingOnly(speedMPS, heading) {
    try {
        if (!window.userMarker) return;
        
        const markerElement = window.userMarker.getElement();
        if (!markerElement) return;
        
        const iconElement = markerElement.querySelector('.user-marker-icon');
        if (!iconElement) return;
        
        // Movement animation class
        if (speedMPS > 0.5) {
            iconElement.classList.add('moving');
        } else {
            iconElement.classList.remove('moving');
        }
        
        // Heading rotation
        if (heading !== null && heading !== undefined && !isNaN(heading)) {
            iconElement.classList.add('has-heading');
            iconElement.style.transform = `rotate(${heading}deg)`;
        } else {
            iconElement.classList.remove('has-heading');
            iconElement.style.transform = '';
        }
        
        // Speed-based visual effects
        if (speedMPS > 2) { // Walking/running
            iconElement.classList.add('fast-moving');
        } else {
            iconElement.classList.remove('fast-moving');
        }
        
    } catch (error) {
        console.warn('Error updating marker styling:', error);
    }
}

/**
 * Handle intelligent zoom based on movement speed and accuracy
 */
function handleIntelligentZoom(speedMPS, accuracy) {
    try {
        if (!window.map || typeof calculateIntelligentZoom !== 'function') return;
        
        // Only adjust zoom when moving significantly
        if (speedMPS < 1) return;
        
        // Find closest game location for context
        let closestDistance = Infinity;
        if (window.gameLocations && window.gameLocations.length > 0) {
            for (const loc of window.gameLocations) {
                if (loc && loc.lat && loc.lng) {
                    const dist = perfectLocationTracker.calculateDistance(
                        window.lastValidPosition, 
                        loc
                    );
                    if (dist < closestDistance) {
                        closestDistance = dist;
                    }
                }
            }
        }
        
        const distanceFeet = closestDistance * 3.28084;
        const targetZoom = calculateIntelligentZoom(speedMPS, distanceFeet);
        
        // Only adjust if significantly different (avoid constant zoom changes)
        if (targetZoom && Math.abs(window.map.getZoom() - targetZoom) > 0.75) {
            window.map.setZoom(targetZoom, { 
                animate: true, 
                duration: 1.5 // Slower zoom for smoother experience
            });
        }
        
    } catch (error) {
        console.warn('Error handling intelligent zoom:', error);
    }
}

/**
 * Update location-dependent UI components
 */
function updateLocationDependentComponents(accuracy, speedMPS) {
    // Throttle UI updates to avoid performance issues
    if (window.uiUpdateThrottle) return;
    
    window.uiUpdateThrottle = setTimeout(() => {
        try {
            // Update distance display
            if (typeof updateDistanceBox === 'function') {
                updateDistanceBox();
            }
            
            // Update accuracy indicator
            if (typeof updateAccuracyIndicator === 'function') {
                updateAccuracyIndicator(accuracy);
            }
            
            // Update speed display if it exists
            if (typeof updateSpeedDisplay === 'function') {
                updateSpeedDisplay(speedMPS);
            }
            
            // Update any location-based filters or search results
            if (typeof refreshLocationBasedContent === 'function') {
                refreshLocationBasedContent();
            }
            
        } catch (error) {
            console.warn('Error updating location-dependent components:', error);
        } finally {
            window.uiUpdateThrottle = null;
        }
    }, 100); // Update UI every 100ms max
}

/**
 * Trigger location-based game events
 */
function triggerLocationBasedEvents(position) {
    try {
        // Check for proximity to game locations
        if (typeof checkProximityAlerts === 'function') {
            checkProximityAlerts(position);
        }
        
        // Update geofencing
        if (typeof updateGeofences === 'function') {
            updateGeofences(position);
        }
        
        // Trigger any location-based achievements
        if (typeof checkLocationAchievements === 'function') {
            checkLocationAchievements(position);
        }
        
    } catch (error) {
        console.warn('Error triggering location-based events:', error);
    }
}

/**
 * Emergency fallback for position recovery
 */
function recoverFromPositionLoss() {
    if (window.lastValidPosition) {
        console.log('üîÑ Recovering from position loss using last valid position');
        updateUserLocation({
            coords: {
                latitude: window.lastValidPosition.lat,
                longitude: window.lastValidPosition.lng,
                accuracy: window.lastValidPosition.accuracy || 50,
                speed: 0
            },
            timestamp: Date.now()
        }, true); // Force update
    }
}

// Export recovery function for external use
if (typeof window !== 'undefined') {
    window.recoverFromPositionLoss = recoverFromPositionLoss;
}

function handleVisibilityChange() {
    if (document.hidden) {
        lastHiddenTime = Date.now();
        // Store current position from perfect tracker instead of marker directly
        lastKnownPosition = perfectLocationTracker.currentPosition ? 
            { lat: perfectLocationTracker.currentPosition.lat, lng: perfectLocationTracker.currentPosition.lng } :
            (userMarker ? userMarker.getLatLng() : null);
    } else {
        const hiddenDuration = Date.now() - lastHiddenTime;
        if (hiddenDuration > CONFIG.BACKGROUND_THRESHOLD) {
            updateLocationAfterBackground();
        } else {
            // Just refresh the map size
            map.invalidateSize();
        }
    }
    resetInactivityTimer();
}

function updateLocationAfterBackground() {
    if (!("geolocation" in navigator)) {
        console.warn("Geolocation is not available");
        return;
    }
    
    console.log("üîÑ Starting background location update...");
    
    // Optimized options for different scenarios
    const quickOptions = {
        enableHighAccuracy: false,
        timeout: 5000,
        maximumAge: 15000,  // Fresher data
    };
    
    const accurateOptions = {
        enableHighAccuracy: true,
        timeout: 12000,     // Reduced timeout
        maximumAge: 5000,   // Very fresh data
    };
    
    const fallbackOptions = {
        enableHighAccuracy: false,
        timeout: 20000,
        maximumAge: 30000,  // More restrictive
    };

    let samplingComplete = false;

    const processPosition = (position, isImprovement = false) => {
        if (!position?.coords) {
            console.warn("Invalid position object in background update");
            return;
        }
        
        const { latitude, longitude, accuracy } = position.coords;
        if (isNaN(latitude) || isNaN(longitude)) {
            console.warn("Invalid coordinates in background update:", { latitude, longitude });
            return;
        }
        
        console.log(`üìç Background position - Lat: ${latitude.toFixed(6)}, Lng: ${longitude.toFixed(6)}, Accuracy: ${accuracy}m`);
        
        try {
            // CLEAN RESET - but let perfect tracker handle everything
            if (!isImprovement) {
                console.log("üßπ Resetting location state for fresh start");
                
                // Reset old tracking variables
                if (typeof lastPosition !== 'undefined') lastPosition = null;
                if (typeof positionBuffer !== 'undefined') positionBuffer = [];
                if (typeof lastVelocity !== 'undefined') lastVelocity = { lat: 0, lng: 0 };
                if (typeof isStationary !== 'undefined') isStationary = false;
                if (typeof stationaryStartTime !== 'undefined') stationaryStartTime = null;
                if (typeof stationaryCount !== 'undefined') stationaryCount = 0;
                
                // Cancel any existing animations
                if (typeof cancelAllLocationAnimations === 'function') {
                    cancelAllLocationAnimations();
                }
                
                // Reset perfect tracker
                perfectLocationTracker.reset();
                
                // Reset enhanced Kalman filter if it exists
                if (typeof enhancedKalmanFilter !== 'undefined' && enhancedKalmanFilter?.reset) {
                    enhancedKalmanFilter.reset({
                        lat: latitude,
                        lng: longitude,
                        accuracy: accuracy,
                        heading: position.coords.heading || null,
                        timestamp: Date.now(),
                    });
                }
            }
            
            // **SINGLE CALL** to perfect location tracker with force update
            const success = updateUserLocation(position, true);
            
            if (success) {
                // Force map centering after background return
                setTimeout(() => {
                    if (map && perfectLocationTracker.currentPosition) {
                        const pos = perfectLocationTracker.currentPosition;
                        map.setView([pos.lat, pos.lng], map.getZoom(), { animate: false });
                        followUser = true;
                        console.log("üéØ Map force-centered after background");
                    }
                }, 100);
                
                // Refresh map display
                setTimeout(() => {
                    if (map?.invalidateSize) {
                        map.invalidateSize();
                    }
                }, 200);
                
                console.log("‚úÖ Background location update completed successfully");
            }
            
        } catch (error) {
            console.error("‚ùå Error in background location update:", error);
            
            // Emergency fallback - try to recover
            setTimeout(() => {
                if (typeof recoverFromPositionLoss === 'function') {
                    recoverFromPositionLoss();
                }
            }, 500);
        }
    };

    const handleSuccess = (position, stage = "unknown") => {
        console.log(`üì° Background update (${stage}) received:`, {
            lat: position.coords.latitude.toFixed(6),
            lng: position.coords.longitude.toFixed(6),
            accuracy: position.coords.accuracy
        });
        
        const accuracy = position.coords.accuracy;
        
        // Validate accuracy thresholds
        if (accuracy > 100) {
            console.warn(`‚ö†Ô∏è Very poor accuracy (${stage}): ${accuracy}m - position may be unreliable`);
        } else if (accuracy > 50) {
            console.warn(`‚ö†Ô∏è Low accuracy (${stage}): ${accuracy}m - may need improvement`);
        }
        
        // Process the position through perfect tracker
        processPosition(position);
        
        // Smart follow-up for accuracy improvement
        if (accuracy > 25 && !samplingComplete && stage !== "improvement") {
            console.log("üéØ Requesting accuracy improvement follow-up");
            samplingComplete = true;
            
            setTimeout(() => {
                navigator.geolocation.getCurrentPosition(
                    (betterPosition) => {
                        const betterAccuracy = betterPosition.coords.accuracy;
                        console.log(`üìä Follow-up accuracy: ${betterAccuracy}m vs original ${accuracy}m`);
                        
                        // Use better position if significantly more accurate
                        if (betterAccuracy < accuracy * 0.7) {
                            console.log("‚ú® Got significantly better position, updating");
                            processPosition(betterPosition, true);
                        } else {
                            console.log("üìç Follow-up not significantly better, keeping original");
                        }
                    },
                    (error) => {
                        console.log("‚ö†Ô∏è High-accuracy follow-up failed:", error.message);
                    },
                    { 
                        enableHighAccuracy: true, 
                        timeout: 8000, 
                        maximumAge: 0
                    }
                );
            }, 500); // Small delay to avoid overwhelming GPS
        }
    };
    
    const handleError = (error, stage) => {
        console.error(`‚ùå Location error during ${stage} attempt:`, error.message);
        
        switch (error.code) {
            case 1: // PERMISSION_DENIED
                console.warn("üö´ User denied geolocation access");
                break;
                
            case 2: // POSITION_UNAVAILABLE
                if (stage === "quick") {
                    console.log("üîÑ Quick position unavailable, trying accurate...");
                    navigator.geolocation.getCurrentPosition(
                        (pos) => handleSuccess(pos, "accurate"),
                        (err) => handleError(err, "accurate"),
                        accurateOptions
                    );
                } else if (stage === "accurate") {
                    console.log("üîÑ Accurate position unavailable, trying fallback...");
                    navigator.geolocation.getCurrentPosition(
                        (pos) => handleSuccess(pos, "fallback"),
                        (err) => handleError(err, "fallback"),
                        fallbackOptions
                    );
                } else {
                    console.warn("‚ùå All position attempts failed - location unavailable");
                    // Try to recover with last known position
                    if (typeof recoverFromPositionLoss === 'function') {
                        recoverFromPositionLoss();
                    }
                }
                break;
                
            case 3: // TIMEOUT
                if (stage === "quick") {
                    console.log("‚è±Ô∏è Quick position timed out, trying accurate...");
                    navigator.geolocation.getCurrentPosition(
                        (pos) => handleSuccess(pos, "accurate"),
                        (err) => handleError(err, "accurate"),
                        accurateOptions
                    );
                } else if (stage === "accurate") {
                    console.log("‚è±Ô∏è Accurate position timed out, trying fallback...");
                    navigator.geolocation.getCurrentPosition(
                        (pos) => handleSuccess(pos, "fallback"),
                        (err) => handleError(err, "fallback"),
                        fallbackOptions
                    );
                } else {
                    console.warn("‚è±Ô∏è All position attempts timed out");
                    if (typeof recoverFromPositionLoss === 'function') {
                        recoverFromPositionLoss();
                    }
                }
                break;
                
            default:
                if (stage !== "fallback") {
                    console.log("üîÑ Unknown error, trying fallback...");
                    navigator.geolocation.getCurrentPosition(
                        (pos) => handleSuccess(pos, "fallback"),
                        (err) => handleError(err, "fallback"),
                        fallbackOptions
                    );
                } else {
                    console.warn("‚ùå All attempts failed:", error.message);
                    if (typeof recoverFromPositionLoss === 'function') {
                        recoverFromPositionLoss();
                    }
                }
        }
    };

    // Start the cascade with quick attempt
    navigator.geolocation.getCurrentPosition(
        (pos) => handleSuccess(pos, "quick"),
        (error) => handleError(error, "quick"),
        quickOptions
    );
}

function updatePositionBuffer(position) {
    // Add new position to buffer
    positionBuffer.push({
        lat: position.lat,
        lng: position.lng,
        accuracy: position.accuracy,
        timestamp: position.timestamp,
        heading: position.heading,
        speedMPS: position.speedMPS
    });

    // Remove old positions if buffer exceeds maxSize
    while (positionBuffer.length > CONFIG.MAX_BUFFER_SIZE) {
        positionBuffer.shift();
    }
}

function calculateWeightedPosition(positions, smoothingFactor = 0.8, defaultAccuracy = 20) {
    // Input validation - return null instead of throwing
    if (!Array.isArray(positions) || positions.length === 0) {
        return null;
    }
    
    // Clamp smoothing factor instead of throwing
    smoothingFactor = Math.max(0.1, Math.min(1.0, smoothingFactor || 0.8));
    
    // Filter out invalid positions
    const validPositions = positions.filter(pos => 
        pos && 
        typeof pos.lat === 'number' && !isNaN(pos.lat) &&
        typeof pos.lng === 'number' && !isNaN(pos.lng)
    );
    
    if (validPositions.length === 0) {
        return null;
    }
    
    // Calculate weighted position
    let sumLat = 0, sumLng = 0, totalWeight = 0;
    
    for (let i = 0; i < validPositions.length; i++) {
        const position = validPositions[i];
        const weight = Math.pow(smoothingFactor, validPositions.length - i - 1);
        
        sumLat += position.lat * weight;
        sumLng += position.lng * weight;
        totalWeight += weight;
    }
    
    const lastPosition = validPositions[validPositions.length - 1];
    
    return {
        lat: sumLat / totalWeight,
        lng: sumLng / totalWeight,
        accuracy: lastPosition.accuracy || defaultAccuracy,
        timestamp: lastPosition.timestamp,
        heading: lastPosition.heading,
        speedMPS: lastPosition.speedMPS
    };
}

function checkProximityForZoom() {
    // Add debounce to prevent rapid zoom changes
    const now = Date.now();
    if (!window.lastProximityCheck) window.lastProximityCheck = 0;
    if (now - window.lastProximityCheck < 200) return;
    window.lastProximityCheck = now;
    
    // Skip if missing data
    if (!userMarker || !gameLocations?.length) return;
    
    // Get valid user position
    const userPos = userMarker.getLatLng();
    if (!userPos || isNaN(userPos.lat)) return;
    
    // Find closest location
    let closestDistance = Infinity;
    for (const loc of gameLocations) {
        if (!loc?.lat) continue;
        const dist = calculateDistance(userPos, loc);
        if (dist < closestDistance) closestDistance = dist;
    }
    
    // Convert to feet
    const distanceFeet = closestDistance * 3.28084;
    
    // Apply hysteresis thresholds
    const ZOOM_IN_THRESHOLD = CONFIG.PROXIMITY_THRESHOLD || 50;        // 50 feet
    const ZOOM_OUT_THRESHOLD = (CONFIG.PROXIMITY_THRESHOLD || 50) * 1.3; // 65 feet
    
    const currentTime = Date.now();
    
    if (typeof window.zoomedInState === 'undefined') {
        window.zoomedInState = false;
    }
    
    const previousState = window.zoomedInState;
    
    if (!window.zoomedInState && distanceFeet <= ZOOM_IN_THRESHOLD) {
        if (currentTime - lastZoomChangeTime >= CONFIG.ZOOM_COOLDOWN) {
            window.zoomedInState = true;
            isNearLocation = true;
            lastZoomChangeTime = currentTime;
            
            window.blockSpeedZoom = true;
            setTimeout(() => window.blockSpeedZoom = false, 5000);
            
            // Actually zoom to 19
            if (!isMapInteracting) {
                map.flyTo(userPos, 19, {
                    duration: 1.2,
                    easeLinearity: 0.25
                });
            }
        }
    } 
    else if (window.zoomedInState && distanceFeet >= ZOOM_OUT_THRESHOLD) {
        if (currentTime - lastZoomChangeTime >= CONFIG.ZOOM_COOLDOWN) {
            window.zoomedInState = false;
            isNearLocation = false;
            lastZoomChangeTime = currentTime;
            
            window.blockSpeedZoom = true;
            setTimeout(() => window.blockSpeedZoom = false, 5000);
            
            // Actually zoom to 17
            if (!isMapInteracting) {
                map.flyTo(userPos, 17, {
                    duration: 1.2,
                    easeLinearity: 0.25
                });
            }
        }
    }
    
    if (previousState !== window.zoomedInState) {
        window.lastProximityZoomTime = currentTime;
    }
}

function getSpeedBasedZoom(speedMPS, distanceToClosestPOI) {
   // Skip speed-based zoom if we're in a proximity zone or recently changed by proximity
   if (window.blockSpeedZoom || isNearLocation) {
       return -1; // Return a special value to indicate no speed-based zoom should happen
   }
   
   // Initialize state tracking with additional jitter handling properties
   if (typeof window.speedTrackingState === 'undefined') {
       window.speedTrackingState = {
           lowSpeedStartTime: null,
           isInTransit: false,
           lastSignificantMove: Date.now(),
           destinationArrivalTime: null,
           previousZoom: null,
           // Properties for jitter and jump handling
           speedBuffer: [],
           lastSpeedMPH: 0,
           stationaryConfidence: 0,
           lastZoomUpdate: Date.now(),
           suddenJumpDetected: false,
           // Interpolated zoom
           currentInterpolatedZoom: 17,
           // Tier tracking for hysteresis
           currentTier: 'exploration',
           lastTierChange: Date.now(),
           // Proximity override tracking
           proximityOverride: false
       };
   }
   
   const state = window.speedTrackingState;
   const speedMPH = speedMPS * 2.23694;
   const now = Date.now();
   
   // Constants
   const WALKING_THRESHOLD = 3.0;  // mph
   const SIGNIFICANT_TRAVEL_THRESHOLD = 10.0; // mph
   const TEMPORARY_STOP_MAX = 90000; // 90 seconds
   const ARRIVAL_DELAY = 20000; // 20 seconds
   const SPEED_BUFFER_SIZE = 5;
   const MAX_SPEED_JUMP = 20; // mph
   const STATIONARY_CONFIDENCE_MAX = 10;
   const ZOOM_INTERPOLATION_SPEED = 0.3;
   const ZOOM_COOLDOWN = 3000; // 3 seconds between tier changes
   const PROXIMITY_THRESHOLD = 50; // feet
   
   // Zoom levels
   const OVERVIEW_ZOOM = 16;    // For speeds > 10 mph
   const EXPLORATION_ZOOM = 17; // For 3-10 mph and stationary
   const DETAIL_ZOOM = 19;      // Within proximity of POI
   
   // Add current speed to buffer for jitter analysis
   state.speedBuffer.push(speedMPH);
   if (state.speedBuffer.length > SPEED_BUFFER_SIZE) {
       state.speedBuffer.shift();
   }
   
   // Calculate median speed from buffer to filter out jitter
   const sortedSpeeds = [...state.speedBuffer].sort((a, b) => a - b);
   const medianSpeed = sortedSpeeds[Math.floor(sortedSpeeds.length / 2)];
   
   // Detect sudden GPS jumps (unrealistic speed changes)
   const speedDelta = Math.abs(medianSpeed - state.lastSpeedMPH);
   if (speedDelta > MAX_SPEED_JUMP) {
       console.debug("Sudden speed jump detected, ignoring:", 
                    {current: medianSpeed, previous: state.lastSpeedMPH});
       state.suddenJumpDetected = true;
       return state.currentInterpolatedZoom;
   } else {
       state.suddenJumpDetected = false;
   }
   
   state.lastSpeedMPH = medianSpeed;
   
   // Enhanced stationary detection with confidence level
   if (medianSpeed < 1.0) {
       state.stationaryConfidence = Math.min(STATIONARY_CONFIDENCE_MAX, 
                                          state.stationaryConfidence + 1);
   } else if (medianSpeed > WALKING_THRESHOLD) {
       state.stationaryConfidence = 0;
   } else {
       state.stationaryConfidence = Math.max(0, state.stationaryConfidence - 0.5);
   }
   
   // Transit detection
   if (medianSpeed >= SIGNIFICANT_TRAVEL_THRESHOLD && !state.suddenJumpDetected) {
       state.isInTransit = true;
       state.lastSignificantMove = now;
       state.destinationArrivalTime = null;
   }
   
   // Determine target zoom level and tier
   let targetZoom;
   let targetTier;
   
   // Check proximity override first
   if (distanceToClosestPOI && distanceToClosestPOI <= PROXIMITY_THRESHOLD) {
       targetTier = 'detail';
       targetZoom = DETAIL_ZOOM;
       state.proximityOverride = true;
   } else {
       state.proximityOverride = false;
       
       // Handle low speed/walking/stopping with improved logic
       if (medianSpeed <= WALKING_THRESHOLD || state.stationaryConfidence > 3) {
           if (!state.lowSpeedStartTime) {
               state.lowSpeedStartTime = now;
           }
           
           const lowSpeedDuration = now - state.lowSpeedStartTime;
           
           // Complex arrival detection logic
           if (state.isInTransit && lowSpeedDuration >= ARRIVAL_DELAY) {
               if (!state.destinationArrivalTime) {
                   state.destinationArrivalTime = now;
               }
               
               if (now - state.destinationArrivalTime >= 5000) {
                   state.isInTransit = false;
                   targetTier = 'exploration';
                   targetZoom = EXPLORATION_ZOOM;
               } else {
                   // Keep previous zoom during arrival confirmation
                   targetZoom = state.previousZoom || EXPLORATION_ZOOM;
                   targetTier = state.currentTier;
               }
           } else if (state.isInTransit && now - state.lastSignificantMove < TEMPORARY_STOP_MAX) {
               // Temporary stop - maintain previous zoom
               targetZoom = state.previousZoom || EXPLORATION_ZOOM;
               targetTier = state.currentTier;
           } else {
               // Walking or truly stationary
               targetTier = 'exploration';
               targetZoom = EXPLORATION_ZOOM;
           }
       } else {
           // Reset low speed tracking
           state.lowSpeedStartTime = null;
           state.destinationArrivalTime = null;
           
           // Three-tier speed-based zoom system
           if (medianSpeed > SIGNIFICANT_TRAVEL_THRESHOLD) {
               targetTier = 'overview';
               targetZoom = OVERVIEW_ZOOM;
           } else if (medianSpeed > WALKING_THRESHOLD) {
               targetTier = 'exploration';
               targetZoom = EXPLORATION_ZOOM;
           } else {
               targetTier = 'exploration';
               targetZoom = EXPLORATION_ZOOM;
           }
       }
   }
   
   // Apply hysteresis - only change tier if we've been in new tier long enough
   if (targetTier !== state.currentTier && !state.proximityOverride) {
       if (now - state.lastTierChange > ZOOM_COOLDOWN) {
           console.debug(`Zoom tier changed from ${state.currentTier} to ${targetTier}`);
           state.currentTier = targetTier;
           state.lastTierChange = now;
           
           // Optional: Announce zoom changes for accessibility
           if (typeof announceToScreenReader === 'function') {
               announceToScreenReader(`Map zoom changed to ${targetTier} view`);
           }
       } else {
           // Keep current zoom during cooldown period
           targetZoom = state.currentInterpolatedZoom;
       }
   } else if (state.proximityOverride) {
       // Proximity overrides always apply immediately
       state.currentTier = targetTier;
       state.lastTierChange = now;
   }
   
   // Store previous zoom for future reference
   state.previousZoom = targetZoom;
   
   // Apply smooth interpolation towards target zoom
   if (Math.abs(state.currentInterpolatedZoom - targetZoom) > 0.05) {
       state.currentInterpolatedZoom += (targetZoom - state.currentInterpolatedZoom) * ZOOM_INTERPOLATION_SPEED;
   } else {
       state.currentInterpolatedZoom = targetZoom;
   }
   
   // Update last zoom update time
   state.lastZoomUpdate = now;
   
   return state.currentInterpolatedZoom;
}

// Exponential smoothing with predictive smoothing and micro-jitter elimination
function applyExponentialSmoothing(newPosition, lastPosition, baseAlpha = 0.25) {
    // Validate inputs with early return
    if (!isValidPosition(newPosition) || !isValidPosition(lastPosition)) {
        return newPosition;
    }
    
    // Initialize smoothing state
    if (!lastSmoothedPosition) {
        lastSmoothedPosition = { ...lastPosition };
        velocityHistory = velocityHistory || [];
        jitterBuffer = jitterBuffer || [];
    }
    
    const distance = calculateDistance(newPosition, lastSmoothedPosition);
    const timeDelta = Math.max(1, newPosition.timestamp - lastPosition.timestamp);
    
    // Micro-jitter detection and elimination
    jitterBuffer.push(distance);
    if (jitterBuffer.length > 5) jitterBuffer.shift();
    
    const avgJitter = jitterBuffer.reduce((a, b) => a + b, 0) / jitterBuffer.length;
    const isJittering = distance < CONFIG.MIN_DISTANCE_THRESHOLD && 
                       jitterBuffer.length >= 3 && 
                       avgJitter < CONFIG.MIN_DISTANCE_THRESHOLD * 0.5;
    
    // Advanced stationary detection with hysteresis
    const stationaryThreshold = CONFIG.MIN_DISTANCE_THRESHOLD * (isJittering ? 0.3 : 0.7);
    
    if (distance < stationaryThreshold) {
        stationaryCount = Math.min(stationaryCount + 2, CONFIG.STATIONARY_THRESHOLD * 3);
    } else if (distance > stationaryThreshold * 2) {
        stationaryCount = Math.max(stationaryCount - 3, 0);
    } else {
        stationaryCount = Math.max(stationaryCount - 1, 0);
    }
    
    // Predictive velocity-based smoothing
    const currentVelocity = distance / (timeDelta / 1000);
    velocityHistory.push(currentVelocity);
    if (velocityHistory.length > 8) velocityHistory.shift();
    
    const avgVelocity = velocityHistory.reduce((a, b) => a + b, 0) / velocityHistory.length;
    const velocityStability = 1 - Math.min(1, Math.abs(currentVelocity - avgVelocity) / Math.max(0.1, avgVelocity));
    
    // Ultra-adaptive alpha calculation
    let alpha = baseAlpha;
    
    // Stationary state with enhanced micro-movement handling
    if (stationaryCount >= CONFIG.STATIONARY_THRESHOLD) {
        alpha = isJittering ? CONFIG.MIN_ALPHA * 0.1 : CONFIG.MIN_ALPHA * 0.3;
    } else {
        // Progressive alpha reduction approaching stationary state
        const stationaryFactor = Math.pow(stationaryCount / (CONFIG.STATIONARY_THRESHOLD * 2), 1.5);
        alpha = CONFIG.MAX_ALPHA * (1 - stationaryFactor * 0.85) + CONFIG.MIN_ALPHA * stationaryFactor;
    }
    
    // Multi-factor accuracy weighting
    const accuracyRatio = Math.max(0, Math.min(1, 1 - (newPosition.accuracy / CONFIG.MAX_ACCEPTABLE_ACCURACY)));
    const accuracyWeight = 0.3 + 0.7 * Math.pow(accuracyRatio, 0.7); // Smoother curve
    alpha *= accuracyWeight;
    
    // Enhanced speed-responsive smoothing
    const reportedSpeed = newPosition.speedMPS || 0;
    const calculatedSpeed = Math.max(reportedSpeed, currentVelocity);
    
    if (calculatedSpeed < 0.2) { // Ultra-low speed
        alpha *= isJittering ? 0.1 : 0.25;
    } else if (calculatedSpeed < 1.0) { // Walking speed
        alpha *= 0.4 + 0.3 * velocityStability;
    } else if (calculatedSpeed > 15) { // High speed - prioritize responsiveness
        alpha = Math.min(0.7, alpha * (1.2 + Math.min(0.5, calculatedSpeed / 30)));
    }
    
    // Temporal smoothing with frame-rate adaptation
    const idealUpdateInterval = 1000; // 1 second
    const temporalFactor = Math.min(2, Math.max(0.3, idealUpdateInterval / timeDelta));
    
    if (timeDelta < 500) { // High frequency updates
        alpha *= 0.4 * temporalFactor;
    } else if (timeDelta > 8000) { // Delayed updates
        alpha = Math.min(0.9, alpha * 2.5);
    }
    
    // Precision-optimized position calculation
    const smoothedPosition = {
        lat: lastSmoothedPosition.lat + alpha * (newPosition.lat - lastSmoothedPosition.lat),
        lng: lastSmoothedPosition.lng + alpha * (newPosition.lng - lastSmoothedPosition.lng),
        accuracy: Math.min(newPosition.accuracy, lastSmoothedPosition.accuracy * 0.95 + newPosition.accuracy * 0.05),
        heading: newPosition.heading,
        timestamp: newPosition.timestamp,
        speedMPS: newPosition.speedMPS ? 
                  (lastSmoothedPosition.speedMPS || 0) * 0.75 + newPosition.speedMPS * 0.25 : 
                  newPosition.speedMPS
    };
    
    // Intelligent heading smoothing with wrap-around handling
    if (newPosition.heading !== undefined && lastSmoothedPosition.heading !== undefined) {
        let headingDiff = newPosition.heading - lastSmoothedPosition.heading;
        
        // Handle heading wrap-around (0¬∞/360¬∞)
        if (headingDiff > 180) headingDiff -= 360;
        if (headingDiff < -180) headingDiff += 360;
        
        const headingAlpha = stationaryCount >= CONFIG.STATIONARY_THRESHOLD ? 
                           alpha * 0.15 : 
                           alpha * (0.3 + 0.4 * velocityStability);
        
        smoothedPosition.heading = (lastSmoothedPosition.heading + headingAlpha * headingDiff + 360) % 360;
    }
    
    // Ultra-fine stabilization for minimal movements
    if (isJittering || (distance < CONFIG.MIN_DISTANCE_THRESHOLD * 0.4 && stationaryCount > 0)) {
        const stabilizationFactor = Math.max(0.01, 0.05 - (stationaryCount * 0.005));
        smoothedPosition.lat = lastSmoothedPosition.lat * (1 - stabilizationFactor) + smoothedPosition.lat * stabilizationFactor;
        smoothedPosition.lng = lastSmoothedPosition.lng * (1 - stabilizationFactor) + smoothedPosition.lng * stabilizationFactor;
    }
    
    // Optional sub-pixel positioning for ultra-smooth animation
    if (CONFIG.ENABLE_SUBPIXEL_SMOOTHING) {
        const pixelDistance = distance * CONFIG.METERS_TO_PIXELS_RATIO;
        if (pixelDistance < 0.5 && stationaryCount > CONFIG.STATIONARY_THRESHOLD / 2) {
            // Apply sub-pixel smoothing to eliminate micro-movements in display
            smoothedPosition._subPixelOffset = {
                lat: (smoothedPosition.lat - lastSmoothedPosition.lat) * 0.1,
                lng: (smoothedPosition.lng - lastSmoothedPosition.lng) * 0.1
            };
        }
    }
    
    // Update state
    lastSmoothedPosition = smoothedPosition;
    
    // Performance monitoring (optional)
    if (CONFIG.DEBUG_PERFORMANCE) {
        smoothedPosition._debug = {
            alpha: alpha.toFixed(4),
            distance: distance.toFixed(2),
            stationaryCount,
            isJittering,
            velocityStability: velocityStability.toFixed(3)
        };
    }
    
    return smoothedPosition;
}

// COMPANION: Suggested CONFIG additions
const ENHANCED_CONFIG = {
    ...CONFIG,
    ENABLE_SUBPIXEL_SMOOTHING: true,
    METERS_TO_PIXELS_RATIO: 100000, // Adjust based on your zoom levels
    DEBUG_PERFORMANCE: false,
    JITTER_SENSITIVITY: 0.5,
    VELOCITY_HISTORY_SIZE: 8
};

// Enhanced velocity filter with acceleration modeling
function calculateVelocityFilter(newPos, lastPos) {
    if (!lastVelocity) {
        lastVelocity = { lat: 0, lng: 0 };
    }

    if (!newPos || !lastPos || 
        typeof newPos.lat !== 'number' || typeof newPos.lng !== 'number' || 
        typeof lastPos.lat !== 'number' || typeof lastPos.lng !== 'number') {
        return newPos;
    }

    const dt = (newPos.timestamp - lastPos.timestamp) / 1000;
    if (dt <= 0 || dt > 10) {
        return newPos;
    }

    const currentVelocity = {
        lat: (newPos.lat - lastPos.lat) / dt,
        lng: (newPos.lng - lastPos.lng) / dt
    };

    // Calculate magnitude of velocity change
    const velocityChangeMagnitude = Math.sqrt(
        Math.pow(currentVelocity.lat - lastVelocity.lat, 2) +
        Math.pow(currentVelocity.lng - lastVelocity.lng, 2)
    );
    
    // Adaptive velocity decay based on change magnitude
    const adaptiveDecay = velocityChangeMagnitude > 0.0001 ? 
        Math.max(0.5, Math.min(0.9, CONFIG.VELOCITY_DECAY * (1 - velocityChangeMagnitude * 1000))) : 
        CONFIG.VELOCITY_DECAY;

    lastVelocity = {
        lat: lastVelocity.lat * adaptiveDecay + currentVelocity.lat * (1 - adaptiveDecay),
        lng: lastVelocity.lng * adaptiveDecay + currentVelocity.lng * (1 - adaptiveDecay)
    };

    // Apply velocity prediction with acceleration modeling
    const predictedPosition = {
        lat: lastPos.lat + lastVelocity.lat * dt,
        lng: lastPos.lng + lastVelocity.lng * dt,
        accuracy: newPos.accuracy,
        timestamp: newPos.timestamp,
        heading: newPos.heading,
        speedMPS: newPos.speedMPS
    };
    
    // Blend prediction with actual position based on speed
    const blendFactor = newPos.speedMPS ? Math.min(0.7, newPos.speedMPS * 0.05) : 0.3;
    
    return {
        lat: predictedPosition.lat * blendFactor + newPos.lat * (1 - blendFactor),
        lng: predictedPosition.lng * blendFactor + newPos.lng * (1 - blendFactor),
        accuracy: newPos.accuracy,
        timestamp: newPos.timestamp,
        heading: newPos.heading,
        speedMPS: newPos.speedMPS
    };
}

// New helper function for enhanced velocity prediction with acceleration
function calculateEnhancedVelocityFilter(currentPosition, lastPosition, timeDelta, speed) {
    if (!timeDelta || timeDelta <= 0) {
        return currentPosition;
    }
    
    // Calculate current velocity components
    const currentVelocity = {
        lat: (currentPosition.lat - lastPosition.lat) / timeDelta,
        lng: (currentPosition.lng - lastPosition.lng) / timeDelta
    };
    
    // If no last velocity, initialize it
    if (!lastVelocity) {
        lastVelocity = currentVelocity;
    }
    
    // Calculate acceleration (change in velocity)
    const acceleration = {
        lat: (currentVelocity.lat - lastVelocity.lat) / timeDelta,
        lng: (currentVelocity.lng - lastVelocity.lng) / timeDelta
    };
    
    // Apply acceleration damping at higher speeds to prevent oscillation
    const accelerationDamping = Math.min(1, Math.max(0.2, 1 - (speed / 20)));
    const dampedAcceleration = {
        lat: acceleration.lat * accelerationDamping,
        lng: acceleration.lng * accelerationDamping
    };
    
    // Store current velocity for next update
    lastVelocity = currentVelocity;
    
    // Calculate predicted position using velocity and damped acceleration
    const predictionTimeFactor = Math.min(0.5, Math.max(0.1, timeDelta)); // Limit prediction time
    
    const predictedPosition = {
        lat: currentPosition.lat + (currentVelocity.lat * predictionTimeFactor) + (0.5 * dampedAcceleration.lat * predictionTimeFactor * predictionTimeFactor),
        lng: currentPosition.lng + (currentVelocity.lng * predictionTimeFactor) + (0.5 * dampedAcceleration.lng * predictionTimeFactor * predictionTimeFactor),
        accuracy: currentPosition.accuracy,
        heading: currentPosition.heading,
        timestamp: currentPosition.timestamp,
        speedMPS: speed
    };
    
    return predictedPosition;
}

function checkStationaryState(newPosition) {
    if (!lastPosition) return;

    const distance = calculateDistance(lastPosition, newPosition);

    // --- movement detected ---
    if (distance >= CONFIG.MICRO_MOVEMENT_THRESHOLD) {
        isStationary = false;
        stationaryStartTime = null;
        console.debug('Movement detected, resuming normal updates');
    }
    // --- became stationary ---
    else if (!isStationary) {
        isStationary = true;
        stationaryStartTime = Date.now();
    }

    // Always clear the old timer
    clearTimeout(stationaryCheckTimeout);
    stationaryCheckTimeout = null;

    // Re-arm if still stationary
    if (isStationary) {
        stationaryCheckTimeout = setTimeout(
            () => checkStationaryState(newPosition),
            CONFIG.STATIONARY_CHECK_INTERVAL
        );
    }
}

function calculateFinalPosition() {
    if (!positionBuffer?.length) return null;
    return positionBuffer.length === 1
        ? positionBuffer[0]
        : calculateWeightedPosition(positionBuffer);
}

// Optimize Map Rendering with Throttled Updates
function throttle(func, limit) {
  let inThrottle;
  return function() {
    const args = arguments;
    const context = this;
    if (!inThrottle) {
      func.apply(context, args);
      inThrottle = true;
      setTimeout(() => inThrottle = false, limit);
    }
  };
}

// Calculate edge proximity for improved centering
function calculateEdgeProximity(map, point) {
    const bounds = map.getBounds();
    const latSpan = bounds.getNorth() - bounds.getSouth();
    const lngSpan = bounds.getEast() - bounds.getWest();
    
    return {
        north: Math.abs(point.lat - bounds.getNorth()) / latSpan,
        south: Math.abs(point.lat - bounds.getSouth()) / latSpan,
        east: Math.abs(point.lng - bounds.getEast()) / lngSpan,
        west: Math.abs(point.lng - bounds.getWest()) / lngSpan
    };
}

// Improved edge detection for better centering
function isMarkerNearEdge(map, marker, isStrict = false) {
    // Don't check edge proximity if user has manually positioned the map
    if (isMapInteracting) {
        return {
            isNearEdge: false,
            edges: { north: false, south: false, east: false, west: false },
            proximities: { north: 1, south: 1, east: 1, west: 1 }
        };
    }
    
    // Only proceed with edge checking when following user location (GPS movement)
    if (!followUser) {
        return {
            isNearEdge: false,
            edges: { north: false, south: false, east: false, west: false },
            proximities: { north: 1, south: 1, east: 1, west: 1 }
        };
    }
    
    const bounds = map.getBounds();
    const point = marker.getLatLng();
    const proximities = calculateEdgeProximity(map, point);
    
    const thresholdPercentage = isStrict ? 
        CONFIG.STRICT_EDGE_THRESHOLD_PERCENTAGE : 
        CONFIG.EDGE_THRESHOLD_PERCENTAGE;
    
    const edges = {
        north: proximities.north < thresholdPercentage,
        south: proximities.south < thresholdPercentage,
        east: proximities.east < thresholdPercentage,
        west: proximities.west < thresholdPercentage
    };
    
    return {
        isNearEdge: Object.values(edges).some(edge => edge),
        edges: edges,
        proximities: proximities
    };
}   
       
function calculateOptimalCenter(map, markerPosition, edgeInfo) {
    const bounds = map.getBounds();
    
    let latOffset = 0;
    let lngOffset = 0;
    
    if (edgeInfo.edges.north) latOffset = -1 * (bounds.getNorth() - bounds.getSouth()) * 0.2;
    if (edgeInfo.edges.south) latOffset = (bounds.getNorth() - bounds.getSouth()) * 0.2;
    if (edgeInfo.edges.east) lngOffset = -1 * (bounds.getEast() - bounds.getWest()) * 0.2;
    if (edgeInfo.edges.west) lngOffset = (bounds.getEast() - bounds.getWest()) * 0.2;
    
    return {
        lat: markerPosition.lat + latOffset,
        lng: markerPosition.lng + lngOffset
    };
}

function shouldRecenter(map, marker) {
    const now = Date.now();
    if (now - lastCenteringTime < CONFIG.MIN_RECENTER_INTERVAL) {
        return { needsRecenter: false };
    }
    
    const edgeInfo = isMarkerNearEdge(map, marker);
    const proximities = edgeInfo.proximities;
    
    const isCritical = Object.values(proximities).some(
        proximity => proximity < CONFIG.CRITICAL_EDGE_THRESHOLD_PERCENTAGE
    );
    
    if (isCritical) {
        lastCenteringTime = now;
        return {
            needsRecenter: true,
            isEmergency: true,
            edgeInfo: edgeInfo
        };
    }
    
    if (edgeInfo.isNearEdge) {
        lastCenteringTime = now;
        return {
            needsRecenter: true,
            isEmergency: false,
            edgeInfo: edgeInfo
        };
    }
    
    return {
        needsRecenter: false,
        isEmergency: false,
        edgeInfo: edgeInfo
    };
}

// Enhanced updateMarkerAndMap with intelligent zoom
function updateMarkerAndMap(position, speedMPS) {
    if (!position || typeof position.lat !== 'number' || typeof position.lng !== 'number') {
        console.warn("Invalid position for marker update");
        return;
    }
    
    // Update enhanced tracking state
    enhancedTrackingState.speedMPS = speedMPS || 0;
    enhancedTrackingState.isMoving = speedMPS > 0.5;
    
    // Update user marker styling (but NOT position - let locationTracker handle that)
    const markerElement = userMarker.getElement();
    if (markerElement) {
        const iconElement = markerElement.querySelector('.user-marker-icon');
        if (iconElement) {
            if (enhancedTrackingState.isMoving) {
                iconElement.classList.add('moving');
            } else {
                iconElement.classList.remove('moving');
            }
            
            if (position.heading !== null && position.heading !== undefined) {
                iconElement.classList.add('has-heading');
                iconElement.style.transform = `rotate(${position.heading}deg)`;
            } else {
                iconElement.classList.remove('has-heading');
                iconElement.style.transform = '';
            }
        }
    }
    
    // USE THE NEW LOCATION TRACKER for marker position updates
    updateUserLocation({
        coords: {
            latitude: position.lat,
            longitude: position.lng,
            accuracy: position.accuracy || 10,
            speed: speedMPS
        }
    });
    
    // Keep your intelligent zoom logic
    let closestDistance = Infinity;
    if (gameLocations && gameLocations.length > 0) {
        for (const loc of gameLocations) {
            if (loc && loc.lat && loc.lng) {
                const dist = calculateDistance(position, loc);
                if (dist < closestDistance) {
                    closestDistance = dist;
                }
            }
        }
    }
    
    const distanceFeet = closestDistance * 3.28084;
    const intelligentZoom = calculateIntelligentZoom(speedMPS, distanceFeet);
    const updateDelay = speedMPS > 10 ? 200 : (speedMPS > 5 ? 500 : 1000);
    
    // Keep your throttled map update but remove marker positioning
    if (!window.throttledMapUpdate) {
        window.throttledMapUpdate = throttle(function(pos, speed, targetZoom) {
            if (followUser && !isMapInteracting) {
                if (speedMPS > 1 || Date.now() - lastCenteringTime > 2000) {
                    const edgeInfo = isMarkerNearEdge(map, userMarker);
                    if (edgeInfo.isNearEdge) {
                        // Let the location tracker handle centering instead
                        locationTracker.centerMapOnPosition(position);
                        lastCenteringTime = Date.now();
                    }
                }
                
                if (targetZoom && Math.abs(map.getZoom() - targetZoom) > 0.5) {
                    map.setZoom(targetZoom, { animate: true, duration: 1 });
                }
            }
        }, updateDelay);
    }
    
    window.throttledMapUpdate(position, speedMPS, intelligentZoom);
    updateDistanceBox();
}

// Optimized function to ensure user marker stays visible on screen
function ensureMarkerVisible() {
    if (!userMarker || !map) return;
    
    const userPos = userMarker.getLatLng();
    if (!userPos || isNaN(userPos.lat) || isNaN(userPos.lng)) return;
    
    const bounds = map.getBounds();
    if (!bounds) return;
    
    // Check if marker is outside visible area or too close to edge
    const mapWidth = bounds.getEast() - bounds.getWest();
    const mapHeight = bounds.getNorth() - bounds.getSouth();
    
    const edgePaddingLng = mapWidth * 0.25; // 25% padding from edges
    const edgePaddingLat = mapHeight * 0.25;
    
    const isNearEdge = 
        userPos.lat > (bounds.getNorth() - edgePaddingLat) ||
        userPos.lat < (bounds.getSouth() + edgePaddingLat) ||
        userPos.lng > (bounds.getEast() - edgePaddingLng) ||
        userPos.lng < (bounds.getWest() + edgePaddingLng);
        
    const isOutsideBounds = !bounds.contains(userPos);
    
    if (isOutsideBounds || (isNearEdge && followUser)) {
        // Calculate optimal center point that keeps user visible with padding
        const now = Date.now();
        if (now - lastCenteringTime > CONFIG.MIN_CENTERING_INTERVAL) {
            map.panTo(userPos, {
                animate: true,
                duration: 0.5,
                easeLinearity: 0.5,
                noZoom: true
            });
            
            lastCenteringTime = now;
        }
    }
}

// Enhanced updateDistanceBox with proximity feedback and accessibility
function updateDistanceBox() {
    const distanceBox = cachedElements.distanceBox || document.getElementById('distanceBox');
    
    // Initial validation
    if (!userMarker || !gameLocations || gameLocations.length === 0) {
        distanceBox.innerText = 'Initializing...';
        return;
    }

    // Get user coordinates
    const userLatLng = userMarker.getLatLng();
    let userLat = userLatLng.lat;
    let userLng = userLatLng.lng;

    // Coordinate validation
    if (!isFinite(userLat) || !isFinite(userLng)) {
        console.warn('Invalid user coordinates:', userLat, userLng);
        distanceBox.innerText = 'Initializing...';
        return;
    }

    // Use map center if at origin
    if (userLat === 0 && userLng === 0) {
        const center = map.getCenter();
        userLat = center.lat;
        userLng = center.lng;
    }

    // Find closest location
    let closestDistance = Infinity;
    let closestLocation = null;
    const userPos = { lat: userLat, lng: userLng };

    for (const location of gameLocations) {
        if (!location || typeof location.lat !== 'number' || typeof location.lng !== 'number') {
            console.warn('Invalid location data:', location);
            continue;
        }

        const locationPos = { lat: location.lat, lng: location.lng };
        const distance = calculateDistance(userPos, locationPos);

        if (isFinite(distance) && distance < closestDistance) {
            closestDistance = distance;
            closestLocation = location;
        }
    }

    // Validate final distance calculation
    if (!isFinite(closestDistance) || closestDistance === Infinity) {
        console.warn('Invalid distance calculation:', closestDistance);
        distanceBox.innerText = 'Initializing...';
        return;
    }

    // Calculate and display distance
    const distanceFeet = Math.round(closestDistance * 3.28084);
    const distanceText = distanceFeet < 5280 
        ? `${distanceFeet.toLocaleString()} feet` 
        : `${(distanceFeet / 5280).toFixed(2)} miles`;
    
    distanceBox.innerText = `Closest Stop: ${distanceText}`;

    // ENTERPRISE ENHANCEMENT: Enhanced border color logic with dark blue default
    if (closestLocation && closestLocation.markerColor) {
        // Set border color based on proximity and marker color
        let borderStyle = '';
        if (distanceFeet <= 100) {
            borderStyle = `3px solid ${closestLocation.markerColor}`;
        } else if (distanceFeet <= 500) {
            borderStyle = `2px solid ${closestLocation.markerColor}`;
        } else {
            borderStyle = `1px solid ${closestLocation.markerColor}`;
        }
        distanceBox.style.border = borderStyle;
    } else {
        // Default dark blue border when no marker color available
        distanceBox.style.border = '3px solid var(--dark-blue)';
        distanceBox.style.color = 'var(--dark-blue)';
        distanceBox.style.background = 'white';
    }

    // Vibrate at 20 feet proximity (where supported)
    if (distanceFeet <= 20 && navigator.vibrate && closestLocation) {
        const locationId = closestLocation.id;
        const now = Date.now();
        const lastVibration = locationTriggerState.lastVibrations?.get(locationId) || 0;
        
        // Only vibrate once per location within 5 seconds to avoid spam
        if ((now - lastVibration) > 5000) {
            navigator.vibrate(200);
            if (!locationTriggerState.lastVibrations) {
                locationTriggerState.lastVibrations = new Map();
            }
            locationTriggerState.lastVibrations.set(locationId, now);
        }
    }

    // ENHANCED: Check for location triggering with improved cooldown enforcement
    if (distanceFeet <= CONFIG.DISTANCE_THRESHOLD && !isLocationHuntVisible && closestLocation) {
        // Check if user is approaching the location
        const userBearing = enhancedTrackingState.heading;
        const isApproaching = isApproachingLocation(userPos, userBearing, closestLocation);
        
        if (isApproaching) {
            // ENHANCED: Strict cooldown check with proper 2-minute enforcement
            const locationId = closestLocation.id;
            const now = Date.now();
            const lastTrigger = locationTriggerState.cooldowns.get(locationId);
            
            // Enforce strict 2-minute cooldown
            if (!lastTrigger || (now - lastTrigger) >= CONFIG.LOCATION_COOLDOWN) {
                // Start dwell timer if not already started
                if (!locationTriggerState.dwellTimers.has(locationId)) {
                    locationTriggerState.dwellTimers.set(locationId, now);
                } else {
                    // Check if dwell time has been met
                    const dwellStart = locationTriggerState.dwellTimers.get(locationId);
                    if ((now - dwellStart) >= CONFIG.DWELL_TIME) {
                        // Set cooldown BEFORE triggering to prevent double triggers
                        locationTriggerState.cooldowns.set(locationId, now);
                        locationTriggerState.dwellTimers.delete(locationId);
                        
                        // Trigger location
                        showLocationHunt(closestLocation);
                    }
                }
            } else {
                // Clear dwell timer if still in cooldown
                locationTriggerState.dwellTimers.delete(locationId);
            }
        } else {
            // Clear dwell timer if not approaching
            locationTriggerState.dwellTimers.delete(closestLocation.id);
        }
    } else {
        // Clear all dwell timers if too far away
        locationTriggerState.dwellTimers.clear();
    }
}

// ------------------------------------------------------------------
//  PERFECT High-Performance User Location Tracking System
// ------------------------------------------------------------------

class PerfectLocationTracker {
    constructor() {
        this.isInitialized = false;
        this.currentPosition = null;
        this.previousPosition = null;
        this.animationId = null;
        this.lastUpdateTime = 0;
        this.lastCenterTime = 0;
        this.isAnimating = false;
        this.pendingUpdate = null;
        this.mapReadyPromise = null;
        
        // High-performance configuration
        this.config = {
            ANIMATION_DURATION: 300,           // Faster animation
            MIN_UPDATE_INTERVAL: 50,           // High frequency updates
            MIN_CENTER_INTERVAL: 200,          // Frequent centering
            BOUNDARY_MARGIN: 0.25,             // Keep user more centered
            MIN_MOVEMENT_THRESHOLD: 0.05,      // Ultra-sensitive movement
            MAJOR_JUMP_THRESHOLD: 50,          // Jump detection
            SMOOTHING_FACTOR: 0.8,             // Less smoothing for responsiveness
            MAX_ANIMATION_DISTANCE: 100        // Max distance to animate vs jump
        };
        
        // Performance optimization
        this.frameThrottle = null;
        this.updateQueue = [];
        this.isProcessingQueue = false;
        
        // Initialize map readiness check
        this.initializeMapReadiness();
    }

    /**
     * Smart map readiness detection
     */
    initializeMapReadiness() {
        this.mapReadyPromise = new Promise((resolve) => {
            const checkMapReady = () => {
                if (window.map && window.map._loaded && window.userMarker) {
                    console.log('‚úÖ Map and marker ready');
                    resolve(true);
                } else {
                    // Check again in 50ms
                    setTimeout(checkMapReady, 50);
                }
            };
            checkMapReady();
        });
    }

    /**
     * Main update function - GUARANTEED to work
     */
    async updateLocation(position, forceUpdate = false) {
        // Wait for map to be ready
        await this.mapReadyPromise;
        
        // Validate inputs
        if (!this.validateInputs(position)) return false;
        
        const now = performance.now();
        
        // Throttle updates for performance
        if (!forceUpdate && now - this.lastUpdateTime < this.config.MIN_UPDATE_INTERVAL) {
            // Queue the update for later
            this.queueUpdate(position, forceUpdate);
            return false;
        }
        
        const newPos = this.normalizePosition(position, now);
        
        console.log('üìç GPS Update:', {
            lat: newPos.lat.toFixed(6),
            lng: newPos.lng.toFixed(6),
            accuracy: newPos.accuracy
        });

        // First time setup
        if (!this.isInitialized) {
            this.initializeFirstPosition(newPos);
            return true;
        }

        // Calculate movement
        const distance = this.calculateDistance(this.currentPosition, newPos);
        
        // Handle different types of updates
        if (forceUpdate || distance > this.config.MAJOR_JUMP_THRESHOLD) {
            this.handleInstantUpdate(newPos);
        } else if (distance > this.config.MIN_MOVEMENT_THRESHOLD) {
            this.handleSmoothUpdate(newPos, distance);
        } else {
            // Even tiny movements should update for perfect tracking
            this.handleMicroUpdate(newPos);
        }

        this.lastUpdateTime = now;
        return true;
    }

    /**
     * Queue updates for high-frequency GPS data
     */
    queueUpdate(position, forceUpdate) {
        this.updateQueue.push({ position, forceUpdate, timestamp: performance.now() });
        
        if (!this.isProcessingQueue) {
            this.processUpdateQueue();
        }
    }

    /**
     * Process queued updates efficiently
     */
    processUpdateQueue() {
        this.isProcessingQueue = true;
        
        const processNext = () => {
            if (this.updateQueue.length === 0) {
                this.isProcessingQueue = false;
                return;
            }
            
            // Take the most recent update and discard older ones
            const latestUpdate = this.updateQueue.pop();
            this.updateQueue = []; // Clear queue
            
            this.updateLocation(latestUpdate.position, latestUpdate.forceUpdate);
            
            // Schedule next processing
            setTimeout(processNext, this.config.MIN_UPDATE_INTERVAL);
        };
        
        processNext();
    }

    /**
     * Enhanced input validation
     */
    validateInputs(position) {
        if (!position?.coords?.latitude || !position?.coords?.longitude) {
            console.error('‚ùå Invalid position data');
            return false;
        }

        if (!window.map) {
            console.error('‚ùå Map not found');
            return false;
        }

        if (!window.userMarker) {
            console.error('‚ùå User marker not found');
            return false;
        }

        return true;
    }

    /**
     * Convert GPS position to standard format
     */
    normalizePosition(position, timestamp) {
        return {
            lat: position.coords.latitude,
            lng: position.coords.longitude,
            accuracy: position.coords.accuracy || 10,
            speed: position.coords.speed || 0,
            heading: position.coords.heading || null,
            timestamp: timestamp
        };
    }

    /**
     * Set up the first position immediately and center perfectly
     */
    initializeFirstPosition(position) {
        console.log('üéØ Initializing first position - centering perfectly');
        
        this.currentPosition = position;
        this.previousPosition = position;
        this.isInitialized = true;
        
        // Set marker immediately
        this.setMarkerPosition(position);
        
        // Center map perfectly
        window.map.setView([position.lat, position.lng], window.map.getZoom(), {
            animate: false
        });
        
        this.lastCenterTime = performance.now();
        this.updateRelatedComponents(position);
    }

    /**
     * Handle instant updates (jumps, force updates)
     */
    handleInstantUpdate(newPosition) {
        console.log('‚ö° Instant update - jumping to new position');
        
        this.cancelAnimation();
        this.setMarkerPosition(newPosition);
        this.currentPosition = newPosition;
        
        // Always center on jumps to keep user on screen
        this.centerMapOnPosition(newPosition, false); // No animation for jumps
        this.updateRelatedComponents(newPosition);
    }

    /**
     * Handle smooth animated updates
     */
    handleSmoothUpdate(newPosition, distance) {
        console.log(`üîÑ Smooth update - ${distance.toFixed(2)}m movement`);
        
        // Apply light smoothing
        const smoothedPosition = this.applySmoothingFilter(newPosition);
        
        // Animate if distance is reasonable
        if (distance < this.config.MAX_ANIMATION_DISTANCE) {
            this.animateToPosition(smoothedPosition);
        } else {
            // Too far to animate smoothly
            this.setMarkerPosition(smoothedPosition);
            this.currentPosition = smoothedPosition;
        }
        
        // Always check if we need to center to keep user on screen
        this.smartCenterCheck(smoothedPosition);
        this.updateRelatedComponents(smoothedPosition);
    }

    /**
     * Handle micro updates for perfect tracking
     */
    handleMicroUpdate(newPosition) {
        // Apply minimal smoothing for micro movements
        const factor = 0.9; // High responsiveness
        const microSmoothPosition = {
            ...newPosition,
            lat: this.currentPosition.lat * (1 - factor) + newPosition.lat * factor,
            lng: this.currentPosition.lng * (1 - factor) + newPosition.lng * factor
        };
        
        this.setMarkerPosition(microSmoothPosition);
        this.currentPosition = microSmoothPosition;
        
        // Check centering even for micro movements
        this.smartCenterCheck(microSmoothPosition);
    }

    /**
     * Smart centering that keeps user optimally positioned
     */
    smartCenterCheck(position) {
        const now = performance.now();
        
        // More frequent centering for perfect tracking
        if (now - this.lastCenterTime < this.config.MIN_CENTER_INTERVAL) {
            return;
        }
        
        // Don't center if user is actively interacting
        if (window.isMapInteracting) return;
        if (window.followUser === false) return;
        
        // Always center if user approaches edges
        if (this.isNearEdgeOrOffCenter(position)) {
            this.centerMapOnPosition(position, true); // Smooth animation
        }
    }

    /**
     * Enhanced edge detection for perfect centering
     */
    isNearEdgeOrOffCenter(position) {
        try {
            const mapSize = window.map.getSize();
            const point = window.map.latLngToContainerPoint([position.lat, position.lng]);
            const margin = this.config.BOUNDARY_MARGIN * Math.min(mapSize.x, mapSize.y);
            
            // Check if near any edge
            const nearEdge = (
                point.x < margin || 
                point.x > mapSize.x - margin ||
                point.y < margin || 
                point.y > mapSize.y - margin
            );
            
            // Also check if too far from center
            const centerX = mapSize.x / 2;
            const centerY = mapSize.y / 2;
            const distanceFromCenter = Math.sqrt(
                Math.pow(point.x - centerX, 2) + Math.pow(point.y - centerY, 2)
            );
            const maxCenterDistance = Math.min(mapSize.x, mapSize.y) * 0.15; // 15% from center
            
            return nearEdge || distanceFromCenter > maxCenterDistance;
        } catch (error) {
            console.warn('Error checking position:', error);
            return true; // Default to centering on error
        }
    }

    /**
     * Apply minimal smoothing for responsiveness
     */
    applySmoothingFilter(newPosition) {
        if (!this.currentPosition) return newPosition;
        
        const factor = this.config.SMOOTHING_FACTOR;
        
        return {
            ...newPosition,
            lat: this.currentPosition.lat * (1 - factor) + newPosition.lat * factor,
            lng: this.currentPosition.lng * (1 - factor) + newPosition.lng * factor
        };
    }

    /**
     * High-performance animation with frame optimization
     */
    animateToPosition(targetPosition) {
        if (this.isAnimating) {
            this.cancelAnimation();
        }
        
        const startPosition = { ...this.currentPosition };
        const startTime = performance.now();
        const duration = this.config.ANIMATION_DURATION;
        
        this.isAnimating = true;
        
        const animate = (currentTime) => {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);
            
            // Ultra-smooth easing
            const easedProgress = this.easeOutQuint(progress);
            
            // Interpolate position
            const interpolatedPos = {
                lat: startPosition.lat + (targetPosition.lat - startPosition.lat) * easedProgress,
                lng: startPosition.lng + (targetPosition.lng - startPosition.lng) * easedProgress,
                timestamp: currentTime
            };
            
            // Update marker position
            this.setMarkerPosition(interpolatedPos);
            this.currentPosition = interpolatedPos;
            
            if (progress < 1) {
                this.animationId = requestAnimationFrame(animate);
            } else {
                this.isAnimating = false;
                this.animationId = null;
                this.currentPosition = targetPosition;
                console.log('‚úÖ Animation complete');
            }
        };
        
        this.animationId = requestAnimationFrame(animate);
    }

    /**
     * Optimized marker positioning
     */
    setMarkerPosition(position) {
        try {
            if (window.userMarker && window.userMarker.setLatLng) {
                // Use the most efficient method
                window.userMarker.setLatLng([position.lat, position.lng]);
                // Don't log every update to avoid console spam
            } else {
                throw new Error('userMarker.setLatLng not available');
            }
        } catch (error) {
            console.error('‚ùå Failed to set marker position:', error);
            this.tryAlternativeMarkerUpdate(position);
        }
    }

    /**
     * Enhanced fallback methods
     */
    tryAlternativeMarkerUpdate(position) {
        const methods = [
            () => window.userMarker.setPosition([position.lat, position.lng]),
            () => window.userMarker.moveTo([position.lat, position.lng]),
            () => {
                if (window.userMarker._latlng) {
                    window.userMarker._latlng.lat = position.lat;
                    window.userMarker._latlng.lng = position.lng;
                    window.userMarker.update();
                }
            },
            () => window.userMarker._latlng = L.latLng(position.lat, position.lng)
        ];

        for (let i = 0; i < methods.length; i++) {
            try {
                methods[i]();
                console.log(`‚úÖ Alternative method ${i + 1} worked`);
                return;
            } catch (error) {
                // Continue to next method
            }
        }
        
        console.error('‚ùå All marker update methods failed');
    }

    /**
     * Smart map centering with performance optimization
     */
    centerMapOnPosition(position, animate = true) {
        try {
            if (animate) {
                window.map.panTo([position.lat, position.lng], {
                    animate: true,
                    duration: 0.6,
                    easeLinearity: 0.15,
                    noMoveStart: true // Optimize performance
                });
            } else {
                window.map.setView([position.lat, position.lng], window.map.getZoom(), {
                    animate: false
                });
            }
            
            this.lastCenterTime = performance.now();
            console.log('üéØ Map centered perfectly');
        } catch (error) {
            console.warn('Error centering map:', error);
            // Fallback
            window.map.setView([position.lat, position.lng], window.map.getZoom(), {
                animate: false
            });
        }
    }

    /**
     * Calculate distance between two positions
     */
    calculateDistance(pos1, pos2) {
        if (!pos1 || !pos2) return 0;
        
        const R = 6371000; // Earth's radius in meters
        const dLat = (pos2.lat - pos1.lat) * Math.PI / 180;
        const dLng = (pos2.lng - pos1.lng) * Math.PI / 180;
        const a = 
            Math.sin(dLat/2) * Math.sin(dLat/2) +
            Math.cos(pos1.lat * Math.PI / 180) * Math.cos(pos2.lat * Math.PI / 180) *
            Math.sin(dLng/2) * Math.sin(dLng/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        return R * c;
    }

    /**
     * Ultra-smooth easing function
     */
    easeOutQuint(t) {
        return 1 - Math.pow(1 - t, 5);
    }

    /**
     * Cancel any ongoing animation
     */
    cancelAnimation() {
        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
            this.animationId = null;
            this.isAnimating = false;
        }
    }

    /**
     * Optimized component updates
     */
    updateRelatedComponents(position) {
        // Throttle component updates to avoid performance issues
        if (this.frameThrottle) return;
        
        this.frameThrottle = requestAnimationFrame(() => {
            try {
                if (typeof updateDistanceBox === 'function') {
                    updateDistanceBox();
                }
            } catch (error) {
                console.warn('Error updating distance:', error);
            }

            try {
                if (typeof updateAccuracyIndicator === 'function') {
                    updateAccuracyIndicator(position.accuracy);
                }
            } catch (error) {
                console.warn('Error updating accuracy:', error);
            }
            
            this.frameThrottle = null;
        });
    }

    /**
     * Reset the tracker
     */
    reset() {
        this.cancelAnimation();
        this.isInitialized = false;
        this.currentPosition = null;
        this.previousPosition = null;
        this.lastUpdateTime = 0;
        this.lastCenterTime = 0;
        this.updateQueue = [];
        this.isProcessingQueue = false;
        
        if (this.frameThrottle) {
            cancelAnimationFrame(this.frameThrottle);
            this.frameThrottle = null;
        }
        
        console.log('üîÑ Perfect location tracker reset');
    }

    /**
     * Get current status for debugging
     */
    getStatus() {
        return {
            initialized: this.isInitialized,
            animating: this.isAnimating,
            currentPosition: this.currentPosition,
            hasMarker: !!window.userMarker,
            hasMap: !!window.map,
            queueLength: this.updateQueue.length,
            isProcessingQueue: this.isProcessingQueue
        };
    }
}

// Create global instance
const perfectLocationTracker = new PerfectLocationTracker();

/**
 * Main function - PERFECT location tracking
 */
function updateUserLocation(position, forceUpdate = false) {
    return perfectLocationTracker.updateLocation(position, forceUpdate);
}

/**
 * Cleanup function
 */
function cleanupLocationTrackingSystem() {
    perfectLocationTracker.reset();
}

/**
 * Debug function
 */
function debugLocationTracker() {
    console.log('üîç Perfect Location Tracker Status:', perfectLocationTracker.getStatus());
}

// Export functions
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { 
        updateUserLocation, 
        cleanupLocationTrackingSystem,
        debugLocationTracker,
        perfectLocationTracker
    };
} else if (typeof window !== 'undefined') {
    window.updateUserLocation = updateUserLocation;
    window.cleanupLocationTrackingSystem = cleanupLocationTrackingSystem;
    window.debugLocationTracker = debugLocationTracker;
    window.perfectLocationTracker = perfectLocationTracker;
}
        
// Calculate distance between two points using Haversine formula
function calculateDistance(pos1, pos2) {
    if (!pos1 || !pos2 || 
        typeof pos1.lat !== 'number' || typeof pos1.lng !== 'number' || 
        typeof pos2.lat !== 'number' || typeof pos2.lng !== 'number') {
        return Infinity;
    }
    
    // Haversine formula implementation
    const R = 6371000; // Earth's radius in meters
    const lat1 = pos1.lat * Math.PI / 180;
    const lat2 = pos2.lat * Math.PI / 180;
    const deltaLat = (pos2.lat - pos1.lat) * Math.PI / 180;
    const deltaLng = (pos2.lng - pos1.lng) * Math.PI / 180;

    const a = Math.sin(deltaLat/2) * Math.sin(deltaLat/2) +
            Math.cos(lat1) * Math.cos(lat2) *
            Math.sin(deltaLng/2) * Math.sin(deltaLng/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

    return R * c;
}

function getGeolocationOptions(retryNumber) {
    return {
        enableHighAccuracy: retryNumber < 2,
        timeout: 10000 + (retryNumber * 5000),
        maximumAge: retryNumber * 5000
    };
}

function handleLocationError(error) {
    console.warn("Error getting user location:", error);
    
    if (retryCount < CONFIG.MAX_RETRIES) {
        retryCount++;
        console.log(`Retrying to get location (Attempt ${retryCount} of ${CONFIG.MAX_RETRIES})`);
        
        // Use increasing timeout for subsequent retries
        const currentRetryDelay = CONFIG.RETRY_DELAY * retryCount;
        
        setTimeout(() => {
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    console.log("Location retrieved successfully after retry");
                    hideLoadingMessage();
                    updateUserLocation(position, true);
                    retryCount = 0;
                }, 
                handleLocationError, 
                getGeolocationOptions(retryCount) 
            );
        }, currentRetryDelay);
        return;
    }
    
    retryCount = 0;
    hideLoadingMessage();
    
    let errorMessage = "An error occurred while getting your location.";
    if (error && error.code) {
        switch(error.code) {
            case 1: // PERMISSION_DENIED
                errorMessage = "Please allow access to your location to use this feature.";
                break;
            case 2: // POSITION_UNAVAILABLE
                errorMessage = "Your location is currently unavailable. Please try again later.";
                break;
            case 3: // TIMEOUT
                errorMessage = "Getting your location took too long. Please try again.";
                break;
        }
    }
    
    showPopup("Location Error", errorMessage);
    
    // Signal that the location request failed
    if (typeof onLocationFailure === 'function') {
        onLocationFailure(error);
    }
}

function showPopup(title, message, type = "info", callback = null) {
    // First, let's create a test element to verify positioning
    console.log("showPopup called with:", title, message);
    
    // Remove any existing popups
    const existingPopups = document.querySelectorAll(".popup-overlay");
    existingPopups.forEach(popup => {
        document.body.removeChild(popup);
    });

    // Create the overlay
    const overlay = document.createElement("div");
    overlay.className = "popup-overlay";
    overlay.style.position = "fixed";
    overlay.style.left = "0";
    overlay.style.top = "0";
    overlay.style.width = "100%";
    overlay.style.height = "100%";
    overlay.style.backgroundColor = "rgba(0, 0, 0, 0.7)";
    overlay.style.zIndex = "9999";
    
    // Create the popup container
    const popupContainer = document.createElement("div");
    popupContainer.className = "popup-container";
    popupContainer.style.position = "absolute";
    popupContainer.style.left = "50%";
    popupContainer.style.top = "50%";
    popupContainer.style.transform = "translate(-50%, -50%)";
    popupContainer.style.backgroundColor = "white";
    popupContainer.style.borderRadius = "8px";
    popupContainer.style.padding = "20px";
    popupContainer.style.width = "300px";
    popupContainer.style.maxWidth = "90%";
    popupContainer.style.boxShadow = "0 4px 15px rgba(0, 0, 0, 0.2)";
    
    // Create title
    const titleElement = document.createElement("h3");
    titleElement.textContent = title;
    titleElement.style.margin = "0 0 15px 0";
    titleElement.style.textAlign = "center";
    titleElement.style.color = "#333";
    
    // Create message
    const messageElement = document.createElement("p");
    messageElement.textContent = message;
    messageElement.style.margin = "0 0 20px 0";
    messageElement.style.textAlign = "center";
    messageElement.style.color = "#555";
    
    // Create button
    const button = document.createElement("button");
    button.textContent = "OK";
    button.style.display = "block";
    button.style.margin = "0 auto";
    button.style.padding = "8px 20px";
    button.style.backgroundColor = "#2c5282";
    button.style.color = "white";
    button.style.border = "none";
    button.style.borderRadius = "4px";
    button.style.cursor = "pointer";
    
    // Add click event to button
    button.addEventListener("click", function() {
        document.body.removeChild(overlay);
        if (callback && typeof callback === "function") {
            callback();
        }
    });
    
    // Add click event to overlay (close when clicking outside)
    overlay.addEventListener("click", function(e) {
        if (e.target === overlay) {
            document.body.removeChild(overlay);
        }
    });
    
    // Assemble the popup
    popupContainer.appendChild(titleElement);
    popupContainer.appendChild(messageElement);
    popupContainer.appendChild(button);
    overlay.appendChild(popupContainer);
    
    // Add to document
    document.body.appendChild(overlay);
    
    // Focus the button for accessibility
    button.focus();
}

// global (add once at top of file)
let pinchDebounceTimer = null;

function recenterMap() {
    // ignore if a pinch is in progress
    if (window.isPinching) {
        clearTimeout(pinchDebounceTimer);
        pinchDebounceTimer = setTimeout(recenterMap, 250);
        return;
    }

    const recenterButton = cachedElements.recenterButton || document.getElementById('recenterButton');
    recenterButton.style.backgroundColor = 'var(--primary-color)';
    recenterButton.style.color = 'white';

    if (userMarker && userMarker.getLatLng()) {
        map.closePopup();
        map.panTo(userMarker.getLatLng(), {
            animate: true,
            duration: 0.5,
            easeLinearity: 0.25,
            noZoom: true
        });
        followUser = true;
        announceToScreenReader('Map recentered on your location');
    }

    setTimeout(() => {
        recenterButton.style.backgroundColor = 'white';
        recenterButton.style.color = 'var(--primary-color)';
    }, 500);
}
    
// ENHANCED: Cooldown configuration with strict 2-minute enforcement
const COOLDOWN_PERIOD = 120 * 1000; // ENHANCED: Exactly 2 minutes (120 seconds) as requested
const MINIMUM_GAP = 15 * 1000; // 15 seconds
const STORAGE_KEY = 'locationCooldowns';

// Device detection for debouncing
const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
const DEBOUNCE_TIME = isTouchDevice ? 100 : 50;

// Simple global debounce
let lastFunctionCall = 0;

// ENHANCED: Cooldown manager with strict 2-minute enforcement
class CooldownManager {
    constructor() {
        this.cooldowns = this.loadCooldowns();
        this.cleanupExpired();
    }

    loadCooldowns() {
        try {
            const stored = localStorage.getItem(STORAGE_KEY);
            return stored ? JSON.parse(stored) : {};
        } catch (e) {
            console.warn('Failed to load cooldowns:', e);
            return {};
        }
    }

    saveCooldowns() {
        try {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(this.cooldowns));
        } catch (e) {
            console.warn('Failed to save cooldowns:', e);
        }
    }

    cleanupExpired() {
        const now = Date.now();
        let cleaned = false;

        Object.keys(this.cooldowns).forEach(key => {
            const timeElapsed = now - this.cooldowns[key];
            
            // Only remove if genuinely expired (past cooldown period)
            if (timeElapsed > COOLDOWN_PERIOD) {
                delete this.cooldowns[key];
                cleaned = true;
            }
        });

        if (cleaned) {
            this.saveCooldowns();
        }
    }

    isOnCooldown(locationId) {
        const key = `location_${locationId}`;
        const now = Date.now();
        
        if (!this.cooldowns[key]) {
            return { onCooldown: false, reason: 'no_cooldown' };
        }

        const timeElapsed = now - this.cooldowns[key];
        
        // Handle invalid timestamps
        if (timeElapsed < 0) {
            console.warn(`Invalid cooldown timestamp for ${locationId}, removing`);
            delete this.cooldowns[key];
            this.saveCooldowns();
            return { onCooldown: false, reason: 'invalid_timestamp' };
        }

        // Check minimum gap (15 seconds)
        if (timeElapsed < MINIMUM_GAP) {
            return { 
                onCooldown: true, 
                reason: 'minimum_gap',
                timeRemaining: MINIMUM_GAP - timeElapsed,
                timeElapsed
            };
        }

        // ENHANCED: Check full cooldown period (exactly 2 minutes)
        if (timeElapsed < COOLDOWN_PERIOD) {
            return { 
                onCooldown: true, 
                reason: 'cooldown_period',
                timeRemaining: COOLDOWN_PERIOD - timeElapsed,
                timeElapsed
            };
        }

        // Cooldown expired
        delete this.cooldowns[key];
        this.saveCooldowns();
        return { onCooldown: false, reason: 'expired' };
    }

    setCooldown(locationId) {
        const key = `location_${locationId}`;
        const now = Date.now();
        
        this.cooldowns[key] = now;
        this.saveCooldowns();
        
        console.log(`Cooldown set for location ${locationId} at ${now} (2-minute cooldown active)`);
    }

    clearAll() {
        this.cooldowns = {};
        this.saveCooldowns();
        console.log('All cooldowns cleared');
    }

    // ENHANCED: Get remaining cooldown time for debugging
    getRemainingTime(locationId) {
        const cooldownStatus = this.isOnCooldown(locationId);
        if (cooldownStatus.onCooldown) {
            return Math.ceil(cooldownStatus.timeRemaining / 1000); // Return seconds
        }
        return 0;
    }
}

// Initialize cooldown manager
const cooldownManager = new CooldownManager();

function showLocationHunt(location) {
    const now = Date.now();
    
    // Global debounce check
    if (now - lastFunctionCall < DEBOUNCE_TIME) {
        console.log(`Function debounced (${now - lastFunctionCall}ms ago) on ${isTouchDevice ? 'touch' : 'desktop'} device`);
        return;
    }
    lastFunctionCall = now;
    
    console.log(`Processing location ${location.id} on ${isTouchDevice ? 'touch' : 'desktop'} device`);
    
    // Clean up expired cooldowns
    cooldownManager.cleanupExpired();
    
    // ENHANCED: Check cooldown status with strict enforcement
    const cooldownStatus = cooldownManager.isOnCooldown(location.id);
    
    if (cooldownStatus.onCooldown) {
        const remainingSeconds = Math.ceil(cooldownStatus.timeRemaining / 1000);
        const remainingMinutes = Math.ceil(remainingSeconds / 60);
        console.log(`Location ${location.id} is on cooldown: ${cooldownStatus.reason}, ${remainingSeconds}s (${remainingMinutes}min) remaining`);
        
        // ENHANCED: Show user-friendly message for cooldown
        if (remainingSeconds > 60) {
            console.log(`Please wait ${remainingMinutes} more minute(s) before visiting this location again.`);
        } else {
            console.log(`Please wait ${remainingSeconds} more seconds before visiting this location again.`);
        }
        return;
    }
    
    console.log(`Location ${location.id} cooldown check passed: ${cooldownStatus.reason}`);
    
    // ENHANCED: Set cooldown for this location IMMEDIATELY to prevent double triggers
    cooldownManager.setCooldown(location.id);
    
    // Continue with the rest of your existing showLocationHunt logic...
    lastVisitedLocationId = location.id;
    isLocationHuntVisible = true;
    const lochuntContainer = cachedElements.lochuntContainer || document.querySelector('.lochunt-container');
    lochuntContainer.innerHTML = '';
    lochuntContainer.style.display = 'flex';
    lochuntContainer.classList.add('fade-in');
    
    // Accessibility announcement
    announceToScreenReader(`Opened location: ${location.name}`);
    
    const scrollableContent = document.createElement('div');
    scrollableContent.style.cssText = `
        flex: 1;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
        scroll-behavior: smooth;
        will-change: scroll-position;
    `;
    
    const locationImage = document.createElement('img');
    locationImage.src = location.image;
    locationImage.alt = location.name;
    locationImage.style.cssText = `
        width: 100%;
        height: 45vh;
        object-fit: cover;
        object-position: center;
    `;
    locationImage.loading = "eager";
    scrollableContent.appendChild(locationImage);
    
    const contentContainer = document.createElement('div');
    contentContainer.classList.add('lochunt-content');
    contentContainer.style.cssText = `
        padding: 24px;
        display: flex;
        flex-direction: column;
        align-items: center;
        max-width: 800px;
        margin: 0 auto;
    `;
    
    const locationInfo = document.createElement('div');
    locationInfo.classList.add('lochunt-info');
    locationInfo.style.cssText = `
        text-align: center;
        width: 100%;
        margin-bottom: 15px;
    `;
    
    const locationName = document.createElement('h1');
    locationName.textContent = location.name;
    locationName.style.cssText = `
        font-size: clamp(1.8rem, 4vw, 2.5rem);
        font-weight: 700;
        color: #1a1a1a;
        margin-bottom: 8px;
        line-height: 1.2;
    `;
    
    const locationCity = document.createElement('p');
    locationCity.textContent = `${location.city}`;
    locationCity.style.cssText = `
        font-size: clamp(1.1rem, 2vw, 1.3rem);
        color: #2c5282;
        font-weight: 600;
        margin-bottom: 4px;
    `;
    
    const locationCreator = document.createElement('p');
    locationCreator.textContent = `Created by: ${location.creator}`;
    locationCreator.style.cssText = `
        font-size: calc(0.9rem + 0.4vw);
        color: #666666;
        font-weight: 500;
    `;
    
    locationInfo.appendChild(locationName);
    locationInfo.appendChild(locationCity);
    locationInfo.appendChild(locationCreator);
    contentContainer.appendChild(locationInfo);
    
    const audioPlayerContainer = createAudioPlayer(location.audio);
    contentContainer.appendChild(audioPlayerContainer);
    scrollableContent.appendChild(contentContainer);
    lochuntContainer.appendChild(scrollableContent);
    
    const bottomActionBar = createBottomActionBar(location);
    bottomActionBar.style.cssText += `
        position: sticky;
        bottom: 0;
        width: 100%;
    `;
    lochuntContainer.appendChild(bottomActionBar);
    
    // Initialize audio player after DOM is updated
    setTimeout(() => {
        window.audioPlayerCleanup = initAudioPlayer();
    }, 100);
    
    // ENTERPRISE ENHANCEMENT: Prefetch nearby audio files
    if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
        const userPos = userMarker ? userMarker.getLatLng() : null;
        if (userPos && gameLocations) {
            navigator.serviceWorker.controller.postMessage({
                type: 'PREFETCH_AUDIO',
                data: {
                    userLocation: { lat: userPos.lat, lng: userPos.lng },
                    locations: gameLocations
                }
            });
        }
    }
}
        
function createAudioPlayer(audioSrc) {
    const audioPlayerContainer = document.createElement('div');
    audioPlayerContainer.classList.add('audio-player');
    audioPlayerContainer.style.cssText = `
        width: 100%;
        max-width: 400px;
        margin-bottom: 15px;
    `;

    const audio = document.createElement('audio');
    audio.id = 'locationAudio';
    audio.src = audioSrc;
    audio.preload = "auto";

    const audioProgress = document.createElement('div');
    audioProgress.classList.add('audio-progress');
    audioProgress.style.cssText = `
        width: 100%;
        margin-bottom: 15px;
    `;

    const progressContainer = document.createElement('div');
    progressContainer.classList.add('progress');
    progressContainer.style.cssText = `
        height: 8px;
        background-color: #e2e8f0;
        border-radius: 4px;
        cursor: pointer;
        margin-bottom: 12px;
        overflow: hidden;
    `;

    const progressBar = document.createElement('div');
    progressBar.id = 'progressBar';
    progressBar.classList.add('progress-bar');
    progressBar.style.cssText = `
        height: 100%;
        background-color: #2c5282;
        width: 0%;
        transition: width 0.1s linear;
    `;

    progressContainer.appendChild(progressBar);
    audioProgress.appendChild(progressContainer);

    const timeInfo = document.createElement('div');
    timeInfo.classList.add('audio-time');
    timeInfo.style.cssText = `
        display: flex;
        justify-content: space-between;
        color: #4a5568;
        font-size: 0.875rem;
        margin-bottom: 16px;
        font-weight: 500;
    `;

    const currentTimeSpan = document.createElement('span');
    currentTimeSpan.id = 'currentTime';
    currentTimeSpan.textContent = '0:00';

    const durationSpan = document.createElement('span');
    durationSpan.id = 'duration';
    durationSpan.textContent = '0:00';

    timeInfo.appendChild(currentTimeSpan);
    timeInfo.appendChild(durationSpan);

    const audioControls = document.createElement('div');
    audioControls.classList.add('audio-controls');
    audioControls.style.cssText = `
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 24px;
    `;

    const rewindBtn = createAudioButton('skip-backward', 'rewindBtn', 'Rewind 10 seconds');
    const playPauseBtn = createAudioButton('play', 'playPauseBtn', 'Play');
    const forwardBtn = createAudioButton('skip-forward', 'forwardBtn', 'Forward 10 seconds');

    audioControls.appendChild(rewindBtn);
    audioControls.appendChild(playPauseBtn);
    audioControls.appendChild(forwardBtn);

    audioPlayerContainer.appendChild(audio);
    audioPlayerContainer.appendChild(audioProgress);
    audioPlayerContainer.appendChild(timeInfo);
    audioPlayerContainer.appendChild(audioControls);

    return audioPlayerContainer;
}

function createAudioButton(iconName, id, ariaLabel) {
    const button = document.createElement('button');
    button.id = id;
    button.classList.add('audio-button');
    button.setAttribute('aria-label', ariaLabel);
    button.innerHTML = `<i class="bi bi-${iconName}"></i>`;
    button.style.cssText = `
        background-color: white;
        color: var(--primary-color);
        border: 2px solid var(--primary-color);
        border-radius: 50%;
        width: 55px;
        height: 55px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.3s ease;
    `;

    button.addEventListener('mouseover', () => {
        button.style.backgroundColor = 'var(--hover-color)';
    });

    button.addEventListener('mouseout', () => {
        button.style.backgroundColor = 'white';
    });

    button.addEventListener('click', () => {
        button.style.backgroundColor = 'var(--primary-color)';
        button.style.color = 'white';
        button.style.transform = 'scale(0.95)';
        
        setTimeout(() => {
            button.style.backgroundColor = 'white';
            button.style.color = 'var(--primary-color)';
            button.style.transform = 'scale(1)';
        }, 200);
    });

    return button;
}

function createBottomActionBar(location) {
    const actionBar = document.createElement('div');
    actionBar.classList.add('location-action-bar');
    actionBar.style.cssText = `
        width: 100%;
        height: 60px;
        background: linear-gradient(to right, #2c5282, #2b6cb0);
        margin-top: auto;
        box-shadow: 0 -2px 10px rgba(0,0,0,0.025);
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0 24px;
        position: sticky;
        bottom: 0;
    `;
    
    const imgSourceBtn = document.createElement('button');
    imgSourceBtn.classList.add('source-info-button', 'btn', 'btn-sm', 'me-2');
    imgSourceBtn.innerHTML = '<i class="bi bi-info-circle-fill text-white" style="font-size: 1.5rem;"></i>';
    imgSourceBtn.setAttribute('aria-label', 'Image source information');
    imgSourceBtn.onclick = () => {
        if (location && location.imageSource) {
            showSourcePopup('Image Source', location.imageSource);
        } else {
            showSourcePopup('Image Source', 'Image source information is not available');
        }
    };

    const feedbackButton = document.createElement('a');
    feedbackButton.href = 'mailto:mattreicher@protonmail.com?subject=Feedback';
    feedbackButton.target = '_blank';
    feedbackButton.rel = 'noopener noreferrer';
    feedbackButton.setAttribute('aria-label', 'Send feedback email');
    feedbackButton.innerHTML = '<i class="bi bi-envelope-fill text-white" style="font-size: 1.5rem;"></i>';
    feedbackButton.classList.add('feedback-email-button', 'btn', 'btn-sm');

    actionBar.appendChild(imgSourceBtn);
    actionBar.appendChild(feedbackButton);
    return actionBar;
}

// Completely new implementation of showPopup focused on image source
function showSourcePopup(title, content) {
    // Remove any existing popups first
    const existingPopup = document.getElementById('sourceInfoPopup');
    if (existingPopup) {
        document.body.removeChild(existingPopup);
    }
    
    // Create overlay container that covers the entire screen
    const overlay = document.createElement('div');
    overlay.id = 'sourceInfoPopup';
    overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 9999;
        backdrop-filter: blur(3px);
    `;

    // Create the popup content box
    const popup = document.createElement('div');
    popup.classList.add('source-info-content');
    popup.style.cssText = `
        background-color: white;
        border-radius: 8px;
        padding: 24px;
        width: 90%;
        max-width: 500px;
        max-height: 80vh;
        overflow-y: auto;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
        display: flex;
        flex-direction: column;
    `;

    // Create title
    const popupTitle = document.createElement('h3');
    popupTitle.textContent = title;
    popupTitle.style.cssText = `
        font-size: 1.5rem;
        font-weight: 600;
        color: #2c5282;
        margin-bottom: 16px;
        border-bottom: 1px solid #e2e8f0;
        padding-bottom: 12px;
    `;

    // Create content
    const popupContent = document.createElement('div');
    popupContent.style.cssText = `
        margin-bottom: 20px;
        line-height: 1.6;
        font-size: 1rem;
    `;
    popupContent.textContent = content;

    // Create close button
    const closeButton = document.createElement('button');
    closeButton.textContent = 'Close';
    closeButton.classList.add('source-close-button', 'btn');
    closeButton.style.cssText = `
        background: linear-gradient(to right, #2c5282, #2b6cb0);
        border: none;
        color: white;
        padding: 8px 24px;
        border-radius: 4px;
        font-weight: 500;
        cursor: pointer;
        align-self: flex-end;
        transition: all 0.2s ease;
    `;
    
    closeButton.addEventListener('mouseover', () => {
        closeButton.style.opacity = '0.9';
    });
    
    closeButton.addEventListener('mouseout', () => {
        closeButton.style.opacity = '1';
    });
    
    closeButton.addEventListener('click', () => {
        document.body.removeChild(overlay);
    });

    // Add click event to close when clicking outside the popup
    overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
            document.body.removeChild(overlay);
        }
    });

    // Assemble popup
    popup.appendChild(popupTitle);
    popup.appendChild(popupContent);
    popup.appendChild(closeButton);
    overlay.appendChild(popup);
    document.body.appendChild(overlay);

    // Add animation
    overlay.style.opacity = '0';
    popup.style.transform = 'translateY(20px)';
    popup.style.transition = 'transform 0.3s ease, opacity 0.3s ease';
    overlay.style.transition = 'opacity 0.3s ease';
    
    // Trigger animation
    setTimeout(() => {
        overlay.style.opacity = '1';
        popup.style.transform = 'translateY(0)';
    }, 10);
}

function initAudioPlayer() {
    const audio = document.getElementById('locationAudio');
    const playPauseBtn = document.getElementById('playPauseBtn');
    const rewindBtn = document.getElementById('rewindBtn');
    const forwardBtn = document.getElementById('forwardBtn');
    const progressBar = document.getElementById('progressBar');
    const progressContainer = document.querySelector('.progress');
    const currentTimeSpan = document.getElementById('currentTime');
    const durationSpan = document.getElementById('duration');

    if (!audio || !playPauseBtn || !progressBar) {
        console.error("Audio player elements not found");
        return;
    }

    // Store original source for recovery
    if (audio.src && !audio.dataset.originalSrc) {
        audio.dataset.originalSrc = audio.src;
    }

    // Background playback management
    let wakeLock = null;
    let audioContext = null;
    let isPlayerActive = true;
    
    // Recovery state management
    let retryCount = 0;
    const maxRetries = 3;
    let lastPlaybackPosition = 0;
    let recoveryInProgress = false;
    
    // Track screen/page visibility for better error messages
    let wasPlayingWhenHidden = false;
    let screenWentAway = false;
    let wasPlaying = false;

    // Initialize audio context
    function initAudioContext() {
        if (!audioContext && isPlayerActive) {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const source = audioContext.createMediaElementSource(audio);
                source.connect(audioContext.destination);
            } catch (e) {
                console.log('AudioContext not available:', e);
            }
        }
        return audioContext;
    }

    // Wake Lock API management
    async function requestWakeLock() {
        try {
            if ('wakeLock' in navigator && !wakeLock && isPlayerActive) {
                wakeLock = await navigator.wakeLock.request('screen');
                console.log('Wake lock acquired');
                
                wakeLock.addEventListener('release', () => {
                    console.log('Wake lock released');
                    wakeLock = null;
                    // Track when wake lock is released (screen went away)
                    if (!audio.paused) {
                        screenWentAway = true;
                        wasPlayingWhenHidden = true;
                    }
                });
            }
        } catch (err) {
            console.warn('Wake lock failed:', err);
        }
    }

    async function releaseWakeLock() {
        if (wakeLock) {
            try {
                await wakeLock.release();
                wakeLock = null;
                console.log('Wake lock manually released');
            } catch (err) {
                console.warn('Wake lock release failed:', err);
            }
        }
    }

    // Track page visibility changes
    document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
            // Page is hidden
            if (!audio.paused) {
                wasPlayingWhenHidden = true;
                screenWentAway = true;
            }
        } else {
            // Page is visible again
            if (wasPlayingWhenHidden && audio.paused) {
                // Audio was interrupted while page was hidden
                setTimeout(() => {
                    if (screenWentAway) {
                        showSourcePopup("Audio Restarted", "Audio was interrupted when this tab became inactive and has restarted from the beginning. Keep this tab active to prevent interruptions.");
                        screenWentAway = false;
                        wasPlayingWhenHidden = false;
                    }
                }, 100); // Small delay to let other events process
            }
        }
    });

    // Track when audio starts playing
    audio.addEventListener('play', () => {
        wasPlaying = true;
        // Accessibility announcement
        announceToScreenReader('Audio playback started');
    });

    // Track when audio pauses
    audio.addEventListener('pause', () => {
        wasPlaying = false;
        // Accessibility announcement
        announceToScreenReader('Audio playback paused');
    });

    // Recovery function
    function recoverAudioSource() {
        if (recoveryInProgress || !isPlayerActive) return;
        
        recoveryInProgress = true;
        console.log('Attempting audio recovery...');
        
        // Store current position
        if (!isNaN(audio.currentTime)) {
            lastPlaybackPosition = audio.currentTime;
        }
        
        // Try to restore source
        if (audio.dataset.originalSrc) {
            audio.src = audio.dataset.originalSrc;
        } else if (audio.getAttribute('data-src')) {
            audio.src = audio.getAttribute('data-src');
        }
        
        audio.load();
        
        // Restore position after load, but only if screen didn't go away
        audio.addEventListener('loadedmetadata', function restorePosition() {
            if (lastPlaybackPosition > 0 && !screenWentAway) {
                audio.currentTime = lastPlaybackPosition;
            } else if (screenWentAway) {
                // Reset to beginning if screen went away
                audio.currentTime = 0;
            }
            recoveryInProgress = false;
            retryCount = 0; // Reset on successful recovery
            audio.removeEventListener('loadedmetadata', restorePosition);
        }, { once: true });
    }

// Enhanced error handling
function handleAudioError(error) {
   console.log('handleAudioError called, isPlayerActive:', isPlayerActive, 'audio exists:', !!audio);
   console.log('Screen went away:', screenWentAway, 'Was playing when hidden:', wasPlayingWhenHidden);
   console.log('Current lastPlaybackPosition:', lastPlaybackPosition);
   
   // Get the actual audio error from the audio element
   const actualError = audio ? audio.error : null;
   if (actualError) {
       console.error("Actual audio error details:", {
           code: actualError.code,
           message: actualError.message,
           MEDIA_ERR_ABORTED: actualError.code === 1,
           MEDIA_ERR_NETWORK: actualError.code === 2,
           MEDIA_ERR_DECODE: actualError.code === 3,
           MEDIA_ERR_SRC_NOT_SUPPORTED: actualError.code === 4
       });
   }
   
   // Only ignore errors if player was explicitly cleaned up AND audio doesn't exist
   if (!isPlayerActive && (!audio || audio.readyState === 0)) {
       console.log('Audio error ignored - player cleaned up');
       return;
   }
   
   console.error("Audio play error event:", error);
   releaseWakeLock();
   
   // Determine error type and show appropriate message
   if (screenWentAway || wasPlayingWhenHidden) {
       // Screen-related interruption - Show message but don't auto-resume
       const resumePosition = lastPlaybackPosition || 0;
       console.log('Screen interruption detected, stored position:', resumePosition);
       
       showSourcePopup("Audio Interrupted", `Audio was paused when you left the screen. Click play to resume from ${Math.floor(resumePosition / 60)}:${String(Math.floor(resumePosition % 60)).padStart(2, '0')}.`);
       
       // Prepare audio for manual resume but don't start playing
       if (audio) {
           // Store the resume position for when user clicks play
           audio.dataset.resumePosition = resumePosition.toString();
           
           // Set up the audio to be ready for resume
           const prepareForResume = () => {
               console.log('Audio prepared for manual resume');
               audio.removeEventListener('loadedmetadata', prepareForResume);
               audio.removeEventListener('canplay', prepareForResume);
           };
           
           audio.addEventListener('loadedmetadata', prepareForResume);
           audio.addEventListener('canplay', prepareForResume);
           
           // Recover the source but don't auto-play
           recoverAudioSource();
       }
       
       // Reset flags
       screenWentAway = false;
       wasPlayingWhenHidden = false;
   } else if (retryCount < maxRetries && isPlayerActive) {
       // Network or other recoverable error
       retryCount++;
       console.log(`Recovery attempt ${retryCount}/${maxRetries}`);
       
       setTimeout(() => {
           const currentPos = lastPlaybackPosition || 0;
           const setPositionAfterNetworkRecovery = () => {
               if (currentPos > 0) {
                   console.log('Setting position after network recovery:', currentPos);
                   audio.currentTime = currentPos;
               }
               audio.removeEventListener('loadedmetadata', setPositionAfterNetworkRecovery);
               audio.removeEventListener('canplay', setPositionAfterNetworkRecovery);
           };
           
           audio.addEventListener('loadedmetadata', setPositionAfterNetworkRecovery);
           audio.addEventListener('canplay', setPositionAfterNetworkRecovery);
           
           recoverAudioSource();
       }, 1000 * retryCount);
   } else if (retryCount >= maxRetries) {
       console.error('Audio recovery failed after maximum retries');
       playPauseBtn.innerHTML = '<i class="bi bi-exclamation-triangle"></i>';
       playPauseBtn.setAttribute('aria-label', 'Audio Error');
       showSourcePopup("Audio Error", "Unable to recover audio after multiple attempts. Please refresh the page or try again later.");
   } else {
       if (audio) {
           const currentPos = lastPlaybackPosition || 0;
           const setPositionAfterGenericRecovery = () => {
               if (currentPos > 0) {
                   console.log('Setting position after generic recovery:', currentPos);
                   audio.currentTime = currentPos;
               }
               audio.removeEventListener('loadedmetadata', setPositionAfterGenericRecovery);
               audio.removeEventListener('canplay', setPositionAfterGenericRecovery);
           };
           
           audio.addEventListener('loadedmetadata', setPositionAfterGenericRecovery);
           audio.addEventListener('canplay', setPositionAfterGenericRecovery);
           
           recoverAudioSource();
       }
       showSourcePopup("Audio Error", "An audio error occurred. Attempting to resume from last position.");
   }
   
   // Always reset UI to play state
   playPauseBtn.innerHTML = '<i class="bi bi-play"></i>';
   playPauseBtn.setAttribute('aria-label', 'Play');
}

// Modified togglePlay function to handle resume from interruption
function togglePlay() {
   if (audio.paused) {
       // Check if there's a stored resume position from screen interruption
       const resumePosition = audio.dataset.resumePosition;
       if (resumePosition && parseFloat(resumePosition) > 0) {
           console.log('Resuming from stored position:', resumePosition);
           audio.currentTime = parseFloat(resumePosition);
           // Clear the stored position
           delete audio.dataset.resumePosition;
       }
       
       audio.play().then(() => {
           playPauseBtn.innerHTML = '<i class="bi bi-pause"></i>';
           playPauseBtn.setAttribute('aria-label', 'Pause');
           requestWakeLock();
       }).catch(error => {
           handleAudioError(error);
       });
   } else {
       audio.pause();
       playPauseBtn.innerHTML = '<i class="bi bi-play"></i>';
       playPauseBtn.setAttribute('aria-label', 'Play');
   }
}

// Store playback position for recovery
audio.addEventListener('timeupdate', () => {
   if (!isNaN(audio.currentTime) && isPlayerActive && audio.currentTime > 0) {
       lastPlaybackPosition = audio.currentTime;
       try {
           localStorage.setItem('audioPosition', audio.currentTime.toString());
       } catch (e) {
           // Ignore localStorage errors
       }
   }
});

// Enhanced visibility change handler - actually pause when screen goes away
document.addEventListener('visibilitychange', () => {
   if (document.hidden) {
       if (audio && !audio.paused) {
           // Store current position immediately when screen goes away
           if (!isNaN(audio.currentTime)) {
               lastPlaybackPosition = audio.currentTime;
               console.log('Screen went away, storing position and pausing:', lastPlaybackPosition);
               try {
                   localStorage.setItem('audioPosition', audio.currentTime.toString());
               } catch (e) {
                   // Ignore localStorage errors
               }
           }
           
           // Set flags BEFORE pausing
           wasPlayingWhenHidden = true;
           screenWentAway = true;
           
           // Actually pause the audio
           audio.pause();
           
           // Update UI
           playPauseBtn.innerHTML = '<i class="bi bi-play"></i>';
           playPauseBtn.setAttribute('aria-label', 'Play');
       }
   }
});

// Handle page focus/blur as additional safety
window.addEventListener('blur', () => {
   if (audio && !audio.paused) {
       lastPlaybackPosition = audio.currentTime;
       wasPlayingWhenHidden = true;
       screenWentAway = true;
       console.log('Window blur, storing position:', lastPlaybackPosition);
   }
});

// Handle network recovery
window.addEventListener('online', () => {
   if (audio.error && isPlayerActive) {
       console.log('Network recovered, attempting to reload audio');
       const savedPos = lastPlaybackPosition || 0;
       const setPositionAfterOnline = () => {
           if (savedPos > 0) {
               audio.currentTime = savedPos;
           }
           audio.removeEventListener('loadedmetadata', setPositionAfterOnline);
           audio.removeEventListener('canplay', setPositionAfterOnline);
       };
       
       audio.addEventListener('loadedmetadata', setPositionAfterOnline);
       audio.addEventListener('canplay', setPositionAfterOnline);
       
       recoverAudioSource();
   }
});

// Set up event listeners 
playPauseBtn.addEventListener('click', togglePlay);
rewindBtn.addEventListener('click', () => seek(-10));
forwardBtn.addEventListener('click', () => seek(10));
audio.addEventListener('timeupdate', updateProgress);
audio.addEventListener('loadedmetadata', setDuration);
audio.addEventListener('ended', async () => {
   playPauseBtn.innerHTML = '<i class="bi bi-play"></i>';
   playPauseBtn.setAttribute('aria-label', 'Play');
   await releaseWakeLock();
   
   // Clear saved position and reset progress bar since audio completed naturally
   try {
       localStorage.removeItem('audioPosition');
   } catch (e) {
       // Ignore localStorage errors
   }
   
   // Reset audio and progress bar to beginning
   audio.currentTime = 0;
   if (progressBar) {
       progressBar.style.width = '0%';
   }
   
   announceToScreenReader('Audio playback completed');
   showAdditionalInfo();
});
audio.addEventListener('pause', releaseWakeLock);
audio.addEventListener('error', (e) => {
   handleAudioError(e);
});

if (progressContainer) {
   progressContainer.addEventListener('click', setProgress);
}

// Restore saved position on load - but only if not resuming from interruption
audio.addEventListener('loadedmetadata', () => {
   try {
       const savedPosition = localStorage.getItem('audioPosition');
       if (savedPosition && !isNaN(savedPosition) && parseFloat(savedPosition) > 0 && !screenWentAway && !wasPlayingWhenHidden) {
           audio.currentTime = parseFloat(savedPosition);
       }
       // Don't force currentTime = 0 here - let the audio start naturally at 0
   } catch (e) {
       // Ignore localStorage errors - let audio start naturally
   }
});

// Preload audio
audio.load();

    async function togglePlay() {
        if (!isPlayerActive) return;
        
        try {
            if (audio.paused) {
                // Initialize audio context on first play
                const ctx = initAudioContext();
                if (ctx && ctx.state === 'suspended') {
                    await ctx.resume();
                }
                
                const playPromise = audio.play();
                if (playPromise !== undefined) {
                    playPromise.then(async () => {
                        playPauseBtn.innerHTML = '<i class="bi bi-pause"></i>';
                        playPauseBtn.setAttribute('aria-label', 'Pause');
                        await requestWakeLock();
                        retryCount = 0; // Reset retry count on successful play
                    }).catch(error => {
                        handleAudioError(error);
                    });
                }
            } else {
                audio.pause();
                playPauseBtn.innerHTML = '<i class="bi bi-play"></i>';
                playPauseBtn.setAttribute('aria-label', 'Play');
                await releaseWakeLock();
            }
        } catch (error) {
            handleAudioError(error);
        }
    }

    function seek(seconds) {
        if (!isPlayerActive) return;
        audio.currentTime = Math.max(0, Math.min(audio.currentTime + seconds, audio.duration));
        
        // Accessibility announcement
        const direction = seconds > 0 ? 'forward' : 'backward';
        announceToScreenReader(`Skipped ${Math.abs(seconds)} seconds ${direction}`);
    }

    function updateProgress() {
        if (!isPlayerActive || !isFinite(audio.duration)) return;
        
        const percent = (audio.currentTime / audio.duration) * 100;
        progressBar.style.width = `${percent}%`;
        currentTimeSpan.textContent = formatTime(audio.currentTime);
    }

    function setProgress(e) {
        if (!isPlayerActive) return;
        
        const width = this.clientWidth;
        const clickX = e.offsetX;
        const duration = audio.duration;
        
        if (isFinite(duration) && width > 0) {
            audio.currentTime = (clickX / width) * duration;
            
            // Accessibility announcement
            const newTime = formatTime(audio.currentTime);
            announceToScreenReader(`Jumped to ${newTime}`);
        }
    }

    function setDuration() {
        if (!isPlayerActive || !isFinite(audio.duration)) return;
        durationSpan.textContent = formatTime(audio.duration);
    }

    function formatTime(time) {
        if (!isFinite(time)) return "0:00";
        
        const minutes = Math.floor(time / 60);
        const seconds = Math.floor(time % 60);
        return `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }

    // Return cleanup function
    return function cleanup() {
        console.log('Audio player cleanup starting');
        releaseWakeLock(); // Release wake lock BEFORE marking inactive
        isPlayerActive = false; // Mark player as inactive AFTER wake lock release
        if (audioContext) {
            audioContext.close();
        }
        console.log('Audio player cleaned up');
    };
}

function showAdditionalInfo() {
    // Find the location using lastVisitedLocationId
    const location = gameLocations.find(loc => loc.id === lastVisitedLocationId);
    if (!location) {
        console.error('Location not found for ID:', lastVisitedLocationId);
        return;
    }
    
    const additionalInfoContainer = cachedElements.additionalInfoContainer || document.querySelector('.additional-info-container');
    additionalInfoContainer.style.display = 'block';
    additionalInfoContainer.classList.add('fade-in');
    
    document.getElementById('additionalInfo').textContent = location.additionalInfo || 
        "No additional information available for this location.";

    // Accessibility announcement
    announceToScreenReader('Additional information is now available');

    const continueButton = document.getElementById('continueButton');
    continueButton.onclick = () => {
        additionalInfoContainer.classList.add('fade-out');
        setTimeout(() => {
            additionalInfoContainer.style.display = 'none';
            additionalInfoContainer.classList.remove('fade-out');
            
            const lochuntContainer = cachedElements.lochuntContainer || document.querySelector('.lochunt-container');
            lochuntContainer.classList.add('fade-out');
            setTimeout(() => {
                lochuntContainer.style.display = 'none';
                lochuntContainer.classList.remove('fade-out');
                isLocationHuntVisible = false;
                
                // Accessibility announcement
                announceToScreenReader('Returned to map view');
                
                // IMPORTANT: Return to location page after closing
                updateDistanceBox();
                
                // Clean up audio player when location closes
                if (window.audioPlayerCleanup) {
                    window.audioPlayerCleanup();
                    window.audioPlayerCleanup = null;
                }
            }, 300);
        }, 300);
    };
}

function showLocationSummary(locationId) {
  const location = locations.find(loc => String(loc.id) === String(locationId));

  if (!location || !location.summary) {
    console.log("Location or summary not found. Location ID:", locationId);
    showPopup("Error", "Summary not available for this location.");
    return;
  }

  // 1. Hide the distance box
  const distanceBox = document.querySelector('#distanceBox');
  if (distanceBox) distanceBox.style.display = 'none';

  // 2. Build modal
  const popupDiv = document.createElement('div');
  popupDiv.id = 'summaryModal';
  popupDiv.style.cssText = `
      position:fixed; inset:0;
      background:rgba(0,0,0,.6); backdrop-filter:blur(4px);
      display:flex; align-items:center; justify-content:center;
      z-index:1000; opacity:0; transition:opacity .3s ease;
  `;

  const darkBlue = '#1a3a8a';
  const darkBlueHover = '#0d2c6e';

  popupDiv.innerHTML = `
    <div style="
        background:#fff; border-radius:16px; width:90%; max-width:420px; max-height:80vh;
        box-shadow:0 15px 40px rgba(0,0,0,.2); overflow:hidden;
        transform:translateY(20px); transition:transform .4s cubic-bezier(.175,.885,.32,1.275);
        display:flex; flex-direction:column;
    ">
      <div style="background:${darkBlue}; color:#fff; text-align:center; padding:18px 28px;">
        <h3 style="margin:0; font-size:1.5rem; font-weight:600">${location.name}</h3>
      </div>

      <div style="flex:1; overflow-y:auto; padding:28px">
        <p style="color:#5c6c7c; line-height:1.6; font-size:1rem; margin:0 0 25px">
          ${location.summary}
        </p>

        <div style="
            border:2px solid ${darkBlue}; border-radius:12px; padding:16px;
            background:rgba(26,58,138,.05); margin-bottom:25px;
            display:flex; align-items:center;
        ">
          <div style="font-weight:600; color:#2c3e50; padding-right:15px; min-width:80px">Location:</div>
          <div style="flex:1; color:#2c3e50; border-left:1px solid rgba(26,58,138,.2); padding-left:15px">
            ${location.today || 'Information not available'}
          </div>
        </div>

        <div style="display:flex; justify-content:center">
          <button class="continue-btn" style="
              padding:14px 24px; background:${darkBlue}; color:#fff; border:none;
              border-radius:10px; cursor:pointer; font-size:1rem; font-weight:600;
              min-width:130px; transition:.2s
          ">Continue</button>
        </div>
      </div>
    </div>
  `;

  document.body.appendChild(popupDiv);

  // Animate in
  requestAnimationFrame(() => {
    popupDiv.style.opacity = '1';
    popupDiv.querySelector('div').style.transform = 'translateY(0)';
  });

  // Close helpers
  function close() {
    popupDiv.style.opacity = '0';
    popupDiv.querySelector('div').style.transform = 'translateY(20px)';
    setTimeout(() => {
      document.body.removeChild(popupDiv);
      // 3. Restore distance box
      if (distanceBox) distanceBox.style.display = 'block';
    }, 300);
  }

  const btn = popupDiv.querySelector('.continue-btn');
  btn.addEventListener('mouseover', () => btn.style.backgroundColor = darkBlueHover);
  btn.addEventListener('mouseout',  () => btn.style.backgroundColor = darkBlue);
  btn.addEventListener('click', close);
  popupDiv.addEventListener('click', e => { if (e.target === popupDiv) close(); });
}

//Updated Navigation Tips Modal
function showNavigationTips() {
   // Hide the distance box when overlay appears
   const distanceBox = document.querySelector('#distanceBox'); 
   if (distanceBox) {
       distanceBox.style.display = 'none';
   }

   // Create modal overlay with proper centering
   const modalOverlay = document.createElement("div");
   modalOverlay.className = "navigation-tips-overlay";
   modalOverlay.style.cssText = `
       position: fixed;
       top: 0;
       left: 0;
       width: 100%;
       height: 100%;
       background-color: rgba(0, 0, 0, 0.6);
       backdrop-filter: blur(4px);
       display: flex;
       justify-content: center;
       align-items: center;
       z-index: 1000;
       opacity: 0;
       transition: opacity 0.3s ease;
   `;
   
   // Define colors
   const darkBlue = "var(--dark-blue)";
   const darkBlueHover = "var(--dark-blue-hover)";
   
   // Create modal content with improved styling and proper centering
   const modalContent = document.createElement("div");
   modalContent.className = "navigation-tips-content";
   modalContent.style.cssText = `
       background-color: white;
       border-radius: 16px;
       width: 90%;
       max-width: 450px;
       max-height: 95vh;
       box-shadow: 0 15px 40px rgba(0, 0, 0, 0.25);
       transform: translateY(20px);
       transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
       overflow: hidden;
       display: flex !important;
       flex-direction: column !important;
       position: relative;
   `;
   
   // Create header
   const header = document.createElement("div");
   header.style.cssText = `
       text-align: center;
       padding: 20px 28px 0;
   `;
   
   header.innerHTML = `
       <h3 style="
           margin: 0 0 10px 0;
           color: ${darkBlue};
           font-size: 1.5rem;
           font-weight: 600;
       ">Navigation Tips</h3>
   `;
   
   // Create content area with tips - reduced vertical spacing
   const contentArea = document.createElement("div");
   contentArea.style.cssText = `
       padding: 0 28px;
       color: #5c6c7c;
       line-height: 1.4;
       font-size: 0.9rem;
   `;
   
   contentArea.innerHTML = `
       <ul style="
           list-style-type: none;
           padding: 0;
           margin: 0 0 10px 0;
       ">
           <li style="margin-bottom: 8px; display: flex; align-items: flex-start;">
               <span style="color: ${darkBlue}; margin-right: 10px; font-size: 1.1rem;">‚Ä¢</span>
               <span>Use the map to navigate to the marked locations.</span>
           </li>
           <li style="margin-bottom: 8px; display: flex; align-items: flex-start;">
               <span style="color: ${darkBlue}; margin-right: 10px; font-size: 1.1rem;">‚Ä¢</span>
               <span>Tap the recenter button to focus on your current position.</span>
           </li>
           <li style="margin-bottom: 8px; display: flex; align-items: flex-start;">
               <span style="color: ${darkBlue}; margin-right: 10px; font-size: 1.1rem;">‚Ä¢</span>
               <span>The distance box shows how far you are from the closest location.</span>
           </li>
           <li style="margin-bottom: 8px; display: flex; align-items: flex-start;">
               <span style="color: ${darkBlue}; margin-right: 10px; font-size: 1.1rem;">‚Ä¢</span>
               <span>When you're within 20 feet of a location, you'll be able to interact with it.</span>
           </li>
           <li style="margin-bottom: 8px; display: flex; align-items: flex-start;">
               <span style="color: ${darkBlue}; margin-right: 10px; font-size: 1.1rem;">‚Ä¢</span>
               <span>Listen to the audio information for each location.</span>
           </li>
           <li style="margin-bottom: 0; display: flex; align-items: flex-start;">
               <span style="color: ${darkBlue}; margin-right: 10px; font-size: 1.1rem;">‚Ä¢</span>
               <span>After the audio, you'll see additional information about the location.</span>
           </li>
       </ul>
   `;
   
   
   // Create footer with close button
   const footer = document.createElement("div");
   footer.style.cssText = `
       padding: 15px 28px 20px !important;
       text-align: center !important;
       border-top: 1px solid rgba(0, 0, 0, 0.05);
       margin-top: 10px !important;
       display: flex !important;
       justify-content: center !important;
       align-items: center !important;
       position: relative !important;
       bottom: 0 !important;
       width: 100% !important;
       box-sizing: border-box !important;
   `;
   
   const closeButton = document.createElement("button");
   closeButton.className = "close-button";
   closeButton.textContent = "Close";
   closeButton.style.cssText = `
       padding: 10px 24px !important;
       background-color: ${darkBlue};
       color: white;
       border: none;
       border-radius: 10px;
       cursor: pointer;
       font-size: 1rem;
       font-weight: 600;
       width: 100% !important;
       max-width: 200px !important;
       transition: all 0.2s ease;
       margin: 0 auto !important;
       display: block !important;
       position: relative !important;
       left: 0 !important;
       right: 0 !important;
   `;
   
   footer.appendChild(closeButton);
   
   // Assemble modal - ensure proper order
   modalContent.appendChild(header);
   modalContent.appendChild(contentArea);
   modalContent.appendChild(footer);
   modalOverlay.appendChild(modalContent);
   document.body.appendChild(modalOverlay);
   
   // Trigger animation after a brief delay
   setTimeout(() => {
       modalOverlay.style.opacity = "1";
       modalContent.style.transform = "translateY(0)";
   }, 10);
   
   // Button hover effects
   closeButton.addEventListener("mouseover", function() {
       this.style.backgroundColor = darkBlueHover;
   });
   
   closeButton.addEventListener("mouseout", function() {
       this.style.backgroundColor = darkBlue;
   });
   
   // Close button event
   closeButton.addEventListener("click", function() {
       modalOverlay.style.opacity = "0";
       modalContent.style.transform = "translateY(20px)";
       setTimeout(() => {
           document.body.removeChild(modalOverlay);
           // Show the distance box again when modal is closed
           if (distanceBox) {
               distanceBox.style.display = 'block';
           }
       }, 300);
   });
   
   // Close when clicking outside
   modalOverlay.addEventListener("click", function(e) {
       if (e.target === modalOverlay) {
           modalOverlay.style.opacity = "0";
           modalContent.style.transform = "translateY(20px)";
           setTimeout(() => {
               document.body.removeChild(modalOverlay);
               // Show the distance box again when modal is closed by clicking outside
               if (distanceBox) {
                   distanceBox.style.display = 'block';
               }
           }, 300);
       }
   });
}

// Update the event listener for the tips button
function startHunt() {
    gameLocations = locations.sort((a, b) => a.id - b.id);
    currentLocationIndex = 0;
    locationTriggerState.cooldowns.clear(); // Reset all cooldowns when starting
    lastVisitedLocationId = null;
    loadAllLocations();
}

function getMarkerColor(tours) {
    if (!tours) return '#0f2bab'; // Default color
    
    switch (tours.toLowerCase()) {
        case 'person':
            return '#FFA500'; // Orange
        case 'gangster':
            return '#3f9b0b'; // Green
        case 'event':
            return '#8B0000'; // Dark red
        case 'place':
            return '#800080'; // Purple
        default:
            return '#0f2bab'; // Default blue
    }
}

function showAppMessage(appName, redirectUrl) {
    const messageEl = document.createElement('div');
    messageEl.style.cssText = `
        position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
        background: #333; color: white; padding: 35px; border-radius: 12px;
        z-index: 5000; text-align: center; line-height: 1.4;
        max-width: 85vw; box-sizing: border-box;
    `;
    messageEl.innerHTML = `
        <div style="font-size: clamp(22px, 5vw, 30px); font-weight: 500;">
            Opening ${appName}...
        </div>
        <div style="font-size: clamp(18px, 4vw, 24px); margin-top: 15px; opacity: 0.9;">
            To return: Switch back to your browser app
        </div>
    `;
    
    document.body.appendChild(messageEl);
    
    setTimeout(() => {
        messageEl.remove();
        window.location.href = redirectUrl;
    }, 3000);
}

// Add a flag to prevent multiple event listener attachments
let markersCreated = false;
let activePopups = new Set(); // Track active popups

// Function to immediately recenter on user location
function recenterOnUser() {
    if (userMarker && map) {
        map.setView(userMarker.getLatLng(), map.getZoom(), {
            animate: true,
            duration: 0.5
        });
    }
}

function createMarkersOnly() {
    if (!gameLocations || !Array.isArray(gameLocations) || gameLocations.length === 0) {
        console.warn("No game locations available");
        return;
    }

    // Clear existing markers
    if (markerClusterGroup) {
        markerClusterGroup.clearLayers();
    }

    // Clear active popups tracking
    activePopups.clear();

    // Create markers for each location
    gameLocations.forEach((location) => {
        if (!location || typeof location.lat !== 'number' || typeof location.lng !== 'number') {
            console.warn("Invalid location data:", location);
            return;
        }

        const markerColor = getMarkerColor(location.tours);
        
        // ENTERPRISE ENHANCEMENT: Store marker color in location object for distance box
        location.markerColor = markerColor;
        
        const locationMarker = L.marker([location.lat, location.lng], {
            icon: L.divIcon({
                className: 'custom-pin-icon',
                html: `<div class="pin-head" style="background-color: ${markerColor};"></div>`,
                iconSize: [30, 30],
                iconAnchor: [15, 30],
            })
        });

        const popupContent = `
            <div class="popup-content">
                <img loading="lazy" src="${location.image}" alt="${location.name}" class="location-image">
                <h4 class="location-name">
                    <a href="${location.link}" target="_blank" rel="noopener noreferrer" style="text-decoration: none; color: inherit;">${location.name}</a>
                </h4>
                <div class="popup-buttons">
                    <button class="button route-button" data-lat="${location.lat}" data-lng="${location.lng}" data-location-id="${location.id}">Directions</button>
                    <button class="button summary-button" data-location-id="${location.id}">Summary</button>
                </div>
            </div>
        `;

        locationMarker.bindPopup(popupContent, {
            offset: L.point(0, -25),
            className: 'custom-popup',
            maxWidth: 300,
            closeButton: true,
            autoClose: true,
            closeOnClick: true
        });

        // Track popup state
        locationMarker.on('popupopen', function(e) {
            activePopups.add(locationMarker);
            attachPopupEventListeners(e.popup._contentNode, location);
        });

        locationMarker.on('popupclose', function(e) {
            activePopups.delete(locationMarker);
        });

        markerClusterGroup.addLayer(locationMarker);
    });

    // Only add to map if not already added
    if (!map.hasLayer(markerClusterGroup)) {
        map.addLayer(markerClusterGroup);
    }
    
    markersCreated = true;
}

// Separate function for popup event listeners
function attachPopupEventListeners(popupElement, location) {
    const routeButton = popupElement.querySelector('.route-button');
    const summaryButton = popupElement.querySelector('.summary-button');

    if (routeButton && !routeButton.hasAttribute('data-listener-attached')) {
        routeButton.setAttribute('data-listener-attached', 'true');
        routeButton.addEventListener('click', function(event) {
            event.preventDefault();
            event.stopPropagation();
            showNavigationModal(location.lat, location.lng);
        });
    }

    if (summaryButton && !summaryButton.hasAttribute('data-listener-attached')) {
        summaryButton.setAttribute('data-listener-attached', 'true');
        summaryButton.addEventListener('click', function(event) {
            event.preventDefault();
            event.stopPropagation();
            showLocationSummary(location.id);
        });
    }
}

// Function to close all popups
function closeAllPopups() {
    activePopups.forEach(marker => {
        if (marker.isPopupOpen()) {
            marker.closePopup();
        }
    });
    activePopups.clear();
}

// Navigation modal function with user location, proper reminder modal, manual forwarding, and responsive design
function showNavigationModal(destinationLat, destinationLng) {
    // Get user's current location first, then show the modal
    if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(
            (position) => {
                const userLat = position.coords.latitude;
                const userLng = position.coords.longitude;
                createNavigationModal(destinationLat, destinationLng, userLat, userLng);
            },
            (error) => {
                // Fallback if location access is denied
                console.log("Location access denied, using destination only");
                createNavigationModal(destinationLat, destinationLng, null, null);
            }
        );
    } else {
        // Fallback for browsers that don't support geolocation
        createNavigationModal(destinationLat, destinationLng, null, null);
    }
}

// Navigation modal function with immediate modal display and background location fetching
function showNavigationModal(destinationLat, destinationLng) {
   // Close all popups first
   closeAllPopups();
   
   // Remove any existing modals
   const existingModals = document.querySelectorAll('.modal');
   existingModals.forEach(modal => modal.remove());
   
   // Show modal immediately
   const modal = document.createElement("div");
   modal.className = "modal";
   modal.style.cssText = `
       position: fixed;
       top: 0;
       left: 0;
       width: 100%;
       height: 100%;
       background-color: rgba(0, 0, 0, 0.5);
       display: flex;
       justify-content: center;
       align-items: center;
       z-index: 10000;
       opacity: 0;
       transition: opacity 0.3s ease;
       margin: 0;
       padding: 0;
       box-sizing: border-box;
   `;
   
   modal.innerHTML = `
       <div class="modal-content" style="
           background-color: white;
           border-radius: 12px;
           padding: 20px;
           width: 90%;
           max-width: 400px;
           min-width: 280px;
           box-shadow: 0 10px 30px rgba(0,0,0,0.3);
           position: relative;
           transform: scale(0.9);
           transition: transform 0.3s ease;
           margin: 0;
           box-sizing: border-box;
       ">
           <h3 style="
               margin: 0 0 20px 0;
               text-align: center;
               color: #333;
               font-size: 1.2rem;
               font-weight: 600;
           ">Choose your preferred navigation app:</h3>
           <div class="modal-buttons" style="
               display: flex;
               flex-direction: column;
               align-items: center;
               gap: 12px;
               width: 100%;
               text-align: center;
           ">
               <button class="modal-button google-maps" style="
                   padding: 14px 20px;
                   margin: 0;
                   border: none;
                   border-radius: 8px;
                   cursor: pointer;
                   font-size: 1rem;
                   font-weight: 600;
                   transition: all 0.2s ease;
                   background-color: #4285F4;
                   color: white;
                   width: 100%;
                   display: flex;
                   align-items: center;
                   justify-content: center;
                   gap: 8px;
                   box-sizing: border-box;
               ">
                   <i class="fab fa-google" style="font-size: 1.1rem;"></i>
                   <span class="btn-text">Google Maps</span>
                   <i class="fas fa-spinner fa-spin location-spinner" style="font-size: 1rem; display: none; margin-left: 8px;"></i>
               </button>
               <button class="modal-button waze" style="
                   padding: 14px 20px;
                   margin: 0;
                   border: none;
                   border-radius: 8px;
                   cursor: pointer;
                   font-size: 1rem;
                   font-weight: 600;
                   transition: all 0.2s ease;
                   background-color: #00D4FF;
                   color: white;
                   width: 100%;
                   display: flex;
                   align-items: center;
                   justify-content: center;
                   gap: 8px;
                   box-sizing: border-box;
               ">
                   <i class="fas fa-route" style="font-size: 1rem;"></i>
                   <span class="btn-text">Waze</span>
                   <i class="fas fa-spinner fa-spin location-spinner" style="font-size: 1rem; display: none; margin-left: 8px;"></i>
               </button>
               <button class="modal-button apple-maps" style="
                   padding: 14px 20px;
                   margin: 0;
                   border: none;
                   border-radius: 8px;
                   cursor: pointer;
                   font-size: 1rem;
                   font-weight: 600;
                   transition: all 0.2s ease;
                   background-color: #007AFF;
                   color: white;
                   width: 100%;
                   display: flex;
                   align-items: center;
                   justify-content: center;
                   gap: 8px;
                   box-sizing: border-box;
               ">
                   <i class="fab fa-apple" style="font-size: 1.1rem;"></i>
                   <span class="btn-text">Apple Maps</span>
                   <i class="fas fa-spinner fa-spin location-spinner" style="font-size: 1rem; display: none; margin-left: 8px;"></i>
               </button>
               <button class="modal-button cancel" style="
                   padding: 14px 20px;
                   margin: 8px 0 0 0;
                   border: 2px solid #ddd;
                   border-radius: 8px;
                   cursor: pointer;
                   font-size: 1rem;
                   font-weight: 600;
                   transition: all 0.2s ease;
                   background-color: white;
                   color: #666;
                   width: 100%;
                   box-sizing: border-box;
               ">Cancel</button>
           </div>
       </div>
   `;
   
   document.body.appendChild(modal);
   
   // Trigger animation immediately
   setTimeout(() => {
       modal.style.opacity = "1";
       modal.querySelector(".modal-content").style.transform = "scale(1)";
   }, 10);
   
   // Get location in background while modal is displayed
   let userLat = null;
   let userLng = null;
   let locationAttempted = false;
   
   const getUserLocation = () => {
       if (locationAttempted) return Promise.resolve();
       locationAttempted = true;
       
       return new Promise((resolve) => {
           if (navigator.geolocation) {
               navigator.geolocation.getCurrentPosition(
                   (position) => {
                       userLat = position.coords.latitude;
                       userLng = position.coords.longitude;
                       resolve();
                   },
                   (error) => {
                       console.log("Location access denied or failed");
                       resolve(); // Still resolve to continue
                   },
                   {
                       timeout: 5000, // 5 second timeout
                       enableHighAccuracy: false // Faster, less accurate location
                   }
               );
           } else {
               resolve();
           }
       });
   };
   
   const closeModal = () => {
       modal.style.opacity = "0";
       modal.querySelector(".modal-content").style.transform = "scale(0.9)";
       setTimeout(() => {
           if (modal.parentNode) {
               modal.remove();
           }
       }, 300);
   };
   
   // Show reminder modal and handle navigation
   const showReminderModal = (navigationUrl) => {
       const reminderModal = document.createElement("div");
       reminderModal.className = "reminder-modal";
       reminderModal.style.cssText = `
           position: fixed;
           top: 0;
           left: 0;
           width: 100%;
           height: 100%;
           background-color: rgba(0, 0, 0, 0.7);
           backdrop-filter: blur(4px);
           display: flex;
           justify-content: center;
           align-items: center;
           z-index: 10001;
           opacity: 0;
           transition: opacity 0.3s ease;
       `;
       
       reminderModal.innerHTML = `
           <div class="reminder-content" style="
               background-color: white;
               border-radius: 16px;
               padding: 24px;
               width: 90%;
               max-width: 400px;
               min-width: 280px;
               box-shadow: 0 15px 40px rgba(0,0,0,0.2);
               text-align: center;
               transform: translateY(20px);
               transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
           ">
               <div style="
                   width: 60px;
                   height: 60px;
                   background-color: #2c5282;
                   border-radius: 50%;
                   display: flex;
                   align-items: center;
                   justify-content: center;
                   margin: 0 auto 20px;
               ">
                   <i class="fas fa-map-marker-alt" style="color: white; font-size: 24px;"></i>
               </div>
               <h3 style="
                   margin: 0 0 15px 0;
                   color: #2c3e50;
                   font-size: 1.3rem;
                   font-weight: 600;
               ">Navigation Reminder</h3>
               <p style="
                   margin: 0 0 25px 0;
                   color: #5c6c7c;
                   line-height: 1.5;
                   font-size: 1rem;
               ">Remember to return to this map when you arrive at your destination to continue exploring!</p>
               <button class="reminder-ok-btn" style="
                   padding: 12px 30px;
                   background-color: #2c5282;
                   color: white;
                   border: none;
                   border-radius: 10px;
                   cursor: pointer;
                   font-size: 1rem;
                   font-weight: 600;
                   transition: all 0.2s ease;
                   min-width: 120px;
               ">Got it!</button>
           </div>
       `;
       
       document.body.appendChild(reminderModal);
       
       // Trigger animation
       setTimeout(() => {
           reminderModal.style.opacity = "1";
           reminderModal.querySelector(".reminder-content").style.transform = "translateY(0)";
       }, 10);
       
       // Button hover effect
       const okBtn = reminderModal.querySelector(".reminder-ok-btn");
       okBtn.addEventListener("mouseover", function() {
           this.style.backgroundColor = "#0d2c6e";
       });
       okBtn.addEventListener("mouseout", function() {
           this.style.backgroundColor = "#2c5282";
       });
       
       // Close reminder modal and navigate
       const closeReminderAndNavigate = () => {
           reminderModal.style.opacity = "0";
           reminderModal.querySelector(".reminder-content").style.transform = "translateY(20px)";
           setTimeout(() => {
               if (reminderModal.parentNode) {
                   reminderModal.remove();
               }
               // Open navigation app ONLY after modal is closed
               window.open(navigationUrl, '_blank');
           }, 300);
       };
       
       // Only navigate when user clicks "Got it!"
       okBtn.addEventListener("click", closeReminderAndNavigate);
   };
   
   // Handle navigation button clicks with loading states
   const handleNavigation = async (button, appType) => {
       // Show spinner
       const spinner = button.querySelector('.location-spinner');
       const btnText = button.querySelector('.btn-text');
       
       spinner.style.display = 'inline-block';
       button.style.opacity = '0.8';
       button.style.cursor = 'wait';
       btnText.textContent = 'Getting location...';
       
       // Get location (will be instant if already fetched)
       await getUserLocation();
       
       // Generate URL based on app type
       let navigationUrl;
       if (appType === 'google') {
           if (userLat && userLng) {
               navigationUrl = `https://www.google.com/maps/dir/${userLat},${userLng}/${destinationLat},${destinationLng}`;
           } else {
               navigationUrl = `https://www.google.com/maps/dir/?api=1&destination=${destinationLat},${destinationLng}`;
           }
       } else if (appType === 'waze') {
           if (userLat && userLng) {
               navigationUrl = `https://www.waze.com/ul?ll=${destinationLat}%2C${destinationLng}&navigate=yes&from=${userLat}%2C${userLng}`;
           } else {
               navigationUrl = `https://www.waze.com/ul?ll=${destinationLat}%2C${destinationLng}&navigate=yes`;
           }
       } else if (appType === 'apple') {
           const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
           if (!isIOS) {
               closeModal();
               showPopup('Info', 'Apple Maps is only available on iOS devices');
               return;
           }
           if (userLat && userLng) {
               navigationUrl = `maps://maps.apple.com/?saddr=${userLat},${userLng}&daddr=${destinationLat},${destinationLng}`;
           } else {
               navigationUrl = `maps://maps.apple.com/?daddr=${destinationLat},${destinationLng}`;
           }
       }
       
       closeModal();
       showReminderModal(navigationUrl);
   };
   
   // Add hover effects and click handlers
   const googleMapsBtn = modal.querySelector('.google-maps');
   const wazeBtn = modal.querySelector('.waze');
   const appleMapsBtn = modal.querySelector('.apple-maps');
   const cancelBtn = modal.querySelector('.cancel');
   
   // Start getting location immediately in background
   getUserLocation();
   
   // Google Maps hover and click
   googleMapsBtn.addEventListener('mouseover', function() {
       if (this.style.cursor !== 'wait') {
           this.style.backgroundColor = '#3367D6';
           this.style.transform = 'translateY(-1px)';
       }
   });
   googleMapsBtn.addEventListener('mouseout', function() {
       if (this.style.cursor !== 'wait') {
           this.style.backgroundColor = '#4285F4';
           this.style.transform = 'translateY(0)';
       }
   });
   googleMapsBtn.addEventListener('click', () => handleNavigation(googleMapsBtn, 'google'));
   
   // Waze hover and click
   wazeBtn.addEventListener('mouseover', function() {
       if (this.style.cursor !== 'wait') {
           this.style.backgroundColor = '#00B8E6';
           this.style.transform = 'translateY(-1px)';
       }
   });
   wazeBtn.addEventListener('mouseout', function() {
       if (this.style.cursor !== 'wait') {
           this.style.backgroundColor = '#00D4FF';
           this.style.transform = 'translateY(0)';
       }
   });
   wazeBtn.addEventListener('click', () => handleNavigation(wazeBtn, 'waze'));
   
   // Apple Maps hover and click
   appleMapsBtn.addEventListener('mouseover', function() {
       if (this.style.cursor !== 'wait') {
           this.style.backgroundColor = '#0056CC';
           this.style.transform = 'translateY(-1px)';
       }
   });
   appleMapsBtn.addEventListener('mouseout', function() {
       if (this.style.cursor !== 'wait') {
           this.style.backgroundColor = '#007AFF';
           this.style.transform = 'translateY(0)';
       }
   });
   appleMapsBtn.addEventListener('click', () => handleNavigation(appleMapsBtn, 'apple'));
   
   // Cancel hover and click
   cancelBtn.addEventListener('mouseover', function() {
       this.style.backgroundColor = '#f5f5f5';
       this.style.borderColor = '#bbb';
   });
   cancelBtn.addEventListener('mouseout', function() {
       this.style.backgroundColor = 'white';
       this.style.borderColor = '#ddd';
   });
   cancelBtn.addEventListener('click', closeModal);
   
   modal.addEventListener('click', (e) => {
       if (e.target === modal) {
           closeModal();
       }
   });
}

function loadAllLocations() {
    if (!gameLocations || !Array.isArray(gameLocations) || gameLocations.length === 0) {
        console.error("No locations available to load");
        showPopup("Error", "No locations available. Please try reloading the page.");
        return;
    }
    
    createMarkersOnly();
    updateDistanceBox();
    resetInactivityTimer();
}

// Improved visibility and focus handlers
let visibilityTimeout;
document.addEventListener('visibilitychange', function() {
    if (!document.hidden) {
        if (visibilityTimeout) {
            clearTimeout(visibilityTimeout);
        }
        
        visibilityTimeout = setTimeout(() => {
            recenterOnUser();
            if (markerClusterGroup && markerClusterGroup.getLayers().length === 0) {
                createMarkersOnly();
            }
        }, 300);
    }
});

window.addEventListener('focus', function() {
    recenterOnUser();
});

// Add this function to handle recentering with popup closure
function recenterMapAndClosePopups() {
    closeAllPopups();          // close every open popup

    if (userMarker) {
        const userPos = userMarker.getLatLng();
        if (userPos && userPos.lat && userPos.lng) {
            map.flyTo(userPos, map.getZoom(), {
                animate: true,
                duration: 1.0,
                easeLinearity: 0.25
            });
        }
    }
}

function returnToIndex() {
   // Hide the distance box when overlay appears
   const distanceBox = document.querySelector('#distanceBox'); 
   if (distanceBox) {
       distanceBox.style.display = 'none';
   }

   // Create popup with proper centering and animation
   const popupDiv = document.createElement("div");
   popupDiv.style.cssText = `
       position: fixed;
       top: 0;
       left: 0;
       width: 100%;
       height: 100%;
       background-color: rgba(0,0,0,0.6);
       backdrop-filter: blur(4px);
       display: flex;
       justify-content: center;
       align-items: center;
       z-index: 1000;
       opacity: 0;
       transition: opacity 0.3s ease;
   `;
   // Using var(--dark-blue) as the dark blue color
   const darkBlue = "var(--dark-blue)";
   const darkBlueHover = "var(--dark-blue-hover)";
   popupDiv.innerHTML = `
       <div class="modal-container" style="
       background-color: white;
       border-radius: 16px;
       padding: 28px;
       width: 90%;
       max-width: 420px;
       max-height: 90vh;
       box-shadow: 0 15px 40px rgba(0,0,0,0.2);
       margin: auto;
       transform: translateY(20px);
       transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
       overflow: hidden;
       display: flex;
       flex-direction: column;
       ">
       <div style="
           text-align: center;
           margin-bottom: 25px;
       ">
        <svg width="50" height="50" viewBox="0 0 24 24" fill="none" xmlns="https://www.w3.org/2000/svg">
           <circle cx="12" cy="12" r="10" stroke="${darkBlue}" stroke-width="1.5"/>
           <path d="M12 8V13" stroke="${darkBlue}" stroke-width="2" stroke-linecap="round"/>
           <circle cx="12" cy="16" r="1" fill="${darkBlue}"/>
        </svg>
       </div>
       <h3 style="
           text-align: center;
           margin: 0 0 15px 0;
           color: #2c3e50;
           font-size: 1.5rem;
           font-weight: 600;
       ">Ready to Leave?</h3>
       <div style="flex-grow: 1; overflow-y: auto; padding: 0 10px;">
           <p style="
           text-align: center;
           margin: 0 0 30px 0;
           color: #5c6c7c;
           line-height: 1.5;
           font-size: 1rem;
           ">Are you sure you want to return to the main page?</p>
       </div>
       <div style="
           display: flex;
           justify-content: center;
           gap: 15px;
           margin-bottom: 15px;
       ">
           <button class="confirm-btn" style="
           padding: 14px 24px;
           background-color: ${darkBlue};
           color: white;
           border: none;
           border-radius: 10px;
           cursor: pointer;
           font-size: 1rem;
           font-weight: 600;
           min-width: 130px;
           transition: all 0.2s ease;
           ">Yes, Exit</button>
           <button class="cancel-btn" style="
           padding: 14px 24px;
           background-color: transparent;
           color: ${darkBlue};
           border: 1.5px solid ${darkBlue};
           border-radius: 10px;
           cursor: pointer;
           font-size: 1rem;
           font-weight: 600;
           min-width: 130px;
           transition: all 0.2s ease;
           ">Stay Here</button>
       </div>
       <div style="text-align: center; margin-top: 15px;">
           <a href="#" class="credits-link" style="
           display: inline-block;
           text-align: center;
           color: #64748b;
           text-decoration: none;
           font-size: 0.9rem;
           padding: 8px 20px;
           border-radius: 100px;
           border: 1px solid rgba(100, 116, 139, 0.2);
           background-color: rgba(100, 116, 139, 0.05);
           transition: all 0.2s ease;
           ">View Acknowledgements</a>
       </div>
       </div>
   `;
   document.body.appendChild(popupDiv);
   // Trigger animation
   setTimeout(() => {
       popupDiv.style.opacity = "1";
       popupDiv.querySelector(".modal-container").style.transform = "translateY(0)";
   }, 10);
   // Button hover effects
   const confirmBtn = popupDiv.querySelector(".confirm-btn");
   confirmBtn.addEventListener("mouseover", function() {
       this.style.backgroundColor = darkBlueHover;
   });
   confirmBtn.addEventListener("mouseout", function() {
       this.style.backgroundColor = darkBlue;
   });
   const cancelBtn = popupDiv.querySelector(".cancel-btn");
   cancelBtn.addEventListener("mouseover", function() {
       this.style.backgroundColor = "rgba(26, 58, 138, 0.05)";
   });
   cancelBtn.addEventListener("mouseout", function() {
       this.style.backgroundColor = "transparent";
   });
   const creditsLink = popupDiv.querySelector(".credits-link");
   creditsLink.addEventListener("mouseover", function() {
       this.style.backgroundColor = "rgba(100, 116, 139, 0.1)";
       this.style.borderColor = "rgba(100, 116, 139, 0.3)";
   });
   creditsLink.addEventListener("mouseout", function() {
       this.style.backgroundColor = "rgba(100, 116, 139, 0.05)";
       this.style.borderColor = "rgba(100, 116, 139, 0.2)";
   });
   // Event listeners
   confirmBtn.addEventListener("click", function() {
       popupDiv.style.opacity = "0";
       popupDiv.querySelector(".modal-container").style.transform = "translateY(20px)";
       setTimeout(() => {
           document.body.removeChild(popupDiv);
           window.location.href = "/index.html";
       }, 300);
   });
   cancelBtn.addEventListener("click", function() {
       popupDiv.style.opacity = "0";
       popupDiv.querySelector(".modal-container").style.transform = "translateY(20px)";
       setTimeout(() => {
           document.body.removeChild(popupDiv);
           // Show the distance box again when user cancels
           if (distanceBox) {
               distanceBox.style.display = 'block';
           }
       }, 300);
   });
   creditsLink.addEventListener("click", function(e) {
       e.preventDefault();
       // Simplified credits popup with dark blue
       const creditsPopup = document.createElement("div");
       creditsPopup.style.cssText = `
           position: fixed;
           top: 0;
           left: 0;
           width: 100%;
           height: 100%;
           background-color: rgba(0,0,0,0.7);
           backdrop-filter: blur(6px);
           display: flex;
           justify-content: center;
           align-items: center;
           z-index: 1001;
           opacity: 0;
           transition: opacity 0.3s ease;
       `;
       creditsPopup.innerHTML = `
           <div class="credits-container" style="
               background-color: white;
               border-radius: 16px;
               width: 92%;
               max-width: 450px;
               max-height: 80vh;
               box-shadow: 0 20px 50px rgba(0,0,0,0.25);
               margin: auto;
               transform: translateY(20px);
               transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
               overflow: hidden;
               display: flex;
               flex-direction: column;
           ">
               <div style="
                   background-color: ${darkBlue};
                   padding: 20px;
                   color: white;
                   text-align: center;
               ">
                   <h3 style="margin: 0; font-size: 1.5rem; font-weight: 600;">Acknowledgements</h3>
               </div>
               <div style="
                   padding: 20px;
                   flex-grow: 1;
                   overflow-y: auto;
               ">
                   <ul style="list-style-type: none; padding: 0; margin: 0;">
                       <li style="margin-bottom: 20px;">
                           <strong style="color: #1e293b; font-size: 1.05rem;">OpenStreetMap</strong>
                           <p style="color: #64748b; margin: 5px 0 0 0; font-size: 0.9rem; line-height: 1.5;">
                               Providing the map data and tiles for this interactive experience.
                           </p>
                       </li>
                       <li style="margin-bottom: 20px;">
                           <strong style="color: #1e293b; font-size: 1.05rem;">Minnesota Historical Society</strong>
                           <p style="color: #64748b; margin: 5px 0 0 0; font-size: 0.9rem; line-height: 1.5;">
                               For their invaluable historical data, photographs, and archive materials.
                           </p>
                       </li>
                       <li style="margin-bottom: 20px;">
                           <strong style="color: #1e293b; font-size: 1.05rem;">Metropolitan State University</strong>
                           <p style="color: #64748b; margin: 5px 0 0 0; font-size: 0.9rem; line-height: 1.5;">
                               For fostering a passion for history and research methodology.
                           </p>
                       </li>
                       <li style="margin-bottom: 20px;">
                           <strong style="color: #1e293b; font-size: 1.05rem;">Leaflet.js</strong>
                           <p style="color: #64748b; margin: 5px 0 0 0; font-size: 0.9rem; line-height: 1.5;">
                               The open-source JavaScript library that powers the mapping features.
                           </p>
                       </li>
                       <li>
                           <strong style="color: #1e293b; font-size: 1.05rem;">All Contributors</strong>
                           <p style="color: #64748b; margin: 5px 0 0 0; font-size: 0.9rem; line-height: 1.5;">
                               Researchers, testers, and developers who made this project possible.
                           </p>
                       </li>
                   </ul>
               </div>
               <div style="padding: 15px; text-align: center; border-top: 1px solid #eee;">
                   <button class="close-credits-btn" style="
                       padding: 12px 30px;
                       background-color: ${darkBlue};
                       color: white;
                       border: none;
                       border-radius: 10px;
                       cursor: pointer;
                       font-size: 0.95rem;
                       font-weight: 600;
                       transition: background-color 0.2s ease;
                   ">Close</button>
               </div>
           </div>
       `;
       document.body.appendChild(creditsPopup);
       // Trigger animation
       setTimeout(() => {
           creditsPopup.style.opacity = "1";
           creditsPopup.querySelector(".credits-container").style.transform = "translateY(0)";
       }, 10);
       // Close button interaction
       const closeBtn = creditsPopup.querySelector(".close-credits-btn");
       closeBtn.addEventListener("mouseover", function() {
           this.style.backgroundColor = darkBlueHover;
       });
       closeBtn.addEventListener("mouseout", function() {
           this.style.backgroundColor = darkBlue;
       });
       closeBtn.addEventListener("click", function() {
           creditsPopup.style.opacity = "0";
           creditsPopup.querySelector(".credits-container").style.transform = "translateY(20px)";
           setTimeout(() => {
               document.body.removeChild(creditsPopup);
           }, 300);
       });
       // Close when clicking outside
       creditsPopup.addEventListener("click", function(e) {
           if (e.target === creditsPopup) {
               creditsPopup.style.opacity = "0";
               creditsPopup.querySelector(".credits-container").style.transform = "translateY(20px)";
               setTimeout(() => {
                   document.body.removeChild(creditsPopup);
               }, 300);
           }
       });
   });
   // Close when clicking outside
   popupDiv.addEventListener("click", function(e) {
       if (e.target === popupDiv) {
           popupDiv.style.opacity = "0";
           popupDiv.querySelector(".modal-container").style.transform = "translateY(20px)";
           setTimeout(() => {
               document.body.removeChild(popupDiv);
               // Show the distance box again when user clicks outside
               if (distanceBox) {
                   distanceBox.style.display = 'block';
               }
           }, 300);
       }
   });
}

// Returns true when the position is far enough from the last stored one
// AND enough time has passed since the last accepted update.
function isSignificantMovement(newPosition) {
    const now = Date.now();

    // First ever position ‚Üí always accept
    if (!lastPositionForJitter) {
        lastPositionForJitter = newPosition;
        lastSignificantMovement = now;
        return true;
    }

    const distance = calculateDistance(lastPositionForJitter, newPosition);
    const timeSinceLast = now - lastSignificantMovement;

    if (distance > CONFIG.JITTER_THRESHOLD && timeSinceLast > CONFIG.SIGNIFICANT_MOVEMENT_COOLDOWN) {
        lastPositionForJitter = newPosition;
        lastSignificantMovement = now;
        return true;
    }

    return false;
}

function resetInactivityTimer(isExplicitInteraction = true) {
    // Clear any previous timer
    clearTimeout(inactivityTimer);

    // Restart the idle timer
    inactivityTimer = setTimeout(() => {
        // Only act if the map is not being interacted with and the user marker exists
        if (!isMapInteracting && userMarker) {
            followUser = true;           // Re-enable auto-follow
            recenterMapAndClosePopups(); // Close popups + fly to user
        }
    }, CONFIG.INACTIVITY_TIMEOUT);

    // If this was a genuine user action, reset the interaction flag
    if (isExplicitInteraction) {
        isMapInteracting = false;
    }
}

function optimizeImages() {
  document.querySelectorAll('img:not([loading])').forEach(img => {
    // 1. Mark as lazy
    img.loading = 'lazy';

    // 2. If dimensions are missing, add them ASAP
    if (!img.hasAttribute('width') && !img.hasAttribute('height') && img.src) {
      if (img.complete) {
        // Image is already loaded or cached
        img.setAttribute('width', img.naturalWidth);
        img.setAttribute('height', img.naturalHeight);
      } else {
        // Wait for image to load
        img.addEventListener('load', () => {
          img.setAttribute('width', img.naturalWidth);
          img.setAttribute('height', img.naturalHeight);
        }, { once: true });
      }
    }
  });
}

function setupEventListeners() {
    // Enhanced state management with background handling
    let userPositionStored = false;
    let storedUserLat = null;
    let storedUserLng = null;
    let zoomInProgress = false;
    let mapInteractionState = {
        isDragging: false,
        isZooming: false,
        isTouching: false,
        lastInteraction: Date.now()
    };
    
    // Track visibility state
    let wasHidden = false;
    
    function storeUserPosition() {
        if (userPositionStored || zoomInProgress) return;
        
        try {
            let positionFound = false;
            
            // Try multiple sources in order of preference
            if (typeof currentLat === 'number' && typeof currentLng === 'number' && 
                !isNaN(currentLat) && !isNaN(currentLng)) {
                storedUserLat = currentLat;
                storedUserLng = currentLng;
                positionFound = true;
            } else if (window.userMarker && typeof window.userMarker.getLatLng === 'function') {
                const pos = window.userMarker.getLatLng();
                if (pos && typeof pos.lat === 'number' && typeof pos.lng === 'number') {
                    storedUserLat = pos.lat;
                    storedUserLng = pos.lng;
                    positionFound = true;
                }
            } else if (map && map.userMarker && typeof map.userMarker.getLatLng === 'function') {
                const pos = map.userMarker.getLatLng();
                if (pos && typeof pos.lat === 'number' && typeof pos.lng === 'number') {
                    storedUserLat = pos.lat;
                    storedUserLng = pos.lng;
                    positionFound = true;
                }
            }
            
            if (positionFound) {
                userPositionStored = true;
                console.debug('User position stored:', storedUserLat, storedUserLng);
            }
        } catch (error) {
            console.warn('Error storing user position:', error);
            resetPositionStorage();
        }
    }
    
    function restoreUserPosition() {
        if (!userPositionStored || storedUserLat === null || storedUserLng === null) return;
        
        try {
            // Safety checks before restoration
            if (!map || zoomInProgress) {
                console.debug('Skipping restore - map not ready or zoom in progress');
                return;
            }
            
            const currentZoom = map.getZoom();
            if (currentZoom >= 18) {
                console.warn('Skipping restore - zoom too high:', currentZoom);
                resetPositionStorage();
                return;
            }
            
            // Validate stored coordinates
            if (Math.abs(storedUserLat) > 90 || Math.abs(storedUserLng) > 180) {
                console.warn('Invalid stored coordinates, skipping restore');
                resetPositionStorage();
                return;
            }
            
            // Restore to all possible locations
            if (typeof currentLat !== 'undefined') {
                currentLat = storedUserLat;
            }
            if (typeof currentLng !== 'undefined') {
                currentLng = storedUserLng;
            }
            
            if (window.userMarker && typeof window.userMarker.setLatLng === 'function') {
                window.userMarker.setLatLng([storedUserLat, storedUserLng]);
            }
            
            if (map && map.userMarker && typeof map.userMarker.setLatLng === 'function') {
                map.userMarker.setLatLng([storedUserLat, storedUserLng]);
            }
            
            console.debug('User position restored:', storedUserLat, storedUserLng);
        } catch (error) {
            console.warn('Error restoring user position:', error);
        } finally {
            resetPositionStorage();
        }
    }
    
    function resetPositionStorage() {
        userPositionStored = false;
        storedUserLat = null;
        storedUserLng = null;
    }
    
    function resetAllState() {
        console.debug('Resetting all interaction state');
        resetPositionStorage();
        zoomInProgress = false;
        mapInteractionState = {
            isDragging: false,
            isZooming: false,
            isTouching: false,
            lastInteraction: Date.now()
        };
        
        // Clear any pending timers
        if (inactivityTimer) {
            clearTimeout(inactivityTimer);
            inactivityTimer = null;
        }
    }
    
    function handleInteractionStart(source) {
        console.debug('Interaction started:', source);
        followUser = false;
        isMapInteracting = true;
        mapInteractionState.lastInteraction = Date.now();
        
        if (inactivityTimer) {
            clearTimeout(inactivityTimer);
            inactivityTimer = null;
        }
    }
    
    function handleInteractionEnd(source, delay = 100) {
        console.debug('Interaction ended:', source);
        
        setTimeout(() => {
            // Only reset if no other interactions are active
            if (!mapInteractionState.isDragging && 
                !mapInteractionState.isZooming && 
                !mapInteractionState.isTouching) {
                isMapInteracting = false;
                if (typeof resetInactivityTimer === 'function') {
                    resetInactivityTimer();
                }
            }
        }, delay);
    }
    
    // Enhanced visibility change handler
    function handleVisibilityChange() {
        if (document.hidden) {
            wasHidden = true;
            console.debug('App went to background');
        } else if (wasHidden) {
            console.debug('App returned from background - resetting state');
            wasHidden = false;
            
            // Reset everything when returning from background
            setTimeout(() => {
                resetAllState();
                
                // Invalidate map size to handle any layout changes
                if (map && typeof map.invalidateSize === 'function') {
                    map.invalidateSize();
                }
                
                // Update any distance calculations
                if (typeof updateDistanceBox === 'function') {
                    updateDistanceBox();
                }
            }, 250);
        }
    }
    
    // Map drag events
    map.on('dragstart', () => {
        mapInteractionState.isDragging = true;
        handleInteractionStart('drag');
    });
    
    map.on('dragend', () => {
        mapInteractionState.isDragging = false;
        handleInteractionEnd('drag');
    });
    
    // Enhanced zoom event handling
    map.on('zoomstart', () => {
        console.debug('Zoom started');
        mapInteractionState.isZooming = true;
        zoomInProgress = true;
        storeUserPosition();
        handleInteractionStart('zoom');
    });
    
    map.on('zoomend', () => {
        console.debug('Zoom ended');
        
        // Use longer delay for zoom end to ensure everything is settled
        setTimeout(() => {
            mapInteractionState.isZooming = false;
            zoomInProgress = false;
            restoreUserPosition();
            handleInteractionEnd('zoom', 50);
        }, 300);
    });
    
    // Additional zoom safety net
    map.on('zoom', () => {
        // If we get a zoom event without zoomstart, something went wrong
        if (!mapInteractionState.isZooming && !zoomInProgress) {
            console.warn('Zoom event without zoomstart detected - resetting');
            resetPositionStorage();
        }
    });
    
    // Enhanced touch handling
    let touchStartPos = null;
    let touchStartTime = 0;
    let multiTouchActive = false;
    
    document.addEventListener('touchstart', (e) => {
        touchStartTime = Date.now();
        
        if (e.touches.length === 1) {
            touchStartPos = {
                x: e.touches[0].clientX,
                y: e.touches[0].clientY
            };
            multiTouchActive = false;
        } else if (e.touches.length >= 2) {
            // Multi-touch (pinch/zoom) detected
            multiTouchActive = true;
            mapInteractionState.isTouching = true;
            touchStartPos = null;
            handleInteractionStart('multitouch');
        }
    }, { passive: true });
    
    document.addEventListener('touchmove', (e) => {
        if (multiTouchActive) return;
        
        if (e.touches.length === 1 && touchStartPos) {
            const dx = e.touches[0].clientX - touchStartPos.x;
            const dy = e.touches[0].clientY - touchStartPos.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // More sensitive touch detection
            if (distance > 8) {
                mapInteractionState.isTouching = true;
                handleInteractionStart('touch');
                touchStartPos = null; // Prevent multiple triggers
            }
        }
    }, { passive: true });
    
    document.addEventListener('touchend', (e) => {
        const touchDuration = Date.now() - touchStartTime;
        
        if (e.touches.length === 0) {
            // All touches ended
            if (mapInteractionState.isTouching || multiTouchActive) {
                mapInteractionState.isTouching = false;
                multiTouchActive = false;
                handleInteractionEnd('touch', touchDuration < 200 ? 50 : 150);
            }
            touchStartPos = null;
        }
    }, { passive: true });
    
    // Handle touch cancellation (e.g., when switching apps)
    document.addEventListener('touchcancel', () => {
        console.debug('Touch cancelled - resetting touch state');
        mapInteractionState.isTouching = false;
        multiTouchActive = false;
        touchStartPos = null;
        handleInteractionEnd('touchcancel');
    }, { passive: true });
    
    // Button event listeners with error handling
    function safeAddEventListener(elementId, event, handler) {
        const element = document.getElementById(elementId);
        if (element) {
            element.addEventListener(event, handler);
        } else {
            console.warn(`Element ${elementId} not found for event listener`);
        }
    }
    
    safeAddEventListener('recenterButton', 'click', () => {
        if (typeof recenterMap === 'function') {
            recenterMap();
        }
    });
    
    safeAddEventListener('returnButton', 'click', () => {
        if (typeof returnToIndex === 'function') {
            returnToIndex();
        }
    });
    
    safeAddEventListener('tipsButton', 'click', () => {
        if (typeof showNavigationTips === 'function') {
            showNavigationTips();
        }
    });
    
    // Contrast toggle with cached elements check
    const contrastToggle = cachedElements && cachedElements.contrastToggle;
    if (contrastToggle) {
        contrastToggle.addEventListener('click', () => {
            if (typeof toggleHighContrast === 'function') {
                toggleHighContrast();
            }
        });
        
        // Apply saved high contrast state
        if (accessibilityState && accessibilityState.highContrast) {
            document.body.classList.add('high-contrast');
        }
    }
    
    // Enhanced visibility change listener
    document.addEventListener('visibilitychange', handleVisibilityChange);
    
    // Window resize handler with debouncing
    let resizeTimeout;
    window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
            if (map && typeof map.invalidateSize === 'function') {
                map.invalidateSize();
            }
            if (typeof updateDistanceBox === 'function') {
                updateDistanceBox();
            }
        }, 150);
    });
    
    // Emergency cleanup on page unload
    window.addEventListener('beforeunload', () => {
        resetAllState();
    });
    
    console.debug('Event listeners setup complete');
}

// Enhanced initialization
document.addEventListener('DOMContentLoaded', () => {
    console.debug('DOM loaded - initializing application');
    
    try {
        // Cache elements first
        if (typeof cacheElements === 'function') {
            cacheElements();
        }
        
        // Initialize map
        if (typeof initMap === 'function') {
            initMap();
        }
        
        // Setup event listeners
        setupEventListeners();
        
        // Optimize images if function exists
        if (typeof optimizeImages === 'function') {
            optimizeImages();
        }
        
        // Hide containers that should start hidden
        const elementsToHide = ['additionalInfoContainer', 'lochuntContainer'];
        elementsToHide.forEach(elementKey => {
            const element = cachedElements && cachedElements[elementKey];
            if (element) {
                element.style.display = 'none';
            }
        });
        
        console.debug('Application initialization complete');
        
    } catch (error) {
        console.error('Error during application initialization:', error);
    }
});
    </script>
</body>
</html>
