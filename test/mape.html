<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#2c5282">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Minnesota Then | Self-Guided Tours</title>
    <link rel="shortcut icon" type="image/x-icon" href="https://www.mnthen.com/images/mnthenfav.ico">
    <link rel="manifest" href="data:application/json;base64,eyJuYW1lIjoiTWlubmVzb3RhIFRoZW4gVG91cnMiLCJzaG9ydF9uYW1lIjoiTU4gVGhlbiIsImRlc2NyaXB0aW9uIjoiU2VsZi1ndWlkZWQgdG91cnMgb2YgaGlzdG9yaWMgTWlubmVzb3RhIiwic3RhcnRfdXJsIjoiLyIsImRpc3BsYXkiOiJzdGFuZGFsb25lIiwiYmFja2dyb3VuZF9jb2xvciI6IiNmZmZmZmYiLCJ0aGVtZV9jb2xvciI6IiMyYzUyODIiLCJpY29ucyI6W3sic3JjIjoiaHR0cHM6Ly93d3cubW50aGVuLmNvbS9pbWFnZXMvaWNvbi0xOTJ4MTkyLnBuZyIsInNpemVzIjoiMTkyeDE5MiIsInR5cGUiOiJpbWFnZS9wbmcifSx7InNyYyI6Imh0dHBzOi8vd3d3Lm1udGhlbi5jb20vaW1hZ2VzL2ljb24tNTEyeDUxMi5wbmciLCJzaXplcyI6IjUxMng1MTIiLCJ0eXBlIjoiaW1hZ2UvcG5nIn1dfQ==">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css">
    
<style>
/* Base styles */
:root {
--primary-color: #2c5282;
--primary-light: #3182ce;
--primary-dark: #1a365d;
--secondary-color: #e53e3e;
--secondary-light: #fc8181;
--secondary-dark: #c53030;
--accent-color: #38a169;
--accent-light: #68d391;
--accent-dark: #276749;
--text-color: #2d3748;
--text-light: #4a5568;
--text-lighter: #718096;
--bg-color: #ffffff;
--bg-light: #f7fafc;
--bg-dark: #edf2f7;
--shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
--shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
--shadow-md: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
--shadow-lg: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
--radius-sm: 0.125rem;
--radius: 0.25rem;
--radius-md: 0.375rem;
--radius-lg: 0.5rem;
--radius-xl: 1rem;
--radius-2xl: 1.5rem;
--transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
--transition-fast: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
--transition-slow: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
--font-sans: 'Segoe UI', -apple-system, BlinkMacSystemFont, 'Helvetica Neue', Arial, sans-serif;
}

* {
margin: 0;
padding: 0;
box-sizing: border-box;
}

body {
margin: 0;
padding: 0;
font-family: var(--font-sans);
overflow: hidden;
height: 100vh;
width: 100vw;
position: relative;
color: var(--text-color);
background-color: var(--bg-color);
-webkit-font-smoothing: antialiased;
-moz-osx-font-smoothing: grayscale;
touch-action: manipulation;
overscroll-behavior: none;
}

#map {
height: 100vh;
width: 100%;
z-index: 1;
}

/* Enhanced Distance box */
#distanceBox {
position: absolute;
top: 16px;
left: 16px;
background-color: rgba(255, 255, 255, 0.98);
padding: 16px 20px;
border-radius: var(--radius-lg);
box-shadow: var(--shadow-md);
z-index: 1000;
font-size: 20px;
font-weight: 600;
color: var(--text-color);
min-width: 200px;
max-width: 320px;
transition: var(--transition);
border-left: 6px solid var(--primary-color);
display: flex;
align-items: center;
backdrop-filter: blur(5px);
transform: translateZ(0);
}

#distanceBox .location-icon {
margin-right: 15px;
color: var(--primary-color);
font-size: 24px;
}

#distanceBox .distance-info {
display: flex;
flex-direction: column;
font-size: 20px;
}

#distanceBox .location-name {
font-weight: 700;
margin-bottom: 4px;
color: var(--primary-color);
font-size: 20px;
}

#distanceBox .distance-value {
font-size: 16px;
color: var(--text-light);
font-weight: 500;
}

/* Location hunt container */
.lochunt-container {
position: fixed;
bottom: 0;
left: 0;
width: 100%;
height: 80%;
background-color: var(--bg-color);
z-index: 1500;
border-radius: var(--radius-2xl) var(--radius-2xl) 0 0;
box-shadow: var(--shadow-lg);
transform: translateY(100%);
transition: transform 0.5s cubic-bezier(0.16, 1, 0.3, 1);
overflow: hidden;
display: none;
will-change: transform;
}

.lochunt-container.active {
transform: translateY(0);
display: block;
}

.lochunt-content {
padding: 24px;
overflow-y: auto;
height: calc(100% - 200px);
}

#locationImage {
width: 100%;
height: 200px;
object-fit: cover;
object-position: center;
}

.lochunt-info {
margin-bottom: 24px;
}

.lochunt-info h2 {
color: var(--primary-color);
margin-bottom: 8px;
font-weight: 700;
}

.lochunt-info p {
line-height: 1.6;
margin-bottom: 16px;
}

.text-muted {
color: var(--text-lighter);
font-size: 14px;
}

/* Audio player */
.audio-player {
margin-top: 24px;
padding: 20px;
background-color: var(--bg-light);
border-radius: var(--radius-lg);
box-shadow: var(--shadow-sm);
}

.audio-progress {
margin-bottom: 12px;
}

.progress {
height: 6px;
background-color: var(--bg-dark);
border-radius: var(--radius-xl);
overflow: hidden;
}

.progress-bar {
background-color: var(--primary-color);
height: 100%;
border-radius: var(--radius-xl);
transition: width 0.1s linear;
}

.audio-time {
display: flex;
justify-content: space-between;
font-size: 12px;
color: var(--text-lighter);
margin-bottom: 12px;
}

.audio-controls {
display: flex;
justify-content: space-between;
align-items: center;
max-width: 200px;
margin: 0 auto;
}

.audio-button {
background-color: var(--bg-color);
border: 2px solid var(--primary-color);
color: var(--primary-color);
width: 44px;
height: 44px;
border-radius: 50%;
display: flex;
align-items: center;
justify-content: center;
cursor: pointer;
transition: var(--transition-fast);
-webkit-tap-highlight-color: transparent;
}

.audio-button:hover, .audio-button:active {
background-color: var(--primary-color);
color: var(--bg-color);
transform: translateY(-2px);
}

/* Trivia container */
.trivia-container {
position: fixed;
bottom: 0;
left: 0;
width: 100%;
background-color: var(--bg-color);
z-index: 1500;
border-radius: var(--radius-2xl) var(--radius-2xl) 0 0;
box-shadow: var(--shadow-lg);
padding: 24px;
transform: translateY(100%);
transition: transform 0.5s cubic-bezier(0.16, 1, 0.3, 1);
display: none;
will-change: transform;
}

.trivia-container.active {
transform: translateY(0);
display: block;
}

.trivia-container h3 {
color: var(--primary-color);
margin-bottom: 16px;
font-weight: 700;
}

.trivia-option {
background-color: var(--bg-light);
border: 2px solid var(--bg-dark);
border-radius: var(--radius-lg);
padding: 16px;
margin-bottom: 12px;
cursor: pointer;
transition: var(--transition-fast);
font-weight: 500;
text-align: left;
width: 100%;
color: var(--text-color);
}

.trivia-option:hover, .trivia-option:active {
background-color: var(--bg-dark);
transform: translateY(-2px);
}

.trivia-option.correct {
background-color: var(--accent-light);
border-color: var(--accent-color);
color: var(--accent-dark);
}

.trivia-option.incorrect {
background-color: var(--secondary-light);
border-color: var(--secondary-color);
color: var(--secondary-dark);
}

/* Map buttons: horizontal and centered at bottom */
.map-buttons {
position: fixed; 
bottom: 40px; 
left: 50%;
transform: translateX(-50%);
display: flex;
flex-direction: row;
gap: 16px;
z-index: 1000;
background-color: rgba(255, 255, 255, 0.9);
padding: 12px 16px;
border-radius: var(--radius-xl);
box-shadow: var(--shadow-md);
backdrop-filter: blur(5px);
width: auto; /* Ensure width is based on content */
max-width: 90%; /* Prevent overflow on very small screens */
}

.map-button {
width: 50px;
height: 50px;
border-radius: 50%;
background-color: var(--bg-color);
border: none;
box-shadow: var(--shadow);
display: flex;
align-items: center;
justify-content: center;
font-size: 22px;
color: var(--primary-color);
cursor: pointer;
transition: var(--transition-fast);
-webkit-tap-highlight-color: transparent;
}

.map-button:hover, .map-button:active {
background-color: var(--primary-color);
color: var(--bg-color);
transform: scale(1.05);
box-shadow: var(--shadow-md);
}

.map-button.active {
background-color: var(--primary-color);
color: var(--bg-color);
}

/* Navigation tips */
.navigation-tips {
position: fixed;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
background-color: var(--bg-color);
border-radius: var(--radius-lg);
box-shadow: var(--shadow-lg);
padding: 24px;
z-index: 2000;
max-width: 90%;
width: 350px;
display: none;
}

.navigation-tips h3 {
margin-bottom: 16px;
color: var(--primary-color);
font-weight: 700;
}

.navigation-tips ul {
padding-left: 20px;
}

.navigation-tips li {
margin-bottom: 12px;
line-height: 1.5;
}

.close-button {
position: absolute;
top: 12px;
right: 12px;
background: none;
border: none;
font-size: 20px;
cursor: pointer;
color: var(--text-lighter);
transition: var(--transition-fast);
-webkit-tap-highlight-color: transparent;
}

.close-button:hover, .close-button:active {
color: var(--text-color);
}

/* Congratulations */
#congratulations {
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background-color: rgba(0, 0, 0, 0.85);
display: flex;
flex-direction: column;
align-items: center;
justify-content: center;
z-index: 3000;
color: var(--bg-color);
text-align: center;
padding: 24px;
display: none;
backdrop-filter: blur(5px);
}

#congratulations h2 {
font-size: 36px;
margin-bottom: 24px;
font-weight: 800;
}

#congratulations p {
font-size: 18px;
margin-bottom: 32px;
max-width: 600px;
line-height: 1.6;
}

#congratulations button {
background-color: var(--primary-color);
color: var(--bg-color);
border: none;
padding: 16px 32px;
border-radius: var(--radius-xl);
font-size: 18px;
font-weight: 600;
cursor: pointer;
transition: var(--transition);
box-shadow: var(--shadow);
}

#congratulations button:hover, #congratulations button:active {
background-color: var(--primary-dark);
transform: translateY(-3px);
box-shadow: var(--shadow-md);
}

/* Enhanced user marker styles */
.user-marker-icon {
width: 24px;
height: 24px;
background-color: var(--secondary-color);
border: 3px solid white;
border-radius: 50%;
box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
position: relative;
transition: transform 0.2s cubic-bezier(0.25, 0.1, 0.25, 1);
will-change: transform;
}

.user-marker-icon::after {
content: '';
position: absolute;
top: 50%;
left: 50%;
width: 36px;
height: 36px;
background-color: rgba(229, 62, 62, 0.2);
border-radius: 50%;
transform: translate(-50%, -50%);
animation: pulse 2s infinite;
will-change: transform, opacity;
}

@keyframes pulse {
0% {
transform: translate(-50%, -50%) scale(1);
opacity: 1;
}
100% {
transform: translate(-50%, -50%) scale(2);
opacity: 0;
}
}

/* Stationary indicator */
.user-marker-stationary .user-marker-icon {
border-color: var(--accent-color);
transition: border-color 0.5s ease-out;
}

.user-marker-stationary .user-marker-icon::after {
background-color: rgba(56, 161, 105, 0.15);
animation: stationaryPulse 3s infinite;
}

@keyframes stationaryPulse {
0% {
transform: translate(-50%, -50%) scale(1);
opacity: 0.6;
}
50% {
transform: translate(-50%, -50%) scale(1.3);
opacity: 0.3;
}
100% {
transform: translate(-50%, -50%) scale(1);
opacity: 0.6;
}
}

/* Optimize for hardware acceleration */
#map, .user-marker-icon, .lochunt-container, .trivia-container {
transform: translateZ(0);
backface-visibility: hidden;
perspective: 1000px;
}

/* Stabilizing modal */
.stabilizing-modal {
position: fixed;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
background-color: var(--bg-color);
padding: 24px;
border-radius: var(--radius-lg);
box-shadow: var(--shadow-lg);
z-index: 2000;
text-align: center;
max-width: 80%;
display: flex;
flex-direction: column;
align-items: center;
}

.stabilizing-modal h3 {
margin-bottom: 16px;
color: var(--primary-color);
font-weight: 700;
}

.stabilizing-modal p {
margin-bottom: 20px;
line-height: 1.5;
}

.stabilizing-modal .spinner {
width: 48px;
height: 48px;
border: 4px solid rgba(44, 82, 130, 0.2);
border-top: 4px solid var(--primary-color);
border-radius: 50%;
margin-bottom: 24px;
animation: spin 1s linear infinite;
}

@keyframes spin {
0% { transform: rotate(0deg); }
100% { transform: rotate(360deg); }
}

/* Preloader styles */
#preloader {
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background-color: var(--bg-color);
display: flex;
flex-direction: column;
justify-content: center;
align-items: center;
z-index: 9999;
}

#preloader .spinner {
width: 60px;
height: 60px;
border: 5px solid rgba(44, 82, 130, 0.2);
border-top: 5px solid var(--primary-color);
border-radius: 50%;
margin-bottom: 24px;
animation: spin 1s linear infinite;
}

#preloader p {
font-size: 18px;
color: var(--text-color);
margin-top: 16px;
font-weight: 500;
}

#preloader .progress-container {
width: 80%;
max-width: 300px;
height: 8px;
background-color: var(--bg-dark);
border-radius: var(--radius-xl);
margin-top: 20px;
overflow: hidden;
}

#preloader .progress-bar {
height: 100%;
background-color: var(--primary-color);
width: 0%;
transition: width 0.3s ease;
border-radius: var(--radius-xl);
}

/* Popup styles */
#popup {
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background-color: rgba(0, 0, 0, 0.5);
display: flex;
align-items: center;
justify-content: center;
z-index: 3000;
display: none;
backdrop-filter: blur(3px);
}

.popup-content {
background-color: var(--bg-color);
border-radius: var(--radius-lg);
padding: 24px;
max-width: 90%;
width: 350px;
text-align: center;
box-shadow: var(--shadow-lg);
}

#popupMessage {
margin-bottom: 24px;
line-height: 1.5;
}

.popup-button {
background-color: var(--primary-color);
color: var(--bg-color);
border: none;
padding: 12px 24px;
border-radius: var(--radius-lg);
font-weight: 600;
cursor: pointer;
transition: var(--transition);
}

.popup-button:hover, .popup-button:active {
background-color: var(--primary-dark);
transform: translateY(-2px);
}

/* Enhanced Location marker styles with numbering */
.location-marker-icon {
width: 40px;
height: 40px;
background-color: #006400;
border: 3px solid white;
border-radius: 50%;
box-shadow: var(--shadow);
position: relative;
transition: var(--transition);
display: flex;
align-items: center;
justify-content: center;
color: white;
font-weight: bold;
font-size: 16px;
}

.location-marker-icon:hover {
transform: scale(1.1);
background-color: var(--primary-dark);
}

/* Enhanced Marker popup styles */
.marker-popup {
max-width: 300px;
padding: 0;
}

.marker-popup-image {
width: 100%;
height: 150px;
object-fit: cover;
border-radius: var(--radius-lg) var(--radius-lg) 0 0;
margin-bottom: 0;
}

.marker-popup-content {
padding: 16px;
}

.marker-popup-title {
font-size: 18px;
font-weight: bold;
margin-bottom: 8px;
color: var(--primary-color);
}

.marker-popup-description {
font-size: 14px;
margin-bottom: 16px;
color: var(--text-light);
line-height: 1.5;
}

.marker-popup-actions {
display: flex;
justify-content: space-between;
gap: 12px;
}

.popup-btn {
padding: 10px 16px;
border-radius: var(--radius);
font-size: 14px;
font-weight: 600;
cursor: pointer;
text-align: center;
transition: var(--transition-fast);
display: flex;
align-items: center;
justify-content: center;
gap: 8px;
flex: 1;
}

.popup-btn.directions {
background-color: var(--primary-color);
color: white;
border: none;
}

.popup-btn.directions:hover, .popup-btn.directions:active {
background-color: var(--primary-dark);
transform: translateY(-2px);
}

.popup-btn.skip {
background-color: var(--bg-light);
color: var(--text-light);
border: 1px solid var(--bg-dark);
}

.popup-btn.skip:hover, .popup-btn.skip:active {
background-color: var(--bg-dark);
transform: translateY(-2px);
}

/* Directions modal */
#directionsModal {
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background-color: rgba(0, 0, 0, 0.5);
display: flex;
align-items: center;
justify-content: center;
z-index: 3000;
display: none;
backdrop-filter: blur(3px);
}

.directions-modal-content {
background-color: var(--bg-color);
border-radius: var(--radius-lg);
padding: 24px;
max-width: 90%;
width: 320px;
box-shadow: var(--shadow-lg);
}

.directions-modal-title {
font-size: 18px;
font-weight: 700;
margin-bottom: 20px;
color: var(--text-color);
text-align: center;
}

.directions-buttons {
display: flex;
flex-direction: column;
gap: 12px;
margin-bottom: 20px;
}

.direction-btn {
padding: 14px;
border-radius: var(--radius);
font-size: 16px;
font-weight: 600;
cursor: pointer;
text-align: center;
transition: var(--transition-fast);
display: flex;
align-items: center;
justify-content: center;
gap: 12px;
text-decoration: none;
}

.direction-btn.google {
background-color: #4285F4;
color: white;
border: none;
}

.direction-btn.apple {
background-color: #000000;
color: white;
border: none;
}

.direction-btn.waze {
background-color: #33CCFF;
color: white;
border: none;
}

.direction-btn:hover, .direction-btn:active {
transform: translateY(-2px);
box-shadow: var(--shadow);
}

.cancel-btn {
background-color: var(--bg-light);
color: var(--text-light);
border: 1px solid var(--bg-dark);
padding: 12px;
border-radius: var(--radius);
font-size: 16px;
font-weight: 600;
cursor: pointer;
text-align: center;
transition: var(--transition-fast);
width: 100%;
}

.cancel-btn:hover, .cancel-btn:active {
background-color: var(--bg-dark);
}

/* Leaflet popup customization */
.leaflet-popup-content-wrapper {
padding: 0;
overflow: hidden;
border-radius: var(--radius-lg);
box-shadow: var(--shadow-md);
}

.leaflet-popup-content {
margin: 0;
width: 280px !important;
}

.leaflet-popup-tip-container {
margin-top: -1px;
}

.leaflet-popup-close-button {
color: white !important;
top: 5px !important;
right: 5px !important;
font-size: 20px !important;
text-shadow: 0 0 3px rgba(0, 0, 0, 0.5);
}

/* Navigation buttons */
.marker-popup-navigation {
display: flex;
flex-direction: column;
gap: 10px;
margin-top: 16px;
}

.nav-button {
display: flex;
align-items: center;
justify-content: center;
gap: 8px;
padding: 10px;
border-radius: var(--radius);
text-decoration: none;
font-weight: 600;
font-size: 14px;
transition: var(--transition-fast);
}

.nav-button.google {
background-color: #4285F4;
color: white;
}

.nav-button.apple {
background-color: #000000;
color: white;
}

.nav-button.waze {
background-color: #33CCFF;
color: white;
}

.nav-button:hover, .nav-button:active {
transform: translateY(-2px);
box-shadow: var(--shadow);
}

/* Responsive adjustments */
@media (max-width: 768px) {
.map-buttons {
bottom: 30px; /* Adjust for medium screens */
padding: 10px 14px;
gap: 12px;
}

.map-button {
width: 46px;
height: 46px;
font-size: 20px;
}

#distanceBox {
max-width: 280px;
padding: 14px 16px;
}
}

@media (max-width: 480px) {
.map-buttons {
bottom: 25px; /* Increase from 20px to 25px for small screens */
padding: 8px 12px;
gap: 10px;
}

.map-button {
width: 40px; /* Slightly smaller buttons on very small screens */
height: 40px;
font-size: 16px;
}

#distanceBox {
max-width: 260px;
padding: 12px 14px;
left: 12px;
top: 12px;
font-size: 18px;
}

#distanceBox .location-icon {
font-size: 20px;
margin-right: 10px;
}

#distanceBox .location-name {
font-size: 18px;
}

#distanceBox .distance-value {
font-size: 16px;
}

.marker-popup {
max-width: 260px;
}

.marker-popup-image {
height: 130px;
}
}

/* Add a new media query for very small screens or devices with unusual interfaces */
@media (max-height: 600px), (max-width: 360px) {
.map-buttons {
bottom: 15px; /* Even more compact for very small screens */
}

.map-button {
width: 36px;
height: 36px;
font-size: 14px;
}
}

/* Add a safe area inset for iOS devices with notches */
@supports (padding-bottom: env(safe-area-inset-bottom)) {
.map-buttons {
bottom: calc(25px + env(safe-area-inset-bottom));
}
}

/* Debug overlay for development */
.debug-overlay {
position: fixed;
top: 10px;
right: 10px;
background-color: rgba(0, 0, 0, 0.7);
color: white;
padding: 10px;
border-radius: 5px;
font-size: 12px;
z-index: 2000;
max-width: 200px;
display: none;
}

/* Offline notification */
.offline-notification {
position: fixed;
top: 0;
left: 0;
width: 100%;
background-color: var(--secondary-color);
color: white;
text-align: center;
padding: 8px;
font-weight: bold;
z-index: 9000;
transform: translateY(-100%);
transition: transform 0.3s ease;
}

.offline-notification.visible {
transform: translateY(0);
}

/* Haptic feedback visual indicator */
.haptic-indicator {
position: fixed;
top: 50%;
left: 50%;
transform: translate(-50%, -50%) scale(0);
width: 100px;
height: 100px;
background-color: rgba(56, 161, 105, 0.3);
border-radius: 50%;
z-index: 1500;
pointer-events: none;
opacity: 0;
transition: transform 0.2s ease, opacity 0.2s ease;
}

.haptic-indicator.active {
transform: translate(-50%, -50%) scale(1);
opacity: 1;
animation: hapticPulse 0.5s ease-out;
}

@keyframes hapticPulse {
0% {
  transform: translate(-50%, -50%) scale(0.5);
  opacity: 0.8;
}
100% {
  transform: translate(-50%, -50%) scale(1.5);
  opacity: 0;
}
}

/* Orientation warning */
.orientation-warning {
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background-color: rgba(0, 0, 0, 0.9);
color: white;
display: flex;
flex-direction: column;
align-items: center;
justify-content: center;
z-index: 10000;
text-align: center;
padding: 20px;
display: none;
}

.orientation-warning h2 {
font-size: 24px;
margin-bottom: 20px;
}

.orientation-warning p {
font-size: 16px;
margin-bottom: 30px;
max-width: 300px;
}

.orientation-warning button {
background-color: var(--primary-color);
color: white;
border: none;
padding: 12px 24px;
border-radius: 5px;
font-weight: bold;
}

/* Improved user marker with direction indicator */
.user-marker-direction {
position: absolute;
top: 50%;
left: 50%;
width: 0;
height: 0;
border-left: 8px solid transparent;
border-right: 8px solid transparent;
border-bottom: 16px solid var(--secondary-color);
transform: translate(-50%, -50%) rotate(0deg);
transform-origin: center;
opacity: 0.9;
transition: transform 0.3s ease;
display: none;
}

.user-marker-icon.with-direction .user-marker-direction {
display: block;
}

/* Improved map attribution */
.leaflet-control-attribution {
background-color: rgba(255, 255, 255, 0.7) !important;
padding: 3px 8px !important;
border-radius: 4px !important;
font-size: 10px !important;
}
</style>

</head>
<body>
    <!-- Offline notification -->
    <div class="offline-notification" id="offlineNotification">
        You are currently offline. Some features may be limited.
    </div>

    <!-- Preloader -->
    <div id="preloader">
        <div class="spinner"></div>
        <p>Loading Minnesota Then Tours...</p>
        <div class="progress-container">
            <div class="progress-bar" id="preloaderProgress"></div>
        </div>
    </div>

    <div id="map"></div>
    
    <!-- Enhanced Distance Box -->
    <div id="distanceBox">
        <div class="location-icon">
            <i class="fas fa-map-marker-alt"></i>
        </div>
        <div class="distance-info">
            <div class="location-name">Initializing...</div>
            <div class="distance-value">Finding your location</div>
        </div>
    </div>
    
    <!-- Haptic feedback visual indicator -->
    <div class="haptic-indicator" id="hapticIndicator"></div>
    
    <div class="lochunt-container">
        <img id="locationImage" src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='400' height='200' viewBox='0 0 400 200'%3E%3Crect width='400' height='200' fill='%23f0f0f0'/%3E%3Ctext x='50%25' y='50%25' font-family='Arial' font-size='20' text-anchor='middle' dominant-baseline='middle' fill='%23999'%3ELoading image...%3C/text%3E%3C/svg%3E" alt="Location Image">
        <div class="lochunt-content">
            <div class="lochunt-info">
                <h2 id="locationTitle" class="mb-2"></h2>
                <p id="locationCity" class="text-muted mb-1"></p>
                <p id="locationCreator" class="text-muted mb-3"></p>
                <p id="locationDescription" class="mb-3"></p>
                
                <div class="marker-popup-navigation">
                    <a href="#" id="googleMapsLink" class="nav-button google" target="_blank">
                        <i class="fab fa-google"></i> Google Maps
                    </a>
                    <a href="#" id="appleMapsLink" class="nav-button apple" target="_blank">
                        <i class="fab fa-apple"></i> Apple Maps
                    </a>
                    <a href="#" id="wazeLink" class="nav-button waze" target="_blank">
                        <i class="fab fa-waze"></i> Waze
                    </a>
                </div>
            </div>
            <div class="audio-player">
                <div class="audio-progress">
                    <div class="progress">
                        <div id="progressBar" class="progress-bar" role="progressbar" style="width: 0%"></div>
                    </div>
                </div>
                <div class="audio-time">
                    <span id="currentTime">0:00</span>
                    <span id="duration">0:00</span>
                </div>
                <div class="audio-controls">
                    <button id="rewindBtn" class="audio-button"><i class="fas fa-backward"></i></button>
                    <button id="playPauseBtn" class="audio-button"><i class="fas fa-play"></i></button>
                    <button id="forwardBtn" class="audio-button"><i class="fas fa-forward"></i></button>
                </div>
                <audio id="locationAudio" preload="none"></audio>
            </div>
        </div>
    </div>
    
    <div class="trivia-container">
        <h3 class="mb-3">Trivia Question</h3>
        <p id="triviaQuestion" class="mb-3 fw-bold"></p>
        <div id="triviaOptions" class="d-grid gap-2"></div>
    </div>
    
    <!-- Enhanced Map Buttons: Horizontal and centered at bottom -->
    <div class="map-buttons">
        <button id="recenterButton" class="map-button" aria-label="Recenter map"><i class="fas fa-crosshairs"></i></button>
        <button id="returnButton" class="map-button" aria-label="Return to home"><i class="fas fa-sign-out-alt"></i></button>
        <button id="tipsButton" class="map-button" aria-label="Show tips"><i class="fas fa-question-circle"></i></button>
    </div>
    
    <div class="navigation-tips">
        <button class="close-button" aria-label="Close tips">&times;</button>
        <h3>Navigation Tips</h3>
        <ul>
            <li>Numbered markers show your tour stops in sequence.</li>
            <li>After visiting a location, the next stop will appear.</li>
            <li>Tap on a marker to see details and navigation options.</li>
            <li>The distance box shows how far you are from the current location.</li>
            <li>Tap the recenter button to focus on your position.</li>
            <li>When you're within 20 feet of a location, you'll be able to interact with it.</li>
            <li>Complete the trivia question to move to the next location.</li>
            <li>The map will automatically zoom in when you get closer to a location.</li>
        </ul>
    </div>
    
    <div id="congratulations">
        <h2>Congratulations!</h2>
        <p>You have successfully completed the Minnesota Then Gangster History Tour!</p>
        <button onclick="endTour()">Return to the Home Page</button>
    </div>
    
    <div id="popup">
        <div class="popup-content">
            <p id="popupMessage"></p>
            <button class="popup-button" onclick="closePopup()">OK</button>
        </div>
    </div>
    
    <!-- Directions Modal -->
    <div id="directionsModal">
        <div class="directions-modal-content">
            <div class="directions-modal-title">Choose Navigation App</div>
            <div class="directions-buttons">
                <a href="#" id="googleMapsBtn" class="direction-btn google" target="_blank">
                    <i class="fab fa-google"></i> Google Maps
                </a>
                <a href="#" id="appleMapsBtn" class="direction-btn apple" target="_blank">
                    <i class="fab fa-apple"></i> Apple Maps
                </a>
                <a href="#" id="wazeBtn" class="direction-btn waze" target="_blank">
                    <i class="fab fa-waze"></i> Waze
                </a>
            </div>
            <button class="cancel-btn" onclick="closeDirectionsModal()">Cancel</button>
        </div>
    </div>

    <!-- Orientation warning -->
    <div class="orientation-warning" id="orientationWarning">
        <h2>Please Enable Device Orientation</h2>
        <p>For the best experience, please allow access to your device's motion and orientation sensors.</p>
        <button id="orientationPermissionBtn">Enable Sensors</button>
    </div>

    <!-- Debug overlay -->
    <div class="debug-overlay" id="debugOverlay">
        <div id="debugInfo">Debug info will appear here</div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    
    <script>
        // Sample locations data (replace with your actual data)
        const locations = [
            {
                id: 1,
                name: "Landmark Center",
                city: "St. Paul",
                creator: "Minnesota Historical Society",
                lat: 44.9448,
                lng: -93.0962,
                image: "https://www.mnthen.com/images/landmark-center.jpg",
                audio: "https://www.mnthen.com/audio/landmark-center.mp3",
                description: "The Landmark Center, completed in 1902, originally served as the Federal Court House and Post Office for the Upper Midwest. This Richardsonian Romanesque building was where many famous gangsters were tried during the 1930s.",
                trivia: {
                    question: "What was the Landmark Center originally built as?",
                    options: [
                        "A hotel",
                        "A federal courthouse and post office",
                        "A train station",
                        "A department store"
                    ],
                    answer: 1
                }
            },
            {
                id: 2,
                name: "Wabasha Street Caves",
                city: "St. Paul",
                creator: "Minnesota Historical Society",
                lat: 44.9338,
                lng: -93.1059,
                image: "https://www.mnthen.com/images/wabasha-caves.jpg",
                audio: "https://www.mnthen.com/audio/wabasha-caves.mp3",
                description: "The Wabasha Street Caves were originally mined for silica in the 1840s. During Prohibition, the caves became a speakeasy known as the Castle Royal. Gangsters like John Dillinger and Ma Barker were rumored to frequent the establishment.",
                trivia: {
                    question: "What illegal activity took place in the Wabasha Street Caves during Prohibition?",
                    options: [
                        "Counterfeiting money",
                        "Illegal gambling",
                        "Speakeasy and nightclub",
                        "All of the above"
                    ],
                    answer: 3
                }
            },
            {
                id: 3,
                name: "Nina's Coffee Cafe",
                city: "St. Paul",
                creator: "Minnesota Historical Society",
                lat: 44.9463,
                lng: -93.1032,
                image: "https://www.mnthen.com/images/ninas-cafe.jpg",
                audio: "https://www.mnthen.com/audio/ninas-cafe.mp3",
                description: "Nina's Coffee Cafe is located in the historic Blair Flats building. The building is rumored to have been a hideout for Al Capone during his visits to St. Paul. The cafe now serves as a popular community gathering spot.",
                trivia: {
                    question: "Which famous gangster was rumored to have a hideout above what is now Nina's Coffee Cafe?",
                    options: [
                        "Al Capone",
                        "John Dillinger",
                        "Ma Barker",
                        "Baby Face Nelson"
                    ],
                    answer: 0
                }
            }
        ];

        // Global variables
        let map, userMarker;
        let currentLocationIndex = 0;
        let visitedLocations = [];
        let gameLocations = [];
        let inactivityTimer;
        let isLocationHuntVisible = false;
        let lastPosition = null;
        let positionBuffer = [];
        const MAX_BUFFER_SIZE = 20; // Increased buffer size for smoother tracking
        const DISTANCE_THRESHOLD = 20; // 20 feet to measure threshold distance to marker before opening location page
        const PROXIMITY_THRESHOLD = 100; // 100 feet to trigger zoom level change
        const HAPTIC_THRESHOLD = 200; // 200 feet to trigger haptic feedback
        const velocity = { lat: 0, lng: 0 };
        let isMapInteracting = false;
        let followUser = true;
        let allLocationMarkers = [];
        let showingAllLocations = false;
        let userIsInteracting = false;
        const preloadedImages = new Map(); // Map to store preloaded images
        const preloadedAudio = new Map(); // Map to store preloaded audio
        let currentSpeed = 0; // Current speed in meters per second
        let lastZoomLevel = 17; // Default zoom level
        let stationaryPositionHistory = []; // Array to store stationary positions for averaging
        let deviceOrientation = null; // Store device orientation data
        let deviceMotion = null; // Store device motion data
        let orientationPermissionGranted = false;
        let activeMarkers = []; // Track currently visible markers
        let currentDirectionsLocation = null; // Store current location for directions modal
        let lastProximityState = null; // Track last proximity state for zoom changes
        let isWithinProximity = false; // Flag to track if user is within proximity of a location
        let isWithinHapticRange = false; // Flag to track if user is within haptic feedback range
        let isOffline = false; // Flag to track offline status
        let mapTiles = null; // Store map tiles for offline use
        let debugMode = false; // Flag to enable debug mode
        let orientationWarningShown = false; // Flag to track if orientation warning has been shown
        let serviceWorkerRegistered = false; // Flag to track if service worker is registered

        // Enhanced constants for better stabilization
        const MICRO_MOVEMENT_THRESHOLD = 0.25; // Meters - threshold for detecting micro-movements (reduced for better stability)
        const STATIONARY_ACCURACY_MULTIPLIER = 1.01; // Tighter accuracy bounds
        const MAX_ACCEPTABLE_ACCURACY = 20; // meters - stricter accuracy requirement
        const STATIONARY_THRESHOLD = 4; // Number of consecutive stationary positions to consider user as stationary
        const STATIONARY_TIME_THRESHOLD = 1500; // ms - time to consider user stationary
        const STATIONARY_CHECK_INTERVAL = 800; // ms - interval to check if still stationary
        const VELOCITY_DECAY = 0.94; // Higher value for smoother velocity transitions
        const MIN_DISTANCE_THRESHOLD = 0.5; // meters - minimum distance to consider movement
        const EXTENDED_DISTANCE_THRESHOLD = 60; // meters - distance to consider a significant position change
        const UPDATE_INTERVAL = 8; // ms - more frequent updates for smoother animation (approx 120fps)
        const STATIONARY_POSITION_HISTORY_SIZE = 20; // Number of positions to keep for stationary averaging
        const STATIONARY_POSITION_WEIGHT_DECAY = 0.92; // Weight decay for older positions in stationary average

        // Background handling constants
        const BACKGROUND_THRESHOLD = 15000; // ms - time to consider app was in background
        const INACTIVITY_TIMEOUT = 20000; // ms - time to consider user inactive

        // Kalman filter parameters - optimized for better stationary stability
        const KALMAN_PROCESS_NOISE = 0.0025; // Lower value for smoother tracking
        const KALMAN_MEASUREMENT_NOISE_BASE = 1.0; // Increased base measurement noise
        const KALMAN_STATIONARY_NOISE = 0.01; // Lower noise when stationary

        // Animation parameters
        const ANIMATION_DURATION = 150; // ms - duration of position animation
        const HEADING_SMOOTHING = 0.92; // Heading smoothing factor

        // Dynamic zoom level parameters - enhanced for better speed adaptation
        const MAX_ZOOM_LEVEL = 18; // Maximum zoom level (stationary)
        const MIN_ZOOM_LEVEL = 13; // Minimum zoom level (high speed)
        const DEFAULT_ZOOM_LEVEL = 17; // Default zoom level for walking speed
        const PROXIMITY_ZOOM_LEVEL = 18; // Zoom level when in proximity to a location
        const WALKING_SPEED_THRESHOLD = 1.5; // m/s - threshold for walking speed
        const RUNNING_SPEED_THRESHOLD = 4.0; // m/s - threshold for running speed
        const DRIVING_SPEED_THRESHOLD = 8.0; // m/s - threshold for driving speed
        const HIGH_SPEED_THRESHOLD = 20.0; // m/s - threshold for high speed
        const ZOOM_TRANSITION_DURATION = 0.4; // seconds - duration of zoom transition
        const ZOOM_UPDATE_INTERVAL = 800; // ms - interval to update zoom level

        // Motion detection parameters
        const MOTION_THRESHOLD = 0.5; // Threshold for detecting significant motion
        const MOTION_SAMPLE_SIZE = 10; // Number of motion samples to keep
        const MOTION_CHECK_INTERVAL = 80; // ms - interval to check motion

        // Edge detection parameters - updated for better recentering
        const EDGE_THRESHOLD_PERCENTAGE = 0.12; // Percentage from edge to trigger recenter
        const STRICT_EDGE_THRESHOLD_PERCENTAGE = 0.08; // Stricter threshold for edge detection
        const CRITICAL_EDGE_THRESHOLD_PERCENTAGE = 0.04; // Critical threshold for immediate recenter
        const RECENTER_COOLDOWN = 300; // ms - cooldown between recenters to prevent excessive recentering

        // Dynamic recentering parameters
        const SPEED_RECENTER_THRESHOLD = 4.0; // m/s - speed threshold to adjust recenter behavior
        const RECENTER_OFFSET_FACTOR = 0.25; // Factor to offset the center point ahead of user when moving fast

        // Haptic feedback parameters
        const HAPTIC_FEEDBACK_DURATION = 50; // ms - duration of haptic feedback
        const HAPTIC_FEEDBACK_INTERVAL = 5000; // ms - minimum interval between haptic feedback
        const HAPTIC_PATTERN = [50, 100, 50]; // Vibration pattern for haptic feedback

        // Offline mode parameters
        const OFFLINE_CHECK_INTERVAL = 10000; // ms - interval to check offline status
        const TILE_CACHE_SIZE = 100; // Number of map tiles to cache for offline use

        // Debug parameters
        const DEBUG_UPDATE_INTERVAL = 500; // ms - interval to update debug info

        // State variables
        let lastUpdateTime = null;
        let lastVelocity = { lat: 0, lng: 0 };
        let isStationary = false;
        let stationaryStartTime = null;
        let stationaryCheckTimeout = null;
        let lastUpdateTimestamp = null;
        let lastHiddenTime = 0;
        let stationaryCount = 0;
        let lastRecenterTime = Date.now();
        let stationaryBuffer = [];
        let isStabilizing = true; // Flag to track initial stabilization
        let lastStationaryPosition = null; // Last stable position when stationary
        let motionSamples = []; // Array to store motion samples
        let deviceStationaryTime = 0; // Time device has been stationary based on motion sensors
        let animationFrameId = null; // Store requestAnimationFrame ID
        let renderTimestamp = null; // Last render timestamp
        let positionUpdateQueue = []; // Queue for position updates to be processed
        let lastHeadingValue = null; // Last heading value
        let headingBuffer = []; // Buffer for heading values
        let isFirstPositionUpdate = true; // Flag for first position update
        let lastRenderPosition = null; // Last rendered position
        let positionInterpolator = null; // Position interpolator for smooth transitions
        let lastRawPosition = null; // Last raw position from GPS
        let consecutiveStationaryUpdates = 0; // Count consecutive stationary updates
        let lastDeviceMotionTimestamp = 0; // Last device motion timestamp
        let deviceMotionBuffer = []; // Buffer for device motion data
        let isDeviceStable = false; // Flag for device stability
        let lastAccuracy = null; // Last position accuracy
        let accuracyTrend = []; // Track accuracy trend
        let lastHeadingUpdateTime = 0; // Last heading update time
        let lastPositionUpdateTime = 0; // Last position update time
        let lastZoomUpdateTime = 0; // Last zoom update time
        let targetZoomLevel = DEFAULT_ZOOM_LEVEL; // Target zoom level for smooth transitions
        let lastSpeedForZoom = 0; // Last speed used for zoom calculation
        let speedSamples = []; // Array to store speed samples for zoom calculation
        let lastRecenterCheckTime = 0; // Last time we checked for recentering
        let lastProximityCheckTime = 0; // Last time we checked for proximity
        let proximityZoomActive = false; // Flag to track if proximity zoom is active
        let forceCenteringActive = true; // Flag to force centering regardless of other conditions - start with true
        let centeringPriority = 10; // Priority level for centering (0-10) - start with max priority
        let lastHapticFeedbackTime = 0; // Last time haptic feedback was triggered
        let offlineCheckInterval = null; // Interval to check offline status
        let debugUpdateInterval = null; // Interval to update debug info
        let mapInteractionTimeout = null; // Timeout to reset map interaction flag
        let lastOrientationPermissionCheck = 0; // Last time we checked for orientation permission
        let watchPositionId = null; // ID for watchPosition
        let highAccuracyFailed = false; // Flag to track if high accuracy failed
        let mapInitialized = false; // Flag to track if map is initialized
        let mapCenteringInterval = null; // Interval to force map centering
        let lastMapCenteringTime = 0; // Last time map was centered
        let mapCenteringCount = 0; // Count of map centerings
        let mapCenteringActive = false; // Flag to track if map centering is active
        let mapCenteringForced = false; // Flag to track if map centering was forced
        let mapCenteringTimeout = null; // Timeout to reset map centering
        let mapCenteringIntervalId = null; // ID for map centering interval
        let lastMapInteractionTime = 0; // Last time user interacted with map
        let mapInteractionCount = 0; // Count of map interactions
        let mapInteractionActive = false; // Flag to track if map interaction is active
        let mapInteractionForced = false; // Flag to track if map interaction was forced
        let mapInteractionTimeout = null; // Timeout to reset map interaction
        let mapInteractionIntervalId = null; // ID for map interaction interval
        let lastMapMoveTime = 0; // Last time map was moved
        let mapMoveCount = 0; // Count of map moves
        let mapMoveActive = false; // Flag to track if map move is active
        let mapMoveForced = false; // Flag to track if map move was forced
        let mapMoveTimeout = null; // Timeout to reset map move
        let mapMoveIntervalId = null; // ID for map move interval
        let lastMapZoomTime = 0; // Last time map was zoomed
        let mapZoomCount = 0; // Count of map zooms
        let mapZoomActive = false; // Flag to track if map zoom is active
        let mapZoomForced = false; // Flag to track if map zoom was forced
        let mapZoomTimeout = null; // Timeout to reset map zoom
        let mapZoomIntervalId = null; // ID for map zoom interval
        let lastMapDragTime = 0; // Last time map was dragged
        let mapDragCount = 0; // Count of map drags
        let mapDragActive = false; // Flag to track if map drag is active
        let mapDragForced = false; // Flag to track if map drag was forced
        let mapDragTimeout = null; // Timeout to reset map drag
        let mapDragIntervalId = null; // ID for map drag interval
        let lastMapPanTime = 0; // Last time map was panned
        let mapPanCount = 0; // Count of map pans
        let mapPanActive = false; // Flag to track if map pan is active
        let mapPanForced = false; // Flag to track if map pan was forced
        let mapPanTimeout = null; // Timeout to reset map pan
        let mapPanIntervalId = null; // ID for map pan interval
        let lastHapticFeedback = 0; // Last time haptic feedback was triggered
        let hapticFeedbackCount = 0; // Count of haptic feedbacks
        let hapticFeedbackActive = false; // Flag to track if haptic feedback is active
        let hapticFeedbackForced = false; // Flag to track if haptic feedback was forced
        let hapticFeedbackTimeout = null; // Timeout to reset haptic feedback
        let hapticFeedbackIntervalId = null; // ID for haptic feedback interval

        // Enhanced Kalman Filter implementation with adaptive noise and multi-sensor fusion
        class KalmanFilter {
            constructor() {
                // State variables
                this.x = 0; // Longitude estimate
                this.y = 0; // Latitude estimate
                this.vx = 0; // Longitude velocity
                this.vy = 0; // Latitude velocity

                // Error covariance matrix
                this.P = [
                    [100, 0, 0, 0], // Initial high uncertainty
                    [0, 100, 0, 0],
                    [0, 0, 10, 0],
                    [0, 0, 0, 10],
                ];

                // Process noise
                this.Q = KALMAN_PROCESS_NOISE;

                // Measurement noise (will be adjusted based on GPS accuracy)
                this.R = KALMAN_MEASUREMENT_NOISE_BASE;

                // Time delta
                this.dt = 1.0;

                // Initialized flag
                this.initialized = false;

                // Heading and accuracy tracking
                this.lastHeading = null;
                this.headingConfidence = 0;

                // Stationary mode flag
                this.stationaryMode = false;

                // Last timestamp
                this.lastTimestamp = null;

                // Adaptive noise parameters
                this.adaptiveNoiseMin = 0.001;
                this.adaptiveNoiseMax = 0.01;
                this.adaptiveNoiseFactor = 1.0;

                // Accuracy history
                this.accuracyHistory = [];
                this.maxAccuracyHistorySize = 8;

                // Jitter detection
                this.positionHistory = [];
                this.maxPositionHistorySize = 8;
                this.jitterThreshold = 0.4; // meters

                // Heading stability
                this.headingHistory = [];
                this.maxHeadingHistorySize = 10;
                
                // Motion integration
                this.motionIntegrated = false;
                this.motionConfidence = 0;
                
                // Sensor fusion weights
                this.gpsWeight = 1.0;
                this.motionWeight = 0.0;
                this.headingWeight = 0.0;
                
                // Adaptive parameters
                this.adaptiveParameters = {
                    stationary: {
                        processNoise: KALMAN_STATIONARY_NOISE,
                        measurementNoise: KALMAN_MEASUREMENT_NOISE_BASE * 2,
                        velocityDamping: 0.95
                    },
                    walking: {
                        processNoise: KALMAN_PROCESS_NOISE,
                        measurementNoise: KALMAN_MEASUREMENT_NOISE_BASE,
                        velocityDamping: 0.8
                    },
                    driving: {
                        processNoise: KALMAN_PROCESS_NOISE * 1.5,
                        measurementNoise: KALMAN_MEASUREMENT_NOISE_BASE * 0.8,
                        velocityDamping: 0.6
                    }
                };
                
                // Current mode
                this.currentMode = 'stationary';
                
                // Confidence in current estimate
                this.estimateConfidence = 0;
            }

            // Initialize the filter with first position
            reset(position) {
                if (!position || typeof position.lat !== "number" || typeof position.lng !== "number") {
                    console.error("Invalid position for Kalman filter reset");
                    return;
                }

                this.x = position.lng;
                this.y = position.lat;
                this.vx = 0;
                this.vy = 0;

                // Reset covariance matrix with high initial uncertainty
                this.P = [
                    [100, 0, 0, 0],
                    [0, 100, 0, 0],
                    [0, 0, 10, 0],
                    [0, 0, 0, 10],
                ];

                this.initialized = true;
                this.lastHeading = position.heading || null;
                this.headingConfidence = 0;
                this.stationaryMode = false;
                this.lastTimestamp = position.timestamp || Date.now();
                this.adaptiveNoiseFactor = 1.0;
                this.accuracyHistory = [];
                this.positionHistory = [];
                this.headingHistory = [];
                this.currentMode = 'stationary';
                this.estimateConfidence = 0;

                // Add initial position to history
                this.addToPositionHistory(position);
                if (position.accuracy) {
                    this.addToAccuracyHistory(position.accuracy);
                }
                if (position.heading !== null && position.heading !== undefined) {
                    this.addToHeadingHistory(position.heading);
                }
            }

            // Add position to history
            addToPositionHistory(position) {
                this.positionHistory.push({
                    lat: position.lat,
                    lng: position.lng,
                    timestamp: position.timestamp || Date.now(),
                    accuracy: position.accuracy || 20
                });

                while (this.positionHistory.length > this.maxPositionHistorySize) {
                    this.positionHistory.shift();
                }
            }

            // Add accuracy to history
            addToAccuracyHistory(accuracy) {
                this.accuracyHistory.push(accuracy);

                while (this.accuracyHistory.length > this.maxAccuracyHistorySize) {
                    this.accuracyHistory.shift();
                }
            }

            // Add heading to history
            addToHeadingHistory(heading) {
                // Normalize heading to 0-360 range
                heading = ((heading % 360) + 360) % 360;

                this.headingHistory.push({
                    heading: heading,
                    timestamp: Date.now(),
                });

                while (this.headingHistory.length > this.maxHeadingHistorySize) {
                    this.headingHistory.shift();
                }
            }

            // Get median accuracy from history
            getMedianAccuracy() {
                if (this.accuracyHistory.length === 0) return 20;

                const sortedAccuracies = [...this.accuracyHistory].sort((a, b) => a - b);
                const mid = Math.floor(sortedAccuracies.length / 2);

                if (sortedAccuracies.length % 2 === 0) {
                    return (sortedAccuracies[mid - 1] + sortedAccuracies[mid]) / 2;
                } else {
                    return sortedAccuracies[mid];
                }
            }

            // Detect jitter in position history
            detectJitter() {
                if (this.positionHistory.length < 3) return false;

                // Calculate distances between consecutive positions
                const distances = [];
                for (let i = 1; i < this.positionHistory.length; i++) {
                    const p1 = this.positionHistory[i - 1];
                    const p2 = this.positionHistory[i];

                    // Calculate distance in meters
                    const distance = calculateDistance(p1, p2);

                    // Calculate time delta in seconds
                    const timeDelta = (p2.timestamp - p1.timestamp) / 1000;

                    // Calculate speed in m/s
                    const speed = timeDelta > 0 ? distance / timeDelta : 0;

                    distances.push({ distance, speed });
                }

                // Check for rapid direction changes (jitter)
                if (distances.length >= 2) {
                    const lastDistance = distances[distances.length - 1].distance;
                    const prevDistance = distances[distances.length - 2].distance;

                    // If both distances are small but non-zero, it might be jitter
                    if (
                        lastDistance > 0 &&
                        lastDistance < this.jitterThreshold &&
                        prevDistance > 0 &&
                        prevDistance < this.jitterThreshold
                    ) {
                        return true;
                    }
                }

                return false;
            }

            // Get stable heading from history
            getStableHeading() {
                if (this.headingHistory.length < 3) {
                    return this.lastHeading;
                }

                // Get recent headings (last 3)
                const recentHeadings = this.headingHistory.slice(-3).map((h) => h.heading);

                // Check if headings are stable (within 15 degrees of each other)
                let isStable = true;
                for (let i = 1; i < recentHeadings.length; i++) {
                    const diff = Math.abs(recentHeadings[i] - recentHeadings[i - 1]);
                    const normalizedDiff = Math.min(diff, 360 - diff);
                    if (normalizedDiff > 15) {
                        isStable = false;
                        break;
                    }
                }

                if (isStable) {
                    // Return median heading
                    const sortedHeadings = [...recentHeadings].sort((a, b) => a - b);
                    return sortedHeadings[Math.floor(sortedHeadings.length / 2)];
                }

                return this.lastHeading;
            }

            // Set stationary mode
            setStationaryMode(isStationary) {
                this.stationaryMode = isStationary;
                this.currentMode = isStationary ? 'stationary' : 'walking';

                // When entering stationary mode, reduce velocity to zero
                if (isStationary) {
                    this.vx = 0;
                    this.vy = 0;

                    // Reduce process noise for stationary mode
                    this.Q = this.adaptiveParameters.stationary.processNoise;
                    this.adaptiveNoiseFactor = 0.4; // Reduce noise in stationary mode
                } else {
                    // Reset to normal process noise when moving
                    this.Q = this.adaptiveParameters.walking.processNoise;
                    this.adaptiveNoiseFactor = 1.0; // Normal noise when moving
                }
            }

            // Adjust process noise based on accuracy and motion
            adjustProcessNoise(accuracy, motionDetected, speed) {
                // Determine current mode based on speed
                if (this.stationaryMode) {
                    this.currentMode = 'stationary';
                } else if (speed > DRIVING_SPEED_THRESHOLD) {
                    this.currentMode = 'driving';
                } else {
                    this.currentMode = 'walking';
                }
                
                // Get parameters for current mode
                const params = this.adaptiveParameters[this.currentMode];
                
                // Base noise level depends on GPS accuracy
                let noiseLevel = params.processNoise;

                // Adjust based on accuracy
                noiseLevel *= Math.min(1.0, accuracy / 40.0) + 0.5;

                // Increase noise when motion is detected
                if (motionDetected && !this.stationaryMode) {
                    noiseLevel *= 1.5;
                }

                // Decrease noise when jitter is detected
                if (this.detectJitter()) {
                    noiseLevel *= 0.6; // Reduce noise to smooth out jitter
                }

                // Apply adaptive factor
                noiseLevel *= this.adaptiveNoiseFactor;

                // Set process noise
                this.Q = noiseLevel;
                
                // Update measurement noise
                this.R = params.measurementNoise * (accuracy / 20);
            }

            // Update the filter with new measurement
            update(position, motionDetected = false) {
                if (!this.initialized) {
                    this.reset(position);
                    return position;
                }

                if (!position || typeof position.lat !== "number" || typeof position.lng !== "number") {
                    console.warn("Invalid position input to Kalman filter");
                    return {
                        lat: this.y,
                        lng: this.x,
                        accuracy: position?.accuracy || 20,
                        heading: this.lastHeading,
                        timestamp: position?.timestamp || Date.now(),
                    };
                }

                // Add to position history
                this.addToPositionHistory(position);

                // Add to accuracy history
                if (position.accuracy) {
                    this.addToAccuracyHistory(position.accuracy);
                }

                // Add to heading history
                if (position.heading !== null && position.heading !== undefined) {
                    this.addToHeadingHistory(position.heading);
                }

                // Calculate time delta
                const timestamp = position.timestamp || Date.now();
                if (this.lastTimestamp) {
                    this.dt = Math.min(Math.max((timestamp - this.lastTimestamp) / 1000, 0.01), 1.0);
                }
                this.lastTimestamp = timestamp;

                // Adjust measurement noise based on GPS accuracy
                const accuracy = position.accuracy || 20;
                const medianAccuracy = this.getMedianAccuracy();
                
                // Calculate current speed
                const speed = position.speedMPS || 0;

                // Adjust process noise based on accuracy, motion and speed
                this.adjustProcessNoise(accuracy, motionDetected, speed);

                // State transition matrix
                const F = [
                    [1, 0, this.dt, 0],
                    [0, 1, 0, this.dt],
                    [0, 0, 1, 0],
                    [0, 0, 0, 1],
                ];

                // Predict step
                // x = F * x
                const predictedX = this.x + this.dt * this.vx;
                const predictedY = this.y + this.dt * this.vy;
                
                // Apply velocity damping based on current mode
                const velocityDamping = this.adaptiveParameters[this.currentMode].velocityDamping;
                const predictedVx = this.stationaryMode ? 0 : this.vx * velocityDamping;
                const predictedVy = this.stationaryMode ? 0 : this.vy * velocityDamping;

                // P = F * P * F' + Q
                const Q = [
                    [(this.Q * this.dt * this.dt * this.dt * this.dt) / 4, 0, (this.Q * this.dt * this.dt * this.dt) / 2, 0],
                    [0, (this.Q * this.dt * this.dt * this.dt * this.dt) / 4, 0, (this.Q * this.dt * this.dt * this.dt) / 2],
                    [(this.Q * this.dt * this.dt * this.dt) / 2, 0, this.Q * this.dt * this.dt, 0],
                    [0, (this.Q * this.dt * this.dt * this.dt) / 2, 0, this.Q * this.dt * this.dt],
                ];

                // Matrix multiplication F * P
                const FP = [
                    [
                        this.P[0][0] + this.dt * this.P[2][0],
                        this.P[0][1] + this.dt * this.P[2][1],
                        this.P[0][2] + this.dt * this.P[2][2],
                        this.P[0][3] + this.dt * this.P[2][3],
                    ],
                    [
                        this.P[1][0] + this.dt * this.P[3][0],
                        this.P[1][1] + this.dt * this.P[3][1],
                        this.P[1][2] + this.dt * this.P[3][2],
                        this.P[1][3] + this.dt * this.P[3][3],
                    ],
                    [this.P[2][0], this.P[2][1], this.P[2][2], this.P[2][3]],
                    [this.P[3][0], this.P[3][1], this.P[3][2], this.P[3][3]],
                ];

                // Matrix multiplication FP * F'
                const predictedP = [
                    [
                        FP[0][0] + this.dt * FP[0][2] + Q[0][0],
                        FP[0][1] + this.dt * FP[0][3] + Q[0][1],
                        FP[0][2] + Q[0][2],
                        FP[0][3] + Q[0][3],
                    ],
                    [
                        FP[1][0] + this.dt * FP[1][2] + Q[1][0],
                        FP[1][1] + this.dt * FP[1][3] + Q[1][1],
                        FP[1][2] + Q[1][2],
                        FP[1][3] + Q[1][3],
                    ],
                    [FP[2][0] + Q[2][0], FP[2][1] + Q[2][1], FP[2][2] + Q[2][2], FP[2][3] + Q[2][3]],
                    [FP[3][0] + Q[3][0], FP[3][1] + Q[3][1], FP[3][2] + Q[3][2], FP[3][3] + Q[3][3]],
                ];

                // Update step
                // y = z - H * x
                const measurementResidualX = position.lng - predictedX;
                const measurementResidualY = position.lat - predictedY;

                // S = H * P * H' + R
                const S = [
                    [predictedP[0][0] + this.R, predictedP[0][1]],
                    [predictedP[1][0], predictedP[1][1] + this.R],
                ];

                // Calculate determinant of S
                const detS = S[0][0] * S[1][1] - S[0][1] * S[1][0];

                // Calculate inverse of S
                const invS = [
                    [S[1][1] / detS, -S[0][1] / detS],
                    [-S[1][0] / detS, S[0][0] / detS],
                ];

                // K = P * H' * inv(S)
                const K = [
                    [
                        predictedP[0][0] * invS[0][0] + predictedP[0][1] * invS[1][0],
                        predictedP[0][0] * invS[0][1] + predictedP[0][1] * invS[1][1],
                    ],
                    [
                        predictedP[1][0] * invS[0][0] + predictedP[1][1] * invS[1][0],
                        predictedP[1][0] * invS[0][1] + predictedP[1][1] * invS[1][1],
                    ],
                    [
                        predictedP[2][0] * invS[0][0] + predictedP[2][1] * invS[1][0],
                        predictedP[2][0] * invS[0][1] + predictedP[2][1] * invS[1][1],
                    ],
                    [
                        predictedP[3][0] * invS[0][0] + predictedP[3][1] * invS[1][0],
                        predictedP[3][0] * invS[0][1] + predictedP[3][1] * invS[1][1],
                    ],
                ];

                // x = x + K * y
                this.x = predictedX + K[0][0] * measurementResidualX + K[0][1] * measurementResidualY;
                this.y = predictedY + K[1][0] * measurementResidualX + K[1][1] * measurementResidualY;

                // In stationary mode, keep velocity at zero
                if (this.stationaryMode) {
                    this.vx = 0;
                    this.vy = 0;
                } else {
                    this.vx = predictedVx + K[2][0] * measurementResidualX + K[2][1] * measurementResidualY;
                    this.vy = predictedVy + K[3][0] * measurementResidualX + K[3][1] * measurementResidualY;
                }

                // P = (I - K * H) * P
                this.P = [
                    [
                        predictedP[0][0] - (K[0][0] * predictedP[0][0] + K[0][1] * predictedP[1][0]),
                        predictedP[0][1] - (K[0][0] * predictedP[0][1] + K[0][1] * predictedP[1][1]),
                        predictedP[0][2] - (K[0][0] * predictedP[0][2] + K[0][1] * predictedP[1][2]),
                        predictedP[0][3] - (K[0][0] * predictedP[0][3] + K[0][1] * predictedP[1][3]),
                    ],
                    [
                        predictedP[1][0] - (K[1][0] * predictedP[0][0] + K[1][1] * predictedP[1][0]),
                        predictedP[1][1] - (K[1][0] * predictedP[0][1] + K[1][1] * predictedP[1][1]),
                        predictedP[1][2] - (K[1][0] * predictedP[0][2] + K[1][1] * predictedP[1][2]),
                        predictedP[1][3] - (K[1][0] * predictedP[0][3] + K[1][1] * predictedP[1][3]),
                    ],
                    [
                        predictedP[2][0] - (K[2][0] * predictedP[0][0] + K[2][1] * predictedP[1][0]),
                        predictedP[2][1] - (K[2][0] * predictedP[0][1] + K[2][1] * predictedP[1][1]),
                        predictedP[2][2] - (K[2][0] * predictedP[0][2] + K[2][1] * predictedP[1][2]),
                        predictedP[2][3] - (K[2][0] * predictedP[0][3] + K[2][1] * predictedP[1][3]),
                    ],
                    [
                        predictedP[3][0] - (K[3][0] * predictedP[0][0] + K[3][1] * predictedP[1][0]),
                        predictedP[3][1] - (K[3][0] * predictedP[0][1] + K[3][1] * predictedP[1][1]),
                        predictedP[3][2] - (K[3][0] * predictedP[0][2] + K[3][1] * predictedP[1][2]),
                        predictedP[3][3] - (K[3][0] * predictedP[0][3] + K[3][1] * predictedP[1][3]),
                    ],
                ];

                // Process heading data
                let smoothedHeading = position.heading;
                if (position.heading !== null && position.heading !== undefined) {
                    // Get stable heading from history
                    smoothedHeading = this.getStableHeading();

                    // If no stable heading yet, use current heading
                    if (smoothedHeading === null) {
                        smoothedHeading = position.heading;
                    }

                    this.lastHeading = smoothedHeading;
                }

                // Calculate speed from velocity components
                const calculatedSpeed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                
                // Calculate estimate confidence (0-1)
                const positionUncertainty = Math.sqrt(this.P[0][0] + this.P[1][1]);
                this.estimateConfidence = Math.max(0, Math.min(1, 1 - (positionUncertainty / 100)));

                return {
                    lat: this.y,
                    lng: this.x,
                    accuracy: position.accuracy,
                    heading: smoothedHeading,
                    timestamp: position.timestamp,
                    speedMPS: this.stationaryMode ? 0 : calculatedSpeed * 111000, // Convert from degrees/second to meters/second (approximate)
                    confidence: this.estimateConfidence,
                    mode: this.currentMode
                };
            }
        }

        // Position interpolator for smooth transitions
        class PositionInterpolator {
            constructor() {
                this.startPosition = null;
                this.targetPosition = null;
                this.startTime = null;
                this.duration = 0;
                this.isActive = false;
                this.lastInterpolatedPosition = null;
                this.easingFunction = this.easeOutCubic; // Default easing function
            }

            start(startPos, targetPos, duration, easingFunction = null) {
                if (!startPos || !targetPos) return;

                // Don't interpolate if positions are too close
                const distance = calculateDistance(startPos, targetPos);
                if (distance < 0.05) {
                    this.isActive = false;
                    this.lastInterpolatedPosition = targetPos;
                    return;
                }

                this.startPosition = { ...startPos };
                this.targetPosition = { ...targetPos };
                this.startTime = performance.now();
                this.duration = duration;
                this.isActive = true;
                
                // Set easing function if provided
                if (easingFunction) {
                    this.easingFunction = easingFunction;
                }
            }

            update() {
                if (!this.isActive) return this.lastInterpolatedPosition || this.targetPosition;

                const now = performance.now();
                const elapsed = now - this.startTime;

                if (elapsed >= this.duration) {
                    this.isActive = false;
                    this.lastInterpolatedPosition = this.targetPosition;
                    return this.targetPosition;
                }

                // Calculate progress with easing
                const t = elapsed / this.duration;
                const easedT = this.easingFunction(t);

                // Interpolate position
                const interpolatedPosition = {
                    lat: this.startPosition.lat + (this.targetPosition.lat - this.startPosition.lat) * easedT,
                    lng: this.startPosition.lng + (this.targetPosition.lng - this.startPosition.lng) * easedT,
                    accuracy: this.targetPosition.accuracy,
                    heading: this.targetPosition.heading,
                    timestamp: now,
                    speedMPS: this.targetPosition.speedMPS,
                    confidence: this.targetPosition.confidence,
                    mode: this.targetPosition.mode
                };

                this.lastInterpolatedPosition = interpolatedPosition;
                return interpolatedPosition;
            }

            // Cubic easing function for smoother motion
            easeOutCubic(t) {
                return 1 - Math.pow(1 - t, 3);
            }
            
            // Quadratic easing function
            easeOutQuad(t) {
                return 1 - (1 - t) * (1 - t);
            }
            
            // Exponential easing function
            easeOutExpo(t) {
                return t === 1 ? 1 : 1 - Math.pow(2, -10 * t);
            }
            
            // Elastic easing function
            easeOutElastic(t) {
                const c4 = (2 * Math.PI) / 3;
                return t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c4) + 1;
            }

            isInterpolating() {
                return this.isActive;
            }

            cancel() {
                this.isActive = false;
            }

            getLastPosition() {
                return this.lastInterpolatedPosition || this.targetPosition;
            }
        }

        // Create Kalman filter instance
        const kalmanFilter = new KalmanFilter();

        // Create position interpolator
        positionInterpolator = new PositionInterpolator();

        // Calculate distance between two points using Haversine formula
        function calculateDistance(pos1, pos2) {
            if (
                !pos1 ||
                !pos2 ||
                typeof pos1.lat !== "number" ||
                typeof pos1.lng !== "number" ||
                typeof pos2.lat !== "number" ||
                typeof pos2.lng !== "number"
            ) {
                return Number.POSITIVE_INFINITY;
            }

            const R = 6371000; // Earth's radius in meters
            const lat1 = (pos1.lat * Math.PI) / 180;
            const lat2 = (pos2.lat * Math.PI) / 180;
            const deltaLat = ((pos2.lat - pos1.lat) * Math.PI) / 180;
            const deltaLng = ((pos2.lng - pos1.lng) * Math.PI) / 180;

            const a =
                Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) +
                Math.cos(lat1) * Math.cos(lat2) * Math.sin(deltaLng / 2) * Math.sin(deltaLng / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

            return R * c;
        }

        // Check if device is in motion based on motion sensors
        function isDeviceInMotion() {
            if (!motionSamples || motionSamples.length < 3) {
                return false;
            }

            // Calculate average motion magnitude
            const avgMotion =
                motionSamples.reduce((sum, sample) => {
                    return sum + Math.sqrt(sample.x * sample.x + sample.y * sample.y + sample.z * sample.z);
                }, 0) / motionSamples.length;

            return avgMotion > MOTION_THRESHOLD;
        }

        // Process device motion data
        function handleDeviceMotion(event) {
            if (!event || !event.acceleration) return;

            const now = Date.now();
            // Throttle motion updates for better performance
            if (now - lastDeviceMotionTimestamp < 50) return;
            lastDeviceMotionTimestamp = now;

            const motion = {
                x: event.acceleration.x || 0,
                y: event.acceleration.y || 0,
                z: event.acceleration.z || 0,
                timestamp: now,
            };

            // Add to motion samples
            motionSamples.push(motion);

            // Keep only recent samples
            while (motionSamples.length > MOTION_SAMPLE_SIZE) {
                motionSamples.shift();
            }

            // Update device motion state
            deviceMotion = motion;

            // Add to device motion buffer for stability detection
            deviceMotionBuffer.push({
                magnitude: Math.sqrt(motion.x * motion.x + motion.y * motion.y + motion.z * motion.z),
                timestamp: now,
            });

            // Keep buffer at reasonable size
            while (deviceMotionBuffer.length > 10) {
                deviceMotionBuffer.shift();
            }

            // Check if device is stationary based on motion
            const inMotion = isDeviceInMotion();

            if (!inMotion) {
                deviceStationaryTime += 50; // Increment by throttle time
            } else {
                deviceStationaryTime = 0;
            }
        }

        // Process device orientation data
        function handleDeviceOrientation(event) {
            if (!event || event.alpha === null) return;

            const now = Date.now();
            // Throttle heading updates
            if (now - lastHeadingUpdateTime < 100) return;
            lastHeadingUpdateTime = now;

            deviceOrientation = {
                alpha: event.alpha, // z-axis rotation [0,360)
                beta: event.beta, // x-axis rotation [-180,180)
                gamma: event.gamma, // y-axis rotation [-90,90)
                timestamp: now,
            };

            // Update heading buffer if we have a compass heading
            if (event.webkitCompassHeading !== undefined) {
                const heading = event.webkitCompassHeading;

                // Add to heading buffer
                headingBuffer.push(heading);

                // Keep only recent headings
                while (headingBuffer.length > 8) {
                    headingBuffer.shift();
                }

                // Calculate median heading to filter outliers
                if (headingBuffer.length >= 3) {
                    const sortedHeadings = [...headingBuffer].sort((a, b) => a - b);
                    lastHeadingValue = sortedHeadings[Math.floor(sortedHeadings.length / 2)];
                }
            }
        }

        // Request device motion and orientation permissions
        function requestMotionPermission() {
            if (typeof DeviceMotionEvent !== "undefined" && typeof DeviceMotionEvent.requestPermission === "function") {
                DeviceMotionEvent.requestPermission()
                    .then((response) => {
                        if (response === "granted") {
                            window.addEventListener("devicemotion", handleDeviceMotion, true);
                            orientationPermissionGranted = true;
                            hideOrientationWarning();
                        } else {
                            showOrientationWarning();
                        }
                    })
                    .catch(error => {
                        console.error("Motion permission error:", error);
                        showOrientationWarning();
                    });
            } else {
                window.addEventListener("devicemotion", handleDeviceMotion, true);
            }

            if (typeof DeviceOrientationEvent !== "undefined" && typeof DeviceOrientationEvent.requestPermission === "function") {
                DeviceOrientationEvent.requestPermission()
                    .then((response) => {
                        if (response === "granted") {
                            orientationPermissionGranted = true;
                            window.addEventListener("deviceorientation", handleDeviceOrientation, true);
                            hideOrientationWarning();
                        } else {
                            showOrientationWarning();
                        }
                    })
                    .catch(error => {
                        console.error("Orientation permission error:", error);
                        showOrientationWarning();
                    });
            } else {
                window.addEventListener("deviceorientation", handleDeviceOrientation, true);
                orientationPermissionGranted = true;
            }
        }

        // Show orientation warning
        function showOrientationWarning() {
            if (orientationWarningShown) return;
            
            const warning = document.getElementById('orientationWarning');
            if (warning) {
                warning.style.display = 'flex';
                orientationWarningShown = true;
            }
        }

        // Hide orientation warning
        function hideOrientationWarning() {
            const warning = document.getElementById('orientationWarning');
            if (warning) {
                warning.style.display = 'none';
                orientationWarningShown = false;
            }
        }

        // Animation loop for smooth rendering
        function startAnimationLoop() {
            function animate(timestamp) {
                // Calculate delta time
                const deltaTime = renderTimestamp ? (timestamp - renderTimestamp) / 1000 : 0;
                renderTimestamp = timestamp;

                // Process position updates
                processPositionUpdateQueue();

                // Update interpolated position
                if (positionInterpolator && positionInterpolator.isInterpolating()) {
                    const interpolatedPosition = positionInterpolator.update();
                    if (interpolatedPosition) {
                        // Update marker position
                        userMarker.setLatLng([interpolatedPosition.lat, interpolatedPosition.lng]);
                        lastRenderPosition = interpolatedPosition;

                        // Update marker rotation if heading is available
                        if (interpolatedPosition.heading !== null && interpolatedPosition.heading !== undefined) {
                            updateMarkerRotation(interpolatedPosition.heading);
                        }
                    }
                }

                // Check for recentering based on edge proximity
                if ((followUser && !isMapInteracting) || forceCenteringActive) {
                    if (Date.now() - lastRecenterCheckTime > 100) { // More frequent checks
                        checkAndRecenterMap();
                        lastRecenterCheckTime = Date.now();
                    }
                }

                // Update zoom level based on speed and proximity
                updateDynamicZoom();

                // Check for proximity to locations
                if (Date.now() - lastProximityCheckTime > 500) {
                    checkProximityForZoom();
                    checkProximityForHaptic();
                    lastProximityCheckTime = Date.now();
                }

                // Update debug info if enabled
                if (debugMode && Date.now() - lastDebugUpdateTime > DEBUG_UPDATE_INTERVAL) {
                    updateDebugInfo();
                    lastDebugUpdateTime = Date.now();
                }

                // Request next frame
                animationFrameId = requestAnimationFrame(animate);
            }

            // Start animation loop
            animationFrameId = requestAnimationFrame(animate);
        }

        // Update marker rotation based on heading
        function updateMarkerRotation(heading) {
            const markerElement = userMarker.getElement();
            if (markerElement) {
                const iconElement = markerElement.querySelector(".user-marker-icon");
                if (iconElement) {
                    iconElement.style.transform = `rotate(${heading}deg)`;
                    
                    // Add direction indicator class if not already present
                    if (!iconElement.classList.contains('with-direction')) {
                        iconElement.classList.add('with-direction');
                    }
                }
                
                // Update direction indicator if it exists
                const directionElement = markerElement.querySelector(".user-marker-direction");
                if (directionElement) {
                    directionElement.style.transform = `translate(-50%, -50%) rotate(${heading}deg)`;
                }
            }
        }

        // Process position update queue
        function processPositionUpdateQueue() {
            if (positionUpdateQueue.length === 0) return;

            // Process all updates in queue
            while (positionUpdateQueue.length > 0) {
                const update = positionUpdateQueue.shift();
                processPositionUpdate(update);
            }
        }

        // Process position update
        function processPositionUpdate(position) {
            // Validate position
            if (!position || typeof position.lat !== "number" || typeof position.lng !== "number") {
                return;
            }

            // Update tracking variables
            lastPosition = position;
            currentSpeed = position.speedMPS || 0;
            
            // Maintain speed samples (5-point buffer)
            speedSamples.push(currentSpeed);
            if (speedSamples.length > 5) speedSamples.shift();

            // Update marker stationary state
            const markerElement = userMarker.getElement();
            if (markerElement) {
                markerElement.classList.toggle("user-marker-stationary", isStationary);
            }

            // Calculate movement distance if we have previous position
            const distance = lastRenderPosition ? calculateDistance(lastRenderPosition, position) : 0;

            // Handle position update
            if (!lastRenderPosition || isFirstPositionUpdate) {
                // Initial position - set directly
                userMarker.setLatLng([position.lat, position.lng]);
                lastRenderPosition = position;
                isFirstPositionUpdate = false;
            } 
            else if (distance > EXTENDED_DISTANCE_THRESHOLD) {
                // Large movement - update immediately without animation
                userMarker.setLatLng([position.lat, position.lng]);
                lastRenderPosition = position;
                
                // Cancel any ongoing animation
                if (positionInterpolator) {
                    positionInterpolator.cancel();
                }
            }
            else {
                // Normal movement - apply smooth interpolation
                const animDuration = isStationary ? 
                    (distance < 0.5 ? 600 : 400) : // Longer duration for stationary micro-movements
                    ANIMATION_DURATION;
                
                // Choose easing function based on movement type
                let easingFunction = null;
                if (isStationary) {
                    easingFunction = positionInterpolator.easeOutExpo; // Smoother for stationary
                } else if (currentSpeed > DRIVING_SPEED_THRESHOLD) {
                    easingFunction = positionInterpolator.easeOutQuad; // Quicker for driving
                } else {
                    easingFunction = positionInterpolator.easeOutCubic; // Default
                }
                
                positionInterpolator.start(lastRenderPosition, position, animDuration, easingFunction);
            }

            // Update marker rotation if heading available
            if (position.heading !== null && position.heading !== undefined) {
                updateMarkerRotation(position.heading);
            }

            // Handle map recentering - IMPROVED to keep user centered
            if (followUser && !isMapInteracting) {
                // Always keep user centered regardless of movement size
                map.setView([position.lat, position.lng], map.getZoom(), {
                    animate: true,
                    duration: 0.2 // Faster animation for more responsive centering
                });
            }
            
            // Check nearby points of interest
            checkNearbyLocations();
        }
        
        // Check for proximity to locations for zoom level adjustment
        function checkProximityForZoom() {
            if (!lastPosition || !gameLocations || gameLocations.length === 0) return;
            
            // Only check the current location
            const location = gameLocations[currentLocationIndex];
            if (!location) return;
            
            // Calculate distance to current location
            const distance = calculateDistance(
                { lat: lastPosition.lat, lng: lastPosition.lng },
                { lat: location.lat, lng: location.lng }
            );
            
            // Convert to feet
            const distanceFeet = Math.round(distance * 3.28084);
            
            // Check if user is within proximity threshold
            const withinProximity = distanceFeet <= PROXIMITY_THRESHOLD;
            
            // Only update if proximity state has changed
            if (withinProximity !== isWithinProximity) {
                isWithinProximity = withinProximity;
                
                // Adjust zoom level based on proximity
                if (isWithinProximity && !proximityZoomActive) {
                    // Zoom in when entering proximity
                    proximityZoomActive = true;
                    if (map && followUser) {
                        map.setZoom(PROXIMITY_ZOOM_LEVEL, {
                            animate: true,
                            duration: 1.0,
                            noMoveStart: true
                        });
                    }
                } else if (!isWithinProximity && proximityZoomActive) {
                    // Zoom out when leaving proximity
                    proximityZoomActive = false;
                    if (map && followUser) {
                        map.setZoom(DEFAULT_ZOOM_LEVEL, {
                            animate: true,
                            duration: 1.0,
                            noMoveStart: true
                        });
                    }
                }
            }
        }
        
        // Check for proximity to trigger haptic feedback
        function checkProximityForHaptic() {
            if (!lastPosition || !gameLocations || gameLocations.length === 0) return;
            
            // Only check the current location
            const location = gameLocations[currentLocationIndex];
            if (!location) return;
            
            // Calculate distance to current location
            const distance = calculateDistance(
                { lat: lastPosition.lat, lng: lastPosition.lng },
                { lat: location.lat, lng: location.lng }
            );
            
            // Convert to feet
            const distanceFeet = Math.round(distance * 3.28084);
            
            // Check if user is within haptic threshold
            const withinHapticRange = distanceFeet <= HAPTIC_THRESHOLD;
            
            // Only trigger haptic feedback if state has changed and we're entering the range
            if (withinHapticRange && !isWithinHapticRange) {
                isWithinHapticRange = true;
                
                // Trigger haptic feedback if supported and not too frequent
                if (Date.now() - lastHapticFeedbackTime > HAPTIC_FEEDBACK_INTERVAL) {
                    triggerHapticFeedback();
                    lastHapticFeedbackTime = Date.now();
                }
            } else if (!withinHapticRange && isWithinHapticRange) {
                isWithinHapticRange = false;
            }
        }
        
        // Trigger haptic feedback
        function triggerHapticFeedback() {
            // Check if vibration API is supported
            if ('vibrate' in navigator) {
                navigator.vibrate(HAPTIC_PATTERN);
            }
            
            // Show visual feedback
            const hapticIndicator = document.getElementById('hapticIndicator');
            if (hapticIndicator) {
                hapticIndicator.classList.add('active');
                
                // Remove active class after animation completes
                setTimeout(() => {
                    hapticIndicator.classList.remove('active');
                }, 500);
            }
        }

        // Check for nearby locations
        function checkNearbyLocations() {
            if (!lastPosition || !gameLocations || isLocationHuntVisible) return;
            
            // Only check the current location (progressive display)
            const location = gameLocations[currentLocationIndex];
            if (!location) return;
            
            // Skip if already visited
            if (visitedLocations.includes(location.id)) return;
            
            const distance = calculateDistance(
                { lat: lastPosition.lat, lng: lastPosition.lng },
                { lat: location.lat, lng: location.lng }
            );
            
            // Convert to feet
            const distanceFeet = Math.round(distance * 3.28084);
            
            // Update distance box
            updateDistanceBox(location, distanceFeet);
            
            // Check if user is close enough to interact
            if (distanceFeet <= DISTANCE_THRESHOLD) {
                showLocationHunt(location);
            }
        }
        
        // Update distance box with location info
        function updateDistanceBox(location, distanceFeet) {
            const distanceBox = document.getElementById('distanceBox');
            if (distanceBox) {
                const locationNameElement = distanceBox.querySelector('.location-name');
                const distanceValueElement = distanceBox.querySelector('.distance-value');
                
                if (locationNameElement && distanceValueElement) {
                    locationNameElement.textContent = location.name;
                    
                    // Format distance based on value
                    let distanceText;
                    if (distanceFeet > 5280) {
                        // Convert to miles and round to 1 decimal place
                        const distanceMiles = (distanceFeet / 5280).toFixed(1);
                        distanceText = `${distanceMiles} miles away`;
                    } else if (distanceFeet === 5280) {
                        distanceText = "1 mile away";
                    } else {
                        distanceText = `${distanceFeet} feet away`;
                    }
                    
                    distanceValueElement.textContent = distanceText;
                }
            }
        }

        // Create navigation links for a location
        function createNavigationLinks(location) {
            // Google Maps
            const googleMapsLink = document.getElementById('googleMapsLink');
            if (googleMapsLink) {
                googleMapsLink.href = `https://www.google.com/maps/dir/?api=1&destination=${location.lat},${location.lng}&travelmode=walking`;
            }
            
            // Apple Maps (iOS only)
            const appleMapsLink = document.getElementById('appleMapsLink');
            if (appleMapsLink) {
                appleMapsLink.href = `maps://maps.apple.com/?daddr=${location.lat},${location.lng}&dirflg=w`;
                
                // Hide Apple Maps link on non-iOS devices
                const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
                appleMapsLink.style.display = isIOS ? 'flex' : 'none';
            }
            
            // Waze
            const wazeLink = document.getElementById('wazeLink');
            if (wazeLink) {
                wazeLink.href = `https://waze.com/ul?ll=${location.lat},${location.lng}&navigate=yes`;
            }
        }
        
        // Set up directions modal links
        function setupDirectionsModal(location) {
            currentDirectionsLocation = location;
            
            // Google Maps
            const googleMapsBtn = document.getElementById('googleMapsBtn');
            if (googleMapsBtn) {
                googleMapsBtn.href = `https://www.google.com/maps/dir/?api=1&destination=${location.lat},${location.lng}&travelmode=walking`;
            }
            
            // Apple Maps (iOS only)
            const appleMapsBtn = document.getElementById('appleMapsBtn');
            if (appleMapsBtn) {
                appleMapsBtn.href = `maps://maps.apple.com/?daddr=${location.lat},${location.lng}&dirflg=w`;
                
                // Hide Apple Maps button on non-iOS devices
                const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
                appleMapsBtn.style.display = isIOS ? 'flex' : 'none';
            }
            
            // Waze
            const wazeBtn = document.getElementById('wazeBtn');
            if (wazeBtn) {
                wazeBtn.href = `https://waze.com/ul?ll=${location.lat},${location.lng}&navigate=yes`;
            }
        }
        
        // Show directions modal
        function showDirectionsModal(location) {
            setupDirectionsModal(location);
            document.getElementById('directionsModal').style.display = 'flex';
        }
        
        // Close directions modal
        function closeDirectionsModal() {
            document.getElementById('directionsModal').style.display = 'none';
        }
        
        // Skip to next location
        function skipToNextLocation() {
            // Close any open popups
            map.closePopup();
            
            // Remove the current marker from the map
            if (currentLocationIndex < allLocationMarkers.length) {
                map.removeLayer(allLocationMarkers[currentLocationIndex]);
            }
            
            // Move to next location
            currentLocationIndex++;
            
            // Check if we've reached the end
            if (currentLocationIndex >= gameLocations.length) {
                showCongratulations();
            } else {
                // Update visible markers
                updateVisibleMarkers();
                
                // Update distance box for new location
                const location = gameLocations[currentLocationIndex];
                if (location && lastPosition) {
                    const distance = calculateDistance(
                        { lat: lastPosition.lat, lng: lastPosition.lng },
                        { lat: location.lat, lng: location.lng }
                    );
                    const distanceFeet = Math.round(distance * 3.28084);
                    updateDistanceBox(location, distanceFeet);
                }
                
                // Reset proximity state
                isWithinProximity = false;
                proximityZoomActive = false;
                isWithinHapticRange = false;
            }
        }

        // Check and recenter map if needed
        function checkAndRecenterMap() {
            if (!userMarker || !map) return;
            
            // Always recenter to keep user in center of screen
            if (followUser || forceCenteringActive) {
                const position = userMarker.getLatLng();
                map.setView([position.lat, position.lng], map.getZoom(), {
                    animate: true,
                    duration: 0.2, // Faster animation for more responsive centering
                    noMoveStart: true
                });
            }
        }

        // Calculate optimal zoom level based on speed
        function calculateOptimalZoom(speed) {
            // If proximity zoom is active, prioritize it
            if (proximityZoomActive) {
                return PROXIMITY_ZOOM_LEVEL;
            }
            
            // Default to walking zoom level
            if (speed === undefined || speed === null) {
                return DEFAULT_ZOOM_LEVEL;
            }

            // Stationary or very slow
            if (speed < 0.5) {
                return MAX_ZOOM_LEVEL;
            }
            // Walking speed
            else if (speed < WALKING_SPEED_THRESHOLD) {
                return DEFAULT_ZOOM_LEVEL;
            }
            // Running speed
            else if (speed < RUNNING_SPEED_THRESHOLD) {
                return DEFAULT_ZOOM_LEVEL - 1;
            }
            // Driving speed
            else if (speed < DRIVING_SPEED_THRESHOLD) {
                return DEFAULT_ZOOM_LEVEL - 2;
            }
            // High speed
            else if (speed < HIGH_SPEED_THRESHOLD) {
                return DEFAULT_ZOOM_LEVEL - 3;
            }
            // Very high speed
            else {
                return MIN_ZOOM_LEVEL;
            }
        }

        // Update zoom level based on speed
        function updateDynamicZoom() {
            const now = Date.now();
            if (now - lastZoomUpdateTime < ZOOM_UPDATE_INTERVAL) return;
            lastZoomUpdateTime = now;

            // Skip if user is interacting with map
            if (isMapInteracting || userIsInteracting) return;

            // Calculate average speed from samples
            let avgSpeed = 0;
            if (speedSamples.length > 0) {
                avgSpeed = speedSamples.reduce((sum, speed) => sum + speed, 0) / speedSamples.length;
            } else if (lastPosition) {
                avgSpeed = lastPosition.speedMPS || 0;
            }

            // Smooth speed changes
            const smoothedSpeed = lastSpeedForZoom * 0.7 + avgSpeed * 0.3;
            lastSpeedForZoom = smoothedSpeed;

            // Calculate optimal zoom level
            const optimalZoom = calculateOptimalZoom(smoothedSpeed);

            // Only update if zoom level needs to change
            if (Math.abs(optimalZoom - targetZoomLevel) >= 0.1) {
                targetZoomLevel = optimalZoom;

                // Apply zoom change with smooth animation
                if (map && followUser) {
                    const currentZoom = map.getZoom();
                    const zoomDiff = Math.abs(currentZoom - targetZoomLevel);

                    // Use faster transition for larger zoom changes
                    const duration = zoomDiff > 1 ? 0.3 : ZOOM_TRANSITION_DURATION;

                    map.setZoom(targetZoomLevel, {
                        animate: true,
                        duration: duration,
                        noMoveStart: true,
                    });
                }
            }
        }

        // Linear interpolation helper
        function lerp(a, b, t) {
            if (typeof a !== "number" || typeof b !== "number" || typeof t !== "number") {
                return a;
            }

            return a + (b - a) * Math.max(0, Math.min(1, t));
        }

        // Calculate stationary position
        function calculateStationaryPosition(buffer) {
            if (!buffer || buffer.length === 0) {
                return null;
            }
            // Sort by accuracy (best first)
            const sortedBuffer = [...buffer].sort((a, b) => a.accuracy - b.accuracy);
            // Take weighted average of best positions
            const topPositions = sortedBuffer.slice(0, Math.ceil(buffer.length / 2));
            const weights = topPositions.map((pos) => 1 / Math.max(1, pos.accuracy));
            const totalWeight = weights.reduce((sum, w) => sum + w, 0);
            if (totalWeight === 0) {
                return sortedBuffer[0];
            }
            // Calculate weighted average
            const avgPosition = {
                lat: topPositions.reduce((sum, pos, i) => sum + pos.lat * weights[i], 0) / totalWeight,
                lng: topPositions.reduce((sum, pos, i) => sum + pos.lng * weights[i], 0) / totalWeight,
                accuracy: topPositions[0].accuracy,
                heading: topPositions[0].heading,
                timestamp: Date.now(),
                speedMPS: 0,
            };
            // If we have a previous stationary position, blend with it for stability
            if (lastStationaryPosition) {
                const blendFactor = 0.85; // 85% previous, 15% new for extreme stability
                return {
                    lat: lastStationaryPosition.lat * blendFactor + avgPosition.lat * (1 - blendFactor),
                    lng: lastStationaryPosition.lng * blendFactor + avgPosition.lng * (1 - blendFactor),
                    accuracy: avgPosition.accuracy,
                    heading: avgPosition.heading,
                    timestamp: avgPosition.timestamp,
                    speedMPS: 0
                };
            }
            return avgPosition;
        }

        // Update stationary position history
        function updateStationaryHistory(position) {
            // Add new position to history
            stationaryPositionHistory.push(position);

            // Keep history at maximum size
            while (stationaryPositionHistory.length > STATIONARY_POSITION_HISTORY_SIZE) {
                stationaryPositionHistory.shift();
            }

            // Calculate weighted average of positions
            let totalWeight = 0;
            let weightedLat = 0;
            let weightedLng = 0;

            // Newer positions have higher weight
            for (let i = 0; i < stationaryPositionHistory.length; i++) {
                const pos = stationaryPositionHistory[i];
                const weight = Math.pow(STATIONARY_POSITION_WEIGHT_DECAY, stationaryPositionHistory.length - i - 1);
                totalWeight += weight;
                weightedLat += pos.lat * weight;
                weightedLng += pos.lng * weight;
            }

            return {
                lat: weightedLat / totalWeight,
                lng: weightedLng / totalWeight,
                accuracy: position.accuracy,
                heading: position.heading,
                timestamp: position.timestamp,
                speedMPS: 0,
            };
        }

        // Update position buffer with new position
        function updatePositionBuffer(position) {
            if (!position || typeof position.lat !== "number" || typeof position.lng !== "number") {
                return;
            }

            // Add new position to buffer
            positionBuffer.push({
                lat: position.lat,
                lng: position.lng,
                accuracy: position.accuracy,
                heading: position.heading,
                timestamp: position.timestamp,
                speedMPS: position.speedMPS,
            });

            // Remove old positions if buffer exceeds maxSize
            while (positionBuffer.length > MAX_BUFFER_SIZE) {
                positionBuffer.shift();
            }
        }

        // Check if user is stationary
        function checkStationaryState(newPosition) {
            if (!lastPosition) return;

            const distance = calculateDistance(lastPosition, newPosition);

            if (distance >= MICRO_MOVEMENT_THRESHOLD) {
                isStationary = false;
                stationaryStartTime = null;
                console.debug("Movement detected, resuming normal updates");

                // Update Kalman filter stationary mode
                kalmanFilter.setStationaryMode(false);

                // Update marker class
                const markerElement = userMarker.getElement();
                if (markerElement) {
                    markerElement.classList.remove("user-marker-stationary");
                }
            }

            if (stationaryCheckTimeout) {
                clearTimeout(stationaryCheckTimeout);
                stationaryCheckTimeout = null;
            }

            if (isStationary) {
                stationaryCheckTimeout = setTimeout(() => checkStationaryState(newPosition), STATIONARY_CHECK_INTERVAL);
            }
        }

        // Predict position based on heading and speed
        function predictPositionFromHeading(position, heading, distance) {
            // Input validation
            if (
                !position ||
                typeof heading !== "number" ||
                typeof distance !== "number" ||
                !position.lat ||
                !position.lng ||
                isNaN(heading) ||
                isNaN(distance)
            ) {
                return position;
            }

            // Normalize heading to 0-360 range
            heading = ((heading % 360) + 360) % 360;

            // Earth's radius in meters
            const R = 6371e3;

            // Convert to radians
            const d = distance / R;
            const  = (heading * Math.PI) / 180;
            const 1 = (position.lat * Math.PI) / 180;
            const 1 = (position.lng * Math.PI) / 180;

            // Calculate predicted position with error handling
            try {
                const sin1 = Math.sin(1);
                const cos1 = Math.cos(1);
                const cosd = Math.cos(d);
                const sind = Math.sin(d);
                const cos = Math.cos();

                const 2 = Math.asin(sin1 * cosd + cos1 * sind * cos);

                const 2 = 1 + Math.atan2(Math.sin() * sind * cos1, cosd - sin1 * Math.sin(2));

                // Convert back to degrees with bounds checking
                const newLat = Math.max(-90, Math.min(90, (2 * 180) / Math.PI));
                const newLng = (((2 * 180) / Math.PI + 540) % 360) - 180;

                return {
                    lat: newLat,
                    lng: newLng,
                };
            } catch (error) {
                // Fallback to original position if calculation fails
                return position;
            }
        }

        // Main function to update user location
        function updateUserLocation(position, forceUpdate = false) {
            // Validate input position
            if (!position?.coords) {
                console.warn("Invalid position data received");
                return;
            }

            const currentTime = Date.now();

            // Throttle updates for performance
            if (!forceUpdate && currentTime - lastPositionUpdateTime < 16) {
                return;
            }
            lastPositionUpdateTime = currentTime;

            const timeDelta = lastUpdateTime ? (currentTime - lastUpdateTime) / 1000 : 0;

            // Create position object
            const newPosition = {
                lat: position.coords.latitude,
                lng: position.coords.longitude,
                accuracy: position.coords.accuracy || 20,
                heading: position.coords.heading !== null ? position.coords.heading : lastHeadingValue || undefined,
                timestamp: currentTime,
                speedMPS: position.coords.speed !== null ? position.coords.speed : 0,
            };

            if (isNaN(newPosition.lat) || isNaN(newPosition.lng)) {
                console.warn("Invalid coordinates received");
                return;
            }

            // Store raw position for comparison
            lastRawPosition = newPosition;

            // Track accuracy trend
            if (lastAccuracy !== null) {
                accuracyTrend.push(newPosition.accuracy - lastAccuracy);
                while (accuracyTrend.length > 5) accuracyTrend.shift();
            }
            lastAccuracy = newPosition.accuracy;

            // First position initialization
            if (!lastPosition) {
                lastPosition = newPosition;
                userMarker.setLatLng([newPosition.lat, newPosition.lng]);
                kalmanFilter.reset(newPosition);
                lastUpdateTime = currentTime;
                stationaryStartTime = currentTime;
                positionBuffer = [newPosition];
                lastStationaryPosition = newPosition;
                lastRenderPosition = newPosition;
                return;
            }

            // Calculate distance from last position
            const distance = calculateDistance(lastPosition, newPosition);

            // Handle large position changes or forced updates
            if (distance > EXTENDED_DISTANCE_THRESHOLD || forceUpdate) {
                if (stationaryCheckTimeout) {
                    clearTimeout(stationaryCheckTimeout);
                    stationaryCheckTimeout = null;
                }
                isStationary = false;
                stationaryStartTime = null;
                stationaryCount = 0;
                stationaryPositionHistory = [];
                lastStationaryPosition = null;
                consecutiveStationaryUpdates = 0;

                // Immediate visual update - no animation
                userMarker.setLatLng([newPosition.lat, newPosition.lng]);
                
                // Always recenter map to keep user centered
                if (followUser || forceCenteringActive) {
                    map.setView([newPosition.lat, newPosition.lng], map.getZoom(), {
                        animate: true,
                        duration: 0.3
                    });
                }

                // Reset tracking variables
                lastPosition = newPosition;
                lastRenderPosition = newPosition;
                positionBuffer = [newPosition];
                kalmanFilter.reset(newPosition);
                kalmanFilter.setStationaryMode(false);
                lastVelocity = { lat: 0, lng: 0 };

                // Cancel any active interpolation
                if (positionInterpolator) {
                    positionInterpolator.cancel();
                }

                // Clear any queued position updates
                positionUpdateQueue = [];

                lastUpdateTime = currentTime;
                lastUpdateTimestamp = currentTime;
                checkNearbyLocations();
                return;
            }

            // Skip updates with poor accuracy or unrealistic movement
            if (
                !forceUpdate &&
                (newPosition.accuracy > MAX_ACCEPTABLE_ACCURACY || (timeDelta > 0 && distance / timeDelta > 50))
            ) {
                console.debug("Skipping update due to poor accuracy or unrealistic movement");
                return;
            }

            try {
                // Check if device is in motion based on motion sensors
                const motionDetected = deviceMotion && isDeviceInMotion();

                // Enhanced stationary detection
                if (distance < MICRO_MOVEMENT_THRESHOLD && (!motionDetected || deviceStationaryTime > STATIONARY_TIME_THRESHOLD)) {
                    stationaryCount++;
                    consecutiveStationaryUpdates++;

                    if (!isStationary && stationaryCount >= STATIONARY_THRESHOLD) {
                        isStationary = true;
                        console.log("User is now stationary");

                        // Set Kalman filter to stationary mode
                        kalmanFilter.setStationaryMode(true);

                        // Update marker class
                        const markerElement = userMarker.getElement();
                        if (markerElement) {
                            markerElement.classList.add("user-marker-stationary");
                        }

                        // Calculate stable position from buffer
                        const stablePosition = calculateStationaryPosition(positionBuffer);
                        if (stablePosition) {
                            // Add to position update queue
                            positionUpdateQueue.push(stablePosition);
                            lastPosition = stablePosition;
                            lastStationaryPosition = stablePosition;
                        }

                        if (stationaryCheckTimeout) clearTimeout(stationaryCheckTimeout);
                        stationaryCheckTimeout = setTimeout(() => checkStationaryState(newPosition), STATIONARY_CHECK_INTERVAL);

                        checkNearbyLocations();
                        return;
                    }
                } else {
                    stationaryCount = Math.max(0, stationaryCount - 1);
                    consecutiveStationaryUpdates = 0;
                    if (isStationary && stationaryCount < STATIONARY_THRESHOLD / 2) {
                        
```You're absolutely right, and I apologize for the incomplete code. The file was cut off significantly. Let me provide the complete solution with all the necessary JavaScript functionality.

```html project="Minnesota Then Tours Ultimate" file="index.html" type="html"
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#2c5282">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Minnesota Then | Self-Guided Tours</title>
    <link rel="shortcut icon" type="image/x-icon" href="https://www.mnthen.com/images/mnthenfav.ico">
    <link rel="manifest" href="data:application/json;base64,eyJuYW1lIjoiTWlubmVzb3RhIFRoZW4gVG91cnMiLCJzaG9ydF9uYW1lIjoiTU4gVGhlbiIsImRlc2NyaXB0aW9uIjoiU2VsZi1ndWlkZWQgdG91cnMgb2YgaGlzdG9yaWMgTWlubmVzb3RhIiwic3RhcnRfdXJsIjoiLyIsImRpc3BsYXkiOiJzdGFuZGFsb25lIiwiYmFja2dyb3VuZF9jb2xvciI6IiNmZmZmZmYiLCJ0aGVtZV9jb2xvciI6IiMyYzUyODIiLCJpY29ucyI6W3sic3JjIjoiaHR0cHM6Ly93d3cubW50aGVuLmNvbS9pbWFnZXMvaWNvbi0xOTJ4MTkyLnBuZyIsInNpemVzIjoiMTkyeDE5MiIsInR5cGUiOiJpbWFnZS9wbmcifSx7InNyYyI6Imh0dHBzOi8vd3d3Lm1udGhlbi5jb20vaW1hZ2VzL2ljb24tNTEyeDUxMi5wbmciLCJzaXplcyI6IjUxMng1MTIiLCJ0eXBlIjoiaW1hZ2UvcG5nIn1dfQ==">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css">
    
<style>
/* Base styles */
:root {
--primary-color: #2c5282;
--primary-light: #3182ce;
--primary-dark: #1a365d;
--secondary-color: #e53e3e;
--secondary-light: #fc8181;
--secondary-dark: #c53030;
--accent-color: #38a169;
--accent-light: #68d391;
--accent-dark: #276749;
--text-color: #2d3748;
--text-light: #4a5568;
--text-lighter: #718096;
--bg-color: #ffffff;
--bg-light: #f7fafc;
--bg-dark: #edf2f7;
--shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
--shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
--shadow-md: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
--shadow-lg: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
--radius-sm: 0.125rem;
--radius: 0.25rem;
--radius-md: 0.375rem;
--radius-lg: 0.5rem;
--radius-xl: 1rem;
--radius-2xl: 1.5rem;
--transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
--transition-fast: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
--transition-slow: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
--font-sans: 'Segoe UI', -apple-system, BlinkMacSystemFont, 'Helvetica Neue', Arial, sans-serif;
}

* {
margin: 0;
padding: 0;
box-sizing: border-box;
}

body {
margin: 0;
padding: 0;
font-family: var(--font-sans);
overflow: hidden;
height: 100vh;
width: 100vw;
position: relative;
color: var(--text-color);
background-color: var(--bg-color);
-webkit-font-smoothing: antialiased;
-moz-osx-font-smoothing: grayscale;
touch-action: manipulation;
overscroll-behavior: none;
}

#map {
height: 100vh;
width: 100%;
z-index: 1;
}

/* Enhanced Distance box */
#distanceBox {
position: absolute;
top: 16px;
left: 16px;
background-color: rgba(255, 255, 255, 0.98);
padding: 16px 20px;
border-radius: var(--radius-lg);
box-shadow: var(--shadow-md);
z-index: 1000;
font-size: 20px;
font-weight: 600;
color: var(--text-color);
min-width: 200px;
max-width: 320px;
transition: var(--transition);
border-left: 6px solid var(--primary-color);
display: flex;
align-items: center;
backdrop-filter: blur(5px);
transform: translateZ(0);
}

#distanceBox .location-icon {
margin-right: 15px;
color: var(--primary-color);
font-size: 24px;
}

#distanceBox .distance-info {
display: flex;
flex-direction: column;
font-size: 20px;
}

#distanceBox .location-name {
font-weight: 700;
margin-bottom: 4px;
color: var(--primary-color);
font-size: 20px;
}

#distanceBox .distance-value {
font-size: 16px;
color: var(--text-light);
font-weight: 500;
}

/* Location hunt container */
.lochunt-container {
position: fixed;
bottom: 0;
left: 0;
width: 100%;
height: 80%;
background-color: var(--bg-color);
z-index: 1500;
border-radius: var(--radius-2xl) var(--radius-2xl) 0 0;
box-shadow: var(--shadow-lg);
transform: translateY(100%);
transition: transform 0.5s cubic-bezier(0.16, 1, 0.3, 1);
overflow: hidden;
display: none;
will-change: transform;
}

.lochunt-container.active {
transform: translateY(0);
display: block;
}

.lochunt-content {
padding: 24px;
overflow-y: auto;
height: calc(100% - 200px);
}

#locationImage {
width: 100%;
height: 200px;
object-fit: cover;
object-position: center;
}

.lochunt-info {
margin-bottom: 24px;
}

.lochunt-info h2 {
color: var(--primary-color);
margin-bottom: 8px;
font-weight: 700;
}

.lochunt-info p {
line-height: 1.6;
margin-bottom: 16px;
}

.text-muted {
color: var(--text-lighter);
font-size: 14px;
}

/* Audio player */
.audio-player {
margin-top: 24px;
padding: 20px;
background-color: var(--bg-light);
border-radius: var(--radius-lg);
box-shadow: var(--shadow-sm);
}

.audio-progress {
margin-bottom: 12px;
}

.progress {
height: 6px;
background-color: var(--bg-dark);
border-radius: var(--radius-xl);
overflow: hidden;
}

.progress-bar {
background-color: var(--primary-color);
height: 100%;
border-radius: var(--radius-xl);
transition: width 0.1s linear;
}

.audio-time {
display: flex;
justify-content: space-between;
font-size: 12px;
color: var(--text-lighter);
margin-bottom: 12px;
}

.audio-controls {
display: flex;
justify-content: space-between;
align-items: center;
max-width: 200px;
margin: 0 auto;
}

.audio-button {
background-color: var(--bg-color);
border: 2px solid var(--primary-color);
color: var(--primary-color);
width: 44px;
height: 44px;
border-radius: 50%;
display: flex;
align-items: center;
justify-content: center;
cursor: pointer;
transition: var(--transition-fast);
-webkit-tap-highlight-color: transparent;
}

.audio-button:hover, .audio-button:active {
background-color: var(--primary-color);
color: var(--bg-color);
transform: translateY(-2px);
}

/* Trivia container */
.trivia-container {
position: fixed;
bottom: 0;
left: 0;
width: 100%;
background-color: var(--bg-color);
z-index: 1500;
border-radius: var(--radius-2xl) var(--radius-2xl) 0 0;
box-shadow: var(--shadow-lg);
padding: 24px;
transform: translateY(100%);
transition: transform 0.5s cubic-bezier(0.16, 1, 0.3, 1);
display: none;
will-change: transform;
}

.trivia-container.active {
transform: translateY(0);
display: block;
}

.trivia-container h3 {
color: var(--primary-color);
margin-bottom: 16px;
font-weight: 700;
}

.trivia-option {
background-color: var(--bg-light);
border: 2px solid var(--bg-dark);
border-radius: var(--radius-lg);
padding: 16px;
margin-bottom: 12px;
cursor: pointer;
transition: var(--transition-fast);
font-weight: 500;
text-align: left;
width: 100%;
color: var(--text-color);
}

.trivia-option:hover, .trivia-option:active {
background-color: var(--bg-dark);
transform: translateY(-2px);
}

.trivia-option.correct {
background-color: var(--accent-light);
border-color: var(--accent-color);
color: var(--accent-dark);
}

.trivia-option.incorrect {
background-color: var(--secondary-light);
border-color: var(--secondary-color);
color: var(--secondary-dark);
}

/* Map buttons: horizontal and centered at bottom */
.map-buttons {
position: fixed; 
bottom: 40px; 
left: 50%;
transform: translateX(-50%);
display: flex;
flex-direction: row;
gap: 16px;
z-index: 1000;
background-color: rgba(255, 255, 255, 0.9);
padding: 12px 16px;
border-radius: var(--radius-xl);
box-shadow: var(--shadow-md);
backdrop-filter: blur(5px);
width: auto; /* Ensure width is based on content */
max-width: 90%; /* Prevent overflow on very small screens */
}

.map-button {
width: 50px;
height: 50px;
border-radius: 50%;
background-color: var(--bg-color);
border: none;
box-shadow: var(--shadow);
display: flex;
align-items: center;
justify-content: center;
font-size: 22px;
color: var(--primary-color);
cursor: pointer;
transition: var(--transition-fast);
-webkit-tap-highlight-color: transparent;
}

.map-button:hover, .map-button:active {
background-color: var(--primary-color);
color: var(--bg-color);
transform: scale(1.05);
box-shadow: var(--shadow-md);
}

.map-button.active {
background-color: var(--primary-color);
color: var(--bg-color);
}

/* Navigation tips */
.navigation-tips {
position: fixed;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
background-color: var(--bg-color);
border-radius: var(--radius-lg);
box-shadow: var(--shadow-lg);
padding: 24px;
z-index: 2000;
max-width: 90%;
width: 350px;
display: none;
}

.navigation-tips h3 {
margin-bottom: 16px;
color: var(--primary-color);
font-weight: 700;
}

.navigation-tips ul {
padding-left: 20px;
}

.navigation-tips li {
margin-bottom: 12px;
line-height: 1.5;
}

.close-button {
position: absolute;
top: 12px;
right: 12px;
background: none;
border: none;
font-size: 20px;
cursor: pointer;
color: var(--text-lighter);
transition: var(--transition-fast);
-webkit-tap-highlight-color: transparent;
}

.close-button:hover, .close-button:active {
color: var(--text-color);
}

/* Congratulations */
#congratulations {
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background-color: rgba(0, 0, 0, 0.85);
display: flex;
flex-direction: column;
align-items: center;
justify-content: center;
z-index: 3000;
color: var(--bg-color);
text-align: center;
padding: 24px;
display: none;
backdrop-filter: blur(5px);
}

#congratulations h2 {
font-size: 36px;
margin-bottom: 24px;
font-weight: 800;
}

#congratulations p {
font-size: 18px;
margin-bottom: 32px;
max-width: 600px;
line-height: 1.6;
}

#congratulations button {
background-color: var(--primary-color);
color: var(--bg-color);
border: none;
padding: 16px 32px;
border-radius: var(--radius-xl);
font-size: 18px;
font-weight: 600;
cursor: pointer;
transition: var(--transition);
box-shadow: var(--shadow);
}

#congratulations button:hover, #congratulations button:active {
background-color: var(--primary-dark);
transform: translateY(-3px);
box-shadow: var(--shadow-md);
}

/* Enhanced user marker styles */
.user-marker-icon {
width: 24px;
height: 24px;
background-color: var(--secondary-color);
border: 3px solid white;
border-radius: 50%;
box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
position: relative;
transition: transform 0.2s cubic-bezier(0.25, 0.1, 0.25, 1);
will-change: transform;
}

.user-marker-icon::after {
content: '';
position: absolute;
top: 50%;
left: 50%;
width: 36px;
height: 36px;
background-color: rgba(229, 62, 62, 0.2);
border-radius: 50%;
transform: translate(-50%, -50%);
animation: pulse 2s infinite;
will-change: transform, opacity;
}

@keyframes pulse {
0% {
transform: translate(-50%, -50%) scale(1);
opacity: 1;
}
100% {
transform: translate(-50%, -50%) scale(2);
opacity: 0;
}
}

/* Stationary indicator */
.user-marker-stationary .user-marker-icon {
border-color: var(--accent-color);
transition: border-color 0.5s ease-out;
}

.user-marker-stationary .user-marker-icon::after {
background-color: rgba(56, 161, 105, 0.15);
animation: stationaryPulse 3s infinite;
}

@keyframes stationaryPulse {
0% {
transform: translate(-50%, -50%) scale(1);
opacity: 0.6;
}
50% {
transform: translate(-50%, -50%) scale(1.3);
opacity: 0.3;
}
100% {
transform: translate(-50%, -50%) scale(1);
opacity: 0.6;
}
}

/* Optimize for hardware acceleration */
#map, .user-marker-icon, .lochunt-container, .trivia-container {
transform: translateZ(0);
backface-visibility: hidden;
perspective: 1000px;
}

/* Stabilizing modal */
.stabilizing-modal {
position: fixed;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
background-color: var(--bg-color);
padding: 24px;
border-radius: var(--radius-lg);
box-shadow: var(--shadow-lg);
z-index: 2000;
text-align: center;
max-width: 80%;
display: flex;
flex-direction: column;
align-items: center;
}

.stabilizing-modal h3 {
margin-bottom: 16px;
color: var(--primary-color);
font-weight: 700;
}

.stabilizing-modal p {
margin-bottom: 20px;
line-height: 1.5;
}

.stabilizing-modal .spinner {
width: 48px;
height: 48px;
border: 4px solid rgba(44, 82, 130, 0.2);
border-top: 4px solid var(--primary-color);
border-radius: 50%;
margin-bottom: 24px;
animation: spin 1s linear infinite;
}

@keyframes spin {
0% { transform: rotate(0deg); }
100% { transform: rotate(360deg); }
}

/* Preloader styles */
#preloader {
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background-color: var(--bg-color);
display: flex;
flex-direction: column;
justify-content: center;
align-items: center;
z-index: 9999;
}

#preloader .spinner {
width: 60px;
height: 60px;
border: 5px solid rgba(44, 82, 130, 0.2);
border-top: 5px solid var(--primary-color);
border-radius: 50%;
margin-bottom: 24px;
animation: spin 1s linear infinite;
}

#preloader p {
font-size: 18px;
color: var(--text-color);
margin-top: 16px;
font-weight: 500;
}

#preloader .progress-container {
width: 80%;
max-width: 300px;
height: 8px;
background-color: var(--bg-dark);
border-radius: var(--radius-xl);
margin-top: 20px;
overflow: hidden;
}

#preloader .progress-bar {
height: 100%;
background-color: var(--primary-color);
width: 0%;
transition: width 0.3s ease;
border-radius: var(--radius-xl);
}

/* Popup styles */
#popup {
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background-color: rgba(0, 0, 0, 0.5);
display: flex;
align-items: center;
justify-content: center;
z-index: 3000;
display: none;
backdrop-filter: blur(3px);
}

.popup-content {
background-color: var(--bg-color);
border-radius: var(--radius-lg);
padding: 24px;
max-width: 90%;
width: 350px;
text-align: center;
box-shadow: var(--shadow-lg);
}

#popupMessage {
margin-bottom: 24px;
line-height: 1.5;
}

.popup-button {
background-color: var(--primary-color);
color: var(--bg-color);
border: none;
padding: 12px 24px;
border-radius: var(--radius-lg);
font-weight: 600;
cursor: pointer;
transition: var(--transition);
}

.popup-button:hover, .popup-button:active {
background-color: var(--primary-dark);
transform: translateY(-2px);
}

/* Enhanced Location marker styles with numbering */
.location-marker-icon {
width: 40px;
height: 40px;
background-color: #006400;
border: 3px solid white;
border-radius: 50%;
box-shadow: var(--shadow);
position: relative;
transition: var(--transition);
display: flex;
align-items: center;
justify-content: center;
color: white;
font-weight: bold;
font-size: 16px;
}

.location-marker-icon:hover {
transform: scale(1.1);
background-color: var(--primary-dark);
}

/* Enhanced Marker popup styles */
.marker-popup {
max-width: 300px;
padding: 0;
}

.marker-popup-image {
width: 100%;
height: 150px;
object-fit: cover;
border-radius: var(--radius-lg) var(--radius-lg) 0 0;
margin-bottom: 0;
}

.marker-popup-content {
padding: 16px;
}

.marker-popup-title {
font-size: 18px;
font-weight: bold;
margin-bottom: 8px;
color: var(--primary-color);
}

.marker-popup-description {
font-size: 14px;
margin-bottom: 16px;
color: var(--text-light);
line-height: 1.5;
}

.marker-popup-actions {
display: flex;
justify-content: space-between;
gap: 12px;
}

.popup-btn {
padding: 10px 16px;
border-radius: var(--radius);
font-size: 14px;
font-weight: 600;
cursor: pointer;
text-align: center;
transition: var(--transition-fast);
display: flex;
align-items: center;
justify-content: center;
gap: 8px;
flex: 1;
}

.popup-btn.directions {
background-color: var(--primary-color);
color: white;
border: none;
}

.popup-btn.directions:hover, .popup-btn.directions:active {
background-color: var(--primary-dark);
transform: translateY(-2px);
}

.popup-btn.skip {
background-color: var(--bg-light);
color: var(--text-light);
border: 1px solid var(--bg-dark);
}

.popup-btn.skip:hover, .popup-btn.skip:active {
background-color: var(--bg-dark);
transform: translateY(-2px);
}

/* Directions modal */
#directionsModal {
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background-color: rgba(0, 0, 0, 0.5);
display: flex;
align-items: center;
justify-content: center;
z-index: 3000;
display: none;
backdrop-filter: blur(3px);
}

.directions-modal-content {
background-color: var(--bg-color);
border-radius: var(--radius-lg);
padding: 24px;
max-width: 90%;
width: 320px;
box-shadow: var(--shadow-lg);
}

.directions-modal-title {
font-size: 18px;
font-weight: 700;
margin-bottom: 20px;
color: var(--text-color);
text-align: center;
}

.directions-buttons {
display: flex;
flex-direction: column;
gap: 12px;
margin-bottom: 20px;
}

.direction-btn {
padding: 14px;
border-radius: var(--radius);
font-size: 16px;
font-weight: 600;
cursor: pointer;
text-align: center;
transition: var(--transition-fast);
display: flex;
align-items: center;
justify-content: center;
gap: 12px;
text-decoration: none;
}

.direction-btn.google {
background-color: #4285F4;
color: white;
border: none;
}

.direction-btn.apple {
background-color: #000000;
color: white;
border: none;
}

.direction-btn.waze {
background-color: #33CCFF;
color: white;
border: none;
}

.direction-btn:hover, .direction-btn:active {
transform: translateY(-2px);
box-shadow: var(--shadow);
}

.cancel-btn {
background-color: var(--bg-light);
color: var(--text-light);
border: 1px solid var(--bg-dark);
padding: 12px;
border-radius: var(--radius);
font-size: 16px;
font-weight: 600;
cursor: pointer;
text-align: center;
transition: var(--transition-fast);
width: 100%;
}

.cancel-btn:hover, .cancel-btn:active {
background-color: var(--bg-dark);
}

/* Leaflet popup customization */
.leaflet-popup-content-wrapper {
padding: 0;
overflow: hidden;
border-radius: var(--radius-lg);
box-shadow: var(--shadow-md);
}

.leaflet-popup-content {
margin: 0;
width: 280px !important;
}

.leaflet-popup-tip-container {
margin-top: -1px;
}

.leaflet-popup-close-button {
color: white !important;
top: 5px !important;
right: 5px !important;
font-size: 20px !important;
text-shadow: 0 0 3px rgba(0, 0, 0, 0.5);
}

/* Navigation buttons */
.marker-popup-navigation {
display: flex;
flex-direction: column;
gap: 10px;
margin-top: 16px;
}

.nav-button {
display: flex;
align-items: center;
justify-content: center;
gap: 8px;
padding: 10px;
border-radius: var(--radius);
text-decoration: none;
font-weight: 600;
font-size: 14px;
transition: var(--transition-fast);
}

.nav-button.google {
background-color: #4285F4;
color: white;
}

.nav-button.apple {
background-color: #000000;
color: white;
}

.nav-button.waze {
background-color: #33CCFF;
color: white;
}

.nav-button:hover, .nav-button:active {
transform: translateY(-2px);
box-shadow: var(--shadow);
}

/* Responsive adjustments */
@media (max-width: 768px) {
.map-buttons {
bottom: 30px; /* Adjust for medium screens */
padding: 10px 14px;
gap: 12px;
}

.map-button {
width: 46px;
height: 46px;
font-size: 20px;
}

#distanceBox {
max-width: 280px;
padding: 14px 16px;
}
}

@media (max-width: 480px) {
.map-buttons {
bottom: 25px; /* Increase from 20px to 25px for small screens */
padding: 8px 12px;
gap: 10px;
}

.map-button {
width: 40px; /* Slightly smaller buttons on very small screens */
height: 40px;
font-size: 16px;
}

#distanceBox {
max-width: 260px;
padding: 12px 14px;
left: 12px;
top: 12px;
font-size: 18px;
}

#distanceBox .location-icon {
font-size: 20px;
margin-right: 10px;
}

#distanceBox .location-name {
font-size: 18px;
}

#distanceBox .distance-value {
font-size: 16px;
}

.marker-popup {
max-width: 260px;
}

.marker-popup-image {
height: 130px;
}
}

/* Add a new media query for very small screens or devices with unusual interfaces */
@media (max-height: 600px), (max-width: 360px) {
.map-buttons {
bottom: 15px; /* Even more compact for very small screens */
}

.map-button {
width: 36px;
height: 36px;
font-size: 14px;
}
}

/* Add a safe area inset for iOS devices with notches */
@supports (padding-bottom: env(safe-area-inset-bottom)) {
.map-buttons {
bottom: calc(25px + env(safe-area-inset-bottom));
}
}

/* Debug overlay for development */
.debug-overlay {
position: fixed;
top: 10px;
right: 10px;
background-color: rgba(0, 0, 0, 0.7);
color: white;
padding: 10px;
border-radius: 5px;
font-size: 12px;
z-index: 2000;
max-width: 200px;
display: none;
}

/* Offline notification */
.offline-notification {
position: fixed;
top: 0;
left: 0;
width: 100%;
background-color: var(--secondary-color);
color: white;
text-align: center;
padding: 8px;
font-weight: bold;
z-index: 9000;
transform: translateY(-100%);
transition: transform 0.3s ease;
}

.offline-notification.visible {
transform: translateY(0);
}

/* Haptic feedback visual indicator */
.haptic-indicator {
position: fixed;
top: 50%;
left: 50%;
transform: translate(-50%, -50%) scale(0);
width: 100px;
height: 100px;
background-color: rgba(56, 161, 105, 0.3);
border-radius: 50%;
z-index: 1500;
pointer-events: none;
opacity: 0;
transition: transform 0.2s ease, opacity 0.2s ease;
}

.haptic-indicator.active {
transform: translate(-50%, -50%) scale(1);
opacity: 1;
animation: hapticPulse 0.5s ease-out;
}

@keyframes hapticPulse {
0% {
  transform: translate(-50%, -50%) scale(0.5);
  opacity: 0.8;
}
100% {
  transform: translate(-50%, -50%) scale(1.5);
  opacity: 0;
}
}

/* Orientation warning */
.orientation-warning {
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background-color: rgba(0, 0, 0, 0.9);
color: white;
display: flex;
flex-direction: column;
align-items: center;
justify-content: center;
z-index: 10000;
text-align: center;
padding: 20px;
display: none;
}

.orientation-warning h2 {
font-size: 24px;
margin-bottom: 20px;
}

.orientation-warning p {
font-size: 16px;
margin-bottom: 30px;
max-width: 300px;
}

.orientation-warning button {
background-color: var(--primary-color);
color: white;
border: none;
padding: 12px 24px;
border-radius: 5px;
font-weight: bold;
}

/* Improved user marker with direction indicator */
.user-marker-direction {
position: absolute;
top: 50%;
left: 50%;
width: 0;
height: 0;
border-left: 8px solid transparent;
border-right: 8px solid transparent;
border-bottom: 16px solid var(--secondary-color);
transform: translate(-50%, -50%) rotate(0deg);
transform-origin: center;
opacity: 0.9;
transition: transform 0.3s ease;
display: none;
}

.user-marker-icon.with-direction .user-marker-direction {
display: block;
}

/* Improved map attribution */
.leaflet-control-attribution {
background-color: rgba(255, 255, 255, 0.7) !important;
padding: 3px 8px !important;
border-radius: 4px !important;
font-size: 10px !important;
}
</style>

</head>
<body>
    <!-- Offline notification -->
    <div class="offline-notification" id="offlineNotification">
        You are currently offline. Some features may be limited.
    </div>

    <!-- Preloader -->
    <div id="preloader">
        <div class="spinner"></div>
        <p>Loading Minnesota Then Tours...</p>
        <div class="progress-container">
            <div class="progress-bar" id="preloaderProgress"></div>
        </div>
    </div>

    <div id="map"></div>
    
    <!-- Enhanced Distance Box -->
    <div id="distanceBox">
        <div class="location-icon">
            <i class="fas fa-map-marker-alt"></i>
        </div>
        <div class="distance-info">
            <div class="location-name">Initializing...</div>
            <div class="distance-value">Finding your location</div>
        </div>
    </div>
    
    <!-- Haptic feedback visual indicator -->
    <div class="haptic-indicator" id="hapticIndicator"></div>
    
    <div class="lochunt-container">
        <img id="locationImage" src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='400' height='200' viewBox='0 0 400 200'%3E%3Crect width='400' height='200' fill='%23f0f0f0'/%3E%3Ctext x='50%25' y='50%25' font-family='Arial' font-size='20' text-anchor='middle' dominant-baseline='middle' fill='%23999'%3ELoading image...%3C/text%3E%3C/svg%3E" alt="Location Image">
        <div class="lochunt-content">
            <div class="lochunt-info">
                <h2 id="locationTitle" class="mb-2"></h2>
                <p id="locationCity" class="text-muted mb-1"></p>
                <p id="locationCreator" class="text-muted mb-3"></p>
                <p id="locationDescription" class="mb-3"></p>
                
                <div class="marker-popup-navigation">
                    <a href="#" id="googleMapsLink" class="nav-button google" target="_blank">
                        <i class="fab fa-google"></i> Google Maps
                    </a>
                    <a href="#" id="appleMapsLink" class="nav-button apple" target="_blank">
                        <i class="fab fa-apple"></i> Apple Maps
                    </a>
                    <a href="#" id="wazeLink" class="nav-button waze" target="_blank">
                        <i class="fab fa-waze"></i> Waze
                    </a>
                </div>
            </div>
            <div class="audio-player">
                <div class="audio-progress">
                    <div class="progress">
                        <div id="progressBar" class="progress-bar" role="progressbar" style="width: 0%"></div>
                    </div>
                </div>
                <div class="audio-time">
                    <span id="currentTime">0:00</span>
                    <span id="duration">0:00</span>
                </div>
                <div class="audio-controls">
                    <button id="rewindBtn" class="audio-button"><i class="fas fa-backward"></i></button>
                    <button id="playPauseBtn" class="audio-button"><i class="fas fa-play"></i></button>
                    <button id="forwardBtn" class="audio-button"><i class="fas fa-forward"></i></button>
                </div>
                <audio id="locationAudio" preload="none"></audio>
            </div>
        </div>
    </div>
    
    <div class="trivia-container">
        <h3 class="mb-3">Trivia Question</h3>
        <p id="triviaQuestion" class="mb-3 fw-bold"></p>
        <div id="triviaOptions" class="d-grid gap-2"></div>
    </div>
    
    <!-- Enhanced Map Buttons: Horizontal and centered at bottom -->
    <div class="map-buttons">
        <button id="recenterButton" class="map-button" aria-label="Recenter map"><i class="fas fa-crosshairs"></i></button>
        <button id="returnButton" class="map-button" aria-label="Return to home"><i class="fas fa-sign-out-alt"></i></button>
        <button id="tipsButton" class="map-button" aria-label="Show tips"><i class="fas fa-question-circle"></i></button>
    </div>
    
    <div class="navigation-tips">
        <button class="close-button" aria-label="Close tips">&times;</button>
        <h3>Navigation Tips</h3>
        <ul>
            <li>Numbered markers show your tour stops in sequence.</li>
            <li>After visiting a location, the next stop will appear.</li>
            <li>Tap on a marker to see details and navigation options.</li>
            <li>The distance box shows how far you are from the current location.</li>
            <li>Tap the recenter button to focus on your position.</li>
            <li>When you're within 20 feet of a location, you'll be able to interact with it.</li>
            <li>Complete the trivia question to move to the next location.</li>
            <li>The map will automatically zoom in when you get closer to a location.</li>
        </ul>
    </div>
    
    <div id="congratulations">
        <h2>Congratulations!</h2>
        <p>You have successfully completed the Minnesota Then Gangster History Tour!</p>
        <button onclick="endTour()">Return to the Home Page</button>
    </div>
    
    <div id="popup">
        <div class="popup-content">
            <p id="popupMessage"></p>
            <button class="popup-button" onclick="closePopup()">OK</button>
        </div>
    </div>
    
    <!-- Directions Modal -->
    <div id="directionsModal">
        <div class="directions-modal-content">
            <div class="directions-modal-title">Choose Navigation App</div>
            <div class="directions-buttons">
                <a href="#" id="googleMapsBtn" class="direction-btn google" target="_blank">
                    <i class="fab fa-google"></i> Google Maps
                </a>
                <a href="#" id="appleMapsBtn" class="direction-btn apple" target="_blank">
                    <i class="fab fa-apple"></i> Apple Maps
                </a>
                <a href="#" id="wazeBtn" class="direction-btn waze" target="_blank">
                    <i class="fab fa-waze"></i> Waze
                </a>
            </div>
            <button class="cancel-btn" onclick="closeDirectionsModal()">Cancel</button>
        </div>
    </div>

    <!-- Orientation warning -->
    <div class="orientation-warning" id="orientationWarning">
        <h2>Please Enable Device Orientation</h2>
        <p>For the best experience, please allow access to your device's motion and orientation sensors.</p>
        <button id="orientationPermissionBtn">Enable Sensors</button>
    </div>

    <!-- Debug overlay -->
    <div class="debug-overlay" id="debugOverlay">
        <div id="debugInfo">Debug info will appear here</div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    
    <script>
        // Sample locations data (replace with your actual data)
        const locations = [
            {
                id: 1,
                name: "Landmark Center",
                city: "St. Paul",
                creator: "Minnesota Historical Society",
                lat: 44.9448,
                lng: -93.0962,
                image: "https://www.mnthen.com/images/landmark-center.jpg",
                audio: "https://www.mnthen.com/audio/landmark-center.mp3",
                description: "The Landmark Center, completed in 1902, originally served as the Federal Court House and Post Office for the Upper Midwest. This Richardsonian Romanesque building was where many famous gangsters were tried during the 1930s.",
                trivia: {
                    question: "What was the Landmark Center originally built as?",
                    options: [
                        "A hotel",
                        "A federal courthouse and post office",
                        "A train station",
                        "A department store"
                    ],
                    answer: 1
                }
            },
            {
                id: 2,
                name: "Wabasha Street Caves",
                city: "St. Paul",
                creator: "Minnesota Historical Society",
                lat: 44.9338,
                lng: -93.1059,
                image: "https://www.mnthen.com/images/wabasha-caves.jpg",
                audio: "https://www.mnthen.com/audio/wabasha-caves.mp3",
                description: "The Wabasha Street Caves were originally mined for silica in the 1840s. During Prohibition, the caves became a speakeasy known as the Castle Royal. Gangsters like John Dillinger and Ma Barker were rumored to frequent the establishment.",
                trivia: {
                    question: "What illegal activity took place in the Wabasha Street Caves during Prohibition?",
                    options: [
                        "Counterfeiting money",
                        "Illegal gambling",
                        "Speakeasy and nightclub",
                        "All of the above"
                    ],
                    answer: 3
                }
            },
            {
                id: 3,
                name: "Nina's Coffee Cafe",
                city: "St. Paul",
                creator: "Minnesota Historical Society",
                lat: 44.9463,
                lng: -93.1032,
                image: "https://www.mnthen.com/images/ninas-cafe.jpg",
                audio: "https://www.mnthen.com/audio/ninas-cafe.mp3",
                description: "Nina's Coffee Cafe is located in the historic Blair Flats building. The building is rumored to have been a hideout for Al Capone during his visits to St. Paul. The cafe now serves as a popular community gathering spot.",
                trivia: {
                    question: "Which famous gangster was rumored to have a hideout above what is now Nina's Coffee Cafe?",
                    options: [
                        "Al Capone",
                        "John Dillinger",
                        "Ma Barker",
                        "Baby Face Nelson"
                    ],
                    answer: 0
                }
            }
        ];

        // Global variables
        let map, userMarker;
        let currentLocationIndex = 0;
        let visitedLocations = [];
        let gameLocations = [];
        let inactivityTimer;
        let isLocationHuntVisible = false;
        let lastPosition = null;
        let positionBuffer = [];
        const MAX_BUFFER_SIZE = 20; // Increased buffer size for smoother tracking
        const DISTANCE_THRESHOLD = 20; // 20 feet to measure threshold distance to marker before opening location page
        const PROXIMITY_THRESHOLD = 100; // 100 feet to trigger zoom level change
        const HAPTIC_THRESHOLD = 200; // 200 feet to trigger haptic feedback
        const velocity = { lat: 0, lng: 0 };
        let isMapInteracting = false;
        let followUser = true;
        let allLocationMarkers = [];
        let showingAllLocations = false;
        let userIsInteracting = false;
        const preloadedImages = new Map(); // Map to store preloaded images
        const preloadedAudio = new Map(); // Map to store preloaded audio
        let currentSpeed = 0; // Current speed in meters per second
        let lastZoomLevel = 17; // Default zoom level
        let stationaryPositionHistory = []; // Array to store stationary positions for averaging
        let deviceOrientation = null; // Store device orientation data
        let deviceMotion = null; // Store device motion data
        let orientationPermissionGranted = false;
        let activeMarkers = []; // Track currently visible markers
        let currentDirectionsLocation = null; // Store current location for directions modal
        let lastProximityState = null; // Track last proximity state for zoom changes
        let isWithinProximity = false; // Flag to track if user is within proximity of a location
        let isWithinHapticRange = false; // Flag to track if user is within haptic feedback range
        let isOffline = false; // Flag to track offline status
        let mapTiles = null; // Store map tiles for offline use
        let debugMode = false; // Flag to enable debug mode
        let orientationWarningShown = false; // Flag to track if orientation warning has been shown
        let serviceWorkerRegistered = false; // Flag to track if service worker is registered

        // Enhanced constants for better stabilization
        const MICRO_MOVEMENT_THRESHOLD = 0.25; // Meters - threshold for detecting micro-movements (reduced for better stability)
        const STATIONARY_ACCURACY_MULTIPLIER = 1.01; // Tighter accuracy bounds
        const MAX_ACCEPTABLE_ACCURACY = 20; // meters - stricter accuracy requirement
        const STATIONARY_THRESHOLD = 4; // Number of consecutive stationary positions to consider user as stationary
        const STATIONARY_TIME_THRESHOLD = 1500; // ms - time to consider user stationary
        const STATIONARY_CHECK_INTERVAL = 800; // ms - interval to check if still stationary
        const VELOCITY_DECAY = 0.94; // Higher value for smoother velocity transitions
        const MIN_DISTANCE_THRESHOLD = 0.5; // meters - minimum distance to consider movement
        const EXTENDED_DISTANCE_THRESHOLD = 60; // meters - distance to consider a significant position change
        const UPDATE_INTERVAL = 8; // ms - more frequent updates for smoother animation (approx 120fps)
        const STATIONARY_POSITION_HISTORY_SIZE = 20; // Number of positions to keep for stationary averaging
        const STATIONARY_POSITION_WEIGHT_DECAY = 0.92; // Weight decay for older positions in stationary average

        // Background handling constants
        const BACKGROUND_THRESHOLD = 15000; // ms - time to consider app was in background
        const INACTIVITY_TIMEOUT = 20000; // ms - time to consider user inactive

        // Kalman filter parameters - optimized for better stationary stability
        const KALMAN_PROCESS_NOISE = 0.0025; // Lower value for smoother tracking
        const KALMAN_MEASUREMENT_NOISE_BASE = 1.0; // Increased base measurement noise
        const KALMAN_STATIONARY_NOISE = 0.01; // Lower noise when stationary

        // Animation parameters
        const ANIMATION_DURATION = 150; // ms - duration of position animation
        const HEADING_SMOOTHING = 0.92; // Heading smoothing factor

        // Dynamic zoom level parameters - enhanced for better speed adaptation
        const MAX_ZOOM_LEVEL = 18; // Maximum zoom level (stationary)
        const MIN_ZOOM_LEVEL = 13; // Minimum zoom level (high speed)
        const DEFAULT_ZOOM_LEVEL = 17; // Default zoom level for walking speed
        const PROXIMITY_ZOOM_LEVEL = 18; // Zoom level when in proximity to a location
        const WALKING_SPEED_THRESHOLD = 1.5; // m/s - threshold for walking speed
        const RUNNING_SPEED_THRESHOLD = 4.0; // m/s - threshold for running speed
        const DRIVING_SPEED_THRESHOLD = 8.0; // m/s - threshold for driving speed
        const HIGH_SPEED_THRESHOLD = 20.0; // m/s - threshold for high speed
        const ZOOM_TRANSITION_DURATION = 0.4; // seconds - duration of zoom transition
        const ZOOM_UPDATE_INTERVAL = 800; // ms - interval to update zoom level

        // Motion detection parameters
        const MOTION_THRESHOLD = 0.5; // Threshold for detecting significant motion
        const MOTION_SAMPLE_SIZE = 10; // Number of motion samples to keep
        const MOTION_CHECK_INTERVAL = 80; // ms - interval to check motion

        // Edge detection parameters - updated for better recentering
        const EDGE_THRESHOLD_PERCENTAGE = 0.12; // Percentage from edge to trigger recenter
        const STRICT_EDGE_THRESHOLD_PERCENTAGE = 0.08; // Stricter threshold for edge detection
        const CRITICAL_EDGE_THRESHOLD_PERCENTAGE = 0.04; // Critical threshold for immediate recenter
        const RECENTER_COOLDOWN = 300; // ms - cooldown between recenters to prevent excessive recentering

        // Dynamic recentering parameters
        const SPEED_RECENTER_THRESHOLD = 4.0; // m/s - speed threshold to adjust recenter behavior
        const RECENTER_OFFSET_FACTOR = 0.25; // Factor to offset the center point ahead of user when moving fast

        // Haptic feedback parameters
        const HAPTIC_FEEDBACK_DURATION = 50; // ms - duration of haptic feedback
        const HAPTIC_FEEDBACK_INTERVAL = 5000; // ms - minimum interval between haptic feedback
        const HAPTIC_PATTERN = [50, 100, 50]; // Vibration pattern for haptic feedback

        // Offline mode parameters
        const OFFLINE_CHECK_INTERVAL = 10000; // ms - interval to check offline status
        const TILE_CACHE_SIZE = 100; // Number of map tiles to cache for offline use

        // Debug parameters
        const DEBUG_UPDATE_INTERVAL = 500; // ms - interval to update debug info

        // State variables
        let lastUpdateTime = null;
        let lastVelocity = { lat: 0, lng: 0 };
        let isStationary = false;
        let stationaryStartTime = null;
        let stationaryCheckTimeout = null;
        let lastUpdateTimestamp = null;
        let lastHiddenTime = 0;
        let stationaryCount = 0;
        let lastRecenterTime = Date.now();
        let stationaryBuffer = [];
        let isStabilizing = true; // Flag to track initial stabilization
        let lastStationaryPosition = null; // Last stable position when stationary
        let motionSamples = []; // Array to store motion samples
        let deviceStationaryTime = 0; // Time device has been stationary based on motion sensors
        let animationFrameId = null; // Store requestAnimationFrame ID
        let renderTimestamp = null; // Last render timestamp
        let positionUpdateQueue = []; // Queue for position updates to be processed
        let lastHeadingValue = null; // Last heading value
        let headingBuffer = []; // Buffer for heading values
        let isFirstPositionUpdate = true; // Flag for first position update
        let lastRenderPosition = null; // Last rendered position
        let positionInterpolator = null; // Position interpolator for smooth transitions
        let lastRawPosition = null; // Last raw position from GPS
        let consecutiveStationaryUpdates = 0; // Count consecutive stationary updates
        let lastDeviceMotionTimestamp = 0; // Last device motion timestamp
        let deviceMotionBuffer = []; // Buffer for device motion data
        let isDeviceStable = false; // Flag for device stability
        let lastAccuracy = null; // Last position accuracy
        let accuracyTrend = []; // Track accuracy trend
        let lastHeadingUpdateTime = 0; // Last heading update time
        let lastPositionUpdateTime = 0; // Last position update time
        let lastZoomUpdateTime = 0; // Last zoom update time
        let targetZoomLevel = DEFAULT_ZOOM_LEVEL; // Target zoom level for smooth transitions
        let lastSpeedForZoom = 0; // Last speed used for zoom calculation
        let speedSamples = []; // Array to store speed samples for zoom calculation
        let lastRecenterCheckTime = 0; // Last time we checked for recentering
        let lastProximityCheckTime = 0; // Last time we checked for proximity
        let proximityZoomActive = false; // Flag to track if proximity zoom is active
        let forceCenteringActive = true; // Flag to force centering regardless of other conditions - start with true
        let centeringPriority = 10; // Priority level for centering (0-10) - start with max priority
        let lastHapticFeedbackTime = 0; // Last time haptic feedback was triggered
        let offlineCheckInterval = null; // Interval to check offline status
        let debugUpdateInterval = null; // Interval to update debug info
        let mapInteractionTimeout = null; // Timeout to reset map interaction flag
        let lastOrientationPermissionCheck = 0; // Last time we checked for orientation permission
        let watchPositionId = null; // ID for watchPosition
        let highAccuracyFailed = false; // Flag to track if high accuracy failed
        let mapInitialized = false; // Flag to track if map is initialized
        let mapCenteringInterval = null; // Interval to force map centering
        let lastMapCenteringTime = 0; // Last time map was centered
        let mapCenteringCount = 0; // Count of map centerings
        let mapCenteringActive = false; // Flag to track if map centering is active
        let mapCenteringForced = false; // Flag to track if map centering was forced
        let mapCenteringTimeout = null; // Timeout to reset map centering
        let mapCenteringIntervalId = null; // ID for map centering interval
        let lastMapInteractionTime = 0; // Last time user interacted with map
        let mapInteractionCount = 0; // Count of map interactions
        let mapInteractionActive = false; // Flag to track if map interaction is active
        let mapInteractionForced = false; // Flag to track if map interaction was forced
        let mapInteractionTimeout = null; // Timeout to reset map interaction
        let mapInteractionIntervalId = null; // ID for map interaction interval
        let lastMapMoveTime = 0; // Last time map was moved
        let mapMoveCount = 0; // Count of map moves
        let mapMoveActive = false; // Flag to track if map move is active
        let mapMoveForced = false; // Flag to track if map move was forced
        let mapMoveTimeout = null; // Timeout to reset map move
        let mapMoveIntervalId = null; // ID for map move interval
        let lastMapZoomTime = 0; // Last time map was zoomed
        let mapZoomCount = 0; // Count of map zooms
        let mapZoomActive = false; // Flag to track if map zoom is active
        let mapZoomForced = false; // Flag to track if map zoom was forced
        let mapZoomTimeout = null; // Timeout to reset map zoom
        let mapZoomIntervalId = null; // ID for map zoom interval
        let lastMapDragTime = 0; // Last time map was dragged
        let mapDragCount = 0; // Count of map drags
        let mapDragActive = false; // Flag to track if map drag is active
        let mapDragForced = false; // Flag to track if map drag was forced
        let mapDragTimeout = null; // Timeout to reset map drag
        let mapDragIntervalId = null; // ID for map drag interval
        let lastMapPanTime = 0; // Last time map was panned
        let mapPanCount = 0; // Count of map pans
        let mapPanActive = false; // Flag to track if map pan is active
        let mapPanForced = false; // Flag to track if map pan was forced
        let mapPanTimeout = null; // Timeout to reset map pan
        let mapPanIntervalId = null; // ID for map pan interval
        let lastHapticFeedback = 0; // Last time haptic feedback was triggered
        let hapticFeedbackCount = 0; // Count of haptic feedbacks
        let hapticFeedbackActive = false; // Flag to track if haptic feedback is active
        let hapticFeedbackForced = false; // Flag to track if haptic feedback was forced
        let hapticFeedbackTimeout = null; // Timeout to reset haptic feedback
        let hapticFeedbackIntervalId = null; // ID for haptic feedback interval

        // Enhanced Kalman Filter implementation with adaptive noise and multi-sensor fusion
        class KalmanFilter {
            constructor() {
                // State variables
                this.x = 0; // Longitude estimate
                this.y = 0; // Latitude estimate
                this.vx = 0; // Longitude velocity
                this.vy = 0; // Latitude velocity

                // Error covariance matrix
                this.P = [
                    [100, 0, 0, 0], // Initial high uncertainty
                    [0, 100, 0, 0],
                    [0, 0, 10, 0],
                    [0, 0, 0, 10],
                ];

                // Process noise
                this.Q = KALMAN_PROCESS_NOISE;

                // Measurement noise (will be adjusted based on GPS accuracy)
                this.R = KALMAN_MEASUREMENT_NOISE_BASE;

                // Time delta
                this.dt = 1.0;

                // Initialized flag
                this.initialized = false;

                // Heading and accuracy tracking
                this.lastHeading = null;
                this.headingConfidence = 0;

                // Stationary mode flag
                this.stationaryMode = false;

                // Last timestamp
                this.lastTimestamp = null;

                // Adaptive noise parameters
                this.adaptiveNoiseMin = 0.001;
                this.adaptiveNoiseMax = 0.01;
                this.adaptiveNoiseFactor = 1.0;

                // Accuracy history
                this.accuracyHistory = [];
                this.maxAccuracyHistorySize = 8;

                // Jitter detection
                this.positionHistory = [];
                this.maxPositionHistorySize = 8;
                this.jitterThreshold = 0.4; // meters

                // Heading stability
                this.headingHistory = [];
                this.maxHeadingHistorySize = 10;
                
                // Motion integration
                this.motionIntegrated = false;
                this.motionConfidence = 0;
                
                // Sensor fusion weights
                this.gpsWeight = 1.0;
                this.motionWeight = 0.0;
                this.headingWeight = 0.0;
                
                // Adaptive parameters
                this.adaptiveParameters = {
                    stationary: {
                        processNoise: KALMAN_STATIONARY_NOISE,
                        measurementNoise: KALMAN_MEASUREMENT_NOISE_BASE * 2,
                        velocityDamping: 0.95
                    },
                    walking: {
                        processNoise: KALMAN_PROCESS_NOISE,
                        measurementNoise: KALMAN_MEASUREMENT_NOISE_BASE,
                        velocityDamping: 0.8
                    },
                    driving: {
                        processNoise: KALMAN_PROCESS_NOISE * 1.5,
                        measurementNoise: KALMAN_MEASUREMENT_NOISE_BASE * 0.8,
                        velocityDamping: 0.6
                    }
                };
                
                // Current mode
                this.currentMode = 'stationary';
                
                // Confidence in current estimate
                this.estimateConfidence = 0;
            }

            // Initialize the filter with first position
            reset(position) {
                if (!position || typeof position.lat !== "number" || typeof position.lng !== "number") {
                    console.error("Invalid position for Kalman filter reset");
                    return;
                }

                this.x = position.lng;
                this.y = position.lat;
                this.vx = 0;
                this.vy = 0;

                // Reset covariance matrix with high initial uncertainty
                this.P = [
                    [100, 0, 0, 0],
                    [0, 100, 0, 0],
                    [0, 0, 10, 0],
                    [0, 0, 0, 10],
                ];

                this.initialized = true;
                this.lastHeading = position.heading || null;
                this.headingConfidence = 0;
                this.stationaryMode = false;
                this.lastTimestamp = position.timestamp || Date.now();
                this.adaptiveNoiseFactor = 1.0;
                this.accuracyHistory = [];
                this.positionHistory = [];
                this.headingHistory = [];
                this.currentMode = 'stationary';
                this.estimateConfidence = 0;

                // Add initial position to history
                this.addToPositionHistory(position);
                if (position.accuracy) {
                    this.addToAccuracyHistory(position.accuracy);
                }
                if (position.heading !== null && position.heading !== undefined) {
                    this.addToHeadingHistory(position.heading);
                }
            }

            // Add position to history
            addToPositionHistory(position) {
                this.positionHistory.push({
                    lat: position.lat,
                    lng: position.lng,
                    timestamp: position.timestamp || Date.now(),
                    accuracy: position.accuracy || 20
                });

                while (this.positionHistory.length > this.maxPositionHistorySize) {
                    this.positionHistory.shift();
                }
            }

            // Add accuracy to history
            addToAccuracyHistory(accuracy) {
                this.accuracyHistory.push(accuracy);

                while (this.accuracyHistory.length > this.maxAccuracyHistorySize) {
                    this.accuracyHistory.shift();
                }
            }

            // Add heading to history
            addToHeadingHistory(heading) {
                // Normalize heading to 0-360 range
                heading = ((heading % 360) + 360) % 360;

                this.headingHistory.push({
                    heading: heading,
                    timestamp: Date.now(),
                });

                while (this.headingHistory.length > this.maxHeadingHistorySize) {
                    this.headingHistory.shift();
                }
            }

            // Get median accuracy from history
            getMedianAccuracy() {
                if (this.accuracyHistory.length === 0) return 20;

                const sortedAccuracies = [...this.accuracyHistory].sort((a, b) => a - b);
                const mid = Math.floor(sortedAccuracies.length / 2);

                if (sortedAccuracies.length % 2 === 0) {
                    return (sortedAccuracies[mid - 1] + sortedAccuracies[mid]) / 2;
                } else {
                    return sortedAccuracies[mid];
                }
            }

            // Detect jitter in position history
            detectJitter() {
                if (this.positionHistory.length < 3) return false;

                // Calculate distances between consecutive positions
                const distances = [];
                for (let i = 1; i < this.positionHistory.length; i++) {
                    const p1 = this.positionHistory[i - 1];
                    const p2 = this.positionHistory[i];

                    // Calculate distance in meters
                    const distance = calculateDistance(p1, p2);

                    // Calculate time delta in seconds
                    const timeDelta = (p2.timestamp - p1.timestamp) / 1000;

                    // Calculate speed in m/s
                    const speed = timeDelta > 0 ? distance / timeDelta : 0;

                    distances.push({ distance, speed });
                }

                // Check for rapid direction changes (jitter)
                if (distances.length >= 2) {
                    const lastDistance = distances[distances.length - 1].distance;
                    const prevDistance = distances[distances.length - 2].distance;

                    // If both distances are small but non-zero, it might be jitter
                    if (
                        lastDistance > 0 &&
                        lastDistance < this.jitterThreshold &&
                        prevDistance > 0 &&
                        prevDistance < this.jitterThreshold
                    ) {
                        return true;
                    }
                }

                return false;
            }

            // Get stable heading from history
            getStableHeading() {
                if (this.headingHistory.length < 3) {
                    return this.lastHeading;
                }

                // Get recent headings (last 3)
                const recentHeadings = this.headingHistory.slice(-3).map((h) => h.heading);

                // Check if headings are stable (within 15 degrees of each other)
                let isStable = true;
                for (let i = 1; i < recentHeadings.length; i++) {
                    const diff = Math.abs(recentHeadings[i] - recentHeadings[i - 1]);
                    const normalizedDiff = Math.min(diff, 360 - diff);
                    if (normalizedDiff > 15) {
                        isStable = false;
                        break;
                    }
                }

                if (isStable) {
                    // Return median heading
                    const sortedHeadings = [...recentHeadings].sort((a, b) => a - b);
                    return sortedHeadings[Math.floor(sortedHeadings.length / 2)];
                }

                return this.lastHeading;
            }

            // Set stationary mode
            setStationaryMode(isStationary) {
                this.stationaryMode = isStationary;
                this.currentMode = isStationary ? 'stationary' : 'walking';

                // When entering stationary mode, reduce velocity to zero
                if (isStationary) {
                    this.vx = 0;
                    this.vy = 0;

                    // Reduce process noise for stationary mode
                    this.Q = this.adaptiveParameters.stationary.processNoise;
                    this.adaptiveNoiseFactor = 0.4; // Reduce noise in stationary mode
                } else {
                    // Reset to normal process noise when moving
                    this.Q = this.adaptiveParameters.walking.processNoise;
                    this.adaptiveNoiseFactor = 1.0; // Normal noise when moving
                }
            }

            // Adjust process noise based on accuracy and motion
            adjustProcessNoise(accuracy, motionDetected, speed) {
                // Determine current mode based on speed
                if (this.stationaryMode) {
                    this.currentMode = 'stationary';
                } else if (speed > DRIVING_SPEED_THRESHOLD) {
                    this.currentMode = 'driving';
                } else {
                    this.currentMode = 'walking';
                }
                
                // Get parameters for current mode
                const params = this.adaptiveParameters[this.currentMode];
                
                // Base noise level depends on GPS accuracy
                let noiseLevel = params.processNoise;

                // Adjust based on accuracy
                noiseLevel *= Math.min(1.0, accuracy / 40.0) + 0.5;

                // Increase noise when motion is detected
                if (motionDetected && !this.stationaryMode) {
                    noiseLevel *= 1.5;
                }

                // Decrease noise when jitter is detected
                if (this.detectJitter()) {
                    noiseLevel *= 0.6; // Reduce noise to smooth out jitter
                }

                // Apply adaptive factor
                noiseLevel *= this.adaptiveNoiseFactor;

                // Set process noise
                this.Q = noiseLevel;
                
                // Update measurement noise
                this.R = params.measurementNoise * (accuracy / 20);
            }

            // Update the filter with new measurement
            update(position, motionDetected = false) {
                if (!this.initialized) {
                    this.reset(position);
                    return position;
                }

                if (!position || typeof position.lat !== "number" || typeof position.lng !== "number") {
                    console.warn("Invalid position input to Kalman filter");
                    return {
                        lat: this.y,
                        lng: this.x,
                        accuracy: position?.accuracy || 20,
                        heading: this.lastHeading,
                        timestamp: position?.timestamp || Date.now(),
                    };
                }

                // Add to position history
                this.addToPositionHistory(position);

                // Add to accuracy history
                if (position.accuracy) {
                    this.addToAccuracyHistory(position.accuracy);
                }

                // Add to heading history
                if (position.heading !== null && position.heading !== undefined) {
                    this.addToHeadingHistory(position.heading);
                }

                // Calculate time delta
                const timestamp = position.timestamp || Date.now();
                if (this.lastTimestamp) {
                    this.dt = Math.min(Math.max((timestamp - this.lastTimestamp) / 1000, 0.01), 1.0);
                }
                this.lastTimestamp = timestamp;

                // Adjust measurement noise based on GPS accuracy
                const accuracy = position.accuracy || 20;
                const medianAccuracy = this.getMedianAccuracy();
                
                // Calculate current speed
                const speed = position.speedMPS || 0;

                // Adjust process noise based on accuracy, motion and speed
                this.adjustProcessNoise(accuracy, motionDetected, speed);

                // State transition matrix
                const F = [
                    [1, 0, this.dt, 0],
                    [0, 1, 0, this.dt],
                    [0, 0, 1, 0],
                    [0, 0, 0, 1],
                ];

                // Predict step
                // x = F * x
                const predictedX = this.x + this.dt * this.vx;
                const predictedY = this.y + this.dt * this.vy;
                
                // Apply velocity damping based on current mode
                const velocityDamping = this.adaptiveParameters[this.currentMode].velocityDamping;
                const predictedVx = this.stationaryMode ? 0 : this.vx * velocityDamping;
                const predictedVy = this.stationaryMode ? 0 : this.vy * velocityDamping;

                // P = F * P * F' + Q
                const Q = [
                    [(this.Q * this.dt * this.dt * this.dt * this.dt) / 4, 0, (this.Q * this.dt * this.dt * this.dt) / 2, 0],
                    [0, (this.Q * this.dt * this.dt * this.dt * this.dt) / 4, 0, (this.Q * this.dt * this.dt * this.dt) / 2],
                    [(this.Q * this.dt * this.dt * this.dt) / 2, 0, this.Q * this.dt * this.dt, 0],
                    [0, (this.Q * this.dt * this.dt * this.dt) / 2, 0, this.Q * this.dt * this.dt],
                ];

                // Matrix multiplication F * P
                const FP = [
                    [
                        this.P[0][0] + this.dt * this.P[2][0],
                        this.P[0][1] + this.dt * this.P[2][1],
                        this.P[0][2] + this.dt * this.P[2][2],
                        this.P[0][3] + this.dt * this.P[2][3],
                    ],
                    [
                        this.P[1][0] + this.dt * this.P[3][0],
                        this.P[1][1] + this.dt * this.P[3][1],
                        this.P[1][2] + this.dt * this.P[3][2],
                        this.P[1][3] + this.dt * this.P[3][3],
                    ],
                    [this.P[2][0], this.P[2][1], this.P[2][2], this.P[2][3]],
                    [this.P[3][0], this.P[3][1], this.P[3][2], this.P[3][3]],
                ];

                // Matrix multiplication FP * F'
                const predictedP = [
                    [
                        FP[0][0] + this.dt * FP[0][2] + Q[0][0],
                        FP[0][1] + this.dt * FP[0][3] + Q[0][1],
                        FP[0][2] + Q[0][2],
                        FP[0][3] + Q[0][3],
                    ],
                    [
                        FP[1][0] + this.dt * FP[1][2] + Q[1][0],
                        FP[1][1] + this.dt * FP[1][3] + Q[1][1],
                        FP[1][2] + Q[1][2],
                        FP[1][3] + Q[1][3],
                    ],
                    [FP[2][0] + Q[2][0], FP[2][1] + Q[2][1], FP[2][2] + Q[2][2], FP[2][3] + Q[2][3]],
                    [FP[3][0] + Q[3][0], FP[3][1] + Q[3][1], FP[3][2] + Q[3][2], FP[3][3] + Q[3][3]],
                ];

                // Update step
                // y = z - H * x
                const measurementResidualX = position.lng - predictedX;
                const measurementResidualY = position.lat - predictedY;

                // S = H * P * H' + R
                const S = [
                    [predictedP[0][0] + this.R, predictedP[0][1]],
                    [predictedP[1][0], predictedP[1][1] + this.R],
                ];

                // Calculate determinant of S
                const detS = S[0][0] * S[1][1] - S[0][1] * S[1][0];

                // Calculate inverse of S
                const invS = [
                    [S[1][1] / detS, -S[0][1] / detS],
                    [-S[1][0] / detS, S[0][0] / detS],
                ];

                // K = P * H' * inv(S)
                const K = [
                    [
                        predictedP[0][0] * invS[0][0] + predictedP[0][1] * invS[1][0],
                        predictedP[0][0] * invS[0][1] + predictedP[0][1] * invS[1][1],
                    ],
                    [
                        predictedP[1][0] * invS[0][0] + predictedP[1][1] * invS[1][0],
                        predictedP[1][0] * invS[0][1] + predictedP[1][1] * invS[1][1],
                    ],
                    [
                        predictedP[2][0] * invS[0][0] + predictedP[2][1] * invS[1][0],
                        predictedP[2][0] * invS[0][1] + predictedP[2][1] * invS[1][1],
                    ],
                    [
                        predictedP[3][0] * invS[0][0] + predictedP[3][1] * invS[1][0],
                        predictedP[3][0] * invS[0][1] + predictedP[3][1] * invS[1][1],
                    ],
                ];

                // x = x + K * y
                this.x = predictedX + K[0][0] * measurementResidualX + K[0][1] * measurementResidualY;
                this.y = predictedY + K[1][0] * measurementResidualX + K[1][1] * measurementResidualY;

                // In stationary mode, keep velocity at zero
                if (this.stationaryMode) {
                    this.vx = 0;
                    this.vy = 0;
                } else {
                    this.vx = predictedVx + K[2][0] * measurementResidualX + K[2][1] * measurementResidualY;
                    this.vy = predictedVy + K[3][0] * measurementResidualX + K[3][1] * measurementResidualY;
                }

                // P = (I - K * H) * P
                this.P = [
                    [
                        predictedP[0][0] - (K[0][0] * predictedP[0][0] + K[0][1] * predictedP[1][0]),
                        predictedP[0][1] - (K[0][0] * predictedP[0][1] + K[0][1] * predictedP[1][1]),
                        predictedP[0][2] - (K[0][0] * predictedP[0][2] + K[0][1] * predictedP[1][2]),
                        predictedP[0][3] - (K[0][0] * predictedP[0][3] + K[0][1] * predictedP[1][3]),
                    ],
                    [
                        predictedP[1][0] - (K[1][0] * predictedP[0][0] + K[1][1] * predictedP[1][0]),
                        predictedP[1][1] - (K[1][0] * predictedP[0][1] + K[1][1] * predictedP[1][1]),
                        predictedP[1][2] - (K[1][0] * predictedP[0][2] + K[1][1] * predictedP[1][2]),
                        predictedP[1][3] - (K[1][0] * predictedP[0][3] + K[1][1] * predictedP[1][3]),
                    ],
                    [
                        predictedP[2][0] - (K[2][0] * predictedP[0][0] + K[2][1] * predictedP[1][0]),
                        predictedP[2][1] - (K[2][0] * predictedP[0][1] + K[2][1] * predictedP[1][1]),
                        predictedP[2][2] - (K[2][0] * predictedP[0][2] + K[2][1] * predictedP[1][2]),
                        predictedP[2][3] - (K[2][0] * predictedP[0][3] + K[2][1] * predictedP[1][3]),
                    ],
                    [
                        predictedP[3][0] - (K[3][0] * predictedP[0][0] + K[3][1] * predictedP[1][0]),
                        predictedP[3][1] - (K[3][0] * predictedP[0][1] + K[3][1] * predictedP[1][1]),
                        predictedP[3][2] - (K[3][0] * predictedP[0][2] + K[3][1] * predictedP[1][2]),
                        predictedP[3][3] - (K[3][0] * predictedP[0][3] + K[3][1] * predictedP[1][3]),
                    ],
                ];

                // Process heading data
                let smoothedHeading = position.heading;
                if (position.heading !== null && position.heading !== undefined) {
                    // Get stable heading from history
                    smoothedHeading = this.getStableHeading();

                    // If no stable heading yet, use current heading
                    if (smoothedHeading === null) {
                        smoothedHeading = position.heading;
                    }

                    this.lastHeading = smoothedHeading;
                }

                // Calculate speed from velocity components
                const calculatedSpeed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                
                // Calculate estimate confidence (0-1)
                const positionUncertainty = Math.sqrt(this.P[0][0] + this.P[1][1]);
                this.estimateConfidence = Math.max(0, Math.min(1, 1 - (positionUncertainty / 100)));

                return {
                    lat: this.y,
                    lng: this.x,
                    accuracy: position.accuracy,
                    heading: smoothedHeading,
                    timestamp: position.timestamp,
                    speedMPS: this.stationaryMode ? 0 : calculatedSpeed * 111000, // Convert from degrees/second to meters/second (approximate)
                    confidence: this.estimateConfidence,
                    mode: this.currentMode
                };
            }
        }

        // Position interpolator for smooth transitions
        class PositionInterpolator {
            constructor() {
                this.startPosition = null;
                this.targetPosition = null;
                this.startTime = null;
                this.duration = 0;
                this.isActive = false;
                this.lastInterpolatedPosition = null;
                this.easingFunction = this.easeOutCubic; // Default easing function
            }

            start(startPos, targetPos, duration, easingFunction = null) {
                if (!startPos || !targetPos) return;

                // Don't interpolate if positions are too close
                const distance = calculateDistance(startPos, targetPos);
                if (distance < 0.05) {
                    this.isActive = false;
                    this.lastInterpolatedPosition = targetPos;
                    return;
                }

                this.startPosition = { ...startPos };
                this.targetPosition = { ...targetPos };
                this.startTime = performance.now();
                this.duration = duration;
                this.isActive = true;
                
                // Set easing function if provided
                if (easingFunction) {
                    this.easingFunction = easingFunction;
                }
            }

            update() {
                if (!this.isActive) return this.lastInterpolatedPosition || this.targetPosition;

                const now = performance.now();
                const elapsed = now - this.startTime;

                if (elapsed >= this.duration) {
                    this.isActive = false;
                    this.lastInterpolatedPosition = this.targetPosition;
                    return this.targetPosition;
                }

                // Calculate progress with easing
                const t = elapsed / this.duration;
                const easedT = this.easingFunction(t);

                // Interpolate position
                const interpolatedPosition = {
                    lat: this.startPosition.lat + (this.targetPosition.lat - this.startPosition.lat) * easedT,
                    lng: this.startPosition.lng + (this.targetPosition.lng - this.startPosition.lng) * easedT,
                    accuracy: this.targetPosition.accuracy,
                    heading: this.targetPosition.heading,
                    timestamp: now,
                    speedMPS: this.targetPosition.speedMPS,
                    confidence: this.targetPosition.confidence,
                    mode: this.targetPosition.mode
                };

                this.lastInterpolatedPosition = interpolatedPosition;
                return interpolatedPosition;
            }

            // Cubic easing function for smoother motion
            easeOutCubic(t) {
                return 1 - Math.pow(1 - t, 3);
            }
            
            // Quadratic easing function
            easeOutQuad(t) {
                return 1 - (1 - t) * (1 - t);
            }
            
            // Exponential easing function
            easeOutExpo(t) {
                return t === 1 ? 1 : 1 - Math.pow(2, -10 * t);
            }
            
            // Elastic easing function
            easeOutElastic(t) {
                const c4 = (2 * Math.PI) / 3;
                return t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c4) + 1;
            }

            isInterpolating() {
                return this.isActive;
            }

            cancel() {
                this.isActive = false;
            }

            getLastPosition() {
                return this.lastInterpolatedPosition || this.targetPosition;
            }
        }

        // Create Kalman filter instance
        const kalmanFilter = new KalmanFilter();

        // Create position interpolator
        positionInterpolator = new PositionInterpolator();

        // Calculate distance between two points using Haversine formula
        function calculateDistance(pos1, pos2) {
            if (
                !pos1 ||
                !pos2 ||
                typeof pos1.lat !== "number" ||
                typeof pos1.lng !== "number" ||
                typeof pos2.lat !== "number" ||
                typeof pos2.lng !== "number"
            ) {
                return Number.POSITIVE_INFINITY;
            }

            const R = 6371000; // Earth's radius in meters
            const lat1 = (pos1.lat * Math.PI) / 180;
            const lat2 = (pos2.lat * Math.PI) / 180;
            const deltaLat = ((pos2.lat - pos1.lat) * Math.PI) / 180;
            const deltaLng = ((pos2.lng - pos1.lng) * Math.PI) / 180;

            const a =
                Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) +
                Math.cos(lat1) * Math.cos(lat2) * Math.sin(deltaLng / 2) * Math.sin(deltaLng / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

            return R * c;
        }

        // Check if device is in motion based on motion sensors
        function isDeviceInMotion() {
            if (!motionSamples || motionSamples.length < 3) {
                return false;
            }

            // Calculate average motion magnitude
            const avgMotion =
                motionSamples.reduce((sum, sample) => {
                    return sum + Math.sqrt(sample.x * sample.x + sample.y * sample.y + sample.z * sample.z);
                }, 0) / motionSamples.length;

            return avgMotion > MOTION_THRESHOLD;
        }

        // Process device motion data
        function handleDeviceMotion(event) {
            if (!event || !event.acceleration) return;

            const now = Date.now();
            // Throttle motion updates for better performance
            if (now - lastDeviceMotionTimestamp < 50) return;
            lastDeviceMotionTimestamp = now;

            const motion = {
                x: event.acceleration.x || 0,
                y: event.acceleration.y || 0,
                z: event.acceleration.z || 0,
                timestamp: now,
            };

            // Add to motion samples
            motionSamples.push(motion);

            // Keep only recent samples
            while (motionSamples.length > MOTION_SAMPLE_SIZE) {
                motionSamples.shift();
            }

            // Update device motion state
            deviceMotion = motion;

            // Add to device motion buffer for stability detection
            deviceMotionBuffer.push({
                magnitude: Math.sqrt(motion.x * motion.x + motion.y * motion.y + motion.z * motion.z),
                timestamp: now,
            });

            // Keep buffer at reasonable size
            while (deviceMotionBuffer.length > 10) {
                deviceMotionBuffer.shift();
            }

            // Check if device is stationary based on motion
            const inMotion = isDeviceInMotion();

            if (!inMotion) {
                deviceStationaryTime += 50; // Increment by throttle time
            } else {
                deviceStationaryTime = 0;
            }
        }

        // Process device orientation data
        function handleDeviceOrientation(event) {
            if (!event || event.alpha === null) return;

            const now = Date.now();
            // Throttle heading updates
            if (now - lastHeadingUpdateTime < 100) return;
            lastHeadingUpdateTime = now;

            deviceOrientation = {
                alpha: event.alpha, // z-axis rotation [0,360)
                beta: event.beta, // x-axis rotation [-180,180)
                gamma: event.gamma, // y-axis rotation [-90,90)
                timestamp: now,
            };

            // Update heading buffer if we have a compass heading
            if (event.webkitCompassHeading !== undefined) {
                const heading = event.webkitCompassHeading;

                // Add to heading buffer
                headingBuffer.push(heading);

                // Keep only recent headings
                while (headingBuffer.length > 8) {
                    headingBuffer.shift();
                }

                // Calculate median heading to filter outliers
                if (headingBuffer.length >= 3) {
                    const sortedHeadings = [...headingBuffer].sort((a, b) => a - b);
                    lastHeadingValue = sortedHeadings[Math.floor(sortedHeadings.length / 2)];
                }
            }
        }

        // Request device motion and orientation permissions
        function requestMotionPermission() {
            if (typeof DeviceMotionEvent !== "undefined" && typeof DeviceMotionEvent.requestPermission === "function") {
                DeviceMotionEvent.requestPermission()
                    .then((response) => {
                        if (response === "granted") {
                            window.addEventListener("devicemotion", handleDeviceMotion, true);
                            orientationPermissionGranted = true;
                            hideOrientationWarning();
                        } else {
                            showOrientationWarning();
                        }
                    })
                    .catch(error => {
                        console.error("Motion permission error:", error);
                        showOrientationWarning();
                    });
            } else {
                window.addEventListener("devicemotion", handleDeviceMotion, true);
            }

            if (typeof DeviceOrientationEvent !== "undefined" && typeof DeviceOrientationEvent.requestPermission === "function") {
                DeviceOrientationEvent.requestPermission()
                    .then((response) => {
                        if (response === "granted") {
                            orientationPermissionGranted = true;
                            window.addEventListener("deviceorientation", handleDeviceOrientation, true);
                            hideOrientationWarning();
                        } else {
                            showOrientationWarning();
                        }
                    })
                    .catch(error => {
                        console.error("Orientation permission error:", error);
                        showOrientationWarning();
                    });
            } else {
                window.addEventListener("deviceorientation", handleDeviceOrientation, true);
                orientationPermissionGranted = true;
            }
        }

        // Show orientation warning
        function showOrientationWarning() {
            if (orientationWarningShown) return;
            
            const warning = document.getElementById('orientationWarning');
            if (warning) {
                warning.style.display = 'flex';
                orientationWarningShown = true;
            }
        }

        // Hide orientation warning
        function hideOrientationWarning() {
            const warning = document.getElementById('orientationWarning');
            if (warning) {
                warning.style.display = 'none';
                orientationWarningShown = false;
            }
        }

        // Animation loop for smooth rendering
        function startAnimationLoop() {
            function animate(timestamp) {
                // Calculate delta time
                const deltaTime = renderTimestamp ? (timestamp - renderTimestamp) / 1000 : 0;
                renderTimestamp = timestamp;

                // Process position updates
                processPositionUpdateQueue();

                // Update interpolated position
                if (positionInterpolator && positionInterpolator.isInterpolating()) {
                    const interpolatedPosition = positionInterpolator.update();
                    if (interpolatedPosition) {
                        // Update marker position
                        userMarker.setLatLng([interpolatedPosition.lat, interpolatedPosition.lng]);
                        lastRenderPosition = interpolatedPosition;

                        // Update marker rotation if heading is available
                        if (interpolatedPosition.heading !== null && interpolatedPosition.heading !== undefined) {
                            updateMarkerRotation(interpolatedPosition.heading);
                        }
                    }
                }

                // Check for recentering based on edge proximity
                if ((followUser && !isMapInteracting) || forceCenteringActive) {
                    if (Date.now() - lastRecenterCheckTime > 100) { // More frequent checks
                        checkAndRecenterMap();
                        lastRecenterCheckTime = Date.now();
                    }
                }

                // Update zoom level based on speed and proximity
                updateDynamicZoom();

                // Check for proximity to locations
                if (Date.now() - lastProximityCheckTime > 500) {
                    checkProximityForZoom();
                    checkProximityForHaptic();
                    lastProximityCheckTime = Date.now();
                }

                // Update debug info if enabled
                if (debugMode && Date.now() - lastDebugUpdateTime > DEBUG_UPDATE_INTERVAL) {
                    updateDebugInfo();
                    lastDebugUpdateTime = Date.now();
                }

                // Request next frame
                animationFrameId = requestAnimationFrame(animate);
            }

            // Start animation loop
            animationFrameId = requestAnimationFrame(animate);
        }

        // Update marker rotation based on heading
        function updateMarkerRotation(heading) {
            const markerElement = userMarker.getElement();
            if (markerElement) {
                const iconElement = markerElement.querySelector(".user-marker-icon");
                if (iconElement) {
                    iconElement.style.transform = `rotate(${heading}deg)`;
                    
                    // Add direction indicator class if not already present
                    if (!iconElement.classList.contains('with-direction')) {
                        iconElement.classList.add('with-direction');
                    }
                }
                
                // Update direction indicator if it exists
                const directionElement = markerElement.querySelector(".user-marker-direction");
                if (directionElement) {
                    directionElement.style.transform = `translate(-50%, -50%) rotate(${heading}deg)`;
                }
            }
        }

        // Process position update queue
        function processPositionUpdateQueue() {
            if (positionUpdateQueue.length === 0) return;

            // Process all updates in queue
            while (positionUpdateQueue.length > 0) {
                const update = positionUpdateQueue.shift();
                processPositionUpdate(update);
            }
        }

        // Process position update
        function processPositionUpdate(position) {
            // Validate position
            if (!position || typeof position.lat !== "number" || typeof position.lng !== "number") {
                return;
            }

            // Update tracking variables
            lastPosition = position;
            currentSpeed = position.speedMPS || 0;
            
            // Maintain speed samples (5-point buffer)
            speedSamples.push(currentSpeed);
            if (speedSamples.length > 5) speedSamples.shift();

            // Update marker stationary state
            const markerElement = userMarker.getElement();
            if (markerElement) {
                markerElement.classList.toggle("user-marker-stationary", isStationary);
            }

            // Calculate movement distance if we have previous position
            const distance = lastRenderPosition ? calculateDistance(lastRenderPosition, position) : 0;

            // Handle position update
            if (!lastRenderPosition || isFirstPositionUpdate) {
                // Initial position - set directly
                userMarker.setLatLng([position.lat, position.lng]);
                lastRenderPosition = position;
                isFirstPositionUpdate = false;
            } 
            else if (distance > EXTENDED_DISTANCE_THRESHOLD) {
                // Large movement - update immediately without animation
                userMarker.setLatLng([position.lat, position.lng]);
                lastRenderPosition = position;
                
                // Cancel any ongoing animation
                if (positionInterpolator) {
                    positionInterpolator.cancel();
                }
            }
            else {
                // Normal movement - apply smooth interpolation
                const animDuration = isStationary ? 
                    (distance < 0.5 ? 600 : 400) : // Longer duration for stationary micro-movements
                    ANIMATION_DURATION;
                
                // Choose easing function based on movement type
                let easingFunction = null;
                if (isStationary) {
                    easingFunction = positionInterpolator.easeOutExpo; // Smoother for stationary
                } else if (currentSpeed > DRIVING_SPEED_THRESHOLD) {
                    easingFunction = positionInterpolator.easeOutQuad; // Quicker for driving
                } else {
                    easingFunction = positionInterpolator.easeOutCubic; // Default
                }
                
                positionInterpolator.start(lastRenderPosition, position, animDuration, easingFunction);
            }

            // Update marker rotation if heading available
            if (position.heading !== null && position.heading !== undefined) {
                updateMarkerRotation(position.heading);
            }

            // Handle map recentering - IMPROVED to keep user centered
            if (followUser && !isMapInteracting) {
                // Always keep user centered regardless of movement size
                map.setView([position.lat, position.lng], map.getZoom(), {
                    animate: true,
                    duration: 0.2 // Faster animation for more responsive centering
                });
            }
            
            // Check nearby points of interest
            checkNearbyLocations();
        }
        
        // Check for proximity to locations for zoom level adjustment
        function checkProximityForZoom() {
            if (!lastPosition || !gameLocations || gameLocations.length === 0) return;
            
            // Only check the current location
            const location = gameLocations[currentLocationIndex];
            if (!location) return;
            
            // Calculate distance to current location
            const distance = calculateDistance(
                { lat: lastPosition.lat, lng: lastPosition.lng },
                { lat: location.lat, lng: location.lng }
            );
            
            // Convert to feet
            const distanceFeet = Math.round(distance * 3.28084);
            
            // Check if user is within proximity threshold
            const withinProximity = distanceFeet <= PROXIMITY_THRESHOLD;
            
            // Only update if proximity state has changed
            if (withinProximity !== isWithinProximity) {
                isWithinProximity = withinProximity;
                
                // Adjust zoom level based on proximity
                if (isWithinProximity && !proximityZoomActive) {
                    // Zoom in when entering proximity
                    proximityZoomActive = true;
                    if (map && followUser) {
                        map.setZoom(PROXIMITY_ZOOM_LEVEL, {
                            animate: true,
                            duration: 1.0,
                            noMoveStart: true
                        });
                    }
                } else if (!isWithinProximity && proximityZoomActive) {
                    // Zoom out when leaving proximity
                    proximityZoomActive = false;
                    if (map && followUser) {
                        map.setZoom(DEFAULT_ZOOM_LEVEL, {
                            animate: true,
                            duration: 1.0,
                            noMoveStart: true
                        });
                    }
                }
            }
        }
        
        // Check for proximity to trigger haptic feedback
        function checkProximityForHaptic() {
            if (!lastPosition || !gameLocations || gameLocations.length === 0) return;
            
            // Only check the current location
            const location = gameLocations[currentLocationIndex];
            if (!location) return;
            
            // Calculate distance to current location
            const distance = calculateDistance(
                { lat: lastPosition.lat, lng: lastPosition.lng },
                { lat: location.lat, lng: location.lng }
            );
            
            // Convert to feet
            const distanceFeet = Math.round(distance * 3.28084);
            
            // Check if user is within haptic threshold
            const withinHapticRange = distanceFeet <= HAPTIC_THRESHOLD;
            
            // Only trigger haptic feedback if state has changed and we're entering the range
            if (withinHapticRange && !isWithinHapticRange) {
                isWithinHapticRange = true;
                
                // Trigger haptic feedback if supported and not too frequent
                if (Date.now() - lastHapticFeedbackTime > HAPTIC_FEEDBACK_INTERVAL) {
                    triggerHapticFeedback();
                    lastHapticFeedbackTime = Date.now();
                }
            } else if (!withinHapticRange && isWithinHapticRange) {
                isWithinHapticRange = false;
            }
        }
        
        // Trigger haptic feedback
        function triggerHapticFeedback() {
            // Check if vibration API is supported
            if ('vibrate' in navigator) {
                navigator.vibrate(HAPTIC_PATTERN);
            }
            
            // Show visual feedback
            const hapticIndicator = document.getElementById('hapticIndicator');
            if (hapticIndicator) {
                hapticIndicator.classList.add('active');
                
                // Remove active class after animation completes
                setTimeout(() => {
                    hapticIndicator.classList.remove('active');
                }, 500);
            }
        }

        // Check for nearby locations
        function checkNearbyLocations() {
            if (!lastPosition || !gameLocations || isLocationHuntVisible) return;
            
            // Only check the current location (progressive display)
            const location = gameLocations[currentLocationIndex];
            if (!location) return;
            
            // Skip if already visited
            if (visitedLocations.includes(location.id)) return;
            
            const distance = calculateDistance(
                { lat: lastPosition.lat, lng: lastPosition.lng },
                { lat: location.lat, lng: location.lng }
            );
            
            // Convert to feet
            const distanceFeet = Math.round(distance * 3.28084);
            
            // Update distance box
            updateDistanceBox(location, distanceFeet);
            
            // Check if user is close enough to interact
            if (distanceFeet <= DISTANCE_THRESHOLD) {
                showLocationHunt(location);
            }
        }
        
        // Update distance box with location info
        function updateDistanceBox(location, distanceFeet) {
            const distanceBox = document.getElementById('distanceBox');
            if (distanceBox) {
                const locationNameElement = distanceBox.querySelector('.location-name');
                const distanceValueElement = distanceBox.querySelector('.distance-value');
                
                if (locationNameElement && distanceValueElement) {
                    locationNameElement.textContent = location.name;
                    
                    // Format distance based on value
                    let distanceText;
                    if (distanceFeet > 5280) {
                        // Convert to miles and round to 1 decimal place
                        const distanceMiles = (distanceFeet / 5280).toFixed(1);
                        distanceText = `${distanceMiles} miles away`;
                    } else if (distanceFeet === 5280) {
                        distanceText = "1 mile away";
                    } else {
                        distanceText = `${distanceFeet} feet away`;
                    }
                    
                    distanceValueElement.textContent = distanceText;
                }
            }
        }

        // Create navigation links for a location
        function createNavigationLinks(location) {
            // Google Maps
            const googleMapsLink = document.getElementById('googleMapsLink');
            if (googleMapsLink) {
                googleMapsLink.href = `https://www.google.com/maps/dir/?api=1&destination=${location.lat},${location.lng}&travelmode=walking`;
            }
            
            // Apple Maps (iOS only)
            const appleMapsLink = document.getElementById('appleMapsLink');
            if (appleMapsLink) {
                appleMapsLink.href = `maps://maps.apple.com/?daddr=${location.lat},${location.lng}&dirflg=w`;
                
                // Hide Apple Maps link on non-iOS devices
                const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
                appleMapsLink.style.display = isIOS ? 'flex' : 'none';
            }
            
            // Waze
            const wazeLink = document.getElementById('wazeLink');
            if (wazeLink) {
                wazeLink.href = `https://waze.com/ul?ll=${location.lat},${location.lng}&navigate=yes`;
            }
        }
        
        // Set up directions modal links
        function setupDirectionsModal(location) {
            currentDirectionsLocation = location;
            
            // Google Maps
            const googleMapsBtn = document.getElementById('googleMapsBtn');
            if (googleMapsBtn) {
                googleMapsBtn.href = `https://www.google.com/maps/dir/?api=1&destination=${location.lat},${location.lng}&travelmode=walking`;
            }
            
            // Apple Maps (iOS only)
            const appleMapsBtn = document.getElementById('appleMapsBtn');
            if (appleMapsBtn) {
                appleMapsBtn.href = `maps://maps.apple.com/?daddr=${location.lat},${location.lng}&dirflg=w`;
                
                // Hide Apple Maps button on non-iOS devices
                const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
                appleMapsBtn.style.display = isIOS ? 'flex' : 'none';
            }
            
            // Waze
            const wazeBtn = document.getElementById('wazeBtn');
            if (wazeBtn) {
                wazeBtn.href = `https://waze.com/ul?ll=${location.lat},${location.lng}&navigate=yes`;
            }
        }
        
        // Show directions modal
        function showDirectionsModal(location) {
            setupDirectionsModal(location);
            document.getElementById('directionsModal').style.display = 'flex';
        }
        
        // Close directions modal
        function closeDirectionsModal() {
            document.getElementById('directionsModal').style.display = 'none';
        }
        
        // Skip to next location
        function skipToNextLocation() {
            // Close any open popups
            map.closePopup();
            
            // Remove the current marker from the map
            if (currentLocationIndex < allLocationMarkers.length) {
                map.removeLayer(allLocationMarkers[currentLocationIndex]);
            }
            
            // Move to next location
            currentLocationIndex++;
            
            // Check if we've reached the end
            if (currentLocationIndex >= gameLocations.length) {
                showCongratulations();
            } else {
                // Update visible markers
                updateVisibleMarkers();
                
                // Update distance box for new location
                const location = gameLocations[currentLocationIndex];
                if (location && lastPosition) {
                    const distance = calculateDistance(
                        { lat: lastPosition.lat, lng: lastPosition.lng },
                        { lat: location.lat, lng: location.lng }
                    );
                    const distanceFeet = Math.round(distance * 3.28084);
                    updateDistanceBox(location, distanceFeet);
                }
                
                // Reset proximity state
                isWithinProximity = false;
                proximityZoomActive = false;
                isWithinHapticRange = false;
            }
        }

        // Check and recenter map if needed
        function checkAndRecenterMap() {
            if (!userMarker || !map) return;
            
            // Always recenter to keep user in center of screen
            if (followUser || forceCenteringActive) {
                const position = userMarker.getLatLng();
                map.setView([position.lat, position.lng], map.getZoom(), {
                    animate: true,
                    duration: 0.2, // Faster animation for more responsive centering
                    noMoveStart: true
                });
            }
        }

        // Calculate optimal zoom level based on speed
        function calculateOptimalZoom(speed) {
            // If proximity zoom is active, prioritize it
            if (proximityZoomActive) {
                return PROXIMITY_ZOOM_LEVEL;
            }
            
            // Default to walking zoom level
            if (speed === undefined || speed === null) {
                return DEFAULT_ZOOM_LEVEL;
            }

            // Stationary or very slow
            if (speed < 0.5) {
                return MAX_ZOOM_LEVEL;
            }
            // Walking speed
            else if (speed < WALKING_SPEED_THRESHOLD) {
                return DEFAULT_ZOOM_LEVEL;
            }
            // Running speed
            else if (speed < RUNNING_SPEED_THRESHOLD) {
                return DEFAULT_ZOOM_LEVEL - 1;
            }
            // Driving speed
            else if (speed < DRIVING_SPEED_THRESHOLD) {
                return DEFAULT_ZOOM_LEVEL - 2;
            }
            // High speed
            else if (speed < HIGH_SPEED_THRESHOLD) {
                return DEFAULT_ZOOM_LEVEL - 3;
            }
            // Very high speed
            else {
                return MIN_ZOOM_LEVEL;
            }
        }

        // Update zoom level based on speed
        function updateDynamicZoom() {
            const now = Date.now();
            if (now - lastZoomUpdateTime < ZOOM_UPDATE_INTERVAL) return;
            lastZoomUpdateTime = now;

            // Skip if user is interacting with map
            if (isMapInteracting || userIsInteracting) return;

            // Calculate average speed from samples
            let avgSpeed = 0;
            if (speedSamples.length > 0) {
                avgSpeed = speedSamples.reduce((sum, speed) => sum + speed, 0) / speedSamples.length;
            } else if (lastPosition) {
                avgSpeed = lastPosition.speedMPS || 0;
            }

            // Smooth speed changes
            const smoothedSpeed = lastSpeedForZoom * 0.7 + avgSpeed * 0.3;
            lastSpeedForZoom = smoothedSpeed;

            // Calculate optimal zoom level
            const optimalZoom = calculateOptimalZoom(smoothedSpeed);

            // Only update if zoom level needs to change
            if (Math.abs(optimalZoom - targetZoomLevel) >= 0.1) {
                targetZoomLevel = optimalZoom;

                // Apply zoom change with smooth animation
                if (map && followUser) {
                    const currentZoom = map.getZoom();
                    const zoomDiff = Math.abs(currentZoom - targetZoomLevel);

                    // Use faster transition for larger zoom changes
                    const duration = zoomDiff > 1 ? 0.3 : ZOOM_TRANSITION_DURATION;

                    map.setZoom(targetZoomLevel, {
                        animate: true,
                        duration: duration,
                        noMoveStart: true,
                    });
                }
            }
        }

        // Linear interpolation helper
        function lerp(a, b, t) {
            if (typeof a !== "number" || typeof b !== "number" || typeof t !== "number") {
                return a;
            }

            return a + (b - a) * Math.max(0, Math.min(1, t));
        }

        // Calculate stationary position
        function calculateStationaryPosition(buffer) {
            if (!buffer || buffer.length === 0) {
                return null;
            }
            // Sort by accuracy (best first)
            const sortedBuffer = [...buffer].sort((a, b) => a.accuracy - b.accuracy);
            // Take weighted average of best positions
            const topPositions = sortedBuffer.slice(0, Math.ceil(buffer.length / 2));
            const weights = topPositions.map((pos) => 1 / Math.max(1, pos.accuracy));
            const totalWeight = weights.reduce((sum, w) => sum + w, 0);
            if (totalWeight === 0) {
                return sortedBuffer[0];
            }
            // Calculate weighted average
            const avgPosition = {
                lat: topPositions.reduce((sum, pos, i) => sum + pos.lat * weights[i], 0) / totalWeight,
                lng: topPositions.reduce((sum, pos, i) => sum + pos.lng * weights[i], 0) / totalWeight,
                accuracy: topPositions[0].accuracy,
                heading: topPositions[0].heading,
                timestamp: Date.now(),
                speedMPS: 0,
            };
            // If we have a previous stationary position, blend with it for stability
            if (lastStationaryPosition) {
                const blendFactor = 0.85; // 85% previous, 15% new for extreme stability
                return {
                    lat: lastStationaryPosition.lat * blendFactor + avgPosition.lat * (1 - blendFactor),
                    lng: lastStationaryPosition.lng * blendFactor + avgPosition.lng * (1 - blendFactor),
                    accuracy: avgPosition.accuracy,
                    heading: avgPosition.heading,
                    timestamp: avgPosition.timestamp,
                    speedMPS: 0
                };
            }
            return avgPosition;
        }

        // Update stationary position history
        function updateStationaryHistory(position) {
            // Add new position to history
            stationaryPositionHistory.push(position);

            // Keep history at maximum size
            while (stationaryPositionHistory.length > STATIONARY_POSITION_HISTORY_SIZE) {
                stationaryPositionHistory.shift();
            }

            // Calculate weighted average of positions
            let totalWeight = 0;
            let weightedLat = 0;
            let weightedLng = 0;

            // Newer positions have higher weight
            for (let i = 0; i < stationaryPositionHistory.length; i++) {
                const pos = stationaryPositionHistory[i];
                const weight = Math.pow(STATIONARY_POSITION_WEIGHT_DECAY, stationaryPositionHistory.length - i - 1);
                totalWeight += weight;
                weightedLat += pos.lat * weight;
                weightedLng += pos.lng * weight;
            }

            return {
                lat: weightedLat / totalWeight,
                lng: weightedLng / totalWeight,
                accuracy: position.accuracy,
                heading: position.heading,
                timestamp: position.timestamp,
                speedMPS: 0,
            };
        }

        // Update position buffer with new position
        function updatePositionBuffer(position) {
            if (!position || typeof position.lat !== "number" || typeof position.lng !== "number") {
                return;
            }

            // Add new position to buffer
            positionBuffer.push({
                lat: position.lat,
                lng: position.lng,
                accuracy: position.accuracy,
                heading: position.heading,
                timestamp: position.timestamp,
                speedMPS: position.speedMPS,
            });

            // Remove old positions if buffer exceeds maxSize
            while (positionBuffer.length > MAX_BUFFER_SIZE) {
                positionBuffer.shift();
            }
        }

        // Check if user is stationary
        function checkStationaryState(newPosition) {
            if (!lastPosition) return;

            const distance = calculateDistance(lastPosition, newPosition);

            if (distance >= MICRO_MOVEMENT_THRESHOLD) {
                isStationary = false;
                stationaryStartTime = null;
                console.debug("Movement detected, resuming normal updates");

                // Update Kalman filter stationary mode
                kalmanFilter.setStationaryMode(false);

                // Update marker class
                const markerElement = userMarker.getElement();
                if (markerElement) {
                    markerElement.classList.remove("user-marker-stationary");
                }
            }

            if (stationaryCheckTimeout) {
                clearTimeout(stationaryCheckTimeout);
                stationaryCheckTimeout = null;
            }

            if (isStationary) {
                stationaryCheckTimeout = setTimeout(() => checkStationaryState(newPosition), STATIONARY_CHECK_INTERVAL);
            }
        }

        // Predict position based on heading and speed
        function predictPositionFromHeading(position, heading, distance) {
            // Input validation
            if (
                !position ||
                typeof heading !== "number" ||
                typeof distance !== "number" ||
                !position.lat ||
                !position.lng ||
                isNaN(heading) ||
                isNaN(distance)
            ) {
                return position;
            }

            // Normalize heading to 0-360 range
            heading = ((heading % 360) + 360) % 360;

            // Earth's radius in meters
            const R = 6371e3;

            // Convert to radians
            const d = distance / R;
            const  = (heading * Math.PI) / 180;
            const 1 = (position.lat * Math.PI) / 180;
            const 1 = (position.lng * Math.PI) / 180;

            // Calculate predicted position with error handling
            try {
                const sin1 = Math.sin(1);
                const cos1 = Math.cos(1);
                const cosd = Math.cos(d);
                const sind = Math.sin(d);
                const cos = Math.cos();

                const 2 = Math.asin(sin1 * cosd + cos1 * sind * cos);

                const 2 = 1 + Math.atan2(Math.sin() * sind * cos1, cosd - sin1 * Math.sin(2));

                // Convert back to degrees with bounds checking
                const newLat = Math.max(-90, Math.min(90, (2 * 180) / Math.PI));
                const newLng = (((2 * 180) / Math.PI + 540) % 360) - 180;

                return {
                    lat: newLat,
                    lng: newLng,
                };
            } catch (error) {
                // Fallback to original position if calculation fails
                return position;
            }
        }

        // Main function to update user location
        function updateUserLocation(position, forceUpdate = false) {
            // Validate input position
            if (!position?.coords) {
                console.warn("Invalid position data received");
                return;
            }

            const currentTime = Date.now();

            // Throttle updates for performance
            if (!forceUpdate && currentTime - lastPositionUpdateTime < 16) {
                return;
            }
            lastPositionUpdateTime = currentTime;

            const timeDelta = lastUpdateTime ? (currentTime - lastUpdateTime) / 1000 : 0;

            // Create position object
            const newPosition = {
                lat: position.coords.latitude,
                lng: position.coords.longitude,
                accuracy: position.coords.accuracy || 20,
                heading: position.coords.heading !== null ? position.coords.heading : lastHeadingValue || undefined,
                timestamp: currentTime,
                speedMPS: position.coords.speed !== null ? position.coords.speed : 0,
            };

            if (isNaN(newPosition.lat) || isNaN(newPosition.lng)) {
                console.warn("Invalid coordinates received");
                return;
            }

            // Store raw position for comparison
            lastRawPosition = newPosition;

            // Track accuracy trend
            if (lastAccuracy !== null) {
                accuracyTrend.push(newPosition.accuracy - lastAccuracy);
                while (accuracyTrend.length > 5) accuracyTrend.shift();
            }
            lastAccuracy = newPosition.accuracy;

            // First position initialization
            if (!lastPosition) {
                lastPosition = newPosition;
                userMarker.setLatLng([newPosition.lat, newPosition.lng]);
                kalmanFilter.reset(newPosition);
                lastUpdateTime = currentTime;
                stationaryStartTime = currentTime;
                positionBuffer = [newPosition];
                lastStationaryPosition = newPosition;
                lastRenderPosition = newPosition;
                return;
            }

            // Calculate distance from last position
            const distance = calculateDistance(lastPosition, newPosition);

            // Handle large position changes or forced updates
            if (distance > EXTENDED_DISTANCE_THRESHOLD || forceUpdate) {
                if (stationaryCheckTimeout) {
                    clearTimeout(stationaryCheckTimeout);
                    stationaryCheckTimeout = null;
                }
                isStationary = false;
                stationaryStartTime = null;
                stationaryCount = 0;
                stationaryPositionHistory = [];
                lastStationaryPosition = null;
                consecutiveStationaryUpdates = 0;

                // Immediate visual update - no animation
                userMarker.setLatLng([newPosition.lat, newPosition.lng]);
                
                // Always recenter map to keep user centered
                if (followUser || forceCenteringActive) {
                    map.setView([newPosition.lat, newPosition.lng], map.getZoom(), {
                        animate: true,
                        duration: 0.3
                    });
                }

                // Reset tracking variables
                lastPosition = newPosition;
                lastRenderPosition = newPosition;
                positionBuffer = [newPosition];
                kalmanFilter.reset(newPosition);
                kalmanFilter.setStationaryMode(false);
                lastVelocity = { lat: 0, lng: 0 };

                // Cancel any active interpolation
                if (positionInterpolator) {
                    positionInterpolator.cancel();
                }

                // Clear any queued position updates
                positionUpdateQueue = [];

                lastUpdateTime = currentTime;
                lastUpdateTimestamp = currentTime;
                checkNearbyLocations();
                return;
            }

            // Skip updates with poor accuracy or unrealistic movement
            if (
                !forceUpdate &&
                (newPosition.accuracy > MAX_ACCEPTABLE_ACCURACY || (timeDelta > 0 && distance / timeDelta > 50))
            ) {
                console.debug("Skipping update due to poor accuracy or unrealistic movement");
                return;
            }

            try {
                // Check if device is in motion based on motion sensors
                const motionDetected = deviceMotion && isDeviceInMotion();

                // Enhanced stationary detection
                if (distance < MICRO_MOVEMENT_THRESHOLD && (!motionDetected || deviceStationaryTime > STATIONARY_TIME_THRESHOLD)) {
                    stationaryCount++;
                    consecutiveStationaryUpdates++;

                    if (!isStationary && stationaryCount >= STATIONARY_THRESHOLD) {
                        isStationary = true;
                        console.log("User is now stationary");

                        // Set Kalman filter to stationary mode
                        kalmanFilter.setStationaryMode(true);

                        // Update marker class
                        const markerElement = userMarker.getElement();
                        if (markerElement) {
                            markerElement.classList.add("user-marker-stationary");
                        }

                        // Calculate stable position from buffer
                        const stablePosition = calculateStationaryPosition(positionBuffer);
                        if (stablePosition) {
                            // Add to position update queue
                            positionUpdateQueue.push(stablePosition);
                            lastPosition = stablePosition;
                            lastStationaryPosition = stablePosition;
                        }

                        if (stationaryCheckTimeout) clearTimeout(stationaryCheckTimeout);
                        stationaryCheckTimeout = setTimeout(() => checkStationaryState(newPosition), STATIONARY_CHECK_INTERVAL);

                        checkNearbyLocations();
                        return;
                    }
                } else {
                    stationaryCount = Math.max(0, stationaryCount - 1);
                    consecutiveStationaryUpdates = 0;
                    if (isStationary && stationaryCount < STATIONARY_THRESHOLD / 2) {
                                                isStationary = false;
                        kalmanFilter.setStationaryMode(false);

                        // Update marker class
                        const markerElement = userMarker.getElement();
                        if (markerElement) {
                            markerElement.classList.remove("user-marker-stationary");
                        }

                        console.log("User is moving again");
                    }
                }

                // Apply Kalman filter with motion detection
                const filteredPosition = kalmanFilter.update(newPosition, motionDetected);

                // Update position buffer
                updatePositionBuffer(filteredPosition);

                // Apply different smoothing based on movement state
                let finalPosition;

                if (isStationary) {
                    // When stationary, use the stable position with minimal updates
                    if (lastStationaryPosition) {
                        // Only update if accuracy significantly improves or after several updates
                        if (newPosition.accuracy < lastStationaryPosition.accuracy * 0.8 || consecutiveStationaryUpdates > 5) {
                            // Update stationary position history
                            updateStationaryHistory(filteredPosition);

                            // Calculate new stable position
                            const stablePosition = calculateStationaryPosition(positionBuffer);
                            if (stablePosition) {
                                // Smooth transition to new stable position
                                finalPosition = {
                                    lat: lerp(lastStationaryPosition.lat, stablePosition.lat, 0.1),
                                    lng: lerp(lastStationaryPosition.lng, stablePosition.lng, 0.1),
                                    accuracy: stablePosition.accuracy,
                                    heading: stablePosition.heading,
                                    timestamp: currentTime,
                                    speedMPS: 0,
                                };

                                // Add to position update queue
                                positionUpdateQueue.push(finalPosition);
                                lastPosition = finalPosition;
                                lastStationaryPosition = finalPosition;
                                consecutiveStationaryUpdates = 0;
                            } else {
                                finalPosition = lastStationaryPosition;
                            }
                        } else {
                            // Use existing stable position
                            finalPosition = lastStationaryPosition;
                        }
                    } else {
                        // If no stable position yet, calculate one
                        const stablePosition = calculateStationaryPosition(positionBuffer);
                        if (stablePosition) {
                            finalPosition = stablePosition;
                            lastStationaryPosition = stablePosition;

                            // Add to position update queue
                            positionUpdateQueue.push(finalPosition);
                        } else {
                            finalPosition = filteredPosition;

                            // Add to position update queue
                            positionUpdateQueue.push(finalPosition);
                        }
                        lastPosition = finalPosition;
                    }
                } else {
                    // Smooth movement when active
                    finalPosition = filteredPosition;

                    // Apply heading-based prediction for smoother movement
                    if (finalPosition.heading !== undefined && finalPosition.speedMPS > 0.5) {
                        const predictedPosition = predictPositionFromHeading(
                            finalPosition,
                            finalPosition.heading,
                            finalPosition.speedMPS * 0.3, // Predict slightly ahead
                        );

                        // Blend predicted and filtered positions
                        finalPosition = {
                            lat: lerp(finalPosition.lat, predictedPosition.lat, 0.2),
                            lng: lerp(finalPosition.lng, predictedPosition.lng, 0.2),
                            accuracy: finalPosition.accuracy,
                            heading: finalPosition.heading,
                            timestamp: currentTime,
                            speedMPS: finalPosition.speedMPS,
                            confidence: finalPosition.confidence,
                            mode: finalPosition.mode
                        };
                    }

                    // Add to position update queue
                    positionUpdateQueue.push(finalPosition);
                    lastPosition = finalPosition;
                }

                lastUpdateTime = currentTime;
                lastUpdateTimestamp = currentTime;
                checkNearbyLocations();
            } catch (error) {
                console.error("Location update error:", error);
                // Fallback with basic filtering
                userMarker.setLatLng([newPosition.lat, newPosition.lng]);
                lastPosition = newPosition;
                lastRenderPosition = newPosition;
                checkNearbyLocations();
            }
        }

        // Handle position updates from geolocation API
        function handlePositionUpdate(position) {
            if (!position?.coords?.latitude || !position?.coords?.longitude) {
                console.warn("Invalid position data received");
                return;
            }

            const currentTime = Date.now();
            if (currentTime - lastUpdateTime >= 100 && !isPopupOpen()) {
                updateUserLocation(position);
                lastUpdateTime = currentTime;
            }
        }

        // Start position updates with high frequency
        function startPositionUpdates() {
            // Try high accuracy first
            if (!highAccuracyFailed) {
                try {
                    watchPositionId = navigator.geolocation.watchPosition(
                        handlePositionUpdate, 
                        (error) => {
                            console.warn("High accuracy position failed:", error);
                            highAccuracyFailed = true;
                            startPositionUpdates(); // Retry with lower accuracy
                        }, 
                        {
                            enableHighAccuracy: true,
                            maximumAge: 0,
                            timeout: 10000,
                        }
                    );
                } catch (error) {
                    console.error("Error starting high accuracy position updates:", error);
                    highAccuracyFailed = true;
                    startPositionUpdates(); // Retry with lower accuracy
                }
            } else {
                // Fallback to lower accuracy
                try {
                    watchPositionId = navigator.geolocation.watchPosition(
                        handlePositionUpdate,
                        handleLocationError,
                        {
                            enableHighAccuracy: false,
                            maximumAge: 1000,
                            timeout: 15000,
                        }
                    );
                } catch (error) {
                    console.error("Error starting position updates:", error);
                    handleLocationError({
                        code: 2,
                        message: "Failed to start position updates"
                    });
                }
            }
        }

        // Update debug info
        function updateDebugInfo() {
            const debugInfo = document.getElementById('debugInfo');
            if (!debugInfo) return;
            
            // Create debug info string
            let info = '';
            
            // Position info
            if (lastPosition) {
                info += `Lat: ${lastPosition.lat.toFixed(6)}<br>`;
                info += `Lng: ${lastPosition.lng.toFixed(6)}<br>`;
                info += `Acc: ${lastPosition.accuracy?.toFixed(1)}m<br>`;
                info += `Spd: ${lastPosition.speedMPS?.toFixed(1)}m/s<br>`;
                info += `Hdg: ${lastPosition.heading?.toFixed(0)}<br>`;
                info += `Mode: ${lastPosition.mode || 'unknown'}<br>`;
                info += `Conf: ${(lastPosition.confidence || 0).toFixed(2)}<br>`;
            }
            
            // State info
            info += `Stationary: ${isStationary ? 'Yes' : 'No'}<br>`;
            info += `Follow: ${followUser ? 'Yes' : 'No'}<br>`;
            info += `Force Center: ${forceCenteringActive ? 'Yes' : 'No'}<br>`;
            info += `Interacting: ${isMapInteracting ? 'Yes' : 'No'}<br>`;
            
            // Motion info
            if (deviceMotion) {
                const motion = deviceMotion;
                info += `Motion X: ${motion.x?.toFixed(2)}<br>`;
                info += `Motion Y: ${motion.y?.toFixed(2)}<br>`;
                info += `Motion Z: ${motion.z?.toFixed(2)}<br>`;
                info += `In Motion: ${isDeviceInMotion() ? 'Yes' : 'No'}<br>`;
            }
            
            // Map info
            info += `Zoom: ${map?.getZoom()?.toFixed(1) || 'N/A'}<br>`;
            info += `Target Zoom: ${targetZoomLevel.toFixed(1)}<br>`;
            
            // Queue info
            info += `Queue: ${positionUpdateQueue.length}<br>`;
            
            // Update element
            debugInfo.innerHTML = info;
        }

        // Check and recenter map if needed
        function checkAndRecenterMap() {
            if (!map || !userMarker || !followUser) return;
            
            const userLatLng = userMarker.getLatLng();
            const mapCenter = map.getCenter();
            
            // Calculate distance from center in pixels
            const userPoint = map.latLngToContainerPoint(userLatLng);
            const centerPoint = map.latLngToContainerPoint(mapCenter);
            const distanceFromCenter = userPoint.distanceTo(centerPoint);
            
            // Get map dimensions
            const mapSize = map.getSize();
            const mapWidth = mapSize.x;
            const mapHeight = mapSize.y;
            
            // Calculate threshold based on map size
            const threshold = Math.min(mapWidth, mapHeight) * EDGE_THRESHOLD_PERCENTAGE;
            
            // If user is too far from center or force centering is active, recenter
            if (distanceFromCenter > threshold || forceCenteringActive) {
                map.setView(userLatLng, map.getZoom(), {
                    animate: true,
                    duration: 0.3
                });
            }
        }

        // Animation loop for smooth rendering
        function startAnimationLoop() {
            // Cancel any existing animation frame
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            
            // Function to process animation frame
            function processAnimationFrame(timestamp) {
                // Calculate time delta
                const delta = renderTimestamp ? (timestamp - renderTimestamp) / 1000 : 0;
                renderTimestamp = timestamp;
                
                // Process position update queue
                if (positionUpdateQueue.length > 0) {
                    // Get latest position from queue
                    const latestPosition = positionUpdateQueue.pop();
                    
                    // Clear the rest of the queue
                    positionUpdateQueue = [];
                    
                    // Update marker position with smooth transition
                    updateMarkerPosition(latestPosition, delta);
                    
                    // Check if map needs recentering
                    if (followUser || forceCenteringActive) {
                        checkAndRecenterMap();
                    }
                }
                
                // Request next frame
                animationFrameId = requestAnimationFrame(processAnimationFrame);
            }
            
            // Start animation loop
            animationFrameId = requestAnimationFrame(processAnimationFrame);
        }

        // Update marker position with smooth transition
        function updateMarkerPosition(position, delta) {
            if (!userMarker || !position) return;
            
            // Get current marker position
            const currentLatLng = userMarker.getLatLng();
            
            // If first update or large distance, snap immediately
            if (!lastRenderPosition || calculateDistance(lastRenderPosition, position) > 10) {
                userMarker.setLatLng([position.lat, position.lng]);
                lastRenderPosition = position;
                updateMarkerHeading(position.heading);
                return;
            }
            
            // Calculate interpolation factor based on delta time
            const factor = Math.min(1, delta * 10); // Adjust for desired smoothness
            
            // Interpolate between current and target position
            const newLat = lerp(currentLatLng.lat, position.lat, factor);
            const newLng = lerp(currentLatLng.lng, position.lng, factor);
            
            // Update marker position
            userMarker.setLatLng([newLat, newLng]);
            
            // Update heading
            updateMarkerHeading(position.heading);
            
            // Update last render position
            lastRenderPosition = {
                lat: newLat,
                lng: newLng,
                heading: position.heading,
                timestamp: position.timestamp,
                accuracy: position.accuracy,
                speedMPS: position.speedMPS
            };
        }

        // Update marker heading
        function updateMarkerHeading(heading) {
            if (!userMarker || heading === undefined || heading === null) return;
            
            const markerElement = userMarker.getElement();
            if (!markerElement) return;
            
            const directionElement = markerElement.querySelector('.user-marker-direction');
            if (!directionElement) return;
            
            // Show direction indicator if we have a valid heading
            markerElement.classList.add('with-direction');
            
            // Rotate direction indicator to match heading
            directionElement.style.transform = `translate(-50%, -50%) rotate(${heading}deg)`;
        }

        // Linear interpolation helper
        function lerp(start, end, factor) {
            return start + factor * (end - start);
        }

        // Calculate distance between two points in meters
        function calculateDistance(point1, point2) {
            if (!point1 || !point2) return 0;
            
            // Convert to radians
            const lat1 = point1.lat * Math.PI / 180;
            const lng1 = point1.lng * Math.PI / 180;
            const lat2 = point2.lat * Math.PI / 180;
            const lng2 = point2.lng * Math.PI / 180;
            
            // Haversine formula
            const dLat = lat2 - lat1;
            const dLng = lng2 - lng1;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(lat1) * Math.cos(lat2) * 
                      Math.sin(dLng/2) * Math.sin(dLng/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            
            // Earth radius in meters
            const R = 6371000;
            
            // Distance in meters
            return R * c;
        }

        // Check nearby locations
        function checkNearbyLocations() {
            if (!lastPosition || currentLocationIndex >= gameLocations.length) return;
            
            const currentLocation = gameLocations[currentLocationIndex];
            const distance = calculateDistance(
                { lat: lastPosition.lat, lng: lastPosition.lng },
                { lat: currentLocation.lat, lng: currentLocation.lng }
            );
            
            // Convert to feet for display
            const distanceFeet = Math.round(distance * 3.28084);
            
            // Update distance box
            updateDistanceBox(currentLocation, distanceFeet);
            
            // Check if within proximity for zoom adjustment
            if (distance < PROXIMITY_THRESHOLD && !isWithinProximity) {
                isWithinProximity = true;
                
                // Zoom in when getting close to location
                if (!proximityZoomActive && !isMapInteracting) {
                    proximityZoomActive = true;
                    targetZoomLevel = PROXIMITY_ZOOM_LEVEL;
                    map.setZoom(targetZoomLevel, {
                        animate: true,
                        duration: ZOOM_TRANSITION_DURATION
                    });
                }
            } else if (distance >= PROXIMITY_THRESHOLD && isWithinProximity) {
                isWithinProximity = false;
                proximityZoomActive = false;
                
                // Reset zoom level based on speed
                if (!isMapInteracting) {
                    updateZoomBasedOnSpeed(lastPosition.speedMPS || 0);
                }
            }
            
            // Check if within haptic range
            if (distance < HAPTIC_THRESHOLD && !isWithinHapticRange) {
                isWithinHapticRange = true;
                triggerHapticFeedback();
            } else if (distance >= HAPTIC_THRESHOLD && isWithinHapticRange) {
                isWithinHapticRange = false;
            }
            
            // Check if within interaction distance
            if (distance < DISTANCE_THRESHOLD && !isLocationHuntVisible) {
                // Show location hunt
                showLocationHunt(currentLocation);
            }
        }

        // Update distance box
        function updateDistanceBox(location, distanceFeet) {
            const distanceBox = document.getElementById('distanceBox');
            const locationName = distanceBox.querySelector('.location-name');
            const distanceValue = distanceBox.querySelector('.distance-value');
            
            if (locationName && distanceValue) {
                locationName.textContent = location.name;
                
                if (distanceFeet < DISTANCE_THRESHOLD) {
                    distanceValue.textContent = "You have arrived!";
                    distanceBox.style.borderLeftColor = "var(--accent-color)";
                } else {
                    distanceValue.textContent = `${distanceFeet} feet away`;
                    distanceBox.style.borderLeftColor = "var(--primary-color)";
                }
            }
        }

        // Update position buffer
        function updatePositionBuffer(position) {
            positionBuffer.push(position);
            
            // Keep buffer size limited
            while (positionBuffer.length > MAX_BUFFER_SIZE) {
                positionBuffer.shift();
            }
        }

        // Update stationary history
        function updateStationaryHistory(position) {
            stationaryPositionHistory.push(position);
            
            // Keep history size limited
            while (stationaryPositionHistory.length > STATIONARY_POSITION_HISTORY_SIZE) {
                stationaryPositionHistory.shift();
            }
        }

        // Calculate stationary position from buffer
        function calculateStationaryPosition(buffer) {
            if (!buffer || buffer.length < 3) return null;
            
            // Use weighted average with more recent positions having higher weight
            let totalWeight = 0;
            let weightedLat = 0;
            let weightedLng = 0;
            let totalAccuracy = 0;
            
            // Calculate weighted average
            for (let i = 0; i < buffer.length; i++) {
                // Weight decreases with age and increases with accuracy
                const ageWeight = Math.pow(STATIONARY_POSITION_WEIGHT_DECAY, buffer.length - i - 1);
                const accuracyWeight = 1 / Math.max(1, buffer[i].accuracy);
                const weight = ageWeight * accuracyWeight;
                
                weightedLat += buffer[i].lat * weight;
                weightedLng += buffer[i].lng * weight;
                totalWeight += weight;
                totalAccuracy += buffer[i].accuracy;
            }
            
            // Calculate average accuracy
            const avgAccuracy = totalAccuracy / buffer.length;
            
            // Get most recent heading
            const heading = buffer[buffer.length - 1].heading;
            
            return {
                lat: weightedLat / totalWeight,
                lng: weightedLng / totalWeight,
                accuracy: avgAccuracy * 0.8, // Slightly improve accuracy due to averaging
                heading: heading,
                timestamp: Date.now(),
                speedMPS: 0, // Stationary
                confidence: 0.9, // High confidence in stationary position
                mode: 'stationary'
            };
        }

        // Check stationary state
        function checkStationaryState(position) {
            if (!isStationary) return;
            
            // Check if still stationary
            if (stationaryCount >= STATIONARY_THRESHOLD) {
                // Still stationary, schedule next check
                stationaryCheckTimeout = setTimeout(() => checkStationaryState(position), STATIONARY_CHECK_INTERVAL);
            } else {
                // No longer stationary
                isStationary = false;
                kalmanFilter.setStationaryMode(false);
                
                // Update marker class
                const markerElement = userMarker.getElement();
                if (markerElement) {
                    markerElement.classList.remove("user-marker-stationary");
                }
                
                console.log("User is moving again (from timeout check)");
            }
        }

        // Predict position from heading
        function predictPositionFromHeading(position, heading, distance) {
            // Convert heading to radians (0 is north, clockwise)
            const headingRad = (90 - heading) * Math.PI / 180;
            
            // Calculate offsets
            const latOffset = Math.sin(headingRad) * distance / 111000; // 1 degree lat  111km
            const lngOffset = Math.cos(headingRad) * distance / (111000 * Math.cos(position.lat * Math.PI / 180));
            
            return {
                lat: position.lat + latOffset,
                lng: position.lng + lngOffset,
                accuracy: position.accuracy,
                heading: position.heading,
                timestamp: position.timestamp,
                speedMPS: position.speedMPS
            };
        }

        // Check if device is in motion based on motion sensors
        function isDeviceInMotion() {
            if (!deviceMotion || deviceMotionBuffer.length < 3) return false;
            
            // Calculate average motion magnitude from recent samples
            let totalMagnitude = 0;
            
            for (const motion of deviceMotionBuffer) {
                const magnitude = Math.sqrt(
                    motion.x * motion.x + 
                    motion.y * motion.y + 
                    motion.z * motion.z
                );
                totalMagnitude += magnitude;
            }
            
            const avgMagnitude = totalMagnitude / deviceMotionBuffer.length;
            
            // Return true if average magnitude exceeds threshold
            return avgMagnitude > MOTION_THRESHOLD;
        }

        // Handle device motion event
        function handleDeviceMotion(event) {
            const currentTime = Date.now();
            
            // Throttle updates
            if (currentTime - lastDeviceMotionTimestamp < 100) return;
            lastDeviceMotionTimestamp = currentTime;
            
            // Store motion data
            deviceMotion = {
                x: event.accelerationIncludingGravity.x,
                y: event.accelerationIncludingGravity.y,
                z: event.accelerationIncludingGravity.z,
                timestamp: currentTime
            };
            
            // Add to buffer
            deviceMotionBuffer.push(deviceMotion);
            
            // Keep buffer size limited
            while (deviceMotionBuffer.length > MOTION_SAMPLE_SIZE) {
                deviceMotionBuffer.shift();
            }
            
            // Update device stationary time
            if (isDeviceInMotion()) {
                deviceStationaryTime = 0;
            } else {
                deviceStationaryTime += (currentTime - lastDeviceMotionTimestamp);
            }
        }

        // Handle device orientation event
        function handleDeviceOrientation(event) {
            // Store orientation data
            deviceOrientation = {
                alpha: event.alpha, // Z-axis rotation [0, 360)
                beta: event.beta,   // X-axis rotation [-180, 180)
                gamma: event.gamma, // Y-axis rotation [-90, 90)
                timestamp: Date.now()
            };
        }

        // Request motion and orientation permissions
        function requestMotionPermission() {
            // Check if DeviceMotionEvent is available and requires permission
            if (typeof DeviceMotionEvent !== 'undefined' && 
                typeof DeviceMotionEvent.requestPermission === 'function') {
                
                // iOS 13+ requires permission
                DeviceMotionEvent.requestPermission()
                    .then(permissionState => {
                        if (permissionState === 'granted') {
                            // Permission granted, add event listeners
                            window.addEventListener("devicemotion", handleDeviceMotion);
                            window.addEventListener("deviceorientation", handleDeviceOrientation);
                            orientationPermissionGranted = true;
                            
                            // Hide orientation warning if shown
                            const orientationWarning = document.getElementById('orientationWarning');
                            if (orientationWarning) {
                                orientationWarning.style.display = 'none';
                            }
                        } else {
                            // Permission denied, show warning
                            showOrientationWarning();
                        }
                    })
                    .catch(console.error);
            } else {
                // No permission required, add event listeners directly
                window.addEventListener("devicemotion", handleDeviceMotion);
                window.addEventListener("deviceorientation", handleDeviceOrientation);
                orientationPermissionGranted = true;
            }
        }

        // Show orientation warning
        function showOrientationWarning() {
            if (orientationWarningShown) return;
            
            const orientationWarning = document.getElementById('orientationWarning');
            if (orientationWarning) {
                orientationWarning.style.display = 'flex';
                orientationWarningShown = true;
            }
        }

        // Trigger haptic feedback
        function triggerHapticFeedback() {
            const currentTime = Date.now();
            
            // Limit frequency of haptic feedback
            if (currentTime - lastHapticFeedbackTime < HAPTIC_FEEDBACK_INTERVAL) return;
            lastHapticFeedbackTime = currentTime;
            
            // Try to use Vibration API if available
            if ('vibrate' in navigator) {
                navigator.vibrate(HAPTIC_PATTERN);
            }
            
            // Visual feedback
            const hapticIndicator = document.getElementById('hapticIndicator');
            if (hapticIndicator) {
                hapticIndicator.classList.add('active');
                
                // Remove active class after animation completes
                setTimeout(() => {
                    hapticIndicator.classList.remove('active');
                }, 500);
            }
        }

        // Show directions modal
        function showDirectionsModal(location) {
            currentDirectionsLocation = location;
            
            // Set up navigation links
            const googleMapsBtn = document.getElementById('googleMapsBtn');
            const appleMapsBtn = document.getElementById('appleMapsBtn');
            const wazeBtn = document.getElementById('wazeBtn');
            
            if (googleMapsBtn && appleMapsBtn && wazeBtn) {
                // Google Maps
                googleMapsBtn.href = `https://www.google.com/maps/dir/?api=1&destination=${location.lat},${location.lng}`;
                
                // Apple Maps
                appleMapsBtn.href = `https://maps.apple.com/?daddr=${location.lat},${location.lng}&dirflg=d`;
                
                // Waze
                wazeBtn.href = `https://waze.com/ul?ll=${location.lat},${location.lng}&navigate=yes`;
                
                // Show modal
                document.getElementById('directionsModal').style.display = 'flex';
            }
        }

        // Close directions modal
        function closeDirectionsModal() {
            document.getElementById('directionsModal').style.display = 'none';
            currentDirectionsLocation = null;
        }

        // Create navigation links
        function createNavigationLinks(location) {
            const googleMapsLink = document.getElementById('googleMapsLink');
            const appleMapsLink = document.getElementById('appleMapsLink');
            const wazeLink = document.getElementById('wazeLink');
            
            if (googleMapsLink && appleMapsLink && wazeLink) {
                // Google Maps
                googleMapsLink.href = `https://www.google.com/maps/dir/?api=1&destination=${location.lat},${location.lng}`;
                
                // Apple Maps
                appleMapsLink.href = `https://maps.apple.com/?daddr=${location.lat},${location.lng}&dirflg=d`;
                
                // Waze
                wazeLink.href = `https://waze.com/ul?ll=${location.lat},${location.lng}&navigate=yes`;
            }
        }

        // Skip to next location
        function skipToNextLocation() {
            // Remove the current marker from the map
            if (currentLocationIndex < allLocationMarkers.length) {
                map.removeLayer(allLocationMarkers[currentLocationIndex]);
            }
            
            // Move to next location
            currentLocationIndex++;
            
            // Update visible markers
            updateVisibleMarkers();
            
            // Update distance box
            if (lastPosition && currentLocationIndex < gameLocations.length) {
                const location = gameLocations[currentLocationIndex];
                const distance = calculateDistance(
                    { lat: lastPosition.lat, lng: lastPosition.lng },
                    { lat: location.lat, lng: location.lng }
                );
                const distanceFeet = Math.round(distance * 3.28084);
                updateDistanceBox(location, distanceFeet);
            }
            
            // Close any open popups
            map.closePopup();
        }

        // Update zoom based on speed
        function updateZoomBasedOnSpeed(speed) {
            // Add to speed samples
            speedSamples.push(speed);
            
            // Keep buffer size limited
            while (speedSamples.length > 5) {
                speedSamples.shift();
            }
            
            // Calculate average speed
            const avgSpeed = speedSamples.reduce((sum, s) => sum + s, 0) / speedSamples.length;
            
            // Calculate target zoom level based on speed
            let newZoomLevel;
            
            if (avgSpeed < WALKING_SPEED_THRESHOLD) {
                // Walking or stationary
                newZoomLevel = DEFAULT_ZOOM_LEVEL;
            } else if (avgSpeed < RUNNING_SPEED_THRESHOLD) {
                // Running
                newZoomLevel = DEFAULT_ZOOM_LEVEL - 1;
            } else if (avgSpeed < DRIVING_SPEED_THRESHOLD) {
                // Slow driving
                newZoomLevel = DEFAULT_ZOOM_LEVEL - 2;
            } else if (avgSpeed < HIGH_SPEED_THRESHOLD) {
                // Normal driving
                newZoomLevel = DEFAULT_ZOOM_LEVEL - 3;
            } else {
                // High speed
                newZoomLevel = MIN_ZOOM_LEVEL;
            }
            
            // Only update if significant change
            if (Math.abs(newZoomLevel - targetZoomLevel) >= 0.5) {
                targetZoomLevel = newZoomLevel;
                
                // Apply zoom change if following user and not interacting
                if (followUser && !isMapInteracting && !proximityZoomActive) {
                    map.setZoom(targetZoomLevel, {
                        animate: true,
                        duration: ZOOM_TRANSITION_DURATION
                    });
                }
            }
        }
    </script>
</body>
</html>
