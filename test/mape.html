
    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"></script>
    
    <script src="/locations_test.js?v=1.0.4"></script>

    <script>
        // Global variables
let map, userMarker, markerClusterGroup
let currentLocationIndex = 0
const visitedLocations = []
let gameLocations = []
let inactivityTimer
let isLocationHuntVisible = false
let lastPosition = null
let positionBuffer = []
const MAX_BUFFER_SIZE = 30 // Increased buffer size for smoother tracking
const DISTANCE_THRESHOLD = 20 // 20 feet to measure threshold distance to marker before opening location page.
const PROXIMITY_THRESHOLD = 40 // 40 feet threshold for zoom changes
let velocity = { lat: 0, lng: 0 }
let isMapInteracting = false
let followUser = true
let locationCooldowns = {}
let userIsInteracting = false
const preloadedImages = new Map() // Map to store preloaded images
const preloadedAudio = new Map() // Map to store preloaded audio
let currentSpeed = 0 // Current speed in meters per second
let lastZoomLevel = 17 // Default zoom level
let stationaryPositionHistory = [] // Array to store stationary positions for averaging
let deviceOrientation = null // Store device orientation data
let deviceMotion = null // Store device motion data
let orientationPermissionGranted = false
let geolocationSensor = null // Store GeolocationSensor instance
let isNearLocation = false // Flag to track if user is near a location
let lastProximityCheck = 0 // Last time proximity was checked
let isReturningFromExhibit = false // Flag to track if returning from exhibit

// Enhanced constants for better stabilization
const MICRO_MOVEMENT_THRESHOLD = 0.3 // Meters - threshold for detecting micro-movements (reduced for better stability)
const STATIONARY_ACCURACY_MULTIPLIER = 1.2 // Looser accuracy bounds to prevent false movement detection
const MAX_ACCEPTABLE_ACCURACY = 25 // meters - more lenient accuracy requirement
const STATIONARY_THRESHOLD = 2 // Number of consecutive stationary positions to consider user as stationary (reduced for faster stabilization)
const STATIONARY_TIME_THRESHOLD = 3000 // ms - time to consider user stationary (reduced)
const STATIONARY_CHECK_INTERVAL = 1000 // ms - interval to check if still stationary (reduced)
const VELOCITY_DECAY = 0.92 // Higher value for smoother velocity transitions
const MIN_DISTANCE_THRESHOLD = 1.0 // meters - minimum distance to consider movement (reduced)
const EXTENDED_DISTANCE_THRESHOLD = 80 // meters - distance to consider a significant position change
const UPDATE_INTERVAL = 50 // ms - more frequent updates for smoother movement
const STATIONARY_POSITION_HISTORY_SIZE = 15 // Number of positions to keep for stationary averaging (increased)
const STATIONARY_POSITION_WEIGHT_DECAY = 0.9 // Weight decay for older positions in stationary average (reduced)
const SUDDEN_MOVEMENT_THRESHOLD = 0.8 // meters - threshold for detecting sudden movements (reduced)
const POSITION_JUMP_THRESHOLD = 2.0 // meters - threshold for detecting position jumps (reduced)
const ZOOM_CHANGE_COOLDOWN = 1500 // ms - cooldown between zoom changes

// Background handling constants
const BACKGROUND_THRESHOLD = 15000 // ms - time to consider app was in background (reduced)
const INACTIVITY_TIMEOUT = 20000 // ms - time to consider user inactive (reduced)

// Kalman filter parameters - optimized for better movement tracking
const KALMAN_PROCESS_NOISE = 0.00001
const KALMAN_MEASUREMENT_NOISE_BASE = 0.1
const KALMAN_STATIONARY_NOISE = 0.000001

// Animation parameters
const ANIMATION_DURATION = 200 // ms - reduced duration of position animation for more responsive transitions
const HEADING_SMOOTHING = 0.85 // Reduced heading smoothing factor for more responsive direction changes

// Zoom level parameters
const MAX_ZOOM_LEVEL = 17 // Maximum zoom level (stationary)
const MIN_ZOOM_LEVEL = 13 // Minimum zoom level (high speed)
const WALKING_ZOOM_LEVEL = 17 // Zoom level for walking speed
const WALKING_SPEED_THRESHOLD = 1.5 // m/s - threshold for walking speed
const RUNNING_SPEED_THRESHOLD = 4.0 // m/s - threshold for running speed
const DRIVING_SPEED_THRESHOLD = 10.0 // m/s - threshold for driving speed
const ZOOM_TRANSITION_DURATION = 0.5 // seconds - reduced duration of zoom transition for more responsive zooming

// Motion detection parameters
const MOTION_THRESHOLD = 0.8 // Reduced threshold for detecting significant motion
const MOTION_SAMPLE_SIZE = 15 // Increased number of motion samples to keep
const MOTION_CHECK_INTERVAL = 200 // ms - reduced interval to check motion for more responsive detection

// Edge recenter parameters - optimized for better edge recentering
const EDGE_THRESHOLD_PERCENTAGE = 0.25 // Percentage of viewport to trigger recenter (reduced)
const CRITICAL_EDGE_THRESHOLD = 0.125 // Critical threshold for emergency recenter (reduced)
const RECENTER_COOLDOWN = 1500 // ms - minimum time between recenters (reduced)

// Speed accuracy parameters
const SPEED_ACCURACY_THRESHOLD = 5.0; // 5 m/s accuracy is reasonable for most GPS systems

// State variables
let lastUpdateTime = null
let lastVelocity = { lat: 0, lng: 0 }
let isStationary = false
let stationaryStartTime = null
let stationaryCheckTimeout = null
let lastUpdateTimestamp = null
let lastHiddenTime = 0
let lastKnownPosition = null
const isTransitioning = false
let lastVisitedLocationId = null
let stationaryCount = 0
let lastSmoothedPosition = null
let lastRecenterTime = Date.now()
let retryCount = 0
const stationaryBuffer = []
const stationaryPosition = null
let isStabilizing = true // Flag to track initial stabilization
let lastStationaryPosition = null // Last stable position when stationary
const motionSamples = [] // Array to store motion samples
const lastMotionTimestamp = 0 // Last time motion was detected
let deviceStationaryTime = 0 // Time device has been stationary based on motion sensors
let animationFrameId = null // Store requestAnimationFrame ID
let renderTimestamp = null // Last render timestamp
const positionUpdateQueue = [] // Queue for position updates to be processed
let lastHeadingValue = null // Last heading value
const headingBuffer = [] // Buffer for heading values
let isFirstPositionUpdate = true // Flag for first position update
let lastRenderPosition = null // Last rendered position

const positionInterpolator = {
  currentAnimation: null,
  startTime: null,
  from: null,
  to: null,
  duration: 0,
  
  start: function(from, to, duration) {
    // Cancel any existing animation
    if (this.currentAnimation) {
      cancelAnimationFrame(this.currentAnimation);
    }
    
    // Store animation parameters
    this.startTime = performance.now();
    this.from = from;
    this.to = to;
    this.duration = duration;
    
    // Start animation
    this.update();
  },
  
  update: function() {
    if (!this.startTime) return;
    
    const currentTime = performance.now();
    const elapsed = currentTime - this.startTime;
    const progress = Math.min(elapsed / this.duration, 1);
    
    // Use easing for smoother motion (ease-out)
    const eased = 1 - Math.pow(1 - progress, 3);
    
    // Interpolate between positions
    const currentPosition = {
      lat: this.from.lat + (this.to.lat - this.from.lat) * eased,
      lng: this.from.lng + (this.to.lng - this.from.lng) * eased
    };
    
    // Update marker position
    updateUserMarkerPosition(currentPosition);
    lastRenderPosition = currentPosition;
    
    // Continue animation if not complete
    if (progress < 1) {
      this.currentAnimation = requestAnimationFrame(() => this.update());
    } else {
      this.currentAnimation = null;
      this.startTime = null;
    }
  },
  
  cancel: function() {
    if (this.currentAnimation) {
      cancelAnimationFrame(this.currentAnimation);
      this.currentAnimation = null;
      this.startTime = null;
    }
  },
  
  isInterpolating: function() {
    return this.currentAnimation !== null;
  }
};
      
let mapViewportWidth = 0 // Store map viewport width
let mapViewportHeight = 0 // Store map viewport height
let lastMapCenter = null // Last map center position
let lastMapZoom = null // Last map zoom level
let edgeRecenterInProgress = false // Flag to track edge recentering
const domUpdateScheduled = false // Flag to track scheduled DOM updates
const pendingDomUpdates = new Map() // Map to store pending DOM updates
let usingGeolocationSensorAPI = false // Flag to track which geolocation API is being used
const lockStationaryPosition = false // Flag to lock stationary position and prevent jitter
let positionHistory = [] // Array to store recent position history for jump detection
const lastPositionTimestamp = 0 // Last time a position was processed
let suddenMovementCount = 0 // Counter for consecutive sudden movements
let isJumpDetected = false // Flag to track if a position jump is detected
let stationaryPositionLocked = false // Flag to indicate if stationary position is locked
let stationaryPositionLockTime = 0 // Time when stationary position was locked
let lastValidPosition = null // Last valid position before a jump
let stationaryLockTimeout = null // Timeout for locking stationary position
const positionStabilityCounter = 0 // Counter for position stability
let lastZoomChangeTime = 0 // Last time zoom was changed due to proximity
let lastProximityDistance = Number.POSITIVE_INFINITY // Last distance to nearest location
const highPrecisionAvailable = true // Flag to track if high precision is available
const lowPrecisionFallbackActive = false // Flag to track if low precision fallback is active
const devicePixelRatio = typeof window !== 'undefined' ? window.devicePixelRatio || 1 : 1 // Device pixel ratio for smoother rendering
const lastDeviceOrientation = null // Last device orientation for smoother heading changes
const orientationUpdateInterval = null // Interval for orientation updates
const motionUpdateInterval = null // Interval for motion updates
const lastAccuracy = Number.POSITIVE_INFINITY // Last position accuracy
const accuracyTrend = [] // Array to track accuracy trend
const isAccuracyImproving = false // Flag to track if accuracy is improving
const lastHeadingUpdateTime = 0 // Last time heading was updated
const headingUpdateInterval = 100 // ms - interval for heading updates
const isDeviceMoving = false // Flag to track if device is moving based on sensors
const lastDeviceMotionTime = 0 // Last time device motion was detected
const deviceMotionTimeout = null // Timeout for device motion detection
const deviceOrientationTimeout = null // Timeout for device orientation detection
const positionUpdateIntervalId = null // Interval ID for position updates
const positionUpdateRate = 1000 // ms - interval for position updates
const adaptivePositionUpdateRate = true // Flag to enable adaptive position update rate
const lastPositionAccuracy = Number.POSITIVE_INFINITY // Last position accuracy for adaptive update rate
const highFrequencyUpdatesActive = false // Flag to track if high frequency updates are active
const highFrequencyUpdateTimeout = null // Timeout for high frequency updates
const lastHighFrequencyUpdateTime = 0 // Last time high frequency updates were activated
const highFrequencyUpdateDuration = 5000 // ms - duration of high frequency updates
const isPositionStable = false // Flag to track if position is stable
const positionStabilityThreshold = 5 // Number of consecutive stable positions to consider position stable
const positionStabilityRadius = 2.0 // meters - radius for position stability
const lastStablePosition = null // Last stable position
const stablePositionConfidence = 0 // Confidence in stable position (0-1)
const isUsingHighAccuracy = true // Flag to track if high accuracy is being used
const highAccuracyFailureCount = 0 // Counter for high accuracy failures
const maxHighAccuracyFailures = 3 // Maximum number of high accuracy failures before fallback
const lastSuccessfulHighAccuracyUpdate = 0 // Last time a high accuracy update was successful
const highAccuracyTimeout = 10000 // ms - timeout for high accuracy updates
let isWatchPositionActive = false // Flag to track if watchPosition is active
let watchPositionId = null // ID for watchPosition
const lastWatchPositionUpdate = 0 // Last time watchPosition was updated
const watchPositionUpdateInterval = 1000 // ms - interval for watchPosition updates
const isUsingDeviceMotionForHeading = false // Flag to track if device motion is being used for heading
const lastCompassHeading = null // Last compass heading
const compassHeadingBuffer = [] // Buffer for compass heading values
const compassHeadingBufferSize = 5 // Size of compass heading buffer
const isCompassCalibrated = false // Flag to track if compass is calibrated
const compassCalibrationTimeout = null // Timeout for compass calibration
const compassCalibrationDuration = 5000 // ms - duration of compass calibration
const lastCompassCalibrationTime = 0 // Last time compass was calibrated
const isUsingGyroscopeForOrientation = false // Flag to track if gyroscope is being used for orientation
const gyroscopeData = null // Gyroscope data
const lastGyroscopeUpdateTime = 0 // Last time gyroscope was updated
const gyroscopeUpdateInterval = 100 // ms - interval for gyroscope updates
const isDeviceStationaryByMotion = false // Flag to track if device is stationary based on motion sensors
const deviceStationaryByMotionTime = 0 // Time device has been stationary based on motion sensors
const deviceStationaryByMotionThreshold = 2000 // ms - threshold for device to be considered stationary by motion
const deviceMotionMagnitude = 0 // Magnitude of device motion
const deviceMotionMagnitudeBuffer = [] // Buffer for device motion magnitude values
const deviceMotionMagnitudeBufferSize = 10 // Size of device motion magnitude buffer
const deviceMotionMagnitudeThreshold = 0.5 // Threshold for device motion magnitude to be considered moving

// Utility function to calculate distance between two coordinates
function calculateDistance(pos1, pos2) {
  if (
    !pos1 ||
    !pos2 ||
    typeof pos1.lat !== "number" ||
    typeof pos1.lng !== "number" ||
    typeof pos2.lat !== "number" ||
    typeof pos2.lng !== "number"
  ) {
    return Number.POSITIVE_INFINITY
  }

  // Haversine formula for more accurate distance calculation
  const R = 6371000 // Earth radius in meters
  const lat1 = (pos1.lat * Math.PI) / 180
  const lat2 = (pos2.lat * Math.PI) / 180
  const deltaLat = ((pos2.lat - pos1.lat) * Math.PI) / 180
  const deltaLng = ((pos2.lng - pos1.lng) * Math.PI) / 180

  const a =
    Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) +
    Math.cos(lat1) * Math.cos(lat2) * Math.sin(deltaLng / 2) * Math.sin(deltaLng / 2)
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))

  return R * c
}

// Enhanced Kalman Filter implementation
class KalmanFilter {
  constructor() {
    // State vector [x, y, vx, vy]
    this.x = 0
    this.y = 0
    this.vx = 0
    this.vy = 0

    // Error covariance matrix
    this.P = [
      [100, 0, 0, 0], // Initial high uncertainty
      [0, 100, 0, 0],
      [0, 0, 10, 0],
      [0, 0, 0, 10],
    ]

    // Process noise
    this.Q = KALMAN_PROCESS_NOISE

    // Measurement noise (will be adjusted based on GPS accuracy)
    this.R = KALMAN_MEASUREMENT_NOISE_BASE

    // Time delta
    this.dt = 1.0

    // Initialized flag
    this.initialized = false

    // Heading and accuracy tracking
    this.lastHeading = null
    this.headingConfidence = 0

    // Stationary mode flag
    this.stationaryMode = false
    this.stationaryStartTime = 0

    // Last timestamp
    this.lastTimestamp = null

    // Adaptive noise parameters
    this.adaptiveNoiseMin = 0.0002
    this.adaptiveNoiseMax = 0.002
    this.adaptiveNoiseFactor = 1.0

    // Position history for jitter detection
    this.positionHistory = []
    this.maxPositionHistory = 10
    this.jitterThreshold = 0.35 // meters
    this.jitterCount = 0

    // Stationary lock
    this.stationaryLocked = false
    this.stationaryPosition = null

    // Heading smoothing
    this.headingSmoothingFactor = 0.8
    this.headingBuffer = []
    this.headingBufferSize = 7

    // Velocity smoothing
    this.velocitySmoothingFactor = 0.8
    this.velocityBuffer = []
    this.velocityBufferSize = 7

    // Accuracy-based adaptation
    this.accuracyBuffer = []
    this.accuracyBufferSize = 7
    this.lastAccuracy = Number.POSITIVE_INFINITY
    this.isAccuracyImproving = false

    // Motion-based adaptation
    this.motionDetected = false
    this.motionConfidence = 0

    // Adaptive parameters based on device capabilities
    this.deviceCapabilitiesSet = false
    this.deviceSupportsHighAccuracy = true
    this.deviceSupportsMotionSensors = true
    this.deviceSupportsOrientationSensors = true

    // Innovation tracking to detect filter divergence
    this.innovationBuffer = []
    this.innovationBufferSize = 10
    this.innovationThreshold = 3.0 // standard deviations

    // GNSS receiver type (GPS, GLONASS, Galileo, etc)
    this.receiverType = "GPS"

    // Environment type (urban, rural, indoor, etc)
    this.environmentType = "mixed"
  }

  // Set device capabilities
  setDeviceCapabilities(highAccuracy, motionSensors, orientationSensors) {
    this.deviceCapabilitiesSet = true
    this.deviceSupportsHighAccuracy = highAccuracy
    this.deviceSupportsMotionSensors = motionSensors
    this.deviceSupportsOrientationSensors = orientationSensors

    // Adjust parameters based on device capabilities
    if (!highAccuracy) {
      this.adaptiveNoiseMin *= 1.5
      this.adaptiveNoiseMax *= 1.5
      this.jitterThreshold *= 1.5
    }

    if (!motionSensors) {
      this.adaptiveNoiseMin *= 1.2
      this.adaptiveNoiseMax *= 1.2
    }

    if (!orientationSensors) {
      this.headingSmoothingFactor = 0.9
    }

    return this
  }

  // Set the type of GNSS receiver
  setReceiverType(type) {
    this.receiverType = type

    // Adjust parameters based on receiver type
    switch (type.toUpperCase()) {
      case "GPS_GLONASS":
      case "MULTI_CONSTELLATION":
        this.adaptiveNoiseMin *= 0.8
        this.adaptiveNoiseMax *= 0.8
        break
      case "BASIC_GPS":
        this.adaptiveNoiseMin *= 1.2
        this.adaptiveNoiseMax *= 1.2
        break
      case "HIGH_PRECISION":
        this.adaptiveNoiseMin *= 0.5
        this.adaptiveNoiseMax *= 0.5
        break
    }

    return this
  }

  // Set the type of environment
  setEnvironmentType(type) {
    this.environmentType = type

    // Adjust parameters based on environment type
    switch (type.toLowerCase()) {
      case "urban":
        this.adaptiveNoiseMin *= 1.3
        this.adaptiveNoiseMax *= 1.3
        this.jitterThreshold *= 0.9
        break
      case "rural":
        this.adaptiveNoiseMin *= 0.8
        this.adaptiveNoiseMax *= 0.8
        this.jitterThreshold *= 1.2
        break
      case "indoor":
        this.adaptiveNoiseMin *= 1.5
        this.adaptiveNoiseMax *= 1.5
        this.jitterThreshold *= 0.7
        break
    }

    return this
  }

  // Initialize the filter with first position
  reset(position) {
    if (!position || typeof position.lat !== "number" || typeof position.lng !== "number") {
      console.error("Invalid position for Kalman filter reset")
      return
    }

    this.x = position.lng
    this.y = position.lat
    this.vx = 0
    this.vy = 0

    // Reset covariance matrix with high initial uncertainty
    this.P = [
      [100, 0, 0, 0],
      [0, 100, 0, 0],
      [0, 0, 10, 0],
      [0, 0, 0, 10],
    ]

    this.initialized = true
    this.lastHeading = position.heading || null
    this.headingConfidence = 0
    this.stationaryMode = false
    this.lastTimestamp = position.timestamp || Date.now()
    this.adaptiveNoiseFactor = 1.0
    this.positionHistory = []
    this.jitterCount = 0
    this.stationaryLocked = false
    this.stationaryPosition = null
    this.headingBuffer = []
    this.velocityBuffer = []
    this.accuracyBuffer = []
    this.lastAccuracy = position.accuracy || Number.POSITIVE_INFINITY
    this.isAccuracyImproving = false
    this.motionDetected = false
    this.motionConfidence = 0
    this.innovationBuffer = []

    return this
  }

  // Set stationary mode
  setStationaryMode(isStationary) {
    this.stationaryMode = isStationary

    // When entering stationary mode, reduce velocity to zero
    if (isStationary) {
      this.vx = 0
      this.vy = 0
      this.stationaryStartTime = Date.now()

      // Reduce process noise for stationary mode
      this.Q = KALMAN_STATIONARY_NOISE
      this.adaptiveNoiseFactor = 0.03
    } else {
      // Reset to normal process noise when moving
      this.Q = KALMAN_PROCESS_NOISE
      this.adaptiveNoiseFactor = 1.0
      this.stationaryLocked = false
      this.stationaryPosition = null
    }

    return this
  }

  // Lock stationary position
  lockStationaryPosition(position) {
    if (!this.stationaryMode) return this

    this.stationaryLocked = true
    this.stationaryPosition = position
    console.log("Kalman filter: Stationary position locked")

    return this
  }

  // Update accuracy buffer and check if accuracy is improving
  updateAccuracyBuffer(accuracy) {
    if (isNaN(accuracy) || accuracy <= 0) {
      accuracy = this.lastAccuracy || 20
    }

    this.accuracyBuffer.push(accuracy)
    while (this.accuracyBuffer.length > this.accuracyBufferSize) {
      this.accuracyBuffer.shift()
    }

    if (this.accuracyBuffer.length >= 3) {
      const avgRecent =
        (this.accuracyBuffer[this.accuracyBuffer.length - 1] + this.accuracyBuffer[this.accuracyBuffer.length - 2]) / 2
      const avgOlder =
        (this.accuracyBuffer[0] + (this.accuracyBuffer.length > 1 ? this.accuracyBuffer[1] : this.accuracyBuffer[0])) /
        2

      this.isAccuracyImproving = avgRecent < avgOlder
    }

    this.lastAccuracy = accuracy

    return this
  }

  // Track innovation to detect filter divergence
  updateInnovationBuffer(innovation) {
    this.innovationBuffer.push(innovation)
    while (this.innovationBuffer.length > this.innovationBufferSize) {
      this.innovationBuffer.shift()
    }

    if (this.innovationBuffer.length >= 5) {
      // Calculate mean and standard deviation of innovations
      const sum = this.innovationBuffer.reduce((acc, val) => acc + val, 0)
      const mean = sum / this.innovationBuffer.length

      const sumSquaredDiff = this.innovationBuffer.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0)
      const stdDev = Math.sqrt(sumSquaredDiff / this.innovationBuffer.length)

      // If innovation is consistently large, the filter might be diverging
      const latestInnovation = this.innovationBuffer[this.innovationBuffer.length - 1]
      if (Math.abs(latestInnovation - mean) > this.innovationThreshold * stdDev) {
        // Increase uncertainty to force filter to trust measurements more
        for (let i = 0; i < 4; i++) {
          this.P[i][i] *= 2.0
        }
      }
    }

    return this
  }

  // Detect jitter in position updates
  detectJitter(newPosition) {
    if (this.positionHistory.length === 0) {
      this.positionHistory.push(newPosition)
      return false
    }

    const lastPos = this.positionHistory[this.positionHistory.length - 1]
    const distance = calculateDistance(lastPos, newPosition)

    // Add to history
    this.positionHistory.push(newPosition)
    while (this.positionHistory.length > this.maxPositionHistory) {
      this.positionHistory.shift()
    }

    // Check for rapid back-and-forth movement (jitter)
    if (this.positionHistory.length >= 3 && this.stationaryMode) {
      const pos1 = this.positionHistory[this.positionHistory.length - 3]
      const pos2 = this.positionHistory[this.positionHistory.length - 2]
      const pos3 = this.positionHistory[this.positionHistory.length - 1]

      const dist1 = calculateDistance(pos1, pos2)
      const dist2 = calculateDistance(pos2, pos3)

      // If moving back and forth in small distances
      if (
        dist1 < this.jitterThreshold &&
        dist2 < this.jitterThreshold &&
        Math.sign(pos3.lat - pos2.lat) !== Math.sign(pos2.lat - pos1.lat) &&
        Math.sign(pos3.lng - pos2.lng) !== Math.sign(pos2.lng - pos1.lng)
      ) {
        this.jitterCount++
        return this.jitterCount > 1
      }
    }

    // Reset jitter count if no jitter detected
    if (distance > this.jitterThreshold) {
      this.jitterCount = 0
    }

    return false
  }

  // Smooth heading values
  smoothHeading(newHeading) {
    if (newHeading === null || newHeading === undefined || isNaN(newHeading)) {
      return this.lastHeading
    }

    // Normalize to 0-360
    newHeading = ((newHeading % 360) + 360) % 360

    // Add to heading buffer
    this.headingBuffer.push(newHeading)
    while (this.headingBuffer.length > this.headingBufferSize) {
      this.headingBuffer.shift()
    }

    if (this.headingBuffer.length < 2) {
      return newHeading
    }

    // Use median filter to remove outliers
    if (this.headingBuffer.length >= 3) {
      const sortedHeadings = [...this.headingBuffer].sort((a, b) => a - b)
      const medianHeading = sortedHeadings[Math.floor(sortedHeadings.length / 2)]

      // If new heading is very different from median, it might be an outlier
      const headingDiff = Math.abs(((newHeading - medianHeading + 180) % 360) - 180)
      if (headingDiff > 45 && this.headingConfidence > 0.5) {
        // Use median instead of potentially erroneous new heading
        newHeading = medianHeading
      }
    }

    // If we have a previous heading, smooth the transition
    if (this.lastHeading !== null) {
      // Normalize headings to 0-360
      const normalizedCurrent = ((newHeading % 360) + 360) % 360
      const normalizedLast = ((this.lastHeading % 360) + 360) % 360

      // Calculate the smallest angle between the two headings
      let diff = normalizedCurrent - normalizedLast
      if (diff > 180) diff -= 360
      if (diff < -180) diff += 360

      // Apply adaptive smoothing based on motion and stationary state
      let headingWeight = this.headingSmoothingFactor
      if (this.stationaryMode) {
        headingWeight = 0.05 // Very smooth when stationary
      } else if (this.motionDetected) {
        headingWeight = Math.min(0.4, headingWeight * (1 + this.motionConfidence)) // More responsive when motion detected
      }

      // Apply smoothing
      const smoothedHeading = normalizedLast + diff * (1 - headingWeight)

      // Normalize back to 0-360
      return ((smoothedHeading % 360) + 360) % 360
    }

    return newHeading
  }

  // Smooth velocity values
  smoothVelocity(vx, vy) {
    const speed = Math.sqrt(vx * vx + vy * vy)

    this.velocityBuffer.push(speed)
    while (this.velocityBuffer.length > this.velocityBufferSize) {
      this.velocityBuffer.shift()
    }

    if (this.velocityBuffer.length < 2) {
      return { vx, vy }
    }

    // Calculate median velocity to filter outliers
    if (this.velocityBuffer.length >= 3) {
      const sortedVelocities = [...this.velocityBuffer].sort((a, b) => a - b)
      const medianVelocity = sortedVelocities[Math.floor(sortedVelocities.length / 2)]

      const currentVelocity = speed

      // If current velocity is drastically different from median, scale it
      if (currentVelocity > medianVelocity * 2) {
        const scale = (medianVelocity * 2) / currentVelocity
        vx *= scale
        vy *= scale
      }
    }

    return { vx, vy }
  }

  // Adjust process noise based on accuracy, motion, and device capabilities
  adjustProcessNoise(accuracy, motionDetected) {
    // Update accuracy buffer and check if accuracy is improving
    this.updateAccuracyBuffer(accuracy)

    // Update motion detection state
    this.motionDetected = motionDetected
    if (motionDetected) {
      this.motionConfidence = Math.min(1.0, this.motionConfidence + 0.1)
    } else {
      this.motionConfidence = Math.max(0.0, this.motionConfidence - 0.05)
    }

    // Base noise level depends on GPS accuracy
    let noiseLevel =
      this.adaptiveNoiseMin + (this.adaptiveNoiseMax - this.adaptiveNoiseMin) * Math.min(1.0, accuracy / 30.0)

    // Reduce noise when stationary
    if (this.stationaryMode) {
      noiseLevel *= 0.03
    }

    // Increase noise when motion is detected
    if (this.motionDetected && !this.stationaryMode) {
      noiseLevel *= 1.0 + this.motionConfidence
    }

    // Adjust based on accuracy trend
    if (this.isAccuracyImproving) {
      noiseLevel *= 0.9
    } else {
      noiseLevel *= 1.1
    }

    // Apply adaptive factor
    noiseLevel *= this.adaptiveNoiseFactor

    // Set process noise
    this.Q = noiseLevel

    return this
  }

  // Update the filter with new measurement
  update(position, motionDetected = false) {
    if (!this.initialized) {
      this.reset(position)
      return position
    }

    if (!position || typeof position.lat !== "number" || typeof position.lng !== "number") {
      console.warn("Invalid position input to Kalman filter")
      return {
        lat: this.y,
        lng: this.x,
        accuracy: position?.accuracy || 20,
        heading: this.lastHeading,
        timestamp: position?.timestamp || Date.now(),
      }
    }

    // If we're in stationary mode and have a locked position, return the locked position
    if (this.stationaryMode && this.stationaryLocked && this.stationaryPosition) {
      return {
        lat: this.stationaryPosition.lat,
        lng: this.stationaryPosition.lng,
        accuracy: position.accuracy,
        heading: this.smoothHeading(position.heading),
        timestamp: position.timestamp,
        speedMPS: 0,
      }
    }

    // Calculate time delta
    const timestamp = position.timestamp || Date.now()
    if (this.lastTimestamp) {
      this.dt = Math.min(Math.max((timestamp - this.lastTimestamp) / 1000, 0.01), 1.0)
    }
    this.lastTimestamp = timestamp

    // Check for jitter
    const isJittering = this.detectJitter(position)

    // Adjust measurement noise based on GPS accuracy and jitter
    const accuracy = position.accuracy || 20
    this.R = Math.max(KALMAN_MEASUREMENT_NOISE_BASE, accuracy / 5)

    // If in stationary mode, increase measurement noise to reduce jitter
    if (this.stationaryMode) {
      this.R *= 5.0
    }

    // If jittering is detected, increase measurement noise significantly
    if (isJittering) {
      this.R *= 10.0
    }

    // Adjust process noise based on accuracy and motion
    this.adjustProcessNoise(accuracy, motionDetected)

    // State transition matrix
    const F = [
      [1, 0, this.dt, 0],
      [0, 1, 0, this.dt],
      [0, 0, 1, 0],
      [0, 0, 0, 1],
    ]

    // Predict step
    // x = F * x
    const predictedX = this.x + this.dt * this.vx
    const predictedY = this.y + this.dt * this.vy
    const predictedVx = this.stationaryMode ? 0 : this.vx
    const predictedVy = this.stationaryMode ? 0 : this.vy

    // P = F * P * F' + Q
    const Q = [
      [(this.Q * this.dt * this.dt * this.dt * this.dt) / 4, 0, (this.Q * this.dt * this.dt * this.dt) / 2, 0],
      [0, (this.Q * this.dt * this.dt * this.dt * this.dt) / 4, 0, (this.Q * this.dt * this.dt * this.dt) / 2],
      [(this.Q * this.dt * this.dt * this.dt) / 2, 0, this.Q * this.dt * this.dt, 0],
      [0, (this.Q * this.dt * this.dt * this.dt) / 2, 0, this.Q * this.dt * this.dt],
    ]

    // Matrix multiplication F * P
    const FP = [
      [
        this.P[0][0] + this.dt * this.P[2][0],
        this.P[0][1] + this.dt * this.P[2][1],
        this.P[0][2] + this.dt * this.P[2][2],
        this.P[0][3] + this.dt * this.P[2][3],
      ],
      [
        this.P[1][0] + this.dt * this.P[3][0],
        this.P[1][1] + this.dt * this.P[3][1],
        this.P[1][2] + this.dt * this.P[3][2],
        this.P[1][3] + this.dt * this.P[3][3],
      ],
      [this.P[2][0], this.P[2][1], this.P[2][2], this.P[2][3]],
      [this.P[3][0], this.P[3][1], this.P[3][2], this.P[3][3]],
    ]

    // Matrix multiplication FP * F'
    const predictedP = [
      [
        FP[0][0] + this.dt * FP[0][2] + Q[0][0],
        FP[0][1] + this.dt * FP[0][3] + Q[0][1],
        FP[0][2] + Q[0][2],
        FP[0][3] + Q[0][3],
      ],
      [
        FP[1][0] + this.dt * FP[1][2] + Q[1][0],
        FP[1][1] + this.dt * FP[1][3] + Q[1][1],
        FP[1][2] + Q[1][2],
        FP[1][3] + Q[1][3],
      ],
      [FP[2][0] + Q[2][0], FP[2][1] + Q[2][1], FP[2][2] + Q[2][2], FP[2][3] + Q[2][3]],
      [FP[3][0] + Q[3][0], FP[3][1] + Q[3][1], FP[3][2] + Q[3][2], FP[3][3] + Q[3][3]],
    ]

    // Update step
    // y = z - H * x
    const measurementResidualX = position.lng - predictedX
    const measurementResidualY = position.lat - predictedY

    // Track innovation to detect filter divergence
    const innovation = Math.sqrt(
      measurementResidualX * measurementResidualX + measurementResidualY * measurementResidualY,
    )
    this.updateInnovationBuffer(innovation)

    // S = H * P * H' + R
    const S = [
      [predictedP[0][0] + this.R, predictedP[0][1]],
      [predictedP[1][0], predictedP[1][1] + this.R],
    ]

    // Calculate determinant of S
    const detS = S[0][0] * S[1][1] - S[0][1] * S[1][0]

    // Calculate inverse of S
    const invS = [
      [S[1][1] / detS, -S[0][1] / detS],
      [-S[1][0] / detS, S[0][0] / detS],
    ]

    // K = P * H' * inv(S)
    const K = [
      [
        predictedP[0][0] * invS[0][0] + predictedP[0][1] * invS[1][0],
        predictedP[0][0] * invS[0][1] + predictedP[0][1] * invS[1][1],
      ],
      [
        predictedP[1][0] * invS[0][0] + predictedP[1][1] * invS[1][0],
        predictedP[1][0] * invS[0][1] + predictedP[1][1] * invS[1][1],
      ],
      [
        predictedP[2][0] * invS[0][0] + predictedP[2][1] * invS[1][0],
        predictedP[2][0] * invS[0][1] + predictedP[2][1] * invS[1][1],
      ],
      [
        predictedP[3][0] * invS[0][0] + predictedP[3][1] * invS[1][0],
        predictedP[3][0] * invS[0][1] + predictedP[3][1] * invS[1][1],
      ],
    ]

    // x = x + K * y
    this.x = predictedX + K[0][0] * measurementResidualX + K[0][1] * measurementResidualY
    this.y = predictedY + K[1][0] * measurementResidualX + K[1][1] * measurementResidualY

    // In stationary mode, keep velocity at zero
    if (this.stationaryMode) {
      this.vx = 0
      this.vy = 0
    } else {
      this.vx = predictedVx + K[2][0] * measurementResidualX + K[2][1] * measurementResidualY
      this.vy = predictedVy + K[3][0] * measurementResidualX + K[3][1] * measurementResidualY

      // Smooth velocity
      const smoothedVelocity = this.smoothVelocity(this.vx, this.vy)
      this.vx = smoothedVelocity.vx
      this.vy = smoothedVelocity.vy
    }

    // P = (I - K * H) * P
    this.P = [
      [
        predictedP[0][0] - (K[0][0] * predictedP[0][0] + K[0][1] * predictedP[1][0]),
        predictedP[0][1] - (K[0][0] * predictedP[0][1] + K[0][1] * predictedP[1][1]),
        predictedP[0][2] - (K[0][0] * predictedP[0][2] + K[0][1] * predictedP[1][2]),
        predictedP[0][3] - (K[0][0] * predictedP[0][3] + K[0][1] * predictedP[1][3]),
      ],
      [
        predictedP[1][0] - (K[1][0] * predictedP[0][0] + K[1][1] * predictedP[1][0]),
        predictedP[1][1] - (K[1][0] * predictedP[0][1] + K[1][1] * predictedP[1][1]),
        predictedP[1][2] - (K[1][0] * predictedP[0][2] + K[1][1] * predictedP[1][2]),
        predictedP[1][3] - (K[1][0] * predictedP[0][3] + K[1][1] * predictedP[1][3]),
      ],
      [
        predictedP[2][0] - (K[2][0] * predictedP[0][0] + K[2][1] * predictedP[1][0]),
        predictedP[2][1] - (K[2][0] * predictedP[0][1] + K[2][1] * predictedP[1][1]),
        predictedP[2][2] - (K[2][0] * predictedP[0][2] + K[2][1] * predictedP[1][2]),
        predictedP[2][3] - (K[2][0] * predictedP[0][3] + K[2][1] * predictedP[1][3]),
      ],
      [
        predictedP[3][0] - (K[3][0] * predictedP[0][0] + K[3][1] * predictedP[1][0]),
        predictedP[3][1] - (K[3][0] * predictedP[0][1] + K[3][1] * predictedP[1][1]),
        predictedP[3][2] - (K[3][0] * predictedP[0][2] + K[3][1] * predictedP[1][2]),
        predictedP[3][3] - (K[3][0] * predictedP[0][3] + K[3][1] * predictedP[1][3]),
      ],
    ]

    // Process heading data
    const smoothedHeading = this.smoothHeading(position.heading)
    this.lastHeading = smoothedHeading

    // Calculate speed from velocity components
    const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy)

    // Create filtered position
    const filteredPosition = {
      lat: this.y,
      lng: this.x,
      accuracy: position.accuracy,
      heading: smoothedHeading,
      timestamp: position.timestamp,
      speedMPS: this.stationaryMode ? 0 : speed * 111000, // Convert from degrees/second to meters/second (approximate)
    }

    // If we're in stationary mode and don't have a locked position yet,
    // check if we should lock the position
    if (this.stationaryMode && !this.stationaryLocked && this.stationaryStartTime) {
      // If we've been stationary for a while, lock the position
      if (Date.now() - this.stationaryStartTime > 2000) {
        this.lockStationaryPosition(filteredPosition)
      }
    }

    return filteredPosition
  }
}

// Position interpolator for smooth transitions
class PositionInterpolator {
  constructor() {
    this.startPosition = null
    this.targetPosition = null
    this.startTime = null
    this.duration = 0
    this.isActive = false
    this.lastInterpolatedPosition = null
    this.interpolationMethod = "cubic" // "cubic", "linear", "spring"
    this.springParams = {
      stiffness: 100,
      damping: 10,
      mass: 1,
    }
  }

  setInterpolationMethod(method, params = {}) {
    this.interpolationMethod = method

    if (method === "spring" && params) {
      this.springParams.stiffness = params.stiffness || 100
      this.springParams.damping = params.damping || 10
      this.springParams.mass = params.mass || 1
    }

    return this
  }

  start(startPos, targetPos, duration) {
    if (!startPos || !targetPos) return this

    this.startPosition = { ...startPos }
    this.targetPosition = { ...targetPos }
    this.startTime = performance.now()
    this.duration = duration
    this.isActive = true

    // For spring animation, we need initial velocity
    if (this.interpolationMethod === "spring") {
      this.velocity = {
        lat: 0,
        lng: 0,
      }
      this.lastUpdateTime = this.startTime
    }

    return this
  }

  update() {
    if (!this.isActive) return null

    const now = performance.now()
    const elapsed = now - this.startTime

    if (elapsed >= this.duration && this.interpolationMethod !== "spring") {
      this.isActive = false
      this.lastInterpolatedPosition = { ...this.targetPosition }
      return this.targetPosition
    }

    let interpolatedPosition

    switch (this.interpolationMethod) {
      case "linear":
        interpolatedPosition = this.linearInterpolation(elapsed / this.duration)
        break
      case "spring":
        interpolatedPosition = this.springInterpolation(now)
        // Check if spring has settled
        const distToTarget = calculateDistance(interpolatedPosition, this.targetPosition)
        if (distToTarget < 0.1 && Math.abs(this.velocity.lat) < 0.0001 && Math.abs(this.velocity.lng) < 0.0001) {
          this.isActive = false
        }
        break
      case "cubic":
      default:
        interpolatedPosition = this.cubicInterpolation(elapsed / this.duration)
        break
    }

    this.lastInterpolatedPosition = interpolatedPosition
    return interpolatedPosition
  }

  // Linear interpolation
  linearInterpolation(t) {
    // Clamp t between 0 and 1
    t = Math.max(0, Math.min(1, t))

    return {
      lat: this.startPosition.lat + (this.targetPosition.lat - this.startPosition.lat) * t,
      lng: this.startPosition.lng + (this.targetPosition.lng - this.startPosition.lng) * t,
      accuracy: this.targetPosition.accuracy,
      heading: this.targetPosition.heading,
      timestamp: performance.now(),
      speedMPS: this.targetPosition.speedMPS,
    }
  }

  // Cubic easing function for smoother motion
  cubicInterpolation(t) {
    // Clamp t between 0 and 1
    t = Math.max(0, Math.min(1, t))

    // Apply easing
    const easedT = this.easeOutCubic(t)

    return {
      lat: this.startPosition.lat + (this.targetPosition.lat - this.startPosition.lat) * easedT,
      lng: this.startPosition.lng + (this.targetPosition.lng - this.startPosition.lng) * easedT,
      accuracy: this.targetPosition.accuracy,
      heading: this.interpolateHeading(this.startPosition.heading, this.targetPosition.heading, easedT),
      timestamp: performance.now(),
      speedMPS: this.targetPosition.speedMPS,
    }
  }

  // Spring-based physics interpolation
  springInterpolation(now) {
    const dt = (now - this.lastUpdateTime) / 1000 // Convert to seconds
    this.lastUpdateTime = now

    // Spring physics parameters
    const k = this.springParams.stiffness
    const b = this.springParams.damping
    const m = this.springParams.mass

    // Calculate spring force for latitude and longitude
    const forceLatSpring = -k * (this.lastInterpolatedPosition.lat - this.targetPosition.lat)
    const forceLngSpring = -k * (this.lastInterpolatedPosition.lng - this.targetPosition.lng)

    // Calculate damping force
    const forceLatDamping = -b * this.velocity.lat
    const forceLngDamping = -b * this.velocity.lng

    // Calculate total force
    const totalForceLat = forceLatSpring + forceLatDamping
    const totalForceLng = forceLngSpring + forceLngDamping

    // Calculate acceleration (F = ma, so a = F/m)
    const accLat = totalForceLat / m
    const accLng = totalForceLng / m

    // Update velocity (v = v0 + a*t)
    this.velocity.lat += accLat * dt
    this.velocity.lng += accLng * dt

    // Update position (x = x0 + v*t)
    const newLat = this.lastInterpolatedPosition.lat + this.velocity.lat * dt
    const newLng = this.lastInterpolatedPosition.lng + this.velocity.lng * dt

    return {
      lat: newLat,
      lng: newLng,
      accuracy: this.targetPosition.accuracy,
      heading: this.interpolateHeading(this.lastInterpolatedPosition.heading, this.targetPosition.heading, 0.1),
      timestamp: now,
      speedMPS: this.targetPosition.speedMPS,
    }
  }

  // Interpolate heading (special case due to circular nature)
  interpolateHeading(startHeading, endHeading, t) {
    if (startHeading === null || endHeading === null) {
      return endHeading
    }

    // Normalize headings to 0-360
    startHeading = ((startHeading % 360) + 360) % 360
    endHeading = ((endHeading % 360) + 360) % 360

    // Find the shortest path around the circle
    let diff = endHeading - startHeading
    if (diff > 180) diff -= 360
    if (diff < -180) diff += 360

    // Interpolate
    const result = (startHeading + diff * t) % 360
    return result < 0 ? result + 360 : result
  }

  // Cubic easing function
  easeOutCubic(t) {
    return 1 - Math.pow(1 - t, 3)
  }

  // Smoother Hermite easing function with configurable smoothness
  easeHermite(t, smoothness = 0) {
    // Clamp t between 0 and 1
    t = Math.max(0, Math.min(1, t))

    // Apply Hermite interpolation with smoothness parameter
    return t * t * (3 - 2 * t - smoothness * (t - 1) * t)
  }

  isInterpolating() {
    return this.isActive
  }

  cancel() {
    this.isActive = false
    return this
  }

  getLastPosition() {
    return this.lastInterpolatedPosition || this.targetPosition || this.startPosition
  }
}

// Adaptive Kalman Filter Factory
class AdaptiveKalmanFilterFactory {
  static createForDevice(deviceInfo) {
    const filter = new KalmanFilter()

    // Configure based on device type and capabilities
    if (deviceInfo) {
      // Set device capabilities
      filter.setDeviceCapabilities(
        deviceInfo.highAccuracySupported || true,
        deviceInfo.motionSensorsAvailable || true,
        deviceInfo.orientationSensorsAvailable || true,
      )

      // Set receiver type based on device
      if (deviceInfo.gnssType) {
        filter.setReceiverType(deviceInfo.gnssType)
      }

      // Set environment type if known
      if (deviceInfo.environment) {
        filter.setEnvironmentType(deviceInfo.environment)
      }
    }

    return filter
  }

  static createFilterAndInterpolator(deviceInfo, interpolationMethod = "cubic") {
    const filter = this.createForDevice(deviceInfo)
    const interpolator = new PositionInterpolator().setInterpolationMethod(interpolationMethod)

    return {
      filter,
      interpolator,

      // Convenience method to update and interpolate in one step
      update(position, motionDetected = false, interpolationDuration = 300) {
        // First update the filter
        const filteredPosition = filter.update(position, motionDetected)

        // Then start interpolation to the new filtered position
        if (!interpolator.isInterpolating()) {
          const startPos = interpolator.getLastPosition() || position
          interpolator.start(startPos, filteredPosition, interpolationDuration)
        } else {
          // Update target while keeping the interpolation
          interpolator.targetPosition = filteredPosition
        }

        // Return the current interpolated position
        return interpolator.update() || filteredPosition
      },
    }
  }
}

// DOM update manager - batch DOM updates for better performance
const domUpdateManager = {
  updates: new Map(),
  scheduled: false,

  // Schedule a DOM update
  schedule(id, updateFn) {
    this.updates.set(id, updateFn)

    if (!this.scheduled) {
      this.scheduled = true
      requestAnimationFrame(() => this.flush())
    }
  },

  // Flush all scheduled DOM updates
  flush() {
    this.updates.forEach((updateFn) => updateFn())
    this.updates.clear()
    this.scheduled = false
  },
}

// Create tracking system with optimized filter and interpolator
const tracking = AdaptiveKalmanFilterFactory.createFilterAndInterpolator(
  {
    highAccuracySupported: true,
    motionSensorsAvailable: true,
    orientationSensorsAvailable: true,
    gnssType: "GPS_GLONASS",
    environment: "urban",
  },
  "cubic",
)

// Calculate appropriate zoom level based on speed with device movement filtering
function calculateZoomLevel(speedMPS) {
  // Use existing global variables without defining new ones
  const now = Date.now();
  
  // Update current speed for global access
  currentSpeed = speedMPS;
  
  // Check if this is genuine GPS movement or potential device movement
  const isGenuineMovement = lastPosition?.hasOwnProperty('speedAccuracy') && 
                           lastPosition.speedAccuracy < SPEED_ACCURACY_THRESHOLD;
  
  // Detect shake patterns using available data without storing history
  let isShaking = false;
  
  // Simple shake detection based on available data
  if (lastPosition && currentPosition && lastPosition.coords && currentPosition.coords) {
    // Check for rapid direction changes if available
    if (lastPosition.coords.heading && currentPosition.coords.heading) {
      const headingDiff = Math.abs(((currentPosition.coords.heading - lastPosition.coords.heading + 540) % 360) - 180);
      // Large heading change in short time may indicate shaking
      if (headingDiff > 90 && (now - lastPosition.timestamp) < 1000) {
        isShaking = true;
      }
    }
    
    // Check for unrealistic speed fluctuations
    if (lastPosition.speedMPS && Math.abs(speedMPS - lastPosition.speedMPS) > 3 && 
        (now - lastPosition.timestamp) < 1000) {
      isShaking = true;
    }
    
    // Check if reported distance implies unrealistic movement pattern
    const timeDelta = now - lastPosition.timestamp;
    if (timeDelta > 0 && timeDelta < 1000) {
      const distanceDelta = calculateDistance(
        {lat: lastPosition.coords.latitude, lng: lastPosition.coords.longitude},
        {lat: currentPosition.coords.latitude, lng: currentPosition.coords.longitude}
      );
      
      // If short erratic movements or physically impossible acceleration
      if ((distanceDelta < 1 && speedMPS > 2) || 
          (lastPosition.speedMPS && (speedMPS - lastPosition.speedMPS) / (timeDelta/1000) > 5)) {
        isShaking = true;
      }
    }
  }
  
  // Use a more conservative speed estimate for non-GPS-confirmed movement or shaking
  const reliableSpeed = (isGenuineMovement && !isShaking) ? speedMPS : Math.min(speedMPS, 1.0);
  
  // Determine target zoom level based on reliable speed
  let targetZoomLevel;
  
  if (isStationary || reliableSpeed < 0.5) {
    // Stationary or very slow movement
    targetZoomLevel = MAX_ZOOM_LEVEL;
  } else if (reliableSpeed < WALKING_SPEED_THRESHOLD) {
    // Walking speed
    targetZoomLevel = WALKING_ZOOM_LEVEL;
  } else if (reliableSpeed < RUNNING_SPEED_THRESHOLD) {
    // Running speed - linear interpolation between walking and running zoom levels
    const t = (reliableSpeed - WALKING_SPEED_THRESHOLD) / (RUNNING_SPEED_THRESHOLD - WALKING_SPEED_THRESHOLD);
    targetZoomLevel = WALKING_ZOOM_LEVEL - t;
  } else if (reliableSpeed < DRIVING_SPEED_THRESHOLD) {
    // Driving speed - linear interpolation between running and driving zoom levels
    const t = (reliableSpeed - RUNNING_SPEED_THRESHOLD) / (DRIVING_SPEED_THRESHOLD - RUNNING_SPEED_THRESHOLD);
    targetZoomLevel = WALKING_ZOOM_LEVEL - 1 - t;
  } else {
    // High speed
    targetZoomLevel = MIN_ZOOM_LEVEL;
  }
  
  // For non-GPS-confirmed movement or shaking, be conservative with zoom changes
  let smoothingFactor = (isGenuineMovement && !isShaking) ? 0.15 : 0.05;
  
  // Adjust smoothing based on GPS confidence and speed changes
  if (isGenuineMovement && !isShaking) {
    const speedChange = lastPosition ? Math.abs(speedMPS - lastPosition.speedMPS) : 0;
    const significantSpeedChange = speedChange > 1.0;
    
    // More responsive when speed changes significantly
    if (significantSpeedChange) {
      smoothingFactor = 0.3;
    }
  }
  
  // Smooth zoom level changes
  let zoomLevel = targetZoomLevel;
  if (lastZoomLevel !== null) {
    zoomLevel = lastZoomLevel * (1 - smoothingFactor) + targetZoomLevel * smoothingFactor;
  }
  
  // Add time-based throttling for zoom changes
  if (lastZoomChangeTime && (now - lastZoomChangeTime < 700)) {
    // Too soon for another zoom change, return last zoom level
    return lastZoomLevel || targetZoomLevel;
  }
  
  // Ensure more immediate response for significant genuine GPS speed transitions
  if (isGenuineMovement && !isShaking && 
      ((isStationary && speedMPS > 1.0) || (!isStationary && speedMPS < 0.5))) {
    zoomLevel = lastZoomLevel * 0.6 + targetZoomLevel * 0.4;
  }
  
  // Only register a zoom change if it's significantly different
  const isSignificantChange = lastZoomLevel === null || Math.abs(zoomLevel - lastZoomLevel) >= 0.3;
  
  if (isSignificantChange) {
    lastZoomChangeTime = now;
    
    // Round to one decimal place for smoother transitions
    zoomLevel = Math.round(zoomLevel * 10) / 10;
  } else {
    // Not enough change to warrant updating zoom
    zoomLevel = lastZoomLevel;
  }
  
  // Clamp to valid zoom range
  zoomLevel = Math.max(MIN_ZOOM_LEVEL, Math.min(MAX_ZOOM_LEVEL, zoomLevel));
  
  // Don't override proximity zooming when near markers
  if (isNearLocation) {
    zoomLevel = 18;
  }
  
  // Update last zoom level
  lastZoomLevel = zoomLevel;
  
  return zoomLevel;
}
        
// Enhanced stationary position calculation
function calculateStationaryPosition(buffer) {
  if (!buffer || buffer.length === 0) {
    return null
  }

  // Sort by accuracy (best first)
  const sortedBuffer = [...buffer].sort((a, b) => a.accuracy - b.accuracy)

  // Take weighted average of best positions
  const topPositions = sortedBuffer.slice(0, Math.ceil(buffer.length / 2))

  const weights = topPositions.map((pos) => 1 / Math.max(1, pos.accuracy))
  const totalWeight = weights.reduce((sum, w) => sum + w, 0)

  if (totalWeight === 0) {
    return sortedBuffer[0]
  }

  // Calculate weighted average
  const avgPosition = {
    lat: topPositions.reduce((sum, pos, i) => sum + pos.lat * weights[i], 0) / totalWeight,
    lng: topPositions.reduce((sum, pos, i) => sum + pos.lng * weights[i], 0) / totalWeight,
    accuracy: topPositions[0].accuracy,
    heading: topPositions[0].heading,
    timestamp: Date.now(),
    speedMPS: 0,
  }

  // If we have a previous stationary position, blend with it for stability
  if (lastStationaryPosition) {
    const blendFactor = 0.9 // Reduced to 90% previous, 10% new for more responsive updates
    return {
      lat: lastStationaryPosition.lat * blendFactor + avgPosition.lat * (1 - blendFactor),
      lng: lastStationaryPosition.lng * blendFactor + avgPosition.lng * (1 - blendFactor),
      accuracy: avgPosition.accuracy,
      heading: avgPosition.heading,
      timestamp: avgPosition.timestamp,
      speedMPS: 0,
    }
  }

  return avgPosition
}

function updateStationaryHistory(position) {
  // Add new position to history
  stationaryPositionHistory.push(position)
  // Keep history at maximum size
  while (stationaryPositionHistory.length > STATIONARY_POSITION_HISTORY_SIZE) {
    stationaryPositionHistory.shift()
  }
  
  // Handle empty history case (shouldn't happen, but just in case)
  if (stationaryPositionHistory.length === 0) {
    return { ...position, speedMPS: 0 };
  }
  
  // Calculate weighted average of positions
  let totalWeight = 0
  let weightedLat = 0
  let weightedLng = 0
  // Newer positions have higher weight
  for (let i = 0; i < stationaryPositionHistory.length; i++) {
    const pos = stationaryPositionHistory[i]
    const weight = Math.pow(STATIONARY_POSITION_WEIGHT_DECAY, stationaryPositionHistory.length - i - 1)
    totalWeight += weight
    weightedLat += pos.lat * weight
    weightedLng += pos.lng * weight
  }
  
  return {
    lat: weightedLat / totalWeight,
    lng: weightedLng / totalWeight,
    accuracy: position.accuracy,
    heading: position.heading,
    timestamp: position.timestamp,
    speedMPS: 0,
  }
}

// Check if device is in motion based on motion sensors
function isDeviceInMotion() {
  if (!motionSamples || motionSamples.length < 3) {
    return false
  }

  // Calculate average motion magnitude
  const avgMotion = motionSamples.reduce((sum, sample) => {
    return sum + Math.sqrt(sample.x * sample.x + sample.y * sample.y + sample.z * sample.z)
  }, 0) / motionSamples.length

  return avgMotion > MOTION_THRESHOLD
}

// Process device motion data
function handleDeviceMotion(event) {
  if (!event || !event.acceleration) return

  const motion = {
    x: event.acceleration.x || 0,
    y: event.acceleration.y || 0,
    z: event.acceleration.z || 0,
    timestamp: Date.now(),
  }

  // Add to motion samples
  motionSamples.push(motion)

  // Keep only recent samples
  while (motionSamples.length > MOTION_SAMPLE_SIZE) {
    motionSamples.shift()
  }

  // Update device motion state
  deviceMotion = motion

  // Check if device is stationary based on motion
  const inMotion = isDeviceInMotion()

  if (!inMotion) {
    deviceStationaryTime += MOTION_CHECK_INTERVAL
  } else {
    deviceStationaryTime = 0
  }
}

// Process device orientation data
function handleDeviceOrientation(event) {
  if (!event || event.alpha === null) return

  deviceOrientation = {
    alpha: event.alpha, // z-axis rotation [0,360)
    beta: event.beta, // x-axis rotation [-180,180)
    gamma: event.gamma, // y-axis rotation [-90,90)
    timestamp: Date.now(),
  }

  // Update heading buffer if we have a compass heading
  if (event.webkitCompassHeading !== undefined) {
    const heading = event.webkitCompassHeading

    // Add to heading buffer
    headingBuffer.push(heading)

    // Keep only recent headings
    while (headingBuffer.length > 5) {
      headingBuffer.shift()
    }

    // Calculate median heading to filter outliers
    if (headingBuffer.length >= 3) {
      const sortedHeadings = [...headingBuffer].sort((a, b) => a - b)
      lastHeadingValue = sortedHeadings[Math.floor(sortedHeadings.length / 2)]
    }
  }
}

// Request device motion and orientation permissions
function requestMotionPermission() {
  if (typeof DeviceMotionEvent !== "undefined" && typeof DeviceMotionEvent.requestPermission === "function") {
    DeviceMotionEvent.requestPermission()
      .then((response) => {
        if (response === "granted") {
          window.addEventListener("devicemotion", handleDeviceMotion, true)
        }
      })
      .catch(console.error)
  } else {
    window.addEventListener("devicemotion", handleDeviceMotion, true)
  }

  if (typeof DeviceOrientationEvent !== "undefined" && typeof DeviceOrientationEvent.requestPermission === "function") {
    DeviceOrientationEvent.requestPermission()
      .then((response) => {
        if (response === "granted") {
          orientationPermissionGranted = true
          window.addEventListener("deviceorientation", handleDeviceOrientation, true)
        }
      })
      .catch(console.error)
  } else {
    window.addEventListener("deviceorientation", handleDeviceOrientation, true)
    orientationPermissionGranted = true
  }
}

// Image preloading function
function preloadImages(locations) {
  return new Promise((resolve) => {
    if (!locations || locations.length === 0) {
      resolve()
      return
    }

    const totalImages = locations.length
    let loadedImages = 0
    const progressBar = document.getElementById("preloaderProgress")

    locations.forEach((location, index) => {
      if (!location.image) {
        loadedImages++
        updateProgress()
        if (loadedImages === totalImages) resolve()
        return
      }

      // Skip if already preloaded
      if (preloadedImages.has(location.image)) {
        loadedImages++
        updateProgress()
        if (loadedImages === totalImages) resolve()
        return
      }

      const img = new Image()
      img.crossOrigin = "anonymous" // Set crossOrigin for canvas operations
      img.onload = () => {
        preloadedImages.set(location.image, img)
        loadedImages++
        updateProgress()
        if (loadedImages === totalImages) resolve()
      }

      img.onerror = () => {
        console.warn(`Failed to load image: ${location.image}`)
        loadedImages++
        updateProgress()
        if (loadedImages === totalImages) resolve()
      }

      img.src = location.image
    })

    // Also preload audio files
    locations.forEach((location) => {
      if (location.audio && !preloadedAudio.has(location.audio)) {
        const audio = new Audio()
        audio.preload = "auto"
        audio.oncanplaythrough = () => {
          preloadedAudio.set(location.audio, audio)
        }
        audio.src = location.audio
      }
    })

    function updateProgress() {
      const percent = (loadedImages / totalImages) * 100
      domUpdateManager.schedule("preloaderProgress", () => {
        if (progressBar) {
          progressBar.style.width = `${percent}%`
        }
      })
    }
  })
}

// Detect sudden movements or position jumps
function detectSuddenMovement(newPosition, lastPosition) {
  if (!lastPosition || !newPosition) return false

  const distance = calculateDistance(lastPosition, newPosition)
  const timeDelta = (newPosition.timestamp - lastPosition.timestamp) / 1000 // seconds

  // If time delta is too small, consider it a valid update
  if (timeDelta < 0.05) return false

  // Calculate speed in meters per second
  const speed = distance / timeDelta

  // Check for unrealistic speeds (teleportation)
  if (speed > 40) {
    // Reduced from 50 to 40 m/s for more sensitive jump detection
    console.log(`Position jump detected: ${distance.toFixed(2)}m in ${timeDelta.toFixed(2)}s (${speed.toFixed(2)} m/s)`)
    return true
  }

  // Check for sudden movements when stationary
  if (isStationary && distance > POSITION_JUMP_THRESHOLD) {
    console.log(`Sudden movement detected while stationary: ${distance.toFixed(2)}m`)
    return true
  }

  // Check for small sudden movements (jitter)
  if (isStationary && distance > SUDDEN_MOVEMENT_THRESHOLD) {
    suddenMovementCount++
    if (suddenMovementCount >= 2) {
      console.log(`Multiple sudden movements detected: ${distance.toFixed(2)}m`)
      return true
    }
  } else {
    suddenMovementCount = 0
  }

  return false
}

// Check proximity to locations and adjust zoom accordingly
function checkLocationProximity() {
    const now = Date.now();
    
    // Don't check too frequently
    if (now - lastProximityCheck < 1000) return;
    lastProximityCheck = now;
    
    // Don't check if zoom was recently changed
    if (now - lastZoomChangeTime < ZOOM_CHANGE_COOLDOWN) return;
    
    if (!userMarker || !gameLocations || gameLocations.length === 0) return;
    
    const userLatLng = userMarker.getLatLng();
    
    // Validate user coordinates
    if (!userLatLng || typeof userLatLng.lat !== 'number' || typeof userLatLng.lng !== 'number' || 
        isNaN(userLatLng.lat) || isNaN(userLatLng.lng)) {
        console.warn("Invalid user coordinates for proximity check");
        return;
    }
    
    const userPos = { lat: userLatLng.lat, lng: userLatLng.lng };
    
    // Find closest location
    let closestDistance = Infinity;
    let closestLocation = null;
    
    for (const location of gameLocations) {
        if (!location || typeof location.lat !== 'number' || typeof location.lng !== 'number' || 
            isNaN(location.lat) || isNaN(location.lng)) {
            continue;
        }
        
        const locationPos = { lat: location.lat, lng: location.lng };
        const distance = calculateDistance(userPos, locationPos);
        
        if (isFinite(distance) && distance < closestDistance) {
            closestDistance = distance;
            closestLocation = location;
        }
    }
    
    // If no valid locations found, exit
    if (!closestLocation || !isFinite(closestDistance)) {
        return;
    }
    
    // Convert to feet for threshold comparison
    const distanceFeet = Math.round(closestDistance * 3.28084);
    
    // Constants for hysteresis and thresholds to prevent rapid toggling
    const ZOOM_IN_THRESHOLD = PROXIMITY_THRESHOLD; 
    const ZOOM_OUT_THRESHOLD = PROXIMITY_THRESHOLD * 1.1; // 10% buffer when moving away
    
    // Get current zoom level
    const currentZoom = map.getZoom();
    
    // Check if we need to adjust zoom based on proximity
    if (distanceFeet <= ZOOM_IN_THRESHOLD) {
        // If we're near a location and zoom is not 18, zoom in to 18
        if (currentZoom !== 18) {
            console.log(`User is within ${ZOOM_IN_THRESHOLD.toFixed(1)} feet of a location, zooming to level 18`);
            isNearLocation = true;
            lastZoomChangeTime = now;
            
            // Apply zoom change with smooth animation
            map.setZoom(18, {
                animate: true,
                duration: ZOOM_TRANSITION_DURATION
            });
        }
    } else if (distanceFeet >= ZOOM_OUT_THRESHOLD) {
        // If we're not near a location and zoom is not 17, zoom out to 17
        if (currentZoom !== 17 && isNearLocation) {
            console.log(`User is now outside ${ZOOM_OUT_THRESHOLD.toFixed(1)} feet of a location, zooming to level 17`);
            isNearLocation = false;
            lastZoomChangeTime = now;
            
            // Apply zoom change with smooth animation
            map.setZoom(17, {
                animate: true,
                duration: ZOOM_TRANSITION_DURATION
            });
        }
    }
    
    // Update last proximity distance
    lastProximityDistance = closestDistance;
}
        
function initMap() {
  // L variable was undeclared. Please fix the import or declare the variable before using it.
  // Declaring L here
  const L = window.L

  map = L.map("map", {
    zoomControl: false,
    attributionControl: false,
    zoomSnap: 0.1,
    zoomDelta: 0.5,
    wheelDebounceTime: 100,
    tapTolerance: 15,
    bounceAtZoomLimits: false,
    preferCanvas: true, // Use canvas renderer for better performance
    renderer: L.canvas({ padding: 0.5 }),
  }).fitWorld()

  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    maxZoom: 18,
    attribution: "© OpenStreetMap contributors",
    updateWhenIdle: true,
    updateWhenZooming: false,
    keepBuffer: 2,
  }).addTo(map)

  markerClusterGroup = L.markerClusterGroup({
    showCoverageOnHover: false,
    zoomToBoundsOnClick: true,
    spiderfyOnMaxZoom: true,
    animate: true,
    animateAddingMarkers: true,
    disableClusteringAtZoom: 17,
    maxClusterRadius: 60,
    iconCreateFunction: (cluster) =>
      L.divIcon({
        html: "<div><span>" + cluster.getChildCount() + "</span></div>",
        className: "marker-cluster-custom",
        iconSize: L.point(40, 40),
      }),
  })
  map.addLayer(markerClusterGroup)

    // Create user icon with custom styling (red)
    const userIcon = L.divIcon({
        className: 'user-marker',
        html: '<div class="user-marker-icon"></div>',
        iconSize: [20, 20],
        iconAnchor: [10, 10]
    });
    userMarker = L.marker([0, 0], { 
        icon: userIcon,
        zIndexOffset: 1000, // Ensure user marker is on top
        interactive: false // Prevent marker from being clickable
    }).addTo(map);

  // Store map viewport dimensions
  updateMapViewportDimensions()

  showLoadingMessage()

  // Request motion and orientation permissions
  requestMotionPermission()

  // Try to use Geolocation Sensor API first, then fall back to standard Geolocation API
  initGeolocation()

  document.addEventListener("visibilitychange", handleVisibilityChange)

  map.on("movestart zoomstart", () => {
    followUser = false
    isMapInteracting = true
  })

  map.on("moveend zoomend", () => {
    isMapInteracting = false
    resetInactivityTimer()
    updateMapViewportDimensions()
  })

  // Listen for resize events to update viewport dimensions
  window.addEventListener("resize", updateMapViewportDimensions)

  // Start animation loop for smooth rendering
  startAnimationLoop()

  // Enable touch interactions
  map.touchZoom.enable()
  map.doubleClickZoom.enable()

  // Add CSS for user marker direction indicator
  addUserMarkerStyles()
}

// Add CSS styles for user marker direction indicator
function addUserMarkerStyles() {
  const style = document.createElement("style")
  style.textContent = `
        .user-marker-icon {
            width: 16px;
            height: 16px;
            background-color: #ff3b30;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            position: relative;
        }
        
        .user-marker-direction {
            position: absolute;
            top: -4px;
            left: 50%;
            margin-left: -2px;
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-bottom: 12px solid #ff3b30;
            transform-origin: center bottom;
            z-index: -1;
        }
        
        .user-marker-icon.pulsing {
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(1.2);
                opacity: 0.8;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }
    `
  document.head.appendChild(style)
}

// Initialize geolocation with priority for Geolocation Sensor API
function initGeolocation() {
  // GeolocationSensor variable was undeclared. Please fix the import or declare the variable before using it.
  // Declaring GeolocationSensor here
  const GeolocationSensor = window.GeolocationSensor

  if ("GeolocationSensor" in window) {
    try {
      console.log("Trying GeolocationSensor API")
      geolocationSensor = new GeolocationSensor({ frequency: 1 })

      geolocationSensor.addEventListener("reading", () => {
        const position = {
          coords: {
            latitude: geolocationSensor.latitude,
            longitude: geolocationSensor.longitude,
            accuracy: geolocationSensor.accuracy,
            altitude: geolocationSensor.altitude,
            altitudeAccuracy: geolocationSensor.altitudeAccuracy,
            heading: geolocationSensor.heading,
            speed: geolocationSensor.speed,
          },
          timestamp: geolocationSensor.timestamp,
        }

        if (!lastPosition) {
          initializeUserLocation(position)
        } else {
          handlePositionUpdate(position)
        }
      })

      geolocationSensor.addEventListener("error", (error) => {
        console.warn("GeolocationSensor error:", error)
        // Fall back to standard Geolocation API
        useStandardGeolocation()
      })

      geolocationSensor.start()
      usingGeolocationSensorAPI = true
      console.log("Using GeolocationSensor API")
    } catch (error) {
      console.warn("GeolocationSensor error:", error)
      // Fall back to standard Geolocation API
      useStandardGeolocation()
    }
  } else {
    // Fall back to standard Geolocation API
    useStandardGeolocation()
  }
}

// Update map viewport dimensions
function updateMapViewportDimensions() {
  if (map && map._container) {
    mapViewportWidth = map._container.clientWidth
    mapViewportHeight = map._container.clientHeight

    // Store current map center and zoom
    if (map.getCenter()) {
      lastMapCenter = map.getCenter()
      lastMapZoom = map.getZoom()
    }
  }
}

// Standard Geolocation API fallback
function useStandardGeolocation() {
  console.log("Using standard Geolocation API")
  usingGeolocationSensorAPI = false

  if ("geolocation" in navigator) {
    const options = {
      enableHighAccuracy: true,
      timeout: 30000, // Reduced timeout for faster fallback
      maximumAge: 0,
    }

    // Try first time
    navigator.geolocation.getCurrentPosition(
      initializeUserLocation,
      (error) => {
        // On error, try one more time before falling back
        navigator.geolocation.getCurrentPosition(initializeUserLocation, handleLocationError, options)
      },
      options,
    )
  } else {
    showPopup("Geolocation is not supported by your browser")
    map.setView([44.9778, -93.265], 17)
    hideLoadingMessage()
  }
}

// Animation loop for smooth rendering
function startAnimationLoop() {
  // Local variables for optimization (not visible outside)
  let _frameCount = 0;
  let _lastFpsTime = 0;
  let _totalFrames = 0;
  let _accumulatedTime = 0;
  let _frameInterval = 16.667; // ms (60fps)
  let _skipThreshold = 16; // ms
  let _lowPerformanceMode = false;
  let _proximityCheckFrequency = 1;
  
  function animate(timestamp) {
    // Calculate delta time
    const deltaTime = renderTimestamp ? (timestamp - renderTimestamp) / 1000 : 0
    renderTimestamp = timestamp
    
    // Performance tracking (hidden implementation detail)
    if (!_lastFpsTime) _lastFpsTime = timestamp;
    _frameCount++;
    _totalFrames++;
    if (timestamp - _lastFpsTime > 1000) {
      const fps = Math.round((_frameCount * 1000) / (timestamp - _lastFpsTime));
      _lowPerformanceMode = fps < 30;
      _proximityCheckFrequency = _lowPerformanceMode ? 3 : 1;
      _frameCount = 0;
      _lastFpsTime = timestamp;
    }
    
    // Frame limiting (hidden implementation detail)
    _accumulatedTime += deltaTime * 1000;
    if (_accumulatedTime < _skipThreshold) {
      animationFrameId = requestAnimationFrame(animate);
      return;
    }

    try {
      // Process position updates
      processPositionUpdateQueue()

      // Update interpolated position
      if (positionInterpolator && positionInterpolator.isInterpolating()) {
        const interpolatedPosition = positionInterpolator.update()
        if (interpolatedPosition) {
          // Update marker position and rotation
          updateUserMarkerPosition(interpolatedPosition)
          lastRenderPosition = interpolatedPosition
        }
      }

      // Check if marker is near edge and recenter if needed
      if (followUser && !isMapInteracting && !edgeRecenterInProgress) {
        const recenterInfo = shouldRecenter(map, userMarker)
        if (recenterInfo.needsRecenter) {
          performEdgeRecenter(recenterInfo)
        }
      }

      // Check proximity to locations for zoom adjustments
      // Optimized to run less frequently on low-performance devices
      if (_totalFrames % _proximityCheckFrequency === 0) {
        checkLocationProximity()
      }
      
      // Reset accumulated time (hidden implementation detail)
      _accumulatedTime -= _frameInterval;
      if (_accumulatedTime > _frameInterval * 2) {
        _accumulatedTime = _frameInterval;
      }

      // Request next frame
      animationFrameId = requestAnimationFrame(animate)
    } catch (error) {
      // Error handling (hidden implementation detail)
      console.error('Error in animation loop:', error);
      animationFrameId = requestAnimationFrame(animate);
    }
  }

  // Start animation loop
  animationFrameId = requestAnimationFrame(animate)
}
       
// Process queued position updates
function processPositionUpdateQueue() {
  // Skip if no updates in queue
  if (positionUpdateQueue.length === 0) return;
  
  // Process all updates in the queue
  while (positionUpdateQueue.length > 0) {
    const update = positionUpdateQueue.shift();
    
    // Apply the update (assuming update contains position data)
    if (update && update.coords) {
      const position = {
        lat: update.coords.latitude,
        lng: update.coords.longitude,
        accuracy: update.coords.accuracy,
        heading: update.coords.heading,
        speedMPS: update.coords.speed,
        speedAccuracy: update.coords.speedAccuracy,
        timestamp: update.timestamp
      };
      
      // Process the position update
      processPositionUpdate(position);
    }
  }
}
      
// Update user marker position and rotation
function updateUserMarkerPosition(position) {
  if (!userMarker) return

  // Update marker position
  userMarker.setLatLng([position.lat, position.lng])

  // Update marker rotation based on heading if available
  if (position.heading !== undefined && position.heading !== null) {
    // Get the marker element
    const markerElement = userMarker.getElement()
    if (markerElement) {
      // Find the direction indicator element
      const directionElement = markerElement.querySelector(".user-marker-direction")
      if (directionElement) {
        // Update the rotation of the direction indicator
        directionElement.style.transform = `rotate(${position.heading}deg)`
      }
    }
  }

  // Apply visual effects based on speed
  if (position.speedMPS !== undefined) {
    const markerElement = userMarker.getElement()
    if (markerElement) {
      const iconElement = markerElement.querySelector(".user-marker-icon")
      if (iconElement) {
        // Add pulsing effect when moving
        if (position.speedMPS > 0.5) {
          iconElement.classList.add("pulsing")
          // Adjust pulse speed based on movement speed
          const pulseRate = Math.max(0.5, Math.min(2.0, 1.0 + position.speedMPS / 5))
          iconElement.style.animationDuration = `${1 / pulseRate}s`
        } else {
          iconElement.classList.remove("pulsing")
        }
      }
    }
  }
}
        
//process position update
function processPositionUpdate(position) {
  // Skip if invalid position
  if (!position || typeof position.lat !== "number" || typeof position.lng !== "number") {
    return;
  }

  // CRITICAL PATH: Handle large position changes differently
  // When position changes dramatically (e.g., GPS jump, returning from background, 
  // or first accurate fix after poor signal), we want to:
  // 1. Skip the smooth interpolation to avoid "rubber-banding" across the map
  // 2. Update the marker position immediately
  // 3. Reset the render position to this new position
  // This prevents disorienting visual effects when position changes significantly
  if (lastRenderPosition && calculateDistance(lastRenderPosition, position) > EXTENDED_DISTANCE_THRESHOLD) {
    console.debug(`Large position change detected (${calculateDistance(lastRenderPosition, position).toFixed(2)}m). Skipping interpolation.`);
    updateUserMarkerPosition(position); // Direct update without animation
    lastRenderPosition = position;
    return; // Skip the rest of the interpolation logic
  }

  // Normal case: Apply smooth interpolation between positions
  if (lastRenderPosition && !isFirstPositionUpdate) {
    if (positionInterpolator) {
      // Use slower animation when stationary for more stability
      positionInterpolator.start(
        lastRenderPosition, 
        position,
        isStationary ? 300 : ANIMATION_DURATION,
      );
    } else {
      console.warn("Position interpolator not available, using direct position update");
      updateUserMarkerPosition(position);
      lastRenderPosition = position;
    }
  } else {
    // First position update - set directly without animation
    updateUserMarkerPosition(position);
    lastRenderPosition = position;
    isFirstPositionUpdate = false;
  }

  // Handle auto-recentering and zoom adjustments
  if (followUser && !isMapInteracting) {
    const recenterInfo = shouldRecenter(map, userMarker);
    if (recenterInfo.needsRecenter) {
      performEdgeRecenter(recenterInfo);
    } else if (Math.abs(map.getZoom() - calculateZoomLevel(position.speedMPS)) > 0.5) {
      const newZoom = calculateZoomLevel(position.speedMPS);
      map.setZoom(newZoom, {
        animate: true,
        duration: ZOOM_TRANSITION_DURATION,
      });
    }
  }
}
        
// Perform edge recentering with smoother transitions based on speed
function performEdgeRecenter(recenterInfo) {
  edgeRecenterInProgress = true
  
  // Get current position
  const position = userMarker.getLatLng()
  
  // Get current speed (in meters per second)
  const currentSpeed = lastPosition?.speedMPS || 0
  
  // Only trust GPS-reported speed, not calculated from position changes
  // This helps filter out device movements like shaking
  const isGenuineMovement = lastPosition?.hasOwnProperty('speedAccuracy') && 
                            lastPosition.speedAccuracy < SPEED_ACCURACY_THRESHOLD
  
  // Use a conservative speed value if we're not confident in the movement
  const reliableSpeed = isGenuineMovement ? currentSpeed : Math.min(currentSpeed, 1.0)
  
  // Calculate appropriate zoom level based on reliable speed
  const dynamicZoom = calculateZoomLevel(reliableSpeed)
  
  // Get current map center
  const currentCenter = map.getCenter()
  
  // Calculate optimal center point that keeps the user icon away from edges
  const optimalCenter = calculateOptimalCenter(map, position, recenterInfo.edgeInfo)
  
  // Calculate edge proximity using your existing function
  const proximity = calculateEdgeProximity(map, position)
  
  // Find the minimum proximity (closest edge)
  const minProximity = Math.min(proximity.north, proximity.south, proximity.east, proximity.west)
  
  // Calculate speed factor (0-1) based on reliable speed
  const SPEED_THRESHOLD_SLOW = 2.0
  const SPEED_THRESHOLD_FAST = 10.0
  const speedFactor = Math.min(1, Math.max(0, (reliableSpeed - SPEED_THRESHOLD_SLOW) / 
                              (SPEED_THRESHOLD_FAST - SPEED_THRESHOLD_SLOW)))
  
  // Calculate combined transition factor
  const baseTransitionFactor = Math.max(0.3, Math.min(0.8, minProximity * 2))
  const speedAdjustedFactor = baseTransitionFactor - (speedFactor * 0.3)
  
  // Blend current and optimal centers for smoother transition
  const blendedCenter = {
    lat: currentCenter.lat + (optimalCenter.lat - currentCenter.lat) * (1 - speedAdjustedFactor),
    lng: currentCenter.lng + (optimalCenter.lng - currentCenter.lng) * (1 - speedAdjustedFactor)
  }
  
  // Only apply forward bias for genuine GPS movement
  let adjustedCenter = blendedCenter
  if (lastPosition && isGenuineMovement) {
    const direction = {
      lat: position.lat - lastPosition.lat,
      lng: position.lng - lastPosition.lng
    }
    
    // Calculate movement magnitude
    const movement = Math.sqrt(direction.lat * direction.lat + direction.lng * direction.lng)
    
    // Only apply forward bias if moving significantly
    if (movement > 0.00001) {
      // Apply forward bias scaled to speed
      const forwardBiasAmount = 0.00005 + (speedFactor * 0.0001)
      
      // Normalize direction and apply forward bias
      adjustedCenter = {
        lat: blendedCenter.lat + (direction.lat / movement) * forwardBiasAmount,
        lng: blendedCenter.lng + (direction.lng / movement) * forwardBiasAmount
      }
    }
  }
  
  // Calculate duration based on reliable speed
  const baseDuration = recenterInfo.isEmergency ? 0.2 : ZOOM_TRANSITION_DURATION
  const speedAdjustedDuration = baseDuration * (1 - (speedFactor * 0.5))
  
  // Set view with animation
  map.setView([adjustedCenter.lat, adjustedCenter.lng], dynamicZoom, {
    animate: true,
    duration: speedAdjustedDuration,
    noMoveStart: true,
    easeLinearity: 0.3 + (speedFactor * 0.2)
  })
  
  // Reset edge recenter flag after animation completes
  setTimeout(
    () => {
      edgeRecenterInProgress = false
    },
    recenterInfo.isEmergency ? 300 : speedAdjustedDuration * 1000,
  )
}

function showLoadingMessage() {
    // Skip creating the loading message element
    // Just log to console for debugging purposes
    console.log("Searching for location...");
    
    // Set a flag to track that we're in the loading state
    window.isSearchingLocation = true;
    
    // If you need to maintain any timing-dependent behavior that might
    // rely on this function, you can add a small timeout
    setTimeout(() => {
        // This ensures any code expecting this function to take some time
        // will still work correctly
    }, 100);
}

function hideLoadingMessage() {
    // Clear the loading state flag
    window.isSearchingLocation = false;
    
    // No need to remove any elements since we didn't create them
    // Just log for debugging
    console.log("Location found, proceeding to stabilization...");
    
    // If any code relies on this function completing, ensure it still works
    const fakeLoadingMessage = document.getElementById('loadingMessage');
    if (fakeLoadingMessage) {
        document.body.removeChild(fakeLoadingMessage);
    }
}
       
function showStabilizingModal() {
  // Hide jitter immediately
  if (userMarker) userMarker.setOpacity(0);

  const modal = document.createElement("div");
  modal.id = "stabilizingModal";
  modal.className = "stabilizing-modal";
  modal.innerHTML = `
    <div class="spinner"></div>
    <h3>Stabilizing Your Location</h3>
    <p>Please wait while we fine-tune your position.</p>
  `;
  document.body.appendChild(modal);

  // Auto-dismiss after 5 seconds
  setTimeout(() => {
    if (userMarker) userMarker.setOpacity(1); // Restore visibility
    const modal = document.getElementById("stabilizingModal");
    if (modal) {
      modal.style.opacity = "0";
      setTimeout(() => modal.remove(), 500);
    }
    isStabilizing = false;
  }, 5000);
}

function initializeUserLocation(position) {
  console.log("Initial position data:", JSON.stringify(position))

  if (!position || !position.coords) {
    console.error("Invalid initial position object")
    handleLocationError(new Error("Invalid initial position"))
    return
  }

  const { latitude: userLat, longitude: userLng, accuracy } = position.coords

  if (isNaN(userLat) || isNaN(userLng)) {
    console.error("Invalid initial coordinates:", { userLat, userLng })
    handleLocationError(new Error("Invalid initial coordinates"))
    return
  }

  console.log("Valid initial position:", { userLat, userLng, accuracy })

  try {
    // Set initial marker position
    updateUserMarkerPosition({
      lat: userLat,
      lng: userLng,
      accuracy: accuracy,
      heading: position.coords.heading,
      timestamp: Date.now(),
      speedMPS: 0,
    })

    map.setView([userLat, userLng], 17)

    // Initialize Kalman filter with first position
    tracking.filter.reset({
      lat: userLat,
      lng: userLng,
      accuracy: accuracy,
      heading: position.coords.heading,
      timestamp: Date.now(),
    })

    // Initialize stationary position
    lastStationaryPosition = {
      lat: userLat,
      lng: userLng,
      accuracy: accuracy,
      heading: position.coords.heading,
      timestamp: Date.now(),
      speedMPS: 0,
    }

    // Initialize last render position
    lastRenderPosition = {
      lat: userLat,
      lng: userLng,
      accuracy: accuracy,
      heading: position.coords.heading,
      timestamp: Date.now(),
      speedMPS: 0,
    }

    // Initialize last valid position
    lastValidPosition = {
      lat: userLat,
      lng: userLng,
      accuracy: accuracy,
      heading: position.coords.heading,
      timestamp: Date.now(),
      speedMPS: 0,
    }

    // Show stabilizing modal
    hideLoadingMessage()
    showStabilizingModal()

    // Start position updates
    startPositionUpdates()
    startHunt()
  } catch (error) {
    console.error("Error setting initial user location:", error)
    handleLocationError(error)
  }
}

function startPositionUpdates() {
  if (usingGeolocationSensorAPI) {
    console.log("Position updates already using GeolocationSensor API");
    return;
  }

  // Track GPS failures
  let gpsFailureCount = 0;
  const MAX_GPS_FAILURES = 3;

  const startWatchPosition = (useHighAccuracy = true) => {
    // Clear existing watch if any
    if (watchPositionId !== null) {
      navigator.geolocation.clearWatch(watchPositionId);
      watchPositionId = null;
    }

    // Adaptive frequency logic (preserved)
    let updateFrequency = positionUpdateRate;
    
    if (adaptivePositionUpdateRate && lastPosition) {
      const speed = lastPosition.speedMPS || 0;
      const accuracy = lastPosition.accuracy || 20;
      
      if (speed > DRIVING_SPEED_THRESHOLD) {
        updateFrequency = 250;
      } else if (speed > RUNNING_SPEED_THRESHOLD) {
        updateFrequency = 400;
      } else if (speed > WALKING_SPEED_THRESHOLD) {
        updateFrequency = 600;
      } else if (isStationary) {
        updateFrequency = 2000;
      }
      
      if (accuracy > 20) {
        updateFrequency = Math.max(500, updateFrequency * 0.8);
      }

      // Slower updates in network fallback mode
      if (!useHighAccuracy) {
        updateFrequency = Math.max(updateFrequency, 3000); // Minimum 3s interval
      }
    }

    // Enhanced error handler with fallback
    const errorHandler = (error) => {
      if (error.code === error.TIMEOUT && useHighAccuracy) {
        gpsFailureCount++;
        if (gpsFailureCount >= MAX_GPS_FAILURES) {
          console.warn("GPS unavailable, falling back to network positioning");
          startWatchPosition(false); // Switch to network mode
        } else {
          handleLocationError(error);
        }
      } else {
        handleLocationError(error);
      }
    };

    // Start watching position
    watchPositionId = navigator.geolocation.watchPosition(
      (position) => {
        gpsFailureCount = 0; // Reset on successful update
        // Auto-revert to GPS if accuracy improves
        if (!useHighAccuracy && position.coords.accuracy <= 30) {
          console.log("GPS signal restored, switching back to high accuracy");
          startWatchPosition(true);
        }
        handlePositionUpdate(position);
      },
      errorHandler,
      {
        enableHighAccuracy: useHighAccuracy,
        maximumAge: updateFrequency * 0.5,
        timeout: 10000
      }
    );

    isWatchPositionActive = true;
    console.log(`Position updates at ${updateFrequency}ms (${useHighAccuracy ? 'GPS' : 'Network'})`);
  };

  // Start with high accuracy (GPS)
  startWatchPosition(true);

  // Periodically restart the watch to ensure fresh data
  setInterval(() => {
    if (isWatchPositionActive) {
      // Use the same value that was used most recently
      const currentHighAccuracy = navigator.geolocation.getCurrentPosition().enableHighAccuracy || true;
      startWatchPosition(currentHighAccuracy);
    }
  }, 30000);
}
    
function handlePositionUpdate(position) {
  // Validate position
  if (!position?.coords?.latitude || !position?.coords?.longitude) {
    console.warn("Invalid position data received");
    return;
  }

  // Determine position source (GPS vs Network)
  const isHighAccuracy = position.coords.accuracy <= 30; // <30m = likely GPS
  const isNetworkFallback = !isHighAccuracy && position.coords.accuracy > 100;

  // Enhance position object with metadata
  const enhancedPosition = {
    ...position,
    coords: {
      ...position.coords,
      source: isHighAccuracy ? 'gps' : 'network',
      isApproximate: isNetworkFallback
    }
  };

  // Adjust Kalman filter parameters based on accuracy
  if (isNetworkFallback) {
    // More aggressive smoothing for network positions
    tracking.filter
      .setEnvironmentType("urban")
      .setStationaryMode(true); // Assume less movement
    
    // Apply additional network-specific filters
    enhancedPosition.coords.accuracy = Math.max(position.coords.accuracy, 150);
  } else {
    // Reset to normal GPS parameters
    tracking.filter
      .setEnvironmentType("default")
      .setStationaryMode(isStationary);
  }

  // Debug logging
  if (isNetworkFallback) {
    console.log(`Using network-derived position (Accuracy: ${Math.round(position.coords.accuracy)}m)`);
  }

  // Process update
  updateUserLocation(enhancedPosition);

  // Visual feedback (optional)
  if (isNetworkFallback && !lastPosition?.coords?.isApproximate) {
    showTemporaryMessage("Using approximate location", 3000);
  }
}

function showTemporaryMessage(message, duration) {
  const messageDiv = document.createElement('div');
  messageDiv.className = 'temporary-message';
  messageDiv.textContent = message;
  document.body.appendChild(messageDiv);
  setTimeout(() => {
    messageDiv.remove();
  }, duration);
}
        
function handleVisibilityChange() {
  if (document.hidden) {
    lastHiddenTime = Date.now()
    lastKnownPosition = userMarker ? userMarker.getLatLng() : null

    // Cancel any active interpolation
    if (positionInterpolator) {
      positionInterpolator.cancel()
    }

    // Cancel animation frame
    if (animationFrameId) {
      cancelAnimationFrame(animationFrameId)
      animationFrameId = null
    }

    // Stop GeolocationSensor if using it
    if (usingGeolocationSensorAPI && geolocationSensor) {
      geolocationSensor.stop()
    }
  } else {
    const hiddenDuration = Date.now() - lastHiddenTime
    if (hiddenDuration > BACKGROUND_THRESHOLD) {
      updateLocationAfterBackground()
    } else {
      map.invalidateSize()

      // Restart animation loop
      if (!animationFrameId) {
        startAnimationLoop()
      }

      // Restart GeolocationSensor if using it
      if (usingGeolocationSensorAPI && geolocationSensor) {
        geolocationSensor.start()
      }

      // If returning from exhibit, ensure movement resumes properly
      if (isReturningFromExhibit) {
        isReturningFromExhibit = false
        // Force a position update to resume tracking
        if (lastValidPosition) {
          updateUserLocation(
            {
              coords: {
                latitude: lastValidPosition.lat,
                longitude: lastValidPosition.lng,
                accuracy: lastValidPosition.accuracy,
                heading: lastValidPosition.heading,
                speed: lastValidPosition.speedMPS,
              },
              timestamp: Date.now(),
            },
            true,
          )
        }
      }
    }
  }
  resetInactivityTimer()
}

// Fix the updateLocationAfterBackground function
function updateLocationAfterBackground() {
  if ("geolocation" in navigator) {
    navigator.geolocation.getCurrentPosition(
      (position) => {
        console.log("Background update raw position:", JSON.stringify(position))
        if (!position || !position.coords) {
          console.warn("Invalid position object in background update")
          return
        }
        const { latitude, longitude, accuracy } = position.coords
        if (isNaN(latitude) || isNaN(longitude)) {
          console.warn("Invalid coordinates in background update:", { latitude, longitude })
          return
        }

        console.log("Valid background position update:", { lat: latitude, lng: longitude })
        try {
          updateUserLocation(position, true)
        } catch (error) {
          console.error("Error in updateUserLocation during background update:", error)
        }

        // Reset tracking variables
        lastPosition = null
        positionBuffer = []
        velocity = { lat: 0, lng: 0 }
        lastVelocity = { lat: 0, lng: 0 }
        isStationary = false
        stationaryStartTime = null
        stationaryCount = 0
        stationaryPositionHistory = []
        lastStationaryPosition = null
        stationaryPositionLocked = false
        positionHistory = []
        suddenMovementCount = 0
        isJumpDetected = false

        // Reset Kalman filter
        tracking.filter.reset({
          lat: latitude,
          lng: longitude,
          accuracy: accuracy,
          heading: position.coords.heading,
          timestamp: Date.now(),
        })

        // Restart animation loop
        if (!animationFrameId) {
          startAnimationLoop()
        }

        // Restart GeolocationSensor if using it
        if (usingGeolocationSensorAPI && geolocationSensor) {
          geolocationSensor.start()
        }

        updateDistanceBox()
        followUser = true
        map.invalidateSize()
      },
      (error) => {
        console.error("Error getting location after background:", error)
        if (error.code === 3) {
          // If timeout, retry with lower accuracy
          navigator.geolocation.getCurrentPosition(
            (position) => {
              console.log("Retry successful with lower accuracy")
              updateUserLocation(position, true)
            },
            (error) => console.error("Error on retry:", error),
            {
              enableHighAccuracy: false,
              timeout: 20000,
              maximumAge: 30000,
            },
          )
        }
      },
      {
        enableHighAccuracy: true,
        timeout: 10000,
        maximumAge: 0,
      },
    )
  } else {
    console.warn("Geolocation is not available")
  }
}

// Helper function to validate position data
function isValidPosition(pos) {
  return (
    pos &&
    typeof pos.lat === "number" &&
    !isNaN(pos.lat) &&
    typeof pos.lng === "number" &&
    !isNaN(pos.lng) &&
    typeof pos.accuracy === "number" &&
    !isNaN(pos.accuracy)
  )
}

// Linear interpolation helper
function lerp(a, b, t) {
  if (typeof a !== "number" || typeof b !== "number" || typeof t !== "number") {
    return a
  }

  return a + (b - a) * Math.max(0, Math.min(1, t))
}

// Update position buffer with new position
function updatePositionBuffer(position) {
  if (!isValidPosition(position)) {
    return
  }

  // Add new position to buffer
  positionBuffer.push({
    lat: position.lat,
    lng: position.lng,
    accuracy: position.accuracy,
    heading: position.heading,
    timestamp: position.timestamp,
    speedMPS: position.speedMPS,
  })

  // Remove old positions if buffer exceeds maxSize
  while (positionBuffer.length > MAX_BUFFER_SIZE) {
    positionBuffer.shift()
  }
}

// Update position history for jump detection
function updatePositionHistory(position) {
  if (!isValidPosition(position)) {
    return
  }

  // Add new position to history
  positionHistory.push({
    lat: position.lat,
    lng: position.lng,
    accuracy: position.accuracy,
    heading: position.heading,
    timestamp: position.timestamp,
    speedMPS: position.speedMPS,
  })

  // Keep only recent positions
  while (positionHistory.length > 10) {
    positionHistory.shift()
  }
}

// Check stationary state
function checkStationaryState(newPosition) {
  if (!lastPosition) return

  // Calculate distance between current and last position
  const distance = calculateDistance(lastPosition, newPosition)

  // Check if device motion sensors indicate movement
  const motionDetected = isDeviceInMotion()

  // If significant movement is detected or motion sensors indicate activity
  if (distance >= MICRO_MOVEMENT_THRESHOLD || motionDetected) {
    if (isStationary) {
      console.debug("Movement detected, transitioning to moving state")
      isStationary = false
      stationaryStartTime = null
      stationaryPositionLocked = false
      stationaryCount = 0 // Reset stationary count
      tracking.filter.setStationaryMode(false)

      // Clear any stationary lock timeout
      if (stationaryLockTimeout) {
        clearTimeout(stationaryLockTimeout)
        stationaryLockTimeout = null
      }
    }

    // Clear the stationary check timeout
    if (stationaryCheckTimeout) {
      clearTimeout(stationaryCheckTimeout)
      stationaryCheckTimeout = null
    }
  } else {
    // If no significant movement, increment stationary count
    stationaryCount++

    // If stationary count exceeds threshold, transition to stationary state
    if (!isStationary && stationaryCount >= STATIONARY_THRESHOLD) {
      console.debug("User is now stationary")
      isStationary = true
      stationaryStartTime = Date.now()
      tracking.filter.setStationaryMode(true)

      // Calculate a stable position by averaging recent positions
      const stablePosition = calculateStationaryPosition(positionBuffer)
      if (stablePosition) {
        lastStationaryPosition = stablePosition

        // Set a timeout to lock the stationary position after a delay
        if (stationaryLockTimeout) {
          clearTimeout(stationaryLockTimeout)
        }

        stationaryLockTimeout = setTimeout(() => {
          stationaryPositionLocked = true
          stationaryPositionLockTime = Date.now()
          console.log("Stationary position locked after delay")

          // Also lock in the Kalman filter
          tracking.filter.lockStationaryPosition(lastStationaryPosition)
        }, 2000) // Reduced from 3000ms for faster locking
      }
    }

    // Schedule the next stationary check
    if (isStationary && !stationaryCheckTimeout) {
      stationaryCheckTimeout = setTimeout(() => {
        stationaryCheckTimeout = null
        checkStationaryState(newPosition)
      }, STATIONARY_CHECK_INTERVAL)
    }
  }
}

// Main function to update user location
function updateUserLocation(position, forceUpdate = false) {
  // Validate input position
  if (!position?.coords?.latitude || !position?.coords?.longitude) {
    console.warn("Invalid position data received")
    return
  }

  const currentTime = Date.now()
  const timeDelta = lastUpdateTime ? (currentTime - lastUpdateTime) / 1000 : 0

  // Create position object
  const newPosition = {
    lat: position.coords.latitude,
    lng: position.coords.longitude,
    accuracy: position.coords.accuracy || 20,
    heading: position.coords.heading !== null ? position.coords.heading : lastHeadingValue || undefined,
    timestamp: currentTime,
    speedMPS: position.coords.speed !== null ? position.coords.speed : 0,
  }

  // First position initialization
  if (!lastPosition) {
    lastPosition = newPosition
    lastValidPosition = newPosition
    updateUserMarkerPosition(newPosition)
    tracking.filter.reset(newPosition)
    lastUpdateTime = currentTime
    stationaryStartTime = currentTime
    positionBuffer = [newPosition]
    positionHistory = [newPosition]
    lastStationaryPosition = newPosition
    lastRenderPosition = newPosition

    // Set initial zoom based on stationary state
    const initialZoom = calculateZoomLevel(0)
    map.setView([newPosition.lat, newPosition.lng], initialZoom, { animate: false })
    updateDistanceBox()
    return
  }

  // Calculate distance from last position
  const distance = calculateDistance(lastPosition, newPosition)

  // Check for sudden movements or position jumps
  const isJump = !forceUpdate && detectSuddenMovement(newPosition, lastPosition)

  // If a jump is detected and we're stationary, ignore this update
  if (isJump && isStationary && stationaryPositionLocked) {
    console.log("Position jump detected while stationary, ignoring update")
    isJumpDetected = true
    return
  }

  // Handle large position changes or forced updates - THIS IS THE CRITICAL CHANGE
  if (distance > EXTENDED_DISTANCE_THRESHOLD || forceUpdate) {
    if (stationaryCheckTimeout) {
      clearTimeout(stationaryCheckTimeout)
      stationaryCheckTimeout = null
    }

    if (stationaryLockTimeout) {
      clearTimeout(stationaryLockTimeout)
      stationaryLockTimeout = null
    }

    isStationary = false
    stationaryStartTime = null
    stationaryCount = 0
    stationaryPositionHistory = []
    lastStationaryPosition = null
    stationaryPositionLocked = false
    isJumpDetected = false

    // Reset tracking variables
    tracking.filter.reset(newPosition)
    tracking.filter.setStationaryMode(false)
    
    // Update marker position IMMEDIATELY without interpolation
    updateUserMarkerPosition(newPosition)
    
    lastPosition = newPosition
    lastValidPosition = newPosition
    lastRenderPosition = newPosition
    positionBuffer = [newPosition]
    positionHistory = [newPosition]
    lastVelocity = { lat: 0, lng: 0 }
    lastSmoothedPosition = null

    // Update map view INSTANTLY without animation
    const zoomLevel = calculateZoomLevel(newPosition.speedMPS)
    map.setView([newPosition.lat, newPosition.lng], zoomLevel, {
      animate: false,  // CHANGED THIS LINE
      duration: 0      // ADDED THIS LINE
    })

    lastUpdateTime = currentTime
    lastUpdateTimestamp = currentTime
    updateDistanceBox()

    if (map._container) {
      map._onResize()
    }
    return
  }

  // Skip updates with poor accuracy or unrealistic movement
  if (
    !forceUpdate &&
    (newPosition.accuracy > MAX_ACCEPTABLE_ACCURACY || (timeDelta > 0 && distance / timeDelta > 40))
  ) {
    console.log("Skipping update due to poor accuracy or unrealistic movement")
    return
  }

  try {
    // Check if device is in motion based on motion sensors
    const motionDetected = deviceMotion && isDeviceInMotion()

    // Check stationary state
    checkStationaryState(newPosition)

    // If we're in stationary mode and have a locked position, use that position
    if (isStationary && stationaryPositionLocked && lastStationaryPosition) {
      // Just update the distance box without changing position
      updateDistanceBox()
      return
    }

// Apply enhanced tracking with motion detection
const smoothedPosition = tracking.update(newPosition, motionDetected, ANIMATION_DURATION)

// Update position buffer and history
updatePositionBuffer(smoothedPosition)
updatePositionHistory(smoothedPosition)

// Add this line here
updateUserMarkerPosition(smoothedPosition)

// Add to position update queue
positionUpdateQueue.push(smoothedPosition)
    lastPosition = smoothedPosition
    lastValidPosition = smoothedPosition

    lastUpdateTime = currentTime
    lastUpdateTimestamp = currentTime
    updateDistanceBox()
  } catch (error) {
    console.error("Location update error:", error)
    // Fallback with basic filtering
    updateUserMarkerPosition(newPosition)
    lastPosition = newPosition
    lastValidPosition = newPosition
    lastRenderPosition = newPosition
    updateDistanceBox()
  }
}

// Predict position based on heading and speed
function predictPositionFromHeading(position, heading, distance) {
  // Input validation
  if (
    !position ||
    typeof heading !== "number" ||
    typeof distance !== "number" ||
    !position.lat ||
    !position.lng ||
    isNaN(heading) ||
    isNaN(distance)
  ) {
    return position
  }

  // Normalize heading to 0-360 range
  heading = ((heading % 360) + 360) % 360

  // Earth's radius in meters
  const R = 6371e3

  // Convert to radians
  const d = distance / R
  const θ = (heading * Math.PI) / 180
  const φ1 = (position.lat * Math.PI) / 180
  const λ1 = (position.lng * Math.PI) / 180

  // Calculate predicted position with error handling
  try {
    const sinφ1 = Math.sin(φ1)
    const cosφ1 = Math.cos(φ1)
    const cosd = Math.cos(d)
    const sind = Math.sin(d)
    const cosθ = Math.cos(θ)

    const φ2 = Math.asin(sinφ1 * cosd + cosφ1 * sind * cosθ)

    const λ2 = λ1 + Math.atan2(Math.sin(θ) * sind * cosφ1, cosd - sinφ1 * Math.sin(φ2))

    // Convert back to degrees with bounds checking
    const newLat = Math.max(-90, Math.min(90, (φ2 * 180) / Math.PI))
    const newLng = (((λ2 * 180) / Math.PI + 540) % 360) - 180

    return {
      lat: newLat,
      lng: newLng,
    }
  } catch (error) {
    // Fallback to original position if calculation fails
    return position
  }
}

// Check if marker is near edge of map
function isMarkerNearEdge(map, marker, isStrict = false) {
  if (!map || !marker) return { isNearEdge: false }

  const bounds = map.getBounds()
  const point = marker.getLatLng()
  const proximities = calculateEdgeProximity(map, point)

  const thresholdPercentage = isStrict ? 0.12 : EDGE_THRESHOLD_PERCENTAGE

  const edges = {
    north: proximities.north < thresholdPercentage,
    south: proximities.south < thresholdPercentage,
    east: proximities.east < thresholdPercentage,
    west: proximities.west < thresholdPercentage,
  }

  return {
    isNearEdge: Object.values(edges).some((edge) => edge),
    edges: edges,
    proximities: proximities,
  }
}

// Calculate proximity to map edges
function calculateEdgeProximity(map, point) {
  const bounds = map.getBounds()
  const latSpan = bounds.getNorth() - bounds.getSouth()
  const lngSpan = bounds.getEast() - bounds.getWest()

  return {
    north: Math.abs(point.lat - bounds.getNorth()) / latSpan,
    south: Math.abs(point.lat - bounds.getSouth()) / latSpan,
    east: Math.abs(point.lng - bounds.getEast()) / lngSpan,
    west: Math.abs(point.lng - bounds.getWest()) / lngSpan,
  }
}

// Determine if map should recenter
function shouldRecenter(map, marker) {
  const now = Date.now()
  if (now - lastRecenterTime < RECENTER_COOLDOWN) {
    return { needsRecenter: false }
  }

  if (!map || !marker) return { needsRecenter: false }

  const edgeInfo = isMarkerNearEdge(map, marker)
  const proximities = edgeInfo.proximities

  // Check for critical edge proximity (very close to edge)
  const isCritical = Object.values(proximities).some((proximity) => proximity < CRITICAL_EDGE_THRESHOLD)

  if (isCritical) {
    lastRecenterTime = now
    return {
      needsRecenter: true,
      isEmergency: true,
      edgeInfo: edgeInfo,
    }
  }

  // Check for normal edge proximity
  if (edgeInfo.isNearEdge) {
    lastRecenterTime = now
    return {
      needsRecenter: true,
      isEmergency: false,
      edgeInfo: edgeInfo,
    }
  }

  return {
    needsRecenter: false,
    isEmergency: false,
    edgeInfo: edgeInfo,
  }
}

// Calculate optimal center point
function calculateOptimalCenter(map, markerPosition, edgeInfo) {
  const bounds = map.getBounds()

  // Calculate offsets based on which edges are being approached
  let latOffset = 0
  let lngOffset = 0

  // Apply stronger offset for the closest edge
  const proximities = edgeInfo.proximities
  const edges = edgeInfo.edges

  // Get viewport dimensions
  const viewportWidth = mapViewportWidth || map._container.clientWidth
  const viewportHeight = mapViewportHeight || map._container.clientHeight

  // Calculate aspect ratio to adjust offsets
  const aspectRatio = viewportWidth / viewportHeight

  // Adjust offsets based on viewport dimensions
  const latSpan = bounds.getNorth() - bounds.getSouth()
  const lngSpan = bounds.getEast() - bounds.getWest()

  // Calculate offsets with consideration for viewport aspect ratio
  if (edges.north) {
    latOffset = -1 * latSpan * 0.25 * (1 / aspectRatio)
  }
  if (edges.south) {
    latOffset = latSpan * 0.25 * (1 / aspectRatio)
  }
  if (edges.east) {
    lngOffset = -1 * lngSpan * 0.25 * aspectRatio
  }
  if (edges.west) {
    lngOffset = lngSpan * 0.25 * aspectRatio
  }

  // Find the closest edge and apply extra offset
  const minProximity = Math.min(
    edges.north ? proximities.north : 1,
    edges.south ? proximities.south : 1,
    edges.east ? proximities.east : 1,
    edges.west ? proximities.west : 1,
  )

  if (minProximity === proximities.north && edges.north) {
    latOffset *= 1.5
  } else if (minProximity === proximities.south && edges.south) {
    latOffset *= 1.5
  } else if (minProximity === proximities.east && edges.east) {
    lngOffset *= 1.5
  } else if (minProximity === proximities.west && edges.west) {
    lngOffset *= 1.5
  }

  return {
    lat: markerPosition.lat + latOffset,
    lng: markerPosition.lng + lngOffset,
  }
}

function updateDistanceBox() {
  const distanceBox = document.getElementById("distanceBox")
  if (!distanceBox) return

  // Schedule DOM update
  domUpdateManager.schedule("distanceBox", () => {
    // Initial validation
    if (!userMarker || !gameLocations || gameLocations.length === 0) {
      distanceBox.innerText = "Initializing..."
      return
    }

    // Get user coordinates
    const userLatLng = userMarker.getLatLng()
    let userLat = userLatLng.lat
    let userLng = userLatLng.lng

    // Coordinate validation
    if (!isFinite(userLat) || !isFinite(userLng)) {
      console.warn("Invalid user coordinates:", userLat, userLng)
      distanceBox.innerText = "Initializing..."
      return
    }

    // Use map center if at origin
    if (userLat === 0 && userLng === 0) {
      const center = map.getCenter()
      userLat = center.lat
      userLng = center.lng
    }

    // Find closest location
    let closestDistance = Number.POSITIVE_INFINITY
    let closestLocation = null
    const userPos = { lat: userLat, lng: userLng }

    for (const location of gameLocations) {
      if (!location || typeof location.lat !== "number" || typeof location.lng !== "number") {
        console.warn("Invalid location data:", location)
        continue
      }

      const locationPos = { lat: location.lat, lng: location.lng }
      const distance = calculateDistance(userPos, locationPos)

      if (isFinite(distance) && distance < closestDistance) {
        closestDistance = distance
        closestLocation = location
      }
    }

    // Validate final distance calculation
    if (!isFinite(closestDistance) || closestDistance === Number.POSITIVE_INFINITY) {
      console.warn("Invalid distance calculation:", closestDistance)
      distanceBox.innerText = "Initializing..."
      return
    }

    // Calculate and display distance
    const distanceFeet = Math.round(closestDistance * 3.28084)
    const distanceText =
      distanceFeet < 5280 ? `${distanceFeet.toLocaleString()} feet` : `${(distanceFeet / 5280).toFixed(2)} miles`

    distanceBox.innerText = `Closest Stop: ${distanceText}`

    // Check if we should show location hunt
    if (distanceFeet <= DISTANCE_THRESHOLD && !isLocationHuntVisible && closestLocation) {
      showLocationHunt(closestLocation)
    }
  })
}

const MAX_RETRIES = 3
const RETRY_DELAY = 1000

function getGeolocationOptions(retryNumber) {
  return {
    enableHighAccuracy: retryNumber < 2,
    timeout: 10000 + retryNumber * 5000,
    maximumAge: retryNumber * 5000,
  }
}

function handleLocationError(error) {
  console.warn("Error getting user location:", error);
  
  // Network availability check
  const isOnline = navigator.onLine;
  const lastKnownNetworkPos = localStorage.getItem('lastNetworkPosition');
  
  // Immediate network fallback if available
  if (!isOnline && lastKnownNetworkPos) {
    console.log("Offline - using cached network position");
    updateUserLocation(JSON.parse(lastKnownNetworkPos), false);
    return;
  }

  // Retry logic for temporary failures
  if (retryCount < MAX_RETRIES) {
    retryCount++;
    const delay = RETRY_DELAY * Math.pow(2, retryCount - 1);
    
    console.log(`Retrying location (Attempt ${retryCount}/${MAX_RETRIES}) in ${delay}ms`);
    
    setTimeout(() => {
      navigator.geolocation.getCurrentPosition(
        (position) => {
          console.log("Location retrieved after retry");
          handlePositionSuccess(position);
        },
        handleLocationError,
        getGeolocationOptions(retryCount)
      );
    }, delay);
    return;
  }

  // Permanent failure handling
  retryCount = 0;
  hideLoadingMessage();

  // Enhanced error messaging
  let errorMessage = "Location unavailable";
  let recoveryAction = null;

  if (error?.code) {
    switch (error.code) {
      case 1: // PERMISSION_DENIED
        errorMessage = "Location access denied";
        recoveryAction = () => {
          notifyAppLocationDenied();
          attemptNetworkPositioning();
        };
        break;

      case 2: // POSITION_UNAVAILABLE
        errorMessage = "GPS signal lost";
        recoveryAction = () => {
          if (lastKnownNetworkPos) {
            updateUserLocation(JSON.parse(lastKnownNetworkPos), false);
          }
          attemptNetworkPositioning();
        };
        break;

      case 3: // TIMEOUT
        errorMessage = "GPS response timeout";
        recoveryAction = () => {
          monitorConnectionRecovery();
          attemptNetworkPositioning();
        };
        break;
    }
  }

  // Smart recovery flow
  if (recoveryAction) {
    showRecoveryDialog(errorMessage, recoveryAction);
  } else {
    showPopup("Location Error", errorMessage);
  }
}

// New helper functions
function handlePositionSuccess(position) {
  hideLoadingMessage();
  retryCount = 0;
  
  // Cache network-derived positions
  if (position.coords.accuracy > 100) {
    localStorage.setItem('lastNetworkPosition', JSON.stringify(position));
  }
  
  updateUserLocation(position, true);
}

function attemptNetworkPositioning() {
  console.log("Attempting network-based positioning");
  navigator.geolocation.getCurrentPosition(
    handlePositionSuccess,
    (fallbackError) => {
      console.warn("Network positioning failed:", fallbackError);
      if (localStorage.getItem('lastKnownLocation')) {
        updateUserLocation(JSON.parse(localStorage.getItem('lastKnownLocation')), false);
      }
    },
    { enableHighAccuracy: false, timeout: 15000 }
  );
}

function monitorConnectionRecovery() {
  if (navigator.connection) {
    const handler = () => {
      navigator.connection.removeEventListener('change', handler);
      startPositionUpdates();
    };
    navigator.connection.addEventListener('change', handler);
  }
}

function showRecoveryDialog(message, recoveryAction) {
  const dialog = document.createElement('div');
  dialog.innerHTML = `
    <div class="error-dialog">
      <p>${message}</p>
      <button class="retry-btn">Try Again</button>
      <button class="network-btn">Use Approximate Location</button>
    </div>
  `;
  
  dialog.querySelector('.retry-btn').onclick = () => {
    dialog.remove();
    startPositionUpdates();
  };
  
  dialog.querySelector('.network-btn').onclick = () => {
    dialog.remove();
    recoveryAction();
  };
  
  document.body.appendChild(dialog);
}
        
function showPopup(title, message, type = "info", callback = null) {
  const popup = document.createElement("div")
  popup.classList.add("popup")
  popup.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: white;
        padding: 24px;
        border-radius: 16px;
        box-shadow: var(--shadow-lg);
        z-index: 2000;
        text-align: center;
        max-width: 80%;
    `

  const titleElement = document.createElement("h3")
  titleElement.textContent = title
  titleElement.style.cssText = `
        margin-bottom: 16px;
        font-size: 20px;
        font-weight: 600;
        color: var(--dark);
    `

  const messageElement = document.createElement("p")
  messageElement.textContent = message
  messageElement.style.cssText = `
        margin-bottom: 24px;
        font-size: 16px;
        line-height: 1.5;
    `

  const buttonContainer = document.createElement("div")
  buttonContainer.style.cssText = `
        display: flex;
        justify-content: center;
        gap: 12px;
    `

  const okButton = document.createElement("button")
  okButton.textContent = "OK"
  okButton.style.cssText = `
        padding: 10px 24px;
        background-color: var(--primary);
        color: white;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-weight: 500;
        transition: var(--transition-normal);
    `

  okButton.addEventListener("click", () => {
    document.body.removeChild(popup)
    if (callback) callback()
  })

  buttonContainer.appendChild(okButton)

  if (type === "info") {
    const cancelButton = document.createElement("button")
    cancelButton.textContent = "Cancel"
    cancelButton.style.cssText = `
            padding: 10px 24px;
            background-color: #f2f2f2;
            color: var(--dark);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: var(--transition-normal);
        `

    cancelButton.addEventListener("click", () => {
      document.body.removeChild(popup)
    })

    buttonContainer.appendChild(cancelButton)
  }

  popup.appendChild(titleElement)
  popup.appendChild(messageElement)
  popup.appendChild(buttonContainer)
  document.body.appendChild(popup)
}

function recenterMap() {
  const recenterButton = document.getElementById("recenterButton")
  recenterButton.style.backgroundColor = "var(--primary)"
  recenterButton.style.color = "var(--white)"

  // Force map to center on user marker immediately
  if (userMarker && userMarker.getLatLng()) {
    map.closePopup()

    // Get dynamic zoom level based on current speed
    const dynamicZoom = calculateZoomLevel(currentSpeed)

    // Use flyTo instead of setView for smoother animation
    map.flyTo(userMarker.getLatLng(), dynamicZoom, {
      duration: 0.5,
    })

    followUser = true

    // onMapRecentered variable is undeclared. Please fix the import or declare the variable before using it.
    // Declaring onMapRecentered here
    const onMapRecentered = () => {}

    // Make sure any other code knows the map has been recentered
    if (typeof onMapRecentered === "function") {
      onMapRecentered()
    }
  }

  setTimeout(() => {
    recenterButton.style.backgroundColor = "var(--white)"
    recenterButton.style.color = "var(--primary)"
  }, 500)
}

function addUIEventListeners() {
  document.getElementById("recenterButton").addEventListener("click", () => {
    recenterMap()
    resetInactivityTimer()
  })
  document.getElementById("returnButton").addEventListener("click", () => {
    returnToIndex()
    resetInactivityTimer()
  })
  document.getElementById("tipsButton").addEventListener("click", () => {
    toggleNavigationTips()
    resetInactivityTimer()
  })
  document.querySelector(".navigation-tips .close-button").addEventListener("click", () => {
    closeNavigationTips()
    resetInactivityTimer()
  })
}

function addMapEventListeners() {
  const startInteraction = () => {
    isMapInteracting = true
    userIsInteracting = true
    followUser = false
    resetInactivityTimer()
  }

  map.on("movestart zoomstart dragstart", startInteraction)
}

function resetInactivityTimer() {
  clearTimeout(window.inactivityTimer)
  window.inactivityTimer = setTimeout(checkInactivity, INACTIVITY_TIMEOUT)
}

function checkInactivity() {
  console.log("Inactivity timer triggered")
  isMapInteracting = false
  userIsInteracting = false

  // Close any open popups
  map.closePopup()
  map.eachLayer((layer) => {
    if (layer.getPopup && layer.getPopup()?.isOpen()) {
      layer.closePopup()
    }
  })

  if (!isMapInteracting && !userIsInteracting) {
    recenterMap()
  }
}

function closeAllPopups() {
  if (map) {
    map.closePopup()
  }
}

let lastVisitTime = 0
const cooldownPeriod = 3 * 60 * 1000

function showLocationHunt(location) {
  const now = performance.now()
  if (location.id === lastVisitedLocationId && now - lastVisitTime < 180000) {
    console.log(`Location ${location.id} is on cooldown. Skipping.`)
    return
  }

  lastVisitedLocationId = location.id
  lastVisitTime = now
  isLocationHuntVisible = true

  domUpdateManager.schedule("locationHunt", () => {
    const lochuntContainer = document.querySelector(".lochunt-container")
    if (!lochuntContainer) return

    lochuntContainer.innerHTML = ""
    lochuntContainer.style.cssText = `
      display: flex;
      flex-direction: column;
      height: 100%;
      overflow: hidden;
      background-color: #fff;
      max-width: 1200px;
      margin: 0 auto;
      box-shadow: 0 2px 20px rgba(0,0,0,0.025);
      will-change: transform;
    `

    const scrollableContent = document.createElement("div")
    scrollableContent.style.cssText = `
      flex: 1;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      scroll-behavior: smooth;
      will-change: scroll-position;
    `

    const locationImage = document.createElement("img")
    if (preloadedImages.has(location.image)) {
      locationImage.src = location.image
    } else {
      locationImage.src = location.image
      const img = new Image()
      img.crossOrigin = "anonymous"
      img.src = location.image
      preloadedImages.set(location.image, img)
    }
    locationImage.alt = location.name
    locationImage.style.cssText = `
      width: 100%;
      height: 45vh;
      object-fit: cover;
      object-position: center;
    `

    scrollableContent.appendChild(locationImage)

    const contentContainer = document.createElement("div")
    contentContainer.classList.add("lochunt-content")
    contentContainer.style.cssText = `
      padding: 24px;
      display: flex;
      flex-direction: column;
      align-items: center;
      max-width: 800px;
      margin: 0 auto;
    `
    const locationInfo = document.createElement("div")
    locationInfo.classList.add("lochunt-info")
    locationInfo.style.cssText = `
      text-align: center;
      width: 100%;
      margin-bottom: 15px;
    `
    const locationName = document.createElement("h1")
    locationName.textContent = location.name
    locationName.style.cssText = `
      font-size: clamp(1.8rem, 4vw, 2.5rem);
      font-weight: 700;
      color: #1a1a1a;
      margin-bottom: 8px;
      line-height: 1.2;
    `
    const locationCity = document.createElement("p")
    locationCity.textContent = `${location.city}`
    locationCity.style.cssText = `
      font-size: clamp(1.1rem, 2vw, 1.3rem);
      color: #ff0000;
      font-weight: 600;
      margin-bottom: 4px;
    `
    const locationCreator = document.createElement("p")
    locationCreator.textContent = `Created by: ${location.creator}`
    locationCreator.style.cssText = `
      font-size: calc(0.9rem + 0.4vw);
      color: #666666;
      font-weight: 500;
    `
    locationInfo.appendChild(locationName)
    locationInfo.appendChild(locationCity)
    locationInfo.appendChild(locationCreator)
    contentContainer.appendChild(locationInfo)
    const audioPlayerContainer = createAudioPlayer(location.audio)
    contentContainer.appendChild(audioPlayerContainer)
    scrollableContent.appendChild(contentContainer)
    lochuntContainer.appendChild(scrollableContent)
    const blueBar = createBlueBar(location)
    blueBar.style.cssText += `
      position: sticky;
      bottom: 0;
      width: 100%;
    `
    lochuntContainer.appendChild(blueBar)

    requestAnimationFrame(initAudioPlayer)
  })
}

function createAudioPlayer(audioSrc) {
  const audioPlayerContainer = document.createElement("div")
  audioPlayerContainer.classList.add("audio-player")
  audioPlayerContainer.style.cssText = `
    width: 100%;
    max-width: 400px;
    margin-bottom: 15px;
  `

  const audio = document.createElement("audio")
  audio.id = "locationAudio"

  if (preloadedAudio.has(audioSrc)) {
    audio.src = audioSrc
  } else {
    audio.src = audioSrc
    const audioPreload = new Audio()
    audioPreload.preload = "auto"
    audioPreload.src = audioSrc
    preloadedAudio.set(audioSrc, audioPreload)
  }

  const audioProgress = document.createElement("div")
  audioProgress.classList.add("audio-progress")
  audioProgress.style.cssText = `
    width: 100%;
    margin-bottom: 15px;
  `

  const progressContainer = document.createElement("div")
  progressContainer.classList.add("progress")
  progressContainer.style.cssText = `
    height: 8px;
    background-color: #e2e8f0;
    border-radius: 4px;
    cursor: pointer;
    margin-bottom: 12px;
    overflow: hidden;
  `

  const progressBar = document.createElement("div")
  progressBar.id = "progressBar"
  progressBar.classList.add("progress-bar")
  progressBar.style.cssText = `
    height: 100%;
    background-color: #ff0000;
    width: 0%;
    transition: width 0.1s linear;
  `

  progressContainer.appendChild(progressBar)
  audioProgress.appendChild(progressContainer)

  const timeInfo = document.createElement("div")
  timeInfo.classList.add("audio-time")
  timeInfo.style.cssText = `
    display: flex;
    justify-content: space-between;
    color: #4a5568;
    font-size: 0.875rem;
    margin-bottom: 16px;
    font-weight: 500;
  `

  const currentTimeSpan = document.createElement("span")
  currentTimeSpan.id = "currentTime"
  currentTimeSpan.textContent = "0:00"

  const durationSpan = document.createElement("span")
  durationSpan.id = "duration"
  durationSpan.textContent = "0:00"

  timeInfo.appendChild(currentTimeSpan)
  timeInfo.appendChild(durationSpan)

  const audioControls = document.createElement("div")
  audioControls.classList.add("audio-controls")
  audioControls.style.cssText = `
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 24px;
  `

  const rewindBtn = createAudioButton("skip-backward", "rewindBtn")
  const playPauseBtn = createAudioButton("play", "playPauseBtn")
  const forwardBtn = createAudioButton("skip-forward", "forwardBtn")

  audioControls.appendChild(rewindBtn)
  audioControls.appendChild(playPauseBtn)
  audioControls.appendChild(forwardBtn)

  audioPlayerContainer.appendChild(audio)
  audioPlayerContainer.appendChild(audioProgress)
  audioPlayerContainer.appendChild(timeInfo)
  audioPlayerContainer.appendChild(audioControls)

  return audioPlayerContainer
}

function createAudioButton(iconName, id) {
  const button = document.createElement("button")
  button.id = id
  button.classList.add("audio-button")
  button.innerHTML = `<i class="bi bi-${iconName}"></i>`
  button.style.cssText = `
    background-color: white;
    color: #0000ff;
    border: 2px solid #0000ff;
    border-radius: 50%;
    width: 55px;
    height: 55px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.3s ease;
  `

  button.addEventListener("mouseover", () => {
    button.style.backgroundColor = "rgba(0, 0, 255, 0.1)"
  })

  button.addEventListener("mouseout", () => {
    button.style.backgroundColor = "white"
  })

  button.addEventListener("click", () => {
    button.style.backgroundColor = "#0000ff"
    button.style.color = "white"
    button.style.transform = "scale(0.95)"

    setTimeout(() => {
      button.style.backgroundColor = "white"
      button.style.color = "#0000ff"
      button.style.transform = "scale(1)"
    }, 200)
  })

  return button
}

function createBlueBar(location) {
  const blueBar = document.createElement("div")
  blueBar.style.cssText = `
    width: 100%;
    height: 60px;
    background: linear-gradient(to right, #0a1f80, #0f2bab);
    margin-top: auto;
    box-shadow: 0 -2px 10px rgba(0,0,0,0.025);
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0 24px;
    position: sticky;
    bottom: 0;
  `

  const infoButton = document.createElement("button")
  infoButton.innerHTML = '<i class="bi bi-info-circle-fill text-white" style="font-size: 1.5rem; z-index: 2500;"></i>'
  infoButton.classList.add("btn", "btn-sm", "me-2")
  infoButton.onclick = () => {
    if (location && location.imageSource) {
      showPopup("Image Source", location.imageSource)
    } else {
      showPopup("Image Source", "Image source information is not available")
    }
  }

  const feedbackButton = document.createElement("a")
  feedbackButton.href = "mailto:mattreicher@protonmail.com?subject=Feedback"
  feedbackButton.target = "_blank"
  feedbackButton.rel = "noopener noreferrer"
  feedbackButton.innerHTML = '<i class="bi bi-envelope-fill text-white" style="font-size: 1.5rem;"></i>'
  feedbackButton.classList.add("btn", "btn-sm")

  blueBar.appendChild(infoButton)
  blueBar.appendChild(feedbackButton)
  return blueBar
}

function initAudioPlayer() {
  const audio = document.getElementById("locationAudio")
  const playPauseBtn = document.getElementById("playPauseBtn")
  const rewindBtn = document.getElementById("rewindBtn")
  const forwardBtn = document.getElementById("forwardBtn")
  const progressBar = document.getElementById("progressBar")
  const progressContainer = document.querySelector(".progress")
  const currentTimeSpan = document.getElementById("currentTime")
  const durationSpan = document.getElementById("duration")

  if (
    !audio ||
    !playPauseBtn ||
    !rewindBtn ||
    !forwardBtn ||
    !progressBar ||
    !progressContainer ||
    !currentTimeSpan ||
    !durationSpan
  ) {
    console.warn("Audio player elements not found, retrying...")
    requestAnimationFrame(initAudioPlayer)
    return
  }

  let lastProgressUpdate = 0
  const PROGRESS_UPDATE_INTERVAL = 250

  playPauseBtn.addEventListener("click", togglePlay)
  rewindBtn.addEventListener("click", () => seek(-10))
  forwardBtn.addEventListener("click", () => seek(10))

  audio.addEventListener("timeupdate", () => {
    const now = Date.now()
    if (now - lastProgressUpdate > PROGRESS_UPDATE_INTERVAL) {
      lastProgressUpdate = now
      updateProgress()
    }
  })

  audio.addEventListener("loadedmetadata", setDuration)
  audio.addEventListener("ended", () => {
    domUpdateManager.schedule("playPauseBtn", () => {
      playPauseBtn.innerHTML = '<i class="bi bi-play"></i>'
    })
    showAdditionalInfo()
  })

  progressContainer.addEventListener("click", setProgress)

  function togglePlay() {
    if (audio.paused) {
      const playPromise = audio.play()
      if (playPromise !== undefined) {
        playPromise
          .then(() => {
            domUpdateManager.schedule("playPauseBtn", () => {
              playPauseBtn.innerHTML = '<i class="bi bi-pause"></i>'
            })
          })
          .catch((error) => {
            console.error("Audio playback failed:", error)
          })
      }
    } else {
      audio.pause()
      domUpdateManager.schedule("playPauseBtn", () => {
        playPauseBtn.innerHTML = '<i class="bi bi-play"></i>'
      })
    }
  }

  function seek(seconds) {
    audio.currentTime = Math.max(0, Math.min(audio.currentTime + seconds, audio.duration))
  }

  function updateProgress() {
    const percent = (audio.currentTime / audio.duration) * 100
    domUpdateManager.schedule("audioProgress", () => {
      progressBar.style.width = `${percent}%`
      currentTimeSpan.textContent = formatTime(audio.currentTime)
    })
  }

  function setProgress(e) {
    const width = this.clientWidth
    const clickX = e.offsetX
    const duration = audio.duration
    audio.currentTime = (clickX / width) * duration
  }

  function setDuration() {
    domUpdateManager.schedule("audioDuration", () => {
      durationSpan.textContent = formatTime(audio.duration)
    })
  }

  function formatTime(time) {
    const minutes = Math.floor(time / 60)
    const seconds = Math.floor(time % 60)
    return `${minutes}:${seconds.toString().padStart(2, "0")}`
  }
}

    
function showAdditionalInfo() {
    // Find the location using lastVisitedLocationId
    const location = gameLocations.find(loc => loc.id === lastVisitedLocationId);
    console.log('Current location:', location);
    
    // Set flag to indicate we're returning from exhibit
    isReturningFromExhibit = true;
    
    domUpdateManager.schedule('additionalInfo', () => {
        const additionalInfoContainer = document.querySelector('.additional-info-container');
        if (!additionalInfoContainer) {
            console.error("Additional info container not found");
            return;
        }
        
        additionalInfoContainer.style.display = 'block';
        
        // Add transition class
        additionalInfoContainer.classList.add('location-transition');
        
        // Trigger reflow to ensure transition works
        void additionalInfoContainer.offsetWidth;
        
        // Make visible with transition
        additionalInfoContainer.classList.add('visible');
        
        const additionalInfoElement = document.getElementById('additionalInfo');
        if (additionalInfoElement && location) {
            additionalInfoElement.textContent = location.additionalInfo;
        }

        const continueButton = document.getElementById('continueButton');
        if (continueButton) {
            continueButton.onclick = () => {
                // Fade out with transition
                additionalInfoContainer.classList.remove('visible');
                
                // Hide after transition completes
                setTimeout(() => {
                    additionalInfoContainer.style.display = 'none';
                    
                    // Also hide location hunt container with transition
                    const lochuntContainer = document.querySelector('.lochunt-container');
                    if (lochuntContainer) {
                        lochuntContainer.classList.remove('visible');
                        
                        setTimeout(() => {
                            lochuntContainer.style.display = 'none';
                            isLocationHuntVisible = false;
                            updateDistanceBox();
                        }, 500);
                    }
                }, 500);
            };
        }
    });
}

function showDirectionsModal(lat, lng) {
    const modal = document.getElementById('directionsModal');
    if (!modal) {
        console.error("Directions modal not found");
        return;
    }
    
    modal.style.display = 'block';

    const mapBtn = document.getElementById('mapButton');
    const cancelBtn = document.getElementById('cancelButton');

    if (mapBtn) {
        mapBtn.onclick = () => {
            window.open(`https://www.google.com/maps/dir/?api=1&destination=${lat},${lng}`, '_blank');
            modal.style.display = 'none';
        };
    }

    if (cancelBtn) {
        cancelBtn.onclick = () => {
            modal.style.display = 'none';
        };
    }

    window.onclick = (event) => {
        if (event.target == modal) {
            modal.style.display = 'none';
        }
    };
}

function showLocationSummary(locationId) {
    console.log("Showing summary for location ID:", locationId);
    console.log("All locations:", gameLocations);
    console.log("Location IDs:", gameLocations.map(loc => loc.id));
    console.log("Location ID type:", typeof locationId);
    
    if (gameLocations.length > 0) {
        console.log("Location ID type:", typeof gameLocations[0].id);
    }
    
    const location = gameLocations.find(loc => loc.id === locationId);
    console.log("Found location:", location);
    
    if (location && location.summary) {
        domUpdateManager.schedule('summaryModal', () => {
            const modal = document.getElementById('summaryModal');
            const summaryContent = document.getElementById('summaryContent');
            
            if (!modal || !summaryContent) {
                console.error("Summary modal elements not found");
                return;
            }
            
            modal.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
            modal.style.display = 'flex';
            modal.style.justifyContent = 'center';
            modal.style.alignItems = 'center';
            
            const modalContent = modal.querySelector('.modal-content');
            if (modalContent) {
                modalContent.style.cssText = `
                    background-color: white;
                    padding: 30px;
                    border-radius: 10px;
                    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.025);
                    max-width: 500px;
                    width: 90%;
                    max-height: 80vh;
                    overflow-y: auto;
                `;
            }
            
            const closeBtn = modal.querySelector('.close');
            if (closeBtn) {
                closeBtn.remove();
            }
            
            summaryContent.style.textAlign = 'left';
            summaryContent.innerHTML = `
               <h3 class="summary-heading" style="font-size: 22px; margin-bottom: 15px; text-align: center;">${location.name}</h3>
                <p style="line-height: 1.6; margin-bottom: 15px;">
                    ${location.summary}
                </p>
                <p style="line-height: 1.6; margin-bottom: 15px;">
                    <strong>Location:</strong> ${location.today}
                </p>
            `;
            
            const continueButton = document.createElement('button');
            continueButton.textContent = 'Continue';
            continueButton.className = 'summary-button';
            continueButton.style.cssText = `
                display: block;
                width: auto;
                padding: 12px 20px;
                color: white;
                border: none;
                border-radius: 10px;
                cursor: pointer;
                font-size: 18px;
                font-weight: bold;
                transition: background-color 0.3s ease;
                margin: 10px auto -15px;
            `;
            continueButton.onclick = function() {
                modal.style.display = 'none';
            };
            summaryContent.appendChild(continueButton);
            modal.style.display = 'flex';
            window.onclick = function(event) {
                if (event.target === modal) {
                    modal.style.display = 'none';
                }
            };
        });
    } else {
        console.log("Location or summary not found. Location ID:", locationId);
        console.log("Available IDs:", gameLocations.map(loc => loc.id));
        showPopup("Error", "Summary not available for this location.");
    }
}

function startHunt() {
    // Check network status before starting
    if (!navigator.onLine) {
        showErrorMessage("No internet connection. Please connect to the internet and try again.");
        
        // Set a timeout to retry
        setTimeout(() => {
            if (navigator.onLine) {
                startHunt();
            }
        }, 5000); //5 seconds
        
        return;
    }
    
    try {
        // Ensure locations is defined before using it
        if (typeof locations !== 'undefined' && Array.isArray(locations)) {
            gameLocations = locations.sort((a, b) => a.id - b.id);
        } else {
            console.warn("Locations data is not available");
            gameLocations = [];
        }
        
        currentLocationIndex = 0;
        locationCooldowns = {};
        lastVisitedLocationId = null;
        
        // Preload all location images before starting
        preloadImages(gameLocations).then(() => {
            // Hide preloader when images are loaded
            const preloader = document.getElementById('preloader');
            if (preloader) {
                preloader.style.opacity = '0';
                preloader.style.transition = 'opacity 0.5s ease';
                setTimeout(() => {
                    if (preloader && preloader.parentNode) {
                        preloader.parentNode.removeChild(preloader);
                    }
                }, 500);
            }
            
            loadAllLocations();
        }).catch(error => {
            console.error("Error preloading images:", error);
            showErrorMessage("Error loading resources. Please check your connection and try again.");
            
            // Try to continue anyway after a delay
            setTimeout(() => {
                loadAllLocations();
            }, 3000);
        });
    } catch (error) {
        console.error("Error starting hunt:", error);
        showErrorMessage("Error starting the experience. Please reload the page.");
    }
}

function getMarkerColor(tours) {
  switch (tours.toLowerCase()) {
    case "person":
      return "#FFA500"
    case "gangster":
      return "#3f9b0b"
    case "event":
      return "#8B0000"
    case "place":
      return "#0f2bab"
    default:
      return "#0f2bab"
  }
}

function loadAllLocations() {
    gameLocations.forEach((location, index) => {
        const markerColor = getMarkerColor(location.tours);
        
        const locationMarker = L.marker([location.lat, location.lng], {
            icon: L.divIcon({
                className: 'custom-pin-icon',
                html: `<div class="pin-head" style="background-color: ${markerColor};">
                       </div>`,
                iconSize: [30, 30],
                iconAnchor: [15, 30],
            })
        });
                
        const popupContent = `
            <div class="popup-content">
                <img src="${location.image}" alt="${location.name}" class="location-image">
                <h4 class="location-name">
                    <a href="${location.link}" target="_blank" rel="noopener noreferrer" style="text-decoration: none; color: inherit;">${location.name}</a>
                </h4>
                <div class="popup-buttons">
                    <button class="button route-button" data-lat="${location.lat}" data-lng="${location.lng}">Directions</button>
                    <button class="button summary-button" data-location-id="${location.id}">Summary</button>
                </div>
            </div>
        `;
        locationMarker.bindPopup(popupContent, {
            offset: L.point(0, -25),
            className: 'custom-popup'
        });
        
        locationMarker.on('popupopen', function(e) {
            const popup = e.popup._contentNode;
            const routeButton = popup.querySelector('.route-button');
            const summaryButton = popup.querySelector('.summary-button');
            
            if (routeButton) {
                routeButton.addEventListener('click', function(event) {
                    event.preventDefault();
                    const lat = this.getAttribute('data-lat');
                    const lng = this.getAttribute('data-lng');
                    
                    // Create and show the modal
                    const modal = document.createElement('div');
                    modal.className = 'modal';
                    modal.innerHTML = `
                        <div class="modal-content">
                            <h3>Choose your preferred navigation app:</h3>
                            <div class="modal-buttons">
                                <button class="modal-button google-maps">
                                    Google Maps
                                </button>
                                <button class="modal-button waze">
                                    Waze
                                </button>
                                <button class="modal-button apple-maps">
                                    Apple Maps
                                </button>
                                <button class="modal-button cancel">Cancel</button>
                            </div>
                        </div>
                    `;

// direction modal styles
if (!document.querySelector('#modal-styles')) {
    const style = document.createElement('style');
    style.id = 'modal-styles';
    style.textContent = `
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.75);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            padding: 16px;
            backdrop-filter: blur(4px);
        }
        .modal-content {
            background: white;
            padding: 24px 16px;
            border-radius: 16px;
            width: 100%;
            max-width: 320px;
            text-align: center;
            box-shadow: 0 20px 40px rgba(0,0,0,0.2);
        }
        .modal-buttons {
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            align-items: center;
        }
        .modal-button {
            padding: 16px;
            border-radius: 12px;
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: 500;
            border: none;
            cursor: pointer;
            transition: transform 0.15s ease;
        }
        .modal-button:active {
            transform: scale(0.98);
        }
        .google-maps {
            background: #4285F4;
            color: white;
            box-shadow: 0 2px 8px rgba(66,133,244,0.3);
        }
        .waze {
            background: #33ccff;
            color: white;
            box-shadow: 0 2px 8px rgba(51,204,255,0.3);
        }
        .apple-maps {
            background: #000000;
            color: white;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
        .cancel {
            background: #f2f2f2;
            color: #666;
        }
    `;
    document.head.appendChild(style);
}

                    document.body.appendChild(modal);

                    // Handle button clicks
                    modal.querySelector('.google-maps').addEventListener('click', () => {
                        window.location.href = `https://www.google.com/maps/dir/?api=1&destination=${lat},${lng}`;
                        modal.remove();
                    });

                    modal.querySelector('.waze').addEventListener('click', () => {
                        window.location.href = `https://www.waze.com/ul?ll=${lat}%2C${lng}&navigate=yes`;
                        modal.remove();
                    });

                    modal.querySelector('.apple-maps').addEventListener('click', () => {
                        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
                        if (isIOS) {
                            window.location.href = `maps://maps.apple.com/?daddr=${lat},${lng}`;
                            modal.remove();
                        } else {
                            const alertEl = document.createElement('div');
                            alertEl.className = 'modal';
                            alertEl.innerHTML = `
                                <div class="modal-content">
                                    <p>Apple Maps is only available on iOS devices</p>
                                    <button class="modal-button">OK</button>
                                </div>
                            `;
                            document.body.appendChild(alertEl);
                            alertEl.querySelector('button').onclick = () => {
                                alertEl.remove();
                                // Don't remove the original modal when showing the alert
                                return false;
                            };
                        }
                    });
                    
                    modal.querySelector('.cancel').addEventListener('click', () => {
                        modal.remove();
                    });

                    // Close modal if clicking outside
                    modal.addEventListener('click', (e) => {
                        if (e.target === modal) {
                            modal.remove();
                        }
                    });
                });
            }
            
            if (summaryButton) {
                summaryButton.addEventListener('click', function(event) {
                    event.preventDefault();
                    const locationId = this.getAttribute('data-location-id');
                    showLocationSummary(locationId);
                });
            }
        });
        
        markerClusterGroup.addLayer(locationMarker);
    });
    map.addLayer(markerClusterGroup);
    updateDistanceBox();
    resetInactivityTimer();
}    

function returnToIndex() {
  showPopup("Confirm", "Are you ready to exit?", "info", () => {
    window.location.href = "/index.html"
  })
  document.getElementById("returnButton").classList.remove("active")
}

function toggleNavigationTips() {
  const tipsElement = document.querySelector(".navigation-tips")
  const computedStyle = window.getComputedStyle(tipsElement)

  if (computedStyle.display === "none") {
    tipsElement.style.display = "block"
  } else {
    tipsElement.style.display = "none"
  }

  document.getElementById("tipsButton").classList.toggle("active")
}

function closeNavigationTips() {
  document.querySelector(".navigation-tips").style.display = "none"
  document.getElementById("tipsButton").classList.remove("active")
}

// Wait for both DOM and window load events to be safe
document.addEventListener('DOMContentLoaded', function() {
  startPreloader();
});

function startPreloader() {
  // Check if elements exist to prevent errors
  const preloader = document.getElementById('preloader');
  const progressBar = document.getElementById('preloaderProgress');
  
  if (!preloader || !progressBar) {
    console.error('Preloader elements not found');
    return;
  }
  
  // Make sure the preloader is visible
  preloader.style.display = 'flex';
  preloader.style.opacity = '1';
  
  console.log('Preloader started');
  
  // Animate the progress bar over 5 seconds
  let progress = 0;
  const progressInterval = setInterval(function() {
    progress += 2;
    progressBar.style.width = progress + '%';
    
    if (progress >= 100) {
      clearInterval(progressInterval);
    }
  }, 100);
  
  // Force the preloader to stay for exactly 7 seconds
  setTimeout(function() {
    // Ensure progress bar is at 100%
    progressBar.style.width = '100%';
    clearInterval(progressInterval);
    
    // Fade out the preloader
    preloader.style.opacity = '0';
    
    // Remove from DOM after fade completes
    setTimeout(function() {
      preloader.style.display = 'none';
    }, 500);
  }, 7000); //7 seconds for the loading screen.
}

function showLocationHunt(location) {
  const now = performance.now()
  if (location.id === lastVisitedLocationId && now - lastVisitTime < 180000) {
    console.log(`Location ${location.id} is on cooldown. Skipping.`)
    return
  }

  lastVisitedLocationId = location.id
  lastVisitTime = now
  isLocationHuntVisible = true

  domUpdateManager.schedule("locationHunt", () => {
    const lochuntContainer = document.querySelector(".lochunt-container")
    if (!lochuntContainer) return

    lochuntContainer.innerHTML = ""
    lochuntContainer.style.cssText = `
      display: flex;
      flex-direction: column;
      height: 100%;
      overflow: hidden;
      background-color: #fff;
      max-width: 1200px;
      margin: 0 auto;
      box-shadow: 0 2px 20px rgba(0,0,0,0.025);
      will-change: transform;
    `

    const scrollableContent = document.createElement("div")
    scrollableContent.style.cssText = `
      flex: 1;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      scroll-behavior: smooth;
      will-change: scroll-position;
    `

    const locationImage = document.createElement("img")
    if (preloadedImages.has(location.image)) {
      locationImage.src = location.image
    } else {
      locationImage.src = location.image
      const img = new Image()
      img.crossOrigin = "anonymous"
      img.src = location.image
      preloadedImages.set(location.image, img)
    }
    locationImage.alt = location.name
    locationImage.style.cssText = `
      width: 100%;
      height: 45vh;
      object-fit: cover;
      object-position: center;
    `

    scrollableContent.appendChild(locationImage)

    const contentContainer = document.createElement("div")
    contentContainer.classList.add("lochunt-content")
    contentContainer.style.cssText = `
      padding: 24px;
      display: flex;
      flex-direction: column;
      align-items: center;
      max-width: 800px;
      margin: 0 auto;
    `
    const locationInfo = document.createElement("div")
    locationInfo.classList.add("lochunt-info")
    locationInfo.style.cssText = `
      text-align: center;
      width: 100%;
      margin-bottom: 15px;
    `
    const locationName = document.createElement("h1")
    locationName.textContent = location.name
    locationName.style.cssText = `
      font-size: clamp(1.8rem, 4vw, 2.5rem);
      font-weight: 700;
      color: #1a1a1a;
      margin-bottom: 8px;
      line-height: 1.2;
    `
    const locationCity = document.createElement("p")
    locationCity.textContent = `${location.city}`
    locationCity.style.cssText = `
      font-size: clamp(1.1rem, 2vw, 1.3rem);
      color: #ff0000;
      font-weight: 600;
      margin-bottom: 4px;
    `
    const locationCreator = document.createElement("p")
    locationCreator.textContent = `Created by: ${location.creator}`
    locationCreator.style.cssText = `
      font-size: calc(0.9rem + 0.4vw);
      color: #666666;
      font-weight: 500;
    `
    locationInfo.appendChild(locationName)
    locationInfo.appendChild(locationCity)
    locationInfo.appendChild(locationCreator)
    contentContainer.appendChild(locationInfo)
    const audioPlayerContainer = createAudioPlayer(location.audio)
    contentContainer.appendChild(audioPlayerContainer)
    scrollableContent.appendChild(contentContainer)
    lochuntContainer.appendChild(scrollableContent)
    const blueBar = createBlueBar(location)
    blueBar.style.cssText += `
      position: sticky;
      bottom: 0;
      width: 100%;
    `
    lochuntContainer.appendChild(blueBar)

    requestAnimationFrame(initAudioPlayer)
  })
}

function createAudioPlayer(audioSrc) {
  const audioPlayerContainer = document.createElement("div")
  audioPlayerContainer.classList.add("audio-player")
  audioPlayerContainer.style.cssText = `
    width: 100%;
    max-width: 400px;
    margin-bottom: 15px;
  `

  const audio = document.createElement("audio")
  audio.id = "locationAudio"

  if (preloadedAudio.has(audioSrc)) {
    audio.src = audioSrc
  } else {
    audio.src = audioSrc
    const audioPreload = new Audio()
    audioPreload.preload = "auto"
    audioPreload.src = audioSrc
    preloadedAudio.set(audioSrc, audioPreload)
  }

  const audioProgress = document.createElement("div")
  audioProgress.classList.add("audio-progress")
  audioProgress.style.cssText = `
    width: 100%;
    margin-bottom: 15px;
  `

  const progressContainer = document.createElement("div")
  progressContainer.classList.add("progress")
  progressContainer.style.cssText = `
    height: 8px;
    background-color: #e2e8f0;
    border-radius: 4px;
    cursor: pointer;
    margin-bottom: 12px;
    overflow: hidden;
  `

  const progressBar = document.createElement("div")
  progressBar.id = "progressBar"
  progressBar.classList.add("progress-bar")
  progressBar.style.cssText = `
    height: 100%;
    background-color: #ff0000;
    width: 0%;
    transition: width 0.1s linear;
  `

  progressContainer.appendChild(progressBar)
  audioProgress.appendChild(progressContainer)

  const timeInfo = document.createElement("div")
  timeInfo.classList.add("audio-time")
  timeInfo.style.cssText = `
    display: flex;
    justify-content: space-between;
    color: #4a5568;
    font-size: 0.875rem;
    margin-bottom: 16px;
    font-weight: 500;
  `

  const currentTimeSpan = document.createElement("span")
  currentTimeSpan.id = "currentTime"
  currentTimeSpan.textContent = "0:00"

  const durationSpan = document.createElement("span")
  durationSpan.id = "duration"
  durationSpan.textContent = "0:00"

  timeInfo.appendChild(currentTimeSpan)
  timeInfo.appendChild(durationSpan)

  const audioControls = document.createElement("div")
  audioControls.classList.add("audio-controls")
  audioControls.style.cssText = `
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 24px;
  `

  const rewindBtn = createAudioButton("skip-backward", "rewindBtn")
  const playPauseBtn = createAudioButton("play", "playPauseBtn")
  const forwardBtn = createAudioButton("skip-forward", "forwardBtn")

  audioControls.appendChild(rewindBtn)
  audioControls.appendChild(playPauseBtn)
  audioControls.appendChild(forwardBtn)

  audioPlayerContainer.appendChild(audio)
  audioPlayerContainer.appendChild(audioProgress)
  audioPlayerContainer.appendChild(timeInfo)
  audioPlayerContainer.appendChild(audioControls)

  return audioPlayerContainer
}

function createAudioButton(iconName, id) {
  const button = document.createElement("button")
  button.id = id
  button.classList.add("audio-button")
  button.innerHTML = `<i class="bi bi-${iconName}"></i>`
  button.style.cssText = `
    background-color: white;
    color: #0000ff;
    border: 2px solid #0000ff;
    border-radius: 50%;
    width: 55px;
    height: 55px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.3s ease;
  `

  button.addEventListener("mouseover", () => {
    button.style.backgroundColor = "rgba(0, 0, 255, 0.1)"
  })

  button.addEventListener("mouseout", () => {
    button.style.backgroundColor = "white"
  })

  button.addEventListener("click", () => {
    button.style.backgroundColor = "#0000ff"
    button.style.color = "white"
    button.style.transform = "scale(0.95)"

    setTimeout(() => {
      button.style.backgroundColor = "white"
      button.style.color = "#0000ff"
      button.style.transform = "scale(1)"
    }, 200)
  })

  return button
}

function createBlueBar(location) {
  const blueBar = document.createElement("div")
  blueBar.style.cssText = `
    width: 100%;
    height: 60px;
    background: linear-gradient(to right, #0a1f80, #0f2bab);
    margin-top: auto;
    box-shadow: 0 -2px 10px rgba(0,0,0,0.025);
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0 24px;
    position: sticky;
    bottom: 0;
  `

  const infoButton = document.createElement("button")
  infoButton.innerHTML = '<i class="bi bi-info-circle-fill text-white" style="font-size: 1.5rem; z-index: 2500;"></i>'
  infoButton.classList.add("btn", "btn-sm", "me-2")
  infoButton.onclick = () => {
    if (location && location.imageSource) {
      showPopup("Image Source", location.imageSource)
    } else {
      showPopup("Image Source", "Image source information is not available")
    }
  }

  const feedbackButton = document.createElement("a")
  feedbackButton.href = "mailto:mattreicher@protonmail.com?subject=Feedback"
  feedbackButton.target = "_blank"
  feedbackButton.rel = "noopener noreferrer"
  feedbackButton.innerHTML = '<i class="bi bi-envelope-fill text-white" style="font-size: 1.5rem;"></i>'
  feedbackButton.classList.add("btn", "btn-sm")

  blueBar.appendChild(infoButton)
  blueBar.appendChild(feedbackButton)
  return blueBar
}

function initAudioPlayer() {
  const audio = document.getElementById("locationAudio")
  const playPauseBtn = document.getElementById("playPauseBtn")
  const rewindBtn = document.getElementById("rewindBtn")
  const forwardBtn = document.getElementById("forwardBtn")
  const progressBar = document.getElementById("progressBar")
  const progressContainer = document.querySelector(".progress")
  const currentTimeSpan = document.getElementById("currentTime")
  const durationSpan = document.getElementById("duration")

  if (
    !audio ||
    !playPauseBtn ||
    !rewindBtn ||
    !forwardBtn ||
    !progressBar ||
    !progressContainer ||
    !currentTimeSpan ||
    !durationSpan
  ) {
    console.warn("Audio player elements not found, retrying...")
    requestAnimationFrame(initAudioPlayer)
    return
  }

  let lastProgressUpdate = 0
  const PROGRESS_UPDATE_INTERVAL = 250

  playPauseBtn.addEventListener("click", togglePlay)
  rewindBtn.addEventListener("click", () => seek(-10))
  forwardBtn.addEventListener("click", () => seek(10))

  audio.addEventListener("timeupdate", () => {
    const now = Date.now()
    if (now - lastProgressUpdate > PROGRESS_UPDATE_INTERVAL) {
      lastProgressUpdate = now
      updateProgress()
    }
  })

  audio.addEventListener("loadedmetadata", setDuration)
  audio.addEventListener("ended", () => {
    domUpdateManager.schedule("playPauseBtn", () => {
      playPauseBtn.innerHTML = '<i class="bi bi-play"></i>'
    })
    showAdditionalInfo()
  })

  progressContainer.addEventListener("click", setProgress)

  function togglePlay() {
    if (audio.paused) {
      const playPromise = audio.play()
      if (playPromise !== undefined) {
        playPromise
          .then(() => {
            domUpdateManager.schedule("playPauseBtn", () => {
              playPauseBtn.innerHTML = '<i class="bi bi-pause"></i>'
            })
          })
          .catch((error) => {
            console.error("Audio playback failed:", error)
          })
      }
    } else {
      audio.pause()
      domUpdateManager.schedule("playPauseBtn", () => {
        playPauseBtn.innerHTML = '<i class="bi bi-play"></i>'
      })
    }
  }

  function seek(seconds) {
    audio.currentTime = Math.max(0, Math.min(audio.currentTime + seconds, audio.duration))
  }

  function updateProgress() {
    const percent = (audio.currentTime / audio.duration) * 100
    domUpdateManager.schedule("audioProgress", () => {
      progressBar.style.width = `${percent}%`
      currentTimeSpan.textContent = formatTime(audio.currentTime)
    })
  }

  function setProgress(e) {
    const width = this.clientWidth
    const clickX = e.offsetX
    const duration = audio.duration
    audio.currentTime = (clickX / width) * duration
  }

  function setDuration() {
    domUpdateManager.schedule("audioDuration", () => {
      durationSpan.textContent = formatTime(audio.duration)
    })
  }

  function formatTime(time) {
    const minutes = Math.floor(time / 60)
    const seconds = Math.floor(time % 60)
    return `${minutes}:${seconds.toString().padStart(2, "0")}`
  }
}

function showAdditionalInfo() {
    // Find the location using lastVisitedLocationId
    const location = gameLocations.find(loc => loc.id === lastVisitedLocationId);
    console.log('Current location:', location);
    
    // Set flag to indicate we're returning from exhibit
    isReturningFromExhibit = true;
    
    domUpdateManager.schedule('additionalInfo', () => {
        const additionalInfoContainer = document.querySelector('.additional-info-container');
        if (!additionalInfoContainer) {
            console.error("Additional info container not found");
            return;
        }
        
        additionalInfoContainer.style.display = 'block';
        
        // Add transition class
        additionalInfoContainer.classList.add('location-transition');
        
        // Trigger reflow to ensure transition works
        void additionalInfoContainer.offsetWidth;
        
        // Make visible with transition
        additionalInfoContainer.classList.add('visible');
        
        const additionalInfoElement = document.getElementById('additionalInfo');
        if (additionalInfoElement && location) {
            additionalInfoElement.textContent = location.additionalInfo;
        }

        const continueButton = document.getElementById('continueButton');
        if (continueButton) {
            continueButton.onclick = () => {
                // Fade out with transition
                additionalInfoContainer.classList.remove('visible');
                
                // Hide after transition completes
                setTimeout(() => {
                    additionalInfoContainer.style.display = 'none';
                    
                    // Also hide location hunt container with transition
                    const lochuntContainer = document.querySelector('.lochunt-container');
                    if (lochuntContainer) {
                        lochuntContainer.classList.remove('visible');
                        
                        setTimeout(() => {
                            lochuntContainer.style.display = 'none';
                            isLocationHuntVisible = false;
                            updateDistanceBox();
                        }, 500);
                    }
                }, 500);
            };
        }
    });
}

function showDirectionsModal(lat, lng) {
    const modal = document.getElementById('directionsModal');
    if (!modal) {
        console.error("Directions modal not found");
        return;
    }
    
    modal.style.display = 'block';

    const mapBtn = document.getElementById('mapButton');
    const cancelBtn = document.getElementById('cancelButton');

    if (mapBtn) {
        mapBtn.onclick = () => {
            window.open(`https://www.google.com/maps/dir/?api=1&destination=${lat},${lng}`, '_blank');
            modal.style.display = 'none';
        };
    }

    if (cancelBtn) {
        cancelBtn.onclick = () => {
            modal.style.display = 'none';
        };
    }

    window.onclick = (event) => {
        if (event.target == modal) {
            modal.style.display = 'none';
        }
    };
}

function showErrorMessage(message) {
    const errorContainer = document.createElement('div');
    errorContainer.className = 'error-message';
    errorContainer.style.cssText = `
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background-color: #ff3b30;
        color: white;
        padding: 12px 20px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        z-index: 2000;
        max-width: 90%;
        text-align: center;
        font-weight: 500;
    `;
    errorContainer.textContent = message;
    
    document.body.appendChild(errorContainer);
    
    // Auto-dismiss after 5 seconds
    setTimeout(() => {
        errorContainer.style.opacity = '0';
        errorContainer.style.transition = 'opacity 0.5s ease';
        
        setTimeout(() => {
            if (errorContainer.parentNode) {
                errorContainer.parentNode.removeChild(errorContainer);
            }
        }, 500);
    }, 5000);
}

// Fix for isDeviceInMotion function
function isDeviceInMotion() {
  if (!motionSamples || motionSamples.length < 3) {
    return false
  }

  // Calculate average motion magnitude
  const avgMotion = motionSamples.reduce((sum, sample) => {
    return sum + Math.sqrt(sample.x * sample.x + sample.y * sample.y + sample.z * sample.z)
  }, 0) / motionSamples.length

  return avgMotion > MOTION_THRESHOLD
}

// Reset inactivity timer
function resetInactivityTimer() {
  clearTimeout(inactivityTimer)
  inactivityTimer = setTimeout(checkInactivity, INACTIVITY_TIMEOUT)
}

// Check for user inactivity
function checkInactivity() {
  console.log("Inactivity timer triggered")
  isMapInteracting = false
  userIsInteracting = false

  // Close any open popups
  map.closePopup()
  map.eachLayer((layer) => {
    if (layer.getPopup && layer.getPopup()?.isOpen()) {
      layer.closePopup()
    }
  })

  if (!isMapInteracting && !userIsInteracting) {
    recenterMap()
  }
}

// Recenter map on user location
function recenterMap() {
  const recenterButton = document.getElementById("recenterButton")
  if (recenterButton) {
    recenterButton.style.backgroundColor = "var(--primary)"
    recenterButton.style.color = "var(--white)"
  }

  // Force map to center on user marker immediately
  if (userMarker && userMarker.getLatLng()) {
    map.closePopup()

    // Get dynamic zoom level based on current speed
    const dynamicZoom = calculateZoomLevel(currentSpeed)

    // Use flyTo instead of setView for smoother animation
    map.flyTo(userMarker.getLatLng(), dynamicZoom, {
      duration: 0.5,
    })

    followUser = true

    // Make sure any other code knows the map has been recentered
    if (typeof onMapRecentered === "function") {
      onMapRecentered()
    }
  }

  setTimeout(() => {
    if (recenterButton) {
      recenterButton.style.backgroundColor = "var(--white)"
      recenterButton.style.color = "var(--primary)"
    }
  }, 500)
}

// Enhanced motion detection for better accuracy
function enhancedMotionDetection() {
  if (!deviceMotion || !motionSamples || motionSamples.length < 5) {
    return false
  }

  // Calculate motion variance to detect significant movement
  const magnitudes = motionSamples.map(sample => 
    Math.sqrt(sample.x * sample.x + sample.y * sample.y + sample.z * sample.z)
  )
  
  const avgMagnitude = magnitudes.reduce((sum, mag) => sum + mag, 0) / magnitudes.length
  
  // Calculate variance
  const variance = magnitudes.reduce((sum, mag) => sum + Math.pow(mag - avgMagnitude, 2), 0) / magnitudes.length
  
  // Higher variance indicates more erratic movement
  return variance > MOTION_THRESHOLD * 0.5 || avgMagnitude > MOTION_THRESHOLD
}

// Optimize dynamic zoom transitions
function optimizeDynamicZoom(currentZoom, targetZoom) {
  // Apply easing for smoother zoom transitions
  const zoomDiff = targetZoom - currentZoom
  
  // Small differences use faster transitions
  if (Math.abs(zoomDiff) <= 0.5) {
    return {
      newZoom: targetZoom,
      duration: ZOOM_TRANSITION_DURATION * 0.5
    }
  }
  
  // Larger differences use slower, smoother transitions
  return {
    newZoom: currentZoom + (zoomDiff * 0.3),
    duration: ZOOM_TRANSITION_DURATION * 1.2
  }
}

// Improved position prediction for smoother tracking
function predictNextPosition(position, velocity, deltaTime) {
  if (!position || !velocity || !deltaTime) return position
  
  return {
    lat: position.lat + velocity.lat * deltaTime,
    lng: position.lng + velocity.lng * deltaTime,
    accuracy: position.accuracy,
    heading: position.heading,
    timestamp: position.timestamp + deltaTime * 1000,
    speedMPS: position.speedMPS
  }
}

// Initialize the application when DOM is loaded
document.addEventListener("DOMContentLoaded", () => {
  // Initialize the map and start preloading images
  initMap()
  addUIEventListeners()
  addMapEventListeners()
})

// Export the main functions and classes for testing
if (typeof module !== 'undefined' && module.exports) {
  module.exports = {
    KalmanFilter,
    PositionInterpolator,
    AdaptiveKalmanFilterFactory,
    calculateDistance,
    calculateZoomLevel,
    checkLocationProximity,
    processPositionUpdate,
    updateUserLocation,
    enhancedMotionDetection,
    optimizeDynamicZoom,
    predictNextPosition
  };
}

console.log("Kalman filter implementation optimized successfully!");
        
    </script>
</body>
</html>
