<!DOCTYPE html>
<html lang="en">
<head> 
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Minnesota Then | A Museum Without Walls</title>
    <link rel="shortcut icon" type="image/x-icon" href="https://www.mnthen.com/images/mnthenfav.ico">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css">
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css" />
    <link rel="stylesheet" href="https://www.mnthen.com/css/mainmap.css">
    <link rel="stylesheet" href="https://www.mnthen.com/css/mnthen_main_map2.css">

    <style>
        .at-location {
  border: 2px solid red !important;
  box-shadow: 0 0 8px rgba(255, 0, 0, 0.5);
  transition: border-color 0.3s ease, box-shadow 0.3s ease;
}
    </style>
    
</head>
<body>
<!-- Preloader -->
<div id="preloader">
    <div class="preloader-content">
        <img class="logo" src="https://www.mnthen.com/images/logo.webp" alt="Minnesota Then Logo">
        <h1>Minnesota Then</h1>
        <h2>Every step tells a story.</h2>
        <p>Loading the Museum Without Walls</p>
        <div class="progress-container">
            <div class="progress-bar" id="preloaderProgress"></div>
        </div>
    </div>
</div>

    <div id="map"></div>
    <div id="distanceBox">Initializing...</div>

    <div class="lochunt-container">
        <img id="locationImage" src="/placeholder.svg" alt="Location Image">
            <div class="lochunt-content">
                <div class="lochunt-info">
                    <h2 id="locationTitle" class="mb-2 text-primary"></h2>
                        <p id="locationCity" class="text-muted mb-1"></p>
                        <p id="locationCreator" class="text-muted mb-3"></p>
                </div>
            <div class="audio-player">
                <div class="audio-progress">
                    <div class="progress">
                        <div id="progressBar" class="progress-bar" role="progressbar" style="width: 0%"></div>
                    </div>
                </div>
                <div class="audio-time">
                    <span id="currentTime">0:00</span>
                    <span id="duration">0:00</span>
                </div>
                <div class="audio-controls">
                    <button id="rewindBtn" class="audio-button"><i class="fas fa-backward"></i></button>
                    <button id="playPauseBtn" class="audio-button"><i class="fas fa-play"></i></button>
                    <button id="forwardBtn" class="audio-button"><i class="fas fa-forward"></i></button>
                </div>
                <audio id="locationAudio" src="/placeholder.svg"></audio>
            </div>
        </div>
    </div>
    
    <div class="additional-info-container">
       <h3 class="mb-3 text-primary text-center">Did You Know?</h3>
       <p id="additionalInfo" class="mb-3 fs-6"></p>
       <div class="d-flex justify-content-center">
           <button id="continueButton" class="btn btn-primary">Continue</button>
       </div>
    </div>
    
    <div class="map-buttons">
        <button id="recenterButton" class="map-button"><i class="fas fa-crosshairs"></i></button>
        <button id="returnButton" class="map-button"><i class="fas fa-sign-out-alt"></i></button>
        <button id="tipsButton" class="map-button"><i class="fas fa-question-circle"></i></button>
    </div>

    <div class="navigation-tips">
        <button class="close-button">&times;</button>
        <h3>Navigation Tips</h3>
        <ul>
            <li>Use the map to navigate to the marked locations.</li>
            <li>Tap the recenter button to focus on your current position.</li>
            <li>The distance box shows how far you are from the closest location.</li>
            <li>When you're within 20 feet of a location, you'll be able to interact with it.</li>
            <li>Listen to the audio information for each location.</li>
            <li>After the audio, you'll see additional information about the location.</li>
        </ul>
    </div>

    <div id="summaryModal" class="modal" style="display: none;">
        <div class="modal-content">
            <p id="summaryContent"></p>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"></script>
    
    <script src="/locations_test.js?v=1.0.4"></script>

    <script>
// Global variables
let map, userMarker, markerClusterGroup;
const currentLocationIndex = 0;
const visitedLocations = [];
const gameLocations = [];
let inactivityTimer;
const isLocationHuntVisible = false;
let lastPosition = null;
let positionBuffer = [];
const MAX_BUFFER_SIZE = 30; // buffer size for smoother tracking
const DISTANCE_THRESHOLD = 20; // 20 feet to measure threshold distance to marker before opening location page.
const PROXIMITY_THRESHOLD = 55; // 55 feet threshold for zoom changes
let velocity = { lat: 0, lng: 0 };
let isMapInteracting = false;
let followUser = true;
const locationCooldowns = {};
const userIsInteracting = false;
const preloadedImages = new Map(); // Map to store preloaded images
const preloadedAudio = new Map(); // Map to store preloaded audio
let currentSpeed = 0; // Current speed in meters per second
let lastZoomLevel = 17; // Default zoom level
let stationaryPositionHistory = []; // Array to store stationary positions for averaging
let deviceOrientation = null; // Store device orientation data
let deviceMotion = null; // Store device motion data
let orientationPermissionGranted = false;
let geolocationSensor = null; // Store GeolocationSensor instance
let isReturningFromExhibit = false; // Flag to track if returning from exhibit
let isWithinProximity = false; // Flag to track if user is within proximity of a location
let proximityZoomActive = false; // Flag to track if proximity zoom is active

// Enhanced constants for better stabilization
const MICRO_MOVEMENT_THRESHOLD = 0.3; // Meters - threshold for detecting micro-movements (reduced for better stability)
const STATIONARY_ACCURACY_MULTIPLIER = 1.2; // Looser accuracy bounds to prevent false movement detection
const MAX_ACCEPTABLE_ACCURACY = 25; // meters - more lenient accuracy requirement
const STATIONARY_THRESHOLD = 2; // Number of consecutive stationary positions to consider user as stationary (reduced for faster stabilization)
const STATIONARY_TIME_THRESHOLD = 3000; // ms - time to consider user stationary (reduced)
const STATIONARY_CHECK_INTERVAL = 1000; // ms - interval to check if still stationary (reduced)
const VELOCITY_DECAY = 0.92; // Higher value for smoother velocity transitions
const MIN_DISTANCE_THRESHOLD = 1.0; // meters - minimum distance to consider movement (reduced)
const EXTENDED_DISTANCE_THRESHOLD = 80; // meters - distance to consider a significant position change
const UPDATE_INTERVAL = 50; // ms - more frequent updates for smoother movement
const STATIONARY_POSITION_HISTORY_SIZE = 15; // Number of positions to keep for stationary averaging (increased)
const STATIONARY_POSITION_WEIGHT_DECAY = 0.9; // Weight decay for older positions in stationary average (reduced)
const SUDDEN_MOVEMENT_THRESHOLD = 0.8; // meters - threshold for detecting sudden movements (reduced)
const POSITION_JUMP_THRESHOLD = 2.0; // meters - threshold for detecting position jumps (reduced)

// Background handling constants
const BACKGROUND_THRESHOLD = 15000; // ms - time to consider app was in background (reduced)
const INACTIVITY_TIMEOUT = 20000; // ms - time to consider user inactive (reduced)

// Kalman filter parameters - optimized for better movement tracking
const KALMAN_PROCESS_NOISE = 0.00001;
const KALMAN_MEASUREMENT_NOISE_BASE = 0.1;
const KALMAN_STATIONARY_NOISE = 0.000001;

// Animation parameters
const ANIMATION_DURATION = 200; // ms - reduced duration of position animation for more responsive transitions
const HEADING_SMOOTHING = 0.85; // Reduced heading smoothing factor for more responsive direction changes

// Zoom level parameters
const MAX_ZOOM_LEVEL = 17; // Maximum zoom level (stationary)
const MIN_ZOOM_LEVEL = 13; // Minimum zoom level (high speed)
const WALKING_ZOOM_LEVEL = 17; // Zoom level for walking speed
const WALKING_SPEED_THRESHOLD = 1.5; // m/s - threshold for walking speed
const RUNNING_SPEED_THRESHOLD = 4.0; // m/s - threshold for running speed
const DRIVING_SPEED_THRESHOLD = 10.0; // m/s - threshold for driving speed
const ZOOM_TRANSITION_DURATION = 0.5; // seconds - reduced duration of zoom transition for more responsive zooming
const PROXIMITY_ZOOM_LEVEL = 18; // Zoom level when near a location
const DEFAULT_ZOOM_LEVEL = 17; // Default zoom level

// Motion detection parameters
const MOTION_THRESHOLD = 0.8; // Reduced threshold for detecting significant motion
const MOTION_SAMPLE_SIZE = 15; // Increased number of motion samples to keep
const MOTION_CHECK_INTERVAL = 200; // ms - reduced interval to check motion for more responsive detection

// Edge recenter parameters - optimized for better edge recentering
const EDGE_THRESHOLD_PERCENTAGE = 0.25; // Percentage of viewport to trigger recenter (reduced)
const CRITICAL_EDGE_THRESHOLD = 0.125; // Critical threshold for emergency recenter (reduced)
const RECENTER_COOLDOWN = 1500; // ms - minimum time between recenters (reduced)

// Speed accuracy parameters
const SPEED_ACCURACY_THRESHOLD = 5.0; // 5 m/s accuracy is reasonable for most GPS systems

// State variables
let lastUpdateTime = null;
let lastVelocity = { lat: 0, lng: 0 };
let isStationary = false;
let stationaryStartTime = null;
let stationaryCheckTimeout = null;
let lastUpdateTimestamp = null;
let lastHiddenTime = 0;
let lastKnownPosition = null;
const lastVisitedLocationId = null;
let stationaryCount = 0;
let lastSmoothedPosition = null;
let lastRecenterTime = Date.now();
const retryCount = 0;
const stationaryBuffer = [];
let isStabilizing = true; // Flag to track initial stabilization
let lastStationaryPosition = null; // Last stable position when stationary
const motionSamples = []; // Array to store motion samples
let deviceStationaryTime = 0; // Time device has been stationary based on motion sensors
let animationFrameId = null; // Store requestAnimationFrame ID
let renderTimestamp = null; // Last render timestamp
const positionUpdateQueue = []; // Queue for position updates to be processed
let lastHeadingValue = null; // Last heading value
const headingBuffer = []; // Buffer for heading values
let isFirstPositionUpdate = true; // Flag for first position update
let lastRenderPosition = null; // Last rendered position
let mapViewportWidth = 0; // Store map viewport width
let mapViewportHeight = 0; // Store map viewport height
let lastMapCenter = null; // Last map center position
let lastMapZoom = null; // Last map zoom level
let edgeRecenterInProgress = false; // Flag to track edge recentering
const pendingDomUpdates = new Map(); // Map to store pending DOM updates
let usingGeolocationSensorAPI = false; // Flag to track which geolocation API is being used
let positionHistory = []; // Array to store recent position history for jump detection
let suddenMovementCount = 0; // Counter for consecutive sudden movements
let isJumpDetected = false; // Flag to track if a position jump is detected
let stationaryPositionLocked = false; // Flag to indicate if stationary position is locked
let stationaryPositionLockTime = 0; // Time when stationary position was locked
let lastValidPosition = null; // Last valid position before a jump
let stationaryLockTimeout = null; // Timeout for locking stationary position
const lastZoomChangeTime = 0; // Last time zoom was changed due to proximity
let isWatchPositionActive = false; // Flag to track if watchPosition is active
let watchPositionId = null; // ID for watchPosition

// Position interpolator for smooth transitions
const positionInterpolator = {
  currentAnimation: null,
  startTime: null,
  from: null,
  to: null,
  duration: 0,

  start: function (from, to, duration) {
    // Cancel any existing animation
    if (this.currentAnimation) {
      cancelAnimationFrame(this.currentAnimation);
    }

    // Store animation parameters
    this.startTime = performance.now();
    this.from = from;
    this.to = to;
    this.duration = duration;

    // Start animation
    this.update();
  },

  update: function () {
    if (!this.startTime) return;

    const currentTime = performance.now();
    const elapsed = currentTime - this.startTime;
    const progress = Math.min(elapsed / this.duration, 1);

    // Use easing for smoother motion (ease-out)
    const eased = 1 - Math.pow(1 - progress, 3);

    // Interpolate between positions
    const currentPosition = {
      lat: this.from.lat + (this.to.lat - this.from.lat) * eased,
      lng: this.from.lng + (this.to.lng - this.from.lng) * eased,
    };

    // Update marker position
    updateUserMarkerPosition(currentPosition);
    lastRenderPosition = currentPosition;

    // Continue animation if not complete
    if (progress < 1) {
      this.currentAnimation = requestAnimationFrame(() => this.update());
    } else {
      this.currentAnimation = null;
      this.startTime = null;
    }
  },

  cancel: function () {
    if (this.currentAnimation) {
      cancelAnimationFrame(this.currentAnimation);
      this.currentAnimation = null;
      this.startTime = null;
    }
  },

  isInterpolating: function () {
    return this.currentAnimation !== null;
  },
};

// Utility function to calculate distance between two coordinates
function calculateDistance(pos1, pos2) {
  if (
    !pos1 ||
    !pos2 ||
    typeof pos1.lat !== "number" ||
    typeof pos1.lng !== "number" ||
    typeof pos2.lat !== "number" ||
    typeof pos2.lng !== "number"
  ) {
    return Number.POSITIVE_INFINITY;
  }

  // Haversine formula for more accurate distance calculation
  const R = 6371000; // Earth radius in meters
  const lat1 = (pos1.lat * Math.PI) / 180;
  const lat2 = (pos2.lat * Math.PI) / 180;
  const deltaLat = ((pos2.lat - pos1.lat) * Math.PI) / 180;
  const deltaLng = ((pos2.lng - pos1.lng) * Math.PI) / 180;

  const a =
    Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) +
    Math.cos(lat1) * Math.cos(lat2) * Math.sin(deltaLng / 2) * Math.sin(deltaLng / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

  return R * c;
}

// Enhanced Kalman Filter implementation
class KalmanFilter {
  constructor() {
    // State vector [x, y, vx, vy]
    this.x = 0;
    this.y = 0;
    this.vx = 0;
    this.vy = 0;

    // Error covariance matrix
    this.P = [
      [100, 0, 0, 0], // Initial high uncertainty
      [0, 100, 0, 0],
      [0, 0, 10, 0],
      [0, 0, 0, 10],
    ];

    // Process noise
    this.Q = KALMAN_PROCESS_NOISE;

    // Measurement noise (will be adjusted based on GPS accuracy)
    this.R = KALMAN_MEASUREMENT_NOISE_BASE;

    // Time delta
    this.dt = 1.0;

    // Initialized flag
    this.initialized = false;

    // Heading and accuracy tracking
    this.lastHeading = null;
    this.headingConfidence = 0;

    // Stationary mode flag
    this.stationaryMode = false;
    this.stationaryStartTime = 0;

    // Last timestamp
    this.lastTimestamp = null;

    // Adaptive noise parameters
    this.adaptiveNoiseMin = 0.0002;
    this.adaptiveNoiseMax = 0.002;
    this.adaptiveNoiseFactor = 1.0;

    // Position history for jitter detection
    this.positionHistory = [];
    this.maxPositionHistory = 10;
    this.jitterThreshold = 0.35; // meters
    this.jitterCount = 0;

    // Stationary lock
    this.stationaryLocked = false;
    this.stationaryPosition = null;

    // Heading smoothing
    this.headingSmoothingFactor = 0.8;
    this.headingBuffer = [];
    this.headingBufferSize = 7;

    // Velocity smoothing
    this.velocitySmoothingFactor = 0.8;
    this.velocityBuffer = [];
    this.velocityBufferSize = 7;

    // Accuracy-based adaptation
    this.accuracyBuffer = [];
    this.accuracyBufferSize = 7;
    this.lastAccuracy = Number.POSITIVE_INFINITY;
    this.isAccuracyImproving = false;

    // Motion-based adaptation
    this.motionDetected = false;
    this.motionConfidence = 0;

    // Adaptive parameters based on device capabilities
    this.deviceCapabilitiesSet = false;
    this.deviceSupportsHighAccuracy = true;
    this.deviceSupportsMotionSensors = true;
    this.deviceSupportsOrientationSensors = true;

    // Innovation tracking to detect filter divergence
    this.innovationBuffer = [];
    this.innovationBufferSize = 10;
    this.innovationThreshold = 3.0; // standard deviations

    // GNSS receiver type (GPS, GLONASS, Galileo, etc)
    this.receiverType = "GPS";

    // Environment type (urban, rural, indoor, etc)
    this.environmentType = "mixed";
  }

  // Set device capabilities
  setDeviceCapabilities(highAccuracy, motionSensors, orientationSensors) {
    this.deviceCapabilitiesSet = true;
    this.deviceSupportsHighAccuracy = highAccuracy;
    this.deviceSupportsMotionSensors = motionSensors;
    this.deviceSupportsOrientationSensors = orientationSensors;

    // Adjust parameters based on device capabilities
    if (!highAccuracy) {
      this.adaptiveNoiseMin *= 1.5;
      this.adaptiveNoiseMax *= 1.5;
      this.jitterThreshold *= 1.5;
    }

    if (!motionSensors) {
      this.adaptiveNoiseMin *= 1.2;
      this.adaptiveNoiseMax *= 1.2;
    }

    if (!orientationSensors) {
      this.headingSmoothingFactor = 0.9;
    }

    return this;
  }

  // Set the type of GNSS receiver
  setReceiverType(type) {
    this.receiverType = type;

    // Adjust parameters based on receiver type
    switch (type.toUpperCase()) {
      case "GPS_GLONASS":
      case "MULTI_CONSTELLATION":
        this.adaptiveNoiseMin *= 0.8;
        this.adaptiveNoiseMax *= 0.8;
        break;
      case "BASIC_GPS":
        this.adaptiveNoiseMin *= 1.2;
        this.adaptiveNoiseMax *= 1.2;
        break;
      case "HIGH_PRECISION":
        this.adaptiveNoiseMin *= 0.5;
        this.adaptiveNoiseMax *= 0.5;
        break;
    }

    return this;
  }

  // Set the type of environment
  setEnvironmentType(type) {
    this.environmentType = type;

    // Adjust parameters based on environment type
    switch (type.toLowerCase()) {
      case "urban":
        this.adaptiveNoiseMin *= 1.3;
        this.adaptiveNoiseMax *= 1.3;
        this.jitterThreshold *= 0.9;
        break;
      case "rural":
        this.adaptiveNoiseMin *= 0.8;
        this.adaptiveNoiseMax *= 0.8;
        this.jitterThreshold *= 1.2;
        break;
      case "indoor":
        this.adaptiveNoiseMin *= 1.5;
        this.adaptiveNoiseMax *= 1.5;
        this.jitterThreshold *= 0.7;
        break;
    }

    return this;
  }

  // Initialize the filter with first position
  reset(position) {
    if (!position || typeof position.lat !== "number" || typeof position.lng !== "number") {
      console.error("Invalid position for Kalman filter reset");
      return;
    }

    this.x = position.lng;
    this.y = position.lat;
    this.vx = 0;
    this.vy = 0;

    // Reset covariance matrix with high initial uncertainty
    this.P = [
      [100, 0, 0, 0],
      [0, 100, 0, 0],
      [0, 0, 10, 0],
      [0, 0, 0, 10],
    ];

    this.initialized = true;
    this.lastHeading = position.heading || null;
    this.headingConfidence = 0;
    this.stationaryMode = false;
    this.lastTimestamp = position.timestamp || Date.now();
    this.adaptiveNoiseFactor = 1.0;
    this.positionHistory = [];
    this.jitterCount = 0;
    this.stationaryLocked = false;
    this.stationaryPosition = null;
    this.headingBuffer = [];
    this.velocityBuffer = [];
    this.accuracyBuffer = [];
    this.lastAccuracy = position.accuracy || Number.POSITIVE_INFINITY;
    this.isAccuracyImproving = false;
    this.motionDetected = false;
    this.motionConfidence = 0;
    this.innovationBuffer = [];

    return this;
  }

  // Set stationary mode
  setStationaryMode(isStationary) {
    this.stationaryMode = isStationary;

    // When entering stationary mode, reduce velocity to zero
    if (isStationary) {
      this.vx = 0;
      this.vy = 0;
      this.stationaryStartTime = Date.now();

      // Reduce process noise for stationary mode
      this.Q = KALMAN_STATIONARY_NOISE;
      this.adaptiveNoiseFactor = 0.03;
    } else {
      // Reset to normal process noise when moving
      this.Q = KALMAN_PROCESS_NOISE;
      this.adaptiveNoiseFactor = 1.0;
      this.stationaryLocked = false;
      this.stationaryPosition = null;
    }

    return this;
  }

  // Lock stationary position
  lockStationaryPosition(position) {
    if (!this.stationaryMode) return this;

    this.stationaryLocked = true;
    this.stationaryPosition = position;
    console.log("Kalman filter: Stationary position locked");

    return this;
  }

  // Update accuracy buffer and check if accuracy is improving
  updateAccuracyBuffer(accuracy) {
    if (isNaN(accuracy) || accuracy <= 0) {
      accuracy = this.lastAccuracy || 20;
    }

    this.accuracyBuffer.push(accuracy);
    while (this.accuracyBuffer.length > this.accuracyBufferSize) {
      this.accuracyBuffer.shift();
    }

    if (this.accuracyBuffer.length >= 3) {
      const avgRecent =
        (this.accuracyBuffer[this.accuracyBuffer.length - 1] + this.accuracyBuffer[this.accuracyBuffer.length - 2]) / 2;
      const avgOlder =
        (this.accuracyBuffer[0] + (this.accuracyBuffer.length > 1 ? this.accuracyBuffer[1] : this.accuracyBuffer[0])) /
        2;

      this.isAccuracyImproving = avgRecent < avgOlder;
    }

    this.lastAccuracy = accuracy;

    return this;
  }

  // Track innovation to detect filter divergence
  updateInnovationBuffer(innovation) {
    this.innovationBuffer.push(innovation);
    while (this.innovationBuffer.length > this.innovationBufferSize) {
      this.innovationBuffer.shift();
    }

    if (this.innovationBuffer.length >= 5) {
      // Calculate mean and standard deviation of innovations
      const sum = this.innovationBuffer.reduce((acc, val) => acc + val, 0);
      const mean = sum / this.innovationBuffer.length;

      const sumSquaredDiff = this.innovationBuffer.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0);
      const stdDev = Math.sqrt(sumSquaredDiff / this.innovationBuffer.length);

      // If innovation is consistently large, the filter might be diverging
      const latestInnovation = this.innovationBuffer[this.innovationBuffer.length - 1];
      if (Math.abs(latestInnovation - mean) > this.innovationThreshold * stdDev) {
        // Increase uncertainty to force filter to trust measurements more
        for (let i = 0; i < 4; i++) {
          this.P[i][i] *= 2.0;
        }
      }
    }

    return this;
  }

  // Detect jitter in position updates
  detectJitter(newPosition) {
    if (this.positionHistory.length === 0) {
      this.positionHistory.push(newPosition);
      return false;
    }

    const lastPos = this.positionHistory[this.positionHistory.length - 1];
    const distance = calculateDistance(lastPos, newPosition);

    // Add to history
    this.positionHistory.push(newPosition);
    while (this.positionHistory.length > this.maxPositionHistory) {
      this.positionHistory.shift();
    }

    // Check for rapid back-and-forth movement (jitter)
    if (this.positionHistory.length >= 3 && this.stationaryMode) {
      const pos1 = this.positionHistory[this.positionHistory.length - 3];
      const pos2 = this.positionHistory[this.positionHistory.length - 2];
      const pos3 = this.positionHistory[this.positionHistory.length - 1];

      const dist1 = calculateDistance(pos1, pos2);
      const dist2 = calculateDistance(pos2, pos3);

      // If moving back and forth in small distances
      if (
        dist1 < this.jitterThreshold &&
        dist2 < this.jitterThreshold &&
        Math.sign(pos3.lat - pos2.lat) !== Math.sign(pos2.lat - pos1.lat) &&
        Math.sign(pos3.lng - pos2.lng) !== Math.sign(pos2.lng - pos1.lng)
      ) {
        this.jitterCount++;
        return this.jitterCount > 1;
      }
    }

    // Reset jitter count if no jitter detected
    if (distance > this.jitterThreshold) {
      this.jitterCount = 0;
    }

    return false;
  }

  // Smooth heading values
  smoothHeading(newHeading) {
    if (newHeading === null || newHeading === undefined || isNaN(newHeading)) {
      return this.lastHeading;
    }

    // Normalize to 0-360
    newHeading = ((newHeading % 360) + 360) % 360;

    // Add to heading buffer
    this.headingBuffer.push(newHeading);
    while (this.headingBuffer.length > this.headingBufferSize) {
      this.headingBuffer.shift();
    }

    if (this.headingBuffer.length < 2) {
      return newHeading;
    }

    // Use median filter to remove outliers
    if (this.headingBuffer.length >= 3) {
      const sortedHeadings = [...this.headingBuffer].sort((a, b) => a - b);
      const medianHeading = sortedHeadings[Math.floor(sortedHeadings.length / 2)];

      // If new heading is very different from median, it might be an outlier
      const headingDiff = Math.abs(((newHeading - medianHeading + 180) % 360) - 180);
      if (headingDiff > 45 && this.headingConfidence > 0.5) {
        // Use median instead of potentially erroneous new heading
        newHeading = medianHeading;
      }
    }

    // If we have a previous heading, smooth the transition
    if (this.lastHeading !== null) {
      // Normalize headings to 0-360
      const normalizedCurrent = ((newHeading % 360) + 360) % 360;
      const normalizedLast = ((this.lastHeading % 360) + 360) % 360;

      // Calculate the smallest angle between the two headings
      let diff = normalizedCurrent - normalizedLast;
      if (diff > 180) diff -= 360;
      if (diff < -180) diff += 360;

      // Apply adaptive smoothing based on motion and stationary state
      let headingWeight = this.headingSmoothingFactor;
      if (this.stationaryMode) {
        headingWeight = 0.05; // Very smooth when stationary
      } else if (this.motionDetected) {
        headingWeight = Math.min(0.4, headingWeight * (1 + this.motionConfidence)); // More responsive when motion detected
      }

      // Apply smoothing
      const smoothedHeading = normalizedLast + diff * (1 - headingWeight);

      // Normalize back to 0-360
      return ((smoothedHeading % 360) + 360) % 360;
    }

    return newHeading;
  }

  // Smooth velocity values
  smoothVelocity(vx, vy) {
    const speed = Math.sqrt(vx * vx + vy * vy);

    this.velocityBuffer.push(speed);
    while (this.velocityBuffer.length > this.velocityBufferSize) {
      this.velocityBuffer.shift();
    }

    if (this.velocityBuffer.length < 2) {
      return { vx, vy };
    }

    // Calculate median velocity to filter outliers
    if (this.velocityBuffer.length >= 3) {
      const sortedVelocities = [...this.velocityBuffer].sort((a, b) => a - b);
      const medianVelocity = sortedVelocities[Math.floor(sortedVelocities.length / 2)];

      const currentVelocity = speed;

      // If current velocity is drastically different from median, scale it
      if (currentVelocity > medianVelocity * 2) {
        const scale = (medianVelocity * 2) / currentVelocity;
        vx *= scale;
        vy *= scale;
      }
    }

    return { vx, vy };
  }

  // Adjust process noise based on accuracy, motion, and device capabilities
  adjustProcessNoise(accuracy, motionDetected) {
    // Update accuracy buffer and check if accuracy is improving
    this.updateAccuracyBuffer(accuracy);

    // Update motion detection state
    this.motionDetected = motionDetected;
    if (motionDetected) {
      this.motionConfidence = Math.min(1.0, this.motionConfidence + 0.1);
    } else {
      this.motionConfidence = Math.max(0.0, this.motionConfidence - 0.05);
    }

    // Base noise level depends on GPS accuracy
    let noiseLevel =
      this.adaptiveNoiseMin + (this.adaptiveNoiseMax - this.adaptiveNoiseMin) * Math.min(1.0, accuracy / 30.0);

    // Reduce noise when stationary
    if (this.stationaryMode) {
      noiseLevel *= 0.03;
    }

    // Increase noise when motion is detected
    if (this.motionDetected && !this.stationaryMode) {
      noiseLevel *= 1.0 + this.motionConfidence;
    }

    // Adjust based on accuracy trend
    if (this.isAccuracyImproving) {
      noiseLevel *= 0.9;
    } else {
      noiseLevel *= 1.1;
    }

    // Apply adaptive factor
    noiseLevel *= this.adaptiveNoiseFactor;

    // Set process noise
    this.Q = noiseLevel;

    return this;
  }

  // Update the filter with new measurement
  update(position, motionDetected = false) {
    if (!this.initialized) {
      this.reset(position);
      return position;
    }

    if (!position || typeof position.lat !== "number" || typeof position.lng !== "number") {
      console.warn("Invalid position input to Kalman filter");
      return {
        lat: this.y,
        lng: this.x,
        accuracy: position?.accuracy || 20,
        heading: this.lastHeading,
        timestamp: position?.timestamp || Date.now(),
      };
    }

    // If we're in stationary mode and have a locked position, return the locked position
    if (this.stationaryMode && this.stationaryLocked && this.stationaryPosition) {
      return {
        lat: this.stationaryPosition.lat,
        lng: this.stationaryPosition.lng,
        accuracy: position.accuracy,
        heading: this.smoothHeading(position.heading),
        timestamp: position.timestamp,
        speedMPS: 0,
      };
    }

    // Calculate time delta
    const timestamp = position.timestamp || Date.now();
    if (this.lastTimestamp) {
      this.dt = Math.min(Math.max((timestamp - this.lastTimestamp) / 1000, 0.01), 1.0);
    }
    this.lastTimestamp = timestamp;

    // Check for jitter
    const isJittering = this.detectJitter(position);

    // Adjust measurement noise based on GPS accuracy and jitter
    const accuracy = position.accuracy || 20;
    this.R = Math.max(KALMAN_MEASUREMENT_NOISE_BASE, accuracy / 5);

    // If in stationary mode, increase measurement noise to reduce jitter
    if (this.stationaryMode) {
      this.R *= 5.0;
    }

    // If jittering is detected, increase measurement noise significantly
    if (isJittering) {
      this.R *= 10.0;
    }

    // Adjust process noise based on accuracy and motion
    this.adjustProcessNoise(accuracy, motionDetected);

    // State transition matrix
    const F = [
      [1, 0, this.dt, 0],
      [0, 1, 0, this.dt],
      [0, 0, 1, 0],
      [0, 0, 0, 1],
    ];

    // Predict step
    // x = F * x
    const predictedX = this.x + this.dt * this.vx;
    const predictedY = this.y + this.dt * this.vy;
    const predictedVx = this.stationaryMode ? 0 : this.vx;
    const predictedVy = this.stationaryMode ? 0 : this.vy;

    // P = F * P * F' + Q
    const Q = [
      [(this.Q * this.dt * this.dt * this.dt * this.dt) / 4, 0, (this.Q * this.dt * this.dt * this.dt) / 2, 0],
      [0, (this.Q * this.dt * this.dt * this.dt * this.dt) / 4, 0, (this.Q * this.dt * this.dt * this.dt) / 2],
      [(this.Q * this.dt * this.dt * this.dt) / 2, 0, this.Q * this.dt * this.dt, 0],
      [0, (this.Q * this.dt * this.dt * this.dt) / 2, 0, this.Q * this.dt * this.dt],
    ];

    // Matrix multiplication F * P
    const FP = [
      [
        this.P[0][0] + this.dt * this.P[2][0],
        this.P[0][1] + this.dt * this.P[2][1],
        this.P[0][2] + this.dt * this.P[2][2],
        this.P[0][3] + this.dt * this.P[2][3],
      ],
      [
        this.P[1][0] + this.dt * this.P[3][0],
        this.P[1][1] + this.dt * this.P[3][1],
        this.P[1][2] + this.dt * this.P[3][2],
        this.P[1][3] + this.dt * this.P[3][3],
      ],
      [this.P[2][0], this.P[2][1], this.P[2][2], this.P[2][3]],
      [this.P[3][0], this.P[3][1], this.P[3][2], this.P[3][3]],
    ];

    // Matrix multiplication FP * F'
    const predictedP = [
      [
        FP[0][0] + this.dt * FP[0][2] + Q[0][0],
        FP[0][1] + this.dt * FP[0][3] + Q[0][1],
        FP[0][2] + Q[0][2],
        FP[0][3] + Q[0][3],
      ],
      [
        FP[1][0] + this.dt * FP[1][2] + Q[1][0],
        FP[1][1] + this.dt * FP[1][3] + Q[1][1],
        FP[1][2] + Q[1][2],
        FP[1][3] + Q[1][3],
      ],
      [FP[2][0] + Q[2][0], FP[2][1] + Q[2][1], FP[2][2] + Q[2][2], FP[2][3] + Q[2][3]],
      [FP[3][0] + Q[3][0], FP[3][1] + Q[3][1], FP[3][2] + Q[3][2], FP[3][3] + Q[3][3]],
    ];

    // Update step
    // y = z - H * x
    const measurementResidualX = position.lng - predictedX;
    const measurementResidualY = position.lat - predictedY;

    // Track innovation to detect filter divergence
    const innovation = Math.sqrt(
      measurementResidualX * measurementResidualX + measurementResidualY * measurementResidualY,
    );
    this.updateInnovationBuffer(innovation);

    // S = H * P * H' + R
    const S = [
      [predictedP[0][0] + this.R, predictedP[0][1]],
      [predictedP[1][0], predictedP[1][1] + this.R],
    ];

    // Calculate determinant of S
    const detS = S[0][0] * S[1][1] - S[0][1] * S[1][0];

    // Calculate inverse of S
    const invS = [
      [S[1][1] / detS, -S[0][1] / detS],
      [-S[1][0] / detS, S[0][0] / detS],
    ];

    // K = P * H' * inv(S)
    const K = [
      [
        predictedP[0][0] * invS[0][0] + predictedP[0][1] * invS[1][0],
        predictedP[0][0] * invS[0][1] + predictedP[0][1] * invS[1][1],
      ],
      [
        predictedP[1][0] * invS[0][0] + predictedP[1][1] * invS[1][0],
        predictedP[1][0] * invS[0][1] + predictedP[1][1] * invS[1][1],
      ],
      [
        predictedP[2][0] * invS[0][0] + predictedP[2][1] * invS[1][0],
        predictedP[2][0] * invS[0][1] + predictedP[2][1] * invS[1][1],
      ],
      [
        predictedP[3][0] * invS[0][0] + predictedP[3][1] * invS[1][0],
        predictedP[3][0] * invS[0][1] + predictedP[3][1] * invS[1][1],
      ],
    ];

    // x = x + K * y
    this.x = predictedX + K[0][0] * measurementResidualX + K[0][1] * measurementResidualY;
    this.y = predictedY + K[1][0] * measurementResidualX + K[1][1] * measurementResidualY;

    // In stationary mode, keep velocity at zero
    if (this.stationaryMode) {
      this.vx = 0;
      this.vy = 0;
    } else {
      this.vx = predictedVx + K[2][0] * measurementResidualX + K[2][1] * measurementResidualY;
      this.vy = predictedVy + K[3][0] * measurementResidualX + K[3][1] * measurementResidualY;

      // Smooth velocity
      const smoothedVelocity = this.smoothVelocity(this.vx, this.vy);
      this.vx = smoothedVelocity.vx;
      this.vy = smoothedVelocity.vy;
    }

    // P = (I - K * H) * P
    this.P = [
      [
        predictedP[0][0] - (K[0][0] * predictedP[0][0] + K[0][1] * predictedP[1][0]),
        predictedP[0][1] - (K[0][0] * predictedP[0][1] + K[0][1] * predictedP[1][1]),
        predictedP[0][2] - (K[0][0] * predictedP[0][2] + K[0][1] * predictedP[1][2]),
        predictedP[0][3] - (K[0][0] * predictedP[0][3] + K[0][1] * predictedP[1][3]),
      ],
      [
        predictedP[1][0] - (K[1][0] * predictedP[0][0] + K[1][1] * predictedP[1][0]),
        predictedP[1][1] - (K[1][0] * predictedP[0][1] + K[1][1] * predictedP[1][1]),
        predictedP[1][2] - (K[1][0] * predictedP[0][2] + K[1][1] * predictedP[1][2]),
        predictedP[1][3] - (K[1][0] * predictedP[0][3] + K[1][1] * predictedP[1][3]),
      ],
      [
        predictedP[2][0] - (K[2][0] * predictedP[0][0] + K[2][1] * predictedP[1][0]),
        predictedP[2][1] - (K[2][0] * predictedP[0][1] + K[2][1] * predictedP[1][1]),
        predictedP[2][2] - (K[2][0] * predictedP[0][2] + K[2][1] * predictedP[1][2]),
        predictedP[2][3] - (K[2][0] * predictedP[0][3] + K[2][1] * predictedP[1][3]),
      ],
      [
        predictedP[3][0] - (K[3][0] * predictedP[0][0] + K[3][1] * predictedP[1][0]),
        predictedP[3][1] - (K[3][0] * predictedP[0][1] + K[3][1] * predictedP[1][1]),
        predictedP[3][2] - (K[3][0] * predictedP[0][2] + K[3][1] * predictedP[1][2]),
        predictedP[3][3] - (K[3][0] * predictedP[0][3] + K[3][1] * predictedP[1][3]),
      ],
    ];

    // Process heading data
    const smoothedHeading = this.smoothHeading(position.heading);
    this.lastHeading = smoothedHeading;

    // Calculate speed from velocity components
    const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);

    // Create filtered position
    const filteredPosition = {
      lat: this.y,
      lng: this.x,
      accuracy: position.accuracy,
      heading: smoothedHeading,
      timestamp: position.timestamp,
      speedMPS: this.stationaryMode ? 0 : speed * 111000, // Convert from degrees/second to meters/second (approximate)
    };

    // If we're in stationary mode and don't have a locked position yet,
    // check if we should lock the position
    if (this.stationaryMode && !this.stationaryLocked && this.stationaryStartTime) {
      // If we've been stationary for a while, lock the position
      if (Date.now() - this.stationaryStartTime > 2000) {
        this.lockStationaryPosition(filteredPosition);
      }
    }

    return filteredPosition;
  }
}

// Position interpolator for smooth transitions
class PositionInterpolator {
  constructor() {
    this.startPosition = null;
    this.targetPosition = null;
    this.startTime = null;
    this.duration = 0;
    this.isActive = false;
    this.lastInterpolatedPosition = null;
    this.interpolationMethod = "cubic"; // "cubic", "linear", "spring"
    this.springParams = {
      stiffness: 100,
      damping: 10,
      mass: 1,
    };
  }

  setInterpolationMethod(method, params = {}) {
    this.interpolationMethod = method;

    if (method === "spring" && params) {
      this.springParams.stiffness = params.stiffness || 100;
      this.springParams.damping = params.damping || 10;
      this.springParams.mass = params.mass || 1;
    }

    return this;
  }

  start(startPos, targetPos, duration) {
    if (!startPos || !targetPos) return this;

    this.startPosition = { ...startPos };
    this.targetPosition = { ...targetPos };
    this.startTime = performance.now();
    this.duration = duration;
    this.isActive = true;

    // For spring animation, we need initial velocity
    if (this.interpolationMethod === "spring") {
      this.velocity = {
        lat: 0,
        lng: 0,
      };
      this.lastUpdateTime = this.startTime;
    }

    return this;
  }

  update() {
    if (!this.isActive) return null;

    const now = performance.now();
    const elapsed = now - this.startTime;

    if (elapsed >= this.duration && this.interpolationMethod !== "spring") {
      this.isActive = false;
      this.lastInterpolatedPosition = { ...this.targetPosition };
      return this.targetPosition;
    }

    let interpolatedPosition;

    switch (this.interpolationMethod) {
      case "linear":
        interpolatedPosition = this.linearInterpolation(elapsed / this.duration);
        break;
      case "spring":
        interpolatedPosition = this.springInterpolation(now);
        // Check if spring has settled
        const distToTarget = calculateDistance(interpolatedPosition, this.targetPosition);
        if (distToTarget < 0.1 && Math.abs(this.velocity.lat) < 0.0001 && Math.abs(this.velocity.lng) < 0.0001) {
          this.isActive = false;
        }
        break;
      case "cubic":
      default:
        interpolatedPosition = this.cubicInterpolation(elapsed / this.duration);
        break;
    }

    this.lastInterpolatedPosition = interpolatedPosition;
    return interpolatedPosition;
  }

  // Linear interpolation
  linearInterpolation(t) {
    // Clamp t between 0 and 1
    t = Math.max(0, Math.min(1, t));

    return {
      lat: this.startPosition.lat + (this.targetPosition.lat - this.startPosition.lat) * t,
      lng: this.startPosition.lng + (this.targetPosition.lng - this.startPosition.lng) * t,
      accuracy: this.targetPosition.accuracy,
      heading: this.targetPosition.heading,
      timestamp: performance.now(),
      speedMPS: this.targetPosition.speedMPS,
    };
  }

  // Cubic easing function for smoother motion
  cubicInterpolation(t) {
    // Clamp t between 0 and 1
    t = Math.max(0, Math.min(1, t));

    // Apply easing
    const easedT = this.easeOutCubic(t);

    return {
      lat: this.startPosition.lat + (this.targetPosition.lat - this.startPosition.lat) * easedT,
      lng: this.startPosition.lng + (this.targetPosition.lng - this.startPosition.lng) * easedT,
      accuracy: this.targetPosition.accuracy,
      heading: this.interpolateHeading(this.startPosition.heading, this.targetPosition.heading, easedT),
      timestamp: performance.now(),
      speedMPS: this.targetPosition.speedMPS,
    };
  }

  // Spring-based physics interpolation
  springInterpolation(now) {
    const dt = (now - this.lastUpdateTime) / 1000; // Convert to seconds
    this.lastUpdateTime = now;

    // Spring physics parameters
    const k = this.springParams.stiffness;
    const b = this.springParams.damping;
    const m = this.springParams.mass;

    // Calculate spring force for latitude and longitude
    const forceLatSpring = -k * (this.lastInterpolatedPosition.lat - this.targetPosition.lat);
    const forceLngSpring = -k * (this.lastInterpolatedPosition.lng - this.targetPosition.lng);

    // Calculate damping force
    const forceLatDamping = -b * this.velocity.lat;
    const forceLngDamping = -b * this.velocity.lng;

    // Calculate total force
    const totalForceLat = forceLatSpring + forceLatDamping;
    const totalForceLng = forceLngSpring + forceLngDamping;

    // Calculate acceleration (F = ma, so a = F/m)
    const accLat = totalForceLat / m;
    const accLng = totalForceLng / m;

    // Update velocity (v = v0 + a*t)
    this.velocity.lat += accLat * dt;
    this.velocity.lng += accLng * dt;

    // Update position (x = x0 + v*t)
    const newLat = this.lastInterpolatedPosition.lat + this.velocity.lat * dt;
    const newLng = this.lastInterpolatedPosition.lng + this.velocity.lng * dt;

    return {
      lat: newLat,
      lng: newLng,
      accuracy: this.targetPosition.accuracy,
      heading: this.interpolateHeading(this.lastInterpolatedPosition.heading, this.targetPosition.heading, 0.1),
      timestamp: now,
      speedMPS: this.targetPosition.speedMPS,
    };
  }

  // Interpolate heading (special case due to circular nature)
  interpolateHeading(startHeading, endHeading, t) {
    if (startHeading === null || endHeading === null) {
      return endHeading;
    }

    // Normalize headings to 0-360
    startHeading = ((startHeading % 360) + 360) % 360;
    endHeading = ((endHeading % 360) + 360) % 360;

    // Find the shortest path around the circle
    let diff = endHeading - startHeading;
    if (diff > 180) diff -= 360;
    if (diff < -180) diff += 360;

    // Interpolate
    const result = (startHeading + diff * t) % 360;
    return result < 0 ? result + 360 : result;
  }

  // Cubic easing function
  easeOutCubic(t) {
    return 1 - Math.pow(1 - t, 3);
  }

  // Smoother Hermite easing function with configurable smoothness
  easeHermite(t, smoothness = 0) {
    // Clamp t between 0 and 1
    t = Math.max(0, Math.min(1, t));

    // Apply Hermite interpolation with smoothness parameter
    return t * t * (3 - 2 * t - smoothness * (t - 1) * t);
  }

  isInterpolating() {
    return this.isActive;
  }

  cancel() {
    this.isActive = false;
    return this;
  }

  getLastPosition() {
    return this.lastInterpolatedPosition || this.targetPosition || this.startPosition;
  }
}

// Adaptive Kalman Filter Factory
class AdaptiveKalmanFilterFactory {
  static createForDevice(deviceInfo) {
    const filter = new KalmanFilter();

    // Configure based on device type and capabilities
    if (deviceInfo) {
      // Set device capabilities
      filter.setDeviceCapabilities(
        deviceInfo.highAccuracySupported || true,
        deviceInfo.motionSensorsAvailable || true,
        deviceInfo.orientationSensorsAvailable || true,
      );

      // Set receiver type based on device
      if (deviceInfo.gnssType) {
        filter.setReceiverType(deviceInfo.gnssType);
      }

      // Set environment type if known
      if (deviceInfo.environment) {
        filter.setEnvironmentType(deviceInfo.environment);
      }
    }

    return filter;
  }

  static createFilterAndInterpolator(deviceInfo, interpolationMethod = "cubic") {
    const filter = this.createForDevice(deviceInfo);
    const interpolator = new PositionInterpolator().setInterpolationMethod(interpolationMethod);

    return {
      filter,
      interpolator,

      // Convenience method to update and interpolate in one step
      update(position, motionDetected = false, interpolationDuration = 300) {
        // First update the filter
        const filteredPosition = filter.update(position, motionDetected);

        // Then start interpolation to the new filtered position
        if (!interpolator.isInterpolating()) {
          const startPos = interpolator.getLastPosition() || position;
          interpolator.start(startPos, filteredPosition, interpolationDuration);
        } else {
          // Update target while keeping the interpolation
          interpolator.targetPosition = filteredPosition;
        }

        // Return the current interpolated position
        return interpolator.update() || filteredPosition;
      },
    };
  }
}

// DOM update manager - batch DOM updates for better performance
const domUpdateManager = {
  updates: new Map(),
  scheduled: false,

  // Schedule a DOM update
  schedule(id, updateFn) {
    this.updates.set(id, updateFn);

    if (!this.scheduled) {
      this.scheduled = true;
      requestAnimationFrame(() => this.flush());
    }
  },

  // Flush all scheduled DOM updates
  flush() {
    this.updates.forEach((updateFn) => updateFn());
    this.updates.clear();
    this.scheduled = false;
  },
};

// Create tracking system with optimized filter and interpolator
const tracking = AdaptiveKalmanFilterFactory.createFilterAndInterpolator(
  {
    highAccuracySupported: true,
    motionSensorsAvailable: true,
    orientationSensorsAvailable: true,
    gnssType: "GPS_GLONASS",
    environment: "urban",
  },
  "cubic",
);

// Calculate appropriate zoom level based on speed with device movement filtering
function calculateZoomLevel(speedMPS) {
  // Update current speed for global access
  currentSpeed = speedMPS;

  // Check if this is genuine GPS movement or potential device movement
  const isGenuineMovement =
    lastPosition?.hasOwnProperty("speedAccuracy") && lastPosition.speedAccuracy < SPEED_ACCURACY_THRESHOLD;

  // Use a more conservative speed estimate for non-GPS-confirmed movement
  const reliableSpeed = isGenuineMovement ? speedMPS : Math.min(speedMPS, 1.0);

  // Determine target zoom level based on reliable speed
  let targetZoomLevel;

  if (isStationary || reliableSpeed < 0.5) {
    // Stationary or very slow movement
    targetZoomLevel = MAX_ZOOM_LEVEL;
  } else if (reliableSpeed < WALKING_SPEED_THRESHOLD) {
    // Walking speed
    targetZoomLevel = WALKING_ZOOM_LEVEL;
  } else if (reliableSpeed < RUNNING_SPEED_THRESHOLD) {
    // Running speed - linear interpolation between walking and running zoom levels
    const t = (reliableSpeed - WALKING_SPEED_THRESHOLD) / (RUNNING_SPEED_THRESHOLD - WALKING_SPEED_THRESHOLD);
    targetZoomLevel = WALKING_ZOOM_LEVEL - t;
  } else if (reliableSpeed < DRIVING_SPEED_THRESHOLD) {
    // Driving speed - linear interpolation between running and driving zoom levels
    const t = (reliableSpeed - RUNNING_SPEED_THRESHOLD) / (DRIVING_SPEED_THRESHOLD - RUNNING_SPEED_THRESHOLD);
    targetZoomLevel = WALKING_ZOOM_LEVEL - 1 - t;
  } else {
    // High speed
    targetZoomLevel = MIN_ZOOM_LEVEL;
  }

  // For non-GPS-confirmed movement, be more conservative with zoom changes
  let smoothingFactor = isGenuineMovement ? 0.15 : 0.05;

  // For GPS-confirmed movement, check for significant speed changes
  if (isGenuineMovement) {
    const speedChange = lastPosition ? Math.abs(speedMPS - lastPosition.speedMPS) : 0;
    const significantSpeedChange = speedChange > 1.0;
    
    // More responsive when speed changes significantly
    if (significantSpeedChange) {
      smoothingFactor = 0.4;
    }
  }

  // Smooth zoom level changes
  let zoomLevel = targetZoomLevel;
  if (lastZoomLevel !== null) {
    zoomLevel = lastZoomLevel * (1 - smoothingFactor) + targetZoomLevel * smoothingFactor;
  }

  // Ensure more immediate response for significant genuine GPS speed transitions
  if (isGenuineMovement && ((isStationary && speedMPS > 1.0) || (!isStationary && speedMPS < 0.5))) {
    zoomLevel = lastZoomLevel * 0.6 + targetZoomLevel * 0.4;
  }

  // Round to one decimal place for smoother transitions
  zoomLevel = Math.round(zoomLevel * 10) / 10;

  // Clamp to valid zoom range
  zoomLevel = Math.max(MIN_ZOOM_LEVEL, Math.min(MAX_ZOOM_LEVEL, zoomLevel));

  // Update last zoom level
  lastZoomLevel = zoomLevel;

  return zoomLevel;
}

// Enhanced edge detection and recentering for smooth user icon behavior
function performEdgeRecenter(recenterInfo) {
  edgeRecenterInProgress = true;

  // Get current position
  const position = userMarker.getLatLng();

  // Get current speed (in meters per second)
  const currentSpeed = lastPosition?.speedMPS || 0;

  // Only trust GPS-reported speed, not calculated from position changes
  // This helps filter out device movements like shaking
  const isGenuineMovement =
    lastPosition?.hasOwnProperty("speedAccuracy") && lastPosition.speedAccuracy < SPEED_ACCURACY_THRESHOLD;

  // Use a conservative speed value if we're not confident in the movement
  const reliableSpeed = isGenuineMovement ? currentSpeed : Math.min(currentSpeed, 1.0);

  // Calculate appropriate zoom level based on reliable speed
  const dynamicZoom = calculateZoomLevel(reliableSpeed);

  // Get current map center
  const currentCenter = map.getCenter();

  // Calculate optimal center point that keeps the user icon away from edges
  const optimalCenter = calculateOptimalCenter(map, position, recenterInfo.edgeInfo);

  // Calculate edge proximity using your existing function
  const proximity = calculateEdgeProximity(map, position);

  // Find the minimum proximity (closest edge)
  const minProximity = Math.min(proximity.north, proximity.south, proximity.east, proximity.west);

  // Calculate speed factor (0-1) based on reliable speed
  const SPEED_THRESHOLD_SLOW = 1.5;
  const SPEED_THRESHOLD_FAST = 10.0;
  const speedFactor = Math.min(
    1,
    Math.max(0, (reliableSpeed - SPEED_THRESHOLD_SLOW) / (SPEED_THRESHOLD_FAST - SPEED_THRESHOLD_SLOW)),
  );

  // Calculate combined transition factor
  const baseTransitionFactor = Math.max(0.3, Math.min(0.8, minProximity * 2));
  const speedAdjustedFactor = baseTransitionFactor - (speedFactor * 0.3);

  // Blend current and optimal centers for smoother transition
  const blendedCenter = {
    lat: currentCenter.lat + (optimalCenter.lat - currentCenter.lat) * (1 - speedAdjustedFactor),
    lng: currentCenter.lng + (optimalCenter.lng - currentCenter.lng) * (1 - speedAdjustedFactor),
  };

  // Only apply forward bias for genuine GPS movement
  let adjustedCenter = blendedCenter;
  if (lastPosition && isGenuineMovement) {
    const direction = {
      lat: position.lat - lastPosition.lat,
      lng: position.lng - lastPosition.lng,
    };
    
    // Calculate movement magnitude
    const movement = Math.sqrt(direction.lat * direction.lat + direction.lng * direction.lng);
    
    // Only apply forward bias if moving significantly
    if (movement > 0.00001) {
      // Apply forward bias scaled to speed
      const forwardBiasAmount = 0.00005 + (speedFactor * 0.0001);
      
      // Normalize direction and apply forward bias
      adjustedCenter = {
        lat: blendedCenter.lat + (direction.lat / movement) * forwardBiasAmount,
        lng: blendedCenter.lng + (direction.lng / movement) * forwardBiasAmount,
      };
    }
  }

  // Calculate duration based on reliable speed
  const baseDuration = recenterInfo.isEmergency ? 0.2 : ZOOM_TRANSITION_DURATION;
  const speedAdjustedDuration = baseDuration * (1 - (speedFactor * 0.5));

  // Set view with animation
  map.setView([adjustedCenter.lat, adjustedCenter.lng], dynamicZoom, {
    animate: true,
    duration: speedAdjustedDuration,
    noMoveStart: true,
    easeLinearity: 0.3 + (speedFactor * 0.2),
  });

  // Reset edge recenter flag after animation completes
  setTimeout(
    () => {
      edgeRecenterInProgress = false;
    },
    recenterInfo.isEmergency ? 300 : speedAdjustedDuration * 1000,
  );
}

// Check for proximity to locations for zoom level adjustment
function checkProximityForZoom() {
  if (!lastPosition || !gameLocations || gameLocations.length === 0) return;

  // Only check the current location
  const location = gameLocations[currentLocationIndex];
  if (!location) return;

  // Calculate distance to current location
  const distance = calculateDistance(
    { lat: lastPosition.lat, lng: lastPosition.lng },
    { lat: location.lat, lng: location.lng },
  );

  // Convert to feet
  const distanceFeet = Math.round(distance * 3.28084);

  // Check if user is within proximity threshold
  const withinProximity = distanceFeet <= PROXIMITY_THRESHOLD;

  // Only update if proximity state has changed
  if (withinProximity !== isWithinProximity) {
    isWithinProximity = withinProximity;
    
    // Update proximity indicator
    // updateProximityIndicator(isWithinProximity, distanceFeet);
    
    // Adjust zoom level based on proximity
    if (isWithinProximity && !proximityZoomActive) {
      // Zoom in when entering proximity
      proximityZoomActive = true;
      if (map && followUser) {
        map.setZoom(18, {
          animate: true,
          duration: 1.0,
          noMoveStart: true,
        });
      }
    } else if (!isWithinProximity && proximityZoomActive) {
      // Zoom out when leaving proximity
      proximityZoomActive = false;
      if (map && followUser) {
        map.setZoom(17, {
          animate: true,
          duration: 1.0,
          noMoveStart: true,
        });
      }
    }
  }
}

// Calculate optimal center point for recentering
function calculateOptimalCenter(map, position, edgeInfo) {
  if (!map || !position || !edgeInfo) {
    return position;
  }

  const bounds = map.getBounds();
  const currentCenter = map.getCenter();
  const latSpan = bounds.getNorth() - bounds.getSouth();
  const lngSpan = bounds.getEast() - bounds.getWest();

  // Calculate optimal center based on which edges are being approached
  let optimalLat = currentCenter.lat;
  let optimalLng = currentCenter.lng;

  // Adjust latitude if approaching north or south edge
  if (edgeInfo.edges.north) {
    optimalLat = position.lat - latSpan * 0.25;
  } else if (edgeInfo.edges.south) {
    optimalLat = position.lat + latSpan * 0.25;
  }

  // Adjust longitude if approaching east or west edge
  if (edgeInfo.edges.east) {
    optimalLng = position.lng - lngSpan * 0.25;
  } else if (edgeInfo.edges.west) {
    optimalLng = position.lng + lngSpan * 0.25;
  }

  return {
    lat: optimalLat,
    lng: optimalLng,
  };
}

// Determine if map should recenter
function shouldRecenter(map, marker) {
  const now = Date.now();
  
  // Get current position and calculate speed
  const currentPosition = marker.getLatLng();
  let speed = 0;
  
  // Reference to previous state (assuming these are defined elsewhere)
  if (marker._prevPosition && marker._prevTimestamp) {
    const distance = map.distance(marker._prevPosition, currentPosition);
    const timeDiff = (now - marker._prevTimestamp) / 1000;
    speed = timeDiff > 0 ? distance / timeDiff : 0;
  }
  
  // Update tracking values
  marker._prevPosition = currentPosition;
  marker._prevTimestamp = now;
  
  // Apply cooldown, but skip for high speeds
  const skipCooldown = speed > 20; // Skip cooldown if moving faster than 20 m/s
  if (!skipCooldown && now - lastRecenterTime < RECENTER_COOLDOWN) {
    return { needsRecenter: false, speed };
  }
  
  if (!map || !marker) return { needsRecenter: false, speed };
  
  // Dynamic threshold adjustment based on speed
  const speedMultiplier = Math.min(1, 0.5 + (speed * 0.01));
  const dynamicEdgeThreshold = EDGE_THRESHOLD_PERCENTAGE * speedMultiplier;
  const dynamicCriticalThreshold = CRITICAL_EDGE_THRESHOLD * speedMultiplier;
  
  // Pass the speed info to the edge detection
  const edgeInfo = isMarkerNearEdge(map, marker, false, speed);
  const proximities = edgeInfo.proximities;
  
  // Check pixel distance to edges
  const mapSize = map.getSize();
  const pixelPoint = map.latLngToContainerPoint(currentPosition);
  const safetyPixels = Math.min(100, 20 + speed * 2); // Dynamic pixel safety margin
  
  const isPixelCritical = 
    pixelPoint.x < safetyPixels || 
    pixelPoint.y < safetyPixels ||
    pixelPoint.x > (mapSize.x - safetyPixels) || 
    pixelPoint.y > (mapSize.y - safetyPixels);
  
  // Check for critical edge proximity (very close to edge)
  const isCritical = Object.values(proximities).some(
    (proximity) => proximity < dynamicCriticalThreshold
  ) || isPixelCritical;
  
  if (isCritical) {
    lastRecenterTime = now;
    return {
      needsRecenter: true,
      isEmergency: true,
      edgeInfo: edgeInfo,
      speed: speed
    };
  }
  
  // Check for normal edge proximity
  if (edgeInfo.isNearEdge) {
    lastRecenterTime = now;
    return {
      needsRecenter: true,
      isEmergency: false,
      edgeInfo: edgeInfo,
      speed: speed
    };
  }
  
  return {
    needsRecenter: false,
    isEmergency: false,
    edgeInfo: edgeInfo,
    speed: speed
  };
}

// Update user marker position and rotation
function updateUserMarkerPosition(position) {
  if (!userMarker) return;

  // Update marker position
  userMarker.setLatLng([position.lat, position.lng]);

  // Update marker rotation based on heading if available
  if (position.heading !== undefined && position.heading !== null) {
    // Get the marker element
    const markerElement = userMarker.getElement();
    if (markerElement) {
      // Find the direction indicator element
      const directionElement = markerElement.querySelector(".user-marker-direction");
      if (directionElement) {
        // Update the rotation of the direction indicator
        directionElement.style.transform = `rotate(${position.heading}deg)`;
      }
    }
  }

  // Apply visual effects based on speed
  if (position.speedMPS !== undefined) {
    const markerElement = userMarker.getElement();
    if (markerElement) {
      const iconElement = markerElement.querySelector(".user-marker-icon");
      if (iconElement) {
        // Add pulsing effect when moving
        if (position.speedMPS > 0.5) {
          iconElement.classList.add("pulsing");
          // Adjust pulse speed based on movement speed
          const pulseRate = Math.max(0.5, Math.min(2.0, 1.0 + position.speedMPS / 5));
          iconElement.style.animationDuration = `${1 / pulseRate}s`;
        } else {
          iconElement.classList.remove("pulsing");
        }
      }
    }
  }
}

// Reset inactivity timer
function resetInactivityTimer() {
  if (inactivityTimer) {
    clearTimeout(inactivityTimer);
  }

  inactivityTimer = setTimeout(checkInactivity, INACTIVITY_TIMEOUT);
}

// Check for user inactivity
function checkInactivity() {
  isMapInteracting = false;

  if (!isMapInteracting && !userIsInteracting) {
    recenterMap();
  }
}

// Recenter map
function recenterMap() {
  if (map && userMarker) {
    const position = userMarker.getLatLng();
    
    // Get dynamic zoom level based on current speed
    const dynamicZoom = calculateZoomLevel(currentSpeed);

    map.setView([position.lat, position.lng], dynamicZoom, {
      animate: true,
      duration: 0.5,
    });

    followUser = true;
  }
}

// Update distance box (placeholder for your implementation)
function updateDistanceBox() {
  // Implementation depends on your UI
}

// Start hunt (placeholder for your implementation)
function startHunt() {
  // Implementation depends on your game logic
}

// Handle location error
function handleLocationError(error) {
  console.warn("Error getting user location:", error);

  let errorMessage = "An error occurred while getting your location.";
  if (error && error.code) {
    switch (error.code) {
      case 1:
        errorMessage = "Please allow access to your location to use this feature.";
        break;
      case 2:
        errorMessage = "Your location is currently unavailable. Please try again later.";
        break;
      case 3:
        errorMessage = "Getting your location took too long. Please try again.";
        break;
    }
  }

  alert(errorMessage);
}

// Initialize map when DOM is ready
document.addEventListener("DOMContentLoaded", function() {
  initMap();
});

// Check if device is in motion based on motion sensors
function isDeviceInMotion() {
  if (!motionSamples || motionSamples.length < 3) {
    return false;
  }

  // Calculate average motion magnitude
  const avgMotion =
    motionSamples.reduce((sum, sample) => {
      return sum + Math.sqrt(sample.x * sample.x + sample.y * sample.y + sample.z * sample.z);
    }, 0) / motionSamples.length;

  return avgMotion > MOTION_THRESHOLD;
}

// Process device motion data
function handleDeviceMotion(event) {
  if (!event || !event.acceleration) return;

  const motion = {
    x: event.acceleration.x || 0,
    y: event.acceleration.y || 0,
    z: event.acceleration.z || 0,
    timestamp: Date.now(),
  };

  // Add to motion samples
  motionSamples.push(motion);

  // Keep only recent samples
  while (motionSamples.length > MOTION_SAMPLE_SIZE) {
    motionSamples.shift();
  }

  // Update device motion state
  deviceMotion = motion;

  // Check if device is stationary based on motion
  const inMotion = isDeviceInMotion();

  if (!inMotion) {
    deviceStationaryTime += MOTION_CHECK_INTERVAL;
  } else {
    deviceStationaryTime = 0;
  }
}

// Process device orientation data
function handleDeviceOrientation(event) {
  if (!event || event.alpha === null) return;

  deviceOrientation = {
    alpha: event.alpha, // z-axis rotation [0,360)
    beta: event.beta, // x-axis rotation [-180,180)
    gamma: event.gamma, // y-axis rotation [-90,90)
    timestamp: Date.now(),
  };

  // Update heading buffer if we have a compass heading
  if (event.webkitCompassHeading !== undefined) {
    const heading = event.webkitCompassHeading;

    // Add to heading buffer
    headingBuffer.push(heading);

    // Keep only recent headings
    while (headingBuffer.length > 5) {
      headingBuffer.shift();
    }

    // Calculate median heading to filter outliers
    if (headingBuffer.length >= 3) {
      const sortedHeadings = [...headingBuffer].sort((a, b) => a - b);
      lastHeadingValue = sortedHeadings[Math.floor(sortedHeadings.length / 2)];
    }
  }
}

// Initialize the application
function initMap() {
  // Ensure we have access to the Leaflet library
  const L = window.L;

  // Map initialization - using globally declared variables
  map = L.map("map", {
    zoomControl: false,
    attributionControl: false,
    zoomSnap: 0.1,
    zoomDelta: 0.5,
    wheelDebounceTime: 100,
    tapTolerance: 15,
    bounceAtZoomLimits: false,
    preferCanvas: true, // Use canvas renderer for better performance
    renderer: L.canvas({ padding: 0.5 }),
  }).fitWorld();

  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    maxZoom: 18,
    attribution: " OpenStreetMap contributors",
    updateWhenIdle: true,
    updateWhenZooming: false,
    keepBuffer: 2,
  }).addTo(map);

  // Initialize marker cluster group
  markerClusterGroup = L.markerClusterGroup({
    showCoverageOnHover: false,
    zoomToBoundsOnClick: true,
    spiderfyOnMaxZoom: true,
    animate: true,
    animateAddingMarkers: true,
    disableClusteringAtZoom: 17,
    maxClusterRadius: 60,
    iconCreateFunction: (cluster) =>
      L.divIcon({
        html: "<div><span>" + cluster.getChildCount() + "</span></div>",
        className: "marker-cluster-custom",
        iconSize: L.point(40, 40),
      }),
  });

  map.addLayer(markerClusterGroup);

  // Create user icon with custom styling (red)
  const userIcon = L.divIcon({
    className: "user-marker",
    html: '<div class="user-marker-icon"></div><div class="user-marker-direction"></div>',
    iconSize: [20, 20],
    iconAnchor: [10, 10],
  });

  userMarker = L.marker([0, 0], {
    icon: userIcon,
    zIndexOffset: 1000, // Ensure user marker is on top
    interactive: false, // Prevent marker from being clickable
  }).addTo(map);

  // Store map viewport dimensions
  updateMapViewportDimensions();
  showLoadingMessage();

  // Request motion and orientation permissions
  requestMotionPermission();

  // Try to use Geolocation Sensor API first, then fall back to standard Geolocation API
  initGeolocation();

  document.addEventListener("visibilitychange", handleVisibilityChange);

  map.on("movestart zoomstart", () => {
    followUser = false;
    isMapInteracting = true;
  });

  map.on("moveend zoomend", () => {
    isMapInteracting = false;
    resetInactivityTimer();
    updateMapViewportDimensions();
  });

  // Listen for resize events to update viewport dimensions
  window.addEventListener("resize", updateMapViewportDimensions);

  // Start animation loop for smooth rendering
  startAnimationLoop();

  // Enable touch interactions
  map.touchZoom.enable();
  map.doubleClickZoom.enable();

  // Add CSS for user marker direction indicator
  addUserMarkerStyles();
}

// Update map viewport dimensions
function updateMapViewportDimensions() {
  if (map && map._container) {
    mapViewportWidth = map._container.clientWidth;
    mapViewportHeight = map._container.clientHeight;

    // Store current map center and zoom
    if (map.getCenter()) {
      lastMapCenter = map.getCenter();
      lastMapZoom = map.getZoom();
    }
  }
}

// Animation loop for smooth rendering
function startAnimationLoop() {
  // Local variables for optimization (not visible outside)
  let _frameCount = 0;
  let _lastFpsTime = 0;
  let _totalFrames = 0;
  let _accumulatedTime = 0;
  const _frameInterval = 16.667; // ms (60fps)
  const _skipThreshold = 16; // ms
  let _lowPerformanceMode = false;
  let _proximityCheckFrequency = 1;
  let lastProximityCheckTime = 0;

  function animate(timestamp) {
    // Calculate delta time
    const deltaTime = renderTimestamp ? (timestamp - renderTimestamp) / 1000 : 0;
    renderTimestamp = timestamp;

    // Performance tracking (hidden implementation detail)
    if (!_lastFpsTime) _lastFpsTime = timestamp;
    _frameCount++;
    _totalFrames++;
    if (timestamp - _lastFpsTime > 1000) {
      const fps = Math.round((_frameCount * 1000) / (timestamp - _lastFpsTime));
      _lowPerformanceMode = fps < 30;
      _proximityCheckFrequency = _lowPerformanceMode ? 3 : 1;
      _frameCount = 0;
      _lastFpsTime = timestamp;
    }

    // Frame limiting (hidden implementation detail)
    _accumulatedTime += deltaTime * 1000;
    if (_accumulatedTime < _skipThreshold) {
      animationFrameId = requestAnimationFrame(animate);
      return;
    }

    try {
      // Process position updates
      processPositionUpdateQueue();

      // Update interpolated position
      if (positionInterpolator && positionInterpolator.isInterpolating()) {
        const interpolatedPosition = positionInterpolator.update();
        if (interpolatedPosition) {
          // Update marker position and rotation
          updateUserMarkerPosition(interpolatedPosition);
          lastRenderPosition = interpolatedPosition;
        }
      }

      // Check if marker is near edge and recenter if needed
      if (followUser && !isMapInteracting && !edgeRecenterInProgress) {
        const recenterInfo = shouldRecenter(map, userMarker);
        if (recenterInfo.needsRecenter) {
          performEdgeRecenter(recenterInfo);
        }
      }

      // Update dynamic zoom based on speed
      updateDynamicZoom();

      // Check for proximity to locations
      if (Date.now() - lastProximityCheckTime > 500) {
        checkProximityForZoom();
        lastProximityCheckTime = Date.now();
      }

      // Reset accumulated time (hidden implementation detail)
      _accumulatedTime -= _frameInterval;
      if (_accumulatedTime > _frameInterval * 2) {
        _accumulatedTime = _frameInterval;
      }

      // Request next frame
      animationFrameId = requestAnimationFrame(animate);
    } catch (error) {
      // Error handling (hidden implementation detail)
      console.error("Error in animation loop:", error);
      animationFrameId = requestAnimationFrame(animate);
    }
  }

  // Start animation loop
  animationFrameId = requestAnimationFrame(animate);
}

// Process queued position updates
function processPositionUpdateQueue() {
  // Skip if no updates in queue
  if (positionUpdateQueue.length === 0) return;

  // Process all updates in the queue
  while (positionUpdateQueue.length > 0) {
    const update = positionUpdateQueue.shift();

    // Apply the update (assuming update contains position data)
    if (update && update.coords) {
      const position = {
        lat: update.coords.latitude,
        lng: update.coords.longitude,
        accuracy: update.coords.accuracy,
        heading: update.coords.heading,
        speedMPS: update.coords.speed,
        speedAccuracy: update.coords.speedAccuracy,
        timestamp: update.timestamp,
      };

      // Process the position update
      processPositionUpdate(position);
    }
  }
}

// Process position update
function processPositionUpdate(position) {
  // Skip if invalid position
  if (!position || typeof position.lat !== "number" || typeof position.lng !== "number") {
    return;
  }

  // This prevents disorienting visual effects when position changes significantly
  if (lastRenderPosition && calculateDistance(lastRenderPosition, position) > EXTENDED_DISTANCE_THRESHOLD) {
    console.debug(
      `Large position change detected (${calculateDistance(lastRenderPosition, position).toFixed(2)}m). Skipping interpolation.`,
    );
    updateUserMarkerPosition(position); // Direct update without animation
    lastRenderPosition = position;
    return; // Skip the rest of the interpolation logic
  }

  // Normal case: Apply smooth interpolation between positions
  if (lastRenderPosition && !isFirstPositionUpdate) {
    if (positionInterpolator) {
      // Use slower animation when stationary for more stability
      positionInterpolator.start(lastRenderPosition, position, isStationary ? 300 : ANIMATION_DURATION);
    } else {
      console.warn("Position interpolator not available, using direct position update");
      updateUserMarkerPosition(position);
      lastRenderPosition = position;
    }
  } else {
    // First position update - set directly without animation
    updateUserMarkerPosition(position);
    lastRenderPosition = position;
    isFirstPositionUpdate = false;
  }

  // Handle auto-recentering and zoom adjustments
  if (followUser && !isMapInteracting) {
    const recenterInfo = shouldRecenter(map, userMarker);
    if (recenterInfo.needsRecenter) {
      performEdgeRecenter(recenterInfo);
    } else if (Math.abs(map.getZoom() - calculateZoomLevel(position.speedMPS)) > 0.5) {
      const newZoom = calculateZoomLevel(position.speedMPS);
      map.setZoom(newZoom, {
        animate: true,
        duration: ZOOM_TRANSITION_DURATION,
      });
    }
  }
}

// Variables for dynamic zoom functionality
const speedSamples = [];
const MAX_SPEED_SAMPLES = 5;
let lastSpeedForZoom = 0;
let targetZoomLevel = MAX_ZOOM_LEVEL;
let lastZoomUpdateTime = 0;
const ZOOM_UPDATE_INTERVAL = 500; // ms - interval between zoom updates

// Update speed samples for dynamic zoom
function updateSpeedSamples(position) {
  if (!position || typeof position.speedMPS !== "number") return;

  // Add speed to samples
  speedSamples.push(position.speedMPS);

  // Keep only recent samples
  while (speedSamples.length > MAX_SPEED_SAMPLES) {
    speedSamples.shift();
  }
}

// Update zoom level based on speed
function updateDynamicZoom() {
  const now = Date.now();
  if (now - lastZoomUpdateTime < ZOOM_UPDATE_INTERVAL) return;
  lastZoomUpdateTime = now;

  // Skip if user is interacting with map
  if (isMapInteracting || userIsInteracting) return;

  // Calculate average speed from samples
  let avgSpeed = 0;
  if (speedSamples.length > 0) {
    avgSpeed = speedSamples.reduce((sum, speed) => sum + speed, 0) / speedSamples.length;
  } else if (lastPosition) {
    avgSpeed = lastPosition.speedMPS || 0;
  }

  // Smooth speed changes
  const smoothedSpeed = lastSpeedForZoom * 0.7 + avgSpeed * 0.3;
  lastSpeedForZoom = smoothedSpeed;

  // Calculate optimal zoom level
  const optimalZoom = calculateZoomLevel(smoothedSpeed);

  // Only update if zoom level needs to change
  if (Math.abs(optimalZoom - targetZoomLevel) >= 0.1) {
    targetZoomLevel = optimalZoom;

    // Apply zoom change with smooth animation
    if (map && followUser) {
      const currentZoom = map.getZoom();
      const zoomDiff = Math.abs(currentZoom - targetZoomLevel);

      // Use faster transition for larger zoom changes
      const duration = zoomDiff > 1 ? 0.3 : ZOOM_TRANSITION_DURATION;

      map.setZoom(targetZoomLevel, {
        animate: true,
        duration: duration,
        noMoveStart: true,
      });
    }
  }
}

// Calculate optimal zoom level based on speed
function calculateOptimalZoom(speed) {
  // Stationary or very slow
  if (speed < 0.5) {
    return MAX_ZOOM_LEVEL;
  }
  // Walking speed
  else if (speed < WALKING_SPEED_THRESHOLD) {
    return WALKING_ZOOM_LEVEL;
  }
  // Running speed - linear interpolation
  else if (speed < RUNNING_SPEED_THRESHOLD) {
    const t = (speed - WALKING_SPEED_THRESHOLD) / (RUNNING_SPEED_THRESHOLD - WALKING_SPEED_THRESHOLD);
    return WALKING_ZOOM_LEVEL - t;
  }
  // Driving speed - linear interpolation
  else if (speed < DRIVING_SPEED_THRESHOLD) {
    const t = (speed - RUNNING_SPEED_THRESHOLD) / (DRIVING_SPEED_THRESHOLD - RUNNING_SPEED_THRESHOLD);
    return WALKING_ZOOM_LEVEL - 1 - t * 2;
  }
  // High speed
  else {
    return MIN_ZOOM_LEVEL;
  }
}

// Optimize dynamic zoom transitions
function optimizeDynamicZoom(currentZoom, targetZoom) {
  // Apply easing for smoother zoom transitions
  const zoomDiff = targetZoom - currentZoom;

  // Small differences use faster transitions
  if (Math.abs(zoomDiff) <= 0.5) {
    return {
      newZoom: targetZoom,
      duration: ZOOM_TRANSITION_DURATION * 0.5,
    };
  }

  // Larger differences use slower, smoother transitions
  return {
    newZoom: currentZoom + zoomDiff * 0.3,
    duration: ZOOM_TRANSITION_DURATION * 1.2,
  };
}

// Enhanced motion detection for better accuracy
function enhancedMotionDetection() {
  if (!deviceMotion || !motionSamples || motionSamples.length < 5) {
    return false;
  }

  // Calculate motion variance to detect significant movement
  const magnitudes = motionSamples.map((sample) =>
    Math.sqrt(sample.x * sample.x + sample.y * sample.y + sample.z * sample.z),
  );

  const avgMagnitude = magnitudes.reduce((sum, mag) => sum + mag, 0) / magnitudes.length;

  // Calculate variance
  const variance = magnitudes.reduce((sum, mag) => sum + Math.pow(mag - avgMagnitude, 2), 0) / magnitudes.length;

  // Higher variance indicates more erratic movement
  return variance > MOTION_THRESHOLD * 0.5 || avgMagnitude > MOTION_THRESHOLD;
}

// Improved position prediction for smoother tracking
function predictNextPosition(position, velocity, deltaTime) {
  if (!position || !velocity || !deltaTime) return position;

  return {
    lat: position.lat + velocity.lat * deltaTime,
    lng: position.lng + velocity.lng * deltaTime,
    accuracy: position.accuracy,
    heading: position.heading,
    timestamp: position.timestamp + deltaTime * 1000,
    speedMPS: position.speedMPS,
  };
}

// Calculate proximity to map edges
function calculateEdgeProximity(map, point) {
  const bounds = map.getBounds();
  const latSpan = bounds.getNorth() - bounds.getSouth();
  const lngSpan = bounds.getEast() - bounds.getWest();

  // Add pixel-based proximity calculation for more accurate edge detection
  const mapSize = map.getSize();
  const pixelPoint = map.latLngToContainerPoint(point);

  return {
    north: Math.abs(point.lat - bounds.getNorth()) / latSpan,
    south: Math.abs(point.lat - bounds.getSouth()) / latSpan,
    east: Math.abs(point.lng - bounds.getEast()) / lngSpan,
    west: Math.abs(point.lng - bounds.getWest()) / lngSpan,
    // Add pixel-based proximities
    northPx: pixelPoint.y / mapSize.y,
    southPx: (mapSize.y - pixelPoint.y) / mapSize.y,
    eastPx: (mapSize.x - pixelPoint.x) / mapSize.x,
    westPx: pixelPoint.x / mapSize.x,
  };
}

// Check if marker is near edge of map
function isMarkerNearEdge(map, marker, isStrict = false, speed = 0) {
  // Validate inputs
  if (!map || !marker) {
    return {
      isNearEdge: false,
      edges: { north: false, south: false, east: false, west: false },
      proximities: { north: 1, south: 1, east: 1, west: 1 },
    };
  }

  // Calculate edge proximities
  const bounds = map.getBounds();
  const currentPos = marker.getLatLng();
  const proximities = {
    north: Math.abs(currentPos.lat - bounds.getNorth()) / (bounds.getNorth() - bounds.getSouth()),
    south: Math.abs(currentPos.lat - bounds.getSouth()) / (bounds.getNorth() - bounds.getSouth()),
    east: Math.abs(currentPos.lng - bounds.getEast()) / (bounds.getEast() - bounds.getWest()),
    west: Math.abs(currentPos.lng - bounds.getWest()) / (bounds.getEast() - bounds.getWest()),
  };

  // Determine threshold
  let threshold = isStrict ? 0.12 : 0.25; // Default edge threshold percentage

  // Scale with speed if provided
  if (speed > 0) {
    threshold = Math.min(0.35, threshold + speed * 0.005);
  }

  // Check pixel proximity
  const safetyMarginPixels = 30;
  let isPixelClose = false;

  if (safetyMarginPixels > 0) {
    const pxPos = map.latLngToContainerPoint(currentPos);
    const pxSize = map.getSize();
    isPixelClose =
      pxPos.x < safetyMarginPixels ||
      pxPos.y < safetyMarginPixels ||
      pxPos.x > pxSize.x - safetyMarginPixels ||
      pxPos.y > pxSize.y - safetyMarginPixels;
  }

  // Edge detection
  const edges = {
    north: proximities.north < threshold,
    south: proximities.south < threshold,
    east: proximities.east < threshold,
    west: proximities.west < threshold,
  };

  const isNearEdge = Object.values(edges).some(Boolean) || isPixelClose;

  // Return results
  return {
    isNearEdge,
    edges,
    proximities,
    currentSpeed: speed,
    isPixelClose,
  };
}

// Request device motion and orientation permissions
function requestMotionPermission() {
  if (typeof DeviceMotionEvent !== "undefined" && typeof DeviceMotionEvent.requestPermission === "function") {
    DeviceMotionEvent.requestPermission()
      .then((response) => {
        if (response === "granted") {
          window.addEventListener("devicemotion", handleDeviceMotion, true);
        }
      })
      .catch(console.error);
  } else {
    window.addEventListener("devicemotion", handleDeviceMotion, true);
  }

  if (typeof DeviceOrientationEvent !== "undefined" && typeof DeviceOrientationEvent.requestPermission === "function") {
    DeviceOrientationEvent.requestPermission()
      .then((response) => {
        if (response === "granted") {
          orientationPermissionGranted = true;
          window.addEventListener("deviceorientation", handleDeviceOrientation, true);
        }
      })
      .catch(console.error);
  } else {
    window.addEventListener("deviceorientation", handleDeviceOrientation, true);
    orientationPermissionGranted = true;
  }
}

// Initialize geolocation with priority for Geolocation Sensor API
function initGeolocation() {
  // Declaring GeolocationSensor here
  const GeolocationSensor = window.GeolocationSensor;

  if ("GeolocationSensor" in window) {
    try {
      console.log("Trying GeolocationSensor API");
      geolocationSensor = new GeolocationSensor({ frequency: 1 });

      geolocationSensor.addEventListener("reading", () => {
        const position = {
          coords: {
            latitude: geolocationSensor.latitude,
            longitude: geolocationSensor.longitude,
            accuracy: geolocationSensor.accuracy,
            altitude: geolocationSensor.altitude,
            altitudeAccuracy: geolocationSensor.altitudeAccuracy,
            heading: geolocationSensor.heading,
            speed: geolocationSensor.speed,
          },
          timestamp: geolocationSensor.timestamp,
        };

        if (!lastPosition) {
          initializeUserLocation(position);
        } else {
          handlePositionUpdate(position);
        }
      });

      geolocationSensor.addEventListener("error", (error) => {
        console.warn("GeolocationSensor error:", error);
        // Fall back to standard Geolocation API
        useStandardGeolocation();
      });

      geolocationSensor.start();
      usingGeolocationSensorAPI = true;
      console.log("Using GeolocationSensor API");
    } catch (error) {
      console.warn("GeolocationSensor error:", error);
      // Fall back to standard Geolocation API
      useStandardGeolocation();
    }
  } else {
    // Fall back to standard Geolocation API
    useStandardGeolocation();
  }
}

// Standard Geolocation API fallback
function useStandardGeolocation() {
  console.log("Using standard Geolocation API");
  usingGeolocationSensorAPI = false;

  if ("geolocation" in navigator) {
    const options = {
      enableHighAccuracy: true,
      timeout: 30000, // Reduced timeout for faster fallback
      maximumAge: 0,
    };

    // Try first time
    navigator.geolocation.getCurrentPosition(
      initializeUserLocation,
      (error) => {
        // On error, try one more time before falling back
        navigator.geolocation.getCurrentPosition(initializeUserLocation, handleLocationError, options);
      },
      options,
    );
  } else {
    showPopup("Geolocation is not supported by your browser");
    map.setView([44.9778, -93.265], 17);
    hideLoadingMessage();
  }
}

// Initialize user location
function initializeUserLocation(position) {
  console.log("Initial position data:", JSON.stringify(position));

  if (!position || !position.coords) {
    console.error("Invalid initial position object");
    handleLocationError(new Error("Invalid initial position"));
    return;
  }

  const { latitude: userLat, longitude: userLng, accuracy } = position.coords;

  if (isNaN(userLat) || isNaN(userLng)) {
    console.error("Invalid initial coordinates:", { userLat, userLng });
    handleLocationError(new Error("Invalid initial coordinates"));
    return;
  }

  console.log("Valid initial position:", { userLat, userLng, accuracy });

  try {
    // Set initial marker position
    updateUserMarkerPosition({
      lat: userLat,
      lng: userLng,
      accuracy: accuracy,
      heading: position.coords.heading,
      timestamp: Date.now(),
      speedMPS: 0,
    });

    map.setView([userLat, userLng], DEFAULT_ZOOM_LEVEL);

    // Initialize Kalman filter with first position
    tracking.filter.reset({
      lat: userLat,
      lng: userLng,
      accuracy: accuracy,
      heading: position.coords.heading,
      timestamp: Date.now(),
    });

    // Initialize stationary position
    lastStationaryPosition = {
      lat: userLat,
      lng: userLng,
      accuracy: accuracy,
      heading: position.coords.heading,
      timestamp: Date.now(),
      speedMPS: 0,
    };

    // Initialize last render position
    lastRenderPosition = {
      lat: userLat,
      lng: userLng,
      accuracy: accuracy,
      heading: position.coords.heading,
      timestamp: Date.now(),
      speedMPS: 0,
    };

    // Initialize last valid position
    lastValidPosition = {
      lat: userLat,
      lng: userLng,
      accuracy: accuracy,
      heading: position.coords.heading,
      timestamp: Date.now(),
      speedMPS: 0,
    };

    // Show stabilizing modal
    hideLoadingMessage();
    showStabilizingModal();

    // Start position updates
    startPositionUpdates();
    startHunt();
  } catch (error) {
    console.error("Error setting initial user location:", error);
    handleLocationError(error);
  }
}

// Start position updates
function startPositionUpdates() {
  // If already using GeolocationSensor API, don't start again
  if (usingGeolocationSensorAPI) {
    console.log("Position updates already using GeolocationSensor API");
    return;
  }

  // Use standard Geolocation API with high frequency updates
  watchPositionId = navigator.geolocation.watchPosition(handlePositionUpdate, handleLocationError, {
    enableHighAccuracy: true,
    maximumAge: 0,
    timeout: 10000,
  });
  isWatchPositionActive = true;
  console.log("Position updates using standard Geolocation API");
}

// Handle position update
function handlePositionUpdate(position) {
  if (!position?.coords?.latitude || !position?.coords?.longitude) {
    console.warn("Invalid position data received");
    return;
  }
  updateUserLocation(position);
}

// Handle visibility change
function handleVisibilityChange() {
  if (document.hidden) {
    lastHiddenTime = Date.now();
    lastKnownPosition = userMarker ? userMarker.getLatLng() : null;

    // Cancel any active interpolation
    if (positionInterpolator) {
      positionInterpolator.cancel();
    }

    // Cancel animation frame
    if (animationFrameId) {
      cancelAnimationFrame(animationFrameId);
      animationFrameId = null;
    }

    // Stop GeolocationSensor if using it
    if (usingGeolocationSensorAPI && geolocationSensor) {
      geolocationSensor.stop();
    }
  } else {
    const hiddenDuration = Date.now() - lastHiddenTime;
    if (hiddenDuration > BACKGROUND_THRESHOLD) {
      updateLocationAfterBackground();
    } else {
      map.invalidateSize();

      // Restart animation loop
      if (!animationFrameId) {
        startAnimationLoop();
      }

      // Restart GeolocationSensor if using it
      if (usingGeolocationSensorAPI && geolocationSensor) {
        geolocationSensor.start();
      }

      // If returning from exhibit, ensure movement resumes properly
      if (isReturningFromExhibit) {
        isReturningFromExhibit = false;
        // Force a position update to resume tracking
        if (lastValidPosition) {
          updateUserLocation(
            {
              coords: {
                latitude: lastValidPosition.lat,
                longitude: lastValidPosition.lng,
                accuracy: lastValidPosition.accuracy,
                heading: lastValidPosition.heading,
                speed: lastValidPosition.speedMPS,
              },
              timestamp: Date.now(),
            },
            true,
          );
        }
      }
    }
  }
  resetInactivityTimer();
}

// Update location after background
function updateLocationAfterBackground() {
  if (!("geolocation" in navigator)) {
    console.warn("Geolocation is not available");
    return;
  }

  // First try with cached position to get quick response
  const quickOptions = {
    enableHighAccuracy: false,
    timeout: 5000,
    maximumAge: 60000, // Use a position from last minute if available
  };

  // Then try with high accuracy
  const accurateOptions = {
    enableHighAccuracy: true,
    timeout: 15000,
    maximumAge: 30000,
  };

  // Final fallback with very permissive settings
  const fallbackOptions = {
    enableHighAccuracy: false,
    timeout: 25000,
    maximumAge: 120000, // Accept positions up to 2 minutes old
  };

  const handleSuccess = (position) => {
    console.log("Background update raw position:", JSON.stringify(position));

    if (!position?.coords) {
      console.warn("Invalid position object in background update");
      return;
    }
    const { latitude, longitude, accuracy } = position.coords;
    if (isNaN(latitude) || isNaN(longitude)) {
      console.warn("Invalid coordinates in background update:", { latitude, longitude });
      return;
    }
    console.log("Valid background position update:", { lat: latitude, lng: longitude });

    try {
      updateUserLocation(position, true);

      // Reset tracking state
      lastPosition = null;
      positionBuffer = [];
      velocity = { lat: 0, lng: 0 };
      lastVelocity = { lat: 0, lng: 0 };
      isStationary = false;
      stationaryStartTime = null;
      stationaryCount = 0;
      stationaryPositionHistory = [];
      lastStationaryPosition = null;
      stationaryPositionLocked = false;
      positionHistory = [];
      suddenMovementCount = 0;
      isJumpDetected = false;
      // Reset Kalman filter
      tracking.filter.reset({
        lat: latitude,
        lng: longitude,
        accuracy: accuracy,
        heading: position.coords.heading || 0,
        timestamp: Date.now(),
      });
      // Restart animation if needed
      if (!animationFrameId) {
        startAnimationLoop();
      }
      // Restart GeolocationSensor if using it
      if (usingGeolocationSensorAPI && geolocationSensor) {
        geolocationSensor.start();
      }
      updateDistanceBox();
      followUser = true;
      map.invalidateSize();
    } catch (error) {
      console.error("Error in updateUserLocation during background update:", error);
    }
  };

  const handleError = (error, stage) => {
    console.error(`Error getting location during ${stage} attempt:`, error);

    switch (error.code) {
      case error.PERMISSION_DENIED:
        console.warn("User denied geolocation access");
        break;

      case error.POSITION_UNAVAILABLE:
        if (stage === "quick") {
          console.log("Quick position unavailable, trying accurate position...");
          navigator.geolocation.getCurrentPosition(
            handleSuccess,
            (err) => handleError(err, "accurate"),
            accurateOptions,
          );
        } else if (stage === "accurate") {
          console.log("Accurate position unavailable, trying fallback...");
          navigator.geolocation.getCurrentPosition(
            handleSuccess,
            (err) => handleError(err, "fallback"),
            fallbackOptions,
          );
        } else {
          console.warn("All position attempts failed - location unavailable");
        }
        break;

      case error.TIMEOUT:
        if (stage === "quick") {
          console.log("Quick position timed out, trying accurate position...");
          navigator.geolocation.getCurrentPosition(
            handleSuccess,
            (err) => handleError(err, "accurate"),
            accurateOptions,
          );
        } else if (stage === "accurate") {
          console.log("Accurate position timed out, trying fallback...");
          navigator.geolocation.getCurrentPosition(
            handleSuccess,
            (err) => handleError(err, "fallback"),
            fallbackOptions,
          );
        } else {
          console.warn("All position attempts timed out");
        }
        break;

      default:
        if (stage !== "fallback") {
          console.log("Unknown error, trying fallback options...");
          navigator.geolocation.getCurrentPosition(
            handleSuccess,
            (err) => handleError(err, "fallback"),
            fallbackOptions,
          );
        } else {
          console.warn("All position attempts failed with unknown error");
        }
    }
  };

  // Start with quick attempt to get position
  navigator.geolocation.getCurrentPosition(handleSuccess, (error) => handleError(error, "quick"), quickOptions);
}

// Helper function to validate position data
function isValidPosition(pos) {
  return (
    pos &&
    typeof pos.lat === "number" &&
    !isNaN(pos.lat) &&
    typeof pos.lng === "number" &&
    !isNaN(pos.lng) &&
    typeof pos.accuracy === "number" &&
    !isNaN(pos.accuracy)
  );
}

// Linear interpolation helper
function lerp(a, b, t) {
  if (typeof a !== "number" || typeof b !== "number" || typeof t !== "number") {
    return a;
  }

  return a + (b - a) * Math.max(0, Math.min(1, t));
}

// Update position buffer with new position
function updatePositionBuffer(position) {
  if (!isValidPosition(position)) {
    return;
  }

  // Add new position to buffer
  positionBuffer.push({
    lat: position.lat,
    lng: position.lng,
    accuracy: position.accuracy,
    heading: position.heading,
    timestamp: position.timestamp,
    speedMPS: position.speedMPS,
  });

  // Remove old positions if buffer exceeds maxSize
  while (positionBuffer.length > MAX_BUFFER_SIZE) {
    positionBuffer.shift();
  }
}

// Update position history for jump detection
function updatePositionHistory(position) {
  if (!isValidPosition(position)) {
    return;
  }

  // Add new position to history
  positionHistory.push({
    lat: position.lat,
    lng: position.lng,
    accuracy: position.accuracy,
    heading: position.heading,
    timestamp: position.timestamp,
    speedMPS: position.speedMPS,
  });

  // Keep only recent positions
  while (positionHistory.length > 10) {
    positionHistory.shift();
  }
}

// Check stationary state
function checkStationaryState(newPosition) {
  if (!lastPosition) return;

  // Calculate distance between current and last position
  const distance = calculateDistance(lastPosition, newPosition);

  // Check if device motion sensors indicate movement
  const motionDetected = isDeviceInMotion();

  // If significant movement is detected or motion sensors indicate activity
  if (distance >= MICRO_MOVEMENT_THRESHOLD || motionDetected) {
    if (isStationary) {
      console.debug("Movement detected, transitioning to moving state");
      isStationary = false;
      stationaryStartTime = null;
      stationaryPositionLocked = false;
      stationaryCount = 0; // Reset stationary count
      tracking.filter.setStationaryMode(false);

      // Clear any stationary lock timeout
      if (stationaryLockTimeout) {
        clearTimeout(stationaryLockTimeout);
        stationaryLockTimeout = null;
      }
    }

    // Clear the stationary check timeout
    if (stationaryCheckTimeout) {
      clearTimeout(stationaryCheckTimeout);
      stationaryCheckTimeout = null;
    }
  } else {
    // If no significant movement, increment stationary count
    stationaryCount++;

    // If stationary count exceeds threshold, transition to stationary state
    if (!isStationary && stationaryCount >= STATIONARY_THRESHOLD) {
      console.debug("User is now stationary");
      isStationary = true;
      stationaryStartTime = Date.now();
      tracking.filter.setStationaryMode(true);

      // Calculate a stable position by averaging recent positions
      const stablePosition = calculateStationaryPosition(positionBuffer);
      if (stablePosition) {
        lastStationaryPosition = stablePosition;

        // Set a timeout to lock the stationary position after a delay
        if (stationaryLockTimeout) {
          clearTimeout(stationaryLockTimeout);
        }

        stationaryLockTimeout = setTimeout(() => {
          stationaryPositionLocked = true;
          stationaryPositionLockTime = Date.now();
          console.log("Stationary position locked after delay");

          // Also lock in the Kalman filter
          tracking.filter.lockStationaryPosition(lastStationaryPosition);
        }, 2000); // Reduced from 3000ms for faster locking
      }
    }

    // Schedule the next stationary check
    if (isStationary && !stationaryCheckTimeout) {
      stationaryCheckTimeout = setTimeout(() => {
        stationaryCheckTimeout = null;
        checkStationaryState(newPosition);
      }, STATIONARY_CHECK_INTERVAL);
    }
  }
}

// Enhanced stationary position calculation
function calculateStationaryPosition(buffer) {
  if (!buffer || buffer.length === 0) {
    return null;
  }

  // Sort by accuracy (best first)
  const sortedBuffer = [...buffer].sort((a, b) => a.accuracy - b.accuracy);

  // Take weighted average of best positions
  const topPositions = sortedBuffer.slice(0, Math.ceil(buffer.length / 2));

  const weights = topPositions.map((pos) => 1 / Math.max(1, pos.accuracy));
  const totalWeight = weights.reduce((sum, w) => sum + w, 0);

  if (totalWeight === 0) {
    return sortedBuffer[0];
  }

  // Calculate weighted average
  const avgPosition = {
    lat: topPositions.reduce((sum, pos, i) => sum + pos.lat * weights[i], 0) / totalWeight,
    lng: topPositions.reduce((sum, pos, i) => sum + pos.lng * weights[i], 0) / totalWeight,
    accuracy: topPositions[0].accuracy,
    heading: topPositions[0].heading,
    timestamp: Date.now(),
    speedMPS: 0,
  };

  // If we have a previous stationary position, blend with it for stability
  if (lastStationaryPosition) {
    const blendFactor = 0.9;
    return {
      lat: lastStationaryPosition.lat * blendFactor + avgPosition.lat * (1 - blendFactor),
      lng: lastStationaryPosition.lng * blendFactor + avgPosition.lng * (1 - blendFactor),
      accuracy: avgPosition.accuracy,
      heading: avgPosition.heading,
      timestamp: avgPosition.timestamp,
      speedMPS: 0,
    };
  }

  return avgPosition;
}

// Update stationary position history
function updateStationaryHistory(position) {
  // Add new position to history
  stationaryPositionHistory.push(position);

  // Keep history at maximum size
  while (stationaryPositionHistory.length > STATIONARY_POSITION_HISTORY_SIZE) {
    stationaryPositionHistory.shift();
  }

  // Calculate weighted average of positions
  let totalWeight = 0;
  let weightedLat = 0;
  let weightedLng = 0;

  // Newer positions have higher weight
  for (let i = 0; i < stationaryPositionHistory.length; i++) {
    const pos = stationaryPositionHistory[i];
    const weight = Math.pow(STATIONARY_POSITION_WEIGHT_DECAY, stationaryPositionHistory.length - i - 1);
    totalWeight += weight;
    weightedLat += pos.lat * weight;
    weightedLng += pos.lng * weight;
  }

  return {
    lat: weightedLat / totalWeight,
    lng: weightedLng / totalWeight,
    accuracy: position.accuracy,
    heading: position.heading,
    timestamp: position.timestamp,
    speedMPS: 0,
  };
}

// Detect sudden movements or position jumps
function detectSuddenMovement(newPosition, lastPosition) {
  if (!lastPosition || !newPosition) return false;

  const distance = calculateDistance(lastPosition, newPosition);
  const timeDelta = (newPosition.timestamp - lastPosition.timestamp) / 1000; // seconds

  // If time delta is too small, consider it a valid update
  if (timeDelta < 0.05) return false;

  // Calculate speed in meters per second
  const speed = distance / timeDelta;

  // Check for unrealistic speeds (teleportation)
  if (speed > 40) {
    // Reduced from 50 to 40 m/s for more sensitive jump detection
    console.log(`Position jump detected: ${distance.toFixed(2)}m in ${timeDelta.toFixed(2)}s (${speed.toFixed(2)} m/s)`);
    return true;
  }

  // Check for sudden movements when stationary
  if (isStationary && distance > POSITION_JUMP_THRESHOLD) {
    console.log(`Sudden movement detected while stationary: ${distance.toFixed(2)}m`);
    return true;
  }

  // Check for small sudden movements (jitter)
  if (isStationary && distance > SUDDEN_MOVEMENT_THRESHOLD) {
    suddenMovementCount++;
    if (suddenMovementCount >= 2) {
      console.log(`Multiple sudden movements detected: ${distance.toFixed(2)}m`);
      return true;
    }
  } else {
    suddenMovementCount = 0;
  }

  return false;
}

// Main function to update user location
function updateUserLocation(position, forceUpdate = false) {
  // Validate input position
  if (!position?.coords?.latitude || !position?.coords?.longitude) {
    console.warn("Invalid position data received");
    return;
  }

  const currentTime = Date.now();
  const timeDelta = lastUpdateTime ? (currentTime - lastUpdateTime) / 1000 : 0;

  // Create position object
  const newPosition = {
    lat: position.coords.latitude,
    lng: position.coords.longitude,
    accuracy: position.coords.accuracy || 20,
    heading: position.coords.heading !== null ? position.coords.heading : lastHeadingValue || undefined,
    timestamp: currentTime,
    speedMPS: position.coords.speed !== null ? position.coords.speed : 0,
  };

  // First position initialization
  if (!lastPosition) {
    lastPosition = newPosition;
    lastValidPosition = newPosition;
    updateUserMarkerPosition(newPosition); // This updates the marker
    tracking.filter.reset(newPosition);
    lastUpdateTime = currentTime;
    stationaryStartTime = currentTime;
    positionBuffer = [newPosition];
    positionHistory = [newPosition];
    lastStationaryPosition = newPosition;
    lastRenderPosition = newPosition;

    // Set initial zoom based on stationary state
    const initialZoom = calculateZoomLevel(0);
    map.setView([newPosition.lat, newPosition.lng], initialZoom, { animate: false });
    updateDistanceBox();
    return;
  }

  // Calculate distance from last position
  const distance = calculateDistance(lastPosition, newPosition);

  // Check for sudden movements or position jumps
  const isJump = !forceUpdate && detectSuddenMovement(newPosition, lastPosition);

  // If a jump is detected and we're stationary, ignore this update
  if (isJump && isStationary && stationaryPositionLocked) {
    console.log("Position jump detected while stationary, ignoring update");
    isJumpDetected = true;
    return;
  }

  // Handle large position changes or forced updates
  if (distance > EXTENDED_DISTANCE_THRESHOLD || forceUpdate) {
    if (stationaryCheckTimeout) {
      clearTimeout(stationaryCheckTimeout);
      stationaryCheckTimeout = null;
    }

    if (stationaryLockTimeout) {
      clearTimeout(stationaryLockTimeout);
      stationaryLockTimeout = null;
    }

    isStationary = false;
    stationaryStartTime = null;
    stationaryCount = 0;
    stationaryPositionHistory = [];
    lastStationaryPosition = null;
    stationaryPositionLocked = false;
    isJumpDetected = false;

    // Reset tracking variables
    tracking.filter.reset(newPosition);
    tracking.filter.setStationaryMode(false);

    // Update marker position IMMEDIATELY without interpolation
    updateUserMarkerPosition(newPosition);

    lastPosition = newPosition;
    lastValidPosition = newPosition;
    lastRenderPosition = newPosition;
    positionBuffer = [newPosition];
    positionHistory = [newPosition];
    lastVelocity = { lat: 0, lng: 0 };
    lastSmoothedPosition = null;

    // Update map view INSTANTLY without animation
    const zoomLevel = calculateZoomLevel(newPosition.speedMPS);
    map.setView([newPosition.lat, newPosition.lng], zoomLevel, {
      animate: false,
      duration: 0,
    });

    lastUpdateTime = currentTime;
    lastUpdateTimestamp = currentTime;
    updateDistanceBox();

    if (map._container) {
      map._onResize();
    }
    return;
  }

  // Skip updates with poor accuracy or unrealistic movement
  if (
    !forceUpdate &&
    (newPosition.accuracy > MAX_ACCEPTABLE_ACCURACY || (timeDelta > 0 && distance / timeDelta > 40))
  ) {
    console.log("Skipping update due to poor accuracy or unrealistic movement");
    return;
  }

  try {
    // Check if device is in motion based on motion sensors
    const motionDetected = deviceMotion && isDeviceInMotion();

    // Check stationary state
    checkStationaryState(newPosition);

    // If we're in stationary mode and have a locked position, use that position
    if (isStationary && stationaryPositionLocked && lastStationaryPosition) {
      // Just update the distance box without changing position
      updateDistanceBox();
      return;
    }

    // Apply enhanced tracking with motion detection
    const smoothedPosition = tracking.update(newPosition, motionDetected, ANIMATION_DURATION);

    // Update position buffer and history
    updatePositionBuffer(smoothedPosition);
    updatePositionHistory(smoothedPosition);

    // Add this line to collect speed samples
    updateSpeedSamples(smoothedPosition);

    // KEY CHANGE: Always update the marker position with smoothed position
    updateUserMarkerPosition(smoothedPosition);

    // Add to position update queue
    positionUpdateQueue.push(smoothedPosition);
    lastPosition = smoothedPosition;
    lastValidPosition = smoothedPosition;
    lastRenderPosition = smoothedPosition; // Ensure this is updated

    lastUpdateTime = currentTime;
    lastUpdateTimestamp = currentTime;
    updateDistanceBox();
  } catch (error) {
    console.error("Location update error:", error);
    // Fallback with basic filtering
    updateUserMarkerPosition(newPosition);
    lastPosition = newPosition;
    lastValidPosition = newPosition;
    lastRenderPosition = newPosition;
    updateDistanceBox();
  }
}

// Predict position based on heading and speed
function predictPositionFromHeading(position, heading, distance) {
  // Input validation
  if (
    !position ||
    typeof heading !== "number" ||
    typeof distance !== "number" ||
    !position.lat ||
    !position.lng ||
    isNaN(heading) ||
    isNaN(distance)
  ) {
    return position;
  }

  // Normalize heading to 0-360 range
  heading = ((heading % 360) + 360) % 360;

  // Earth's radius in meters
  const R = 6371e3;

  // Convert to radians
  const d = distance / R;
  const  = (heading * Math.PI) / 180;
  const 1 = (position.lat * Math.PI) / 180;
  const 1 = (position.lng * Math.PI) / 180;

  // Calculate predicted position with error handling
  try {
    const sin1 = Math.sin(1);
    const cos1 = Math.cos(1);
    const cosd = Math.cos(d);
    const sind = Math.sin(d);
    const cos = Math.cos();

    const 2 = Math.asin(sin1 * cosd + cos1 * sind * cos);

    const 2 = 1 + Math.atan2(Math.sin() * sind * cos1, cosd - sin1 * Math.sin(2));

    // Convert back to degrees with bounds checking
    const newLat = Math.max(-90, Math.min(90, (2 * 180) / Math.PI));
    const newLng = (((2 * 180) / Math.PI + 540) % 360) - 180;

    return {
      lat: newLat,
      lng: newLng,
    };
  } catch (error) {
    // Fallback to original position if calculation fails
    return position;
  }
}

// Add CSS styles for user marker direction indicator
function addUserMarkerStyles() {
  const style = document.createElement("style");
  style.textContent = `
    .user-marker-icon {
      width: 16px;
      height: 16px;
      background-color: #ff3b30;
      border-radius: 50%;
      border: 2px solid white;
      box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
      position: relative;
    }
    
    .user-marker-direction {
      position: absolute;
      top: -4px;
      left: 50%;
      margin-left: -2px;
      width: 0;
      height: 0;
      border-left: 6px solid transparent;
      border-right: 6px solid transparent;
      border-bottom: 12px solid #ff3b30;
      transform-origin: center bottom;
      z-index: -1;
    }
    
    .user-marker-icon.pulsing {
      animation: pulse 1.5s infinite;
    }
    
    @keyframes pulse {
      0% {
        transform: scale(1);
        opacity: 1;
      }
      50% {
        transform: scale(1.2);
        opacity: 0.8;
      }
      100% {
        transform: scale(1);
        opacity: 1;
      }
    }
  `;
  document.head.appendChild(style);
}

// Show loading message
function showLoadingMessage() {
  // Skip creating the loading message element
  // Just log to console for debugging purposes
  console.log("Searching for location...");

  // Set a flag to track that we're in the loading state
  window.isSearchingLocation = true;

  // If you need to maintain any timing-dependent behavior that might
  // rely on this function, you can add a small timeout
  setTimeout(() => {
    // This ensures any code expecting this function to take some time
    // will still work correctly
  }, 100);
}

// Hide loading message
function hideLoadingMessage() {
  // Clear the loading state flag
  window.isSearchingLocation = false;

  // No need to remove any elements since we didn't create them
  // Just log for debugging
  console.log("Location found, proceeding to stabilization...");

  // If any code relies on this function completing, ensure it still works
  const fakeLoadingMessage = document.getElementById("loadingMessage");
  if (fakeLoadingMessage) {
    document.body.removeChild(fakeLoadingMessage);
  }
}

// Show stabilizing modal
function showStabilizingModal() {
  // Hide jitter immediately
  if (userMarker) userMarker.setOpacity(0);

  const modal = document.createElement("div");
  modal.id = "stabilizingModal";
  modal.className = "stabilizing-modal";
  modal.innerHTML = `
    <div class="spinner"></div>
    <h3>Stabilizing Your Location</h3>
    <p>Please wait while we fine-tune your position.</p>
  `;
  document.body.appendChild(modal);

  // Auto-dismiss after 5 seconds
  setTimeout(() => {
    if (userMarker) userMarker.setOpacity(1); // Restore visibility
    const modal = document.getElementById("stabilizingModal");
    if (modal) {
      modal.style.opacity = "0";
      setTimeout(() => modal.remove(), 500);
    }
    isStabilizing = false;
  }, 5000);
}

// Image preloading function
function preloadImages(locations) {
  return new Promise((resolve) => {
    if (!locations || locations.length === 0) {
      resolve();
      return;
    }

    const totalImages = locations.length;
    let loadedImages = 0;
    const progressBar = document.getElementById("preloaderProgress");

    locations.forEach((location, index) => {
      if (!location.image) {
        loadedImages++;
        updateProgress();
        if (loadedImages === totalImages) resolve();
        return;
      }

      // Skip if already preloaded
      if (preloadedImages.has(location.image)) {
        loadedImages++;
        updateProgress();
        if (loadedImages === totalImages) resolve();
        return;
      }

      const img = new Image();
      img.crossOrigin = "anonymous"; // Set crossOrigin for canvas operations
      img.onload = () => {
        preloadedImages.set(location.image, img);
        loadedImages++;
        updateProgress();
        if (loadedImages === totalImages) resolve();
      };

      img.onerror = () => {
        console.warn(`Failed to load image: ${location.image}`);
        loadedImages++;
        updateProgress();
        if (loadedImages === totalImages) resolve();
      };

      img.src = location.image;
    });

    // Also preload audio files
    locations.forEach((location) => {
      if (location.audio && !preloadedAudio.has(location.audio)) {
        const audio = new Audio();
        audio.preload = "auto";
        audio.oncanplaythrough = () => {
          preloadedAudio.set(location.audio, audio);
        };
        audio.src = location.audio;
      }
    });

    function updateProgress() {
      const percent = (loadedImages / totalImages) * 100;
      domUpdateManager.schedule("preloaderProgress", () => {
        if (progressBar) {
          progressBar.style.width = `${percent}%`;
        }
      });
    }
  });
}

// Initialize the application when the DOM is ready
document.addEventListener("DOMContentLoaded", function() {
  initMap();
});

// Show popup
function showPopup(title, message, type = "info", callback = null) {
  // Popup implementation would go here
  alert(`${title}: ${message}`);
  if (callback) callback();
}

// Get marker color based on tour type
function getMarkerColor(tours) {
  switch (tours?.toLowerCase()) {
    case "person":
      return "#FFA500";
    case "gangster":
      return "#3f9b0b";
    case "event":
      return "#8B0000";
    case "place":
      return "#0f2bab";
    default:
      return "#0f2bab";
  }
}

// Calculate optimal center for recentering
function calculateOptimalCenter(map, position, edgeInfo) {
  if (!map || !position || !edgeInfo) {
    return position;
  }

  const bounds = map.getBounds();
  const currentCenter = map.getCenter();
  const latSpan = bounds.getNorth() - bounds.getSouth();
  const lngSpan = bounds.getEast() - bounds.getWest();

  // Calculate optimal center based on which edges are being approached
  let optimalLat = currentCenter.lat;
  let optimalLng = currentCenter.lng;

  // Adjust latitude if approaching north or south edge
  if (edgeInfo.edges.north) {
    optimalLat = position.lat - latSpan * 0.25;
  } else if (edgeInfo.edges.south) {
    optimalLat = position.lat + latSpan * 0.25;
  }

  // Adjust longitude if approaching east or west edge
  if (edgeInfo.edges.east) {
    optimalLng = position.lng - lngSpan * 0.25;
  } else if (edgeInfo.edges.west) {
    optimalLng = position.lng + lngSpan * 0.25;
  }

  return {
    lat: optimalLat,
    lng: optimalLng,
  };
}

// Start hunt - initialize game locations and setup
function startHunt() {
  // This would be implemented based on your game logic
  console.log("Starting location hunt...");
  
  // Example implementation:
  // 1. Load game locations from API or local data
  // 2. Set up markers for locations
  // 3. Initialize game state
  
  // For demonstration, we'll just set up some sample locations
  gameLocations = [
    { id: 1, lat: 44.9778, lng: -93.265, name: "Sample Location 1", description: "This is a sample location" },
    { id: 2, lat: 44.975, lng: -93.26, name: "Sample Location 2", description: "Another sample location" },
  ];
  
  // Add markers for game locations
  if (markerClusterGroup) {
    gameLocations.forEach(location => {
      const marker = L.marker([location.lat, location.lng], {
        icon: L.divIcon({
          className: "custom-pin-icon",
          html: `<div class="pin-head" style="background-color: ${getMarkerColor('place')};"></div>`,
          iconSize: [30, 30],
          iconAnchor: [15, 30],
        })
      });
      
      // Add popup with location info
      marker.bindPopup(`<h3>${location.name}</h3><p>${location.description}</p>`);
      
      // Add to cluster group
      markerClusterGroup.addLayer(marker);
    });
  }
  
  // Start checking proximity to locations
  setInterval(checkProximityForZoom, 1000);
}

// Update distance box with current location information
function updateDistanceBox() {
  // Skip if no current location or game locations
  if (!lastPosition || !gameLocations || gameLocations.length === 0) return;
  
  // Get current location
  const currentLocation = gameLocations[currentLocationIndex];
  if (!currentLocation) return;
  
  // Calculate distance to current location
  const distance = calculateDistance(
    { lat: lastPosition.lat, lng: lastPosition.lng },
    { lat: currentLocation.lat, lng: currentLocation.lng }
  );
  
  // Convert to feet
  const distanceFeet = Math.round(distance * 3.28084);
  
  // Update distance display if it exists
  const distanceElement = document.getElementById("distanceDisplay");
  if (distanceElement) {
    distanceElement.textContent = `${distanceFeet} ft`;
    
    // Update color based on proximity
    if (distanceFeet <= DISTANCE_THRESHOLD) {
      distanceElement.classList.add("near");
    } else {
      distanceElement.classList.remove("near");
    }
  }
  
  // Check if user is within threshold distance to open location
  if (distanceFeet <= DISTANCE_THRESHOLD) {
    // Check cooldown to prevent rapid reopening
    const lastOpenTime = locationCooldowns[currentLocation.id] || 0;
    const now = Date.now();
    
    if (now - lastOpenTime > 30000) { // 30 second cooldown
      // Update cooldown
      locationCooldowns[currentLocation.id] = now;
      
      // Show location info (would be implemented based on your UI)
      // showLocationInfo(currentLocation);
      console.log(`Within range of location: ${currentLocation.name}`);
    }
  }
}

// Handle window resize
window.addEventListener("resize", function() {
  if (map) {
    map.invalidateSize();
    updateMapViewportDimensions();
  }
});

// Handle device orientation change
window.addEventListener("orientationchange", function() {
  if (map) {
    // Short delay to allow orientation change to complete
    setTimeout(() => {
      map.invalidateSize();
      updateMapViewportDimensions();
      
      // Recenter map if following user
      if (followUser && userMarker) {
        const position = userMarker.getLatLng();
        map.setView([position.lat, position.lng], map.getZoom(), {
          animate: false
        });
      }
    }, 200);
  }
});

// Handle page visibility changes
document.addEventListener("visibilitychange", handleVisibilityChange);

// Handle page unload to clean up resources
window.addEventListener("beforeunload", function() {
  // Clean up watch position if active
  if (isWatchPositionActive && watchPositionId !== null) {
    navigator.geolocation.clearWatch(watchPositionId);
  }
  
  // Stop GeolocationSensor if using it
  if (usingGeolocationSensorAPI && geolocationSensor) {
    geolocationSensor.stop();
  }
  
  // Cancel any animation frame
  if (animationFrameId) {
    cancelAnimationFrame(animationFrameId);
  }
  
  // Clear any timeouts
  if (stationaryCheckTimeout) {
    clearTimeout(stationaryCheckTimeout);
  }
  
  if (stationaryLockTimeout) {
    clearTimeout(stationaryLockTimeout);
  }
  
  if (inactivityTimer) {
    clearTimeout(inactivityTimer);
  }
});

// Create a recenter button
function createRecenterButton() {
  const recenterButton = document.createElement("button");
  recenterButton.className = "recenter-button";
  recenterButton.innerHTML = '<span class="icon"></span>';
  recenterButton.setAttribute("aria-label", "Recenter map");
  recenterButton.addEventListener("click", recenterMap);
  
  const controlsContainer = document.createElement("div");
  controlsContainer.className = "map-controls";
  controlsContainer.appendChild(recenterButton);
  
  // Add tips button
  const tipsButton = document.createElement("button");
  tipsButton.className = "tips-button";
  tipsButton.innerHTML = '<span class="icon"></span>';
  tipsButton.setAttribute("aria-label", "Show navigation tips");
  tipsButton.addEventListener("click", toggleTips);
  controlsContainer.appendChild(tipsButton);
  
  document.body.appendChild(controlsContainer);
  
  return controlsContainer;
}

// Toggle navigation tips
function toggleTips() {
  const tipsElement = document.getElementById("navigationTips");
  
  if (tipsElement) {
    // Toggle visibility if tips element exists
    if (tipsElement.style.display === "none") {
      tipsElement.style.display = "block";
    } else {
      tipsElement.style.display = "none";
    }
  } else {
    // Create tips element if it doesn't exist
    const tips = document.createElement("div");
    tips.id = "navigationTips";
    tips.className = "navigation-tips";
    tips.innerHTML = `
      <button class="close-button" onclick="document.getElementById('navigationTips').style.display='none'"></button>
      <h3>Navigation Tips</h3>
      <ul>
        <li>Tap the recenter button to focus on your location</li>
        <li>Pinch to zoom in and out</li>
        <li>Drag to move the map</li>
        <li>Tap on markers to see location details</li>
      </ul>
    `;
    document.body.appendChild(tips);
  }
}

// Create distance display
function createDistanceDisplay() {
  const distanceDisplay = document.createElement("div");
  distanceDisplay.id = "distanceDisplay";
  distanceDisplay.className = "distance-display";
  distanceDisplay.textContent = "-- ft";
  document.body.appendChild(distanceDisplay);
  
  return distanceDisplay;
}

// Initialize UI elements
function initUI() {
  createRecenterButton();
  createDistanceDisplay();
  
  // Add CSS for UI elements
  const style = document.createElement("style");
  style.textContent = `
    .map-controls {
      position: absolute;
      bottom: 20px;
      right: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      z-index: 500;
    }
    
    .map-controls button {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background-color: white;
      border: none;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .map-controls button:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }
    
    .map-controls button:active {
      transform: translateY(0);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }
    
    .distance-display {
      position: absolute;
      top: 20px;
      left: 20px;
      background-color: white;
      padding: 8px 12px;
      border-radius: 20px;
      font-weight: bold;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      z-index: 500;
    }
    
    .distance-display.near {
      background-color: #4CAF50;
      color: white;
    }
    
    .navigation-tips {
      position: absolute;
      bottom: 20px;
      left: 20px;
      background-color: white;
      border-radius: 10px;
      padding: 15px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      max-width: 250px;
      z-index: 500;
    }
    
    .navigation-tips h3 {
      margin-top: 0;
      margin-bottom: 10px;
      font-size: 16px;
    }
    
    .navigation-tips ul {
      margin: 0;
      padding-left: 20px;
    }
    
    .navigation-tips li {
      margin-bottom: 5px;
      font-size: 14px;
    }
    
    .navigation-tips .close-button {
      position: absolute;
      top: 5px;
      right: 5px;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background-color: #f5f5f5;
      border: none;
      font-size: 16px;
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
    }
  `;
  document.head.appendChild(style);
}

// Initialize map container
function createMapContainer() {
  const mapContainer = document.createElement("div");
  mapContainer.id = "map";
  mapContainer.className = "map-container";
  document.body.appendChild(mapContainer);
  
  return mapContainer;
}

// Main initialization function
function init() {
  // Create map container if it doesn't exist
  if (!document.getElementById("map")) {
    createMapContainer();
  }
  
  // Initialize UI elements
  initUI();
  
  // Initialize map
  initMap();
}

// Call init when DOM is ready
if (document.readyState === "loading") {
  document.addEventListener("DOMContentLoaded", init);
} else {
  init();
}

// Add user marker styles
function addUserMarkerStyles() {
  const style = document.createElement("style");
  style.textContent = `
    .user-marker {
      position: relative;
    }
    
    .user-marker-icon {
      width: 20px;
      height: 20px;
      background-color: #3388ff;
      border: 2px solid white;
      border-radius: 50%;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
      transition: transform 0.2s ease-out;
    }
    
    .user-marker-icon.pulsing {
      animation: pulse 1s infinite;
    }
    
    .user-marker-direction {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      border-left: 8px solid transparent;
      border-right: 8px solid transparent;
      border-bottom: 16px solid #3388ff;
      transform-origin: center bottom;
      transform: translate(-50%, -50%) rotate(0deg);
      z-index: -1;
    }
    
    @keyframes pulse {
      0% {
        transform: scale(1);
        opacity: 1;
      }
      50% {
        transform: scale(1.1);
        opacity: 0.8;
      }
      100% {
        transform: scale(1);
        opacity: 1;
      }
    }
    
    .custom-pin-icon {
      position: relative;
    }
    
    .pin-head {
      width: 20px;
      height: 20px;
      background-color: #0f2bab;
      border: 2px solid white;
      border-radius: 50%;
      box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
      position: relative;
    }
    
    .pin-head::after {
      content: '';
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 6px solid transparent;
      border-right: 6px solid transparent;
      border-top: 10px solid #0f2bab;
    }
    
    .marker-cluster-custom {
      background-color: rgba(51, 136, 255, 0.6);
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      color: white;
      font-weight: bold;
      border: 2px solid white;
      box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
    }
    
    .marker-cluster-custom div {
      width: 34px;
      height: 34px;
      border-radius: 50%;
      background-color: rgba(51, 136, 255, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
    }
    
    .marker-cluster-custom span {
      font-size: 14px;
    }
    
    .loading-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(255, 255, 255, 0.9);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    
    .loading-spinner {
      width: 50px;
      height: 50px;
      border: 5px solid #f3f3f3;
      border-top: 5px solid #3388ff;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 20px;
    }
    
    .loading-text {
      font-size: 18px;
      font-weight: bold;
      color: #333;
    }
    
    .loading-progress {
      width: 200px;
      height: 10px;
      background-color: #f3f3f3;
      border-radius: 5px;
      margin-top: 10px;
      overflow: hidden;
    }
    
    .loading-progress-bar {
      height: 100%;
      background-color: #3388ff;
      width: 0%;
      transition: width 0.3s ease;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  `;
  document.head.appendChild(style);
}

// Show loading message
function showLoadingMessage() {
  const loadingOverlay = document.createElement("div");
  loadingOverlay.className = "loading-overlay";
  loadingOverlay.id = "loadingOverlay";
  
  const spinner = document.createElement("div");
  spinner.className = "loading-spinner";
  
  const text = document.createElement("div");
  text.className = "loading-text";
  text.textContent = "Getting your location...";
  
  const progress = document.createElement("div");
  progress.className = "loading-progress";
  
  const progressBar = document.createElement("div");
  progressBar.className = "loading-progress-bar";
  progressBar.id = "loadingProgressBar";
  
  progress.appendChild(progressBar);
  loadingOverlay.appendChild(spinner);
  loadingOverlay.appendChild(text);
  loadingOverlay.appendChild(progress);
  
  document.body.appendChild(loadingOverlay);
}

// Hide loading message
function hideLoadingMessage() {
  const loadingOverlay = document.getElementById("loadingOverlay");
  if (loadingOverlay) {
    loadingOverlay.style.opacity = "0";
    loadingOverlay.style.transition = "opacity 0.5s ease";
    
    setTimeout(() => {
      if (loadingOverlay.parentNode) {
        loadingOverlay.parentNode.removeChild(loadingOverlay);
      }
    }, 500);
  }
}

// Update loading progress
function updateLoadingProgress(percent) {
  const progressBar = document.getElementById("loadingProgressBar");
  if (progressBar) {
    progressBar.style.width = `${percent}%`;
  }
}

// Handle visibility change
function handleVisibilityChange() {
  if (document.hidden) {
    // Page is hidden
    lastHiddenTime = Date.now();
    
    // Pause animations to save battery
    if (animationFrameId) {
      cancelAnimationFrame(animationFrameId);
      animationFrameId = null;
    }
  } else {
    // Page is visible again
    const hiddenDuration = Date.now() - lastHiddenTime;
    
    // If hidden for a significant time, reset position tracking
    if (hiddenDuration > BACKGROUND_THRESHOLD) {
      console.log("App was in background for", hiddenDuration, "ms. Resetting position tracking.");
      
      // Reset position tracking
      if (tracking && tracking.filter) {
        tracking.filter.reset(lastPosition);
      }
      
      // Clear position buffer
      positionBuffer = [];
      
      // Reset stationary detection
      isStationary = false;
      stationaryCount = 0;
      stationaryStartTime = null;
      
      // Reset velocity
      velocity = { lat: 0, lng: 0 };
      
      // Reset motion samples
      motionSamples.length = 0;
      
      // Reset position history
      positionHistory.length = 0;
      
      // Reset stationary position history
      stationaryPositionHistory.length = 0;
      
      // Reset heading buffer
      headingBuffer.length = 0;
      
      // Reset position interpolator
      if (positionInterpolator) {
        positionInterpolator.cancel();
      }
    }
    
    // Resume animations
    if (!animationFrameId) {
      renderTimestamp = null;
      startAnimationLoop();
    }
  }
}

// Request motion and orientation permissions
function requestMotionPermission() {
  // Check if DeviceMotionEvent is available and requires permission
  if (typeof DeviceMotionEvent !== 'undefined' && 
      typeof DeviceMotionEvent.requestPermission === 'function') {
    
    // Create permission button
    const permissionButton = document.createElement("button");
    permissionButton.textContent = "Enable Motion Sensors";
    permissionButton.className = "permission-button";
    permissionButton.style.position = "absolute";
    permissionButton.style.top = "50%";
    permissionButton.style.left = "50%";
    permissionButton.style.transform = "translate(-50%, -50%)";
    permissionButton.style.zIndex = "1001";
    permissionButton.style.padding = "12px 20px";
    permissionButton.style.backgroundColor = "#3388ff";
    permissionButton.style.color = "white";
    permissionButton.style.border = "none";
    permissionButton.style.borderRadius = "5px";
    permissionButton.style.fontWeight = "bold";
    permissionButton.style.boxShadow = "0 2px 10px rgba(0, 0, 0, 0.2)";
    
    permissionButton.addEventListener("click", function() {
      // Request device motion permission
      DeviceMotionEvent.requestPermission()
        .then(response => {
          if (response === 'granted') {
            console.log("Device motion permission granted");
            
            // Add event listener for device motion
            window.addEventListener('devicemotion', handleDeviceMotion);
            
            // Request device orientation permission
            if (typeof DeviceOrientationEvent !== 'undefined' && 
                typeof DeviceOrientationEvent.requestPermission === 'function') {
              
              DeviceOrientationEvent.requestPermission()
                .then(response => {
                  if (response === 'granted') {
                    console.log("Device orientation permission granted");
                    orientationPermissionGranted = true;
                    
                    // Add event listener for device orientation
                    window.addEventListener('deviceorientation', handleDeviceOrientation);
                  }
                })
                .catch(console.error);
            }
            
            // Remove button
            document.body.removeChild(permissionButton);
          }
        })
        .catch(console.error);
    });
    
    document.body.appendChild(permissionButton);
  } else {
    // No permission required, add event listeners directly
    window.addEventListener('devicemotion', handleDeviceMotion);
    window.addEventListener('deviceorientation', handleDeviceOrientation);
    orientationPermissionGranted = true;
  }
}

// Initialize geolocation
function initGeolocation() {
  // Try to use Geolocation Sensor API first
  if ('GeolocationSensor' in window) {
    try {
      geolocationSensor = new GeolocationSensor({ frequency: 1 });
      
      geolocationSensor.addEventListener('reading', () => {
        const position = {
          coords: {
            latitude: geolocationSensor.latitude,
            longitude: geolocationSensor.longitude,
            accuracy: geolocationSensor.accuracy,
            altitude: geolocationSensor.altitude,
            altitudeAccuracy: geolocationSensor.altitudeAccuracy,
            heading: geolocationSensor.heading,
            speed: geolocationSensor.speed
          },
          timestamp: geolocationSensor.timestamp
        };
        
        handlePositionUpdate(position);
      });
      
      geolocationSensor.addEventListener('error', (error) => {
        console.error("GeolocationSensor error:", error);
        fallbackToStandardGeolocation();
      });
      
      geolocationSensor.start();
      usingGeolocationSensorAPI = true;
      console.log("Using GeolocationSensor API");
    } catch (error) {
      console.error("Error initializing GeolocationSensor:", error);
      fallbackToStandardGeolocation();
    }
  } else {
    fallbackToStandardGeolocation();
  }
}

// Fallback to standard geolocation API
function fallbackToStandardGeolocation() {
  console.log("Falling back to standard Geolocation API");
  
  if (navigator.geolocation) {
    const options = {
      enableHighAccuracy: true,
      timeout: 10000,
      maximumAge: 0
    };
    
    // Get initial position
    navigator.geolocation.getCurrentPosition(
      (position) => {
        handlePositionUpdate(position);
        
        // Start watching position
        watchPositionId = navigator.geolocation.watchPosition(
          handlePositionUpdate,
          handleLocationError,
          options
        );
        
        isWatchPositionActive = true;
      },
      handleLocationError,
      options
    );
  } else {
    handleLocationError({ code: 0, message: "Geolocation is not supported by this browser." });
  }
}

// Handle position update
function handlePositionUpdate(position) {
  if (!position || !position.coords) return;
  
  // Hide loading message after first position update
  hideLoadingMessage();
  
  // Add to position update queue for processing in animation loop
  positionUpdateQueue.push(position);
  
  // Update last position
  lastPosition = {
    lat: position.coords.latitude,
    lng: position.coords.longitude,
    accuracy: position.coords.accuracy,
    heading: position.coords.heading,
    speedMPS: position.coords.speed,
    speedAccuracy: position.coords.speedAccuracy,
    timestamp: position.timestamp
  };
  
  // Update speed samples for dynamic zoom
  updateSpeedSamples(lastPosition);
  
  // Center map on first position
  if (isFirstPositionUpdate && map) {
    map.setView([lastPosition.lat, lastPosition.lng], DEFAULT_ZOOM_LEVEL);
    isFirstPositionUpdate = false;
  }
  
  // Update distance box
  updateDistanceBox();
}

// Calculate edge proximity
function calculateEdgeProximity(map, position) {
  if (!map || !position) return { north: 1, south: 1, east: 1, west: 1 };
  
  const bounds = map.getBounds();
  const northEdge = bounds.getNorth();
  const southEdge = bounds.getSouth();
  const eastEdge = bounds.getEast();
  const westEdge = bounds.getWest();
  
  // Calculate normalized distances to edges (0-1, where 0 is at the edge)
  const northProximity = (northEdge - position.lat) / (northEdge - southEdge);
  const southProximity = (position.lat - southEdge) / (northEdge - southEdge);
  const eastProximity = (eastEdge - position.lng) / (eastEdge - westEdge);
  const westProximity = (position.lng - westEdge) / (eastEdge - westEdge);
  
  return {
    north: northProximity,
    south: southProximity,
    east: eastProximity,
    west: westProximity
  };
}

// Check if marker is near edge
function isMarkerNearEdge(map, marker, usePixels = false, speed = 0) {
  if (!map || !marker) return { isNearEdge: false, edges: {}, proximities: {} };
  
  const position = marker.getLatLng();
  const proximities = calculateEdgeProximity(map, position);
  
  // Dynamic threshold based on speed
  const speedFactor = Math.min(1, speed / 10); // 0-1 based on speed up to 10 m/s
  const baseThreshold = EDGE_THRESHOLD_PERCENTAGE;
  const dynamicThreshold = baseThreshold * (1 - speedFactor * 0.5); // Reduce threshold at higher speeds
  
  // Check if near any edge
  const edges = {
    north: proximities.north < dynamicThreshold,
    south: proximities.south < dynamicThreshold,
    east: proximities.east < dynamicThreshold,
    west: proximities.west < dynamicThreshold
  };
  
  const isNearEdge = edges.north || edges.south || edges.east || edges.west;
  
  return {
    isNearEdge,
    edges,
    proximities
  };
}

// Preload images
function preloadImages(imageUrls, callback) {
  if (!imageUrls || imageUrls.length === 0) {
    if (callback) callback();
    return;
  }
  
  let loadedImages = 0;
  const totalImages = imageUrls.length;
  let progressBar = document.getElementById("loadingProgressBar");
  
  imageUrls.forEach(url => {
    // Skip if already preloaded
    if (preloadedImages.has(url)) {
      loadedImages++;
      updateProgress();
      if (loadedImages === totalImages && callback) callback();
      return;
    }
    
    const img = new Image();
    img.crossOrigin = "anonymous"; // Prevent CORS issues
    
    img.onload = function() {
      preloadedImages.set(url, img);
      loadedImages++;
      updateProgress();
      
      if (loadedImages === totalImages && callback) {
        callback();
      }
    };
    
    img.onerror = function() {
      console.warn("Failed to load image:", url);
      loadedImages++;
      updateProgress();
      
      if (loadedImages === totalImages && callback) {
        callback();
      }
    };
    
    img.src = url;
  });
  
  function updateProgress() {
    const percent = (loadedImages / totalImages) * 100;
    domUpdateManager.schedule("preloaderProgress", () => {
      if (progressBar) {
        progressBar.style.width = `${percent}%`;
      }
    });
  }
}

// Preload audio
function preloadAudio(audioUrls, callback) {
  if (!audioUrls || audioUrls.length === 0) {
    if (callback) callback();
    return;
  }
  
  let loadedAudio = 0;
  const totalAudio = audioUrls.length;
  
  audioUrls.forEach(url => {
    // Skip if already preloaded
    if (preloadedAudio.has(url)) {
      loadedAudio++;
      if (loadedAudio === totalAudio && callback) callback();
      return;
    }
    
    const audio = new Audio();
    
    audio.oncanplaythrough = function() {
      preloadedAudio.set(url, audio);
      loadedAudio++;
      
      if (loadedAudio === totalAudio && callback) {
        callback();
      }
    };
    
    audio.onerror = function() {
      console.warn("Failed to load audio:", url);
      loadedAudio++;
      
      if (loadedAudio === totalAudio && callback) {
        callback();
      }
    };
    
    audio.src = url;
    audio.load();
  });
}

// Detect device capabilities
function detectDeviceCapabilities() {
  const capabilities = {
    highAccuracySupported: true,
    motionSensorsAvailable: typeof DeviceMotionEvent !== 'undefined',
    orientationSensorsAvailable: typeof DeviceOrientationEvent !== 'undefined',
    gnssType: 'GPS',
    environment: 'urban'
  };
  
  // Try to detect device type
  const userAgent = navigator.userAgent || navigator.vendor || window.opera;
  
  // Check if device is iOS
  const isIOS = /iPad|iPhone|iPod/.test(userAgent) && !window.MSStream;
  
  // Check if device is Android
  const isAndroid = /android/i.test(userAgent);
  
  // Set GNSS type based on device
  if (isIOS) {
    capabilities.gnssType = 'GPS_GLONASS';
  } else if (isAndroid) {
    capabilities.gnssType = 'MULTI_CONSTELLATION';
  }
  
  // Try to detect environment based on accuracy
  if (lastPosition && lastPosition.accuracy) {
    if (lastPosition.accuracy < 10) {
      capabilities.environment = 'rural';
    } else if (lastPosition.accuracy > 30) {
      capabilities.environment = 'urban';
    } else {
      capabilities.environment = 'mixed';
    }
  }
  
  return capabilities;
}

// Mobile device detection
function isMobileDevice() {
  return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
}

// Check if device supports touch events
function supportsTouch() {
  return 'ontouchstart' in window || navigator.maxTouchPoints > 0;
}

// Utility function to debounce function calls
function debounce(func, wait) {
  let timeout;
  return function(...args) {
    const context = this;
    clearTimeout(timeout);
    timeout = setTimeout(() => func.apply(context, args), wait);
  };
}

// Utility function to throttle function calls
function throttle(func, limit) {
  let inThrottle;
  return function(...args) {
    const context = this;
    if (!inThrottle) {
      func.apply(context, args);
      inThrottle = true;
      setTimeout(() => inThrottle = false, limit);
    }
  };
}

// Format distance for display
function formatDistance(meters) {
  if (meters < 1000) {
    return `${Math.round(meters)} m`;
  } else {
    return `${(meters / 1000).toFixed(1)} km`;
  }
}

// Format time for display
function formatTime(seconds) {
  if (seconds < 60) {
    return `${Math.round(seconds)} sec`;
  } else if (seconds < 3600) {
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = Math.round(seconds % 60);
    return `${minutes}:${remainingSeconds.toString().padStart(2, '0')} min`;
  } else {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    return `${hours}:${minutes.toString().padStart(2, '0')} hr`;
  }
}

// Get browser language
function getBrowserLanguage() {
  return navigator.language || navigator.userLanguage || 'en-US';
}

// Format coordinates for display
function formatCoordinates(lat, lng) {
  return `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
}

// Check if coordinates are valid
function isValidCoordinate(lat, lng) {
  return (
    typeof lat === 'number' && 
    typeof lng === 'number' && 
    !isNaN(lat) && 
    !isNaN(lng) && 
    lat >= -90 && 
    lat <= 90 && 
    lng >= -180 && 
    lng <= 180
  );
}

// Export functions for testing or external use
if (typeof module !== 'undefined' && module.exports) {
  module.exports = {
    calculateDistance,
    calculateZoomLevel,
    isMarkerNearEdge,
    calculateEdgeProximity,
    formatDistance,
    formatTime,
    formatCoordinates,
    isValidCoordinate
  };
}

// Utility function to get current position as a promise
function getCurrentPositionPromise(options = {}) {
  return new Promise((resolve, reject) => {
    if (!navigator.geolocation) {
      reject(new Error('Geolocation is not supported by this browser.'));
      return;
    }
    
    const defaultOptions = {
      enableHighAccuracy: true,
      timeout: 10000,
      maximumAge: 0
    };
    
    const mergedOptions = { ...defaultOptions, ...options };
    
    navigator.geolocation.getCurrentPosition(resolve, reject, mergedOptions);
  });
}

// Get distance and bearing between two points
function getDistanceAndBearing(start, end) {
  const distance = calculateDistance(start, end);
  
  // Calculate bearing
  const startLat = (start.lat * Math.PI) / 180;
  const startLng = (start.lng * Math.PI) / 180;
  const endLat = (end.lat * Math.PI) / 180;
  const endLng = (end.lng * Math.PI) / 180;
  
  const y = Math.sin(endLng - startLng) * Math.cos(endLat);
  const x = Math.cos(startLat) * Math.sin(endLat) -
            Math.sin(startLat) * Math.cos(endLat) * Math.cos(endLng - startLng);
  
  let bearing = Math.atan2(y, x) * 180 / Math.PI;
  bearing = (bearing + 360) % 360; // Normalize to 0-360
  
  return {
    distance,
    bearing
  };
}

// Get cardinal direction from bearing
function getCardinalDirection(bearing) {
  const directions = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
  const index = Math.round(bearing / 45) % 8;
  return directions[index];
}

// Format bearing as a human-readable direction
function formatDirection(bearing) {
  return getCardinalDirection(bearing);
}

// Check if a point is inside a polygon
function isPointInPolygon(point, polygon) {
  if (!point || !polygon || !polygon.length) return false;
  
  let inside = false;
  const x = point.lng;
  const y = point.lat;
  
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const xi = polygon[i].lng;
    const yi = polygon[i].lat;
    const xj = polygon[j].lng;
    const yj = polygon[j].lat;
    
    const intersect = ((yi > y) !== (yj > y)) &&
        (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
    
    if (intersect) inside = !inside;
  }
  
  return inside;
}

// Calculate the area of a polygon
function calculatePolygonArea(polygon) {
  if (!polygon || polygon.length < 3) return 0;
  
  let area = 0;
  const R = 6371000; // Earth radius in meters
  
  for (let i = 0; i < polygon.length; i++) {
    const j = (i + 1) % polygon.length;
    
    const xi = polygon[i].lng * Math.PI / 180;
    const yi = polygon[i].lat * Math.PI / 180;
    const xj = polygon[j].lng * Math.PI / 180;
    const yj = polygon[j].lat * Math.PI / 180;
    
    area += xi * Math.cos(yj) - xj * Math.cos(yi);
  }
  
  area = area * R * R / 2;
  return Math.abs(area);
}

// Calculate the center of a polygon
function calculatePolygonCenter(polygon) {
  if (!polygon || polygon.length === 0) return null;
  
  let sumLat = 0;
  let sumLng = 0;
  
  for (const point of polygon) {
    sumLat += point.lat;
    sumLng += point.lng;
  }
  
  return {
    lat: sumLat / polygon.length,
    lng: sumLng / polygon.length
  };
}

// Calculate the bounding box of a polygon
function calculateBoundingBox(polygon) {
  if (!polygon || polygon.length === 0) return null;
  
  let minLat = polygon[0].lat;
  let maxLat = polygon[0].lat;
  let minLng = polygon[0].lng;
  let maxLng = polygon[0].lng;
  
  for (const point of polygon) {
    minLat = Math.min(minLat, point.lat);
    maxLat = Math.max(maxLat, point.lat);
    minLng = Math.min(minLng, point.lng);
    maxLng = Math.max(maxLng, point.lng);
  }
  
  return {
    southWest: { lat: minLat, lng: minLng },
    northEast: { lat: maxLat, lng: maxLng }
  };
}

// Calculate the midpoint between two points
function calculateMidpoint(point1, point2) {
  return {
    lat: (point1.lat + point2.lat) / 2,
    lng: (point1.lng + point2.lng) / 2
  };
}

// Calculate a point at a given distance and bearing from a starting point
function calculateDestinationPoint(startPoint, distance, bearing) {
  const R = 6371000; // Earth radius in meters
  const d = distance / R; // Angular distance
  const bearingRad = (bearing * Math.PI) / 180; // Convert bearing to radians
  
  const lat1 = (startPoint.lat * Math.PI) / 180;
  const lng1 = (startPoint.lng * Math.PI) / 180;
  
  const lat2 = Math.asin(
    Math.sin(lat1) * Math.cos(d) + Math.cos(lat1) * Math.sin(d) * Math.cos(bearingRad)
  );
  
  const lng2 = lng1 + Math.atan2(
    Math.sin(bearingRad) * Math.sin(d) * Math.cos(lat1),
    Math.cos(d) - Math.sin(lat1) * Math.sin(lat2)
  );
  
  return {
    lat: (lat2 * 180) / Math.PI,
    lng: ((lng2 * 180) / Math.PI + 540) % 360 - 180 // Normalize longitude to -180 to 180
  };
}

// Generate a random point within a given radius of a center point
function generateRandomPointNear(center, radiusMeters) {
  // Generate a random distance within the radius
  const randomDistance = Math.random() * radiusMeters;
  
  // Generate a random bearing (0-360 degrees)
  const randomBearing = Math.random() * 360;
  
  // Calculate the random point
  return calculateDestinationPoint(center, randomDistance, randomBearing);
}

// Convert meters to feet
function metersToFeet(meters) {
  return meters * 3.28084;
}

// Convert feet to meters
function feetToMeters(feet) {
  return feet / 3.28084;
}

// Convert meters per second to miles per hour
function mpsToMph(mps) {
  return mps * 2.23694;
}

// Convert miles per hour to meters per second
function mphToMps(mph) {
  return mph / 2.23694;
}

// Get device orientation as a promise
function getDeviceOrientation() {
  return new Promise((resolve, reject) => {
    if (!orientationPermissionGranted) {
      reject(new Error('Device orientation permission not granted.'));
      return;
    }
    
    if (deviceOrientation) {
      resolve(deviceOrientation);
      return;
    }
    
    // Wait for orientation data
    const timeout = setTimeout(() => {
      window.removeEventListener('deviceorientation', orientationHandler);
      reject(new Error('Device orientation timeout.'));
    }, 3000);
    
    function orientationHandler(event) {
      if (event.alpha !== null) {
        clearTimeout(timeout);
        window.removeEventListener('deviceorientation', orientationHandler);
        
        resolve({
          alpha: event.alpha,
          beta: event.beta,
          gamma: event.gamma,
          timestamp: Date.now()
        });
      }
    }
    
    window.addEventListener('deviceorientation', orientationHandler);
  });
}

// Get device motion as a promise
function getDeviceMotion() {
  return new Promise((resolve, reject) => {
    if (deviceMotion) {
      resolve(deviceMotion);
      return;
    }
    
    // Wait for motion data
    const timeout = setTimeout(() => {
      window.removeEventListener('devicemotion', motionHandler);
      reject(new Error('Device motion timeout.'));
    }, 3000);
    
    function motionHandler(event) {
      if (event.acceleration) {
        clearTimeout(timeout);
        window.removeEventListener('devicemotion', motionHandler);
        
        resolve({
          x: event.acceleration.x || 0,
          y: event.acceleration.y || 0,
          z: event.acceleration.z || 0,
          timestamp: Date.now()
        });
      }
    }
    
    window.addEventListener('devicemotion', motionHandler);
  });
}

// Save state to local storage
function saveState(key, value) {
  try {
    localStorage.setItem(key, JSON.stringify(value));
    return true;
  } catch (error) {
    console.error('Error saving state:', error);
    return false;
  }
}

// Load state from local storage
function loadState(key, defaultValue = null) {
  try {
    const value = localStorage.getItem(key);
    return value ? JSON.parse(value) : defaultValue;
  } catch (error) {
    console.error('Error loading state:', error);
    return defaultValue;
  }
}

// Clear state from local storage
function clearState(key) {
  try {
    localStorage.removeItem(key);
    return true;
  } catch (error) {
    console.error('Error clearing state:', error);
    return false;
  }
}

// Check if local storage is available
function isLocalStorageAvailable() {
  try {
    const test = '__test__';
    localStorage.setItem(test, test);
    localStorage.removeItem(test);
    return true;
  } catch (e) {
    return false;
  }
}

// Get URL parameters
function getUrlParams() {
  const params = {};
  const queryString = window.location.search.substring(1);
  const pairs = queryString.split('&');
  
  for (const pair of pairs) {
    const [key, value] = pair.split('=');
    if (key) {
      params[decodeURIComponent(key)] = decodeURIComponent(value || '');
    }
  }
  
  return params;
}

// Set URL parameter
function setUrlParam(key, value) {
  const url = new URL(window.location.href);
  url.searchParams.set(key, value);
  window.history.replaceState({}, '', url.toString());
}

// Remove URL parameter
function removeUrlParam(key) {
  const url = new URL(window.location.href);
  url.searchParams.delete(key);
  window.history.replaceState({}, '', url.toString());
}

// Get device pixel ratio
function getDevicePixelRatio() {
  return window.devicePixelRatio || 1;
}

// Adjust canvas for high DPI displays
function setupHighDpiCanvas(canvas) {
  const dpr = getDevicePixelRatio();
  const rect = canvas.getBoundingClientRect();
  
  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;
  
  const ctx = canvas.getContext('2d');
  ctx.scale(dpr, dpr);
  
  return ctx;
}

// Register service worker for offline support
function registerServiceWorker() {
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('/service-worker.js')
      .then(registration => {
        console.log('ServiceWorker registration successful with scope:', registration.scope);
      })
      .catch(error => {
        console.error('ServiceWorker registration failed:', error);
      });
  }
}

// Check if device is online
function isOnline() {
  return navigator.onLine;
}

// Add online/offline event listeners
function setupConnectivityListeners(onlineCallback, offlineCallback) {
  window.addEventListener('online', onlineCallback);
  window.addEventListener('offline', offlineCallback);
  
  return {
    remove: () => {
      window.removeEventListener('online', onlineCallback);
      window.removeEventListener('offline', offlineCallback);
    }
  };
}

// Get battery status
async function getBatteryStatus() {
  if (!navigator.getBattery) {
    return null;
  }
  
  try {
    const battery = await navigator.getBattery();
    return {
      level: battery.level,
      charging: battery.charging,
      chargingTime: battery.chargingTime,
      dischargingTime: battery.dischargingTime
    };
  } catch (error) {
    console.error('Error getting battery status:', error);
    return null;
  }
}

// Optimize for low battery
async function optimizeForLowBattery() {
  const battery = await getBatteryStatus();
  
  if (battery && battery.level < 0.2 && !battery.charging) {
    // Reduce animation frame rate
    const _frameInterval = 33.333; // 30fps instead of 60fps
    
    // Reduce map quality
    if (map) {
      map.getRenderer().options.padding = 0;
    }
    
    console.log('Optimizing for low battery');
    return true;
  }
  
  return false;
}

// Initialize application
function initApp() {
  // Register service worker
  registerServiceWorker();
  
  // Set up connectivity listeners
  setupConnectivityListeners(
    () => console.log('App is online'),
    () => console.log('App is offline')
  );
  
  // Check battery status and optimize if needed
  optimizeForLowBattery();
  
  // Initialize map
  initMap();
  
  // Load saved state
  if (isLocalStorageAvailable()) {
    const savedLocations = loadState('gameLocations', []);
    if (savedLocations.length > 0) {
      gameLocations = savedLocations;
    }
  }
  
  // Check URL parameters
  const params = getUrlParams();
  if (params.lat && params.lng) {
    const lat = parseFloat(params.lat);
    const lng = parseFloat(params.lng);
    
    if (isValidCoordinate(lat, lng) && map) {
      map.setView([lat, lng], params.zoom ? parseInt(params.zoom) : DEFAULT_ZOOM_LEVEL);
    }
  }
  
  // Start hunt if auto parameter is present
  if (params.auto === 'true') {
    startHunt();
  }
}

// Initialize when document is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initApp);
} else {
  initApp();
}

// Clean up resources when page is unloaded
window.addEventListener('beforeunload', () => {
  // Save state
  if (isLocalStorageAvailable() && gameLocations.length > 0) {
    saveState('gameLocations', gameLocations);
  }
  
  // Clean up resources
  if (map) {
    map.remove();
  }
  
  // Clear watch position
  if (isWatchPositionActive && watchPositionId !== null) {
    navigator.geolocation.clearWatch(watchPositionId);
  }
  
  // Stop GeolocationSensor
  if (usingGeolocationSensorAPI && geolocationSensor) {
    geolocationSensor.stop();
  }
  
  // Cancel animation frame
  if (animationFrameId) {
    cancelAnimationFrame(animationFrameId);
  }
});

// Export additional functions for testing or external use
if (typeof module !== 'undefined' && module.exports) {
  Object.assign(module.exports, {
    getDistanceAndBearing,
    getCardinalDirection,
    formatDirection,
    isPointInPolygon,
    calculatePolygonArea,
    calculatePolygonCenter,
    calculateBoundingBox,
    calculateMidpoint,
    calculateDestinationPoint,
    generateRandomPointNear,
    metersToFeet,
    feetToMeters,
    mpsToMph,
    mphToMps
  });
}

// Application version
const APP_VERSION = '1.0.0';

// Log application start
console.log(`Map Application v${APP_VERSION} initialized`);

// Self-invoking function to initialize the application
(function() {
  // Check if the application is already initialized
  if (window.mapAppInitialized) {
    console.warn('Map application already initialized');
    return;
  }
  
  // Mark as initialized
  window.mapAppInitialized = true;
  
  // Initialize when document is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initApp);
  } else {
    initApp();
  }
})();
    </script>
  </body>
</html>
