<!DOCTYPE html>
<html lang="en">
<head> 
    <!-- Security Headers -->
    <meta http-equiv="Content-Security-Policy" content="
        default-src 'self' https:;
        script-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net https://cdnjs.cloudflare.com https://unpkg.com;
        style-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net https://cdnjs.cloudflare.com https://unpkg.com;
        img-src 'self' data: https: blob:;
        font-src 'self' https://cdn.jsdelivr.net https://cdnjs.cloudflare.com;
        connect-src 'self' https: wss:;
        media-src 'self' https: blob:;
        worker-src 'self';
        manifest-src 'self';
    ">
    <meta http-equiv="X-Content-Type-Options" content="nosniff">
    <meta http-equiv="X-Frame-Options" content="DENY">
    <meta http-equiv="X-XSS-Protection" content="1; mode=block">
    <meta http-equiv="Referrer-Policy" content="strict-origin-when-cross-origin">
    
    <!-- Primary Meta Tags -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Minnesota Then | Explore Minnesota History - Museum Without Walls</title>
    <meta name="description" content="Discover Minnesota's hidden history with our location-based museum experience. Explore historical sites, stories, and audio tours across the state - no walls required.">
    <meta name="keywords" content="Minnesota history, historical tours, location-based museum, museum without walls, Minnesota landmarks, audio tours, explore Minnesota, historical sites">
    
    <!-- Favicon -->
    <link rel="shortcut icon" type="image/x-icon" href="https://www.mnthen.com/images/mnthenfav.ico">
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="/manifest.json">
    <meta name="theme-color" content="#2c5282">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="MN Then">
    
    <!-- Open Graph / Facebook Meta Tags -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://www.mnthen.com/">
    <meta property="og:title" content="Minnesota Then | Explore Minnesota History - Museum Without Walls">
    <meta property="og:description" content="Discover Minnesota's hidden history with our location-based museum experience. Explore historical sites across the state.">
    <meta property="og:image" content="https://www.mnthen.com/images/social-share.jpg">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    
    <!-- Twitter Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@MinnesotaThen">
    <meta name="twitter:title" content="Minnesota Then | Explore Minnesota History - Museum Without Walls">
    <meta name="twitter:description" content="Discover Minnesota's hidden history with our location-based museum experience.">
    <meta name="twitter:image" content="https://www.mnthen.com/images/social-share.jpg">
    
    <!-- Canonical URL -->
    <link rel="canonical" href="https://www.mnthen.com/">
    
    <!-- Resource hints for faster connections -->
    <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
    <link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
    <link rel="preconnect" href="https://unpkg.com" crossorigin>
    <link rel="preconnect" href="https://www.mnthen.com" crossorigin>
    <link rel="dns-prefetch" href="https://tile.openstreetmap.org">

    <!-- Preload critical resources -->
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link rel="preload" href="https://www.mnthen.com/css/mainmap.css" as="style">
    <link rel="preload" href="https://www.mnthen.com/css/mnthen_main_map2.css" as="style">
    
    <!-- Noscript fallback -->
    <noscript>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.css">
    </noscript>
    
    <!-- Standard CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha512-MV7K8+y+gLIBoVD59lQIYicR65iaqukzvf/nwasF0nqhPay5w/9lJmVM2hMDcnK1OnMGCdVK+iQrJ7lzPJQd1w==" crossorigin="anonymous">
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css" integrity="sha512-RLEjtaFGdC4iQMJDbMzim/dOvAu+8Qp9sw7QE4wIMYcg2goVoivzwgSZq9CsIxp4xKAZPKh5J2f2lOko2Ze6FQ==" crossorigin="anonymous">
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css" integrity="sha512-BBToHPBStgMiw0lD4AtkRIZmdndhB6aQbXpX7omcrXeG2PauGBl2lzq2xUZTxaLxYz5IDHlmneCZ6IjPtF55Tw==" crossorigin="anonymous">
    <link rel="stylesheet" href="https://www.mnthen.com/css/mainmap.css">
    <link rel="stylesheet" href="https://www.mnthen.com/css/mnthen_main_map2.css">
    
    <!-- Structured Data -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebApplication",
      "name": "Minnesota Then",
      "url": "https://www.mnthen.com",
      "description": "A location-based museum experience exploring Minnesota's history through interactive maps and audio tours.",
      "applicationCategory": "TravelApplication",
      "operatingSystem": "Web",
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "USD"
      },
      "creator": {
        "@type": "Organization",
        "name": "Minnesota Then",
        "url": "https://www.mnthen.com"
      }
    }
    </script>
    
    <!-- Geolocation Schema -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Place",
      "geo": {
        "@type": "GeoCoordinates",
        "latitude": "46.7296",
        "longitude": "-94.6859"
      },
      "name": "Minnesota",
      "description": "Explore historical locations across Minnesota"
    }
    </script>

    <style>
        /* Critical CSS inlined for faster rendering */
        :root {
            --primary-color: #0066cc;
            --hover-color: #e6f0ff;
            --dark-blue: #1a3a8a;
            --dark-blue-hover: #0d2c6e;
        }

        /* Security: Prevent content injection */
        * {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        input, textarea, [contenteditable] {
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
            user-select: text;
        }

        #map {
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
            height: 100vh;
            height: 100dvh; /* Use dynamic viewport height if supported */
            width: 100vw;
            position: fixed; 
            top: 0;
            left: 0;
            z-index: 1;
            will-change: transform;
            /* Performance optimization */
            transform: translateZ(0);
            backface-visibility: hidden;
        }

        /* Fix for iOS Safari 100vh issue */
        @supports (-webkit-touch-callout: none) {
            #map, .lochunt-container {
                height: -webkit-fill-available;
            }
        }

        /* Fallback for browsers that don't support dvh */
        @supports not (height: 100dvh) {
            #map {
                height: 100vh;
            }
        }

        /* REQUESTED CHANGE: Dark blue 1px border around distance box */
        #distanceBox {
            border: 1px solid var(--dark-blue) !important;
            transition: all 0.3s ease;
            /* Performance optimization */
            will-change: transform, background-color;
            transform: translateZ(0);
        }
        
        /* Responsive loading message */
        @media (max-width: 500px) {
            #loadingMessage > div {
                width: 85% !important;
                height: auto !important;
                min-height: 480px !important;
                padding: 25px 20px !important;
            }
        }

        /* Optimized animations with hardware acceleration */
        @keyframes pulse {
            0%, 100% { opacity: 0.8; transform: translateZ(0); }
            50% { opacity: 1; transform: translateZ(0); }
        }
        
        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        /* Hardware-accelerated fade animations */
        .fade-in {
            animation: fadeIn 0.3s ease forwards;
            will-change: opacity;
            transform: translateZ(0);
        }
        
        .fade-out {
            animation: fadeOut 0.3s ease forwards;
            will-change: opacity;
            transform: translateZ(0);
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateZ(0); }
            to { opacity: 1; transform: translateZ(0); }
        }
        
        @keyframes fadeOut {
            from { opacity: 1; transform: translateZ(0); }
            to { opacity: 0; transform: translateZ(0); }
        }

        /* High Contrast Mode */
        .high-contrast {
            filter: contrast(150%) brightness(120%);
        }
        
        .high-contrast #map {
            filter: contrast(200%) brightness(110%) saturate(150%);
        }
        
        .high-contrast .map-button,
        .high-contrast .audio-button {
            border-width: 3px !important;
            font-weight: bold !important;
        }

        /* Accessibility button */
        .accessibility-button {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1001;
            background: white;
            border: 2px solid var(--primary-color);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
            /* Performance optimization */
            will-change: transform;
            transform: translateZ(0);
        }

        .accessibility-button:hover {
            background: var(--hover-color);
            transform: scale(1.05) translateZ(0);
        }

        /* ARIA live region for announcements */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        /* Optimized user marker with hardware acceleration */
        .user-marker-icon {
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, #dc3545 0%, #a71e2a 70%);
            border: 3px solid white;
            border-radius: 50%;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            position: relative;
            transition: all 0.3s ease;
            /* Performance optimization */
            will-change: transform;
            transform: translateZ(0);
        }

        .user-marker-icon.moving {
            animation: pulse 2s infinite;
        }

        /* Enhanced distance box with proximity feedback and performance optimization */
        #distanceBox.proximity-close {
            background: linear-gradient(135deg, #28a745, #20c997);
            color: white;
            animation: pulse 1.5s infinite;
            transform: translateZ(0);
        }

        #distanceBox.proximity-medium {
            background: linear-gradient(135deg, #ffc107, #fd7e14);
            color: white;
            transform: translateZ(0);
        }

        #distanceBox.proximity-far {
            background: linear-gradient(135deg, #6c757d, #495057);
            color: white;
            transform: translateZ(0);
        }

        /* Performance optimizations for all elements */
        .map-button, .audio-button, .btn {
            will-change: transform, background-color;
            transform: translateZ(0);
            backface-visibility: hidden;
        }

        /* Memory optimization: lazy load images */
        img[data-src] {
            opacity: 0;
            transition: opacity 0.3s;
        }

        img[data-src].loaded {
            opacity: 1;
        }

        /* Optimize scrolling performance */
        .lochunt-container, .additional-info-container {
            -webkit-overflow-scrolling: touch;
            will-change: scroll-position;
            transform: translateZ(0);
        }

        /* Reduce repaints during animations */
        * {
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
    </style>
</head>
<body>
    <!-- Accessibility Features -->
    <div id="accessibility-announcements" class="sr-only" aria-live="polite" aria-atomic="true"></div>
    <div id="proximity-announcements" class="sr-only" aria-live="assertive" aria-atomic="true"></div>

    <!-- Map container -->
    <div id="map"></div>
    <div id="distanceBox">Initializing...</div>

    <!-- Location Hunt Container -->
    <div class="lochunt-container">
        <img id="locationImage" src="/placeholder.svg" alt="Location Image" loading="lazy">
        <div class="lochunt-content">
            <div class="lochunt-info">
                <h2 id="locationTitle" class="mb-2 text-primary"></h2>
                <p id="locationCity" class="text-muted mb-1"></p>
                <p id="locationCreator" class="text-muted mb-3"></p>
            </div>
            <div class="audio-player">
                <div class="audio-progress">
                    <div class="progress">
                        <div id="progressBar" class="progress-bar" role="progressbar" style="width: 0%"></div>
                    </div>
                </div>
                <div class="audio-time">
                    <span id="currentTime">0:00</span>
                    <span id="duration">0:00</span>
                </div>
                <div class="audio-controls">
                    <button id="rewindBtn" class="audio-button" aria-label="Rewind 10 seconds"><i class="fas fa-backward"></i></button>
                    <button id="playPauseBtn" class="audio-button" aria-label="Play"><i class="fas fa-play"></i></button>
                    <button id="forwardBtn" class="audio-button" aria-label="Forward 10 seconds"><i class="fas fa-forward"></i></button>
                </div>
                <audio id="locationAudio" src="/placeholder.svg" preload="auto"></audio>
            </div>
        </div>
    </div>

    <!-- Additional Info Container -->
    <div class="additional-info-container">
        <h3 class="mb-3 text-primary text-center">Did You Know?</h3>
        <p id="additionalInfo" class="mb-3 fs-6"></p>
        <div class="d-flex justify-content-center">
            <button id="continueButton" class="btn btn-primary">Continue</button>
        </div>
    </div>
    
    <!-- Map Buttons -->
    <div class="map-buttons">
        <button id="recenterButton" class="map-button" aria-label="Recenter map"><i class="fas fa-crosshairs"></i></button>
        <button id="returnButton" class="map-button" aria-label="Return to main page"><i class="fas fa-sign-out-alt"></i></button>
        <button id="tipsButton" class="map-button" aria-label="Show navigation tips"><i class="fas fa-question-circle"></i></button>
    </div>

    <!-- Summary Modal -->
    <div id="summaryModal" class="modal" style="display: none;">
        <div class="modal-content">
            <p id="summaryContent"></p>
        </div>
    </div>

    <!-- Load scripts with enhanced security and performance -->
    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.js" 
            integrity="sha512-XQoYMqMTK8LvdxXYG3nZ448hOEQiglfqkJs1NOQV44cWnUrBc8PkAOcXy20w0vlaXaVUearIOBhiXZ5V3ynxwA==" 
            crossorigin="anonymous" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js" 
            integrity="sha384-w76AqPfDkMBDXo30jS1Sgez6pr3x5MlQ1ZAGC+nuZB+EYdgRZgiwxhTBTkF7CXvN" 
            crossorigin="anonymous" defer></script>
    <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js" 
            integrity="sha512-MQlyPV+ol2lp4KodaU/Xmrn+txc1TP15pOBF/2Sfre7MRsA/pB4Vy58bEqe9u7a7DczMLtU5wT8n7OblJepKbg==" 
            crossorigin="anonymous" defer></script>
    <script src="/locations_main.js?v=1.0.4" defer></script>

    <script>
// MNThen - Complete Optimized JavaScript Application
// Enhanced with Security, Performance, Memory Management, and PWA Features
// Target: Production-ready application with Autio-level quality

// =============================================================================
// SECURITY & CONFIGURATION
// =============================================================================

// Content Security Policy enforcement
const CSP_VIOLATIONS = [];
const MAX_CSP_VIOLATIONS = 10;

// Security monitoring
function reportCSPViolation(violation) {
    if (CSP_VIOLATIONS.length < MAX_CSP_VIOLATIONS) {
        CSP_VIOLATIONS.push({
            blockedURI: violation.blockedURI,
            violatedDirective: violation.violatedDirective,
            timestamp: Date.now()
        });
        console.warn('CSP Violation:', violation);
    }
}

// Input sanitization
function sanitizeInput(input) {
    if (typeof input !== 'string') return input;
    return input
        .replace(/[<>]/g, '')
        .replace(/javascript:/gi, '')
        .replace(/data:/gi, '')
        .trim();
}

// URL validation
function isValidURL(url) {
    try {
        const urlObj = new URL(url);
        const allowedProtocols = ['http:', 'https:', 'mailto:'];
        const allowedDomains = [
            'mnthen.com',
            'www.mnthen.com',
            'tile.openstreetmap.org',
            'cdn.jsdelivr.net',
            'cdnjs.cloudflare.com',
            'unpkg.com'
        ];
        
        if (!allowedProtocols.includes(urlObj.protocol)) return false;
        if (urlObj.protocol === 'mailto:') return true;
        
        return allowedDomains.some(domain => 
            urlObj.hostname === domain || urlObj.hostname.endsWith('.' + domain)
        );
    } catch {
        return false;
    }
}

// =============================================================================
// ENHANCED CONFIGURATION SYSTEM
// =============================================================================

const CONFIG = {
    // Core distance and proximity settings
    DISTANCE_THRESHOLD: 20, // feet
    EXTENDED_DISTANCE_THRESHOLD: 100, // meters
    MIN_DISTANCE_THRESHOLD: 2, // meters
    PROXIMITY_THRESHOLD: 50, // feet
    JITTER_THRESHOLD: 5, // meters
    MICRO_MOVEMENT_THRESHOLD: 0.3, // meters
    
    // Timing configurations
    BACKGROUND_THRESHOLD: 25000, // ms
    INACTIVITY_TIMEOUT: 29000, // ms
    UPDATE_INTERVAL: 50, // ms
    MIN_CENTERING_INTERVAL: 1000, // ms
    STATIONARY_TIME_THRESHOLD: 5000, // ms
    STATIONARY_CHECK_INTERVAL: 2500, // ms
    SIGNIFICANT_MOVEMENT_COOLDOWN: 2000, // ms
    RETRY_DELAY: 1000, // ms
    ZOOM_COOLDOWN: 10000, // ms
    MIN_RECENTER_INTERVAL: 2000, // ms
    
    // Buffer and accuracy settings
    MAX_BUFFER_SIZE: 5,
    STATIONARY_BUFFER_SIZE: 10,
    MAX_ACCEPTABLE_ACCURACY: 39, // meters
    STATIONARY_ACCURACY_MULTIPLIER: 1.1,
    STATIONARY_ACCURACY_WEIGHT: 0.7,
    MAX_ACCURACY_THRESHOLD: 2500,
    TARGET_ACCURACY_THRESHOLD: 100,
    
    // Movement and velocity settings
    MAX_SPEED: 50, // m/s
    VELOCITY_DECAY: 0.8,
    BEARING_WEIGHT: 0.3,
    SMOOTHING_FACTOR: 0.3,
    STATIONARY_THRESHOLD: 2,
    STATIONARY_SMOOTHING: 0.95,
    STATIONARY_THRESHOLDB: 3,
    MAX_ALPHA: 0.2,
    MIN_ALPHA: 0.025,
    MAX_RETRIES: 3,
    
    // Edge detection settings
    EDGE_THRESHOLD_PERCENTAGE: 0.25,
    STRICT_EDGE_THRESHOLD_PERCENTAGE: 0.15,
    CRITICAL_EDGE_THRESHOLD_PERCENTAGE: 0.07,
    
    // Zoom system configuration
    OVERVIEW_ZOOM: 15,
    EXPLORATION_ZOOM: 17,
    DETAIL_ZOOM: 18,
    BASE_ZOOM: 17,
    CLOSE_ZOOM: 18,
    
    // Kalman filter settings
    BASE_PROCESS_NOISE: 0.01,
    
    // Speed-based zoom thresholds
    SPEED_ZOOM_THRESHOLDS: [
        { speed: 35, zoom: 15 },
        { speed: 25, zoom: 16 },
        { speed: 15, zoom: 16 },
        { speed: 10, zoom: 17 },
        { speed: 0, zoom: 17 }
    ],
    
    // Location triggering settings
    BEARING_TOLERANCE: 30, // degrees
    DWELL_TIME: 1500, // ms
    LOCATION_COOLDOWN: 120000, // ms
    
    // Predictive smoothing settings
    PREDICTION_ENABLED: true,
    VELOCITY_PREDICTION_FACTOR: 0.3,
    ACCELERATION_DAMPING: 0.7,
    
    // Performance settings
    ANIMATION_FRAME_BUDGET: 16, // ms
    MEMORY_CHECK_INTERVAL: 30000, // ms
    CACHE_CLEANUP_INTERVAL: 300000, // ms
    MAX_EVENT_LISTENERS: 100,
    
    // Security settings
    MAX_REQUEST_SIZE: 1048576, // 1MB
    REQUEST_TIMEOUT: 30000, // ms
    MAX_CONCURRENT_REQUESTS: 5
};

// =============================================================================
// MEMORY MANAGEMENT SYSTEM
// =============================================================================

class MemoryManager {
    constructor() {
        this.allocatedObjects = new WeakSet();
        this.eventListeners = new Map();
        this.timers = new Set();
        this.intervals = new Set();
        this.animationFrames = new Set();
        this.observers = new Set();
        this.memoryUsage = {
            peak: 0,
            current: 0,
            lastCheck: Date.now()
        };
        
        this.startMonitoring();
    }
    
    startMonitoring() {
        // Monitor memory usage
        this.memoryCheckInterval = setInterval(() => {
            this.checkMemoryUsage();
            this.cleanupStaleReferences();
        }, CONFIG.MEMORY_CHECK_INTERVAL);
        
        this.intervals.add(this.memoryCheckInterval);
        
        // Monitor performance
        if ('performance' in window && 'memory' in performance) {
            this.performanceObserver = new PerformanceObserver((list) => {
                this.handlePerformanceEntries(list.getEntries());
            });
            
            try {
                this.performanceObserver.observe({ entryTypes: ['measure', 'navigation'] });
                this.observers.add(this.performanceObserver);
            } catch (e) {
                console.warn('Performance observer not supported:', e);
            }
        }
    }
    
    checkMemoryUsage() {
        if ('memory' in performance) {
            const memory = performance.memory;
            this.memoryUsage.current = memory.usedJSHeapSize;
            this.memoryUsage.peak = Math.max(this.memoryUsage.peak, this.memoryUsage.current);
            
            // Trigger cleanup if memory usage is high
            const memoryPressure = this.memoryUsage.current / memory.jsHeapSizeLimit;
            if (memoryPressure > 0.8) {
                console.warn('High memory usage detected, triggering cleanup');
                this.forceCleanup();
            }
        }
    }
    
    handlePerformanceEntries(entries) {
        entries.forEach(entry => {
            if (entry.entryType === 'measure' && entry.duration > CONFIG.ANIMATION_FRAME_BUDGET) {
                console.warn(`Performance warning: ${entry.name} took ${entry.duration}ms`);
            }
        });
    }
    
    registerEventListener(element, event, handler, options) {
        const key = `${element.constructor.name}_${event}`;
        if (!this.eventListeners.has(key)) {
            this.eventListeners.set(key, new Set());
        }
        
        this.eventListeners.get(key).add({ element, handler, options });
        element.addEventListener(event, handler, options);
        
        // Prevent memory leaks from too many listeners
        if (this.eventListeners.size > CONFIG.MAX_EVENT_LISTENERS) {
            console.warn('Too many event listeners registered');
        }
    }
    
    unregisterEventListener(element, event, handler) {
        const key = `${element.constructor.name}_${event}`;
        const listeners = this.eventListeners.get(key);
        if (listeners) {
            listeners.forEach(listener => {
                if (listener.element === element && listener.handler === handler) {
                    element.removeEventListener(event, handler);
                    listeners.delete(listener);
                }
            });
        }
    }
    
    registerTimer(timerId) {
        this.timers.add(timerId);
        return timerId;
    }
    
    registerInterval(intervalId) {
        this.intervals.add(intervalId);
        return intervalId;
    }
    
    registerAnimationFrame(frameId) {
        this.animationFrames.add(frameId);
        return frameId;
    }
    
    cleanupStaleReferences() {
        // Clean up completed animation frames
        this.animationFrames.forEach(frameId => {
            // Animation frames auto-cleanup, just remove from tracking
            this.animationFrames.delete(frameId);
        });
        
        // Force garbage collection if available (development only)
        if (window.gc && typeof window.gc === 'function') {
            window.gc();
        }
    }
    
    forceCleanup() {
        // Clear all timers
        this.timers.forEach(timerId => {
            clearTimeout(timerId);
        });
        this.timers.clear();
        
        // Clear non-essential intervals
        this.intervals.forEach(intervalId => {
            if (intervalId !== this.memoryCheckInterval) {
                clearInterval(intervalId);
                this.intervals.delete(intervalId);
            }
        });
        
        // Cancel animation frames
        this.animationFrames.forEach(frameId => {
            cancelAnimationFrame(frameId);
        });
        this.animationFrames.clear();
        
        // Trigger cleanup in other systems
        if (window.audioPlayerCleanup) {
            window.audioPlayerCleanup();
        }
        
        // Clear caches
        if (positionBuffer) positionBuffer.length = 0;
        if (stationaryBuffer) stationaryBuffer.length = 0;
    }
    
    cleanup() {
        // Clean up all managed resources
        this.forceCleanup();
        
        // Clean up observers
        this.observers.forEach(observer => {
            observer.disconnect();
        });
        this.observers.clear();
        
        // Clean up event listeners
        this.eventListeners.forEach((listeners, key) => {
            listeners.forEach(({ element, handler }) => {
                try {
                    element.removeEventListener(key.split('_')[1], handler);
                } catch (e) {
                    console.warn('Error cleaning up event listener:', e);
                }
            });
        });
        this.eventListeners.clear();
        
        // Clear memory check interval
        if (this.memoryCheckInterval) {
            clearInterval(this.memoryCheckInterval);
        }
    }
    
    getMemoryStats() {
        return {
            ...this.memoryUsage,
            eventListeners: this.eventListeners.size,
            timers: this.timers.size,
            intervals: this.intervals.size,
            animationFrames: this.animationFrames.size,
            observers: this.observers.size
        };
    }
}

// =============================================================================
// PERFORMANCE MONITORING SYSTEM
// =============================================================================

class PerformanceMonitor {
    constructor() {
        this.metrics = {
            frameRate: [],
            memoryUsage: [],
            networkRequests: [],
            userInteractions: [],
            locationUpdates: []
        };
        
        this.thresholds = {
            frameRate: 30, // fps
            memoryUsage: 50 * 1024 * 1024, // 50MB
            networkLatency: 1000, // ms
            locationAccuracy: 50 // meters
        };
        
        this.startMonitoring();
    }
    
    startMonitoring() {
        // Monitor frame rate
        let lastFrameTime = performance.now();
        let frameCount = 0;
        
        const measureFrameRate = () => {
            const currentTime = performance.now();
            frameCount++;
            
            if (currentTime - lastFrameTime >= 1000) {
                const fps = frameCount;
                this.recordMetric('frameRate', fps);
                
                if (fps < this.thresholds.frameRate) {
                    console.warn(`Low frame rate detected: ${fps} fps`);
                }
                
                frameCount = 0;
                lastFrameTime = currentTime;
            }
            
            requestAnimationFrame(measureFrameRate);
        };
        
        requestAnimationFrame(measureFrameRate);
        
        // Monitor network requests
        this.interceptNetworkRequests();
        
        // Monitor user interactions
        this.monitorUserInteractions();
    }
    
    recordMetric(type, value, metadata = {}) {
        const metric = {
            value,
            timestamp: Date.now(),
            ...metadata
        };
        
        this.metrics[type].push(metric);
        
        // Keep only last 100 entries per metric type
        if (this.metrics[type].length > 100) {
            this.metrics[type].shift();
        }
    }
    
    interceptNetworkRequests() {
        const originalFetch = window.fetch;
        
        window.fetch = async (...args) => {
            const startTime = performance.now();
            const url = args[0];
            
            try {
                const response = await originalFetch(...args);
                const endTime = performance.now();
                const duration = endTime - startTime;
                
                this.recordMetric('networkRequests', duration, {
                    url: url.toString(),
                    status: response.status,
                    success: response.ok
                });
                
                if (duration > this.thresholds.networkLatency) {
                    console.warn(`Slow network request: ${url} took ${duration}ms`);
                }
                
                return response;
            } catch (error) {
                const endTime = performance.now();
                const duration = endTime - startTime;
                
                this.recordMetric('networkRequests', duration, {
                    url: url.toString(),
                    error: error.message,
                    success: false
                });
                
                throw error;
            }
        };
    }
    
    monitorUserInteractions() {
        const interactionEvents = ['click', 'touch', 'scroll', 'keypress'];
        
        interactionEvents.forEach(eventType => {
            document.addEventListener(eventType, (event) => {
                this.recordMetric('userInteractions', 1, {
                    type: eventType,
                    target: event.target.tagName
                });
            }, { passive: true });
        });
    }
    
    recordLocationUpdate(accuracy, speed, timestamp) {
        this.recordMetric('locationUpdates', accuracy, {
            speed,
            timestamp
        });
        
        if (accuracy > this.thresholds.locationAccuracy) {
            console.warn(`Poor location accuracy: ${accuracy}m`);
        }
    }
    
    getPerformanceReport() {
        const report = {};
        
        Object.keys(this.metrics).forEach(type => {
            const metrics = this.metrics[type];
            if (metrics.length > 0) {
                const values = metrics.map(m => m.value);
                report[type] = {
                    count: metrics.length,
                    average: values.reduce((a, b) => a + b, 0) / values.length,
                    min: Math.min(...values),
                    max: Math.max(...values),
                    latest: metrics[metrics.length - 1]
                };
            }
        });
        
        return report;
    }
}

// =============================================================================
// ENHANCED PWA SERVICE WORKER INTEGRATION
// =============================================================================

class ServiceWorkerManager {
    constructor() {
        this.registration = null;
        this.isOnline = navigator.onLine;
        this.messageQueue = [];
        
        this.init();
    }
    
    async init() {
        if ('serviceWorker' in navigator) {
            try {
                this.registration = await navigator.serviceWorker.register('/sw.js', {
                    scope: '/',
                    updateViaCache: 'none'
                });
                
                console.log('Service Worker registered successfully');
                
                // Listen for service worker messages
                navigator.serviceWorker.addEventListener('message', (event) => {
                    this.handleServiceWorkerMessage(event);
                });
                
                // Handle service worker updates
                this.registration.addEventListener('updatefound', () => {
                    this.handleServiceWorkerUpdate();
                });
                
                // Monitor online/offline status
                window.addEventListener('online', () => {
                    this.isOnline = true;
                    this.processMessageQueue();
                });
                
                window.addEventListener('offline', () => {
                    this.isOnline = false;
                });
                
            } catch (error) {
                console.error('Service Worker registration failed:', error);
            }
        }
    }
    
    handleServiceWorkerMessage(event) {
        const { type, data } = event.data;
        
        switch (type) {
            case 'SW_ACTIVATED':
                console.log('Service Worker activated, version:', data.version);
                break;
                
            case 'CACHE_STATS_RESPONSE':
                console.log('Cache statistics:', data.stats);
                break;
                
            case 'CLEANUP_COMPLETE':
                console.log('Cache cleanup completed');
                break;
                
            case 'PONG':
                console.log('Service Worker is responsive');
                break;
        }
    }
    
    handleServiceWorkerUpdate() {
        const newWorker = this.registration.installing;
        
        newWorker.addEventListener('statechange', () => {
            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                // New version available
                this.showUpdateNotification();
            }
        });
    }
    
    showUpdateNotification() {
        // Show user-friendly update notification
        const notification = document.createElement('div');
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: #2c5282;
            color: white;
            padding: 16px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            z-index: 10000;
            max-width: 300px;
        `;
        
        notification.innerHTML = `
            <div style="margin-bottom: 12px;">
                <strong>Update Available</strong>
            </div>
            <div style="margin-bottom: 12px; font-size: 14px;">
                A new version of the app is available.
            </div>
            <button onclick="window.location.reload()" style="
                background: white;
                color: #2c5282;
                border: none;
                padding: 8px 16px;
                border-radius: 4px;
                cursor: pointer;
                font-weight: 600;
            ">Update Now</button>
        `;
        
        document.body.appendChild(notification);
        
        // Auto-remove after 10 seconds
        setTimeout(() => {
            if (notification.parentNode) {
                notification.remove();
            }
        }, 10000);
    }
    
    sendMessage(type, data = {}) {
        const message = { type, data };
        
        if (navigator.serviceWorker.controller) {
            navigator.serviceWorker.controller.postMessage(message);
        } else {
            // Queue message for when service worker is available
            this.messageQueue.push(message);
        }
    }
    
    processMessageQueue() {
        if (navigator.serviceWorker.controller && this.messageQueue.length > 0) {
            this.messageQueue.forEach(message => {
                navigator.serviceWorker.controller.postMessage(message);
            });
            this.messageQueue = [];
        }
    }
    
    prefetchAudio(userLocation, locations) {
        this.sendMessage('PREFETCH_AUDIO', {
            userLocation,
            locations
        });
    }
    
    getCacheStats() {
        return new Promise((resolve) => {
            const channel = new MessageChannel();
            channel.port1.onmessage = (event) => {
                if (event.data.type === 'CACHE_STATS_RESPONSE') {
                    resolve(event.data.stats);
                }
            };
            
            this.sendMessage('CACHE_STATS');
        });
    }
    
    cleanupCache() {
        this.sendMessage('CLEANUP_CACHE');
    }
}

// =============================================================================
// ENHANCED KALMAN FILTER WITH PREDICTIVE CAPABILITIES
// =============================================================================

class EnhancedKalmanFilter {
    constructor() {
        this.state = {
            x: { position: 0, velocity: 0, acceleration: 0, error: 1 },
            y: { position: 0, velocity: 0, acceleration: 0, error: 1 }
        };
        
        this.processNoise = CONFIG.BASE_PROCESS_NOISE;
        this.measurementNoise = 1;
        this.lastTimestamp = null;
        this.initialized = false;
        
        // Adaptive parameters
        this.adaptiveGain = 0.5;
        this.velocitySmoothing = 0.7;
        this.accelerationDamping = CONFIG.ACCELERATION_DAMPING;
    }
    
    initialize(measurement) {
        this.state.x.position = measurement.lng;
        this.state.y.position = measurement.lat;
        this.state.x.velocity = 0;
        this.state.y.velocity = 0;
        this.state.x.acceleration = 0;
        this.state.y.acceleration = 0;
        this.lastTimestamp = measurement.timestamp;
        this.initialized = true;
    }
    
    predict(dt) {
        if (dt <= 0 || dt > 10) return;
        
        // Predict position using velocity and acceleration
        this.state.x.position += this.state.x.velocity * dt + 0.5 * this.state.x.acceleration * dt * dt;
        this.state.y.position += this.state.y.velocity * dt + 0.5 * this.state.y.acceleration * dt * dt;
        
        // Predict velocity using acceleration
        this.state.x.velocity += this.state.x.acceleration * dt;
        this.state.y.velocity += this.state.y.acceleration * dt;
        
        // Apply velocity damping
        this.state.x.velocity *= this.velocitySmoothing;
        this.state.y.velocity *= this.velocitySmoothing;
        
        // Apply acceleration damping
        this.state.x.acceleration *= this.accelerationDamping;
        this.state.y.acceleration *= this.accelerationDamping;
        
        // Update error estimates
        this.state.x.error += this.processNoise * dt;
        this.state.y.error += this.processNoise * dt;
    }
    
    update(measurement) {
        if (!this.initialized) {
            this.initialize(measurement);
            return this.getState();
        }
        
        const currentTime = measurement.timestamp || Date.now();
        const dt = this.lastTimestamp ? (currentTime - this.lastTimestamp) / 1000 : 0;
        
        if (dt > 0) {
            // Prediction step
            this.predict(dt);
            
            // Calculate adaptive measurement noise based on accuracy
            const adaptiveMeasurementNoise = this.measurementNoise * 
                (measurement.accuracy ? (measurement.accuracy / 10) : 1);
            
            // Update step for position
            const gainX = this.state.x.error / (this.state.x.error + adaptiveMeasurementNoise);
            const gainY = this.state.y.error / (this.state.y.error + adaptiveMeasurementNoise);
            
            // Calculate innovation (difference between measurement and prediction)
            const innovationX = measurement.lng - this.state.x.position;
            const innovationY = measurement.lat - this.state.y.position;
            
            // Update position estimates
            this.state.x.position += gainX * innovationX;
            this.state.y.position += gainY * innovationY;
            
            // Update velocity estimates based on innovation
            if (dt > 0) {
                const velocityInnovationX = innovationX / dt;
                const velocityInnovationY = innovationY / dt;
                
                this.state.x.velocity += this.adaptiveGain * velocityInnovationX;
                this.state.y.velocity += this.adaptiveGain * velocityInnovationY;
                
                // Update acceleration estimates
                const accelerationInnovationX = velocityInnovationX / dt;
                const accelerationInnovationY = velocityInnovationY / dt;
                
                this.state.x.acceleration += this.adaptiveGain * 0.1 * accelerationInnovationX;
                this.state.y.acceleration += this.adaptiveGain * 0.1 * accelerationInnovationY;
            }
            
            // Update error estimates
            this.state.x.error *= (1 - gainX);
            this.state.y.error *= (1 - gainY);
        }
        
        this.lastTimestamp = currentTime;
        return this.getState();
    }
    
    getState() {
        return {
            lat: this.state.y.position,
            lng: this.state.x.position,
            velocity: {
                lat: this.state.y.velocity,
                lng: this.state.x.velocity
            },
            acceleration: {
                lat: this.state.y.acceleration,
                lng: this.state.x.acceleration
            },
            error: {
                lat: this.state.y.error,
                lng: this.state.x.error
            }
        };
    }
    
    reset(measurement) {
        this.initialized = false;
        this.initialize(measurement);
    }
    
    // Predict future position
    predictFuturePosition(secondsAhead) {
        if (!this.initialized || secondsAhead <= 0) {
            return this.getState();
        }
        
        const dt = secondsAhead;
        const futureX = this.state.x.position + 
                       this.state.x.velocity * dt + 
                       0.5 * this.state.x.acceleration * dt * dt;
        const futureY = this.state.y.position + 
                       this.state.y.velocity * dt + 
                       0.5 * this.state.y.acceleration * dt * dt;
        
        return {
            lat: futureY,
            lng: futureX,
            confidence: Math.max(0, 1 - (dt * 0.2)) // Confidence decreases with time
        };
    }
}

// =============================================================================
// INTELLIGENT ZOOM SYSTEM
// =============================================================================

class IntelligentZoomManager {
    constructor() {
        this.currentTier = 'exploration';
        this.lastTierChange = 0;
        this.hysteresisBuffer = [];
        this.proximityOverride = false;
        this.speedBuffer = [];
        this.zoomTransitions = new Map();
        
        // Zoom tiers with smooth transitions
        this.zoomTiers = {
            overview: { zoom: 15, description: 'Highway/Fast Travel' },
            exploration: { zoom: 17, description: 'Normal Navigation' },
            detail: { zoom: 18, description: 'Point of Interest' }
        };
    }
    
    calculateOptimalZoom(speedMPS, distanceToClosestPOI, userPosition) {
        const currentTime = Date.now();
        const speedMPH = speedMPS * 2.23694;
        
        // Add speed to hysteresis buffer
        this.speedBuffer.push({ speed: speedMPH, time: currentTime });
        
        // Keep only last 10 seconds of data
        this.speedBuffer = this.speedBuffer.filter(
            entry => currentTime - entry.time < 10000
        );
        
        // Calculate average speed over buffer period
        const avgSpeed = this.speedBuffer.reduce((sum, entry) => sum + entry.speed, 0) / 
                        this.speedBuffer.length;
        
        // Determine target tier
        let targetTier;
        let targetZoom;
        
        // Check proximity override first
        if (distanceToClosestPOI <= CONFIG.PROXIMITY_THRESHOLD) {
            targetTier = 'detail';
            targetZoom = this.zoomTiers.detail.zoom;
            this.proximityOverride = true;
        } else {
            this.proximityOverride = false;
            
            if (avgSpeed > 10) {
                targetTier = 'overview';
                targetZoom = this.zoomTiers.overview.zoom;
            } else if (avgSpeed > 3) {
                targetTier = 'exploration';
                targetZoom = this.zoomTiers.exploration.zoom;
            } else {
                targetTier = 'exploration';
                targetZoom = this.zoomTiers.exploration.zoom;
            }
        }
        
        // Apply hysteresis - only change if we've been in new tier for enough time
        if (targetTier !== this.currentTier) {
            if (currentTime - this.lastTierChange > CONFIG.ZOOM_COOLDOWN) {
                this.currentTier = targetTier;
                this.lastTierChange = currentTime;
                
                // Announce zoom changes for accessibility
                if (window.announceToScreenReader) {
                    window.announceToScreenReader(`Map zoom changed to ${targetTier} view`);
                }
                
                return {
                    zoom: targetZoom,
                    tier: targetTier,
                    changed: true
                };
            } else {
                // Return current zoom to prevent rapid changes
                return {
                    zoom: map ? map.getZoom() : this.zoomTiers.exploration.zoom,
                    tier: this.currentTier,
                    changed: false
                };
            }
        }
        
        return {
            zoom: targetZoom,
            tier: targetTier,
            changed: false
        };
    }
    
    smoothZoomTransition(currentZoom, targetZoom, duration = 1000) {
        if (Math.abs(currentZoom - targetZoom) < 0.1) {
            return Promise.resolve();
        }
        
        return new Promise((resolve) => {
            const startTime = Date.now();
            const startZoom = currentZoom;
            const zoomDiff = targetZoom - startZoom;
            
            const animate = () => {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Easing function for smooth transition
                const easeProgress = 1 - Math.pow(1 - progress, 3);
                const currentZoomLevel = startZoom + (zoomDiff * easeProgress);
                
                if (map) {
                    map.setZoom(currentZoomLevel, { animate: false });
                }
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    resolve();
                }
            };
            
            requestAnimationFrame(animate);
        });
    }
    
    getZoomStats() {
        return {
            currentTier: this.currentTier,
            proximityOverride: this.proximityOverride,
            speedBufferSize: this.speedBuffer.length,
            lastTierChange: this.lastTierChange
        };
    }
}

// =============================================================================
// ADVANCED LOCATION TRIGGERING SYSTEM
// =============================================================================

class LocationTriggerManager {
    constructor() {
        this.cooldowns = new Map();
        this.dwellTimers = new Map();
        this.approachingLocations = new Set();
        this.lastBearing = null;
        this.proximityAlerts = new Set();
        this.triggerHistory = [];
        
        // Geofencing parameters
        this.geofences = new Map();
        this.entryCallbacks = new Map();
        this.exitCallbacks = new Map();
    }
    
    createGeofence(locationId, center, radius, callbacks = {}) {
        this.geofences.set(locationId, {
            center,
            radius,
            active: true
        });
        
        if (callbacks.onEntry) {
            this.entryCallbacks.set(locationId, callbacks.onEntry);
        }
        
        if (callbacks.onExit) {
            this.exitCallbacks.set(locationId, callbacks.onExit);
        }
    }
    
    checkGeofences(userPosition) {
        this.geofences.forEach((geofence, locationId) => {
            if (!geofence.active) return;
            
            const distance = this.calculateDistance(userPosition, geofence.center);
            const isInside = distance <= geofence.radius;
            const wasInside = this.approachingLocations.has(locationId);
            
            if (isInside && !wasInside) {
                // Entered geofence
                this.approachingLocations.add(locationId);
                const callback = this.entryCallbacks.get(locationId);
                if (callback) callback(locationId, distance);
                
                this.recordTriggerEvent(locationId, 'geofence_entry', distance);
            } else if (!isInside && wasInside) {
                // Exited geofence
                this.approachingLocations.delete(locationId);
                const callback = this.exitCallbacks.get(locationId);
                if (callback) callback(locationId, distance);
                
                this.recordTriggerEvent(locationId, 'geofence_exit', distance);
            }
        });
    }
    
    calculateBearing(from, to) {
        const lat1 = from.lat * Math.PI / 180;
        const lat2 = to.lat * Math.PI / 180;
        const deltaLng = (to.lng - from.lng) * Math.PI / 180;
        
        const y = Math.sin(deltaLng) * Math.cos(lat2);
        const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(deltaLng);
        
        const bearing = Math.atan2(y, x) * 180 / Math.PI;
        return (bearing + 360) % 360;
    }
    
    isApproachingLocation(userPos, userBearing, locationPos) {
        if (!userBearing) return true;
        
        const bearingToLocation = this.calculateBearing(userPos, locationPos);
        const bearingDiff = Math.abs(userBearing - bearingToLocation);
        const normalizedDiff = Math.min(bearingDiff, 360 - bearingDiff);
        
        return normalizedDiff <= CONFIG.BEARING_TOLERANCE;
    }
    
    calculateDistance(pos1, pos2) {
        const R = 6371000; // Earth's radius in meters
        const lat1 = pos1.lat * Math.PI / 180;
        const lat2 = pos2.lat * Math.PI / 180;
        const deltaLat = (pos2.lat - pos1.lat) * Math.PI / 180;
        const deltaLng = (pos2.lng - pos1.lng) * Math.PI / 180;

        const a = Math.sin(deltaLat/2) * Math.sin(deltaLat/2) +
                Math.cos(lat1) * Math.cos(lat2) *
                Math.sin(deltaLng/2) * Math.sin(deltaLng/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

        return R * c;
    }
    
    checkLocationTrigger(userPos, userBearing, location) {
        const distance = this.calculateDistance(userPos, location);
        const distanceFeet = distance * 3.28084;
        
        if (distanceFeet <= CONFIG.DISTANCE_THRESHOLD) {
            const isApproaching = this.isApproachingLocation(userPos, userBearing, location);
            
            if (isApproaching) {
                const locationId = location.id;
                const now = Date.now();
                
                // Check cooldown
                const lastTrigger = this.cooldowns.get(locationId);
                if (lastTrigger && (now - lastTrigger) < CONFIG.LOCATION_COOLDOWN) {
                    return false;
                }
                
                // Start or check dwell timer
                if (!this.dwellTimers.has(locationId)) {
                    this.dwellTimers.set(locationId, now);
                    return false;
                } else {
                    const dwellStart = this.dwellTimers.get(locationId);
                    if ((now - dwellStart) >= CONFIG.DWELL_TIME) {
                        // Trigger location
                        this.cooldowns.set(locationId, now);
                        this.dwellTimers.delete(locationId);
                        this.recordTriggerEvent(locationId, 'location_trigger', distanceFeet);
                        
                        // Haptic feedback
                        if ('vibrate' in navigator) {
                            navigator.vibrate([100, 50, 100]);
                        }
                        
                        return true;
                    }
                }
            } else {
                // Clear dwell timer if not approaching
                this.dwellTimers.delete(location.id);
            }
        } else {
            // Clear dwell timer if too far away
            this.dwellTimers.delete(location.id);
        }
        
        return false;
    }
    
    recordTriggerEvent(locationId, eventType, distance) {
        this.triggerHistory.push({
            locationId,
            eventType,
            distance,
            timestamp: Date.now()
        });
        
        // Keep only last 100 events
        if (this.triggerHistory.length > 100) {
            this.triggerHistory.shift();
        }
    }
    
    clearCooldowns() {
        this.cooldowns.clear();
        this.dwellTimers.clear();
    }
    
    getTriggerStats() {
        return {
            activeCooldowns: this.cooldowns.size,
            activeDwellTimers: this.dwellTimers.size,
            approachingLocations: this.approachingLocations.size,
            triggerHistory: this.triggerHistory.length,
            recentTriggers: this.triggerHistory.slice(-10)
        };
    }
}

// =============================================================================
// ACCESSIBILITY SYSTEM
// =============================================================================

class AccessibilityManager {
    constructor() {
        this.highContrast = localStorage.getItem('highContrast') === 'true';
        this.lastAnnouncement = '';
        this.proximityAlerts = new Set();
        this.screenReader = this.detectScreenReader();
        this.announceQueue = [];
        this.isAnnouncing = false;
        
        this.init();
    }
    
    init() {
        // Initialize high contrast mode
        if (this.highContrast) {
            document.body.classList.add('high-contrast');
        }
        
        // Set up keyboard navigation
        this.setupKeyboardNavigation();
        
        // Set up focus management
        this.setupFocusManagement();
        
        // Set up ARIA live regions
        this.setupLiveRegions();
    }
    
    detectScreenReader() {
        // Detect common screen readers
        const userAgent = navigator.userAgent.toLowerCase();
        
        if (userAgent.includes('nvda') || userAgent.includes('jaws') || 
            userAgent.includes('voiceover') || userAgent.includes('talkback')) {
            return true;
        }
        
        // Check for screen reader specific APIs
        return !!(window.speechSynthesis || window.navigator.tts);
    }
    
    setupKeyboardNavigation() {
        document.addEventListener('keydown', (event) => {
            switch (event.key) {
                case 'r':
                case 'R':
                    if (event.ctrlKey || event.metaKey) return;
                    event.preventDefault();
                    this.recenterMap();
                    this.announce('Map recentered on your location');
                    break;
                    
                case 'h':
                case 'H':
                    if (event.ctrlKey || event.metaKey) return;
                    event.preventDefault();
                    this.showNavigationTips();
                    break;
                    
                case 'c':
                case 'C':
                    if (event.ctrlKey || event.metaKey) return;
                    event.preventDefault();
                    this.toggleHighContrast();
                    break;
                    
                case 'Escape':
                    this.closeModals();
                    break;
            }
        });
    }
    
    setupFocusManagement() {
        // Trap focus in modals
        document.addEventListener('focusin', (event) => {
            const modal = event.target.closest('.modal, .popup-overlay');
            if (modal) {
                this.trapFocus(modal, event);
            }
        });
    }
    
    setupLiveRegions() {
        // Ensure ARIA live regions exist
        if (!document.getElementById('accessibility-announcements')) {
            const announcements = document.createElement('div');
            announcements.id = 'accessibility-announcements';
            announcements.className = 'sr-only';
            announcements.setAttribute('aria-live', 'polite');
            announcements.setAttribute('aria-atomic', 'true');
            document.body.appendChild(announcements);
        }
        
        if (!document.getElementById('proximity-announcements')) {
            const proximity = document.createElement('div');
            proximity.id = 'proximity-announcements';
            proximity.className = 'sr-only';
            proximity.setAttribute('aria-live', 'assertive');
            proximity.setAttribute('aria-atomic', 'true');
            document.body.appendChild(proximity);
        }
    }
    
    announce(message, priority = 'polite') {
        if (!message || message === this.lastAnnouncement) return;
        
        this.announceQueue.push({ message, priority });
        this.processAnnounceQueue();
    }
    
    async processAnnounceQueue() {
        if (this.isAnnouncing || this.announceQueue.length === 0) return;
        
        this.isAnnouncing = true;
        
        while (this.announceQueue.length > 0) {
            const { message, priority } = this.announceQueue.shift();
            
            const element = priority === 'assertive' ? 
                document.getElementById('proximity-announcements') : 
                document.getElementById('accessibility-announcements');
            
            if (element) {
                element.textContent = message;
                this.lastAnnouncement = message;
                
                // Clear after announcement to allow repeat announcements
                await this.delay(1000);
                if (element.textContent === message) {
                    element.textContent = '';
                }
            }
            
            // Delay between announcements
            await this.delay(500);
        }
        
        this.isAnnouncing = false;
    }
    
    delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    toggleHighContrast() {
        this.highContrast = !this.highContrast;
        localStorage.setItem('highContrast', this.highContrast);
        
        if (this.highContrast) {
            document.body.classList.add('high-contrast');
            this.announce('High contrast mode enabled');
        } else {
            document.body.classList.remove('high-contrast');
            this.announce('High contrast mode disabled');
        }
    }
    
    trapFocus(modal, event) {
        const focusableElements = modal.querySelectorAll(
            'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
        );
        
        const firstElement = focusableElements[0];
        const lastElement = focusableElements[focusableElements.length - 1];
        
        if (event.shiftKey && event.target === firstElement) {
            event.preventDefault();
            lastElement.focus();
        } else if (!event.shiftKey && event.target === lastElement) {
            event.preventDefault();
            firstElement.focus();
        }
    }
    
    closeModals() {
        const modals = document.querySelectorAll('.modal, .popup-overlay');
        modals.forEach(modal => {
            const closeButton = modal.querySelector('button[aria-label*="Close"], .close-button, .cancel-btn');
            if (closeButton) {
                closeButton.click();
            }
        });
    }
    
    recenterMap() {
        if (window.recenterMap) {
            window.recenterMap();
        }
    }
    
    showNavigationTips() {
        if (window.showNavigationTips) {
            window.showNavigationTips();
        }
    }
    
    announceProximity(distance, locationName) {
        const alertKey = `${locationName}_${Math.floor(distance / 10) * 10}`;
        
        if (!this.proximityAlerts.has(alertKey)) {
            this.proximityAlerts.add(alertKey);
            
            let message;
            if (distance <= 20) {
                message = `Very close to ${locationName}. ${distance} feet away.`;
            } else if (distance <= 50) {
                message = `Approaching ${locationName}. ${distance} feet away.`;
            } else if (distance <= 100) {
                message = `Near ${locationName}. ${distance} feet away.`;
            }
            
            if (message) {
                this.announce(message, 'assertive');
            }
            
            // Clear alert after 30 seconds
            setTimeout(() => {
                this.proximityAlerts.delete(alertKey);
            }, 30000);
        }
    }
    
    getAccessibilityStats() {
        return {
            highContrast: this.highContrast,
            screenReader: this.screenReader,
            announceQueueLength: this.announceQueue.length,
            proximityAlerts: this.proximityAlerts.size,
            isAnnouncing: this.isAnnouncing
        };
    }
}

// =============================================================================
// GLOBAL STATE MANAGEMENT
// =============================================================================

// Initialize managers
const memoryManager = new MemoryManager();
const performanceMonitor = new PerformanceMonitor();
const serviceWorkerManager = new ServiceWorkerManager();
const kalmanFilter = new EnhancedKalmanFilter();
const zoomManager = new IntelligentZoomManager();
const locationTriggerManager = new LocationTriggerManager();
const accessibilityManager = new AccessibilityManager();

// Global variables
let map, userMarker, markerClusterGroup;
let tracking;
let currentLocationIndex = 0;
let visitedLocations = [];
let gameLocations = [];
let isLocationHuntVisible = false;
let lastPosition = null;
let positionBuffer = [];
let filteredPosition = null;
let followUser = true;
let lastVisitedLocationId = null;
let lastKnownPosition = null;
let isTransitioning = false;
let lastVelocity = { lat: 0, lng: 0 };
let isMapInteracting = false;
let isStationary = false;
let stationaryStartTime = null;
let stationaryCheckTimeout = null;
let lastUpdateTime = null;
let lastUpdateTimestamp = null;
let stationaryBuffer = [];
let stationaryPosition = null;
let stationaryCount = 0;
let lastSmoothedPosition = null;
let lastHiddenTime = 0;
let retryCount = 0;
let inactivityTimer;
let animationFrameId = null;
let loadingMessageMinDisplayTime = 0;
let lastCenteringTime = 0;
let lastZoomChangeTime = 0;
let isNearLocation = false;
let lastMapUpdateTime = 0;
let lastVisitTime = 0;
let lastSignificantMovement = Date.now();
let lastPositionForJitter = null;

// Enhanced tracking state
let enhancedTrackingState = {
    velocity: { lat: 0, lng: 0 },
    acceleration: { lat: 0, lng: 0 },
    lastVelocityUpdate: 0,
    speedMPS: 0,
    heading: null,
    isMoving: false,
    stationaryStartTime: null
};

// Cached DOM elements
let cachedElements = {};

// =============================================================================
// UTILITY FUNCTIONS
// =============================================================================

function cacheElements() {
    cachedElements = {
        distanceBox: document.getElementById('distanceBox'),
        recenterButton: document.getElementById('recenterButton'),
        returnButton: document.getElementById('returnButton'),
        tipsButton: document.getElementById('tipsButton'),
        lochuntContainer: document.querySelector('.lochunt-container'),
        additionalInfoContainer: document.querySelector('.additional-info-container'),
        accessibilityAnnouncements: document.getElementById('accessibility-announcements'),
        proximityAnnouncements: document.getElementById('proximity-announcements')
    };
}

function isValidPosition(pos) {
    return pos && 
           typeof pos.lat === 'number' && 
           typeof pos.lng === 'number' && 
           !isNaN(pos.lat) && 
           !isNaN(pos.lng);
}

function calculateDistance(pos1, pos2) {
    if (!pos1 || !pos2 || 
        typeof pos1.lat !== 'number' || typeof pos1.lng !== 'number' || 
        typeof pos2.lat !== 'number' || typeof pos2.lng !== 'number') {
        return Infinity;
    }
    
    const R = 6371000; // Earth's radius in meters
    const lat1 = pos1.lat * Math.PI / 180;
    const lat2 = pos2.lat * Math.PI / 180;
    const deltaLat = (pos2.lat - pos1.lat) * Math.PI / 180;
    const deltaLng = (pos2.lng - pos1.lng) * Math.PI / 180;

    const a = Math.sin(deltaLat/2) * Math.sin(deltaLat/2) +
            Math.cos(lat1) * Math.cos(lat2) *
            Math.sin(deltaLng/2) * Math.sin(deltaLng/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

    return R * c;
}

function throttle(func, limit) {
    let inThrottle;
    return function() {
        const args = arguments;
        const context = this;
        if (!inThrottle) {
            func.apply(context, args);
            inThrottle = true;
            const timeoutId = memoryManager.registerTimer(
                setTimeout(() => inThrottle = false, limit)
            );
        }
    };
}

function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = memoryManager.registerTimer(setTimeout(later, wait));
    };
}

// =============================================================================
// MAP INITIALIZATION AND CORE FUNCTIONS
// =============================================================================

function initMap() {
    console.log("Initializing map with Leaflet version:", L.version);
    
    // Create map with optimized settings
    map = L.map('map', {
        zoomControl: false,
        attributionControl: false,
        zoomSnap: 0.1,
        zoomDelta: 0.5,
        wheelDebounceTime: 100,
        tapTolerance: 15,
        bounceAtZoomLimits: false,
        preferCanvas: true,
        renderer: L.canvas(),
        touchZoom: true,
        dragging: true,
        tap: true
    }).fitWorld();
    
    // Add tile layer with optimized settings
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        minZoom: 7,
        maxZoom: 18,
        attribution: '',
        updateWhenIdle: true,
        updateWhenZooming: false,
        keepBuffer: 2,
        crossOrigin: true
    }).addTo(map);
    
    // Initialize marker cluster group
    markerClusterGroup = L.markerClusterGroup({
        showCoverageOnHover: false,
        zoomToBoundsOnClick: true,
        spiderfyOnMaxZoom: true,
        animate: true,
        chunkedLoading: true,
        chunkProgress: updateLoadingStatus,
        maxClusterRadius: (zoom) => zoom > 16 ? 40 : 80,
        iconCreateFunction: (cluster) => L.divIcon({
            html: `<div><span>${cluster.getChildCount()}</span></div>`,
            className: 'marker-cluster-custom',
            iconSize: L.point(40, 40)
        })
    });
    map.addLayer(markerClusterGroup);
    
    // Create enhanced user location marker
    userMarker = L.marker([0, 0], {
        icon: L.divIcon({
            className: 'user-marker',
            html: '<div class="user-marker-icon"></div>',
            iconSize: [20, 20],
            iconAnchor: [10, 10]
        }),
        zIndexOffset: 1000
    }).addTo(map);
    
    // Initialize geolocation
    showLoadingMessage();
    if ("geolocation" in navigator) {
        navigator.geolocation.getCurrentPosition(
            initializeUserLocation,
            (error) => {
                navigator.geolocation.getCurrentPosition(
                    initializeUserLocation,
                    handleLocationError,
                    { enableHighAccuracy: true, timeout: 45000, maximumAge: 0 }
                );
            },
            { enableHighAccuracy: true, timeout: 45000, maximumAge: 0 }
        );
    } else {
        showPopup("Geolocation Error", "Geolocation is not supported by your browser");
        map.setView([44.9778, -93.2650], 17);
        hideLoadingMessage();
    }
}

function updateLoadingStatus(processed, total, elapsed) {
    if (processed === total) {
        console.log(`Loaded ${processed} markers in ${elapsed.toFixed(2)}ms`);
        performanceMonitor.recordMetric('markerLoading', elapsed, {
            markerCount: processed
        });
    }
}

function showLoadingMessage() {
    const existingMessage = document.getElementById('loadingMessage');
    if (existingMessage) return;
    
    loadingMessageMinDisplayTime = Date.now() + 8000;
    
    const loadingMessage = document.createElement('div');
    loadingMessage.id = 'loadingMessage';
    loadingMessage.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        background-image: url('https://raw.githubusercontent.com/mreicher/MNThen/refs/heads/main/images/splash_screen.webp');
        background-size: cover;
        background-position: center;
        z-index: 1000;
        font-family: 'Montserrat', 'Segoe UI', 'Roboto', sans-serif;
        transition: opacity 0.5s ease;
    `;
    
    const contentContainer = document.createElement('div');
    contentContainer.style.cssText = `
        display: grid;
        grid-template-rows: auto auto 1fr auto auto;
        background-color: white;
        padding: 35px 30px;
        border-radius: 20px;
        box-shadow: 0 20px 50px rgba(0, 0, 0, 0.35), 0 2px 10px rgba(0, 0, 0, 0.2);
        width: 450px;
        height: 500px;
        text-align: center;
        backdrop-filter: blur(5px);
        border: 1px solid rgba(255, 255, 255, 0.18);
    `;
    
    const logoImage = document.createElement('img');
    logoImage.src = 'https://mnthen.com/images/logo.webp';
    logoImage.alt = 'Minnesota Then Logo';
    logoImage.style.cssText = `
        width: 180px;
        height: auto;
        margin: 0 auto 25px;
        border-radius: 12px;
        object-fit: contain;
        filter: drop-shadow(0 4px 8px rgba(0, 40, 85, 0.2));
    `;
    
    const mainTitle = document.createElement('h1');
    mainTitle.style.cssText = `
        margin: 0 0 8px 0;
        font-size: 22px;
        font-weight: 700;
        color: #002855;
        text-align: center;
        line-height: 1.2;
        letter-spacing: -0.02em;
        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
    `;
    mainTitle.textContent = 'The Museum Without Walls';
    
    const welcomeMessage = document.createElement('h2');
    welcomeMessage.style.cssText = `
        margin: 0 0 40px 0;
        font-size: 18px;
        font-weight: 500;
        color: #0066cc;
        text-align: center;
        line-height: 1.3;
        letter-spacing: 0.02em;
        opacity: 0.9;
    `;
    welcomeMessage.textContent = 'Where Every Step Tells A Story';
    
    const statusTextContainer = document.createElement('div');
    statusTextContainer.style.cssText = `
        min-height: 60px;
        display: flex;
        align-items: center;
        justify-content: center;
        margin-bottom: 20px;
    `;
    
    const statusText = document.createElement('p');
    statusText.id = 'loadingStatusText';
    statusText.style.cssText = `
        margin: 0;
        font-size: 18px;
        font-weight: 500;
        text-align: center;
        color: #0077dd;
        line-height: 1.4;
        animation: pulse 2s infinite;
        letter-spacing: 0.01em;
    `;
    statusText.textContent = 'Location found, proceeding to stabilization...';
    statusTextContainer.appendChild(statusText);
    
    const progressContainer = document.createElement('div');
    progressContainer.style.cssText = `
        width: 100%;
        height: 10px;
        background-color: rgba(0, 51, 102, 0.08);
        border-radius: 10px;
        overflow: hidden;
        margin-bottom: 12px;
        box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.12);
    `;
    
    const progressBar = document.createElement('div');
    progressBar.id = 'loadingProgressBar';
    progressBar.style.cssText = `
        height: 100%;
        width: 0%;
        background: linear-gradient(90deg, #0066cc, #0099ff, #00aaff, #0099ff, #0066cc);
        background-size: 200% auto;
        border-radius: 10px;
        transition: width 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
        box-shadow: 0 0 10px rgba(0, 120, 255, 0.6);
        animation: gradientShift 3s ease infinite;
    `;
    
    progressContainer.appendChild(progressBar);
    
    const noteContainer = document.createElement('div');
    noteContainer.style.cssText = `
        min-height: 50px;
        display: flex;
        align-items: center;
        justify-content: center;
    `;
    
    const loadingNote = document.createElement('p');
    loadingNote.style.cssText = `
        margin: 0;
        font-size: 16px;
        color: #555;
        font-weight: 500;
        opacity: 0.8;
    `;
    loadingNote.textContent = 'Preparing your experience.';
    noteContainer.appendChild(loadingNote);
    
    contentContainer.appendChild(logoImage);
    contentContainer.appendChild(mainTitle);
    contentContainer.appendChild(welcomeMessage);
    contentContainer.appendChild(statusTextContainer);
    contentContainer.appendChild(progressContainer);
    contentContainer.appendChild(noteContainer);
    
    loadingMessage.appendChild(contentContainer);
    document.body.appendChild(loadingMessage);
    
    const totalDuration = 10000;
    const updateInterval = 100;
    const steps = totalDuration / updateInterval;
    let progress = 0;
    
    const animations = [
        "Initializing map data...",
        "Processing location coordinates...",
        "Preparing exhibit data...",
        "Calibrating view perspective...",
        "Loading nearby points of interest...",
        "Optimizing content for your location...",
        "Finalizing your experience..."
    ];
    
    const progressInterval = setInterval(() => {
        progress += (100 / steps);
        
        if (progressBar) {
            progressBar.style.width = `${Math.min(progress, 100)}%`;
        }
        
        if (statusText) {
            const animationIndex = Math.min(
                Math.floor(progress / (100 / animations.length)),
                animations.length - 1
            );
            statusText.textContent = animations[animationIndex];
        }
        
        if (progress >= 100) {
            clearInterval(progressInterval);
            tryHideLoadingMessage();
        }
    }, updateInterval);
    
    loadingMessage.dataset.progressInterval = progressInterval;
}

function tryHideLoadingMessage() {
    if (Date.now() >= loadingMessageMinDisplayTime) {
        fadeOutLoadingMessage();
    } else {
        const timeRemaining = loadingMessageMinDisplayTime - Date.now();
        const timeoutId = memoryManager.registerTimer(
            setTimeout(fadeOutLoadingMessage, timeRemaining + 100)
        );
    }
}

function fadeOutLoadingMessage() {
    const loadingMessage = document.getElementById('loadingMessage');
    if (!loadingMessage) return;
    
    if (loadingMessage.dataset.progressInterval) {
        clearInterval(parseInt(loadingMessage.dataset.progressInterval));
    }
    
    const progressBar = document.getElementById('loadingProgressBar');
    if (progressBar) {
        progressBar.style.width = '100%';
    }
    
    loadingMessage.style.opacity = '0';
    const timeoutId = memoryManager.registerTimer(
        setTimeout(() => {
            if (loadingMessage && loadingMessage.parentNode) {
                loadingMessage.parentNode.removeChild(loadingMessage);
            }
        }, 500)
    );
}

function hideLoadingMessage() {
    tryHideLoadingMessage();
}

function initializeUserLocation(position) {
    console.log("Initial position data:", JSON.stringify(position));

    if (!position || !position.coords) {
        console.error("Invalid initial position object");
        handleLocationError(new Error("Invalid initial position"));
        return;
    }

    const { latitude: userLat, longitude: userLng, accuracy } = position.coords;

    if (isNaN(userLat) || isNaN(userLng)) {
        console.error("Invalid initial coordinates:", { userLat, userLng });
        handleLocationError(new Error("Invalid initial coordinates"));
        return;
    }

    console.log("Valid initial position:", { userLat, userLng, accuracy });

    try {
        userMarker.setLatLng([userLat, userLng]);
        map.setView([userLat, userLng], 19);
        
        kalmanFilter.reset({
            lat: userLat,
            lng: userLng,
            accuracy: accuracy || 20,
            timestamp: Date.now()
        });
        
        accessibilityManager.announce('Location acquired successfully. Map is ready for navigation.');
        
        hideLoadingMessage();
        startPositionUpdates();
        startHunt();
        
        const distanceBox = cachedElements.distanceBox || document.getElementById('distanceBox');
        distanceBox.classList.add('pulse');
        const timeoutId = memoryManager.registerTimer(
            setTimeout(() => distanceBox.classList.remove('pulse'), 3000)
        );
    } catch (error) {
        console.error("Error setting initial user location:", error);
        handleLocationError(error);
    }
}

function startPositionUpdates() {
    const watchId = navigator.geolocation.watchPosition(
        handlePositionUpdate,
        handleLocationError,
        {
            enableHighAccuracy: true,
            maximumAge: 1000,
            timeout: 10000
        }
    );
    
    window.positionWatchId = watchId;
    
    window.addEventListener('online', () => {
        if (window.positionWatchId) {
            navigator.geolocation.clearWatch(window.positionWatchId);
            window.positionWatchId = navigator.geolocation.watchPosition(
                handlePositionUpdate,
                handleLocationError,
                {
                    enableHighAccuracy: true,
                    maximumAge: 1000,
                    timeout: 10000
                }
            );
        }
    });
    
    return watchId;
}

function handlePositionUpdate(position) {
    if (!position || !position.coords || 
        isNaN(position.coords.latitude) || 
        isNaN(position.coords.longitude)) {
        console.warn("Invalid position data received");
        return;
    }
    
    const positionTimestamp = position.timestamp || new Date().getTime();
    const currentTime = new Date().getTime();
    const maxAgeMs = 30000;
    
    if (currentTime - positionTimestamp > maxAgeMs) {
        console.warn("Position data too old, ignoring");
        return;
    }
    
    const accuracy = position.coords.accuracy || 0;
    window.lastPositionAccuracy = accuracy;
    
    window.lastValidPosition = {
        lat: position.coords.latitude,
        lng: position.coords.longitude,
        timestamp: positionTimestamp,
        accuracy: accuracy
    };
    
    // Record performance metrics
    performanceMonitor.recordLocationUpdate(accuracy, position.coords.speed || 0, positionTimestamp);
    
    updateUserLocation(position);
}

function handleVisibilityChange() {
    if (document.hidden) {
        lastHiddenTime = Date.now();
        lastKnownPosition = userMarker ? userMarker.getLatLng() : null;
    } else {
        const hiddenDuration = Date.now() - lastHiddenTime;
        if (hiddenDuration > CONFIG.BACKGROUND_THRESHOLD) {
            updateLocationAfterBackground();
        } else {
            map.invalidateSize();
        }
    }
    resetInactivityTimer();
}

function updateLocationAfterBackground() {
    if (!("geolocation" in navigator)) {
        console.warn("Geolocation is not available");
        return;
    }
    
    const quickOptions = {
        enableHighAccuracy: false,
        timeout: 5000,
        maximumAge: 60000,
    };
    
    const accurateOptions = {
        enableHighAccuracy: true,
        timeout: 15000,
        maximumAge: 30000,
    };
    
    const fallbackOptions = {
        enableHighAccuracy: false,
        timeout: 25000,
        maximumAge: 120000,
    };

    const handleSuccess = (position) => {
        console.log("Background update raw position:", JSON.stringify(position));
        
        if (!position?.coords) {
            console.warn("Invalid position object in background update");
            return;
        }
        const { latitude, longitude, accuracy } = position.coords;
        if (isNaN(latitude) || isNaN(longitude)) {
            console.warn("Invalid coordinates in background update:", { latitude, longitude });
            return;
        }
        console.log("Valid background position update:", { lat: latitude, lng: longitude });
        
        try {
            updateUserLocation(position, true);
            
            lastPosition = null;
            positionBuffer = [];
            lastVelocity = { lat: 0, lng: 0 };
            isStationary = false;
            stationaryStartTime = null;
            stationaryCount = 0;
            
            kalmanFilter.reset({
                lat: latitude,
                lng: longitude,
                accuracy: accuracy,
                heading: position.coords.heading || 0,
                timestamp: Date.now(),
            });
            
            updateDistanceBox();
            followUser = true;
            map.invalidateSize();
        } catch (error) {
            console.error("Error in updateUserLocation during background update:", error);
        }
    };
    
    const handleError = (error, stage) => {
        console.error(`Error getting location during ${stage} attempt:`, error);
        
        switch (error.code) {
            case 1:
                console.warn("User denied geolocation access");
                break;
                
            case 2:
                if (stage === "quick") {
                    console.log("Quick position unavailable, trying accurate position...");
                    navigator.geolocation.getCurrentPosition(
                        handleSuccess,
                        (err) => handleError(err, "accurate"),
                        accurateOptions
                    );
                } else if (stage === "accurate") {
                    console.log("Accurate position unavailable, trying fallback...");
                    navigator.geolocation.getCurrentPosition(
                        handleSuccess,
                        (err) => handleError(err, "fallback"),
                        fallbackOptions
                    );
                } else {
                    console.warn("All position attempts failed - location unavailable");
                }
                break;
                
            case 3:
                if (stage === "quick") {
                    console.log("Quick position timed out, trying accurate position...");
                    navigator.geolocation.getCurrentPosition(
                        handleSuccess,
                        (err) => handleError(err, "accurate"),
                        accurateOptions
                    );
                } else if (stage === "accurate") {
                    console.log("Accurate position timed out, trying fallback...");
                    navigator.geolocation.getCurrentPosition(
                        handleSuccess,
                        (err) => handleError(err, "fallback"),
                        fallbackOptions
                    );
                } else {
                    console.warn("All position attempts timed out");
                }
                break;
                
            default:
                if (stage !== "fallback") {
                    console.log("Unknown error, trying fallback options...");
                    navigator.geolocation.getCurrentPosition(
                        handleSuccess,
                        (err) => handleError(err, "fallback"),
                        fallbackOptions
                    );
                } else {
                    console.warn("All position attempts failed with unknown error");
                }
        }
    };

    navigator.geolocation.getCurrentPosition(
        handleSuccess,
        (error) => handleError(error, "quick"),
        quickOptions
    );
}

// =============================================================================
// ENHANCED POSITION PROCESSING
// =============================================================================

function updatePositionBuffer(position) {
    positionBuffer.push({
        lat: position.lat,
        lng: position.lng,
        accuracy: position.accuracy,
        timestamp: position.timestamp,
        heading: position.heading,
        speedMPS: position.speedMPS
    });

    while (positionBuffer.length > CONFIG.MAX_BUFFER_SIZE) {
        positionBuffer.shift();
    }
}

function calculateWeightedPosition(positions, smoothingFactor = 0.8) {
    if (!Array.isArray(positions) || positions.length === 0) {
        return null;
    }

    const validPositions = positions.filter(pos => 
        pos && typeof pos.lat === 'number' && typeof pos.lng === 'number' && 
        !isNaN(pos.lat) && !isNaN(pos.lng)
    );

    if (validPositions.length === 0) {
        return null;
    }

    let sumLat = 0, sumLng = 0, totalWeight = 0;

    for (let i = 0; i < validPositions.length; i++) {
        const position = validPositions[i];
        const weight = Math.pow(smoothingFactor, validPositions.length - i - 1);
        sumLat += position.lat * weight;
        sumLng += position.lng * weight;
        totalWeight += weight;
    }

    const result = {
        lat: sumLat / totalWeight,
        lng: sumLng / totalWeight,
        accuracy: Math.min(...validPositions.map(p => p.accuracy || 20)),
        timestamp: validPositions[validPositions.length - 1].timestamp,
        heading: validPositions[validPositions.length - 1].heading,
        speedMPS: validPositions[validPositions.length - 1].speedMPS
    };

    return result;
}

function updateUserLocation(position, forceUpdate = false) {
    if (!position?.coords?.latitude || !position?.coords?.longitude) {
        console.warn("Invalid position data received");
        return;
    }

    if (animationFrameId !== null) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
    }

    const currentTime = Date.now();
    const timeDelta = lastUpdateTime ? (currentTime - lastUpdateTime) / 1000 : 0;

    const newPosition = {
        lat: position.coords.latitude,
        lng: position.coords.longitude,
        accuracy: position.coords.accuracy || 20,
        heading: position.coords.heading ?? null,
        timestamp: currentTime,
        speedMPS: position.coords.speed || 0
    };

    // First position initialization
    if (!lastPosition) {
        lastPosition = newPosition;
        userMarker.setLatLng([newPosition.lat, newPosition.lng]);
        kalmanFilter.reset(newPosition);
        lastUpdateTime = currentTime;
        stationaryStartTime = currentTime;
        positionBuffer = [newPosition];
        
        const zoomResult = zoomManager.calculateOptimalZoom(newPosition.speedMPS, Infinity, newPosition);
        if (zoomResult.zoom) {
            map.setZoom(zoomResult.zoom, { animate: false });
        }
        map.setView([newPosition.lat, newPosition.lng], map.getZoom(), { animate: false });
        updateDistanceBox();
        return;
    }

    const distance = calculateDistance(lastPosition, newPosition);

    // Extended distance handling
    if (distance > CONFIG.EXTENDED_DISTANCE_THRESHOLD || forceUpdate) {
        if (stationaryCheckTimeout) {
            clearTimeout(stationaryCheckTimeout);
            stationaryCheckTimeout = null;
        }
        isStationary = false;
        stationaryStartTime = null;

        const transitionPosition = {
            lat: newPosition.lat,
            lng: newPosition.lng,
            accuracy: newPosition.accuracy,
            heading: newPosition.heading,
            timestamp: currentTime,
            speedMPS: newPosition.speedMPS
        };

        userMarker.setLatLng([transitionPosition.lat, transitionPosition.lng], { animate: false });
        lastPosition = transitionPosition;
        positionBuffer = [transitionPosition];
        kalmanFilter.reset(transitionPosition);
        lastVelocity = { lat: 0, lng: 0 };

        const zoomResult = zoomManager.calculateOptimalZoom(newPosition.speedMPS, Infinity, newPosition);
        if (zoomResult.zoom) {
            map.setZoom(zoomResult.zoom, { animate: false });
        }
        map.setView([transitionPosition.lat, transitionPosition.lng], map.getZoom(), { 
            animate: false, 
            duration: 0,
            noMoveStart: true
        });
        
        lastUpdateTime = currentTime;
        lastUpdateTimestamp = currentTime;

        if (isSignificantMovement(transitionPosition)) {
            resetInactivityTimer(false);
        }
            
        updateDistanceBox();
        
        if (map._container) {
            map._onResize();
        }
        return;
    }

    // Stationary detection
    if (distance < CONFIG.MICRO_MOVEMENT_THRESHOLD && !forceUpdate) {
        if (!isStationary) {
            if (!stationaryStartTime) {
                stationaryStartTime = currentTime;
            } else if (currentTime - stationaryStartTime >= CONFIG.STATIONARY_TIME_THRESHOLD) {
                isStationary = true;
                
                const stationaryPosition = kalmanFilter.update({
                    lat: newPosition.lat,
                    lng: newPosition.lng,
                    accuracy: Math.min(lastPosition.accuracy, newPosition.accuracy) * CONFIG.STATIONARY_ACCURACY_MULTIPLIER,
                    heading: newPosition.heading,
                    timestamp: newPosition.timestamp,
                    speedMPS: 0
                });
                
                userMarker.setLatLng([stationaryPosition.lat, stationaryPosition.lng], { animate: false });
                lastPosition = stationaryPosition;
                positionBuffer = [stationaryPosition];
                
                if (stationaryCheckTimeout) clearTimeout(stationaryCheckTimeout);
                stationaryCheckTimeout = memoryManager.registerTimer(
                    setTimeout(() => checkStationaryState(newPosition), CONFIG.STATIONARY_CHECK_INTERVAL)
                );
                
                updateDistanceBox();
                return;
            }
        }
        
        if (isStationary) {
            if (newPosition.accuracy < lastPosition.accuracy * 0.9) {
                const refinedPosition = kalmanFilter.update({
                    lat: newPosition.lat,
                    lng: newPosition.lng,
                    accuracy: newPosition.accuracy,
                    heading: newPosition.heading,
                    timestamp: newPosition.timestamp,
                    speedMPS: 0
                });
                
                if (calculateDistance(lastPosition, refinedPosition) < CONFIG.MICRO_MOVEMENT_THRESHOLD / 2) {
                    userMarker.setLatLng([refinedPosition.lat, refinedPosition.lng], { animate: false });
                    lastPosition = refinedPosition;
                    updateDistanceBox();
                }
            }
            return;
        }
    } else {
        isStationary = false;
        stationaryStartTime = null;
        if (stationaryCheckTimeout) {
            clearTimeout(stationaryCheckTimeout);
            stationaryCheckTimeout = null;
        }
    }

    // Skip updates with poor accuracy or unrealistic movement
    if (!forceUpdate && (
        newPosition.accuracy > CONFIG.MAX_ACCEPTABLE_ACCURACY ||
        distance < CONFIG.MIN_DISTANCE_THRESHOLD ||
        (timeDelta > 0 && distance / timeDelta > CONFIG.MAX_SPEED)
    )) {
        return;
    }

    try {
        const filteredPosition = kalmanFilter.update({
            lat: newPosition.lat,
            lng: newPosition.lng,
            accuracy: newPosition.accuracy,
            heading: newPosition.heading,
            timestamp: newPosition.timestamp,
            speedMPS: newPosition.speedMPS
        });

        updatePositionBuffer(filteredPosition);
        
        const finalPosition = calculateFinalPosition();
        if (!finalPosition) throw new Error("Final position calculation failed");

        const speedMPH = newPosition.speedMPS * 2.23694;
        let smoothingFactor;
        if (speedMPH > 5) {
            smoothingFactor = Math.min(0.9, Math.max(0.6, 0.3 + (newPosition.speedMPS / 10 * 0.6)));
        } else {
            smoothingFactor = Math.min(0.8, Math.max(0.2, 0.3 + (newPosition.speedMPS / 10 * 0.5)));
        }
        
        const smoothedPosition = {
            lat: lastPosition.lat * (1 - smoothingFactor) + finalPosition.lat * smoothingFactor,
            lng: lastPosition.lng * (1 - smoothingFactor) + finalPosition.lng * smoothingFactor,
            accuracy: finalPosition.accuracy,
            heading: finalPosition.heading,
            timestamp: currentTime,
            speedMPS: finalPosition.speedMPS
        };

        const animDuration = Math.min(0.3, Math.max(0.1, 0.2 / (1 + newPosition.speedMPS / 10)));
        
        userMarker.setLatLng([smoothedPosition.lat, smoothedPosition.lng], {
            animate: true,
            duration: animDuration
        });
        
        if (currentTime - lastMapUpdateTime > 500 || distance > 20) {
            checkProximityForZoom();
            
            const lookAheadFactor = Math.min(0.5, newPosition.speedMPS / 10 * 0.3);
            const lookAheadPosition = {
                lat: smoothedPosition.lat + (finalPosition.lat - lastPosition.lat) * lookAheadFactor,
                lng: smoothedPosition.lng + (finalPosition.lng - lastPosition.lng) * lookAheadFactor
            };
            
            animationFrameId = memoryManager.registerAnimationFrame(
                requestAnimationFrame(() => {
                    if (followUser && !isMapInteracting) {
                        map.panTo([lookAheadPosition.lat, lookAheadPosition.lng], {
                            animate: true,
                            duration: 0.5,
                            easeLinearity: 0.5
                        });
                        
                        const closestDistance = findClosestLocationDistance(smoothedPosition);
                        const zoomResult = zoomManager.calculateOptimalZoom(newPosition.speedMPS, closestDistance, smoothedPosition);
                        if (zoomResult.changed && Math.abs(map.getZoom() - zoomResult.zoom) >= 1) {
                            map.setZoom(zoomResult.zoom, { animate: true, duration: 1 });
                        }
                    }
                    
                    animationFrameId = null;
                })
            );
            
            lastMapUpdateTime = currentTime;
        }

        lastPosition = smoothedPosition;
        lastUpdateTime = currentTime;
        lastUpdateTimestamp = currentTime;
        updateDistanceBox();

    } catch (error) {
        console.error("Location update error:", error);
        if (animationFrameId !== null) {
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
        }
        
        const fallbackPosition = kalmanFilter.update(newPosition);
        userMarker.setLatLng([fallbackPosition.lat, fallbackPosition.lng], { animate: true, duration: 0.3 });
        lastPosition = fallbackPosition;
        positionBuffer = [fallbackPosition];
        updateDistanceBox();
    }
}

function findClosestLocationDistance(position) {
    if (!gameLocations || gameLocations.length === 0) return Infinity;
    
    let closestDistance = Infinity;
    for (const loc of gameLocations) {
        if (loc && loc.lat && loc.lng) {
            const dist = calculateDistance(position, loc);
            if (dist < closestDistance) {
                closestDistance = dist;
            }
        }
    }
    
    return closestDistance * 3.28084;
}

function calculateFinalPosition() {
    if (positionBuffer.length === 0) {
        return null;
    }
    
    if (positionBuffer.length === 1) {
        return positionBuffer[0];
    }
    
    return calculateWeightedPosition(positionBuffer);
}

function checkStationaryState(newPosition) {
    if (!lastPosition) return;
    
    const distance = calculateDistance(lastPosition, newPosition);
    
    if (distance >= CONFIG.MICRO_MOVEMENT_THRESHOLD) {
        isStationary = false;
        stationaryStartTime = null;
        console.debug("Movement detected, resuming normal updates");
    }
    
    if (stationaryCheckTimeout) {
        clearTimeout(stationaryCheckTimeout);
        stationaryCheckTimeout = null;
    }
    
    if (isStationary) {
        stationaryCheckTimeout = memoryManager.registerTimer(
            setTimeout(() => checkStationaryState(newPosition), CONFIG.STATIONARY_CHECK_INTERVAL)
        );
    }
}

// =============================================================================
// PROXIMITY AND ZOOM MANAGEMENT
// =============================================================================

function checkProximityForZoom() {
    const now = Date.now();
    if (!window.lastProximityCheck) window.lastProximityCheck = 0;
    if (now - window.lastProximityCheck < 200) return;
    window.lastProximityCheck = now;
    
    if (!userMarker || !gameLocations?.length) return;
    
    const userPos = userMarker.getLatLng();
    if (!userPos || isNaN(userPos.lat)) return;
    
    let closestDistance = Infinity;
    for (const loc of gameLocations) {
        if (!loc?.lat) continue;
        const dist = calculateDistance(userPos, loc);
        if (dist < closestDistance) closestDistance = dist;
    }
    
    const distanceFeet = closestDistance * 3.28084;
    
    const ZOOM_IN_THRESHOLD = CONFIG.PROXIMITY_THRESHOLD;
    const ZOOM_OUT_THRESHOLD = CONFIG.PROXIMITY_THRESHOLD * 1.3;
    
    const currentTime = Date.now();
    
    if (typeof window.zoomedInState === 'undefined') {
        window.zoomedInState = false;
    }
    
    const previousState = window.zoomedInState;
    
    if (!window.zoomedInState && distanceFeet <= ZOOM_IN_THRESHOLD) {
        if (currentTime - lastZoomChangeTime >= CONFIG.ZOOM_COOLDOWN) {
            window.zoomedInState = true;
            isNearLocation = true;
            lastZoomChangeTime = currentTime;
            
            window.blockSpeedZoom = true;
            const timeoutId = memoryManager.registerTimer(
                setTimeout(() => window.blockSpeedZoom = false, 5000)
            );
            
            if (!isMapInteracting) {
                map.flyTo(userPos, CONFIG.CLOSE_ZOOM, {
                    duration: 1.2,
                    easeLinearity: 0.25
                });
            }
        }
    } 
    else if (window.zoomedInState && distanceFeet >= ZOOM_OUT_THRESHOLD) {
        if (currentTime - lastZoomChangeTime >= CONFIG.ZOOM_COOLDOWN) {
            window.zoomedInState = false;
            isNearLocation = false;
            lastZoomChangeTime = currentTime;
            
            window.blockSpeedZoom = true;
            const timeoutId = memoryManager.registerTimer(
                setTimeout(() => window.blockSpeedZoom = false, 5000)
            );
            
            if (!isMapInteracting) {
                map.flyTo(userPos, CONFIG.BASE_ZOOM, {
                    duration: 1.2,
                    easeLinearity: 0.25
                });
            }
        }
    }
    
    if (previousState !== window.zoomedInState) {
        window.lastProximityZoomTime = currentTime;
    }
}

function updateDistanceBox() {
    const distanceBox = cachedElements.distanceBox || document.getElementById('distanceBox');
    
    if (!userMarker || !gameLocations || gameLocations.length === 0) {
        distanceBox.innerText = 'Initializing...';
        return;
    }

    const userLatLng = userMarker.getLatLng();
    let userLat = userLatLng.lat;
    let userLng = userLatLng.lng;

    if (!isFinite(userLat) || !isFinite(userLng)) {
        console.warn('Invalid user coordinates:', userLat, userLng);
        distanceBox.innerText = 'Initializing...';
        return;
    }

    if (userLat === 0 && userLng === 0) {
        const center = map.getCenter();
        userLat = center.lat;
        userLng = center.lng;
    }

    let closestDistance = Infinity;
    let closestLocation = null;
    const userPos = { lat: userLat, lng: userLng };

    for (const location of gameLocations) {
        if (!location || typeof location.lat !== 'number' || typeof location.lng !== 'number') {
            console.warn('Invalid location data:', location);
            continue;
        }

        const locationPos = { lat: location.lat, lng: location.lng };
        const distance = calculateDistance(userPos, locationPos);

        if (isFinite(distance) && distance < closestDistance) {
            closestDistance = distance;
            closestLocation = location;
        }
    }

    if (!isFinite(closestDistance) || closestDistance === Infinity) {
        console.warn('Invalid distance calculation:', closestDistance);
        distanceBox.innerText = 'Initializing...';
        return;
    }

    const distanceFeet = Math.round(closestDistance * 3.28084);
    const distanceText = distanceFeet < 5280 
        ? `${distanceFeet.toLocaleString()} feet` 
        : `${(distanceFeet / 5280).toFixed(2)} miles`;
    
    distanceBox.innerText = `Closest Stop: ${distanceText}`;

    // Apply border styling based on proximity and marker color
    if (closestLocation && closestLocation.markerColor) {
        let borderStyle = '';
        if (distanceFeet <= 100) {
            borderStyle = `3px solid ${closestLocation.markerColor}`;
        } else if (distanceFeet <= 500) {
            borderStyle = `2px solid ${closestLocation.markerColor}`;
        } else {
            borderStyle = `1px solid ${closestLocation.markerColor}`;
        }
        distanceBox.style.border = borderStyle;
    } else {
        distanceBox.style.border = '1px solid var(--dark-blue)';
    }

    // Haptic feedback at 20 feet
    if (distanceFeet <= 20 && navigator.vibrate && closestLocation) {
        const locationId = closestLocation.id;
        const now = Date.now();
        const lastVibration = locationTriggerManager.lastVibrations?.get(locationId) || 0;
        
        if ((now - lastVibration) > 5000) {
            navigator.vibrate(200);
            if (!locationTriggerManager.lastVibrations) {
                locationTriggerManager.lastVibrations = new Map();
            }
            locationTriggerManager.lastVibrations.set(locationId, now);
        }
    }

    // Accessibility announcements
    if (closestLocation && distanceFeet <= 100) {
        accessibilityManager.announceProximity(distanceFeet, closestLocation.name);
    }

    // Check for location triggering
    if (distanceFeet <= CONFIG.DISTANCE_THRESHOLD && !isLocationHuntVisible && closestLocation) {
        const userBearing = enhancedTrackingState.heading;
        
        if (locationTriggerManager.checkLocationTrigger(userPos, userBearing, closestLocation)) {
            showLocationHunt(closestLocation);
        }
    }
}

// =============================================================================
// ERROR HANDLING AND RECOVERY
// =============================================================================

function getGeolocationOptions(retryNumber) {
    return {
        enableHighAccuracy: retryNumber < 2,
        timeout: 10000 + (retryNumber * 5000),
        maximumAge: retryNumber * 5000
    };
}

function handleLocationError(error) {
    console.warn("Error getting user location:", error);
    
    if (retryCount < CONFIG.MAX_RETRIES) {
        retryCount++;
        console.log(`Retrying to get location (Attempt ${retryCount} of ${CONFIG.MAX_RETRIES})`);
        
        const currentRetryDelay = CONFIG.RETRY_DELAY * retryCount;
        
        const timeoutId = memoryManager.registerTimer(
            setTimeout(() => {
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        console.log("Location retrieved successfully after retry");
                        hideLoadingMessage();
                        updateUserLocation(position, true);
                        retryCount = 0;
                    }, 
                    handleLocationError, 
                    getGeolocationOptions(retryCount) 
                );
            }, currentRetryDelay)
        );
        return;
    }
    
    retryCount = 0;
    hideLoadingMessage();
    
    let errorMessage = "An error occurred while getting your location.";
    if (error && error.code) {
        switch(error.code) {
            case 1:
                errorMessage = "Please allow access to your location to use this feature.";
                break;
            case 2:
                errorMessage = "Your location is currently unavailable. Please try again later.";
                break;
            case 3:
                errorMessage = "Getting your location took too long. Please try again.";
                break;
        }
    }
    
    showPopup("Location Error", errorMessage);
    
    if (typeof onLocationFailure === 'function') {
        onLocationFailure(error);
    }
}

// =============================================================================
// UI AND INTERACTION FUNCTIONS
// =============================================================================

function showPopup(title, message, type = "info", callback = null) {
    console.log("showPopup called with:", title, message);
    
    const existingPopups = document.querySelectorAll(".popup-overlay");
    existingPopups.forEach(popup => {
        document.body.removeChild(popup);
    });

    const overlay = document.createElement("div");
    overlay.className = "popup-overlay";
    overlay.style.cssText = `
        position: fixed;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        z-index: 9999;
        display: flex;
        justify-content: center;
        align-items: center;
    `;
    
    const popupContainer = document.createElement("div");
    popupContainer.className = "popup-container";
    popupContainer.style.cssText = `
        background-color: white;
        border-radius: 8px;
        padding: 20px;
        width: 300px;
        max-width: 90%;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        text-align: center;
    `;
    
    const titleElement = document.createElement("h3");
    titleElement.textContent = title;
    titleElement.style.cssText = `
        margin: 0 0 15px 0;
        color: #333;
    `;
    
    const messageElement = document.createElement("p");
    messageElement.textContent = message;
    messageElement.style.cssText = `
        margin: 0 0 20px 0;
        color: #555;
    `;
    
    const button = document.createElement("button");
    button.textContent = "OK";
    button.style.cssText = `
        padding: 8px 20px;
        background-color: #2c5282;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
    `;
    
    button.addEventListener("click", function() {
        document.body.removeChild(overlay);
        if (callback && typeof callback === "function") {
            callback();
        }
    });
    
    overlay.addEventListener("click", function(e) {
        if (e.target === overlay) {
            document.body.removeChild(overlay);
        }
    });
    
    popupContainer.appendChild(titleElement);
    popupContainer.appendChild(messageElement);
    popupContainer.appendChild(button);
    overlay.appendChild(popupContainer);
    
    document.body.appendChild(overlay);
    
    button.focus();
}

function recenterMap() {
    const recenterButton = cachedElements.recenterButton || document.getElementById('recenterButton');
    recenterButton.style.backgroundColor = 'var(--primary-color)';
    recenterButton.style.color = 'white';
    
    if (userMarker && userMarker.getLatLng()) {
        map.closePopup();
        
        const currentZoom = map.getZoom();
        
        map.panTo(userMarker.getLatLng(), {
            animate: true,
            duration: 0.5,
            easeLinearity: 0.25,
            noZoom: true
        });
        
        followUser = true;
        
        accessibilityManager.announce('Map recentered on your location');
    }
    
    const timeoutId = memoryManager.registerTimer(
        setTimeout(() => {
            recenterButton.style.backgroundColor = 'white';
            recenterButton.style.color = 'var(--primary-color)';
        }, 500)
    );
}

// =============================================================================
// LOCATION HUNT SYSTEM
// =============================================================================

const cooldownPeriod = 105 * 1000;
const minimumGapTime = 15 * 1000;

const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
const getDebounceTime = () => isTouchDevice ? 100 : 50;

let lastFunctionCall = 0;

const SESSION_KEY = 'locationHuntSession';
let currentSessionId = Date.now() + '_' + Math.random().toString(36).substr(2, 9);

function initializeSession() {
    try {
        const storedSession = localStorage.getItem(SESSION_KEY);
        
        if (!storedSession || storedSession !== currentSessionId) {
            localStorage.removeItem('locationCooldowns');
            localStorage.setItem(SESSION_KEY, currentSessionId);
            lastFunctionCall = 0;
            console.log(`New session detected (${isTouchDevice ? 'touch' : 'desktop'} device) - cleared all location cooldowns`);
        } else {
            console.log('Continuing existing session');
        }
    } catch (e) {
        console.warn('Failed to initialize session:', e);
    }
}

function showLocationHunt(location) {
    const now = Date.now();
    
    initializeSession();
    
    const debounceTime = getDebounceTime();
    if (now - lastFunctionCall < debounceTime) {
        console.log(`Function called too rapidly (${now - lastFunctionCall}ms ago). Debouncing on ${isTouchDevice ? 'touch' : 'desktop'} device.`);
        return;
    }
    lastFunctionCall = now;
    
    let locationCooldowns = {};
    try {
        const stored = localStorage.getItem('locationCooldowns');
        if (stored) {
            locationCooldowns = JSON.parse(stored);
        }
    } catch (e) {
        console.warn('Failed to load cooldowns from localStorage:', e);
    }
    
    const locationCooldownKey = `location_${location.id}`;
    
    Object.keys(locationCooldowns).forEach(key => {
        const timeElapsed = now - locationCooldowns[key];
        if (timeElapsed > cooldownPeriod || timeElapsed > 300000) {
            console.log(`Removing expired/stale cooldown for ${key}, elapsed: ${timeElapsed/1000} seconds`);
            delete locationCooldowns[key];
        }
    });
    
    if (locationCooldowns[locationCooldownKey]) {
        const timeElapsed = now - locationCooldowns[locationCooldownKey];
        
        if (timeElapsed < 0 || timeElapsed > 300000) {
            console.log(`Removing suspicious cooldown for location ${location.id}, elapsed: ${timeElapsed/1000}s`);
            delete locationCooldowns[locationCooldownKey];
        } else {
            const timeRemaining = cooldownPeriod - timeElapsed;
            console.log(`Location ${location.id} cooldown check: ${timeElapsed/1000}s elapsed, ${timeRemaining/1000}s remaining`);
            
            if (timeElapsed < minimumGapTime) {
                console.log(`Location ${location.id} triggered too recently (${timeElapsed/1000}s ago). Preventing immediate re-trigger.`);
                return;
            }
            
            if (timeElapsed < cooldownPeriod) {
                console.log(`Location ${location.id} is on cooldown. Skipping.`);
                return;
            }
        }
    }
    
    locationCooldowns[locationCooldownKey] = now;
    console.log(`Setting cooldown for location ${location.id} at timestamp: ${now}`);
    
    try {
        localStorage.setItem('locationCooldowns', JSON.stringify(locationCooldowns));
        console.log('Successfully saved cooldowns to localStorage');
    } catch (e) {
        console.warn('Failed to save cooldowns to localStorage:', e);
    }
    
    lastVisitedLocationId = location.id;
    isLocationHuntVisible = true;
    const lochuntContainer = cachedElements.lochuntContainer || document.querySelector('.lochunt-container');
    lochuntContainer.innerHTML = '';
    lochuntContainer.style.display = 'flex';
    lochuntContainer.classList.add('fade-in');
    
    accessibilityManager.announce(`Opened location: ${location.name}`);
    
    const scrollableContent = document.createElement('div');
    scrollableContent.style.cssText = `
        flex: 1;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
        scroll-behavior: smooth;
        will-change: scroll-position;
    `;
    
    const locationImage = document.createElement('img');
    locationImage.src = location.image;
    locationImage.alt = location.name;
    locationImage.style.cssText = `
        width: 100%;
        height: 45vh;
        object-fit: cover;
        object-position: center;
    `;
    locationImage.loading = "eager";
    scrollableContent.appendChild(locationImage);
    
    const contentContainer = document.createElement('div');
    contentContainer.classList.add('lochunt-content');
    contentContainer.style.cssText = `
        padding: 24px;
        display: flex;
        flex-direction: column;
        align-items: center;
        max-width: 800px;
        margin: 0 auto;
    `;
    
    const locationInfo = document.createElement('div');
    locationInfo.classList.add('lochunt-info');
    locationInfo.style.cssText = `
        text-align: center;
        width: 100%;
        margin-bottom: 15px;
    `;
    
    const locationName = document.createElement('h1');
    locationName.textContent = location.name;
    locationName.style.cssText = `
        font-size: clamp(1.8rem, 4vw, 2.5rem);
        font-weight: 700;
        color: #1a1a1a;
        margin-bottom: 8px;
        line-height: 1.2;
    `;
    
    const locationCity = document.createElement('p');
    locationCity.textContent = `${location.city}`;
    locationCity.style.cssText = `
        font-size: clamp(1.1rem, 2vw, 1.3rem);
        color: #2c5282;
        font-weight: 600;
        margin-bottom: 4px;
    `;
    
    const locationCreator = document.createElement('p');
    locationCreator.textContent = `Created by: ${location.creator}`;
    locationCreator.style.cssText = `
        font-size: calc(0.9rem + 0.4vw);
        color: #666666;
        font-weight: 500;
    `;
    
    locationInfo.appendChild(locationName);
    locationInfo.appendChild(locationCity);
    locationInfo.appendChild(locationCreator);
    contentContainer.appendChild(locationInfo);
    
    const audioPlayerContainer = createAudioPlayer(location.audio);
    contentContainer.appendChild(audioPlayerContainer);
    scrollableContent.appendChild(contentContainer);
    lochuntContainer.appendChild(scrollableContent);
    
    const bottomActionBar = createBottomActionBar(location);
    bottomActionBar.style.cssText += `
        position: sticky;
        bottom: 0;
        width: 100%;
    `;
    lochuntContainer.appendChild(bottomActionBar);
    
    const timeoutId = memoryManager.registerTimer(
        setTimeout(() => {
            window.audioPlayerCleanup = initAudioPlayer();
        }, 100)
    );
    
    // Prefetch nearby audio files
    serviceWorkerManager.prefetchAudio(
        userMarker ? userMarker.getLatLng() : null,
        gameLocations
    );
}

function createAudioPlayer(audioSrc) {
    const audioPlayerContainer = document.createElement('div');
    audioPlayerContainer.classList.add('audio-player');
    audioPlayerContainer.style.cssText = `
        width: 100%;
        max-width: 400px;
        margin-bottom: 15px;
    `;

    const audio = document.createElement('audio');
    audio.id = 'locationAudio';
    audio.src = audioSrc;
    audio.preload = "auto";

    const audioProgress = document.createElement('div');
    audioProgress.classList.add('audio-progress');
    audioProgress.style.cssText = `
        width: 100%;
        margin-bottom: 15px;
    `;

    const progressContainer = document.createElement('div');
    progressContainer.classList.add('progress');
    progressContainer.style.cssText = `
        height: 8px;
        background-color: #e2e8f0;
        border-radius: 4px;
        cursor: pointer;
        margin-bottom: 12px;
        overflow: hidden;
    `;

    const progressBar = document.createElement('div');
    progressBar.id = 'progressBar';
    progressBar.classList.add('progress-bar');
    progressBar.style.cssText = `
        height: 100%;
        background-color: #2c5282;
        width: 0%;
        transition: width 0.1s linear;
    `;

    progressContainer.appendChild(progressBar);
    audioProgress.appendChild(progressContainer);

    const timeInfo = document.createElement('div');
    timeInfo.classList.add('audio-time');
    timeInfo.style.cssText = `
        display: flex;
        justify-content: space-between;
        color: #4a5568;
        font-size: 0.875rem;
        margin-bottom: 16px;
        font-weight: 500;
    `;

    const currentTimeSpan = document.createElement('span');
    currentTimeSpan.id = 'currentTime';
    currentTimeSpan.textContent = '0:00';

    const durationSpan = document.createElement('span');
    durationSpan.id = 'duration';
    durationSpan.textContent = '0:00';

    timeInfo.appendChild(currentTimeSpan);
    timeInfo.appendChild(durationSpan);

    const audioControls = document.createElement('div');
    audioControls.classList.add('audio-controls');
    audioControls.style.cssText = `
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 24px;
    `;

    const rewindBtn = createAudioButton('skip-backward', 'rewindBtn', 'Rewind 10 seconds');
    const playPauseBtn = createAudioButton('play', 'playPauseBtn', 'Play');
    const forwardBtn = createAudioButton('skip-forward', 'forwardBtn', 'Forward 10 seconds');

    audioControls.appendChild(rewindBtn);
    audioControls.appendChild(playPauseBtn);
    audioControls.appendChild(forwardBtn);

    audioPlayerContainer.appendChild(audio);
    audioPlayerContainer.appendChild(audioProgress);
    audioPlayerContainer.appendChild(timeInfo);
    audioPlayerContainer.appendChild(audioControls);

    return audioPlayerContainer;
}

function createAudioButton(iconName, id, ariaLabel) {
    const button = document.createElement('button');
    button.id = id;
    button.classList.add('audio-button');
    button.setAttribute('aria-label', ariaLabel);
    button.innerHTML = `<i class="bi bi-${iconName}"></i>`;
    button.style.cssText = `
        background-color: white;
        color: var(--primary-color);
        border: 2px solid var(--primary-color);
        border-radius: 50%;
        width: 55px;
        height: 55px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.3s ease;
    `;

    memoryManager.registerEventListener(button, 'mouseover', () => {
        button.style.backgroundColor = 'var(--hover-color)';
    });

    memoryManager.registerEventListener(button, 'mouseout', () => {
        button.style.backgroundColor = 'white';
    });

    memoryManager.registerEventListener(button, 'click', () => {
        button.style.backgroundColor = 'var(--primary-color)';
        button.style.color = 'white';
        button.style.transform = 'scale(0.95)';
        
        const timeoutId = memoryManager.registerTimer(
            setTimeout(() => {
                button.style.backgroundColor = 'white';
                button.style.color = 'var(--primary-color)';
                button.style.transform = 'scale(1)';
            }, 200)
        );
    });

    return button;
}

function createBottomActionBar(location) {
    const actionBar = document.createElement('div');
    actionBar.classList.add('location-action-bar');
    actionBar.style.cssText = `
        width: 100%;
        height: 60px;
        background: linear-gradient(to right, #2c5282, #2b6cb0);
        margin-top: auto;
        box-shadow: 0 -2px 10px rgba(0,0,0,0.025);
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0 24px;
        position: sticky;
        bottom: 0;
    `;
    
    const imgSourceBtn = document.createElement('button');
    imgSourceBtn.classList.add('source-info-button', 'btn', 'btn-sm', 'me-2');
    imgSourceBtn.innerHTML = '<i class="bi bi-info-circle-fill text-white" style="font-size: 1.5rem;"></i>';
    imgSourceBtn.setAttribute('aria-label', 'Image source information');
    imgSourceBtn.onclick = () => {
        if (location && location.imageSource) {
            showSourcePopup('Image Source', location.imageSource);
        } else {
            showSourcePopup('Image Source', 'Image source information is not available');
        }
    };

    const feedbackButton = document.createElement('a');
    feedbackButton.href = 'mailto:mattreicher@protonmail.com?subject=Feedback';
    feedbackButton.target = '_blank';
    feedbackButton.rel = 'noopener noreferrer';
    feedbackButton.setAttribute('aria-label', 'Send feedback email');
    feedbackButton.innerHTML = '<i class="bi bi-envelope-fill text-white" style="font-size: 1.5rem;"></i>';
    feedbackButton.classList.add('feedback-email-button', 'btn', 'btn-sm');

    actionBar.appendChild(imgSourceBtn);
    actionBar.appendChild(feedbackButton);
    return actionBar;
}

function showSourcePopup(title, content) {
    const existingPopup = document.getElementById('sourceInfoPopup');
    if (existingPopup) {
        document.body.removeChild(existingPopup);
    }
    
    const overlay = document.createElement('div');
    overlay.id = 'sourceInfoPopup';
    overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 9999;
        backdrop-filter: blur(3px);
    `;

    const popup = document.createElement('div');
    popup.classList.add('source-info-content');
    popup.style.cssText = `
        background-color: white;
        border-radius: 8px;
        padding: 24px;
        width: 90%;
        max-width: 500px;
        max-height: 80vh;
        overflow-y: auto;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
        display: flex;
        flex-direction: column;
    `;

    const popupTitle = document.createElement('h3');
    popupTitle.textContent = title;
    popupTitle.style.cssText = `
        font-size: 1.5rem;
        font-weight: 600;
        color: #2c5282;
        margin-bottom: 16px;
        border-bottom: 1px solid #e2e8f0;
        padding-bottom: 12px;
    `;

    const popupContent = document.createElement('div');
    popupContent.style.cssText = `
        margin-bottom: 20px;
        line-height: 1.6;
        font-size: 1rem;
    `;
    popupContent.textContent = content;

    const closeButton = document.createElement('button');
    closeButton.textContent = 'Close';
    closeButton.classList.add('source-close-button', 'btn');
    closeButton.style.cssText = `
        background: linear-gradient(to right, #2c5282, #2b6cb0);
        border: none;
        color: white;
        padding: 8px 24px;
        border-radius: 4px;
        font-weight: 500;
        cursor: pointer;
        align-self: flex-end;
        transition: all 0.2s ease;
    `;
    
    memoryManager.registerEventListener(closeButton, 'mouseover', () => {
        closeButton.style.opacity = '0.9';
    });
    
    memoryManager.registerEventListener(closeButton, 'mouseout', () => {
        closeButton.style.opacity = '1';
    });
    
    memoryManager.registerEventListener(closeButton, 'click', () => {
        document.body.removeChild(overlay);
    });

    memoryManager.registerEventListener(overlay, 'click', (e) => {
        if (e.target === overlay) {
            document.body.removeChild(overlay);
        }
    });

    popup.appendChild(popupTitle);
    popup.appendChild(popupContent);
    popup.appendChild(closeButton);
    overlay.appendChild(popup);
    document.body.appendChild(overlay);

    overlay.style.opacity = '0';
    popup.style.transform = 'translateY(20px)';
    popup.style.transition = 'transform 0.3s ease, opacity 0.3s ease';
    overlay.style.transition = 'opacity 0.3s ease';
    
    const timeoutId = memoryManager.registerTimer(
        setTimeout(() => {
            overlay.style.opacity = '1';
            popup.style.transform = 'translateY(0)';
        }, 10)
    );
}

// =============================================================================
// ENHANCED AUDIO PLAYER WITH RECOVERY
// =============================================================================

function initAudioPlayer() {
    const audio = document.getElementById('locationAudio');
    const playPauseBtn = document.getElementById('playPauseBtn');
    const rewindBtn = document.getElementById('rewindBtn');
    const forwardBtn = document.getElementById('forwardBtn');
    const progressBar = document.getElementById('progressBar');
    const progressContainer = document.querySelector('.progress');
    const currentTimeSpan = document.getElementById('currentTime');
    const durationSpan = document.getElementById('duration');

    if (!audio || !playPauseBtn || !progressBar) {
        console.error("Audio player elements not found");
        return;
    }

    if (audio.src && !audio.dataset.originalSrc) {
        audio.dataset.originalSrc = audio.src;
    }

    let wakeLock = null;
    let audioContext = null;
    let isPlayerActive = true;
    
    let retryCount = 0;
    const maxRetries = 3;
    let lastPlaybackPosition = 0;
    let recoveryInProgress = false;
    
    let wasPlayingWhenHidden = false;
    let screenWentAway = false;
    let wasPlaying = false;

    function initAudioContext() {
        if (!audioContext && isPlayerActive) {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const source = audioContext.createMediaElementSource(audio);
                source.connect(audioContext.destination);
            } catch (e) {
                console.log('AudioContext not available:', e);
            }
        }
        return audioContext;
    }

    async function requestWakeLock() {
        try {
            if ('wakeLock' in navigator && !wakeLock && isPlayerActive) {
                wakeLock = await navigator.wakeLock.request('screen');
                console.log('Wake lock acquired');
                
                wakeLock.addEventListener('release', () => {
                    console.log('Wake lock released');
                    wakeLock = null;
                    if (!audio.paused) {
                        screenWentAway = true;
                        wasPlayingWhenHidden = true;
                    }
                });
            }
        } catch (err) {
            console.warn('Wake lock failed:', err);
        }
    }

    async function releaseWakeLock() {
        if (wakeLock) {
            try {
                await wakeLock.release();
                wakeLock = null;
                console.log('Wake lock manually released');
            } catch (err) {
                console.warn('Wake lock release failed:', err);
            }
        }
    }

    memoryManager.registerEventListener(document, 'visibilitychange', () => {
        if (document.hidden) {
            if (!audio.paused) {
                wasPlayingWhenHidden = true;
                screenWentAway = true;
            }
        } else {
            if (wasPlayingWhenHidden && audio.paused) {
                const timeoutId = memoryManager.registerTimer(
                    setTimeout(() => {
                        if (screenWentAway) {
                            showSourcePopup("Audio Restarted", "Audio was interrupted when this tab became inactive and has restarted from the beginning. Keep this tab active to prevent interruptions.");
                            screenWentAway = false;
                            wasPlayingWhenHidden = false;
                        }
                    }, 100)
                );
            }
        }
    });

    memoryManager.registerEventListener(audio, 'play', () => {
        wasPlaying = true;
        accessibilityManager.announce('Audio playback started');
    });

    memoryManager.registerEventListener(audio, 'pause', () => {
        wasPlaying = false;
        accessibilityManager.announce('Audio playback paused');
    });

    function recoverAudioSource() {
        if (recoveryInProgress || !isPlayerActive) return;
        
        recoveryInProgress = true;
        console.log('Attempting audio recovery...');
        
        if (!isNaN(audio.currentTime)) {
            lastPlaybackPosition = audio.currentTime;
        }
        
        if (audio.dataset.originalSrc) {
            audio.src = audio.dataset.originalSrc;
        } else if (audio.getAttribute('data-src')) {
            audio.src = audio.getAttribute('data-src');
        }
        
        audio.load();
        
        memoryManager.registerEventListener(audio, 'loadedmetadata', function restorePosition() {
            if (lastPlaybackPosition > 0 && !screenWentAway) {
                audio.currentTime = lastPlaybackPosition;
            } else if (screenWentAway) {
                audio.currentTime = 0;
            }
            recoveryInProgress = false;
            retryCount = 0;
            memoryManager.unregisterEventListener(audio, 'loadedmetadata', restorePosition);
        });
    }

    function handleAudioError(error) {
        console.log('handleAudioError called, isPlayerActive:', isPlayerActive, 'audio exists:', !!audio);
        console.log('Screen went away:', screenWentAway, 'Was playing when hidden:', wasPlayingWhenHidden);
        console.log('Current lastPlaybackPosition:', lastPlaybackPosition);
        
        const actualError = audio ? audio.error : null;
        if (actualError) {
            console.error("Actual audio error details:", {
                code: actualError.code,
                message: actualError.message,
                MEDIA_ERR_ABORTED: actualError.code === 1,
                MEDIA_ERR_NETWORK: actualError.code === 2,
                MEDIA_ERR_DECODE: actualError.code === 3,
                MEDIA_ERR_SRC_NOT_SUPPORTED: actualError.code === 4
            });
        }
        
        if (!isPlayerActive && (!audio || audio.readyState === 0)) {
            console.log('Audio error ignored - player cleaned up');
            return;
        }
        
        console.error("Audio play error event:", error);
        releaseWakeLock();
        
        if (screenWentAway || wasPlayingWhenHidden) {
            const resumePosition = lastPlaybackPosition || 0;
            console.log('Screen interruption detected, stored position:', resumePosition);
            
            showSourcePopup("Audio Interrupted", `Audio was paused when you left the screen. Click play to resume from ${Math.floor(resumePosition / 60)}:${String(Math.floor(resumePosition % 60)).padStart(2, '0')}.`);
            
            if (audio) {
                audio.dataset.resumePosition = resumePosition.toString();
                
                const prepareForResume = () => {
                    console.log('Audio prepared for manual resume');
                    memoryManager.unregisterEventListener(audio, 'loadedmetadata', prepareForResume);
                    memoryManager.unregisterEventListener(audio, 'canplay', prepareForResume);
                };
                
                memoryManager.registerEventListener(audio, 'loadedmetadata', prepareForResume);
                memoryManager.registerEventListener(audio, 'canplay', prepareForResume);
                
                recoverAudioSource();
            }
            
            screenWentAway = false;
            wasPlayingWhenHidden = false;
        } else if (retryCount < maxRetries && isPlayerActive) {
            retryCount++;
            console.log(`Recovery attempt ${retryCount}/${maxRetries}`);
            
            const timeoutId = memoryManager.registerTimer(
                setTimeout(() => {
                    const currentPos = lastPlaybackPosition || 0;
                    const setPositionAfterNetworkRecovery = () => {
                        if (currentPos > 0) {
                            console.log('Setting position after network recovery:', currentPos);
                            audio.currentTime = currentPos;
                        }
                        memoryManager.unregisterEventListener(audio, 'loadedmetadata', setPositionAfterNetworkRecovery);
                        memoryManager.unregisterEventListener(audio, 'canplay', setPositionAfterNetworkRecovery);
                    };
                    
                    memoryManager.registerEventListener(audio, 'loadedmetadata', setPositionAfterNetworkRecovery);
                    memoryManager.registerEventListener(audio, 'canplay', setPositionAfterNetworkRecovery);
                    
                    recoverAudioSource();
                }, 1000 * retryCount)
            );
        } else if (retryCount >= maxRetries) {
            console.error('Audio recovery failed after maximum retries');
            playPauseBtn.innerHTML = '<i class="bi bi-exclamation-triangle"></i>';
            playPauseBtn.setAttribute('aria-label', 'Audio Error');
            showSourcePopup("Audio Error", "Unable to recover audio after multiple attempts. Please refresh the page or try again later.");
        } else {
            if (audio) {
                const currentPos = lastPlaybackPosition || 0;
                const setPositionAfterGenericRecovery = () => {
                    if (currentPos > 0) {
                        console.log('Setting position after generic recovery:', currentPos);
                        audio.currentTime = currentPos;
                    }
                    memoryManager.unregisterEventListener(audio, 'loadedmetadata', setPositionAfterGenericRecovery);
                    memoryManager.unregisterEventListener(audio, 'canplay', setPositionAfterGenericRecovery);
                };
                
                memoryManager.registerEventListener(audio, 'loadedmetadata', setPositionAfterGenericRecovery);
                memoryManager.registerEventListener(audio, 'canplay', setPositionAfterGenericRecovery);
                
                recoverAudioSource();
            }
            showSourcePopup("Audio Error", "An audio error occurred. Attempting to resume from last position.");
        }
        
        playPauseBtn.innerHTML = '<i class="bi bi-play"></i>';
        playPauseBtn.setAttribute('aria-label', 'Play');
    }

    function togglePlay() {
        if (audio.paused) {
            const resumePosition = audio.dataset.resumePosition;
            if (resumePosition && parseFloat(resumePosition) > 0) {
                console.log('Resuming from stored position:', resumePosition);
                audio.currentTime = parseFloat(resumePosition);
                delete audio.dataset.resumePosition;
            }
            
            audio.play().then(() => {
                playPauseBtn.innerHTML = '<i class="bi bi-pause"></i>';
                playPauseBtn.setAttribute('aria-label', 'Pause');
                requestWakeLock();
            }).catch(error => {
                handleAudioError(error);
            });
        } else {
            audio.pause();
            playPauseBtn.innerHTML = '<i class="bi bi-play"></i>';
            playPauseBtn.setAttribute('aria-label', 'Play');
        }
    }

    async function togglePlayAsync() {
        if (!isPlayerActive) return;
        
        try {
            if (audio.paused) {
                const ctx = initAudioContext();
                if (ctx && ctx.state === 'suspended') {
                    await ctx.resume();
                }
                
                const playPromise = audio.play();
                if (playPromise !== undefined) {
                    playPromise.then(async () => {
                        playPauseBtn.innerHTML = '<i class="bi bi-pause"></i>';
                        playPauseBtn.setAttribute('aria-label', 'Pause');
                        await requestWakeLock();
                        retryCount = 0;
                    }).catch(error => {
                        handleAudioError(error);
                    });
                }
            } else {
                audio.pause();
                playPauseBtn.innerHTML = '<i class="bi bi-play"></i>';
                playPauseBtn.setAttribute('aria-label', 'Play');
                await releaseWakeLock();
            }
        } catch (error) {
            handleAudioError(error);
        }
    }

    function seek(seconds) {
        if (!isPlayerActive) return;
        audio.currentTime = Math.max(0, Math.min(audio.currentTime + seconds, audio.duration));
        
        const direction = seconds > 0 ? 'forward' : 'backward';
        accessibilityManager.announce(`Skipped ${Math.abs(seconds)} seconds ${direction}`);
    }

    function updateProgress() {
        if (!isPlayerActive || !isFinite(audio.duration)) return;
        
        const percent = (audio.currentTime / audio.duration) * 100;
        progressBar.style.width = `${percent}%`;
        currentTimeSpan.textContent = formatTime(audio.currentTime);
    }

    function setProgress(e) {
        if (!isPlayerActive) return;
        
        const width = this.clientWidth;
        const clickX = e.offsetX;
        const duration = audio.duration;
        
        if (isFinite(duration) && width > 0) {
            audio.currentTime = (clickX / width) * duration;
            
            const newTime = formatTime(audio.currentTime);
            accessibilityManager.announce(`Jumped to ${newTime}`);
        }
    }

    function setDuration() {
        if (!isPlayerActive || !isFinite(audio.duration)) return;
        durationSpan.textContent = formatTime(audio.duration);
    }

    function formatTime(time) {
        if (!isFinite(time)) return "0:00";
        
        const minutes = Math.floor(time / 60);
        const seconds = Math.floor(time % 60);
        return `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }

    memoryManager.registerEventListener(audio, 'timeupdate', () => {
        if (!isNaN(audio.currentTime) && isPlayerActive && audio.currentTime > 0) {
            lastPlaybackPosition = audio.currentTime;
            try {
                localStorage.setItem('audioPosition', audio.currentTime.toString());
            } catch (e) {
                // Ignore localStorage errors
            }
        }
    });

    memoryManager.registerEventListener(document, 'visibilitychange', () => {
        if (document.hidden) {
            if (audio && !audio.paused) {
                if (!isNaN(audio.currentTime)) {
                    lastPlaybackPosition = audio.currentTime;
                    console.log('Screen went away, storing position and pausing:', lastPlaybackPosition);
                    try {
                        localStorage.setItem('audioPosition', audio.currentTime.toString());
                    } catch (e) {
                        // Ignore localStorage errors
                    }
                }
                
                wasPlayingWhenHidden = true;
                screenWentAway = true;
                
                audio.pause();
                
                playPauseBtn.innerHTML = '<i class="bi bi-play"></i>';
                playPauseBtn.setAttribute('aria-label', 'Play');
            }
        }
    });

    memoryManager.registerEventListener(window, 'blur', () => {
        if (audio && !audio.paused) {
            lastPlaybackPosition = audio.currentTime;
            wasPlayingWhenHidden = true;
            screenWentAway = true;
            console.log('Window blur, storing position:', lastPlaybackPosition);
        }
    });

    memoryManager.registerEventListener(window, 'online', () => {
        if (audio.error && isPlayerActive) {
            console.log('Network recovered, attempting to reload audio');
            const savedPos = lastPlaybackPosition || 0;
            const setPositionAfterOnline = () => {
                if (savedPos > 0) {
                    audio.currentTime = savedPos;
                }
                memoryManager.unregisterEventListener(audio, 'loadedmetadata', setPositionAfterOnline);
                memoryManager.unregisterEventListener(audio, 'canplay', setPositionAfterOnline);
            };
            
            memoryManager.registerEventListener(audio, 'loadedmetadata', setPositionAfterOnline);
            memoryManager.registerEventListener(audio, 'canplay', setPositionAfterOnline);
            
            recoverAudioSource();
        }
    });

    // Set up event listeners 
    memoryManager.registerEventListener(playPauseBtn, 'click', togglePlay);
    memoryManager.registerEventListener(rewindBtn, 'click', () => seek(-10));
    memoryManager.registerEventListener(forwardBtn, 'click', () => seek(10));
    memoryManager.registerEventListener(audio, 'timeupdate', updateProgress);
    memoryManager.registerEventListener(audio, 'loadedmetadata', setDuration);
    memoryManager.registerEventListener(audio, 'ended', async () => {
        playPauseBtn.innerHTML = '<i class="bi bi-play"></i>';
        playPauseBtn.setAttribute('aria-label', 'Play');
        await releaseWakeLock();
        
        try {
            localStorage.removeItem('audioPosition');
        } catch (e) {
            // Ignore localStorage errors
        }
        
        audio.currentTime = 0;
        if (progressBar) {
            progressBar.style.width = '0%';
        }
        
        accessibilityManager.announce('Audio playback completed');
        showAdditionalInfo();
    });
    memoryManager.registerEventListener(audio, 'pause', releaseWakeLock);
    memoryManager.registerEventListener(audio, 'error', (e) => {
        handleAudioError(e);
    });

    if (progressContainer) {
        memoryManager.registerEventListener(progressContainer, 'click', setProgress);
    }

    memoryManager.registerEventListener(audio, 'loadedmetadata', () => {
        try {
            const savedPosition = localStorage.getItem('audioPosition');
            if (savedPosition && !isNaN(savedPosition) && parseFloat(savedPosition) > 0 && !screenWentAway && !wasPlayingWhenHidden) {
                audio.currentTime = parseFloat(savedPosition);
            }
        } catch (e) {
            // Ignore localStorage errors
        }
    });

    audio.load();

    return function cleanup() {
        console.log('Audio player cleanup starting');
        releaseWakeLock();
        isPlayerActive = false;
        if (audioContext) {
            audioContext.close();
        }
        console.log('Audio player cleaned up');
    };
}

function showAdditionalInfo() {
    const location = gameLocations.find(loc => loc.id === lastVisitedLocationId);
    if (!location) {
        console.error('Location not found for ID:', lastVisitedLocationId);
        return;
    }
    
    const additionalInfoContainer = cachedElements.additionalInfoContainer || document.querySelector('.additional-info-container');
    additionalInfoContainer.style.display = 'block';
    additionalInfoContainer.classList.add('fade-in');
    
    document.getElementById('additionalInfo').textContent = location.additionalInfo || 
        "No additional information available for this location.";

    accessibilityManager.announce('Additional information is now available');

    const continueButton = document.getElementById('continueButton');
    continueButton.onclick = () => {
        additionalInfoContainer.classList.add('fade-out');
        const timeoutId = memoryManager.registerTimer(
            setTimeout(() => {
                additionalInfoContainer.style.display = 'none';
                additionalInfoContainer.classList.remove('fade-out');
                
                const lochuntContainer = cachedElements.lochuntContainer || document.querySelector('.lochunt-container');
                lochuntContainer.classList.add('fade-out');
                const timeoutId2 = memoryManager.registerTimer(
                    setTimeout(() => {
                        lochuntContainer.style.display = 'none';
                        lochuntContainer.classList.remove('fade-out');
                        isLocationHuntVisible = false;
                        
                        accessibilityManager.announce('Returned to map view');
                        
                        updateDistanceBox();
                        
                        if (window.audioPlayerCleanup) {
                            window.audioPlayerCleanup();
                            window.audioPlayerCleanup = null;
                        }
                    }, 300)
                );
            }, 300)
        );
    };
}

// =============================================================================
// NAVIGATION AND MODAL SYSTEMS
// =============================================================================

function showNavigationTips() {
    const modalOverlay = document.createElement("div");
    modalOverlay.className = "navigation-tips-overlay";
    modalOverlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.6);
        backdrop-filter: blur(4px);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
        opacity: 0;
        transition: opacity 0.3s ease;
    `;
    
    const darkBlue = "var(--dark-blue)";
    const darkBlueHover = "var(--dark-blue-hover)";
    
    const modalContent = document.createElement("div");
    modalContent.className = "navigation-tips-content";
    modalContent.style.cssText = `
        background-color: white;
        border-radius: 16px;
        width: 90%;
        max-width: 450px;
        max-height: 95vh;
        box-shadow: 0 15px 40px rgba(0, 0, 0, 0.25);
        transform: translateY(20px);
        transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        overflow: hidden;
        display: flex !important;
        flex-direction: column !important;
        position: relative;
    `;
    
    const header = document.createElement("div");
    header.style.cssText = `
        text-align: center;
        padding: 20px 28px 0;
    `;
    
    header.innerHTML = `
        <h3 style="
            margin: 0 0 10px 0;
            color: ${darkBlue};
            font-size: 1.5rem;
            font-weight: 600;
        ">Navigation Tips</h3>
    `;
    
    const contentArea = document.createElement("div");
    contentArea.style.cssText = `
        padding: 0 28px;
        color: #5c6c7c;
        line-height: 1.4;
        font-size: 0.9rem;
    `;
    
    contentArea.innerHTML = `
        <ul style="
            list-style-type: none;
            padding: 0;
            margin: 0 0 10px 0;
        ">
            <li style="margin-bottom: 8px; display: flex; align-items: flex-start;">
                <span style="color: ${darkBlue}; margin-right: 10px; font-size: 1.1rem;"></span>
                <span>Use the map to navigate to the marked locations.</span>
            </li>
            <li style="margin-bottom: 8px; display: flex; align-items: flex-start;">
                <span style="color: ${darkBlue}; margin-right: 10px; font-size: 1.1rem;"></span>
                <span>Tap the recenter button to focus on your current position.</span>
            </li>
            <li style="margin-bottom: 8px; display: flex; align-items: flex-start;">
                <span style="color: ${darkBlue}; margin-right: 10px; font-size: 1.1rem;"></span>
                <span>The distance box shows how far you are from the closest location.</span>
            </li>
            <li style="margin-bottom: 8px; display: flex; align-items: flex-start;">
                <span style="color: ${darkBlue}; margin-right: 10px; font-size: 1.1rem;"></span>
                <span>When you're within 20 feet of a location, you'll be able to interact with it.</span>
            </li>
            <li style="margin-bottom: 8px; display: flex; align-items: flex-start;">
                <span style="color: ${darkBlue}; margin-right: 10px; font-size: 1.1rem;"></span>
                <span>Listen to the audio information for each location.</span>
            </li>
            <li style="margin-bottom: 0; display: flex; align-items: flex-start;">
                <span style="color: ${darkBlue}; margin-right: 10px; font-size: 1.1rem;"></span>
                <span>After the audio, you'll see additional information about the location.</span>
            </li>
        </ul>
    `;
    
    const footer = document.createElement("div");
    footer.style.cssText = `
        padding: 15px 28px 20px !important;
        text-align: center !important;
        border-top: 1px solid rgba(0, 0, 0, 0.05);
        margin-top: 10px !important;
        display: flex !important;
        justify-content: center !important;
        align-items: center !important;
        position: relative !important;
        bottom: 0 !important;
        width: 100% !important;
        box-sizing: border-box !important;
    `;
    
    const closeButton = document.createElement("button");
    closeButton.className = "close-button";
    closeButton.textContent = "Close";
    closeButton.style.cssText = `
        padding: 10px 24px !important;
        background-color: ${darkBlue};
        color: white;
        border: none;
        border-radius: 10px;
        cursor: pointer;
        font-size: 1rem;
        font-weight: 600;
        width: 100% !important;
        max-width: 200px !important;
        transition: all 0.2s ease;
        margin: 0 auto !important;
        display: block !important;
        position: relative !important;
        left: 0 !important;
        right: 0 !important;
    `;
    
    footer.appendChild(closeButton);
    
    modalContent.appendChild(header);
    modalContent.appendChild(contentArea);
    modalContent.appendChild(footer);
    modalOverlay.appendChild(modalContent);
    document.body.appendChild(modalOverlay);
    
    const timeoutId = memoryManager.registerTimer(
        setTimeout(() => {
            modalOverlay.style.opacity = "1";
            modalContent.style.transform = "translateY(0)";
        }, 10)
    );
    
    memoryManager.registerEventListener(closeButton, 'mouseover', function() {
        this.style.backgroundColor = darkBlueHover;
    });
    
    memoryManager.registerEventListener(closeButton, 'mouseout', function() {
        this.style.backgroundColor = darkBlue;
    });
    
    memoryManager.registerEventListener(closeButton, 'click', function() {
        modalOverlay.style.opacity = "0";
        modalContent.style.transform = "translateY(20px)";
        const timeoutId = memoryManager.registerTimer(
            setTimeout(() => {
                document.body.removeChild(modalOverlay);
            }, 300)
        );
    });
    
    memoryManager.registerEventListener(modalOverlay, 'click', function(e) {
        if (e.target === modalOverlay) {
            modalOverlay.style.opacity = "0";
            modalContent.style.transform = "translateY(20px)";
            const timeoutId = memoryManager.registerTimer(
                setTimeout(() => {
                    document.body.removeChild(modalOverlay);
                }, 300)
            );
        }
    });
}

// =============================================================================
// LOCATION AND MARKER MANAGEMENT
// =============================================================================

function startHunt() {
    gameLocations = locations.sort((a, b) => a.id - b.id);
    currentLocationIndex = 0;
    locationTriggerManager.clearCooldowns();
    lastVisitedLocationId = null;
    loadAllLocations();
}

function getMarkerColor(tours) {
    if (!tours) return '#0f2bab';
    
    switch (tours.toLowerCase()) {
        case 'person':
            return '#FFA500';
        case 'gangster':
            return '#3f9b0b';
        case 'event':
            return '#8B0000';
        case 'place':
            return '#800080';
        default:
            return '#0f2bab';
    }
}

let markersCreated = false;
let activePopups = new Set();

function createMarkersOnly() {
    if (!gameLocations || !Array.isArray(gameLocations) || gameLocations.length === 0) {
        console.warn("No game locations available");
        return;
    }

    if (markerClusterGroup) {
        markerClusterGroup.clearLayers();
    }

    activePopups.clear();

    gameLocations.forEach((location) => {
        if (!location || typeof location.lat !== 'number' || typeof location.lng !== 'number') {
            console.warn("Invalid location data:", location);
            return;
        }

        const markerColor = getMarkerColor(location.tours);
        
        const locationMarker = L.marker([location.lat, location.lng], {
            icon: L.divIcon({
                className: 'custom-pin-icon',
                html: `<div class="pin-head" style="background-color: ${markerColor};"></div>`,
                iconSize: [30, 30],
                iconAnchor: [15, 30],
            })
        });

        const popupContent = `
            <div class="popup-content">
                <img loading="lazy" src="${location.image}" alt="${location.name}" class="location-image">
                <h4 class="location-name">
                    <a href="${location.link}" target="_blank" rel="noopener noreferrer" style="text-decoration: none; color: inherit;">${location.name}</a>
                </h4>
                <div class="popup-buttons">
                    <button class="button route-button" data-lat="${location.lat}" data-lng="${location.lng}" data-location-id="${location.id}">Directions</button>
                    <button class="button summary-button" data-location-id="${location.id}">Summary</button>
                </div>
            </div>
        `;

        locationMarker.bindPopup(popupContent, {
            offset: L.point(0, -25),
            className: 'custom-popup',
            maxWidth: 300,
            closeButton: true,
            autoClose: true,
            closeOnClick: true
        });

        locationMarker.on('popupopen', function(e) {
            activePopups.add(locationMarker);
            attachPopupEventListeners(e.popup._contentNode, location);
        });

        locationMarker.on('popupclose', function(e) {
            activePopups.delete(locationMarker);
        });

        markerClusterGroup.addLayer(locationMarker);
    });

    if (!map.hasLayer(markerClusterGroup)) {
        map.addLayer(markerClusterGroup);
    }
    
    markersCreated = true;
}

function attachPopupEventListeners(popupElement, location) {
    const routeButton = popupElement.querySelector('.route-button');
    const summaryButton = popupElement.querySelector('.summary-button');

    if (routeButton && !routeButton.hasAttribute('data-listener-attached')) {
        routeButton.setAttribute('data-listener-attached', 'true');
        memoryManager.registerEventListener(routeButton, 'click', function(event) {
            event.preventDefault();
            event.stopPropagation();
            showNavigationModal(location.lat, location.lng);
        });
    }

    if (summaryButton && !summaryButton.hasAttribute('data-listener-attached')) {
        summaryButton.setAttribute('data-listener-attached', 'true');
        memoryManager.registerEventListener(summaryButton, 'click', function(event) {
            event.preventDefault();
            event.stopPropagation();
            showLocationSummary(location.id);
        });
    }
}

function closeAllPopups() {
    activePopups.forEach(marker => {
        if (marker.isPopupOpen()) {
            marker.closePopup();
        }
    });
    activePopups.clear();
}

function loadAllLocations() {
    if (!gameLocations || !Array.isArray(gameLocations) || gameLocations.length === 0) {
        console.error("No locations available to load");
        showPopup("Error", "No locations available. Please try reloading the page.");
        return;
    }
    
    createMarkersOnly();
    updateDistanceBox();
    resetInactivityTimer();
}

// =============================================================================
// UTILITY AND HELPER FUNCTIONS
// =============================================================================

function isSignificantMovement(newPosition) {
    if (!lastPositionForJitter) {
        lastPositionForJitter = newPosition;
        lastSignificantMovement = Date.now();
        return true;
    }
    
    const distance = calculateDistance(lastPositionForJitter, newPosition);
    const timeSinceLastMovement = Date.now() - lastSignificantMovement;
    
    if (distance > CONFIG.JITTER_THRESHOLD && timeSinceLastMovement > CONFIG.SIGNIFICANT_MOVEMENT_COOLDOWN) {
        lastPositionForJitter = newPosition;
        lastSignificantMovement = Date.now();
        return true;
    }
    
    return false;
}

function resetInactivityTimer(isExplicitInteraction = true) {
    if (inactivityTimer) {
        clearTimeout(inactivityTimer);
        inactivityTimer = null;
    }
    
    inactivityTimer = memoryManager.registerTimer(
        setTimeout(() => {
            if (!isMapInteracting && userMarker) {
                followUser = true;
                
                const userPos = userMarker.getLatLng();
                if (userPos && userPos.lat && userPos.lng) {
                    map.flyTo(userPos, map.getZoom(), {
                        animate: true,
                        duration: 1.0,
                        easeLinearity: 0.25
                    });
                }
            }
        }, CONFIG.INACTIVITY_TIMEOUT)
    );
    
    if (isExplicitInteraction) {
        isMapInteracting = false;
    }
}

// =============================================================================
// EVENT LISTENERS AND INITIALIZATION
// =============================================================================

function setupEventListeners() {
    // Map interaction events
    map.on('dragstart', () => {
        followUser = false;
        isMapInteracting = true;
        if (inactivityTimer) {
            clearTimeout(inactivityTimer);
            inactivityTimer = null;
        }
    });
    
    map.on('dragend', () => {
        isMapInteracting = false;
        resetInactivityTimer();
    });
    
    map.on('zoomstart', () => {
        isMapInteracting = true;
        if (inactivityTimer) {
            clearTimeout(inactivityTimer);
            inactivityTimer = null;
        }
    });
    
    map.on('zoomend', () => {
        isMapInteracting = false;
        resetInactivityTimer();
    });
    
    // Enhanced touch event handling
    let touchStartTime = 0;
    let touchStartPos = null;
    let isTouchMoving = false;
    
    memoryManager.registerEventListener(document, 'touchstart', (e) => {
        touchStartTime = Date.now();
        touchStartPos = {
            x: e.touches[0].clientX,
            y: e.touches[0].clientY
        };
        isTouchMoving = false;
    }, { passive: true });
    
    memoryManager.registerEventListener(document, 'touchmove', (e) => {
        if (!touchStartPos) return;
        
        const touchCurrentPos = {
            x: e.touches[0].clientX,
            y: e.touches[0].clientY
        };
        
        const dx = touchCurrentPos.x - touchStartPos.x;
        const dy = touchCurrentPos.y - touchStartPos.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance > 10) {
            isTouchMoving = true;
            isMapInteracting = true;
            followUser = false;
            
            if (inactivityTimer) {
                clearTimeout(inactivityTimer);
                inactivityTimer = null;
            }
        }
    }, { passive: true });
    
    memoryManager.registerEventListener(document, 'touchend', (e) => {
        const touchEndTime = Date.now();
        const touchDuration = touchEndTime - touchStartTime;
        
        touchStartPos = null;
        
        if (touchDuration < 300 && !isTouchMoving) {
            return;
        }
        
        isMapInteracting = false;
        resetInactivityTimer();
    }, { passive: true });
    
    // Button event listeners
    memoryManager.registerEventListener(document.getElementById('recenterButton'), 'click', recenterMap);
    memoryManager.registerEventListener(document.getElementById('returnButton'), 'click', returnToIndex);
    memoryManager.registerEventListener(document.getElementById('tipsButton'), 'click', showNavigationTips);

    // Visibility and resize events
    memoryManager.registerEventListener(document, 'visibilitychange', handleVisibilityChange);
    
    memoryManager.registerEventListener(window, 'resize', () => {
        if (map) {
            map.invalidateSize();
            updateDistanceBox();
        }
    });
    
    // Enhanced pinch-zoom handling
    let initialPinchDistance = 0;
    let initialZoom = 0;
    let isPinching = false;
    
    memoryManager.registerEventListener(document, 'touchstart', (e) => {
        if (e.touches.length === 2) {
            isPinching = true;
            isMapInteracting = true;
            followUser = false;
            
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            initialPinchDistance = Math.hypot(
                touch2.clientX - touch1.clientX,
                touch2.clientY - touch1.clientY
            );
            initialZoom = map.getZoom();
            
            e.preventDefault();
        }
    }, { passive: false });
    
    memoryManager.registerEventListener(document, 'touchmove', (e) => {
        if (isPinching && e.touches.length === 2) {
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            const currentPinchDistance = Math.hypot(
                touch2.clientX - touch1.clientX,
                touch2.clientY - touch1.clientY
            );
            
            const pinchRatio = currentPinchDistance / initialPinchDistance;
            const zoomDelta = Math.log2(pinchRatio) * 2;
            const newZoom = Math.max(7, Math.min(18, initialZoom + zoomDelta));
            
            const centerX = (touch1.clientX + touch2.clientX) / 2;
            const centerY = (touch1.clientY + touch2.clientY) / 2;
            const centerPoint = L.point(centerX, centerY);
            const centerLatLng = map.containerPointToLatLng(centerPoint);
            
            map.setView(centerLatLng, newZoom, { animate: false });
            
            e.preventDefault();
        }
    }, { passive: false });
    
    memoryManager.registerEventListener(document, 'touchend', (e) => {
        if (isPinching) {
            isPinching = false;
            isMapInteracting = false;
            resetInactivityTimer();
            
            if (e.touches.length < 2) {
                e.preventDefault();
            }
        }
    }, { passive: false });
}

// =============================================================================
// INITIALIZATION AND CLEANUP
// =============================================================================

// Initialize session management
window.addEventListener('load', initializeSession);
window.addEventListener('pageshow', initializeSession);
window.addEventListener('storage', (event) => {
    if (event.key === SESSION_KEY && event.newValue !== currentSessionId) {
        console.log('Detected session change from another tab');
        currentSessionId = event.newValue;
        initializeSession();
    }
});

// Initialize immediately
initializeSession();

// Global cleanup function
window.performCleanup = () => {
    memoryManager.cleanup();
    if (window.audioPlayerCleanup) {
        window.audioPlayerCleanup();
    }
};

// Cleanup on page unload
window.addEventListener('beforeunload', window.performCleanup);

// Initialize the application
document.addEventListener('DOMContentLoaded', () => {
    // Cache DOM elements
    cacheElements();
    
    // Initialize map 
    initMap();
    
    // Set up event listeners
    setupEventListeners();
    
    // Initialize containers
    const additionalInfoContainer = cachedElements.additionalInfoContainer;
    if (additionalInfoContainer) {
        additionalInfoContainer.style.display = 'none';
    }
    
    const lochuntContainer = cachedElements.lochuntContainer;
    if (lochuntContainer) {
        lochuntContainer.style.display = 'none';
    }
    
    // Start performance monitoring
    console.log('Application initialized with enhanced systems');
    console.log('Memory Manager:', memoryManager.getMemoryStats());
    console.log('Performance Monitor:', performanceMonitor.getPerformanceReport());
    console.log('Accessibility Manager:', accessibilityManager.getAccessibilityStats());
});

// =============================================================================
// GLOBAL API EXPOSURE
// =============================================================================

// Expose key functions and managers globally for debugging and external access
window.MNThen = {
    memoryManager,
    performanceMonitor,
    serviceWorkerManager,
    kalmanFilter,
    zoomManager,
    locationTriggerManager,
    accessibilityManager,
    
    // Utility functions
    calculateDistance,
    isValidPosition,
    
    // Core functions
    recenterMap,
    updateDistanceBox,
    showLocationHunt,
    
    // Debug functions
    getStats: () => ({
        memory: memoryManager.getMemoryStats(),
        performance: performanceMonitor.getPerformanceReport(),
        accessibility: accessibilityManager.getAccessibilityStats(),
        zoom: zoomManager.getZoomStats(),
        locationTrigger: locationTriggerManager.getTriggerStats()
    }),
    
    cleanup: window.performCleanup
};

// Announce to screen reader function for global access
window.announceToScreenReader = (message, priority = 'polite') => {
    accessibilityManager.announce(message, priority);
};

console.log('MNThen Enhanced Application Loaded - Version 2.0');
console.log('Total lines of code: ~6800');
console.log('Features: Security, Performance, Memory Management, PWA, Accessibility');
    </script>
</body>
</html>
