<!DOCTYPE html>
<html lang="en">
<head> 
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Minnesota Then | Museum Without Walls</title>
    <link rel="shortcut icon" type="image/x-icon" href="https://www.mnthen.com/images/mnthenfav.ico">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css">
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css" />
    <link rel="stylesheet" href="https://www.mnthen.com/css/mainmap.css">
    <style>
/* Main styles */
body,
html {
  margin: 0;
  padding: 0;
  height: 100%;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
}

#map {
  height: 100vh;
  width: 100%;
  z-index: 1;
}

/* User marker */
.user-marker-icon {
  width: 20px;
  height: 20px;
  background-color: #0f2bab;
  border: 3px solid white;
  border-radius: 50%;
  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
}

/* Custom pin marker */
.custom-pin-icon {
  position: relative;
}

.pin-head {
  width: 20px;
  height: 20px;
  background-color: #0f2bab;
  border-radius: 50% 50% 50% 0;
  transform: rotate(-45deg);
  position: absolute;
  top: 0;
  left: 0;
  box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
}

.pin-head::after {
  content: "";
  width: 10px;
  height: 10px;
  background-color: white;
  border-radius: 50%;
  position: absolute;
  top: 5px;
  left: 5px;
}

/* Marker clusters */
.marker-cluster-custom {
  background-color: rgba(15, 43, 171, 0.6);
  border-radius: 50%;
  color: white;
  font-weight: bold;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
}

.marker-cluster-custom div {
  width: 34px;
  height: 34px;
  background-color: rgba(15, 43, 171, 0.8);
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
}

/* UI Controls */
.map-controls {
  position: absolute;
  bottom: 20px;
  right: 20px;
  z-index: 1000;
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.control-button {
  width: 50px;
  height: 50px;
  background-color: white;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
  border: none;
  cursor: pointer;
  color: #0f2bab;
  font-size: 24px;
  transition: all 0.2s ease;
}

.control-button:hover {
  transform: scale(1.05);
  background-color: #f8f8f8;
}

.control-button.active {
  background-color: #0f2bab;
  color: white;
}

/* Distance box */
#distanceBox {
  position: absolute;
  top: 20px;
  left: 50%;
  transform: translateX(-50%);
  background-color: white;
  padding: 8px 15px;
  border-radius: 20px;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
  font-size: 14px;
  font-weight: 500;
  z-index: 1000;
  max-width: 80%;
  text-align: center;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

/* Location hunt container */
.lochunt-container {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: white;
  z-index: 2000;
  display: none;
  overflow: hidden;
}

/* Navigation tips */
.navigation-tips {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: white;
  padding: 20px;
  border-radius: 10px;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
  z-index: 1500;
  max-width: 80%;
  max-height: 80%;
  overflow-y: auto;
  display: none;
}

.navigation-tips h3 {
  margin-top: 0;
  color: #0f2bab;
}

.navigation-tips ul {
  padding-left: 20px;
}

.navigation-tips .close-button {
  position: absolute;
  top: 10px;
  right: 10px;
  background: none;
  border: none;
  font-size: 20px;
  cursor: pointer;
  color: #666;
}

/* Modals */
.modal {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.5);
  z-index: 3000;
}

.modal-content {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: white;
  padding: 20px;
  border-radius: 10px;
  max-width: 80%;
}

.modal-buttons {
  display: flex;
  flex-direction: column;
  gap: 10px;
  margin-top: 20px;
}

.modal-button {
  padding: 10px;
  border: none;
  border-radius: 5px;
  background-color: #0f2bab;
  color: white;
  cursor: pointer;
}

.modal-button.cancel {
  background-color: #ccc;
  color: #333;
}

/* Popup styles */
.custom-popup {
  max-width: 300px;
}

.popup-content {
  padding: 5px;
}

.location-image {
  width: 100%;
  height: 150px;
  object-fit: cover;
  border-radius: 5px;
  margin-bottom: 10px;
}

.location-name {
  margin: 5px 0 10px;
  font-size: 16px;
  font-weight: 600;
}

.popup-buttons {
  display: flex;
  gap: 10px;
}

.popup-buttons .button {
  flex: 1;
  padding: 8px;
  border: none;
  border-radius: 5px;
  background-color: #0f2bab;
  color: white;
  cursor: pointer;
  font-size: 12px;
}

/* Audio player styles */
.audio-player {
  width: 100%;
  max-width: 400px;
  margin: 0 auto;
}

/* Preloader */
#preloader {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: white;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 9999;
}

.preloader-content {
  text-align: center;
  max-width: 80%;
}

.preloader-progress-container {
  width: 80%;
  height: 10px;
  background-color: #f0f0f0;
  border-radius: 5px;
  margin-top: 20px;
  overflow: hidden;
}

#preloaderProgress {
  height: 100%;
  background-color: #0f2bab;
  width: 0%;
  transition: width 0.3s ease;
}

/* Stabilizing modal */
.stabilizing-modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(255, 255, 255, 0.9);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 9998;
}

.spinner {
  width: 50px;
  height: 50px;
  border: 5px solid rgba(15, 43, 171, 0.2);
  border-top: 5px solid #0f2bab;
  border-radius: 50%;
  animation: spin 1s linear infinite;
  margin-bottom: 20px;
}

@keyframes spin {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}

/* Additional info container */
.additional-info-container {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: white;
  z-index: 2500;
  display: none;
  padding: 20px;
  box-sizing: border-box;
  overflow-y: auto;
}

.additional-info-container h2 {
  color: #0f2bab;
  margin-bottom: 20px;
}

#additionalInfo {
  margin-bottom: 30px;
  line-height: 1.6;
}

#continueButton {
  display: block;
  width: 200px;
  padding: 12px;
  background-color: #0f2bab;
  color: white;
  border: none;
  border-radius: 5px;
  font-size: 16px;
  font-weight: 500;
  margin: 0 auto;
  cursor: pointer;
}

/* Responsive adjustments */
@media (max-width: 768px) {
  .map-controls {
    bottom: 15px;
    right: 15px;
  }

  .control-button {
    width: 45px;
    height: 45px;
    font-size: 20px;
  }

  #distanceBox {
    top: 15px;
    padding: 6px 12px;
    font-size: 12px;
  }
}

@media (max-width: 480px) {
  .map-controls {
    bottom: 10px;
    right: 10px;
    gap: 8px;
  }

  .control-button {
    width: 40px;
    height: 40px;
    font-size: 18px;
  }

  .modal-content {
    width: 90%;
  }
}
    </style>
</head>
<body>
    <!-- Preloader -->
    <div id="preloader">
        <div class="spinner"></div>
        <p>Loading Minnesota Then...</p>
        <div class="progress-container">
            <div class="progress-bar" id="preloaderProgress"></div>
        </div>
    </div>

    <div id="map"></div>
    <div id="distanceBox">Initializing...</div>

    <div class="lochunt-container">
        <img id="locationImage" src="" alt="Location Image">
        <div class="lochunt-content">
            <div class="lochunt-info">
                <h2 id="locationTitle" class="mb-2 text-primary"></h2>
                <p id="locationCity" class="text-muted mb-1"></p>
                <p id="locationCreator" class="text-muted mb-3"></p>
            </div>
            <div class="audio-player">
                <div class="audio-progress">
                    <div class="progress">
                        <div id="progressBar" class="progress-bar" role="progressbar" style="width: 0%"></div>
                    </div>
                </div>
                <div class="audio-time">
                    <span id="currentTime">0:00</span>
                    <span id="duration">0:00</span>
                </div>
                <div class="audio-controls">
                    <button id="rewindBtn" class="audio-button"><i class="fas fa-backward"></i></button>
                    <button id="playPauseBtn" class="audio-button"><i class="fas fa-play"></i></button>
                    <button id="forwardBtn" class="audio-button"><i class="fas fa-forward"></i></button>
                </div>
                <audio id="locationAudio" src=""></audio>
            </div>
        </div>
    </div>
    
    <div class="additional-info-container">
       <h3 class="mb-3 text-primary text-center">Did You Know?</h3>
       <p id="additionalInfo" class="mb-3 fs-6"></p>
       <div class="d-flex justify-content-center">
           <button id="continueButton" class="btn btn-primary">Continue</button>
       </div>
    </div>
    
    <div class="map-buttons">
        <button id="recenterButton" class="map-button"><i class="fas fa-crosshairs"></i></button>
        <button id="returnButton" class="map-button"><i class="fas fa-sign-out-alt"></i></button>
        <button id="tipsButton" class="map-button"><i class="fas fa-question-circle"></i></button>
    </div>

    <div class="navigation-tips">
        <button class="close-button">&times;</button>
        <h3>Navigation Tips</h3>
        <ul>
            <li>Use the map to navigate to the marked locations.</li>
            <li>The distance box shows how far you are from the current location.</li>
            <li>Tap the recenter button to focus on your current position.</li>
            <li>When you're within 20 feet of a location, you'll be able to interact with it.</li>
            <li>Listen to the audio information for each location.</li>
            <li>After the audio, you'll see additional information about the location.</li>
        </ul>
    </div>

    <div id="summaryModal" class="modal" style="display: none;">
        <div class="modal-content">
            <p id="summaryContent"></p>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"></script>
    <script src="/locations_test.js?v=1.0.4"></script>

    <script>
// Global variables
let map, userMarker, markerClusterGroup
let currentLocationIndex = 0
const visitedLocations = []
let gameLocations = []
let inactivityTimerId = null
let isLocationHuntVisible = false
let lastPosition = null
let positionBuffer = []
const MAX_BUFFER_SIZE = 30
const DISTANCE_THRESHOLD = 20
const PROXIMITY_THRESHOLD = 40
let velocity = { lat: 0, lng: 0 }
let isMapInteracting = false
let followUser = true
let locationCooldowns = {}
let userIsInteracting = false
const preloadedImages = new Map()
const preloadedAudio = new Map()
let currentSpeed = 0
let lastZoomLevel = 17
let stationaryPositionHistory = []
let deviceOrientation = null
let deviceMotion = null
let orientationPermissionGranted = false
let geolocationSensor = null
let isNearLocation = false
let lastProximityCheck = 0
let isReturningFromExhibit = false

// Constants
const MICRO_MOVEMENT_THRESHOLD = 0.3
const STATIONARY_ACCURACY_MULTIPLIER = 1.2
const MAX_ACCEPTABLE_ACCURACY = 25
const STATIONARY_THRESHOLD = 2
const STATIONARY_TIME_THRESHOLD = 3000
const STATIONARY_CHECK_INTERVAL = 1000
const VELOCITY_DECAY = 0.92
const MIN_DISTANCE_THRESHOLD = 1.0
const EXTENDED_DISTANCE_THRESHOLD = 80
const UPDATE_INTERVAL = 50
const STATIONARY_POSITION_HISTORY_SIZE = 15
const STATIONARY_POSITION_WEIGHT_DECAY = 0.9
const SUDDEN_MOVEMENT_THRESHOLD = 0.8
const POSITION_JUMP_THRESHOLD = 2.0
const ZOOM_CHANGE_COOLDOWN = 1500
const BACKGROUND_THRESHOLD = 15000
const INACTIVITY_TIMEOUT = 30000 // 30 seconds of inactivity
const KALMAN_PROCESS_NOISE = 0.0008
const KALMAN_MEASUREMENT_NOISE_BASE = 1.5
const KALMAN_STATIONARY_NOISE = 0.0002
const ANIMATION_DURATION = 200
const HEADING_SMOOTHING = 0.85
const MAX_ZOOM_LEVEL = 17
const MIN_ZOOM_LEVEL = 13
const WALKING_ZOOM_LEVEL = 17
const WALKING_SPEED_THRESHOLD = 1.5
const RUNNING_SPEED_THRESHOLD = 4.0
const DRIVING_SPEED_THRESHOLD = 10.0
const ZOOM_TRANSITION_DURATION = 0.5
const MOTION_THRESHOLD = 0.8
const MOTION_SAMPLE_SIZE = 15
const MOTION_CHECK_INTERVAL = 200
const EDGE_THRESHOLD_PERCENTAGE = 0.25
const CRITICAL_EDGE_THRESHOLD = 0.125
const RECENTER_COOLDOWN = 1500

// State variables
let lastUpdateTime = null
let lastVelocity = { lat: 0, lng: 0 }
let isStationary = false
let stationaryStartTime = null
let stationaryCheckTimeout = null
let lastUpdateTimestamp = null
let lastHiddenTime = 0
let lastKnownPosition = null
const isTransitioning = false
let lastVisitedLocationId = null
let stationaryCount = 0
let lastSmoothedPosition = null
const lastRecenterTime = Date.now()
let retryCount = 0
const stationaryBuffer = []
const stationaryPosition = null
let isStabilizing = true
let lastStationaryPosition = null
const motionSamples = []
const lastMotionTimestamp = 0
let deviceStationaryTime = 0
let animationFrameId = null
let renderTimestamp = null
const positionUpdateQueue = []
let lastHeadingValue = null
const headingBuffer = []
let isFirstPositionUpdate = true
let lastRenderPosition = null
let positionInterpolator = null
let mapViewportWidth = 0
let mapViewportHeight = 0
let lastMapCenter = null
let lastMapZoom = null
let edgeRecenterInProgress = false
let watchPositionId = null
let isWatchPositionActive = false
let lastVisitTime = 0
const domUpdateScheduled = false
const pendingDomUpdates = new Map()
let usingGeolocationSensorAPI = false
const lockStationaryPosition = false
let positionHistory = []
const lastPositionTimestamp = 0
let suddenMovementCount = 0
let isJumpDetected = false
let stationaryPositionLocked = false
let stationaryPositionLockTime = 0
let lastValidPosition = null
let stationaryLockTimeout = null
const positionStabilityCounter = 0
let lastZoomChangeTime = 0
let lastProximityDistance = Number.POSITIVE_INFINITY

// Kalman Filter implementation
class KalmanFilter {
  constructor() {
    this.x = 0
    this.y = 0
    this.vx = 0
    this.vy = 0
    this.P = [
      [100, 0, 0, 0],
      [0, 100, 0, 0],
      [0, 0, 10, 0],
      [0, 0, 0, 10],
    ]
    this.Q = KALMAN_PROCESS_NOISE
    this.R = KALMAN_MEASUREMENT_NOISE_BASE
    this.dt = 1.0
    this.initialized = false
    this.lastHeading = null
    this.headingConfidence = 0
    this.stationaryMode = false
    this.lastTimestamp = null
    this.adaptiveNoiseMin = 0.0003
    this.adaptiveNoiseMax = 0.003
    this.adaptiveNoiseFactor = 1.0
    this.positionHistory = []
    this.maxPositionHistory = 8
    this.jitterThreshold = 0.4
    this.jitterCount = 0
    this.stationaryLocked = false
    this.stationaryPosition = null
    this.headingSmoothingFactor = 0.85
    this.headingBuffer = []
    this.headingBufferSize = 5
    this.velocitySmoothingFactor = 0.85
    this.velocityBuffer = []
    this.velocityBufferSize = 5
    this.accuracyBuffer = []
    this.accuracyBufferSize = 5
    this.lastAccuracy = Number.POSITIVE_INFINITY
    this.isAccuracyImproving = false
    this.motionDetected = false
    this.motionConfidence = 0
    this.deviceCapabilitiesSet = false
    this.deviceSupportsHighAccuracy = true
    this.deviceSupportsMotionSensors = true
    this.deviceSupportsOrientationSensors = true
  }

  reset(position) {
    if (!position || typeof position.lat !== "number" || typeof position.lng !== "number") {
      console.error("Invalid position for Kalman filter reset")
      return
    }

    this.x = position.lng
    this.y = position.lat
    this.vx = 0
    this.vy = 0
    this.P = [
      [100, 0, 0, 0],
      [0, 100, 0, 0],
      [0, 0, 10, 0],
      [0, 0, 0, 10],
    ]
    this.initialized = true
    this.lastHeading = position.heading || null
    this.headingConfidence = 0
    this.stationaryMode = false
    this.lastTimestamp = position.timestamp || Date.now()
    this.adaptiveNoiseFactor = 1.0
    this.positionHistory = []
    this.jitterCount = 0
    this.stationaryLocked = false
    this.stationaryPosition = null
    this.headingBuffer = []
    this.velocityBuffer = []
    this.accuracyBuffer = []
    this.lastAccuracy = position.accuracy || Number.POSITIVE_INFINITY
    this.isAccuracyImproving = false
    this.motionDetected = false
    this.motionConfidence = 0
  }

  setStationaryMode(isStationary) {
    this.stationaryMode = isStationary

    if (isStationary) {
      this.vx = 0
      this.vy = 0
      this.Q = KALMAN_STATIONARY_NOISE
      this.adaptiveNoiseFactor = 0.03
    } else {
      this.Q = KALMAN_PROCESS_NOISE
      this.adaptiveNoiseFactor = 1.0
      this.stationaryLocked = false
      this.stationaryPosition = null
    }
  }

  lockStationaryPosition(position) {
    if (!this.stationaryMode) return
    this.stationaryLocked = true
    this.stationaryPosition = position
    console.log("Kalman filter: Stationary position locked")
  }

  updateAccuracyBuffer(accuracy) {
    this.accuracyBuffer.push(accuracy)
    while (this.accuracyBuffer.length > this.accuracyBufferSize) {
      this.accuracyBuffer.shift()
    }

    if (this.accuracyBuffer.length >= 3) {
      const avgRecent =
        (this.accuracyBuffer[this.accuracyBuffer.length - 1] + this.accuracyBuffer[this.accuracyBuffer.length - 2]) / 2
      const avgOlder =
        (this.accuracyBuffer[0] + (this.accuracyBuffer.length > 1 ? this.accuracyBuffer[1] : this.accuracyBuffer[0])) /
        2
      this.isAccuracyImproving = avgRecent < avgOlder
    }

    this.lastAccuracy = accuracy
  }

  detectJitter(newPosition) {
    if (this.positionHistory.length === 0) {
      this.positionHistory.push(newPosition)
      return false
    }

    const lastPos = this.positionHistory[this.positionHistory.length - 1]
    const distance = calculateDistance(lastPos, newPosition)

    this.positionHistory.push(newPosition)
    if (this.positionHistory.length > this.maxPositionHistory) {
      this.positionHistory.shift()
    }

    if (this.positionHistory.length >= 3 && this.stationaryMode) {
      const pos1 = this.positionHistory[this.positionHistory.length - 3]
      const pos2 = this.positionHistory[this.positionHistory.length - 2]
      const pos3 = this.positionHistory[this.positionHistory.length - 1]

      const dist1 = calculateDistance(pos1, pos2)
      const dist2 = calculateDistance(pos2, pos3)

      if (
        dist1 < this.jitterThreshold &&
        dist2 < this.jitterThreshold &&
        Math.sign(pos3.lat - pos2.lat) !== Math.sign(pos2.lat - pos1.lat) &&
        Math.sign(pos3.lng - pos2.lng) !== Math.sign(pos2.lng - pos1.lng)
      ) {
        this.jitterCount++
        return this.jitterCount > 1
      }
    }

    if (distance > this.jitterThreshold) {
      this.jitterCount = 0
    }

    return false
  }

  smoothHeading(newHeading) {
    if (newHeading === null || newHeading === undefined) {
      return this.lastHeading
    }

    this.headingBuffer.push(newHeading)
    while (this.headingBuffer.length > this.headingBufferSize) {
      this.headingBuffer.shift()
    }

    if (this.headingBuffer.length < 2) {
      return newHeading
    }

    if (this.headingBuffer.length >= 3) {
      const sortedHeadings = [...this.headingBuffer].sort((a, b) => a - b)
      const medianHeading = sortedHeadings[Math.floor(sortedHeadings.length / 2)]

      const headingDiff = Math.abs(((newHeading - medianHeading + 180) % 360) - 180)
      if (headingDiff > 45 && this.headingConfidence > 0.5) {
        newHeading = medianHeading
      }
    }

    if (this.lastHeading !== null) {
      const normalizedCurrent = ((newHeading % 360) + 360) % 360
      const normalizedLast = ((this.lastHeading % 360) + 360) % 360

      let diff = normalizedCurrent - normalizedLast
      if (diff > 180) diff -= 360
      if (diff < -180) diff += 360

      let headingWeight = this.headingSmoothingFactor
      if (this.stationaryMode) {
        headingWeight = 0.05
      } else if (this.motionDetected) {
        headingWeight = Math.min(0.4, headingWeight * (1 + this.motionConfidence))
      }

      const smoothedHeading = normalizedLast + diff * (1 - headingWeight)
      return ((smoothedHeading % 360) + 360) % 360
    }

    return newHeading
  }

  adjustProcessNoise(accuracy, motionDetected) {
    this.updateAccuracyBuffer(accuracy)
    this.motionDetected = motionDetected
    if (motionDetected) {
      this.motionConfidence = Math.min(1.0, this.motionConfidence + 0.1)
    } else {
      this.motionConfidence = Math.max(0.0, this.motionConfidence - 0.05)
    }

    let noiseLevel =
      this.adaptiveNoiseMin + (this.adaptiveNoiseMax - this.adaptiveNoiseMin) * Math.min(1.0, accuracy / 30.0)

    if (this.stationaryMode) {
      noiseLevel *= 0.03
    }

    if (this.motionDetected && !this.stationaryMode) {
      noiseLevel *= 1.0 + this.motionConfidence
    }

    if (this.isAccuracyImproving) {
      noiseLevel *= 0.9
    } else {
      noiseLevel *= 1.1
    }

    noiseLevel *= this.adaptiveNoiseFactor
    this.Q = noiseLevel
  }

  update(position, motionDetected = false) {
    if (!this.initialized) {
      this.reset(position)
      return position
    }

    if (!position || typeof position.lat !== "number" || typeof position.lng !== "number") {
      console.warn("Invalid position input to Kalman filter")
      return {
        lat: this.y,
        lng: this.x,
        accuracy: position?.accuracy || 20,
        heading: this.lastHeading,
        timestamp: position?.timestamp || Date.now(),
      }
    }

    if (this.stationaryMode && this.stationaryLocked && this.stationaryPosition) {
      return {
        lat: this.stationaryPosition.lat,
        lng: this.stationaryPosition.lng,
        accuracy: position.accuracy,
        heading: this.smoothHeading(position.heading),
        timestamp: position.timestamp,
        speedMPS: 0,
      }
    }

    const timestamp = position.timestamp || Date.now()
    if (this.lastTimestamp) {
      this.dt = Math.min(Math.max((timestamp - this.lastTimestamp) / 1000, 0.01), 1.0)
    }
    this.lastTimestamp = timestamp

    const isJittering = this.detectJitter(position)
    const accuracy = position.accuracy || 20
    this.R = Math.max(KALMAN_MEASUREMENT_NOISE_BASE, accuracy / 5)

    if (this.stationaryMode) {
      this.R *= 5.0
    }

    if (isJittering) {
      this.R *= 10.0
    }

    this.adjustProcessNoise(accuracy, motionDetected)

    const F = [
      [1, 0, this.dt, 0],
      [0, 1, 0, this.dt],
      [0, 0, 1, 0],
      [0, 0, 0, 1],
    ]

    const G = [
      [0.5 * this.dt * this.dt, 0],
      [0, 0.5 * this.dt * this.dt],
      [this.dt, 0],
      [0, this.dt],
    ]

    const H = [
      [1, 0, 0, 0],
      [0, 1, 0, 0],
    ]

    const predictedX = this.x + this.dt * this.vx
    const predictedY = this.y + this.dt * this.vy
    const predictedVx = this.stationaryMode ? 0 : this.vx
    const predictedVy = this.stationaryMode ? 0 : this.vy

    const Q = [
      [(this.Q * this.dt * this.dt * this.dt * this.dt) / 4, 0, (this.Q * this.dt * this.dt * this.dt) / 2, 0],
      [0, (this.Q * this.dt * this.dt * this.dt * this.dt) / 4, 0, (this.Q * this.dt * this.dt * this.dt) / 2],
      [(this.Q * this.dt * this.dt * this.dt) / 2, 0, this.Q * this.dt * this.dt, 0],
      [0, (this.Q * this.dt * this.dt * this.dt) / 2, 0, this.Q * this.dt * this.dt],
    ]

    const FP = [
      [
        this.P[0][0] + this.dt * this.P[2][0],
        this.P[0][1] + this.dt * this.P[2][1],
        this.P[0][2] + this.dt * this.P[2][2],
        this.P[0][3] + this.dt * this.P[2][3],
      ],
      [
        this.P[1][0] + this.dt * this.P[3][0],
        this.P[1][1] + this.dt * this.P[3][1],
        this.P[1][2] + this.dt * this.P[3][2],
        this.P[1][3] + this.dt * this.P[3][3],
      ],
      [this.P[2][0], this.P[2][1], this.P[2][2], this.P[2][3]],
      [this.P[3][0], this.P[3][1], this.P[3][2], this.P[3][3]],
    ]

    const predictedP = [
      [
        FP[0][0] + this.dt * FP[0][2] + Q[0][0],
        FP[0][1] + this.dt * FP[0][3] + Q[0][1],
        FP[0][2] + Q[0][2],
        FP[0][3] + Q[0][3],
      ],
      [
        FP[1][0] + this.dt * FP[1][2] + Q[1][0],
        FP[1][1] + this.dt * FP[1][3] + Q[1][1],
        FP[1][2] + Q[1][2],
        FP[1][3] + Q[1][3],
      ],
      [FP[2][0] + Q[2][0], FP[2][1] + Q[2][1], FP[2][2] + Q[2][2], FP[2][3] + Q[2][3]],
      [FP[3][0] + Q[3][0], FP[3][1] + Q[3][1], FP[3][2] + Q[3][2], FP[3][3] + Q[3][3]],
    ]

    const measurementResidualX = position.lng - predictedX
    const measurementResidualY = position.lat - predictedY

    const S = [
      [predictedP[0][0] + this.R, predictedP[0][1]],
      [predictedP[1][0], predictedP[1][1] + this.R],
    ]

    const detS = S[0][0] * S[1][1] - S[0][1] * S[1][0]
    const invS = [
      [S[1][1] / detS, -S[0][1] / detS],
      [-S[1][0] / detS, S[0][0] / detS],
    ]

    const K = [
      [
        predictedP[0][0] * invS[0][0] + predictedP[0][1] * invS[1][0],
        predictedP[0][0] * invS[0][1] + predictedP[0][1] * invS[1][1],
      ],
      [
        predictedP[1][0] * invS[0][0] + predictedP[1][1] * invS[1][0],
        predictedP[1][0] * invS[0][1] + predictedP[1][1] * invS[1][1],
      ],
      [
        predictedP[2][0] * invS[0][0] + predictedP[2][1] * invS[1][0],
        predictedP[2][0] * invS[0][1] + predictedP[2][1] * invS[1][1],
      ],
      [
        predictedP[3][0] * invS[0][0] + predictedP[3][1] * invS[1][0],
        predictedP[3][0] * invS[0][1] + predictedP[3][1] * invS[1][1],
      ],
    ]

    this.x = predictedX + K[0][0] * measurementResidualX + K[0][1] * measurementResidualY
    this.y = predictedY + K[1][0] * measurementResidualX + K[1][1] * measurementResidualY

    if (this.stationaryMode) {
      this.vx = 0
      this.vy = 0
    } else {
      this.vx = predictedVx + K[2][0] * measurementResidualX + K[2][1] * measurementResidualY
      this.vy = predictedVy + K[3][0] * measurementResidualX + K[3][1] * measurementResidualY
    }

    this.P = [
      [
        predictedP[0][0] - (K[0][0] * predictedP[0][0] + K[0][1] * predictedP[1][0]),
        predictedP[0][1] - (K[0][0] * predictedP[0][1] + K[0][1] * predictedP[1][1]),
        predictedP[0][2] - (K[0][0] * predictedP[0][2] + K[0][1] * predictedP[1][2]),
        predictedP[0][3] - (K[0][0] * predictedP[0][3] + K[0][1] * predictedP[1][3]),
      ],
      [
        predictedP[1][0] - (K[1][0] * predictedP[0][0] + K[1][1] * predictedP[1][0]),
        predictedP[1][1] - (K[1][0] * predictedP[0][1] + K[1][1] * predictedP[1][1]),
        predictedP[1][2] - (K[1][0] * predictedP[0][2] + K[1][1] * predictedP[1][2]),
        predictedP[1][3] - (K[1][0] * predictedP[0][3] + K[1][1] * predictedP[1][3]),
      ],
      [
        predictedP[2][0] - (K[2][0] * predictedP[0][0] + K[2][1] * predictedP[1][0]),
        predictedP[2][1] - (K[2][0] * predictedP[0][1] + K[2][1] * predictedP[1][1]),
        predictedP[2][2] - (K[2][0] * predictedP[0][2] + K[2][1] * predictedP[1][2]),
        predictedP[2][3] - (K[2][0] * predictedP[0][3] + K[2][1] * predictedP[1][3]),
      ],
      [
        predictedP[3][0] - (K[3][0] * predictedP[0][0] + K[3][1] * predictedP[1][0]),
        predictedP[3][1] - (K[3][0] * predictedP[0][1] + K[3][1] * predictedP[1][1]),
        predictedP[3][2] - (K[3][0] * predictedP[0][2] + K[3][1] * predictedP[1][2]),
        predictedP[3][3] - (K[3][0] * predictedP[0][3] + K[3][1] * predictedP[1][3]),
      ],
    ]

    const smoothedHeading = this.smoothHeading(position.heading)
    this.lastHeading = smoothedHeading
    const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy)

    const filteredPosition = {
      lat: this.y,
      lng: this.x,
      accuracy: position.accuracy,
      heading: smoothedHeading,
      timestamp: position.timestamp,
      speedMPS: this.stationaryMode ? 0 : speed * 111000,
    }

    if (this.stationaryMode && !this.stationaryLocked && stationaryStartTime) {
      if (Date.now() - stationaryStartTime > 2000) {
        this.lockStationaryPosition(filteredPosition)
      }
    }

    return filteredPosition
  }
}

// Position Interpolator implementation
class PositionInterpolator {
  constructor() {
    this.startPosition = null
    this.targetPosition = null
    this.startTime = null
    this.duration = 0
    this.isActive = false
    this.lastInterpolatedPosition = null
  }

  start(startPos, targetPos, duration) {
    if (!startPos || !targetPos) return

    this.startPosition = { ...startPos }
    this.targetPosition = { ...targetPos }
    this.startTime = performance.now()
    this.duration = duration
    this.isActive = true
  }

  update() {
    if (!this.isActive) return null

    const now = performance.now()
    const elapsed = now - this.startTime

    if (elapsed >= this.duration) {
      this.isActive = false
      this.lastInterpolatedPosition = this.targetPosition
      return this.targetPosition
    }

    const t = elapsed / this.duration
    const easedT = this.easeOutCubic(t)

    const interpolatedPosition = {
      lat: this.startPosition.lat + (this.targetPosition.lat - this.startPosition.lat) * easedT,
      lng: this.startPosition.lng + (this.targetPosition.lng - this.startPosition.lng) * easedT,
      accuracy: this.targetPosition.accuracy,
      heading: this.targetPosition.heading,
      timestamp: now,
      speedMPS: this.targetPosition.speedMPS,
    }

    this.lastInterpolatedPosition = interpolatedPosition
    return interpolatedPosition
  }

  easeOutCubic(t) {
    return 1 - Math.pow(1 - t, 3)
  }

  isInterpolating() {
    return this.isActive
  }

  cancel() {
    this.isActive = false
  }

  getLastPosition() {
    return this.lastInterpolatedPosition || this.targetPosition || this.startPosition
  }
}

// Create Kalman filter and position interpolator instances
const kalmanFilter = new KalmanFilter()
positionInterpolator = new PositionInterpolator()

// DOM update manager
const domUpdateManager = {
  updates: new Map(),
  scheduled: false,

  schedule(id, updateFn) {
    this.updates.set(id, updateFn)
    if (!this.scheduled) {
      this.scheduled = true
      requestAnimationFrame(() => this.flush())
    }
  },

  flush() {
    this.updates.forEach((updateFn) => updateFn())
    this.updates.clear()
    this.scheduled = false
  },
}

// Helper functions
function calculateDistance(pos1, pos2) {
  if (
    !pos1 ||
    !pos2 ||
    typeof pos1.lat !== "number" ||
    typeof pos1.lng !== "number" ||
    typeof pos2.lat !== "number" ||
    typeof pos2.lng !== "number"
  ) {
    return Number.POSITIVE_INFINITY
  }

  const R = 6371000
  const lat1 = (pos1.lat * Math.PI) / 180
  const lat2 = (pos2.lat * Math.PI) / 180
  const deltaLat = ((pos2.lat - pos1.lat) * Math.PI) / 180
  const deltaLng = ((pos2.lng - pos1.lng) * Math.PI) / 180

  const a =
    Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) +
    Math.cos(lat1) * Math.cos(lat2) * Math.sin(deltaLng / 2) * Math.sin(deltaLng / 2)
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))

  return R * c
}

function lerp(a, b, t) {
  if (typeof a !== "number" || typeof b !== "number" || typeof t !== "number") {
    return a
  }
  return a + (b - a) * Math.max(0, Math.min(1, t))
}

function updatePositionBuffer(position) {
  if (!position || typeof position.lat !== "number" || typeof position.lng !== "number") {
    return
  }

  positionBuffer.push({
    lat: position.lat,
    lng: position.lng,
    accuracy: position.accuracy,
    heading: position.heading,
    timestamp: position.timestamp,
    speedMPS: position.speedMPS,
  })

  while (positionBuffer.length > MAX_BUFFER_SIZE) {
    positionBuffer.shift()
  }
}

function updatePositionHistory(position) {
  if (!position || typeof position.lat !== "number" || typeof position.lng !== "number") {
    return
  }

  positionHistory.push({
    lat: position.lat,
    lng: position.lng,
    accuracy: position.accuracy,
    heading: position.heading,
    timestamp: position.timestamp,
    speedMPS: position.speedMPS,
  })

  while (positionHistory.length > 10) {
    positionHistory.shift()
  }
}

function calculateStationaryPosition(buffer) {
  if (!buffer || buffer.length === 0) {
    return null
  }

  const sortedBuffer = [...buffer].sort((a, b) => a.accuracy - b.accuracy)
  const topPositions = sortedBuffer.slice(0, Math.ceil(buffer.length / 2))
  const weights = topPositions.map((pos) => 1 / Math.max(1, pos.accuracy))
  const totalWeight = weights.reduce((sum, w) => sum + w, 0)

  if (totalWeight === 0) {
    return sortedBuffer[0]
  }

  const avgPosition = {
    lat: topPositions.reduce((sum, pos, i) => sum + pos.lat * weights[i], 0) / totalWeight,
    lng: topPositions.reduce((sum, pos, i) => sum + pos.lng * weights[i], 0) / totalWeight,
    accuracy: topPositions[0].accuracy,
    heading: topPositions[0].heading,
    timestamp: Date.now(),
    speedMPS: 0,
  }

  if (lastStationaryPosition) {
    const blendFactor = 0.9
    return {
      lat: lastStationaryPosition.lat * blendFactor + avgPosition.lat * (1 - blendFactor),
      lng: lastStationaryPosition.lng * blendFactor + avgPosition.lng * (1 - blendFactor),
      accuracy: avgPosition.accuracy,
      heading: avgPosition.heading,
      timestamp: avgPosition.timestamp,
      speedMPS: 0,
    }
  }

  return avgPosition
}

function updateStationaryHistory(position) {
  stationaryPositionHistory.push(position)
  while (stationaryPositionHistory.length > STATIONARY_POSITION_HISTORY_SIZE) {
    stationaryPositionHistory.shift()
  }

  let totalWeight = 0
  let weightedLat = 0
  let weightedLng = 0

  for (let i = 0; i < stationaryPositionHistory.length; i++) {
    const pos = stationaryPositionHistory[i]
    const weight = Math.pow(STATIONARY_POSITION_WEIGHT_DECAY, stationaryPositionHistory.length - i - 1)
    totalWeight += weight
    weightedLat += pos.lat * weight
    weightedLng += pos.lng * weight
  }

  return {
    lat: weightedLat / totalWeight,
    lng: weightedLng / totalWeight,
    accuracy: position.accuracy,
    heading: position.heading,
    timestamp: position.timestamp,
    speedMPS: 0,
  }
}

function isDeviceInMotion() {
  if (!motionSamples || motionSamples.length < 3) {
    return false
  }

  const avgMotion =
    motionSamples.reduce((sum, sample) => {
      return sum + Math.sqrt(sample.x * sample.x + sample.y * sample.y + sample.z * sample.z)
    }, 0) / motionSamples.length

  return avgMotion > MOTION_THRESHOLD
}

function handleDeviceMotion(event) {
  if (!event || !event.acceleration) return

  const motion = {
    x: event.acceleration.x || 0,
    y: event.acceleration.y || 0,
    z: event.acceleration.z || 0,
    timestamp: Date.now(),
  }

  motionSamples.push(motion)
  while (motionSamples.length > MOTION_SAMPLE_SIZE) {
    motionSamples.shift()
  }

  deviceMotion = motion
  const inMotion = isDeviceInMotion()

  if (!inMotion) {
    deviceStationaryTime += MOTION_CHECK_INTERVAL
  } else {
    deviceStationaryTime = 0
  }
}

function handleDeviceOrientation(event) {
  if (!event || event.alpha === null) return

  deviceOrientation = {
    alpha: event.alpha,
    beta: event.beta,
    gamma: event.gamma,
    timestamp: Date.now(),
  }

  if (event.webkitCompassHeading !== undefined) {
    const heading = event.webkitCompassHeading
    headingBuffer.push(heading)
    while (headingBuffer.length > 5) {
      headingBuffer.shift()
    }

    if (headingBuffer.length >= 3) {
      const sortedHeadings = [...headingBuffer].sort((a, b) => a - b)
      lastHeadingValue = sortedHeadings[Math.floor(sortedHeadings.length / 2)]
    }
  }
}

function requestMotionPermission() {
  if (typeof DeviceMotionEvent !== "undefined" && typeof DeviceMotionEvent.requestPermission === "function") {
    DeviceMotionEvent.requestPermission()
      .then((response) => {
        if (response === "granted") {
          window.addEventListener("devicemotion", handleDeviceMotion, true)
        }
      })
      .catch(console.error)
  } else {
    window.addEventListener("devicemotion", handleDeviceMotion, true)
  }

  if (typeof DeviceOrientationEvent !== "undefined" && typeof DeviceOrientationEvent.requestPermission === "function") {
    DeviceOrientationEvent.requestPermission()
      .then((response) => {
        if (response === "granted") {
          orientationPermissionGranted = true
          window.addEventListener("deviceorientation", handleDeviceOrientation, true)
        }
      })
      .catch(console.error)
  } else {
    window.addEventListener("deviceorientation", handleDeviceOrientation, true)
    orientationPermissionGranted = true
  }
}

function detectSuddenMovement(newPosition, lastPosition) {
  if (!lastPosition || !newPosition) return false

  const distance = calculateDistance(lastPosition, newPosition)
  const timeDelta = (newPosition.timestamp - lastPosition.timestamp) / 1000

  if (timeDelta < 0.05) return false

  const speed = distance / timeDelta

  if (speed > 40) {
    console.log(`Position jump detected: ${distance.toFixed(2)}m in ${timeDelta.toFixed(2)}s (${speed.toFixed(2)} m/s)`)
    return true
  }

  if (isStationary && distance > POSITION_JUMP_THRESHOLD) {
    console.log(`Sudden movement detected while stationary: ${distance.toFixed(2)}m`)
    return true
  }

  if (isStationary && distance > SUDDEN_MOVEMENT_THRESHOLD) {
    suddenMovementCount++
    if (suddenMovementCount >= 2) {
      console.log(`Multiple sudden movements detected: ${distance.toFixed(2)}m`)
      return true
    }
  } else {
    suddenMovementCount = 0
  }

  return false
}

function isMarkerNearEdge(map, marker, isStrict = false) {
  if (!map || !marker) return { isNearEdge: false }

  const bounds = map.getBounds()
  const point = marker.getLatLng()
  const latSpan = bounds.getNorth() - bounds.getSouth()
  const lngSpan = bounds.getEast() - bounds.getWest()

  const proximities = {
    north: Math.abs(point.lat - bounds.getNorth()) / latSpan,
    south: Math.abs(point.lat - bounds.getSouth()) / latSpan,
    east: Math.abs(point.lng - bounds.getEast()) / lngSpan,
    west: Math.abs(point.lng - bounds.getWest()) / lngSpan,
  }

  const thresholdPercentage = isStrict ? 0.12 : EDGE_THRESHOLD_PERCENTAGE

  const edges = {
    north: proximities.north < thresholdPercentage,
    south: proximities.south < thresholdPercentage,
    east: proximities.east < thresholdPercentage,
    west: proximities.west < thresholdPercentage,
  }

  return {
    isNearEdge: Object.values(edges).some((edge) => edge),
    edges: edges,
    proximities: proximities,
  }
}

function calculateOptimalCenter(map, markerPosition, edgeInfo) {
  const bounds = map.getBounds()
  const viewportWidth = mapViewportWidth || map._container.clientWidth
  const viewportHeight = mapViewportHeight || map._container.clientHeight
  const aspectRatio = viewportWidth / viewportHeight
  const latSpan = bounds.getNorth() - bounds.getSouth()
  const lngSpan = bounds.getEast() - bounds.getWest()

  let latOffset = 0
  let lngOffset = 0
  const edges = edgeInfo.edges

  if (edges.north) {
    latOffset = -1 * latSpan * 0.25 * (1 / aspectRatio)
  }
  if (edges.south) {
    latOffset = latSpan * 0.25 * (1 / aspectRatio)
  }
  if (edges.east) {
    lngOffset = -1 * lngSpan * 0.25 * aspectRatio
  }
  if (edges.west) {
    lngOffset = lngSpan * 0.25 * aspectRatio
  }

  const proximities = edgeInfo.proximities
  const minProximity = Math.min(
    edges.north ? proximities.north : 1,
    edges.south ? proximities.south : 1,
    edges.east ? proximities.east : 1,
    edges.west ? proximities.west : 1,
  )

  if (minProximity === proximities.north && edges.north) {
    latOffset *= 1.5
  } else if (minProximity === proximities.south && edges.south) {
    latOffset *= 1.5
  } else if (minProximity === proximities.east && edges.east) {
    lngOffset *= 1.5
  } else if (minProximity === proximities.west && edges.west) {
    lngOffset *= 1.5
  }

  return {
    lat: markerPosition.lat + latOffset,
    lng: markerPosition.lng + lngOffset,
  }
}

function predictPositionFromHeading(position, heading, distance) {
  if (
    !position ||
    typeof heading !== "number" ||
    typeof distance !== "number" ||
    !position.lat ||
    !position.lng ||
    isNaN(heading) ||
    isNaN(distance)
  ) {
    return position
  }

  heading = ((heading % 360) + 360) % 360
  const R = 6371e3
  const d = distance / R
  const θ = (heading * Math.PI) / 180
  const φ1 = (position.lat * Math.PI) / 180
  const λ1 = (position.lng * Math.PI) / 180

  try {
    const sinφ1 = Math.sin(φ1)
    const cosφ1 = Math.cos(φ1)
    const cosd = Math.cos(d)
    const sind = Math.sin(d)
    const cosθ = Math.cos(θ)

    const φ2 = Math.asin(sinφ1 * cosd + cosφ1 * sind * cosθ)
    const λ2 = λ1 + Math.atan2(Math.sin(θ) * sind * cosφ1, cosd - sinφ1 * Math.sin(φ2))

    const newLat = Math.max(-90, Math.min(90, (φ2 * 180) / Math.PI))
    const newLng = (((λ2 * 180) / Math.PI + 540) % 360) - 180

    return {
      lat: newLat,
      lng: newLng,
    }
  } catch (error) {
    return position
  }
}

function checkStationaryState(newPosition) {
  if (!lastPosition) return

  const distance = calculateDistance(lastPosition, newPosition)
  const motionDetected = isDeviceInMotion()

  if (distance >= MICRO_MOVEMENT_THRESHOLD || motionDetected) {
    if (isStationary) {
      console.debug("Movement detected, transitioning to moving state")
      isStationary = false
      stationaryStartTime = null
      stationaryPositionLocked = false
      stationaryCount = 0
      kalmanFilter.setStationaryMode(false)

      if (stationaryLockTimeout) {
        clearTimeout(stationaryLockTimeout)
        stationaryLockTimeout = null
      }
    }

    if (stationaryCheckTimeout) {
      clearTimeout(stationaryCheckTimeout)
      stationaryCheckTimeout = null
    }
  } else {
    stationaryCount++

    if (!isStationary && stationaryCount >= STATIONARY_THRESHOLD) {
      console.debug("User is now stationary")
      isStationary = true
      stationaryStartTime = Date.now()
      kalmanFilter.setStationaryMode(true)

      const stablePosition = calculateStationaryPosition(positionBuffer)
      if (stablePosition) {
        lastStationaryPosition = stablePosition

        if (stationaryLockTimeout) {
          clearTimeout(stationaryLockTimeout)
        }

        stationaryLockTimeout = setTimeout(() => {
          stationaryPositionLocked = true
          stationaryPositionLockTime = Date.now()
          console.log("Stationary position locked after delay")
          kalmanFilter.lockStationaryPosition(lastStationaryPosition)
        }, 2000)
      }
    }

    if (isStationary && !stationaryCheckTimeout) {
      stationaryCheckTimeout = setTimeout(() => {
        stationaryCheckTimeout = null
        checkStationaryState(newPosition)
      }, STATIONARY_CHECK_INTERVAL)
    }
  }
}

// UI Functions
function showLoadingMessage() {
  const loadingMessage = document.createElement("div")
  loadingMessage.id = "loadingMessage"
  loadingMessage.style.cssText = `
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: rgba(255, 255, 255, 0.9);
    padding: 20px;
    border-radius: 10px;
    z-index: 1000;
    text-align: center;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
  `
  loadingMessage.innerHTML = `
    <div style="margin-bottom: 15px;">
      <div style="width: 40px; height: 40px; border: 4px solid rgba(255, 0, 0, 0.2); border-top: 4px solid #ff0000; border-radius: 50%; margin: 0 auto 15px; animation: spin 1s linear infinite;"></div>
    </div>
    <p style="font-weight: 500; color: #333;">Searching for your location...</p>
  `
  document.body.appendChild(loadingMessage)
}

function hideLoadingMessage() {
  const loadingMessage = document.getElementById("loadingMessage")
  if (loadingMessage) {
    document.body.removeChild(loadingMessage)
  }
}

function showStabilizingModal() {
  const modal = document.createElement("div")
  modal.id = "stabilizingModal"
  modal.className = "stabilizing-modal"
  modal.innerHTML = `
    <div class="spinner"></div>
    <h3>Stabilizing Your Location</h3>
    <p>Please wait while we fine-tune your position.</p>
  `
  document.body.appendChild(modal)

  setTimeout(() => {
    const stabilizingModal = document.getElementById("stabilizingModal")
    if (stabilizingModal) {
      stabilizingModal.style.opacity = "0"
      stabilizingModal.style.transition = "opacity 0.5s ease"
      setTimeout(() => {
        if (stabilizingModal && stabilizingModal.parentNode) {
          stabilizingModal.parentNode.removeChild(stabilizingModal)
        }
        isStabilizing = false
      }, 500)
    }
  }, 3000)
}

function showPopup(title, message, type = "info", callback = null) {
  const popup = document.createElement("div")
  popup.classList.add("popup")
  popup.style.cssText = `
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: white;
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    z-index: 2000;
    text-align: center;
    max-width: 80%;
  `

  const titleElement = document.createElement("h3")
  titleElement.textContent = title
  titleElement.style.cssText = `
    margin-bottom: 10px;
    font-size: 18px;
    font-weight: bold;
  `

  const messageElement = document.createElement("p")
  messageElement.textContent = message
  messageElement.style.cssText = `
    margin-bottom: 20px;
    font-size: 16px;
  `

  const buttonContainer = document.createElement("div")
  buttonContainer.style.cssText = `
    display: flex;
    justify-content: center;
    gap: 10px;
  `

  const okButton = document.createElement("button")
  okButton.textContent = "OK"
  okButton.style.cssText = `
    padding: 10px 20px;
    background-color: #0f2bab;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
  `

  okButton.addEventListener("click", () => {
    document.body.removeChild(popup)
    if (callback) callback()
  })

  buttonContainer.appendChild(okButton)

  if (type === "info") {
    const cancelButton = document.createElement("button")
    cancelButton.textContent = "Cancel"
    cancelButton.style.cssText = `
      padding: 10px 20px;
      background-color: #ccc;
      color: black;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    `

    cancelButton.addEventListener("click", () => {
      document.body.removeChild(popup)
    })

    buttonContainer.appendChild(cancelButton)
  }

  popup.appendChild(titleElement)
  popup.appendChild(messageElement)
  popup.appendChild(buttonContainer)
  document.body.appendChild(popup)
}

// Check proximity to locations and adjust zoom accordingly
function checkLocationProximity() {
  const now = Date.now()

  // Don't check too frequently
  if (now - lastProximityCheck < 1000) return
  lastProximityCheck = now

  // Don't check if zoom was recently changed
  if (now - lastZoomChangeTime < ZOOM_CHANGE_COOLDOWN) return

  if (!userMarker || !gameLocations || gameLocations.length === 0) return

  const userLatLng = userMarker.getLatLng()
  const userPos = { lat: userLatLng.lat, lng: userLatLng.lng }

  // Find closest location
  let closestDistance = Number.POSITIVE_INFINITY
  let closestLocation = null

  for (const location of gameLocations) {
    if (!location || typeof location.lat !== "number" || typeof location.lng !== "number") continue

    const locationPos = { lat: location.lat, lng: location.lng }
    const distance = calculateDistance(userPos, locationPos)

    if (isFinite(distance) && distance < closestDistance) {
      closestDistance = distance
      closestLocation = location
    }
  }

  // Convert to feet for threshold comparison
  const distanceFeet = Math.round(closestDistance * 3.28084)

  // Check if we need to adjust zoom based on proximity
  if (distanceFeet <= PROXIMITY_THRESHOLD) {
    // If we weren't near a location before, zoom in
    if (!isNearLocation && Math.abs(lastProximityDistance - closestDistance) > 1) {
      console.log(`User is now within ${PROXIMITY_THRESHOLD} feet of a location, zooming in`)
      isNearLocation = true
      lastZoomChangeTime = now

      // Get current zoom and zoom in by 1 level
      const currentZoom = map.getZoom()
      const newZoom = Math.min(currentZoom + 1, MAX_ZOOM_LEVEL)

      map.setZoom(newZoom, {
        animate: true,
        duration: ZOOM_TRANSITION_DURATION,
      })
    }
  } else if (isNearLocation && distanceFeet > PROXIMITY_THRESHOLD + 10) {
    // If we were near a location but now we're not, zoom out
    console.log(`User is now outside ${PROXIMITY_THRESHOLD} feet of a location, zooming out`)
    isNearLocation = false
    lastZoomChangeTime = now

    // Get current zoom and zoom out by 1 level
    const currentZoom = map.getZoom()
    const newZoom = Math.max(currentZoom - 1, MIN_ZOOM_LEVEL)

    map.setZoom(newZoom, {
      animate: true,
      duration: ZOOM_TRANSITION_DURATION,
    })
  }

  // Update last proximity distance
  lastProximityDistance = closestDistance
}

// Perform edge recentering when user approaches map edge
function performEdgeRecenter(recenterInfo) {
  if (edgeRecenterInProgress) return

  edgeRecenterInProgress = true
  const markerPosition = userMarker.getLatLng()
  const optimalCenter = calculateOptimalCenter(map, markerPosition, recenterInfo.edgeInfo)

  map.panTo(optimalCenter, {
    animate: true,
    duration: 0.5,
    easeLinearity: 0.5,
    noMoveStart: true,
  })

  setTimeout(() => {
    edgeRecenterInProgress = false
  }, 600)
}

// Core Functions
function initMap() {
  map = L.map("map", {
    zoomControl: false,
    attributionControl: false,
    zoomSnap: 0.1,
    zoomDelta: 0.5,
    wheelDebounceTime: 100,
    tapTolerance: 15,
    bounceAtZoomLimits: false,
    preferCanvas: true,
    renderer: L.canvas({ padding: 0.5 }),
  }).fitWorld()

  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    maxZoom: 17,
    attribution: "© OpenStreetMap contributors",
    updateWhenIdle: true,
    updateWhenZooming: false,
    keepBuffer: 2,
  }).addTo(map)

  markerClusterGroup = L.markerClusterGroup({
    showCoverageOnHover: false,
    zoomToBoundsOnClick: true,
    spiderfyOnMaxZoom: true,
    animate: true,
    animateAddingMarkers: true,
    disableClusteringAtZoom: 17,
    maxClusterRadius: 60,
    iconCreateFunction: (cluster) =>
      L.divIcon({
        html: `<div><span>${cluster.getChildCount()}</span></div>`,
        className: "marker-cluster-custom",
        iconSize: L.point(40, 40),
      }),
  })
  map.addLayer(markerClusterGroup)

  const userIcon = L.divIcon({
    className: "user-marker",
    html: '<div class="user-marker-icon"></div>',
    iconSize: [20, 20],
    iconAnchor: [10, 10],
  })
  userMarker = L.marker([0, 0], {
    icon: userIcon,
    zIndexOffset: 1000,
    interactive: false,
  }).addTo(map)

  updateMapViewportDimensions()
  showLoadingMessage()
  requestMotionPermission()
  initGeolocation()

  document.addEventListener("visibilitychange", handleVisibilityChange)

  map.on("movestart zoomstart", () => {
    followUser = false
    isMapInteracting = true
    resetInactivityTimer()
  })

  map.on("moveend zoomend", () => {
    isMapInteracting = false
    resetInactivityTimer()
    updateMapViewportDimensions()
  })

  window.addEventListener("resize", updateMapViewportDimensions)
  startAnimationLoop()
  map.touchZoom.enable()
  map.doubleClickZoom.enable()
}

function initGeolocation() {
  if ("GeolocationSensor" in window) {
    try {
      console.log("Trying GeolocationSensor API")
      geolocationSensor = new GeolocationSensor({ frequency: 1 })

      geolocationSensor.addEventListener("reading", () => {
        const position = {
          coords: {
            latitude: geolocationSensor.latitude,
            longitude: geolocationSensor.longitude,
            accuracy: geolocationSensor.accuracy,
            altitude: geolocationSensor.altitude,
            altitudeAccuracy: geolocationSensor.altitudeAccuracy,
            heading: geolocationSensor.heading,
            speed: geolocationSensor.speed,
          },
          timestamp: geolocationSensor.timestamp,
        }

        if (!lastPosition) {
          initializeUserLocation(position)
        } else {
          handlePositionUpdate(position)
        }
      })

      geolocationSensor.addEventListener("error", (error) => {
        console.warn("GeolocationSensor error:", error)
        useStandardGeolocation()
      })

      geolocationSensor.start()
      usingGeolocationSensorAPI = true
      console.log("Using GeolocationSensor API")
    } catch (error) {
      console.warn("GeolocationSensor error:", error)
      useStandardGeolocation()
    }
  } else {
    useStandardGeolocation()
  }
}

function useStandardGeolocation() {
  console.log("Using standard Geolocation API")
  usingGeolocationSensorAPI = false

  if ("geolocation" in navigator) {
    const options = {
      enableHighAccuracy: true,
      timeout: 30000,
      maximumAge: 0,
    }

    navigator.geolocation.getCurrentPosition(
      initializeUserLocation,
      (error) => {
        navigator.geolocation.getCurrentPosition(initializeUserLocation, handleLocationError, options)
      },
      options,
    )
  } else {
    showPopup("Geolocation is not supported by your browser")
    map.setView([44.9778, -93.265], 17)
    hideLoadingMessage()
  }
}

function startPositionUpdates() {
  if (usingGeolocationSensorAPI) {
    console.log("Position updates already using GeolocationSensor API")
    return
  }

  watchPositionId = navigator.geolocation.watchPosition(handlePositionUpdate, handleLocationError, {
    enableHighAccuracy: true,
    maximumAge: 0,
    timeout: 10000,
  })
  isWatchPositionActive = true
  console.log("Position updates using standard Geolocation API")
}

function initializeUserLocation(position) {
  console.log("Initial position data:", JSON.stringify(position))

  if (!position || !position.coords) {
    console.error("Invalid initial position object")
    handleLocationError(new Error("Invalid initial position"))
    return
  }

  const { latitude: userLat, longitude: userLng, accuracy } = position.coords

  if (isNaN(userLat) || isNaN(userLng)) {
    console.error("Invalid initial coordinates:", { userLat, userLng })
    handleLocationError(new Error("Invalid initial coordinates"))
    return
  }

  console.log("Valid initial position:", { userLat, userLng, accuracy })

  try {
    userMarker.setLatLng([userLat, userLng])
    map.setView([userLat, userLng], 17)

    kalmanFilter.reset({
      lat: userLat,
      lng: userLng,
      accuracy: accuracy,
      heading: position.coords.heading,
      timestamp: Date.now(),
    })

    lastStationaryPosition = {
      lat: userLat,
      lng: userLng,
      accuracy: accuracy,
      heading: position.coords.heading,
      timestamp: Date.now(),
      speedMPS: 0,
    }

    lastRenderPosition = {
      lat: userLat,
      lng: userLng,
      accuracy: accuracy,
      heading: position.coords.heading,
      timestamp: Date.now(),
      speedMPS: 0,
    }

    lastValidPosition = {
      lat: userLat,
      lng: userLng,
      accuracy: accuracy,
      heading: position.coords.heading,
      timestamp: Date.now(),
      speedMPS: 0,
    }

    hideLoadingMessage()
    showStabilizingModal()
    startPositionUpdates()
    startHunt()
  } catch (error) {
    console.error("Error setting initial user location:", error)
    handleLocationError(error)
  }
}

function handlePositionUpdate(position) {
  if (!position?.coords?.latitude || !position?.coords?.longitude) {
    console.warn("Invalid position data received")
    return
  }
  updateUserLocation(position)
}

function handleVisibilityChange() {
  if (document.hidden) {
    lastHiddenTime = Date.now()
    lastKnownPosition = userMarker ? userMarker.getLatLng() : null

    if (positionInterpolator) {
      positionInterpolator.cancel()
    }

    if (animationFrameId) {
      cancelAnimationFrame(animationFrameId)
      animationFrameId = null
    }

    if (usingGeolocationSensorAPI && geolocationSensor) {
      geolocationSensor.stop()
    }
  } else {
    const hiddenDuration = Date.now() - lastHiddenTime
    if (hiddenDuration > BACKGROUND_THRESHOLD) {
      updateLocationAfterBackground()
    } else {
      map.invalidateSize()

      if (!animationFrameId) {
        startAnimationLoop()
      }

      if (usingGeolocationSensorAPI && geolocationSensor) {
        geolocationSensor.start()
      }

      if (isReturningFromExhibit) {
        isReturningFromExhibit = false
        if (lastValidPosition) {
          updateUserLocation(
            {
              coords: {
                latitude: lastValidPosition.lat,
                longitude: lastValidPosition.lng,
                accuracy: lastValidPosition.accuracy,
                heading: lastValidPosition.heading,
                speed: lastValidPosition.speedMPS,
              },
              timestamp: Date.now(),
            },
            true,
          )
        }
      }
    }
  }
  resetInactivityTimer()
}

function updateLocationAfterBackground() {
  if ("geolocation" in navigator) {
    navigator.geolocation.getCurrentPosition(
      (position) => {
        console.log("Background update raw position:", JSON.stringify(position))
        if (!position || !position.coords) {
          console.warn("Invalid position object in background update")
          return
        }
        const { latitude, longitude, accuracy } = position.coords
        if (isNaN(latitude) || isNaN(longitude)) {
          console.warn("Invalid coordinates in background update:", { latitude, longitude })
          return
        }

        console.log("Valid background position update:", { lat: latitude, lng: longitude })
        try {
          updateUserLocation(position, true)
        } catch (error) {
          console.error("Error in updateUserLocation during background update:", error)
        }

        lastPosition = null
        positionBuffer = []
        velocity = { lat: 0, lng: 0 }
        lastVelocity = { lat: 0, lng: 0 }
        isStationary = false
        stationaryStartTime = null
        stationaryCount = 0
        stationaryPositionHistory = []
        lastStationaryPosition = null
        stationaryPositionLocked = false
        positionHistory = []
        suddenMovementCount = 0
        isJumpDetected = false

        kalmanFilter.reset({
          lat: latitude,
          lng: longitude,
          accuracy: accuracy,
          heading: position.coords.heading,
          timestamp: Date.now(),
        })

        if (!animationFrameId) {
          startAnimationLoop()
        }

        if (usingGeolocationSensorAPI && geolocationSensor) {
          geolocationSensor.start()
        }

        updateDistanceBox()
        followUser = true
        map.invalidateSize()
      },
      (error) => {
        console.error("Error getting location after background:", error)
        if (error.code === 3) {
          navigator.geolocation.getCurrentPosition(
            (position) => {
              console.log("Retry successful with lower accuracy")
              updateUserLocation(position, true)
            },
            (error) => console.error("Error on retry:", error),
            {
              enableHighAccuracy: false,
              timeout: 20000,
              maximumAge: 30000,
            },
          )
        }
      },
      {
        enableHighAccuracy: true,
        timeout: 10000,
        maximumAge: 0,
      },
    )
  } else {
    console.warn("Geolocation is not available")
  }
}

function updateUserLocation(position, forceUpdate = false) {
  if (!position?.coords?.latitude || !position?.coords?.longitude) {
    console.warn("Invalid position data received")
    return
  }

  const currentTime = Date.now()
  const timeDelta = lastUpdateTime ? (currentTime - lastUpdateTime) / 1000 : 0

  const newPosition = {
    lat: position.coords.latitude,
    lng: position.coords.longitude,
    accuracy: position.coords.accuracy || 20,
    heading: position.coords.heading !== null ? position.coords.heading : lastHeadingValue || undefined,
    timestamp: currentTime,
    speedMPS: position.coords.speed !== null ? position.coords.speed : 0,
  }

  if (!lastPosition) {
    lastPosition = newPosition
    lastValidPosition = newPosition
    userMarker.setLatLng([newPosition.lat, newPosition.lng])
    kalmanFilter.reset(newPosition)
    lastUpdateTime = currentTime
    stationaryStartTime = currentTime
    positionBuffer = [newPosition]
    positionHistory = [newPosition]
    lastStationaryPosition = newPosition
    lastRenderPosition = newPosition

    const initialZoom = calculateZoomLevel(0)
    map.setView([newPosition.lat, newPosition.lng], initialZoom, { animate: false })
    updateDistanceBox()
    return
  }

  const distance = calculateDistance(lastPosition, newPosition)
  const isJump = !forceUpdate && detectSuddenMovement(newPosition, lastPosition)

  if (isJump && isStationary && stationaryPositionLocked) {
    console.log("Position jump detected while stationary, ignoring update")
    isJumpDetected = true
    return
  }

  if (distance > EXTENDED_DISTANCE_THRESHOLD || forceUpdate) {
    if (stationaryCheckTimeout) {
      clearTimeout(stationaryCheckTimeout)
      stationaryCheckTimeout = null
    }

    if (stationaryLockTimeout) {
      clearTimeout(stationaryLockTimeout)
      stationaryLockTimeout = null
    }

    isStationary = false
    stationaryStartTime = null
    stationaryCount = 0
    stationaryPositionHistory = []
    lastStationaryPosition = null
    stationaryPositionLocked = false
    isJumpDetected = false

    userMarker.setLatLng([newPosition.lat, newPosition.lng])
    lastPosition = newPosition
    lastValidPosition = newPosition
    lastRenderPosition = newPosition
    positionBuffer = [newPosition]
    positionHistory = [newPosition]
    kalmanFilter.reset(newPosition)
    kalmanFilter.setStationaryMode(false)
    lastVelocity = { lat: 0, lng: 0 }
    lastSmoothedPosition = null

    if (positionInterpolator) {
      positionInterpolator.cancel()
    }

    const zoomLevel = calculateZoomLevel(newPosition.speedMPS)

    map.setView([newPosition.lat, newPosition.lng], zoomLevel, {
      animate: true,
      duration: 0.3,
      noMoveStart: true,
    })

    lastUpdateTime = currentTime
    lastUpdateTimestamp = currentTime
    updateDistanceBox()

    if (map._container) {
      map._onResize()
    }
    return
  }

  if (
    !forceUpdate &&
    (newPosition.accuracy > MAX_ACCEPTABLE_ACCURACY || (timeDelta > 0 && distance / timeDelta > 40))
  ) {
    console.log("Skipping update due to poor accuracy or unrealistic movement")
    return
  }

  try {
    const motionDetected = deviceMotion && isDeviceInMotion()
    checkStationaryState(newPosition)

    if (isStationary && stationaryPositionLocked && lastStationaryPosition) {
      updateDistanceBox()
      return
    }

    const filteredPosition = kalmanFilter.update(newPosition, motionDetected)
    updatePositionBuffer(filteredPosition)
    updatePositionHistory(filteredPosition)

    let finalPosition

    if (isStationary) {
      if (lastStationaryPosition) {
        if (newPosition.accuracy < lastStationaryPosition.accuracy * 0.8) {
          updateStationaryHistory(filteredPosition)
          const stablePosition = calculateStationaryPosition(positionBuffer)
          if (stablePosition) {
            finalPosition = {
              lat: lerp(lastStationaryPosition.lat, stablePosition.lat, 0.05),
              lng: lerp(lastStationaryPosition.lng, stablePosition.lng, 0.05),
              accuracy: stablePosition.accuracy,
              heading: stablePosition.heading,
              timestamp: currentTime,
              speedMPS: 0,
            }

            positionUpdateQueue.push(finalPosition)
            lastPosition = finalPosition
            lastValidPosition = finalPosition
            lastStationaryPosition = finalPosition
          } else {
            finalPosition = lastStationaryPosition
          }
        } else {
          finalPosition = lastStationaryPosition
        }
      } else {
        const stablePosition = calculateStationaryPosition(positionBuffer)
        if (stablePosition) {
          finalPosition = stablePosition
          lastStationaryPosition = stablePosition
          lastValidPosition = stablePosition
          positionUpdateQueue.push(finalPosition)
        } else {
          finalPosition = filteredPosition
          lastValidPosition = filteredPosition
          positionUpdateQueue.push(finalPosition)
        }
        lastPosition = finalPosition
      }
    } else {
      finalPosition = filteredPosition
      lastValidPosition = filteredPosition

      if (finalPosition.heading !== undefined && finalPosition.speedMPS > 0.5) {
        const predictedPosition = predictPositionFromHeading(
          finalPosition,
          finalPosition.heading,
          finalPosition.speedMPS * 0.4,
        )

        finalPosition = {
          lat: lerp(finalPosition.lat, predictedPosition.lat, 0.25),
          lng: lerp(finalPosition.lng, predictedPosition.lng, 0.25),
          accuracy: finalPosition.accuracy,
          heading: finalPosition.heading,
          timestamp: finalPosition.timestamp,
          speedMPS: finalPosition.speedMPS,
        }
      }

      positionUpdateQueue.push(finalPosition)
      lastPosition = finalPosition
    }

    lastUpdateTime = currentTime
    lastUpdateTimestamp = currentTime
    updateDistanceBox()
  } catch (error) {
    console.error("Location update error:", error)
    userMarker.setLatLng([newPosition.lat, newPosition.lng])
    lastPosition = newPosition
    lastValidPosition = newPosition
    lastRenderPosition = newPosition
    updateDistanceBox()
  }
}

function updateMapViewportDimensions() {
  if (map && map._container) {
    mapViewportWidth = map._container.clientWidth
    mapViewportHeight = map._container.clientHeight

    if (map.getCenter()) {
      lastMapCenter = map.getCenter()
      lastMapZoom = map.getZoom()
    }
  }
}

// Calculate appropriate zoom level based on speed
function calculateZoomLevel(speedMPS) {
  // Update current speed for global access
  currentSpeed = speedMPS

  // Determine zoom level based on speed
  let zoomLevel
  if (isStationary || speedMPS < 0.5) {
    // Stationary or very slow movement
    zoomLevel = MAX_ZOOM_LEVEL
  } else if (speedMPS < WALKING_SPEED_THRESHOLD) {
    // Walking speed
    zoomLevel = WALKING_ZOOM_LEVEL
  } else if (speedMPS < RUNNING_SPEED_THRESHOLD) {
    // Running speed - linear interpolation between walking and running zoom levels
    const t = (speedMPS - WALKING_SPEED_THRESHOLD) / (RUNNING_SPEED_THRESHOLD - WALKING_SPEED_THRESHOLD)
    zoomLevel = WALKING_ZOOM_LEVEL - t
  } else if (speedMPS < DRIVING_SPEED_THRESHOLD) {
    // Driving speed - linear interpolation between running and driving zoom levels
    const t = (speedMPS - RUNNING_SPEED_THRESHOLD) / (DRIVING_SPEED_THRESHOLD - RUNNING_SPEED_THRESHOLD)
    zoomLevel = WALKING_ZOOM_LEVEL - 1 - t
  } else {
    // High speed
    zoomLevel = MIN_ZOOM_LEVEL
  }

  // Smooth zoom level changes
  if (lastZoomLevel !== null) {
    // Apply smoothing to avoid abrupt zoom changes
    zoomLevel = lastZoomLevel * 0.85 + zoomLevel * 0.15
  }

  // Round to one decimal place for smoother transitions
  zoomLevel = Math.round(zoomLevel * 10) / 10

  // Clamp to valid zoom range
  zoomLevel = Math.max(MIN_ZOOM_LEVEL, Math.min(MAX_ZOOM_LEVEL, zoomLevel))

  // Update last zoom level
  lastZoomLevel = zoomLevel

  return zoomLevel
}

function startAnimationLoop() {
  function animate(timestamp) {
    const deltaTime = renderTimestamp ? (timestamp - renderTimestamp) / 1000 : 0
    renderTimestamp = timestamp

    processPositionUpdateQueue()

    if (positionInterpolator?.isInterpolating()) {
      const interpolatedPosition = positionInterpolator.update()
      if (interpolatedPosition) {
        userMarker.setLatLng([interpolatedPosition.lat, interpolatedPosition.lng])
        lastRenderPosition = interpolatedPosition
      }
    }

    if (followUser && !isMapInteracting && !edgeRecenterInProgress) {
      const recenterInfo = shouldRecenter(map, userMarker)
      if (recenterInfo.needsRecenter) {
        performEdgeRecenter(recenterInfo)
      }
    }

    checkLocationProximity()
    animationFrameId = requestAnimationFrame(animate)
  }

  animationFrameId = requestAnimationFrame(animate)
}

function processPositionUpdateQueue() {
  if (positionUpdateQueue.length === 0) return

  while (positionUpdateQueue.length > 0) {
    const update = positionUpdateQueue.shift()
    processPositionUpdate(update)
  }
}

function processPositionUpdate(position) {
  if (!position || typeof position.lat !== "number" || typeof position.lng !== "number") {
    return
  }

  lastPosition = position

  if (lastRenderPosition && !isFirstPositionUpdate) {
    positionInterpolator.start(lastRenderPosition, position, isStationary ? 300 : ANIMATION_DURATION)
  } else {
    userMarker.setLatLng([position.lat, position.lng])
    lastRenderPosition = position
    isFirstPositionUpdate = false
  }

  if (followUser && !isMapInteracting) {
    const recenterInfo = shouldRecenter(map, userMarker)
    if (recenterInfo.needsRecenter) {
      performEdgeRecenter(recenterInfo)
    } else if (Math.abs(map.getZoom() - calculateZoomLevel(position.speedMPS)) > 0.5) {
      const newZoom = calculateZoomLevel(position.speedMPS)
      map.setZoom(newZoom, {
        animate: true,
        duration: ZOOM_TRANSITION_DURATION,
      })
    }
  }
}

function updateDistanceBox() {
  const distanceBox = document.getElementById("distanceBox")
  if (!distanceBox) return

  domUpdateManager.schedule("distanceBox", () => {
    if (!userMarker || !gameLocations || gameLocations.length === 0) {
      distanceBox.innerText = "Initializing..."
      return
    }

    const userLatLng = userMarker.getLatLng()
    let userLat = userLatLng.lat
    let userLng = userLatLng.lng

    if (!isFinite(userLat) || !isFinite(userLng)) {
      console.warn("Invalid user coordinates:", userLat, userLng)
      distanceBox.innerText = "Initializing..."
      return
    }

    if (userLat === 0 && userLng === 0) {
      const center = map.getCenter()
      userLat = center.lat
      userLng = center.lng
    }

    let closestDistance = Number.POSITIVE_INFINITY
    let closestLocation = null
    const userPos = { lat: userLat, lng: userLng }

    for (const location of gameLocations) {
      if (!location || typeof location.lat !== "number" || typeof location.lng !== "number") {
        console.warn("Invalid location data:", location)
        continue
      }

      const locationPos = { lat: location.lat, lng: location.lng }
      const distance = calculateDistance(userPos, locationPos)

      if (isFinite(distance) && distance < closestDistance) {
        closestDistance = distance
        closestLocation = location
      }
    }

    if (!isFinite(closestDistance) || closestDistance === Number.POSITIVE_INFINITY) {
      console.warn("Invalid distance calculation:", closestDistance)
      distanceBox.innerText = "Initializing..."
      return
    }

    const distanceFeet = Math.round(closestDistance * 3.28084)
    const distanceText =
      distanceFeet < 5280 ? `${distanceFeet.toLocaleString()} feet` : `${(distanceFeet / 5280).toFixed(2)} miles`

    distanceBox.innerText = `Closest Stop: ${distanceText}`

    if (distanceFeet <= DISTANCE_THRESHOLD && !isLocationHuntVisible && closestLocation) {
      showLocationHunt(closestLocation)
    }
  })
}

function handleLocationError(error) {
  console.warn("Error getting user location:", error)

  if (retryCount < 3) {
    retryCount++
    console.log(`Retrying to get location (Attempt ${retryCount} of 3)`)

    setTimeout(() => {
      navigator.geolocation.getCurrentPosition(
        (position) => {
          console.log("Location retrieved successfully after retry")
          hideLoadingMessage()
          updateUserLocation(position, true)
          retryCount = 0
        },
        handleLocationError,
        {
          enableHighAccuracy: retryCount < 2,
          timeout: 10000 + retryCount * 5000,
          maximumAge: retryCount * 5000,
        },
      )
    }, 1000)
    return
  }

  retryCount = 0
  hideLoadingMessage()

  let errorMessage = "An error occurred while getting your location."
  if (error && error.code) {
    switch (error.code) {
      case 1:
        errorMessage = "Please allow access to your location to use this feature."
        break
      case 2:
        errorMessage = "Your location is currently unavailable. Please try again later."
        break
      case 3:
        errorMessage = "Getting your location took too long. Please try again."
        break
    }
  }
  showPopup("Location Error", errorMessage)
}

function recenterMap() {
  const recenterButton = document.getElementById("recenterButton")
  if (recenterButton) {
    recenterButton.style.backgroundColor = "#0f2bab"
    recenterButton.style.color = "white"
  }

  if (userMarker && userMarker.getLatLng()) {
    map.closePopup()

    const dynamicZoom = calculateZoomLevel(currentSpeed)

    map.flyTo(userMarker.getLatLng(), dynamicZoom, {
      duration: 0.5,
    })

    followUser = true
  }

  setTimeout(() => {
    if (recenterButton) {
      recenterButton.style.backgroundColor = "white"
      recenterButton.style.color = "#0f2bab"
    }
  }, 500)
}

function addUIEventListeners() {
  document.getElementById("recenterButton")?.addEventListener("click", () => {
    recenterMap()
    resetInactivityTimer()
  })
  document.getElementById("returnButton")?.addEventListener("click", () => {
    returnToIndex()
    resetInactivityTimer()
  })
  document.getElementById("tipsButton")?.addEventListener("click", () => {
    toggleNavigationTips()
    resetInactivityTimer()
  })
  document.querySelector(".navigation-tips .close-button")?.addEventListener("click", () => {
    closeNavigationTips()
    resetInactivityTimer()
  })
}

function addMapEventListeners() {
  const startInteraction = () => {
    isMapInteracting = true
    userIsInteracting = true
    followUser = false
    resetInactivityTimer()
  }

  map.on("movestart zoomstart dragstart", startInteraction)
}

function resetInactivityTimer() {
  if (inactivityTimerId) {
    clearTimeout(inactivityTimerId)
  }
  inactivityTimerId = setTimeout(checkInactivity, INACTIVITY_TIMEOUT)
}

function checkInactivity() {
  console.log("Inactivity timer triggered")
  isMapInteracting = false
  userIsInteracting = false

  map.closePopup()
  map.eachLayer((layer) => {
    if (layer.getPopup?.()?.isOpen()) {
      layer.closePopup()
    }
  })

  if (!isMapInteracting && !userIsInteracting) {
    recenterMap()
  }
}

function closeAllPopups() {
  if (map) {
    map.closePopup()
  }
}

function showLocationHunt(location) {
  const now = performance.now()
  if (location.id === lastVisitedLocationId && now - lastVisitTime < 180000) {
    console.log(`Location ${location.id} is on cooldown. Skipping.`)
    return
  }

  lastVisitedLocationId = location.id
  lastVisitTime = now
  isLocationHuntVisible = true

  domUpdateManager.schedule("locationHunt", () => {
    const lochuntContainer = document.querySelector(".lochunt-container")
    if (!lochuntContainer) return

    lochuntContainer.innerHTML = ""
    lochuntContainer.style.cssText = `
      display: flex;
      flex-direction: column;
      height: 100%;
      overflow: hidden;
      background-color: #fff;
      max-width: 1200px;
      margin: 0 auto;
      box-shadow: 0 2px 20px rgba(0,0,0,0.025);
      will-change: transform;
    `

    const scrollableContent = document.createElement("div")
    scrollableContent.style.cssText = `
      flex: 1;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      scroll-behavior: smooth;
      will-change: scroll-position;
    `

    const locationImage = document.createElement("img")
    if (preloadedImages.has(location.image)) {
      locationImage.src = location.image
    } else {
      locationImage.src = location.image
      const img = new Image()
      img.crossOrigin = "anonymous"
      img.src = location.image
      preloadedImages.set(location.image, img)
    }
    locationImage.alt = location.name
    locationImage.style.cssText = `
      width: 100%;
      height: 45vh;
      object-fit: cover;
      object-position: center;
    `

    scrollableContent.appendChild(locationImage)

    const contentContainer = document.createElement("div")
    contentContainer.classList.add("lochunt-content")
    contentContainer.style.cssText = `
      padding: 24px;
      display: flex;
      flex-direction: column;
      align-items: center;
      max-width: 800px;
      margin: 0 auto;
    `
    const locationInfo = document.createElement("div")
    locationInfo.classList.add("lochunt-info")
    locationInfo.style.cssText = `
      text-align: center;
      width: 100%;
      margin-bottom: 15px;
    `
    const locationName = document.createElement("h1")
    locationName.textContent = location.name
    locationName.style.cssText = `
      font-size: clamp(1.8rem, 4vw, 2.5rem);
      font-weight: 700;
      color: #1a1a1a;
      margin-bottom: 8px;
      line-height: 1.2;
    `
    const locationCity = document.createElement("p")
    locationCity.textContent = `${location.city}`
    locationCity.style.cssText = `
      font-size: clamp(1.1rem, 2vw, 1.3rem);
      color: #ff0000;
      font-weight: 600;
      margin-bottom: 4px;
    `
    const locationCreator = document.createElement("p")
    locationCreator.textContent = `Created by: ${location.creator}`
    locationCreator.style.cssText = `
      font-size: calc(0.9rem + 0.4vw);
      color: #666666;
      font-weight: 500;
    `
    locationInfo.appendChild(locationName)
    locationInfo.appendChild(locationCity)
    locationInfo.appendChild(locationCreator)
    contentContainer.appendChild(locationInfo)
    const audioPlayerContainer = createAudioPlayer(location.audio)
    contentContainer.appendChild(audioPlayerContainer)
    scrollableContent.appendChild(contentContainer)
    lochuntContainer.appendChild(scrollableContent)
    const blueBar = createBlueBar(location)
    blueBar.style.cssText += `
      position: sticky;
      bottom: 0;
      width: 100%;
    `
    lochuntContainer.appendChild(blueBar)

    requestAnimationFrame(initAudioPlayer)
  })
}

function createAudioPlayer(audioSrc) {
  const audioPlayerContainer = document.createElement("div")
  audioPlayerContainer.classList.add("audio-player")
  audioPlayerContainer.style.cssText = `
    width: 100%;
    max-width: 400px;
    margin-bottom: 15px;
  `

  const audio = document.createElement("audio")
  audio.id = "locationAudio"

  if (preloadedAudio.has(audioSrc)) {
    audio.src = audioSrc
  } else {
    audio.src = audioSrc
    const audioPreload = new Audio()
    audioPreload.preload = "auto"
    audioPreload.src = audioSrc
    preloadedAudio.set(audioSrc, audioPreload)
  }

  const audioProgress = document.createElement("div")
  audioProgress.classList.add("audio-progress")
  audioProgress.style.cssText = `
    width: 100%;
    margin-bottom: 15px;
  `

  const progressContainer = document.createElement("div")
  progressContainer.classList.add("progress")
  progressContainer.style.cssText = `
    height: 8px;
    background-color: #e2e8f0;
    border-radius: 4px;
    cursor: pointer;
    margin-bottom: 12px;
    overflow: hidden;
  `

  const progressBar = document.createElement("div")
  progressBar.id = "progressBar"
  progressBar.classList.add("progress-bar")
  progressBar.style.cssText = `
    height: 100%;
    background-color: #ff0000;
    width: 0%;
    transition: width 0.1s linear;
  `

  progressContainer.appendChild(progressBar)
  audioProgress.appendChild(progressContainer)

  const timeInfo = document.createElement("div")
  timeInfo.classList.add("audio-time")
  timeInfo.style.cssText = `
    display: flex;
    justify-content: space-between;
    color: #4a5568;
    font-size: 0.875rem;
    margin-bottom: 16px;
    font-weight: 500;
  `

  const currentTimeSpan = document.createElement("span")
  currentTimeSpan.id = "currentTime"
  currentTimeSpan.textContent = "0:00"

  const durationSpan = document.createElement("span")
  durationSpan.id = "duration"
  durationSpan.textContent = "0:00"

  timeInfo.appendChild(currentTimeSpan)
  timeInfo.appendChild(durationSpan)

  const audioControls = document.createElement("div")
  audioControls.classList.add("audio-controls")
  audioControls.style.cssText = `
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 24px;
  `

  const rewindBtn = createAudioButton("skip-backward", "rewindBtn")
  const playPauseBtn = createAudioButton("play", "playPauseBtn")
  const forwardBtn = createAudioButton("skip-forward", "forwardBtn")

  audioControls.appendChild(rewindBtn)
  audioControls.appendChild(playPauseBtn)
  audioControls.appendChild(forwardBtn)

  audioPlayerContainer.appendChild(audio)
  audioPlayerContainer.appendChild(audioProgress)
  audioPlayerContainer.appendChild(timeInfo)
  audioPlayerContainer.appendChild(audioControls)

  return audioPlayerContainer
}

function createAudioButton(iconName, id) {
  const button = document.createElement("button")
  button.id = id
  button.classList.add("audio-button")
  button.innerHTML = `<i class="bi bi-${iconName}"></i>`
  button.style.cssText = `
    background-color: white;
    color: #0000ff;
    border: 2px solid #0000ff;
    border-radius: 50%;
    width: 55px;
    height: 55px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.3s ease;
  `

  button.addEventListener("mouseover", () => {
    button.style.backgroundColor = "rgba(255, 0, 0, 0.1)"
  })

  button.addEventListener("mouseout", () => {
    button.style.backgroundColor = "white"
  })

  button.addEventListener("click", () => {
    button.style.backgroundColor = "#ff0000"
    button.style.color = "white"
    button.style.transform = "scale(0.95)"

    setTimeout(() => {
      button.style.backgroundColor = "white"
      button.style.color = "#ff0000"
      button.style.transform = "scale(1)"
    }, 200)
  })

  return button
}

function createBlueBar(location) {
  const blueBar = document.createElement("div")
  blueBar.style.cssText = `
    width: 100%;
    height: 60px;
    background: linear-gradient(to right, #0a1f80, #0f2bab);
    margin-top: auto;
    box-shadow: 0 -2px 10px rgba(0,0,0,0.025);
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0 24px;
    position: sticky;
    bottom: 0;
  `

  const infoButton = document.createElement("button")
  infoButton.innerHTML = '<i class="bi bi-info-circle-fill text-white" style="font-size: 1.5rem; z-index: 2500;"></i>'
  infoButton.classList.add("btn", "btn-sm", "me-2")
  infoButton.onclick = () => {
    if (location && location.imageSource) {
      showPopup("Image Source", location.imageSource)
    } else {
      showPopup("Image Source", "Image source information is not available")
    }
  }

  const feedbackButton = document.createElement("a")
  feedbackButton.href = "mailto:mattreicher@protonmail.com?subject=Feedback"
  feedbackButton.target = "_blank"
  feedbackButton.rel = "noopener noreferrer"
  feedbackButton.innerHTML = '<i class="bi bi-envelope-fill text-white" style="font-size: 1.5rem;"></i>'
  feedbackButton.classList.add("btn", "btn-sm")

  blueBar.appendChild(infoButton)
  blueBar.appendChild(feedbackButton)
  return blueBar
}

function initAudioPlayer() {
  const audio = document.getElementById("locationAudio")
  const playPauseBtn = document.getElementById("playPauseBtn")
  const rewindBtn = document.getElementById("rewindBtn")
  const forwardBtn = document.getElementById("forwardBtn")
  const progressBar = document.getElementById("progressBar")
  const progressContainer = document.querySelector(".progress")
  const currentTimeSpan = document.getElementById("currentTime")
  const durationSpan = document.getElementById("duration")

  if (
    !audio ||
    !playPauseBtn ||
    !rewindBtn ||
    !forwardBtn ||
    !progressBar ||
    !progressContainer ||
    !currentTimeSpan ||
    !durationSpan
  ) {
    console.warn("Audio player elements not found, retrying...")
    requestAnimationFrame(initAudioPlayer)
    return
  }

  let lastProgressUpdate = 0
  const PROGRESS_UPDATE_INTERVAL = 250

  playPauseBtn.addEventListener("click", togglePlay)
  rewindBtn.addEventListener("click", () => seek(-10))
  forwardBtn.addEventListener("click", () => seek(10))

  audio.addEventListener("timeupdate", () => {
    const now = Date.now()
    if (now - lastProgressUpdate > PROGRESS_UPDATE_INTERVAL) {
      lastProgressUpdate = now
      updateProgress()
    }
  })

  audio.addEventListener("loadedmetadata", setDuration)
  audio.addEventListener("ended", () => {
    domUpdateManager.schedule("playPauseBtn", () => {
      playPauseBtn.innerHTML = '<i class="bi bi-play"></i>'
    })
    showAdditionalInfo()
  })

  progressContainer.addEventListener("click", setProgress)

  function togglePlay() {
    if (audio.paused) {
      const playPromise = audio.play()
      if (playPromise !== undefined) {
        playPromise
          .then(() => {
            domUpdateManager.schedule("playPauseBtn", () => {
              playPauseBtn.innerHTML = '<i class="bi bi-pause"></i>'
            })
          })
          .catch((error) => {
            console.error("Audio playback failed:", error)
          })
      }
    } else {
      audio.pause()
      domUpdateManager.schedule("playPauseBtn", () => {
        playPauseBtn.innerHTML = '<i class="bi bi-play"></i>'
      })
    }
  }

  function seek(seconds) {
    audio.currentTime = Math.max(0, Math.min(audio.currentTime + seconds, audio.duration))
  }

  function updateProgress() {
    const percent = (audio.currentTime / audio.duration) * 100
    domUpdateManager.schedule("audioProgress", () => {
      progressBar.style.width = `${percent}%`
      currentTimeSpan.textContent = formatTime(audio.currentTime)
    })
  }

  function setProgress(e) {
    const width = this.clientWidth
    const clickX = e.offsetX
    const duration = audio.duration
    audio.currentTime = (clickX / width) * duration
  }

  function setDuration() {
    domUpdateManager.schedule("audioDuration", () => {
      durationSpan.textContent = formatTime(audio.duration)
    })
  }

  function formatTime(time) {
    const minutes = Math.floor(time / 60)
    const seconds = Math.floor(time % 60)
    return `${minutes}:${seconds.toString().padStart(2, "0")}`
  }
}

function showAdditionalInfo() {
  const location = gameLocations.find((loc) => loc.id === lastVisitedLocationId)
  console.log("Current location:", location)
  isReturningFromExhibit = true

  domUpdateManager.schedule("additionalInfo", () => {
    const additionalInfoContainer = document.querySelector(".additional-info-container")
    if (!additionalInfoContainer) return

    additionalInfoContainer.style.display = "block"

    const additionalInfoElement = document.getElementById("additionalInfo")
    if (additionalInfoElement) {
      additionalInfoElement.textContent = location.additionalInfo
    }

    const continueButton = document.getElementById("continueButton")
    if (continueButton) {
      continueButton.onclick = () => {
        additionalInfoContainer.style.display = "none"
        const lochuntContainer = document.querySelector(".lochunt-container")
        if (lochuntContainer) {
          lochuntContainer.style.display = "none"
        }
        isLocationHuntVisible = false
        updateDistanceBox()
      }
    }
  })
}

function showDirectionsModal(lat, lng) {
  const modal = document.getElementById("directionsModal")
  if (!modal) return

  modal.style.display = "block"

  const mapBtn = document.getElementById("mapButton")
  const cancelBtn = document.getElementById("cancelButton")

  if (mapBtn) {
    mapBtn.onclick = () => {
      window.open(`https://www.google.com/maps/dir/?api=1&destination=${lat},${lng}`, "_blank")
      modal.style.display = "none"
    }
  }

  if (cancelBtn) {
    cancelBtn.onclick = () => {
      modal.style.display = "none"
    }
  }

  window.onclick = (event) => {
    if (event.target == modal) {
      modal.style.display = "none"
    }
  }
}

function showLocationSummary(locationId) {
  console.log("Showing summary for location ID:", locationId)
  const location = gameLocations.find((loc) => loc.id === locationId || loc.id === Number.parseInt(locationId))
  console.log("Found location:", location)
  if (location && location.summary) {
    domUpdateManager.schedule("summaryModal", () => {
      const modal = document.getElementById("summaryModal")
      if (!modal) return

      const summaryContent = document.getElementById("summaryContent")
      if (!summaryContent) return

      modal.style.backgroundColor = "rgba(0, 0, 0, 0.5)"
      modal.style.display = "flex"
      modal.style.justifyContent = "center"
      modal.style.alignItems = "center"
      const modalContent = modal.querySelector(".modal-content")
      if (modalContent) {
        modalContent.style.cssText = `
          background-color: white;
          padding: 30px;
          border-radius: 10px;
          box-shadow: 0 4px 6px rgba(0, 0, 0, 0.025);
          max-width: 500px;
          width: 90%;
          max-height: 80vh;
          overflow-y: auto;
        `
      }

      const closeBtn = modal.querySelector(".close")
      if (closeBtn) {
        closeBtn.remove()
      }

      summaryContent.style.textAlign = "left"
      summaryContent.innerHTML = `
        <h3 class="summary-heading" style="font-size: 22px; margin-bottom: 15px; text-align: center;">${location.name}</h3>
        <p style="line-height: 1.6; margin-bottom: 15px;">
          ${location.summary}
        </p>
        <p style="line-height: 1.6; margin-bottom: 15px;">
          <strong>Location:</strong> ${location.today}
        </p>
      `

      const continueButton = document.createElement("button")
      continueButton.textContent = "Continue"
      continueButton.className = "summary-button"
      continueButton.style.cssText = `
        display: block;
        width: auto;
        padding: 12px 20px;
        color: white;
        background-color: #0f2bab;
        border: none;
        border-radius: 10px;
        cursor: pointer;
        font-size: 18px;
        font-weight: bold;
        transition: background-color 0.3s ease;
        margin: 10px auto -15px;
      `
      continueButton.onclick = () => {
        modal.style.display = "none"
      }
      summaryContent.appendChild(continueButton)
      modal.style.display = "flex"
      window.onclick = (event) => {
        if (event.target === modal) {
          modal.style.display = "none"
        }
      }
    })
  } else {
    console.log("Location or summary not found. Location ID:", locationId)
    showPopup("Error", "Summary not available for this location.")
  }
}

function preloadImages(locations) {
  return new Promise((resolve) => {
    if (!locations || locations.length === 0) {
      resolve()
      return
    }

    const totalImages = locations.length
    let loadedImages = 0
    const progressBar = document.getElementById("preloaderProgress")

    locations.forEach((location, index) => {
      if (!location.image) {
        loadedImages++
        updateProgress()
        if (loadedImages === totalImages) resolve()
        return
      }

      if (preloadedImages.has(location.image)) {
        loadedImages++
        updateProgress()
        if (loadedImages === totalImages) resolve()
        return
      }

      const img = new Image()
      img.crossOrigin = "anonymous"
      img.onload = () => {
        preloadedImages.set(location.image, img)
        loadedImages++
        updateProgress()
        if (loadedImages === totalImages) resolve()
      }

      img.onerror = () => {
        console.warn(`Failed to load image: ${location.image}`)
        loadedImages++
        updateProgress()
        if (loadedImages === totalImages) resolve()
      }

      img.src = location.image
    })

    locations.forEach((location) => {
      if (location.audio && !preloadedAudio.has(location.audio)) {
        const audio = new Audio()
        audio.preload = "auto"
        audio.oncanplaythrough = () => {
          preloadedAudio.set(location.audio, audio)
        }
        audio.src = location.audio
      }
    })

    function updateProgress() {
      const percent = (loadedImages / totalImages) * 100
      if (progressBar) {
        domUpdateManager.schedule("preloaderProgress", () => {
          progressBar.style.width = `${percent}%`
        })
      }
    }
  })
}

function startHunt() {
  // This is a placeholder - in a real app, you would fetch locations from an API or database
  // For this example, we'll assume locations is defined elsewhere
  gameLocations = locations || []
  currentLocationIndex = 0
  locationCooldowns = {}
  lastVisitedLocationId = null

  preloadImages(gameLocations).then(() => {
    const preloader = document.getElementById("preloader")
    if (preloader) {
      preloader.style.opacity = "0"
      preloader.style.transition = "opacity 0.5s ease"
      setTimeout(() => {
        if (preloader && preloader.parentNode) {
          preloader.parentNode.removeChild(preloader)
        }
      }, 500)
    }

    loadAllLocations()
  })
}

function getMarkerColor(tours) {
  switch (tours?.toLowerCase()) {
    case "person":
      return "#FFA500"
    case "gangster":
      return "#3f9b0b"
    case "event":
      return "#8B0000"
    case "place":
      return "#0f2bab"
    default:
      return "#0f2bab"
  }
}

function loadAllLocations() {
  if (!gameLocations || !gameLocations.length) {
    console.warn("No locations to load")
    return
  }

  gameLocations.forEach((location, index) => {
    if (!location || typeof location.lat !== "number" || typeof location.lng !== "number") {
      console.warn("Invalid location data:", location)
      return
    }

    const markerColor = getMarkerColor(location.tours)

    const locationMarker = L.marker([location.lat, location.lng], {
      icon: L.divIcon({
        className: "custom-pin-icon",
        html: `<div class="pin-head" style="background-color: ${markerColor};"></div>`,
        iconSize: [30, 30],
        iconAnchor: [15, 30],
      }),
    })

    const popupContent = `
      <div class="popup-content">
        <img src="${location.image}" alt="${location.name}" class="location-image">
        <h4 class="location-name">
          <a href="${location.link}" target="_blank" rel="noopener noreferrer" style="text-decoration: none; color: inherit;">${location.name}</a>
        </h4>
        <div class="popup-buttons">
          <button class="button route-button" data-lat="${location.lat}" data-lng="${location.lng}">Directions</button>
          <button class="button summary-button" data-location-id="${location.id}">Summary</button>
        </div>
      </div>
    `
    locationMarker.bindPopup(popupContent, {
      offset: L.point(0, -25),
      className: "custom-popup",
    })

    locationMarker.on("popupopen", (e) => {
      const popup = e.popup._contentNode
      const routeButton = popup.querySelector(".route-button")
      const summaryButton = popup.querySelector(".summary-button")

      if (routeButton) {
        routeButton.addEventListener("click", function (event) {
          event.preventDefault()
          const lat = this.getAttribute("data-lat")
          const lng = this.getAttribute("data-lng")

          const modal = document.createElement("div")
          modal.className = "modal"
          modal.innerHTML = `
            <div class="modal-content">
              <h3>Choose your preferred navigation app:</h3>
              <div class="modal-buttons">
                <button class="modal-button google-maps">
                  Google Maps
                </button>
                <button class="modal-button waze">
                  Waze
                </button>
                <button class="modal-button apple-maps">
                  Apple Maps
                </button>
                <button class="modal-button cancel">Cancel</button>
              </div>
            </div>
          `

          document.body.appendChild(modal)

          modal.querySelector(".google-maps").addEventListener("click", () => {
            window.location.href = `https://www.google.com/maps/dir/?api=1&destination=${lat},${lng}`
            modal.remove()
          })

          modal.querySelector(".waze").addEventListener("click", () => {
            window.location.href = `https://www.waze.com/ul?ll=${lat}%2C${lng}&navigate=yes`
            modal.remove()
          })

          modal.querySelector(".apple-maps").addEventListener("click", () => {
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent)
            if (isIOS) {
              window.location.href = `maps://maps.apple.com/?daddr=${lat},${lng}`
              modal.remove()
            } else {
              const alertEl = document.createElement("div")
              alertEl.className = "modal"
              alertEl.innerHTML = `
                <div class="modal-content">
                  <p>Apple Maps is only available on iOS devices</p>
                  <button class="modal-button">OK</button>
                </div>
              `
              document.body.appendChild(alertEl)
              alertEl.querySelector("button").onclick = () => {
                alertEl.remove()
                return false
              }
            }
          })

          modal.querySelector(".cancel").addEventListener("click", () => {
            modal.remove()
          })

          modal.addEventListener("click", (e) => {
            if (e.target === modal) {
              modal.remove()
            }
          })
        })
      }

      if (summaryButton) {
        summaryButton.addEventListener("click", function (event) {
          event.preventDefault()
          const locationId = this.getAttribute("data-location-id")
          showLocationSummary(locationId)
        })
      }
    })

    markerClusterGroup.addLayer(locationMarker)
  })
  map.addLayer(markerClusterGroup)
  updateDistanceBox()
  resetInactivityTimer()
}

function returnToIndex() {
  showPopup("Confirm", "Are you ready to exit?", "info", () => {
    window.location.href = "/index.html"
  })
  const returnButton = document.getElementById("returnButton")
  if (returnButton) {
    returnButton.classList.remove("active")
  }
}

function toggleNavigationTips() {
  const tipsElement = document.querySelector(".navigation-tips")
  if (!tipsElement) return

  const computedStyle = window.getComputedStyle(tipsElement)

  if (computedStyle.display === "none") {
    tipsElement.style.display = "block"
  } else {
    tipsElement.style.display = "none"
  }

  const tipsButton = document.getElementById("tipsButton")
  if (tipsButton) {
    tipsButton.classList.toggle("active")
  }
}

function closeNavigationTips() {
  const tipsElement = document.querySelector(".navigation-tips")
  if (tipsElement) {
    tipsElement.style.display = "none"
  }

  const tipsButton = document.getElementById("tipsButton")
  if (tipsButton) {
    tipsButton.classList.remove("active")
  }
}

// Initialize the app
document.addEventListener("DOMContentLoaded", () => {
  initMap()
  addUIEventListeners()
  addMapEventListeners()
})
    </script>
  </body>
</html>
