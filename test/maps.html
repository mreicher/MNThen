<!DOCTYPE html> 
<html lang="en">
<head> 
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Minnesota Then | A Museum Without Walls</title>
    <link rel="shortcut icon" type="image/x-icon" href="https://www.mnthen.com/images/mnthenfav.ico">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css">
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css" />
    <link rel="stylesheet" href="https://www.mnthen.com/css/mainmap.css">
    <link rel="stylesheet" href="https://www.mnthen.com/css/mnthen_main_map2.css">

    <style>
        .at-location {
  border: 2px solid red !important;
  box-shadow: 0 0 8px rgba(255, 0, 0, 0.5);
  transition: border-color 0.3s ease, box-shadow 0.3s ease;
}

/* Enhancement for existing preloader */
.loading-animation {
    margin: 20px auto 10px;
    text-align: center;
}

.dot {
    display: inline-block;
    width: 12px;
    height: 12px;
    margin: 0 5px;
    border-radius: 50%;
    background-color: #333;
    opacity: 0.6;
    animation: dotPulse 1.4s infinite ease-in-out;
}

.dot:nth-child(1) {
    animation-delay: 0s;
}

.dot:nth-child(2) {
    animation-delay: 0.2s;
}

.dot:nth-child(3) {
    animation-delay: 0.4s;
}

@keyframes dotPulse {
    0%, 80%, 100% { 
        transform: scale(0.8);
        opacity: 0.6;
    }
    40% { 
        transform: scale(1.2);
        opacity: 1;
    }
}

.mn-facts {
    max-width: 80%;
    margin: 15px auto;
    padding: 12px 15px;
    border-radius: 8px;
    background-color: rgba(0, 65, 123, 0.08); /* Light blue tint */
    border-left: 4px solid #0078d4; /* Minnesota blue accent */
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    text-align: center;
}

.mn-facts p {
    color: #333;
    font-weight: 500;
    margin: 0;
    font-size: 17px;
}

/* Minnesota facts container - completely transparent background, no blue tint, no left border */
.mn-facts-container {
    margin-top: 30px;
    width: 100%;
    max-width: 700px; /* Even larger container */
    display: flex;
    align-items: flex-start;
    background: rgba(0, 0, 0, 0.2); /* Dark transparent background, no blue */
    border-radius: 8px;
    padding: 24px; /* Larger padding */
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
}

.mn-facts-icon {
    flex-shrink: 0;
    margin-right: 18px;
    margin-top: 4px;
    transform: scale(1.4); /* Larger icon */
}

.mn-facts {
    text-align: left;
    color: rgba(255, 255, 255, 1); /* Fully opaque white text */
    flex-grow: 1;
}

.mn-facts p {
    margin: 0;
    font-size: 20px; /* Significantly larger font */
    line-height: 1.5;
    font-style: normal;
    font-weight: 500;
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5); /* Stronger shadow for better contrast */
}

/* Loading animation dots */
.loading-animation {
    margin: 30px auto 0;
    text-align: center;
}

.dot {
    display: inline-block;
    width: 10px; /* Larger dots */
    height: 10px;
    margin: 0 6px;
    border-radius: 50%;
    background-color: rgba(255, 255, 255, 0.9);
    opacity: 0.6;
    animation: dotPulse 1.4s infinite ease-in-out;
}

.dot:nth-child(1) {
    animation-delay: 0s;
}

.dot:nth-child(2) {
    animation-delay: 0.2s;
}

.dot:nth-child(3) {
    animation-delay: 0.4s;
}

@keyframes dotPulse {
    0%, 80%, 100% { 
        transform: scale(0.8);
        opacity: 0.6;
    }
    40% { 
        transform: scale(1.2);
        opacity: 1;
    }
}

/* Responsive adjustments */
@media (max-width: 768px) {
    .mn-facts-container {
        padding: 20px;
        margin-top: 25px;
        max-width: 90%;
    }
    
    .mn-facts p {
        font-size: 18px;
    }
}

@media (max-width: 480px) {
    .mn-facts-container {
        padding: 16px;
        margin-top: 20px;
    }
    
    .mn-facts-icon {
        margin-right: 12px;
        transform: scale(1.2);
    }
    
    .mn-facts p {
        font-size: 16px;
    }
}
    </style>
    
</head>
<body>
<!-- Preloader (keeping your existing structure) -->
<div id="preloader">
    <div class="preloader-content">
        <img class="logo" src="https://www.mnthen.com/images/logo.webp" alt="Minnesota Then Logo">
        <h1>Minnesota Then</h1>
        <h2>Every step tells a story.</h2>
        <p>Loading the Museum Without Walls</p>
        <div class="progress-container">
            <div class="progress-bar" id="preloaderProgress"></div>
        </div>
        
        <!-- New Minnesota facts box -->
        <div class="mn-facts-container">
            <div class="mn-facts-icon">
                <svg viewBox="0 0 24 24" width="24" height="24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 22C17.5228 22 22 17.5228 22 12C22 6.47715 17.5228 2 12 2C6.47715 2 2 6.47715 2 12C2 17.5228 6.47715 22 12 22Z" stroke="white" stroke-width="2"/>
                    <path d="M12 8V12" stroke="white" stroke-width="2" stroke-linecap="round"/>
                    <circle cx="12" cy="16" r="1" fill="white"/>
                </svg>
            </div>
            <div class="mn-facts" id="loadingFacts">
                <p>Did you know? The Mississippi River begins its journey in Minnesota.</p>
            </div>
        </div>
    </div>
</div>

    <div id="map"></div>
    <div id="distanceBox">Initializing...</div>

    <div class="lochunt-container">
        <img id="locationImage" src="" alt="Location Image">
            <div class="lochunt-content">
                <div class="lochunt-info">
                    <h2 id="locationTitle" class="mb-2 text-primary"></h2>
                        <p id="locationCity" class="text-muted mb-1"></p>
                        <p id="locationCreator" class="text-muted mb-3"></p>
                </div>
            <div class="audio-player">
                <div class="audio-progress">
                    <div class="progress">
                        <div id="progressBar" class="progress-bar" role="progressbar" style="width: 0%"></div>
                    </div>
                </div>
                <div class="audio-time">
                    <span id="currentTime">0:00</span>
                    <span id="duration">0:00</span>
                </div>
                <div class="audio-controls">
                    <button id="rewindBtn" class="audio-button"><i class="fas fa-backward"></i></button>
                    <button id="playPauseBtn" class="audio-button"><i class="fas fa-play"></i></button>
                    <button id="forwardBtn" class="audio-button"><i class="fas fa-forward"></i></button>
                </div>
                <audio id="locationAudio" src="/placeholder.svg"></audio>
            </div>
        </div>
    </div>
    
    <div class="additional-info-container">
       <h3 class="mb-3 text-primary text-center">Did You Know?</h3>
       <p id="additionalInfo" class="mb-3 fs-6"></p>
       <div class="d-flex justify-content-center">
           <button id="continueButton" class="btn btn-primary">Continue</button>
       </div>
    </div>
    
    <div class="map-buttons">
        <button id="recenterButton" class="map-button"><i class="fas fa-crosshairs"></i></button>
        <button id="returnButton" class="map-button"><i class="fas fa-sign-out-alt"></i></button>
        <button id="tipsButton" class="map-button"><i class="fas fa-question-circle"></i></button>
    </div>

    <div class="navigation-tips">
        <button class="close-button">&times;</button>
        <h3>Navigation Tips</h3>
        <ul>
            <li>Use the map to navigate to the marked locations.</li>
            <li>Tap the recenter button to focus on your current position.</li>
            <li>The distance box shows how far you are from the closest location.</li>
            <li>When you're within 20 feet of a location, you'll be able to interact with it.</li>
            <li>Listen to the audio information for each location.</li>
            <li>After the audio, you'll see additional information about the location.</li>
        </ul>
    </div>

    <div id="summaryModal" class="modal" style="display: none;">
        <div class="modal-content">
            <p id="summaryContent"></p>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"></script>
    
    <script src="/locations_test.js?v=1.0.4"></script>

    <script>
// Global variables
let map, userMarker, markerClusterGroup
let currentLocationIndex = 0
const visitedLocations = []
let gameLocations = []
let inactivityTimer
let isLocationHuntVisible = false
let lastPosition = null
let positionBuffer = []
const MAX_BUFFER_SIZE = 30 // buffer size for smoother tracking
const DISTANCE_THRESHOLD = 20 // 20 feet to measure threshold distance to marker before opening location page.
const PROXIMITY_THRESHOLD = 45 // 45 feet threshold for zoom changes
let velocity = { lat: 0, lng: 0 }
let isMapInteracting = false
let followUser = true
let locationCooldowns = {}
let userIsInteracting = false
const preloadedImages = new Map() // Map to store preloaded images
const preloadedAudio = new Map() // Map to store preloaded audio
let currentSpeed = 0 // Current speed in meters per second
let lastZoomLevel = 17 // Default zoom level
let stationaryPositionHistory = [] // Array to store stationary positions for averaging
let deviceOrientation = null // Store device orientation data
let deviceMotion = null // Store device motion data
let orientationPermissionGranted = false
let geolocationSensor = null // Store GeolocationSensor instance
let isReturningFromExhibit = false // Flag to track if returning from exhibit
let positionWatchId = null;
let watchSettings = null;
let wasStationary = false;
let isWithinProximity = false; // Flag to track if user is within proximity of a location

// Timestamps for throttling checks and changes
let lastProximityCheck = 0; // Initialize to 0 to allow first check
let lastZoomChangeTime = 0; // Initialize to 0 to allow first zoom change

// State tracking variables
let isNearLocation = false;
let lastProximityDistance = Infinity;

//inacitivty timer recentering
let userIsManuallyNavigating = false;

let shouldCheckProximityThreshold = false;

let animationFrameId = null;

// Enhanced constants for better stabilization
const MICRO_MOVEMENT_THRESHOLD = 0.2 // Meters - reduced threshold for detecting micro-movements for higher sensitivity
const MAX_ACCEPTABLE_ACCURACY = 20 // meters - reduced for higher precision
const STATIONARY_THRESHOLD = 1 // Reduced number of consecutive stationary positions to consider user as stationary for faster response
const STATIONARY_TIME_THRESHOLD = 2000 // ms - reduced time to consider user stationary for faster response
const STATIONARY_CHECK_INTERVAL = 500 // ms - reduced interval to check if still stationary for faster response
const VELOCITY_DECAY = 0.95 // Higher value for smoother velocity transitions but more responsive
const MIN_DISTANCE_THRESHOLD = 0.5 // meters - reduced minimum distance to consider movement for higher sensitivity
const EXTENDED_DISTANCE_THRESHOLD = 80 // meters - distance to consider a significant position change
const STATIONARY_POSITION_HISTORY_SIZE = 10 // Reduced number of positions to keep for stationary averaging for faster response
const STATIONARY_POSITION_WEIGHT_DECAY = 0.85 // Adjusted weight decay for older positions in stationary average
const SUDDEN_MOVEMENT_THRESHOLD = 0.5 // meters - reduced threshold for detecting sudden movements for higher sensitivity
const POSITION_JUMP_THRESHOLD = 1.5 // meters - reduced threshold for detecting position jumps for higher sensitivity

let stationaryPositionVariance = { lat: 0, lng: 0 };
const VARIANCE_SCALING_FACTOR = 2.0; // Reduced for more precise variance calculation

// Adaptive threshold based on device-reported accuracy
let MIN_STATIONARY_DRIFT_THRESHOLD = 1.5; // Default value
        
const STATIONARY_DAMPING_FACTOR = 0.97; // Increased for smoother but still responsive damping
const STRONG_MOTION_THRESHOLD = 1.2; // m/s - reduced for higher sensitivity
const MIN_CONSISTENT_MOTION = 0.3; // m/s - reduced for higher sensitivity

// Background handling constants
const BACKGROUND_THRESHOLD = 10000 // ms - reduced time to consider app was in background for faster response
const INACTIVITY_TIMEOUT = 20000 // ms - reduced time to consider user inactive for faster response

// Kalman filter parameters - optimized for better movement tracking
const KALMAN_PROCESS_NOISE = 0.000008 // Reduced for more precise tracking
const KALMAN_MEASUREMENT_NOISE_BASE = 0.08 // Reduced for more precise tracking
const KALMAN_STATIONARY_NOISE = 0.0000008 // Reduced for more precise tracking when stationary

// Animation parameters
const ANIMATION_DURATION = 150 // ms - significantly reduced duration of position animation for more responsive transitions
const HEADING_SMOOTHING = 0.75 // Reduced heading smoothing factor for more responsive direction changes

// Zoom level parameters
const MAX_ZOOM_LEVEL = 17 // Maximum zoom level (stationary)
const MIN_ZOOM_LEVEL = 15 // Minimum zoom level (high speed)
const WALKING_ZOOM_LEVEL = 17 // Zoom level for walking speed
const WALKING_SPEED_THRESHOLD = 1.5 // m/s - threshold for walking speed
const RUNNING_SPEED_THRESHOLD = 4.0 // m/s - threshold for running speed
const DRIVING_SPEED_THRESHOLD = 10.0 // m/s - threshold for driving speed
const ZOOM_TRANSITION_DURATION = 0.3 // seconds - reduced duration of zoom transition for more responsive zooming

const DRIVING_CITY_THRESHOLD = 8.0 // m/s - threshold for walking speed
const DRIVING_HIGHWAY_THRESHOLD = 15.0 // m/s - threshold for running speed

// Motion detection parameters
const MOTION_THRESHOLD = 0.6 // Reduced threshold for detecting significant motion for higher sensitivity
const MOTION_SAMPLE_SIZE = 20 // Increased number of motion samples to keep for more accurate motion detection
const MOTION_CHECK_INTERVAL = 100 // ms - reduced interval to check motion for more responsive detection

// Edge recenter parameters - optimized for better edge recentering
const EDGE_THRESHOLD_PERCENTAGE = 0.20 // Percentage of viewport to trigger recenter (reduced)
const CRITICAL_EDGE_THRESHOLD = 0.10 // Critical threshold for emergency recenter (reduced)
const RECENTER_COOLDOWN = 1000 // ms - reduced minimum time between recenters for faster response

// Speed accuracy parameters
const SPEED_ACCURACY_THRESHOLD = 3.0; // Reduced for higher precision

// State variables
let lastUpdateTime = null
let lastVelocity = { lat: 0, lng: 0 }
let isStationary = false
let stationaryStartTime = null
let stationaryCheckTimeout = null
let lastUpdateTimestamp = null
let lastHiddenTime = 0
let lastKnownPosition = null
let lastVisitedLocationId = null
let stationaryCount = 0
let lastSmoothedPosition = null
let lastRecenterTime = Date.now()
let retryCount = 0
const stationaryBuffer = []
const stationaryPosition = null
let isStabilizing = true // Flag to track initial stabilization
let lastStationaryPosition = null // Last stable position when stationary
const motionSamples = [] // Array to store motion samples
let deviceStationaryTime = 0 // Time device has been stationary based on motion sensors
let renderTimestamp = null // Last render timestamp
const positionUpdateQueue = [] // Queue for position updates to be processed
let lastHeadingValue = null // Last heading value
const headingBuffer = [] // Buffer for heading values
let isFirstPositionUpdate = true // Flag for first position update
let lastRenderPosition = null // Last rendered position

// Optimized position interpolator with improved animation curve and performance
const positionInterpolator = {
  currentAnimation: null,
  startTime: null,
  from: null,
  to: null,
  duration: 0,
  
  start: function(from, to, duration) {
    // Cancel any existing animation
    if (this.currentAnimation) {
      cancelAnimationFrame(this.currentAnimation);
    }
    
    // Validate inputs to prevent NaN issues
    if (!from || !to || typeof from.lat !== 'number' || typeof from.lng !== 'number' || 
        typeof to.lat !== 'number' || typeof to.lng !== 'number') {
      console.warn("Invalid position data for interpolation");
      return;
    }
    
    // Store animation parameters
    this.startTime = performance.now();
    this.from = from;
    this.to = to;
    this.duration = duration;
    
    // Start animation
    this.update();
  },
  
  update: function() {
    if (!this.startTime) return;
    
    const currentTime = performance.now();
    const elapsed = currentTime - this.startTime;
    const progress = Math.min(elapsed / this.duration, 1);
    
    // Use optimized easing for smoother motion (custom ease-out curve)
    // This provides a more natural acceleration/deceleration curve
    const eased = 1 - Math.pow(1 - progress, 2.5);
    
    // Interpolate between positions with high precision
    const currentPosition = {
      lat: this.from.lat + (this.to.lat - this.from.lat) * eased,
      lng: this.from.lng + (this.to.lng - this.from.lng) * eased
    };
    
    // Update marker position with high-performance rendering
    if (typeof updateUserMarkerPosition === 'function') {
      updateUserMarkerPosition(currentPosition);
    }
    lastRenderPosition = currentPosition;
    
    // Continue animation if not complete with optimized frame scheduling
    if (progress < 1) {
      this.currentAnimation = requestAnimationFrame(() => this.update());
    } else {
      // Ensure final position is exactly the target position
      if (typeof updateUserMarkerPosition === 'function') {
        updateUserMarkerPosition(this.to);
      }
      lastRenderPosition = this.to;
      this.currentAnimation = null;
      this.startTime = null;
    }
  },
  
  cancel: function() {
    if (this.currentAnimation) {
      cancelAnimationFrame(this.currentAnimation);
      this.currentAnimation = null;
      this.startTime = null;
    }
  },
  
  isInterpolating: function() {
    return this.currentAnimation !== null;
  }
};
      
let mapViewportWidth = 0 // Store map viewport width
let mapViewportHeight = 0 // Store map viewport height
let lastMapCenter = null // Last map center position
let lastMapZoom = null // Last map zoom level
let edgeRecenterInProgress = false // Flag to track edge recentering
const pendingDomUpdates = new Map() // Map to store pending DOM updates
let usingGeolocationSensorAPI = false // Flag to track which geolocation API is being used
const lockStationaryPosition = false // Flag to lock stationary position and prevent jitter
let positionHistory = [] // Array to store recent position history for jump detection
const lastPositionTimestamp = 0 // Last time a position was processed
let suddenMovementCount = 0 // Counter for consecutive sudden movements
let isJumpDetected = false // Flag to track if a position jump is detected
let stationaryPositionLocked = false // Flag to indicate if stationary position is locked
let stationaryPositionLockTime = 0 // Time when stationary position was locked
let lastValidPosition = null // Last valid position before a jump
let stationaryLockTimeout = null // Timeout for locking stationary position
const lastAccuracy = Number.POSITIVE_INFINITY // Last position accuracy
const isAccuracyImproving = false // Flag to track if accuracy is improving
let isWatchPositionActive = false // Flag to track if watchPosition is active
let watchPositionId = null // ID for watchPosition
const watchPositionUpdateInterval = 500 // ms - reduced interval for watchPosition updates for more responsive tracking
        
// Optimized utility function to calculate distance between two coordinates
function calculateDistance(pos1, pos2) {
  if (
    !pos1 ||
    !pos2 ||
    typeof pos1.lat !== "number" ||
    typeof pos1.lng !== "number" ||
    typeof pos2.lat !== "number" ||
    typeof pos2.lng !== "number"
  ) {
    return Number.POSITIVE_INFINITY
  }

  // Haversine formula with optimized math operations
  const R = 6371000 // Earth radius in meters
  const lat1 = pos1.lat * Math.PI / 180
  const lat2 = pos2.lat * Math.PI / 180
  const deltaLat = (pos2.lat - pos1.lat) * Math.PI / 180
  const deltaLng = (pos2.lng - pos1.lng) * Math.PI / 180

  // Optimized sin² calculation
  const sinDeltaLat2 = deltaLat * 0.5;
  const sinDeltaLng2 = deltaLng * 0.5;
  const a = Math.sin(sinDeltaLat2) * Math.sin(sinDeltaLat2) +
            Math.cos(lat1) * Math.cos(lat2) * 
            Math.sin(sinDeltaLng2) * Math.sin(sinDeltaLng2);
  
  // Optimized sqrt and atan2 calculation
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))

  return R * c
}

// Enhanced Kalman Filter implementation with optimized performance
class KalmanFilter {
  constructor() {
    // State vector [x, y, vx, vy]
    this.x = 0
    this.y = 0
    this.vx = 0
    this.vy = 0

    // Error covariance matrix - optimized initial values for faster convergence
    this.P = [
      [50, 0, 0, 0], // Reduced initial uncertainty for faster convergence
      [0, 50, 0, 0],
      [0, 0, 5, 0],
      [0, 0, 0, 5],
    ]

    // Process noise - optimized for better tracking
    this.Q = KALMAN_PROCESS_NOISE

    // Measurement noise (will be adjusted based on GPS accuracy)
    this.R = KALMAN_MEASUREMENT_NOISE_BASE

    // Time delta
    this.dt = 1.0

    // Initialized flag
    this.initialized = false

    // Heading and accuracy tracking
    this.lastHeading = null
    this.headingConfidence = 0

    // Stationary mode flag
    this.stationaryMode = false
    this.stationaryStartTime = 0

    // Last timestamp
    this.lastTimestamp = null

    // Adaptive noise parameters - optimized for better tracking
    this.adaptiveNoiseMin = 0.0001 // Reduced for more precise tracking
    this.adaptiveNoiseMax = 0.001 // Reduced for more precise tracking
    this.adaptiveNoiseFactor = 1.0

    // Position history for jitter detection
    this.positionHistory = []
    this.maxPositionHistory = 15 // Increased for better jitter detection
    this.jitterThreshold = 0.75 // Reduced for higher sensitivity
    this.jitterCount = 0
    this.maxJitterCount = 2 // number of zigzag patterns required before confirming jitter

    // Stationary lock
    this.stationaryLocked = false
    this.stationaryPosition = null

    // Heading smoothing - optimized for more responsive direction changes
    this.headingSmoothingFactor = 0.7 // Reduced for more responsive direction changes
    this.headingBuffer = []
    this.headingBufferSize = 5 // Reduced for more responsive direction changes

    // Velocity smoothing - optimized for more responsive velocity changes
    this.velocitySmoothingFactor = 0.7 // Reduced for more responsive velocity changes
    this.velocityBuffer = []
    this.velocityBufferSize = 5 // Reduced for more responsive velocity changes

    // Accuracy-based adaptation
    this.accuracyBuffer = []
    this.accuracyBufferSize = 5 // Reduced for faster adaptation
    this.lastAccuracy = Number.POSITIVE_INFINITY
    this.isAccuracyImproving = false

    // Motion-based adaptation
    this.motionDetected = false
    this.motionConfidence = 0

    // Adaptive parameters based on device capabilities
    this.deviceCapabilitiesSet = false
    this.deviceSupportsHighAccuracy = true
    this.deviceSupportsMotionSensors = true
    this.deviceSupportsOrientationSensors = true

    // Innovation tracking to detect filter divergence
    this.innovationBuffer = []
    this.innovationBufferSize = 8 // Reduced for faster adaptation
    this.innovationThreshold = 2.5 // Reduced for higher sensitivity

    // GNSS receiver type (GPS, GLONASS, Galileo, etc)
    this.receiverType = "GPS"

    // Environment type (urban, rural, indoor, etc)
    this.environmentType = "mixed"
  }

  // Set device capabilities
  setDeviceCapabilities(highAccuracy, motionSensors, orientationSensors) {
    this.deviceCapabilitiesSet = true
    this.deviceSupportsHighAccuracy = highAccuracy
    this.deviceSupportsMotionSensors = motionSensors
    this.deviceSupportsOrientationSensors = orientationSensors

    // Adjust parameters based on device capabilities
    if (!highAccuracy) {
      this.adaptiveNoiseMin *= 1.3 // Reduced multiplier for more precise tracking
      this.adaptiveNoiseMax *= 1.3
      this.jitterThreshold *= 1.3
    }

    if (!motionSensors) {
      this.adaptiveNoiseMin *= 1.1 // Reduced multiplier for more precise tracking
      this.adaptiveNoiseMax *= 1.1
    }

    if (!orientationSensors) {
      this.headingSmoothingFactor = 0.8 // Reduced for more responsive direction changes
    }

    return this
  }

  // Set the type of GNSS receiver
  setReceiverType(type) {
    this.receiverType = type

    // Adjust parameters based on receiver type
    switch (type.toUpperCase()) {
      case "GPS_GLONASS":
      case "MULTI_CONSTELLATION":
        this.adaptiveNoiseMin *= 0.7 // Reduced multiplier for more precise tracking
        this.adaptiveNoiseMax *= 0.7
        break
      case "BASIC_GPS":
        this.adaptiveNoiseMin *= 1.1 // Reduced multiplier for more precise tracking
        this.adaptiveNoiseMax *= 1.1
        break
      case "HIGH_PRECISION":
        this.adaptiveNoiseMin *= 0.4 // Reduced multiplier for more precise tracking
        this.adaptiveNoiseMax *= 0.4
        break
    }

    return this
  }

  // Set the type of environment
  setEnvironmentType(type) {
    this.environmentType = type

    // Adjust parameters based on environment type
    switch (type.toLowerCase()) {
      case "urban":
        this.adaptiveNoiseMin *= 1.2 // Reduced multiplier for more precise tracking
        this.adaptiveNoiseMax *= 1.2
        this.jitterThreshold *= 0.8 // Reduced for higher sensitivity
        break
      case "rural":
        this.adaptiveNoiseMin *= 0.7 // Reduced multiplier for more precise tracking
        this.adaptiveNoiseMax *= 0.7
        this.jitterThreshold *= 1.1 // Increased for lower sensitivity in rural areas
        break
      case "indoor":
        this.adaptiveNoiseMin *= 1.4 // Reduced multiplier for more precise tracking
        this.adaptiveNoiseMax *= 1.4
        this.jitterThreshold *= 0.6 // Reduced for higher sensitivity indoors
        break
    }

    return this
  }

  // Initialize the filter with first position
  reset(position) {
    if (!position || typeof position.lat !== "number" || typeof position.lng !== "number") {
      console.error("Invalid position for Kalman filter reset")
      return this;
    }

    this.x = position.lng
    this.y = position.lat
    this.vx = 0
    this.vy = 0

    // Reset covariance matrix with optimized initial uncertainty
    this.P = [
      [50, 0, 0, 0], // Reduced for faster convergence
      [0, 50, 0, 0],
      [0, 0, 5, 0],
      [0, 0, 0, 5],
    ]

    this.initialized = true
    this.lastHeading = position.heading || null
    this.headingConfidence = 0
    this.stationaryMode = false
    this.lastTimestamp = position.timestamp || Date.now()
    this.adaptiveNoiseFactor = 1.0
    this.positionHistory = []
    this.jitterCount = 0
    this.stationaryLocked = false
    this.stationaryPosition = null
    this.headingBuffer = []
    this.velocityBuffer = []
    this.accuracyBuffer = []
    this.lastAccuracy = position.accuracy || Number.POSITIVE_INFINITY
    this.isAccuracyImproving = false
    this.motionDetected = false
    this.motionConfidence = 0
    this.innovationBuffer = []

    return this
  }

  // Set stationary mode
  setStationaryMode(isStationary) {
    this.stationaryMode = isStationary

    // When entering stationary mode, reduce velocity to zero
    if (isStationary) {
      this.vx = 0
      this.vy = 0
      this.stationaryStartTime = Date.now()

      // Reduce process noise for stationary mode
      this.Q = KALMAN_STATIONARY_NOISE
      this.adaptiveNoiseFactor = 0.02 // Reduced for more precise tracking when stationary
    } else {
      // Reset to normal process noise when moving
      this.Q = KALMAN_PROCESS_NOISE
      this.adaptiveNoiseFactor = 1.0
      this.stationaryLocked = false
      this.stationaryPosition = null
    }

    return this
  }

  // Lock stationary position
  lockStationaryPosition(position) {
    if (!this.stationaryMode) return this

    this.stationaryLocked = true
    this.stationaryPosition = position

    return this
  }

  // Update accuracy buffer and check if accuracy is improving
  updateAccuracyBuffer(accuracy) {
    if (isNaN(accuracy) || accuracy <= 0) {
      accuracy = this.lastAccuracy || 20
    }

    this.accuracyBuffer.push(accuracy)
    while (this.accuracyBuffer.length > this.accuracyBufferSize) {
      this.accuracyBuffer.shift()
    }

    if (this.accuracyBuffer.length >= 3) {
      const avgRecent =
        (this.accuracyBuffer[this.accuracyBuffer.length - 1] + this.accuracyBuffer[this.accuracyBuffer.length - 2]) / 2
      const avgOlder =
        (this.accuracyBuffer[0] + (this.accuracyBuffer.length > 1 ? this.accuracyBuffer[1] : this.accuracyBuffer[0])) /
        2

      this.isAccuracyImproving = avgRecent < avgOlder
    }

    this.lastAccuracy = accuracy

    return this
  }

  // Track innovation to detect filter divergence
  updateInnovationBuffer(innovation) {
    this.innovationBuffer.push(innovation)
    while (this.innovationBuffer.length > this.innovationBufferSize) {
      this.innovationBuffer.shift()
    }

    if (this.innovationBuffer.length >= 4) { // Reduced for faster adaptation
      // Calculate mean and standard deviation of innovations
      const sum = this.innovationBuffer.reduce((acc, val) => acc + val, 0)
      const mean = sum / this.innovationBuffer.length

      const sumSquaredDiff = this.innovationBuffer.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0)
      const stdDev = Math.sqrt(sumSquaredDiff / this.innovationBuffer.length)

      // If innovation is consistently large, the filter might be diverging
      const latestInnovation = this.innovationBuffer[this.innovationBuffer.length - 1]
      if (Math.abs(latestInnovation - mean) > this.innovationThreshold * stdDev) {
        // Increase uncertainty to force filter to trust measurements more
        for (let i = 0; i < 4; i++) {
          this.P[i][i] *= 2.5 // Increased for faster adaptation
        }
      }
    }

    return this
  }

  // Detect jitter in position updates
  detectJitter(newPosition) {
    if (this.positionHistory.length === 0) {
      this.positionHistory.push(newPosition)
      return false
    }

    const lastPos = this.positionHistory[this.positionHistory.length - 1]
    const distance = calculateDistance(lastPos, newPosition)

    // Add to history
    this.positionHistory.push(newPosition)
    while (this.positionHistory.length > this.maxPositionHistory) {
      this.positionHistory.shift()
    }

    // Check for rapid back-and-forth movement (jitter)
    if (this.positionHistory.length >= 3 && this.stationaryMode) {
      const pos1 = this.positionHistory[this.positionHistory.length - 3]
      const pos2 = this.positionHistory[this.positionHistory.length - 2]
      const pos3 = this.positionHistory[this.positionHistory.length - 1]

      const dist1 = calculateDistance(pos1, pos2)
      const dist2 = calculateDistance(pos2, pos3)

      // Adaptive jitter threshold based on accuracy
      const adaptiveJitterThreshold = newPosition.accuracy ? 
        Math.max(0.6, newPosition.accuracy * 0.12) : this.jitterThreshold;

      // If moving back and forth in small distances
      if (
        dist1 < adaptiveJitterThreshold &&
        dist2 < adaptiveJitterThreshold &&
        Math.sign(pos3.lat - pos2.lat) !== Math.sign(pos2.lat - pos1.lat) &&
        Math.sign(pos3.lng - pos2.lng) !== Math.sign(pos2.lng - pos1.lng)
      ) {
        this.jitterCount++
        return this.jitterCount > 1
      }
    }

    // Reset jitter count if no jitter detected
    if (distance > this.jitterThreshold) {
      this.jitterCount = 0
    }

    return false
  }

  // Smooth heading values with optimized algorithm
  smoothHeading(newHeading) {
    if (newHeading === null || newHeading === undefined || isNaN(newHeading)) {
      return this.lastHeading
    }

    // Normalize to 0-360
    newHeading = ((newHeading % 360) + 360) % 360

    // Add to heading buffer
    this.headingBuffer.push(newHeading)
    while (this.headingBuffer.length > this.headingBufferSize) {
      this.headingBuffer.shift()
    }

    if (this.headingBuffer.length < 2) {
      return newHeading
    }

    // Use median filter to remove outliers
    if (this.headingBuffer.length >= 3) {
      const sortedHeadings = [...this.headingBuffer].sort((a, b) => a - b)
      const medianHeading = sortedHeadings[Math.floor(sortedHeadings.length / 2)]

      // If new heading is very different from median, it might be an outlier
      const headingDiff = Math.abs(((newHeading - medianHeading + 180) % 360) - 180)
      if (headingDiff > 40 && this.headingConfidence > 0.4) { // Reduced threshold for higher sensitivity
        // Use median instead of potentially erroneous new heading
        newHeading = medianHeading
      }
    }

    // If we have a previous heading, smooth the transition
    if (this.lastHeading !== null) {
      // Normalize headings to 0-360
      const normalizedCurrent = ((newHeading % 360) + 360) % 360
      const normalizedLast = ((this.lastHeading % 360) + 360) % 360

      // Calculate the smallest angle between the two headings
      let diff = normalizedCurrent - normalizedLast
      if (diff > 180) diff -= 360
      if (diff < -180) diff += 360

      // Apply adaptive smoothing based on motion and stationary state
      let headingWeight = this.headingSmoothingFactor
      if (this.stationaryMode) {
        headingWeight = 0.03 // Very smooth when stationary, reduced for more stability
      } else if (this.motionDetected) {
        headingWeight = Math.min(0.3, headingWeight * (1 + this.motionConfidence)) // More responsive when motion detected
      }

      // Apply smoothing
      const smoothedHeading = normalizedLast + diff * (1 - headingWeight)

      // Normalize back to 0-360
      return ((smoothedHeading % 360) + 360) % 360
    }

    return newHeading
  }

  // Smooth velocity values with optimized algorithm
  smoothVelocity(vx, vy) {
    const speed = Math.sqrt(vx * vx + vy * vy)

    this.velocityBuffer.push(speed)
    while (this.velocityBuffer.length > this.velocityBufferSize) {
      this.velocityBuffer.shift()
    }

    if (this.velocityBuffer.length < 2) {
      return { vx, vy }
    }

    // Calculate median velocity to filter outliers
    if (this.velocityBuffer.length >= 3) {
      const sortedVelocities = [...this.velocityBuffer].sort((a, b) => a - b)
      const medianVelocity = sortedVelocities[Math.floor(sortedVelocities.length / 2)]

      const currentVelocity = speed

      // If current velocity is drastically different from median, scale it
      if (currentVelocity > medianVelocity * 1.8) { // Reduced threshold for higher sensitivity
        const scale = (medianVelocity * 1.8) / currentVelocity
        vx *= scale
        vy *= scale
      }
    }

    return { vx, vy }
  }

  // Adjust process noise based on accuracy, motion, and device capabilities
  adjustProcessNoise(accuracy, motionDetected) {
    // Update accuracy buffer and check if accuracy is improving
    this.updateAccuracyBuffer(accuracy)

    // Update motion detection state
    this.motionDetected = motionDetected
    if (motionDetected) {
      this.motionConfidence = Math.min(1.0, this.motionConfidence + 0.15) // Increased for faster adaptation
    } else {
      this.motionConfidence = Math.max(0.0, this.motionConfidence - 0.08) // Increased for faster adaptation
    }

    // Base noise level depends on GPS accuracy
    let noiseLevel =
      this.adaptiveNoiseMin + (this.adaptiveNoiseMax - this.adaptiveNoiseMin) * Math.min(1.0, accuracy / 25.0) // Reduced for higher precision

    // Reduce noise when stationary
    if (this.stationaryMode) {
      noiseLevel *= 0.02 // Reduced for more stability when stationary
    }

    // Increase noise when motion is detected
    if (this.motionDetected && !this.stationaryMode) {
      noiseLevel *= 1.0 + this.motionConfidence * 1.2 // Increased for more responsiveness when moving
    }

    // Adjust based on accuracy trend
    if (this.isAccuracyImproving) {
      noiseLevel *= 0.85 // Reduced for more stability when accuracy is improving
    } else {
      noiseLevel *= 1.15 // Increased for more responsiveness when accuracy is degrading
    }

    // Apply adaptive factor
    noiseLevel *= this.adaptiveNoiseFactor

    // Set process noise
    this.Q = noiseLevel

    return this
  }

  // Update the filter with new measurement - optimized for performance and precision
  update(position, motionDetected = false) {
    if (!this.initialized) {
      this.reset(position)
      return position
    }

    if (!position || typeof position.lat !== "number" || typeof position.lng !== "number") {
      console.warn("Invalid position input to Kalman filter")
      return {
        lat: this.y,
        lng: this.x,
        accuracy: position?.accuracy || 20,
        heading: this.lastHeading,
        timestamp: position?.timestamp || Date.now(),
      }
    }

    // If we're in stationary mode and have a locked position, return the locked position
    if (this.stationaryMode && this.stationaryLocked && this.stationaryPosition) {
      return {
        lat: this.stationaryPosition.lat,
        lng: this.stationaryPosition.lng,
        accuracy: position.accuracy,
        heading: this.smoothHeading(position.heading),
        timestamp: position.timestamp,
        speedMPS: 0,
      }
    }

    // Calculate time delta
    const timestamp = position.timestamp || Date.now()
    if (this.lastTimestamp) {
      this.dt = Math.min(Math.max((timestamp - this.lastTimestamp) / 1000, 0.01), 0.5) // Reduced max dt for more responsive updates
    }
    this.lastTimestamp = timestamp

    // Check for jitter
    const isJittering = this.detectJitter(position)

    // Adjust measurement noise based on GPS accuracy and jitter
    const accuracy = position.accuracy || 20
    this.R = Math.max(KALMAN_MEASUREMENT_NOISE_BASE, accuracy / 6) // Reduced divisor for more precise tracking

    // If in stationary mode, increase measurement noise to reduce jitter
    if (this.stationaryMode) {
      this.R *= 4.0 // Reduced multiplier for more responsiveness
    }

    // If jittering is detected, increase measurement noise significantly
    if (isJittering) {
      this.R *= 8.0 // Reduced multiplier for more responsiveness
    }

    // Adjust process noise based on accuracy and motion
    this.adjustProcessNoise(accuracy, motionDetected)

    // State transition matrix
    const F = [
      [1, 0, this.dt, 0],
      [0, 1, 0, this.dt],
      [0, 0, 1, 0],
      [0, 0, 0, 1],
    ]

    // Predict step
    // x = F * x
    const predictedX = this.x + this.dt * this.vx
    const predictedY = this.y + this.dt * this.vy
    const predictedVx = this.stationaryMode ? 0 : this.vx
    const predictedVy = this.stationaryMode ? 0 : this.vy

    // P = F * P * F' + Q
    const Q = [
      [(this.Q * this.dt * this.dt * this.dt * this.dt) / 4, 0, (this.Q * this.dt * this.dt * this.dt) / 2, 0],
      [0, (this.Q * this.dt * this.dt * this.dt * this.dt) / 4, 0, (this.Q * this.dt * this.dt * this.dt) / 2],
      [(this.Q * this.dt * this.dt * this.dt) / 2, 0, this.Q * this.dt * this.dt, 0],
      [0, (this.Q * this.dt * this.dt * this.dt) / 2, 0, this.Q * this.dt * this.dt],
    ]

    // Matrix multiplication F * P
    const FP = [
      [
        this.P[0][0] + this.dt * this.P[2][0],
        this.P[0][1] + this.dt * this.P[2][1],
        this.P[0][2] + this.dt * this.P[2][2],
        this.P[0][3] + this.dt * this.P[2][3],
      ],
      [
        this.P[1][0] + this.dt * this.P[3][0],
        this.P[1][1] + this.dt * this.P[3][1],
        this.P[1][2] + this.dt * this.P[3][2],
        this.P[1][3] + this.dt * this.P[3][3],
      ],
      [this.P[2][0], this.P[2][1], this.P[2][2], this.P[2][3]],
      [this.P[3][0], this.P[3][1], this.P[3][2], this.P[3][3]],
    ]

    // Matrix multiplication FP * F'
    const predictedP = [
      [
        FP[0][0] + this.dt * FP[0][2] + Q[0][0],
        FP[0][1] + this.dt * FP[0][3] + Q[0][1],
        FP[0][2] + Q[0][2],
        FP[0][3] + Q[0][3],
      ],
      [
        FP[1][0] + this.dt * FP[1][2] + Q[1][0],
        FP[1][1] + this.dt * FP[1][3] + Q[1][1],
        FP[1][2] + Q[1][2],
        FP[1][3] + Q[1][3],
      ],
      [FP[2][0] + Q[2][0], FP[2][1] + Q[2][1], FP[2][2] + Q[2][2], FP[2][3] + Q[2][3]],
      [FP[3][0] + Q[3][0], FP[3][1] + Q[3][1], FP[3][2] + Q[3][2], FP[3][3] + Q[3][3]],
    ]

    // Update step
    // y = z - H * x
    const measurementResidualX = position.lng - predictedX
    const measurementResidualY = position.lat - predictedY

    // Track innovation to detect filter divergence
    const innovation = Math.sqrt(
      measurementResidualX * measurementResidualX + measurementResidualY * measurementResidualY,
    )
    this.updateInnovationBuffer(innovation)

    // S = H * P * H' + R
    const S = [
      [predictedP[0][0] + this.R, predictedP[0][1]],
      [predictedP[1][0], predictedP[1][1] + this.R],
    ]

    // Calculate determinant of S
    const detS = S[0][0] * S[1][1] - S[0][1] * S[1][0]

    // Calculate inverse of S
    const invS = [
      [S[1][1] / detS, -S[0][1] / detS],
      [-S[1][0] / detS, S[0][0] / detS],
    ]

    // K = P * H' * inv(S)
    const K = [
      [
        predictedP[0][0] * invS[0][0] + predictedP[0][1] * invS[1][0],
        predictedP[0][0] * invS[0][1] + predictedP[0][1] * invS[1][1],
      ],
      [
        predictedP[1][0] * invS[0][0] + predictedP[1][1] * invS[1][0],
        predictedP[1][0] * invS[0][1] + predictedP[1][1] * invS[1][1],
      ],
      [
        predictedP[2][0] * invS[0][0] + predictedP[2][1] * invS[1][0],
        predictedP[2][0] * invS[0][1] + predictedP[2][1] * invS[1][1],
      ],
      [
        predictedP[3][0] * invS[0][0] + predictedP[3][1] * invS[1][0],
        predictedP[3][0] * invS[0][1] + predictedP[3][1] * invS[1][1],
      ],
    ]

    // x = x + K * y
    this.x = predictedX + K[0][0] * measurementResidualX + K[0][1] * measurementResidualY
    this.y = predictedY + K[1][0] * measurementResidualX + K[1][1] * measurementResidualY

    // In stationary mode, keep velocity at zero
    if (this.stationaryMode) {
      this.vx = 0
      this.vy = 0
    } else {
      this.vx = predictedVx + K[2][0] * measurementResidualX + K[2][1] * measurementResidualY
      this.vy = predictedVy + K[3][0] * measurementResidualX + K[3][1] * measurementResidualY

      // Smooth velocity
      const smoothedVelocity = this.smoothVelocity(this.vx, this.vy)
      this.vx = smoothedVelocity.vx
      this.vy = smoothedVelocity.vy
    }

    // P = (I - K * H) * P
    this.P = [
      [
        predictedP[0][0] - (K[0][0] * predictedP[0][0] + K[0][1] * predictedP[1][0]),
        predictedP[0][1] - (K[0][0] * predictedP[0][1] + K[0][1] * predictedP[1][1]),
        predictedP[0][2] - (K[0][0] * predictedP[0][2] + K[0][1] * predictedP[1][2]),
        predictedP[0][3] - (K[0][0] * predictedP[0][3] + K[0][1] * predictedP[1][3]),
      ],
      [
        predictedP[1][0] - (K[1][0] * predictedP[0][0] + K[1][1] * predictedP[1][0]),
        predictedP[1][1] - (K[1][0] * predictedP[0][1] + K[1][1] * predictedP[1][1]),
        predictedP[1][2] - (K[1][0] * predictedP[0][2] + K[1][1] * predictedP[1][2]),
        predictedP[1][3] - (K[1][0] * predictedP[0][3] + K[1][1] * predictedP[1][3]),
      ],
      [
        predictedP[2][0] - (K[2][0] * predictedP[0][0] + K[2][1] * predictedP[1][0]),
        predictedP[2][1] - (K[2][0] * predictedP[0][1] + K[2][1] * predictedP[1][1]),
        predictedP[2][2] - (K[2][0] * predictedP[0][2] + K[2][1] * predictedP[1][2]),
        predictedP[2][3] - (K[2][0] * predictedP[0][3] + K[2][1] * predictedP[1][3]),
      ],
      [
        predictedP[3][0] - (K[3][0] * predictedP[0][0] + K[3][1] * predictedP[1][0]),
        predictedP[3][1] - (K[3][0] * predictedP[0][1] + K[3][1] * predictedP[1][1]),
        predictedP[3][2] - (K[3][0] * predictedP[0][2] + K[3][1] * predictedP[1][2]),
        predictedP[3][3] - (K[3][0] * predictedP[0][3] + K[3][1] * predictedP[1][3]),
      ],
    ]

    // Process heading data
    const smoothedHeading = this.smoothHeading(position.heading)
    this.lastHeading = smoothedHeading

    // Calculate speed from velocity components
    const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy)

    // Create filtered position
    const filteredPosition = {
      lat: this.y,
      lng: this.x,
      accuracy: position.accuracy,
      heading: smoothedHeading,
      timestamp: position.timestamp,
      speedMPS: this.stationaryMode ? 0 : speed * 111000, // Convert from degrees/second to meters/second (approximate)
    }

    // If we're in stationary mode and don't have a locked position yet,
    // check if we should lock the position
    if (this.stationaryMode && !this.stationaryLocked && this.stationaryStartTime) {
      // If we've been stationary for a while, lock the position
      if (Date.now() - this.stationaryStartTime > 1500) { // Reduced for faster locking
        this.lockStationaryPosition(filteredPosition)
      }
    }

    return filteredPosition
  }
}

// Position interpolator for smooth transitions - optimized for performance and precision
class PositionInterpolator {
  constructor() {
    this.startPosition = null
    this.targetPosition = null
    this.startTime = null
    this.duration = 0
    this.isActive = false
    this.lastInterpolatedPosition = null
    this.interpolationMethod = "cubic" // "cubic", "linear", "spring"
    this.springParams = {
      stiffness: 120, // Increased for more responsive spring
      damping: 12,    // Increased for more responsive spring
      mass: 1,
    }
  }

  setInterpolationMethod(method, params = {}) {
    this.interpolationMethod = method

    if (method === "spring" && params) {
      this.springParams.stiffness = params.stiffness || 120
      this.springParams.damping = params.damping || 12
      this.springParams.mass = params.mass || 1
    }

    return this
  }

  start(startPos, targetPos, duration) {
    if (!startPos || !targetPos) return this

    this.startPosition = { ...startPos }
    this.targetPosition = { ...targetPos }
    this.startTime = performance.now()
    this.duration = duration
    this.isActive = true

    // For spring animation, we need initial velocity
    if (this.interpolationMethod === "spring") {
      this.velocity = {
        lat: 0,
        lng: 0,
      }
      this.lastUpdateTime = this.startTime
    }

    return this
  }

  update() {
    if (!this.isActive) return null

    const now = performance.now()
    const elapsed = now - this.startTime

    if (elapsed >= this.duration && this.interpolationMethod !== "spring") {
      this.isActive = false
      this.lastInterpolatedPosition = { ...this.targetPosition }
      return this.targetPosition
    }

    let interpolatedPosition

    switch (this.interpolationMethod) {
      case "linear":
        interpolatedPosition = this.linearInterpolation(elapsed / this.duration)
        break
      case "spring":
        interpolatedPosition = this.springInterpolation(now)
        // Check if spring has settled
        const distToTarget = calculateDistance(interpolatedPosition, this.targetPosition)
        if (distToTarget < 0.05 && Math.abs(this.velocity.lat) < 0.00005 && Math.abs(this.velocity.lng) < 0.00005) {
          this.isActive = false
        }
        break
      case "cubic":
      default:
        interpolatedPosition = this.cubicInterpolation(elapsed / this.duration)
        break
    }

    this.lastInterpolatedPosition = interpolatedPosition
    return interpolatedPosition
  }

  // Linear interpolation
  linearInterpolation(t) {
    // Clamp t between 0 and 1
    t = Math.max(0, Math.min(1, t))

    return {
      lat: this.startPosition.lat + (this.targetPosition.lat - this.startPosition.lat) * t,
      lng: this.startPosition.lng + (this.targetPosition.lng - this.startPosition.lng) * t,
      accuracy: this.targetPosition.accuracy,
      heading: this.targetPosition.heading,
      timestamp: performance.now(),
      speedMPS: this.targetPosition.speedMPS,
    }
  }

  // Cubic easing function for smoother motion
  cubicInterpolation(t) {
    // Clamp t between 0 and 1
    t = Math.max(0, Math.min(1, t))

    // Apply easing - optimized for more responsive transitions
    const easedT = this.easeOutCubic(t)

    return {
      lat: this.startPosition.lat + (this.targetPosition.lat - this.startPosition.lat) * easedT,
      lng: this.startPosition.lng + (this.targetPosition.lng - this.startPosition.lng) * easedT,
      accuracy: this.targetPosition.accuracy,
      heading: this.interpolateHeading(this.startPosition.heading, this.targetPosition.heading, easedT),
      timestamp: performance.now(),
      speedMPS: this.targetPosition.speedMPS,
    }
  }

  // Spring-based physics interpolation - optimized for more responsive transitions
  springInterpolation(now) {
    const dt = (now - this.lastUpdateTime) / 1000 // Convert to seconds
    this.lastUpdateTime = now

    // Spring physics parameters
    const k = this.springParams.stiffness
    const b = this.springParams.damping
    const m = this.springParams.mass

    // Calculate spring force for latitude and longitude
    const forceLatSpring = -k * (this.lastInterpolatedPosition.lat - this.targetPosition.lat)
    const forceLngSpring = -k * (this.lastInterpolatedPosition.lng - this.targetPosition.lng)

    // Calculate damping force
    const forceLatDamping = -b * this.velocity.lat
    const forceLngDamping = -b * this.velocity.lng

    // Calculate total force
    const totalForceLat = forceLatSpring + forceLatDamping
    const totalForceLng = forceLngSpring + forceLngDamping

    // Calculate acceleration (F = ma, so a = F/m)
    const accLat = totalForceLat / m
    const accLng = totalForceLng / m

    // Update velocity (v = v0 + a*t)
    this.velocity.lat += accLat * dt
    this.velocity.lng += accLng * dt

    // Update position (x = x0 + v*t)
    const newLat = this.lastInterpolatedPosition.lat + this.velocity.lat * dt
    const newLng = this.lastInterpolatedPosition.lng + this.velocity.lng * dt

    return {
      lat: newLat,
      lng: newLng,
      accuracy: this.targetPosition.accuracy,
      heading: this.interpolateHeading(this.lastInterpolatedPosition.heading, this.targetPosition.heading, 0.15), // Increased for more responsive heading changes
      timestamp: now,
      speedMPS: this.targetPosition.speedMPS,
    }
  }

  // Interpolate heading (special case due to circular nature)
  interpolateHeading(startHeading, endHeading, t) {
    if (startHeading === null || endHeading === null) {
      return endHeading
    }

    // Normalize headings to 0-360
    startHeading = ((startHeading % 360) + 360) % 360
    endHeading = ((endHeading % 360) + 360) % 360

    // Find the shortest path around the circle
    let diff = endHeading - startHeading
    if (diff > 180) diff -= 360
    if (diff < -180) diff += 360

    // Interpolate
    const result = (startHeading + diff * t) % 360
    return result < 0 ? result + 360 : result
  }

  // Cubic easing function - optimized for more responsive transitions
  easeOutCubic(t) {
    return 1 - Math.pow(1 - t, 2.5)
  }

  // Smoother Hermite easing function with configurable smoothness
  easeHermite(t, smoothness = 0) {
    // Clamp t between 0 and 1
    t = Math.max(0, Math.min(1, t))

    // Apply Hermite interpolation with smoothness parameter
    return t * t * (3 - 2 * t - smoothness * (t - 1) * t)
  }

  isInterpolating() {
    return this.isActive
  }

  cancel() {
    this.isActive = false
    return this
  }

  getLastPosition() {
    return this.lastInterpolatedPosition || this.targetPosition || this.startPosition
  }
}

// Adaptive Kalman Filter Factory - optimized for better device-specific tracking
class AdaptiveKalmanFilterFactory {
  static createForDevice(deviceInfo) {
    const filter = new KalmanFilter()

    // Configure based on device type and capabilities
    if (deviceInfo) {
      // Set device capabilities
      filter.setDeviceCapabilities(
        deviceInfo.highAccuracySupported || true,
        deviceInfo.motionSensorsAvailable || true,
        deviceInfo.orientationSensorsAvailable || true,
      )

      // Set receiver type based on device
      if (deviceInfo.gnssType) {
        filter.setReceiverType(deviceInfo.gnssType)
      }

      // Set environment type if known
      if (deviceInfo.environment) {
        filter.setEnvironmentType(deviceInfo.environment)
      }
    }

    return filter
  }

  static createFilterAndInterpolator(deviceInfo, interpolationMethod = "cubic") {
    const filter = this.createForDevice(deviceInfo)
    const interpolator = new PositionInterpolator().setInterpolationMethod(interpolationMethod)

    return {
      filter,
      interpolator,

      // Convenience method to update and interpolate in one step
      update(position, motionDetected = false, interpolationDuration = ANIMATION_DURATION) {
        // First update the filter
        const filteredPosition = filter.update(position, motionDetected)

        // Then start interpolation to the new filtered position
        if (!interpolator.isInterpolating()) {
          const startPos = interpolator.getLastPosition() || position
          interpolator.start(startPos, filteredPosition, interpolationDuration)
        } else {
          // Update target while keeping the interpolation
          interpolator.targetPosition = filteredPosition
        }

        // Return the current interpolated position
        return interpolator.update() || filteredPosition
      },
    }
  }
}

// DOM update manager - batch DOM updates for better performance
const domUpdateManager = {
  updates: new Map(),
  scheduled: false,

  // Schedule a DOM update
  schedule(id, updateFn) {
    this.updates.set(id, updateFn)

    if (!this.scheduled) {
      this.scheduled = true
      requestAnimationFrame(() => this.flush())
    }
  },

  // Flush all scheduled DOM updates
  flush() {
    this.updates.forEach((updateFn) => updateFn())
    this.updates.clear()
    this.scheduled = false
  },
}

const DEBUG_MODE = false; // Set to true for additional logging

// Track previous state to improve transitions between motion states
let prevMotionState = false;
let configLastUpdated = 0;
const CONFIG_UPDATE_INTERVAL = 2000; // Reconfigure every 2 seconds if needed

// Enhanced tracking function with improved motion detection, position filtering and centering
function enhancedTracking(newPosition, motionDetected, viewportDimensions = null) {
  // Store last valid position for fallback
  if (newPosition && typeof newPosition.x === 'number' && typeof newPosition.y === 'number') {
    lastValidPosition = {...newPosition};
  } else if (!lastValidPosition) {
    if (DEBUG_MODE) {
      console.warn("Invalid position provided and no fallback available");
    }
    return newPosition; // First-time case, can't do much
  }
  
  // Handle invalid input case
  if (!newPosition || typeof newPosition !== 'object') {
    if (DEBUG_MODE) {
      console.warn("Invalid position provided, using last known position");
    }
    newPosition = lastValidPosition;
  }

  // Validate tracking object first
  if (!tracking) {
    if (DEBUG_MODE) {
      console.warn("Tracking not initialized - creating emergency tracking object");
    }
    // Emergency initialize tracking rather than simply returning raw position
    tracking = createPassthroughTracker();
  }

  // Detect motion state transitions for smoother animation
  const isTransitioning = prevMotionState !== motionDetected;
  prevMotionState = motionDetected;
  
  // Reconfigure tracking parameters periodically or on motion state change
  const now = Date.now();
  if (!tracking.__configAttempted || isTransitioning || (now - configLastUpdated > CONFIG_UPDATE_INTERVAL)) {
    // More adaptive parameter configuration based on current conditions
    const params = {
      processNoise: motionDetected ? 0.05 : 0.008, // Increased for better tracking during motion
      measurementNoise: Math.max(newPosition.accuracy / 10, 0.01), // More adaptive to accuracy
      adaptivity: motionDetected ? 0.02 : 0.005, // More responsive during motion
      // Add transition dampening for state changes
      transitionDampening: isTransitioning ? 0.7 : 1.0
    };

    // Try to configure with better error handling
    let configSuccess = false;
    
    if (typeof tracking.configure === 'function') {
      try {
        tracking.configure(params);
        configSuccess = true;
      } catch (error) {
        if (DEBUG_MODE) {
          console.warn("Configure method failed:", error);
        }
      }
    } 
    
    if (!configSuccess && typeof tracking.setParameters === 'function') {
      try {
        tracking.setParameters(params);
        configSuccess = true;
      } catch (error) {
        if (DEBUG_MODE) {
          console.warn("SetParameters method failed:", error);
        }
      }
    }

    // Mark that we've attempted configuration and when
    tracking.__configAttempted = true;
    configLastUpdated = now;
  }

  // Calculate animation duration - optimized for smoother transitions
  // Use shorter durations for motion and slower for stationary for perceived smoothness
  let animationDuration = motionDetected ? ANIMATION_DURATION / 1.5 : ANIMATION_DURATION;
  
  // Use slightly longer animation during transitions to avoid jerky movement
  if (isTransitioning) {
    animationDuration *= 1.2;
  }
  
  // Process position with error recovery
  let processedPosition;
  
  try {
    // Process position through tracking system
    if (typeof tracking.update === 'function') {
      processedPosition = tracking.update(newPosition, motionDetected, animationDuration);
    } else if (typeof tracking.process === 'function') {
      processedPosition = tracking.process(newPosition, {
        isMoving: motionDetected,
        animationDuration: animationDuration,
        isTransitioning: isTransitioning
      });
    } else if (tracking.filter?.update) {
      processedPosition = tracking.filter.update(newPosition);
    } else if (tracking.setPosition) {
      tracking.setPosition(newPosition);
      processedPosition = newPosition;
    } else {
      if (DEBUG_MODE) {
        console.debug("No update method found - using filtered position");
      }
      // Apply basic filtering even when no method is available
      processedPosition = applyBasicFiltering(newPosition, lastValidPosition);
    }
  } catch (error) {
    if (DEBUG_MODE) {
      console.error("Position update failed:", error);
    }
    // Apply gradual fallback rather than immediate raw position return
    processedPosition = applyBasicFiltering(newPosition, lastValidPosition);
  }
  
  // Apply centering logic if viewport dimensions are provided
  if (viewportDimensions && 
      typeof viewportDimensions.width === 'number' && 
      typeof viewportDimensions.height === 'number') {
    
    const viewportCenter = {
      x: viewportDimensions.width / 2,
      y: viewportDimensions.height / 2
    };
    
    // Calculate how far from center the position is (0-1 scale)
    const distanceFromCenter = calculateNormalizedDistanceFromCenter(
      processedPosition, 
      viewportCenter,
      viewportDimensions
    );
    
    // Apply automatic recentering when position drifts too far from center
    // More aggressive recentering when stationary, gentler when in motion
    const recenterThreshold = motionDetected ? 0.4 : 0.25;
    
    if (distanceFromCenter > recenterThreshold) {
      processedPosition = applySmoothedRecentering(
        processedPosition, 
        viewportCenter, 
        motionDetected ? 0.15 : 0.3 // Recentering strength
      );
    }
  }
  
  return processedPosition;
}

// Helper function for basic position filtering as fallback
function applyBasicFiltering(newPosition, lastPosition) {
  if (!lastPosition) return newPosition;
  
  // Simple exponential smoothing filter
  const alpha = 0.3; // Smoothing factor
  
  return {
    x: alpha * newPosition.x + (1 - alpha) * lastPosition.x,
    y: alpha * newPosition.y + (1 - alpha) * lastPosition.y,
    // Preserve other properties
    ...newPosition
  };
}

// Helper to calculate normalized distance from viewport center (0-1 scale)
function calculateNormalizedDistanceFromCenter(position, center, viewport) {
  const dx = Math.abs(position.x - center.x) / (viewport.width / 2);
  const dy = Math.abs(position.y - center.y) / (viewport.height / 2);
  return Math.sqrt(dx * dx + dy * dy); // Normalized distance
}

// Apply gradual recentering with easing
function applySmoothedRecentering(position, center, strength) {
  return {
    x: position.x + (center.x - position.x) * strength,
    y: position.y + (center.y - position.y) * strength,
    // Preserve other properties
    ...position
  };
}

// Now define createPassthroughTracker with additional methods
const createPassthroughTracker = () => {
  console.warn("Using passthrough filter (no filtering)");
  
  // Create more robust fallback object
  return {
    update: (position) => applyBasicFiltering(position, lastValidPosition || position),
    setParameters: () => {},
    configure: () => {},
    process: (position) => applyBasicFiltering(position, lastValidPosition || position),
    filter: {
      update: (position) => applyBasicFiltering(position, lastValidPosition || position)
    },
    setPosition: (position) => { lastValidPosition = {...position}; }
  };
};

// Create tracking system with optimized filter and interpolator
const TRACKING_CONFIG = {
  highAccuracySupported: true,
  motionSensorsAvailable: true,
  orientationSensorsAvailable: true,
  gnssType: "GPS_GLONASS",
  environment: "urban",
  fallbackFilterType: "cubic" // Using cubic for better interpolation
};

// Initialize tracking system with optimized parameters
function initializeTracking() {
  try {
    // First try preferred configuration
    if (typeof AdaptiveKalmanFilterFactory?.createFilterAndInterpolator === 'function') {
      console.log("Using AdaptiveKalmanFilterFactory");
      return AdaptiveKalmanFilterFactory.createFilterAndInterpolator(
        TRACKING_CONFIG,
        "cubic" // Use cubic interpolation for smoother transitions
      );
    }
    
    // Fallbacks if primary method fails
    if (typeof BasicKalmanFilter === 'function') {
      console.warn("Using basic Kalman filter fallback");
      return new BasicKalmanFilter({ /*...*/ });
    }
    
    // Use the feature detection fallback
    return createPassthroughTracker();
  } catch (error) {
    console.error("Tracking initialization failed:", error);
    // Return minimal API even in error case
    return createPassthroughTracker();
  }
}

const tracking = initializeTracking(); // Initialize the tracking system

console.log("Map tracking system initialized with optimized parameters");

// Calculate optimal zoom level based on speed and context
function calculateZoomLevel(speedMPS) {
  // Update speed tracking with more immediate response
  currentSpeed = Math.max(0, speedMPS);
  
  // If near a point of interest, use maximum zoom regardless of speed
  if (isNearLocation) {
    return 18;
  }
  
  // Determine if this is reliable GPS data
  const isReliableSpeed = lastPosition?.speedAccuracy < SPEED_ACCURACY_THRESHOLD;
  
  // Less conservative adjustment for speed estimates
  const adjustedSpeed = isReliableSpeed ? currentSpeed : Math.min(currentSpeed, 2.0);
  
  // Get basic target zoom from the existing function
  let targetZoom = calculateOptimalZoom(adjustedSpeed);
  
  // More responsive smoothing between zoom levels
  if (lastZoomLevel !== null) {
    // Increase responsiveness with more aggressive smoothing factors
    const speedChange = Math.abs(currentSpeed - (lastPosition?.speedMPS || 0));
    const smoothingFactor = isReliableSpeed ? 
      (speedChange > 1.0 ? 0.5 : 0.25) : 
      0.15;
    
    // Apply smoothing with higher weight to new values
    targetZoom = lastZoomLevel * (1 - smoothingFactor) + targetZoom * smoothingFactor;
    
    // Round to one decimal for smoother transitions
    targetZoom = Math.round(targetZoom * 10) / 10;
  }
  
  // Update tracking for next calculation
  lastZoomLevel = targetZoom;
  
  // Ensure zoom is within valid range, but don't exceed 17 unless near a location
  return Math.max(MIN_ZOOM_LEVEL, Math.min(isNearLocation ? MAX_ZOOM_LEVEL : 17, targetZoom));
}
        
// Enhanced stationary position calculation
function calculateStationaryPosition(buffer) {
  if (!buffer || buffer.length === 0) {
    return null
  }

  // Sort by accuracy (best first)
  const sortedBuffer = [...buffer].sort((a, b) => a.accuracy - b.accuracy)

  // Take weighted average of best positions
  const topPositions = sortedBuffer.slice(0, Math.ceil(buffer.length / 2))

  const weights = topPositions.map((pos) => 1 / Math.max(1, pos.accuracy))
  const totalWeight = weights.reduce((sum, w) => sum + w, 0)

  if (totalWeight === 0) {
    return sortedBuffer[0]
  }

  // Calculate weighted average
  const avgPosition = {
    lat: topPositions.reduce((sum, pos, i) => sum + pos.lat * weights[i], 0) / totalWeight,
    lng: topPositions.reduce((sum, pos, i) => sum + pos.lng * weights[i], 0) / totalWeight,
    accuracy: topPositions[0].accuracy,
    heading: topPositions[0].heading,
    timestamp: Date.now(),
    speedMPS: 0,
  }

  // If we have a previous stationary position, blend with it for stability
  if (lastStationaryPosition) {
    const blendFactor = 0.5 
    return {
      lat: lastStationaryPosition.lat * blendFactor + avgPosition.lat * (1 - blendFactor),
      lng: lastStationaryPosition.lng * blendFactor + avgPosition.lng * (1 - blendFactor),
      accuracy: avgPosition.accuracy,
      heading: avgPosition.heading,
      timestamp: avgPosition.timestamp,
      speedMPS: 0,
    }
  }

  return avgPosition
}

// Update stationary position history
function updateStationaryHistory(position) {
  // Add new position to history
  stationaryPositionHistory.push(position)

  // Keep history at maximum size
  while (stationaryPositionHistory.length > STATIONARY_POSITION_HISTORY_SIZE) {
    stationaryPositionHistory.shift()
  }

  // Calculate weighted average of positions
  let totalWeight = 0
  let weightedLat = 0
  let weightedLng = 0

  // Newer positions have higher weight
  for (let i = 0; i < stationaryPositionHistory.length; i++) {
    const pos = stationaryPositionHistory[i]
    const weight = Math.pow(STATIONARY_POSITION_WEIGHT_DECAY, stationaryPositionHistory.length - i - 1)
    totalWeight += weight
    weightedLat += pos.lat * weight
    weightedLng += pos.lng * weight
  }

  return {
    lat: weightedLat / totalWeight,
    lng: weightedLng / totalWeight,
    accuracy: position.accuracy,
    heading: position.heading,
    timestamp: position.timestamp,
    speedMPS: 0,
  }
}

// Check if device is in motion based on motion sensors
function isDeviceInMotion() {
  if (!motionSamples || motionSamples.length < 3) {
    return false
  }

  // Calculate average motion magnitude
  const avgMotion = motionSamples.reduce((sum, sample) => {
    return sum + Math.sqrt(sample.x * sample.x + sample.y * sample.y + sample.z * sample.z)
  }, 0) / motionSamples.length

  return avgMotion > MOTION_THRESHOLD
}

// Process device motion data
function handleDeviceMotion(event) {
  if (!event || !event.acceleration) return

  const motion = {
    x: event.acceleration.x || 0,
    y: event.acceleration.y || 0,
    z: event.acceleration.z || 0,
    timestamp: Date.now(),
  }

  // Add to motion samples
  motionSamples.push(motion)

  // Keep only recent samples
  while (motionSamples.length > MOTION_SAMPLE_SIZE) {
    motionSamples.shift()
  }

  // Update device motion state
  deviceMotion = motion

  // Check if device is stationary based on motion
  const inMotion = isDeviceInMotion()

  if (!inMotion) {
    deviceStationaryTime += MOTION_CHECK_INTERVAL
  } else {
    deviceStationaryTime = 0
  }
}

// Process device orientation data
function handleDeviceOrientation(event) {
  if (!event || event.alpha === null) return

  deviceOrientation = {
    alpha: event.alpha, // z-axis rotation [0,360)
    beta: event.beta, // x-axis rotation [-180,180)
    gamma: event.gamma, // y-axis rotation [-90,90)
    timestamp: Date.now(),
  }

  // Update heading buffer if we have a compass heading
  if (event.webkitCompassHeading !== undefined) {
    const heading = event.webkitCompassHeading

    // Add to heading buffer
    headingBuffer.push(heading)

    // Keep only recent headings
    while (headingBuffer.length > 5) {
      headingBuffer.shift()
    }

    // Calculate median heading to filter outliers
    if (headingBuffer.length >= 3) {
      const sortedHeadings = [...headingBuffer].sort((a, b) => a - b)
      lastHeadingValue = sortedHeadings[Math.floor(sortedHeadings.length / 2)]
    }
  }
}

// Request device motion and orientation permissions
function requestMotionPermission() {
  if (typeof DeviceMotionEvent !== "undefined" && typeof DeviceMotionEvent.requestPermission === "function") {
    DeviceMotionEvent.requestPermission()
      .then((response) => {
        if (response === "granted") {
          window.addEventListener("devicemotion", handleDeviceMotion, true)
        }
      })
      .catch(console.error)
  } else {
    window.addEventListener("devicemotion", handleDeviceMotion, true)
  }

  if (typeof DeviceOrientationEvent !== "undefined" && typeof DeviceOrientationEvent.requestPermission === "function") {
    DeviceOrientationEvent.requestPermission()
      .then((response) => {
        if (response === "granted") {
          orientationPermissionGranted = true
          window.addEventListener("deviceorientation", handleDeviceOrientation, true)
        }
      })
      .catch(console.error)
  } else {
    window.addEventListener("deviceorientation", handleDeviceOrientation, true)
    orientationPermissionGranted = true
  }
}

// Image preloading function
function preloadImages(locations) {
  return new Promise((resolve) => {
    if (!locations || locations.length === 0) {
      resolve()
      return
    }

    const totalImages = locations.length
    let loadedImages = 0
    const progressBar = document.getElementById("preloaderProgress")

    locations.forEach((location, index) => {
      if (!location.image) {
        loadedImages++
        updateProgress()
        if (loadedImages === totalImages) resolve()
        return
      }

      // Skip if already preloaded
      if (preloadedImages.has(location.image)) {
        loadedImages++
        updateProgress()
        if (loadedImages === totalImages) resolve()
        return
      }

      const img = new Image()
      img.crossOrigin = "anonymous" // Set crossOrigin for canvas operations
      img.onload = () => {
        preloadedImages.set(location.image, img)
        loadedImages++
        updateProgress()
        if (loadedImages === totalImages) resolve()
      }

      img.onerror = () => {
        console.warn(`Failed to load image: ${location.image}`)
        loadedImages++
        updateProgress()
        if (loadedImages === totalImages) resolve()
      }

      img.src = location.image
    })

    // Also preload audio files
    locations.forEach((location) => {
      if (location.audio && !preloadedAudio.has(location.audio)) {
        const audio = new Audio()
        audio.preload = "auto"
        audio.oncanplaythrough = () => {
          preloadedAudio.set(location.audio, audio)
        }
        audio.src = location.audio
      }
    })

    function updateProgress() {
      const percent = (loadedImages / totalImages) * 100
      domUpdateManager.schedule("preloaderProgress", () => {
        if (progressBar) {
          progressBar.style.width = `${percent}%`
        }
      })
    }
  })
}

// Detect sudden movements or position jumps
function detectSuddenMovement(newPosition, lastPosition, baseThreshold) {
  // Calculate distance between positions
  const distance = calculateDistance(lastPosition, newPosition);
  
  // Calculate time difference in seconds
  const timeDelta = (newPosition.timestamp - lastPosition.timestamp) / 1000;
  if (timeDelta <= 0) return false;
  
  // Calculate speed of movement
  const speed = distance / timeDelta;
  
  // Calculate adaptive threshold based on recent variance when stationary
  let adaptiveThreshold = baseThreshold;
  
  if (isStationary && stationaryPositionVariance) {
    // Calculate standard deviation and use it for threshold adjustment
    const latStdDev = Math.sqrt(stationaryPositionVariance.lat);
    const lngStdDev = Math.sqrt(stationaryPositionVariance.lng);
    
    // Convert lat/lng standard deviation to approximate meters
    const latMeters = latStdDev * 111320; // Rough conversion at equator
    const lngMeters = lngStdDev * 111320 * Math.cos(newPosition.lat * Math.PI/180);
    
    // Use maximum of standard deviations scaled by a factor
    const varianceBasedThreshold = Math.max(latMeters, lngMeters) * VARIANCE_SCALING_FACTOR;
    adaptiveThreshold = Math.max(baseThreshold, varianceBasedThreshold);
  }
  
  // Also consider accuracy in the threshold
  adaptiveThreshold = Math.max(adaptiveThreshold, newPosition.accuracy * 0.5);
  
  // Return true if movement exceeds the adaptive threshold
  return distance > adaptiveThreshold && speed > baseThreshold;
}

// Track if we're in frequent checking mode
let inFrequentCheckingMode = false;
let lastOutsideCheckTime = 0;
let currentTransition = null;

function checkProximityForZoom() {
    const ZOOM_CHANGE_COOLDOWN = 3000;
    const PROXIMITY_CHECK_RADIUS = 100; // Feet
    const ZOOM_OUT_BUFFER_PERCENT = 0.15; // 15% buffer for zooming out
    const OUTSIDE_CHECK_INTERVAL = 15000; // Check every 15 seconds when outside radius
    const ZOOM_TRANSITION_DURATION = 1200; // Longer, smoother transition
    const now = Date.now();
    
    // Basic rate limiting check
    if (now - lastProximityCheck < 1000) {
        return;
    }
    lastProximityCheck = now;
    
    // Don't check if zoom was recently changed
    if (now - lastZoomChangeTime < ZOOM_CHANGE_COOLDOWN) {
        return;
    }
    
    // If we're not in frequent checking mode, only check every OUTSIDE_CHECK_INTERVAL
    if (!inFrequentCheckingMode && now - lastOutsideCheckTime < OUTSIDE_CHECK_INTERVAL) {
        return;
    }
    
    // Safety checks for required variables
    if (!userMarker || !gameLocations || gameLocations.length === 0) {
        console.log("Missing required objects for proximity check");
        return;
    }
    
    const userLatLng = userMarker.getLatLng();
    
    // Validate user coordinates
    if (!userLatLng || typeof userLatLng.lat !== 'number' || typeof userLatLng.lng !== 'number' || 
        isNaN(userLatLng.lat) || isNaN(userLatLng.lng)) {
        console.log("Invalid user coordinates");
        return;
    }
    
    const userPos = { lat: userLatLng.lat, lng: userLatLng.lng };
    
    // Find closest location
    let closestDistance = Infinity;
    let closestLocation = null;
    
    for (const location of gameLocations) {
        if (!location || typeof location.lat !== 'number' || typeof location.lng !== 'number' || 
            isNaN(location.lat) || isNaN(location.lng)) {
            continue;
        }
        
        const locationPos = { lat: location.lat, lng: location.lng };
        const distance = calculateDistance(userPos, locationPos);
        
        if (isFinite(distance) && distance < closestDistance) {
            closestDistance = distance;
            closestLocation = location;
        }
    }
    
    // If no valid locations found, exit
    if (!closestLocation || !isFinite(closestDistance)) {
        console.log("No valid locations found");
        lastOutsideCheckTime = now;
        inFrequentCheckingMode = false;
        return;
    }
    
    // Convert to feet for threshold comparison
    const distanceFeet = Math.round(closestDistance * 3.28084);
    
    // Calculate zoom out threshold with 15% buffer
    const zoomOutThreshold = Math.round(PROXIMITY_THRESHOLD * (1 + ZOOM_OUT_BUFFER_PERCENT));
    
    // Check if we should be in frequent checking mode
    if (distanceFeet <= PROXIMITY_CHECK_RADIUS) {
        if (!inFrequentCheckingMode) {
            console.log(`Entering frequent proximity check mode (${distanceFeet}ft)`);
            inFrequentCheckingMode = true;
        }
    } else {
        if (inFrequentCheckingMode) {
            console.log(`Exiting frequent proximity check mode (${distanceFeet}ft)`);
            inFrequentCheckingMode = false;
        }
        lastOutsideCheckTime = now;
    }
    
    console.log(`Distance to closest location: ${distanceFeet}ft (Threshold In: ${PROXIMITY_THRESHOLD}ft, Out: ${zoomOutThreshold}ft)`);
    
    // Cancel any ongoing transition
    if (currentTransition) {
        clearInterval(currentTransition);
        currentTransition = null;
    }
    
    // Enhanced smooth zoom logic
    if (!isNearLocation && distanceFeet <= PROXIMITY_THRESHOLD) {
        // User has entered the proximity zone - smooth zoom in
        console.log(`User entered proximity zone (${distanceFeet}ft), smoothly zooming in`);
        isNearLocation = true;
        lastZoomChangeTime = now;
        
        smoothZoomTo(18, ZOOM_TRANSITION_DURATION);
        
    } else if (isNearLocation && distanceFeet >= zoomOutThreshold) {
        // User has left the proximity zone - smooth zoom out
        console.log(`User left proximity zone (${distanceFeet}ft > ${zoomOutThreshold}ft), smoothly zooming out`);
        isNearLocation = false;
        lastZoomChangeTime = now;
        
        smoothZoomTo(17, ZOOM_TRANSITION_DURATION);
    }
    
    // Update for next time
    lastProximityDistance = closestDistance;
}

// Smooth zoom function that uses easing and lerp
function smoothZoomTo(targetZoom, duration) {
    const startZoom = map.getZoom();
    const startTime = Date.now();
    
    // Don't zoom if we're already at target
    if (Math.abs(targetZoom - startZoom) < 0.01) return;
    
    // Clear any existing transition
    if (currentTransition) {
        clearInterval(currentTransition);
    }
    
    currentTransition = setInterval(() => {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        // Calculate easing factor (easeInOutCubic)
        const easedProgress = progress < 0.5 
            ? 4 * progress * progress * progress 
            : 1 - Math.pow(-2 * progress + 2, 3) / 2;
        
        // Use lerp for the actual interpolation
        const newZoom = lerp(startZoom, targetZoom, easedProgress);
        
        map.setZoom(newZoom, { animate: false });
        
        if (progress >= 1) {
            clearInterval(currentTransition);
            currentTransition = null;
            
            // Ensure we end exactly at target zoom
            map.setZoom(targetZoom, { animate: false });
        }
    }, 16); // ~60fps for smooth animation
}
        
function initMap() {
  // Leaflet library
  const L = window.L;
  
  // Map initialization - using globally declared variables
map = L.map("map", {
    zoomControl: false,
    attributionControl: false,
    zoomSnap: 0.1,
    zoomDelta: 0.5,
    wheelDebounceTime: 50, 
    tapTolerance: 10, 
    bounceAtZoomLimits: false,
    preferCanvas: true,
    renderer: L.canvas({ padding: 1.0 }), 
    fadeAnimation: true, 
    markerZoomAnimation: true 
}).fitWorld();
  
L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    maxZoom: 18, 
    attribution: "© OpenStreetMap contributors",
    updateWhenIdle: true,  
    updateWhenZooming: false,  
    keepBuffer: 2,  
    detectRetina: true,  
    reuseTiles: true  
}).addTo(map);
  
  // Initialize marker cluster group
  markerClusterGroup = L.markerClusterGroup({
    showCoverageOnHover: false,
    zoomToBoundsOnClick: true,
    spiderfyOnMaxZoom: true,
    chunkedLoading: true, 
    chunkDelay: 100, 
    animate: true,
    animateAddingMarkers: true,
    disableClusteringAtZoom: 17,
    maxClusterRadius: 60,
    iconCreateFunction: (cluster) =>
      L.divIcon({
        html: "<div><span>" + cluster.getChildCount() + "</span></div>",
        className: "marker-cluster-custom",
        iconSize: L.point(40, 40),
      }),
  });
  
  map.addLayer(markerClusterGroup);
  
  // Create user icon with custom styling
  const userIcon = L.divIcon({
    className: 'user-marker',
    html: '<div class="user-marker-icon"></div>',
    iconSize: [20, 20],
    iconAnchor: [10, 10] // Center the icon precisely
  });
  
  // Initialize user marker with a higher z-index to ensure visibility
  userMarker = L.marker([0, 0], { 
    icon: userIcon,
    zIndexOffset: 1000, // Ensure user marker is on top
    interactive: true, // Prevent marker from being clickable
    bubblingMouseEvents: false // Prevent events from bubbling
  }).addTo(map);
  
  // Store map viewport dimensions
  updateMapViewportDimensions();
  showLoadingMessage();
  
  // Request motion and orientation permissions
  requestMotionPermission();
  
  // Initialize geolocation tracking
  initGeolocation();
  
  // Handle visibility changes (tab switching, app in background)
  document.addEventListener("visibilitychange", handleVisibilityChange);
  
  // Track when the user is manually interacting with the map
  let userInteractionTimeout;
  
  map.on("movestart zoomstart dragstart", () => {
    followUser = false;
    isMapInteracting = true;
    userIsManuallyNavigating = true;
    
    // Clear any existing timers
    clearTimeout(userInteractionTimeout);
  });
  
  map.on("moveend zoomend dragend", () => {
    isMapInteracting = false;
    resetInactivityTimer();
    updateMapViewportDimensions();
    
    // Set a timer to re-enable auto-follow after period of inactivity
    clearTimeout(userInteractionTimeout);
    userInteractionTimeout = setTimeout(() => {
      userIsManuallyNavigating = false;
      // Only re-enable follow mode if we're not currently interacting
      if (!isMapInteracting) {
        followUser = true;
        // Update user marker position immediately
        if (lastKnownPosition) {
          updateUserMarkerPosition(lastKnownPosition);
        }
      }
    }, INACTIVITY_TIMEOUT); // 30 seconds of inactivity before re-enabling follow
  });
  
  // Listen for resize events to update viewport dimensions
  window.addEventListener("resize", () => {
    updateMapViewportDimensions();
    // Re-center user marker if in follow mode
    if (followUser && lastKnownPosition) {
      updateUserMarkerPosition(lastKnownPosition);
    }
  });
  
  // Start animation loop for smooth rendering
  startAnimationLoop();
  
  // Enable touch interactions
  map.touchZoom.enable();
  map.doubleClickZoom.enable();
  
  // Add CSS for user marker direction indicator
  addUserMarkerStyles();
}

// Add CSS styles for user marker direction indicator
function addUserMarkerStyles() {
  const style = document.createElement("style")
  style.textContent = `
        .user-marker-icon {
            width: 16px;
            height: 16px;
            background-color: #ff3b30;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            position: relative;
        }
        
        .user-marker-direction {
            position: absolute;
            top: -4px;
            left: 50%;
            margin-left: -2px;
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-bottom: 12px solid #ff3b30;
            transform-origin: center bottom;
            z-index: -1;
        }
        
        .user-marker-icon.pulsing {
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(1.2);
                opacity: 0.8;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }
    `
  document.head.appendChild(style)
}

// Initialize geolocation with priority for Geolocation Sensor API
function initGeolocation() {
  // Declaring GeolocationSensor here
  const GeolocationSensor = window.GeolocationSensor

  if ("GeolocationSensor" in window) {
    try {
      console.log("Trying GeolocationSensor API")
      geolocationSensor = new GeolocationSensor({ frequency: 1 })

      geolocationSensor.addEventListener("reading", () => {
        const position = {
          coords: {
            latitude: geolocationSensor.latitude,
            longitude: geolocationSensor.longitude,
            accuracy: geolocationSensor.accuracy,
            altitude: geolocationSensor.altitude,
            altitudeAccuracy: geolocationSensor.altitudeAccuracy,
            heading: geolocationSensor.heading,
            speed: geolocationSensor.speed,
          },
          timestamp: geolocationSensor.timestamp,
        }

        if (!lastPosition) {
          initializeUserLocation(position)
        } else {
          handlePositionUpdate(position)
        }
      })

      geolocationSensor.addEventListener("error", (error) => {
        console.warn("GeolocationSensor error:", error)
        // Fall back to standard Geolocation API
        useStandardGeolocation()
      })

      geolocationSensor.start()
      usingGeolocationSensorAPI = true
      console.log("Using GeolocationSensor API")
    } catch (error) {
      console.warn("GeolocationSensor error:", error)
      // Fall back to standard Geolocation API
      useStandardGeolocation()
    }
  } else {
    // Fall back to standard Geolocation API
    useStandardGeolocation()
  }
}

// Update map viewport dimensions
function updateMapViewportDimensions() {
  if (map && map._container) {
    mapViewportWidth = map._container.clientWidth
    mapViewportHeight = map._container.clientHeight

    // Store current map center and zoom
    if (map.getCenter()) {
      lastMapCenter = map.getCenter()
      lastMapZoom = map.getZoom()
    }
  }
}

// Standard Geolocation API fallback
function useStandardGeolocation() {
  console.log("Using standard Geolocation API");
  usingGeolocationSensorAPI = false;
  
  if ("geolocation" in navigator) {
    const options = {
      enableHighAccuracy: true,
      timeout: 15000, // Reduced timeout for faster fallback
      maximumAge: 0,
    };
    
    // Track retry attempts
    let retryCount = 0;
    const maxRetries = 2;
    
    // Function to handle successful position acquisition
    function handleGeolocationSuccess(position) {
      if (!lastPosition) {
        initializeUserLocation(position);
      } else {
        handlePositionUpdate(position);
      }
      
      // Store this position as our last known position for recovery
      lastKnownPosition = position;
      
      // Start continuous watching after initial position
      if (watchPositionId === null) {
        startWatchPosition();
      }
    }
    
    // Function to handle geolocation errors with retry logic
    function handleGeolocationRetry(error) {
      console.warn(`Geolocation error (attempt ${retryCount + 1}/${maxRetries + 1}):`, error.code, error.message);
      
      retryCount++;
      if (retryCount <= maxRetries) {
        console.log(`Retrying geolocation (attempt ${retryCount + 1}/${maxRetries + 1})...`);
        navigator.geolocation.getCurrentPosition(handleGeolocationSuccess, handleGeolocationRetry, options);
      } else {
        handleLocationError(error);
      }
    }
    
    // Function to start continuous position watching
    function startWatchPosition() {
      // Clear any existing watch
      if (watchPositionId !== null) {
        navigator.geolocation.clearWatch(watchPositionId);
      }
      
      // Set up continuous location watching
      watchPositionId = navigator.geolocation.watchPosition(
        handlePositionUpdate,
        (error) => {
          console.warn("Watch position error:", error.code, error.message);
          
          // If watching fails, try to restart after a short delay
          if (watchPositionId !== null) {
            navigator.geolocation.clearWatch(watchPositionId);
            watchPositionId = null;
            
            setTimeout(() => {
              if (watchPositionId === null) {
                startWatchPosition();
              }
            }, 5000);
          }
        },
        {
          ...options,
          timeout: 27000, // Longer timeout for continuous watching
        }
      );
    }
    
    // Initial position acquisition
    navigator.geolocation.getCurrentPosition(handleGeolocationSuccess, handleGeolocationRetry, options);
  } else {
    showPopup("Geolocation is not supported by your browser");
    map.setView([44.9778, -93.265], 17); // Default view (Minneapolis)
    hideLoadingMessage();
    
    // Add a manual location button as fallback
    addManualLocationButton();
  }
}

// Variables for dynamic zoom functionality
let speedSamples = [];
const MAX_SPEED_SAMPLES = 5;
let lastSpeedForZoom = 0;
let targetZoomLevel = MAX_ZOOM_LEVEL;
let lastZoomUpdateTime = 0;
const ZOOM_UPDATE_INTERVAL = 300; // ms - interval between zoom updates
let zoomTransitionInProgress = false;

// Update speed samples for dynamic zoom
function updateSpeedSamples(position) {
  // Add speed to samples (default to 0 if not available)
  speedSamples.push(position?.speedMPS || 0);
  
  // Keep only recent samples
  while (speedSamples.length > MAX_SPEED_SAMPLES) {
    speedSamples.shift();
  }
}

// Update zoom level based on speed with improved responsiveness
function updateDynamicZoom() {
  const now = Date.now();
  
  // Reduce update interval to improve responsiveness
  // Use a shorter interval (e.g., 100ms instead of whatever ZOOM_UPDATE_INTERVAL was)
  if (now - lastZoomUpdateTime < 100) return;
  lastZoomUpdateTime = now;
  
  // Allow updates during map interaction if they're minor adjustments
  // This prevents completely blocking zoom updates during extended interactions
  if ((isMapInteracting || userIsInteracting) && !zoomTransitionInProgress) {
    // If user is interacting, only allow small zoom adjustments to avoid disruption
    const currentZoom = map ? map.getZoom() : targetZoomLevel;
    if (Math.abs(currentZoom - targetZoomLevel) > 1.5) return;
  } else if (zoomTransitionInProgress) {
    return; // Still block during transitions
  }
  
  // Skip if not in follow mode
  if (!followUser) return;
  
  // Calculate average speed from samples with more weight on recent values
  let avgSpeed;
  if (speedSamples.length > 0) {
    // Give more weight to recent samples
    const totalWeight = speedSamples.length * (speedSamples.length + 1) / 2;
    let weightedSum = 0;
    
    for (let i = 0; i < speedSamples.length; i++) {
      // Weight increases with recency (index)
      const weight = i + 1;
      weightedSum += speedSamples[i] * weight;
    }
    
    avgSpeed = weightedSum / totalWeight;
  } else {
    avgSpeed = lastPosition?.speedMPS || 0;
  }
  
  // Apply more responsive exponential smoothing for speed changes
  const smoothingAlpha = 0.4; // More responsive value (was 0.3)
  const smoothedSpeed = lastSpeedForZoom * (1 - smoothingAlpha) + avgSpeed * smoothingAlpha;
  lastSpeedForZoom = smoothedSpeed;
  
  // Calculate optimal zoom level
  const optimalZoom = calculateZoomLevel(smoothedSpeed);
  
  // Reduce threshold for zoom updates to make them more responsive
  if (Math.abs(optimalZoom - targetZoomLevel) >= 0.15) { // Was 0.2
    targetZoomLevel = optimalZoom;
    
    // Apply zoom change with smooth animation
    if (map && followUser) {
      const currentZoom = map.getZoom();
      const zoomDiff = Math.abs(currentZoom - targetZoomLevel);
      
      // Use faster transition for all zoom changes
      const duration = zoomDiff > 0.5 ? 200 : 300; // Faster transitions overall
      
      // Track zoom transition state
      zoomTransitionInProgress = true;
      
      // Perform the zoom
      map.setZoom(targetZoomLevel, {
        animate: true,
        duration: duration,
        noMoveStart: true,
      });
      
      // Reset transition flag after animation completes
      // Use a shorter buffer time
      setTimeout(() => {
        zoomTransitionInProgress = false;
        // Re-center on user position after zoom completes
        if (followUser && lastPosition) {
          updateUserMarkerPosition(lastPosition);
        }
      }, duration + 25); 
    }
  }
}

function calculateOptimalZoom(speed) {
  // Ensure speed is non-negative
  speed = Math.max(0, speed);
  
  // Stationary, walking, running, biking (zoom 17)
  if (speed < DRIVING_CITY_THRESHOLD) {
    return 17;
  }
  // City driving (zoom 16)
  else if (speed < DRIVING_HIGHWAY_THRESHOLD) {
    return 16;
  }
  // Highway/fast driving (zoom 15)
  else {
    return 15;
  }
}
        
// Enhanced motion detection for better accuracy
function enhancedMotionDetection(deviceMotion, motionSamples) {
  // Early return if insufficient data
  if (!deviceMotion || !motionSamples || motionSamples.length < 5) {
    return false;
  }

  const squaredThreshold = MOTION_THRESHOLD * MOTION_THRESHOLD;
  const magnitudes = new Array(motionSamples.length);
  let sum = 0;

  // Single-pass magnitude + sum calculation
  for (let i = 0; i < motionSamples.length; i++) {
    const { x, y, z } = motionSamples[i];
    magnitudes[i] = x * x + y * y + z * z;
    sum += magnitudes[i];
  }

  const avgMagnitude = sum / motionSamples.length;

  // Early exit if average magnitude exceeds threshold
  if (Math.sqrt(avgMagnitude) > MOTION_THRESHOLD) {
    return true;
  }

  // Variance calculation
  let varianceSum = 0;
  for (let i = 0; i < magnitudes.length; i++) {
    varianceSum += Math.pow(magnitudes[i] - avgMagnitude, 2);
  }
  const variance = varianceSum / magnitudes.length;

  // Dynamic threshold adjustment
  const thresholdFactor = lerp(0.4, 0.6, Math.min(1, variance / squaredThreshold));
  return variance > squaredThreshold * thresholdFactor;
}

// Improved position prediction for smoother tracking
function predictNextPosition(position, velocity, deltaTime) {
  if (!position || !velocity || !deltaTime) return position
  
  return {
    lat: position.lat + velocity.lat * deltaTime,
    lng: position.lng + velocity.lng * deltaTime,
    accuracy: position.accuracy,
    heading: position.heading,
    timestamp: position.timestamp + deltaTime * 1000,
    speedMPS: position.speedMPS
  }
}

// Advanced animation loop with adaptive performance management
function startAnimationLoop() {
  // Performance monitoring
  let lastFrameTime = performance.now();
  let frameCount = 0;
  let frameRateCheckTime = performance.now();
  let currentFPS = 60;
  let targetFPS = 60;
  let performanceMode = 'high'; // 'high', 'medium', 'low'
  
  // Operation scheduling
  let lastEdgeCheckTime = 0;
  let lastProximityCheckTime = 0;
  let lastPerformanceCheckTime = 0;
  
  // Edge check frequency adapts to movement speed and performance
  const EDGE_CHECK_INTERVAL = { high: 50, medium: 100, low: 200 };
  const PROXIMITY_CHECK_INTERVAL = { high: 300, medium: 500, low: 1000 };
  const PERFORMANCE_CHECK_INTERVAL = 2000;
  
  // Predictive positioning
  let lastKnownVelocity = { x: 0, y: 0 };
  let lastPositionUpdateTime = 0;
  let isMoving = false;
  let movementPredictionEnabled = true;
  
  // Background detection
  let isInBackground = false;
  let backgroundTransitionTime = 0;
  
  // Battery status
  let isBatteryLow = false;
  let batteryManager = null;
  
  // Initialize battery monitoring if available
  if ('getBattery' in navigator) {
    navigator.getBattery().then(battery => {
      batteryManager = battery;
      updateBatteryStatus();
      
      battery.addEventListener('levelchange', updateBatteryStatus);
      battery.addEventListener('chargingchange', updateBatteryStatus);
      
      function updateBatteryStatus() {
        isBatteryLow = battery.level < 0.2 && !battery.charging;
        adjustPerformanceMode();
      }
    });
  }
  
  // Handle visibility change
  document.addEventListener('visibilitychange', () => {
    isInBackground = document.hidden;
    backgroundTransitionTime = performance.now();
    
    if (isInBackground) {
      // Reduce processing when in background
      targetFPS = 5;
    } else {
      // Resume normal processing
      targetFPS = 60;
      // Force immediate position update when returning to foreground
      lastPositionUpdateTime = 0;
      // Reset frame monitoring
      frameRateCheckTime = performance.now();
      frameCount = 0;
    }
  });
  
  // Adjust performance mode based on FPS and battery
  function adjustPerformanceMode() {
    if (isBatteryLow) {
      performanceMode = 'low';
    } else if (currentFPS < 30) {
      performanceMode = 'low';
    } else if (currentFPS < 45) {
      performanceMode = 'medium';
    } else {
      performanceMode = 'high';
    }
    
    // Only enable prediction in high or medium performance modes
    movementPredictionEnabled = performanceMode !== 'low';
  }
  
  // Calculate and update velocity based on position changes
  function updateVelocity(newPosition) {
    if (!lastRenderPosition || !newPosition) return;
    
    const timeDelta = performance.now() - lastPositionUpdateTime;
    if (timeDelta > 0) {
      // Calculate pixels moved per millisecond
      lastKnownVelocity = {
        x: (newPosition.x - lastRenderPosition.x) / timeDelta,
        y: (newPosition.y - lastRenderPosition.y) / timeDelta
      };
      
      // Determine if currently moving (with small threshold to avoid minor fluctuations)
      const speed = Math.sqrt(
        lastKnownVelocity.x * lastKnownVelocity.x + 
        lastKnownVelocity.y * lastKnownVelocity.y
      );
      isMoving = speed > 0.0001;
    }
    
    lastPositionUpdateTime = performance.now();
  }
  
  // Predict position based on velocity and time since last update
  function getPredictedPosition() {
    if (!lastRenderPosition || !isMoving || !movementPredictionEnabled) {
      return lastRenderPosition;
    }
    
    const timeSinceUpdate = performance.now() - lastPositionUpdateTime;
    
    // Only predict up to 500ms ahead to avoid extreme extrapolation
    if (timeSinceUpdate > 500) return lastRenderPosition;
    
    return {
      x: lastRenderPosition.x + lastKnownVelocity.x * timeSinceUpdate,
      y: lastRenderPosition.y + lastKnownVelocity.y * timeSinceUpdate,
      heading: lastRenderPosition.heading
    };
  }
  
  // Process updates with priority during performance constraints
  function processPrioritizedUpdates(timestamp, deltaTime) {
    // Always process position updates
    const positionUpdated = processPositionUpdateQueue();
    
    // Update interpolated position (highest priority)
    let positionChanged = false;
    if (positionInterpolator && positionInterpolator.isInterpolating()) {
      const interpolatedPosition = positionInterpolator.update(deltaTime);
      if (interpolatedPosition) {
        updateUserMarkerPosition(interpolatedPosition);
        lastRenderPosition = interpolatedPosition;
        positionChanged = true;
        
        // Update velocity for prediction
        updateVelocity(interpolatedPosition);
      }
    } else if (isMoving && movementPredictionEnabled) {
      // Apply prediction when not interpolating but still moving
      const predictedPosition = getPredictedPosition();
      if (predictedPosition && predictedPosition !== lastRenderPosition) {
        updateUserMarkerPosition(predictedPosition);
        positionChanged = true;
      }
    }
    
    // Edge recentering (medium priority)
    // Only check if following user, not interacting, and enough time has passed
    const edgeCheckInterval = EDGE_CHECK_INTERVAL[performanceMode];
    if (followUser && !isMapInteracting && !edgeRecenterInProgress && 
        timestamp - lastEdgeCheckTime > edgeCheckInterval) {
      
      lastEdgeCheckTime = timestamp;
      
      // Skip edge checks if we haven't moved
      if (positionChanged || positionUpdated) {
        const recenterInfo = shouldRecenter(map, userMarker);
        if (recenterInfo.needsRecenter) {
          performEdgeRecenter(recenterInfo);
        }
      }
    }
    
    // Proximity checks (lowest priority)
    // Run less frequently, especially in lower performance modes
    const proximityCheckInterval = PROXIMITY_CHECK_INTERVAL[performanceMode];
    if (timestamp - lastProximityCheckTime > proximityCheckInterval) {
      lastProximityCheckTime = timestamp;
      checkProximityForZoom();
    }
    
    // Performance monitoring
    if (timestamp - lastPerformanceCheckTime > PERFORMANCE_CHECK_INTERVAL) {
      lastPerformanceCheckTime = timestamp;
      
      // Calculate FPS
      const timeElapsed = (timestamp - frameRateCheckTime) / 1000;
      currentFPS = Math.round(frameCount / timeElapsed);
      
      // Reset counters
      frameRateCheckTime = timestamp;
      frameCount = 0;
      
      // Adjust performance mode based on measured performance
      adjustPerformanceMode();
    }
  }
  
  //Main animation frame function
  function animate(timestamp) {
    // Increment frame counter for FPS calculation
    frameCount++;
    
    // Calculate time since last frame
    const timeSinceLastFrame = lastFrameTime ? timestamp - lastFrameTime : 16.7;
    const deltaTime = timeSinceLastFrame / 1000; // Convert to seconds
    lastFrameTime = timestamp;
    renderTimestamp = timestamp;
    
    // Handle background throttling
    if (isInBackground) {
      // Minimal processing in background
      if (positionInterpolator && positionInterpolator.isInterpolating()) {
        positionInterpolator.update(deltaTime);
      }
      animationFrameId = requestAnimationFrame(animate);
      return;
    }
    
    // Handle resuming from background
    if (timestamp - backgroundTransitionTime < 1000 && backgroundTransitionTime > 0) {
      // Force immediate full update when returning to foreground
      lastEdgeCheckTime = 0;
      lastProximityCheckTime = 0;
    }
    
    // Process updates with priority system
    processPrioritizedUpdates(timestamp, deltaTime);
    
    // Schedule next frame with frame rate limiting if needed
    if (performanceMode === 'low' && targetFPS < 60) {
      // Simple frame limiting for low power mode
      const targetFrameTime = 1000 / targetFPS;
      const nextFrameDelay = Math.max(0, targetFrameTime - timeSinceLastFrame);
      
      if (nextFrameDelay > 0) {
        setTimeout(() => {
          animationFrameId = requestAnimationFrame(animate);
        }, nextFrameDelay);
      } else {
        animationFrameId = requestAnimationFrame(animate);
      }
    } else {
      animationFrameId = requestAnimationFrame(animate);
    }
  }
  
  // Cancel any existing animation frame before starting
  if (animationFrameId) {
    cancelAnimationFrame(animationFrameId);
  }
  
  // Start animation loop
  animationFrameId = requestAnimationFrame(animate);
  
  // Return control functions that can be called externally
  return {
    setPerformanceMode: (mode) => {
      if (['high', 'medium', 'low'].includes(mode)) {
        performanceMode = mode;
      }
    },
    getPerformanceStats: () => ({
      fps: currentFPS,
      mode: performanceMode,
      batteryLow: isBatteryLow,
      isMoving
    })
  };
}

// Process a single position update
function processPositionUpdate(position) {
  if (!position) return;

  // Immediate marker update
  updateUserMarkerPosition(position);

  if (followUser && !isMapInteracting) {
    const speed = position.speedMPS || 0;
    const zoomLevel = calculateZoomLevel(speed);
    
    // Your predictive offset logic (unchanged)
    let mapCenter = [position.lat, position.lng];
    if (speed > 3 && lastRenderPosition && position.heading !== undefined) {
      const headingRad = position.heading * (Math.PI / 180);
      const offset = speed * 0.000005;
      mapCenter = [
        position.lat + Math.cos(headingRad) * offset,
        position.lng + Math.sin(headingRad) * offset
      ];
    }

    // Smart animation decision
    if (speed > 5) {
      // Fast movement: minimal animation
      map.setView(mapCenter, zoomLevel, { animate: false });
    } else {
      // Normal movement: smooth but controlled animation
      map.flyTo(mapCenter, zoomLevel, {
        animate: true,
        duration: 0.3,
        noMoveStart: true,
        easeLinearity: 0.3
      });
    }
  }

  lastRenderPosition = position;
  updateDistanceBox();
  checkProximityForZoom();
}

// State tracking variables for position smoothing
let smoothingBuffer = [];
const MAX_SMOOTHING_SAMPLES = 5; // Increased for better smoothing
let lastCenterTime = 0;
const MAP_CENTERING_THROTTLE_MS = 200; // Limit map centering frequency
let lastHeading = null;
let isRotationTransitioning = false;

// Enhanced user marker position update function
function updateUserMarkerPosition(position) {
  if (!userMarker || !position || position.lat === undefined || position.lng === undefined) return;
  
  const currentTime = Date.now();
  const speed = position.speedMPS !== undefined ? position.speedMPS : 0;
  
  // ALWAYS-ON SMOOTHING (regardless of speed)
  // Add to smoothing buffer
  smoothingBuffer.push(position);
  
  // Keep buffer at appropriate size
  if (smoothingBuffer.length > MAX_SMOOTHING_SAMPLES) {
    smoothingBuffer.shift();
  }
  
  let smoothedPosition = position;
  
  // ADAPTIVE WEIGHTING based on speed
  if (smoothingBuffer.length >= 2) {
    // Dynamically adjust weights based on speed
    // At higher speeds, favor recent positions more heavily
    const baseWeight = 0.5;
    const speedFactor = Math.min(1, speed / 10); // Normalize speed influence
    
    // Generate weights array that decays faster at higher speeds
    const weights = [];
    let totalWeight = 0;
    
    for (let i = 0; i < smoothingBuffer.length; i++) {
      // More recent positions (higher index) get higher weights
      const age = smoothingBuffer.length - 1 - i;
      // Exponential decay that's more aggressive at higher speeds
      const weight = baseWeight * Math.pow(1 - (speedFactor * 0.5), age);
      weights[i] = weight;
      totalWeight += weight;
    }
    
    // Normalize weights
    for (let i = 0; i < weights.length; i++) {
      weights[i] = weights[i] / totalWeight;
    }
    
    // Calculate weighted average of positions
    let lat = 0, lng = 0;
    for (let i = 0; i < smoothingBuffer.length; i++) {
      lat += smoothingBuffer[i].lat * weights[i];
      lng += smoothingBuffer[i].lng * weights[i];
    }
    
    // Create smoothed position
    smoothedPosition = {
      ...position,
      lat: lat,
      lng: lng
    };
  }
  
  // Update marker position with smoothed coordinates
  userMarker.setLatLng([smoothedPosition.lat, smoothedPosition.lng]);
  
  // CONTROLLED MAP CENTERING with LOOK-AHEAD POSITIONING
  if (followUser && !isMapInteracting && !edgeRecenterInProgress) {
    // Throttle map updates to avoid excessive recentering
    if (currentTime - lastCenterTime > MAP_CENTERING_THROTTLE_MS) {
      // Calculate look-ahead offset based on speed and heading
      let centerLat = smoothedPosition.lat;
      let centerLng = smoothedPosition.lng;
      
      // Only apply look-ahead when actually moving
      if (speed > 0.5 && position.heading !== undefined) {
        // Convert heading to radians
        const headingRad = (position.heading * Math.PI) / 180;
        
        // Calculate offset distance based on speed (stronger at higher speeds)
        const offsetFactor = Math.min(0.0002, speed * 0.00002);
        
        // Apply offset in direction of travel
        centerLat += offsetFactor * Math.cos(headingRad);
        centerLng += offsetFactor * Math.sin(headingRad);
      }
      
      // Use flyTo for smoother animation
      map.flyTo([centerLat, centerLng], map.getZoom(), {
        animate: true,
        duration: 0.4,
        noMoveStart: true,
        easeLinearity: 0.5
      });
      
      lastCenterTime = currentTime;
    }
  }
  
  // SMOOTH ROTATION for heading changes
  if (position.heading !== undefined && position.heading !== null) {
    const markerElement = userMarker.getElement();
    if (markerElement) {
      const directionElement = markerElement.querySelector(".user-marker-direction");
      if (directionElement) {
        // Initialize lastHeading if not set
        if (lastHeading === null) {
          lastHeading = position.heading;
        }
        
        // Detect significant heading change that needs transition
        const headingDiff = Math.abs(position.heading - lastHeading);
        const needsSmoothing = headingDiff > 5 && headingDiff < 180;
        
        if (needsSmoothing && !isRotationTransitioning) {
          isRotationTransitioning = true;
          
          // Add transition temporarily for smooth rotation
          directionElement.style.transition = "transform 0.5s ease-out";
          
          // After transition completes, remove the transition property
          setTimeout(() => {
            directionElement.style.transition = "";
            isRotationTransitioning = false;
          }, 500);
        }
        
        // Update the rotation
        directionElement.style.transform = `rotate(${position.heading}deg)`;
        lastHeading = position.heading;
      }
    }
  }
  
  // Check if marker is near the edge of the visible map
  const mapBounds = map.getBounds();
  const markerPos = userMarker.getLatLng();
  const bufferRatio = 0.15; // Buffer zone of 15% from edge
  
  const latRange = Math.abs(mapBounds.getNorth() - mapBounds.getSouth());
  const lngRange = Math.abs(mapBounds.getEast() - mapBounds.getWest());
  
  const latBuffer = latRange * bufferRatio;
  const lngBuffer = lngRange * bufferRatio;
  
  const isNearEdge = 
    markerPos.lat > (mapBounds.getNorth() - latBuffer) ||
    markerPos.lat < (mapBounds.getSouth() + latBuffer) ||
    markerPos.lng > (mapBounds.getEast() - lngBuffer) ||
    markerPos.lng < (mapBounds.getWest() + lngBuffer);
  
  // Force recenter if near edge and following user
  if (isNearEdge && followUser && !isMapInteracting && !edgeRecenterInProgress) {
    edgeRecenterInProgress = true;
    
    // Immediate centering for edge case
    map.flyTo([smoothedPosition.lat, smoothedPosition.lng], map.getZoom(), {
      animate: true,
      duration: 0.3,
      noMoveStart: true
    });
    
    // Reset edge recenter flag after animation
    setTimeout(() => {
      edgeRecenterInProgress = false;
    }, 300);
  }
  
  // TRANSITION EFFECTS for visual changes
  if (position.speedMPS !== undefined && !isNaN(position.speedMPS)) {
    const markerElement = userMarker.getElement();
    if (markerElement) {
      const iconElement = markerElement.querySelector(".user-marker-icon");
      if (iconElement) {
        // Ensure transitions are enabled for visual smoothness
        if (!iconElement.style.transition) {
          iconElement.style.transition = "all 0.3s ease-out";
        }
        
        // Add pulsing effect when moving
        if (speed > 0.5) {
          // Only add class if not already present to avoid restarting animation
          if (!iconElement.classList.contains("pulsing")) {
            iconElement.classList.add("pulsing");
          }
          
          // Adjust pulse speed based on movement speed with smooth transition
          const pulseRate = Math.max(0.5, Math.min(2.0, 1.0 + speed / 5));
          iconElement.style.animationDuration = `${1 / pulseRate}s`;
          
          // Scale marker slightly based on speed for visual feedback
          const scaleFactor = Math.min(1.2, 1 + speed / 20);
          iconElement.style.transform = `scale(${scaleFactor})`;
        } else {
          // Graceful transition to static state
          iconElement.classList.remove("pulsing");
          iconElement.style.transform = "scale(1)";
          iconElement.style.animationDuration = "";
        }
      }
    }
  }
  
  // Update last rendered position for other functions
  lastRenderPosition = smoothedPosition;
}
        
// Process position update queue
function processPositionUpdateQueue() {
  if (positionUpdateQueue.length === 0) return
  
  // Only process the oldest position update in the queue
  // This allows for smoother transitions between positions
  const update = positionUpdateQueue.shift()
  processPositionUpdate(update)
  
  // If we still have items in the queue, schedule the next update
  if (positionUpdateQueue.length > 0) {
    requestAnimationFrame(processPositionUpdateQueue)
  }
}

// Add these variables to your existing scope
const BACKGROUND_THRESHOLD_MS = 1500; // 1.5 seconds threshold to detect background

function processPositionUpdate(position) {
  // Calculate time since last update to detect background state
  const currentTime = Date.now();
  const timeSinceLastUpdate = currentTime - lastUpdateTime;
  const possibleBackgroundTransition = timeSinceLastUpdate > BACKGROUND_THRESHOLD_MS;
  
  // Update timestamp for next call
  lastUpdateTime = currentTime;
  
  // Skip if invalid position
  if (!position || typeof position.lat !== "number" || typeof position.lng !== "number") {
    return;
  }

  // This prevents disorienting visual effects when position changes significantly
  if (lastRenderPosition && calculateDistance(lastRenderPosition, position) > EXTENDED_DISTANCE_THRESHOLD) {
    console.debug(`Large position change detected (${calculateDistance(lastRenderPosition, position).toFixed(2)}m). Skipping interpolation.`);
    updateUserMarkerPosition(position); // Direct update without animation
    lastRenderPosition = position;
    return; // Skip the rest of the interpolation logic
  }

  // Normal case: Apply smooth interpolation between positions
  if (lastRenderPosition && !isFirstPositionUpdate) {
    if (positionInterpolator) {
      // Use slower animation when stationary for more stability
      positionInterpolator.start(
        lastRenderPosition, 
        position,
        isStationary ? 300 : ANIMATION_DURATION,
      );
    } else {
      console.warn("Position interpolator not available, using direct position update");
      updateUserMarkerPosition(position);
      lastRenderPosition = position;
    }
  } else {
    // First position update - set directly without animation
    updateUserMarkerPosition(position);
    lastRenderPosition = position;
    isFirstPositionUpdate = false;
  }

  // Handle auto-recentering and zoom adjustments
  if (followUser && !isMapInteracting) {
    const recenterInfo = shouldRecenter(map, userMarker);
    if (recenterInfo.needsRecenter) {
      performEdgeRecenter(recenterInfo);
    } else if (Math.abs(map.getZoom() - calculateZoomLevel(position.speedMPS)) > 0.5) {
      const newZoom = calculateZoomLevel(position.speedMPS);
      map.setZoom(newZoom, {
        animate: true,
        duration: ZOOM_TRANSITION_DURATION,
      });
    }
  }
}
        
// Perform edge recentering with smoother transitions based on speed
function performEdgeRecenter(recenterInfo) {
  edgeRecenterInProgress = true
  
  // Get current position
  const position = userMarker.getLatLng()
  
  // Get current speed (in meters per second)
  const currentSpeed = lastPosition?.speedMPS || 0
  
  // Only trust GPS-reported speed, not calculated from position changes
  // This helps filter out device movements like shaking
  const isGenuineMovement = lastPosition?.hasOwnProperty('speedAccuracy') && 
                            lastPosition.speedAccuracy < SPEED_ACCURACY_THRESHOLD
  
  // Use a conservative speed value if we're not confident in the movement
  const reliableSpeed = isGenuineMovement ? currentSpeed : Math.min(currentSpeed, 1.0)
  
  // Calculate appropriate zoom level based on reliable speed
  const dynamicZoom = calculateZoomLevel(reliableSpeed)
  
  // Get current map center
  const currentCenter = map.getCenter()
  
  // Calculate optimal center point that keeps the user icon away from edges
  const optimalCenter = calculateOptimalCenter(map, position, recenterInfo.edgeInfo)
  
  // Calculate edge proximity using your existing function
  const proximity = calculateEdgeProximity(map, position)
  
  // Find the minimum proximity (closest edge)
  const minProximity = Math.min(proximity.north, proximity.south, proximity.east, proximity.west)
  
  // Calculate speed factor (0-1) based on reliable speed
  const SPEED_THRESHOLD_SLOW = 1.5
  const SPEED_THRESHOLD_FAST = 10.0
  const speedFactor = Math.min(1, Math.max(0, (reliableSpeed - SPEED_THRESHOLD_SLOW) / 
                              (SPEED_THRESHOLD_FAST - SPEED_THRESHOLD_SLOW)))
  
  // Calculate combined transition factor
  const baseTransitionFactor = Math.max(0.3, Math.min(0.8, minProximity * 2))
  const speedAdjustedFactor = baseTransitionFactor - (speedFactor * 0.3)
  
  // Blend current and optimal centers for smoother transition
  const blendedCenter = {
    lat: currentCenter.lat + (optimalCenter.lat - currentCenter.lat) * (1 - speedAdjustedFactor),
    lng: currentCenter.lng + (optimalCenter.lng - currentCenter.lng) * (1 - speedAdjustedFactor)
  }
  
  // Only apply forward bias for genuine GPS movement
  let adjustedCenter = blendedCenter
  if (lastPosition && isGenuineMovement) {
    const direction = {
      lat: position.lat - lastPosition.lat,
      lng: position.lng - lastPosition.lng
    }
    
    // Calculate movement magnitude
    const movement = Math.sqrt(direction.lat * direction.lat + direction.lng * direction.lng)
    
    // Only apply forward bias if moving significantly
    if (movement > 0.00001) {
      // Apply forward bias scaled to speed
      const forwardBiasAmount = 0.00005 + (speedFactor * 0.0001)
      
      // Normalize direction and apply forward bias
      adjustedCenter = {
        lat: blendedCenter.lat + (direction.lat / movement) * forwardBiasAmount,
        lng: blendedCenter.lng + (direction.lng / movement) * forwardBiasAmount
      }
    }
  }
  
  // Calculate duration based on reliable speed
  const baseDuration = recenterInfo.isEmergency ? 0.2 : ZOOM_TRANSITION_DURATION
  const speedAdjustedDuration = baseDuration * (1 - (speedFactor * 0.5))
  
  // Set view with animation
  map.setView([adjustedCenter.lat, adjustedCenter.lng], dynamicZoom, {
    animate: true,
    duration: speedAdjustedDuration,
    noMoveStart: true,
    easeLinearity: 0.3 + (speedFactor * 0.2)
  })
  
  // Reset edge recenter flag after animation completes
  setTimeout(
    () => {
      edgeRecenterInProgress = false
    },
    recenterInfo.isEmergency ? 300 : speedAdjustedDuration * 1000,
  )
}

function showLoadingMessage() {
    // Skip creating the loading message element
    // Just log to console for debugging purposes
    console.log("Searching for location...");
    
    // Set a flag to track that we're in the loading state
    window.isSearchingLocation = true;
    
    // If you need to maintain any timing-dependent behavior that might
    // rely on this function, you can add a small timeout
    setTimeout(() => {
        // This ensures any code expecting this function to take some time
        // will still work correctly
    }, 100);
}

function hideLoadingMessage() {
    // Clear the loading state flag
    window.isSearchingLocation = false;
    
    // No need to remove any elements since we didn't create them
    // Just log for debugging
    console.log("Location found, proceeding to stabilization...");
    
    // If any code relies on this function completing, ensure it still works
    const fakeLoadingMessage = document.getElementById('loadingMessage');
    if (fakeLoadingMessage) {
        document.body.removeChild(fakeLoadingMessage);
    }
}
       
function showStabilizingModal() {
  // Hide jitter immediately
  if (userMarker) userMarker.setOpacity(0);
  const modal = document.createElement("div");
  modal.id = "stabilizingModal";
  modal.className = "stabilizing-modal";
  modal.innerHTML = `
    <div class="spinner"></div>
    <h3>Stabilizing Your Location</h3>
    <p>Please wait while we fine-tune your position.</p>
  `;
  document.body.appendChild(modal);
  // Auto-dismiss after 5 seconds
  setTimeout(() => {
    if (userMarker) userMarker.setOpacity(1); // Restore visibility
    const modal = document.getElementById("stabilizingModal");
    if (modal) {
      modal.style.opacity = "0";
      setTimeout(() => modal.remove(), 500);
    }
    isStabilizing = false;
  }, 5000);
}

function initializeUserLocation(position) {
  console.log("Initial position data:", JSON.stringify(position))

  if (typeof tracking === 'undefined') {
    tracking = initializeTracking();
  }

  if (!position || !position.coords) {
    console.error("Invalid initial position object")
    handleLocationError(new Error("Invalid initial position"))
    return
  }

  const { latitude: userLat, longitude: userLng, accuracy } = position.coords

  if (isNaN(userLat) || isNaN(userLng)) {
    console.error("Invalid initial coordinates:", { userLat, userLng })
    handleLocationError(new Error("Invalid initial coordinates"))
    return
  }

  console.log("Valid initial position:", { userLat, userLng, accuracy })

  try {
    // Set initial marker position
    updateUserMarkerPosition({
      lat: userLat,
      lng: userLng,
      accuracy: accuracy,
      heading: position.coords.heading,
      timestamp: Date.now(),
      speedMPS: 0,
    })

    map.setView([userLat, userLng], 17)

    // Initialize Kalman filter with first position
    tracking.filter.reset({
      lat: userLat,
      lng: userLng,
      accuracy: accuracy,
      heading: position.coords.heading,
      timestamp: Date.now(),
    })

    // Initialize stationary position
    lastStationaryPosition = {
      lat: userLat,
      lng: userLng,
      accuracy: accuracy,
      heading: position.coords.heading,
      timestamp: Date.now(),
      speedMPS: 0,
    }

    // Initialize last render position
    lastRenderPosition = {
      lat: userLat,
      lng: userLng,
      accuracy: accuracy,
      heading: position.coords.heading,
      timestamp: Date.now(),
      speedMPS: 0,
    }

    // Initialize last valid position
    lastValidPosition = {
      lat: userLat,
      lng: userLng,
      accuracy: accuracy,
      heading: position.coords.heading,
      timestamp: Date.now(),
      speedMPS: 0,
    }

    // Show stabilizing modal
    hideLoadingMessage()
    showStabilizingModal()

    // Start position updates
    startPositionUpdates()
    startHunt()
  } catch (error) {
    console.error("Error setting initial user location:", error)
    handleLocationError(error)
  }
}

function startPositionUpdates() {
  // If already using GeolocationSensor API, don't start again
  if (usingGeolocationSensorAPI) {
    console.log("Position updates already using GeolocationSensor API")
    return
  }

  // Use standard Geolocation API with high frequency updates
  watchPositionId = navigator.geolocation.watchPosition(handlePositionUpdate, handleLocationError, {
    enableHighAccuracy: true,
    maximumAge: 0,
    timeout: 10000,
  })
  isWatchPositionActive = true
  console.log("Position updates using standard Geolocation API")
}

function handlePositionUpdate(position) {
  if (!position?.coords?.latitude || !position?.coords?.longitude) {
    console.warn("Invalid position data received")
    return
  }
  updateUserLocation(position)
}

function handleVisibilityChange() {
  if (document.hidden) {
    lastHiddenTime = Date.now()
    lastKnownPosition = userMarker ? userMarker.getLatLng() : null

    // Cancel any active interpolation
    if (positionInterpolator) {
      positionInterpolator.cancel()
    }

    // Cancel animation frame
    if (animationFrameId) {
      cancelAnimationFrame(animationFrameId)
      animationFrameId = null
    }

    // Stop GeolocationSensor if using it
    if (usingGeolocationSensorAPI && geolocationSensor) {
      geolocationSensor.stop()
    }
  } else {
    const hiddenDuration = Date.now() - lastHiddenTime
    if (hiddenDuration > BACKGROUND_THRESHOLD) {
      updateLocationAfterBackground()
    } else {
      map.invalidateSize()

      // Restart animation loop
      if (!animationFrameId) {
        startAnimationLoop()
      }

      // Restart GeolocationSensor if using it
      if (usingGeolocationSensorAPI && geolocationSensor) {
        geolocationSensor.start()
      }

      // If returning from exhibit, ensure movement resumes properly
      if (isReturningFromExhibit) {
        isReturningFromExhibit = false
        // Force a position update to resume tracking
        if (lastValidPosition) {
          updateUserLocation(
            {
              coords: {
                latitude: lastValidPosition.lat,
                longitude: lastValidPosition.lng,
                accuracy: lastValidPosition.accuracy,
                heading: lastValidPosition.heading,
                speed: lastValidPosition.speedMPS,
              },
              timestamp: Date.now(),
            },
            true,
          )
        }
      }
    }
  }
  resetInactivityTimer()
}

function updateLocationAfterBackground() {
    if (!("geolocation" in navigator)) {
        console.warn("Geolocation is not available");
        return;
    }

    // Smart timeout adjustment based on likely environment
    const isLikelyIndoor = !navigator.connection?.effectiveType.includes('cellular');
    const baseTimeout = isLikelyIndoor ? 5000 : 8000;

    const quickOptions = {
        enableHighAccuracy: false,
        timeout: baseTimeout,
        maximumAge: isLikelyIndoor ? 120000 : 30000
    };

    const accurateOptions = {
        enableHighAccuracy: true,
        timeout: isLikelyIndoor ? 10000 : 15000,
        maximumAge: 0
    };

    const fallbackOptions = {
        enableHighAccuracy: false,
        timeout: 20000,
        maximumAge: 300000
    };

    const handleSuccess = (position, stage = 'quick') => {
        if (!position?.coords) {
            console.warn(`Invalid position during ${stage} attempt`);
            return;
        }

        const { latitude, longitude, accuracy, heading, speed } = position.coords;
        if (isNaN(latitude) || isNaN(longitude)) {
            console.warn(`Invalid coordinates during ${stage} attempt`);
            return;
        }

        console.log(`Successful ${stage} update (snap mode)`, { 
            lat: latitude, 
            lng: longitude,
            accuracy,
            source: stage
        });

        try {
            // Cancel any active animation/interpolation
            if (positionInterpolator) {
                positionInterpolator.cancel();
            }
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }

            // Create a new position object with timestamp if missing
            const snapPosition = {
                coords: {
                    latitude,
                    longitude,
                    accuracy: accuracy ?? 50,
                    heading: heading ?? 0,
                    speed: speed ?? 0
                },
                timestamp: position.timestamp || Date.now()
            };

            // Force immediate update without animation
            if (userMarker) {
                userMarker.setLatLng([latitude, longitude]);
            }
            if (accuracyCircle) {
                accuracyCircle.setLatLng([latitude, longitude]);
                accuracyCircle.setRadius(accuracy ?? 50);
            }

            // Reset all tracking state
            const resetValues = {
                lastPosition: snapPosition,
                positionBuffer: [],
                velocity: { lat: 0, lng: 0 },
                lastVelocity: { lat: 0, lng: 0 },
                isStationary: false,
                stationaryStartTime: null,
                stationaryCount: 0,
                stationaryPositionHistory: [],
                lastStationaryPosition: null,
                stationaryPositionLocked: false,
                positionHistory: [[latitude, longitude, Date.now()]],
                suddenMovementCount: 0,
                isJumpDetected: false,
                lastValidPosition: {
                    lat: latitude,
                    lng: longitude,
                    accuracy: accuracy ?? 50,
                    heading: heading ?? 0,
                    speedMPS: speed ?? 0,
                    timestamp: snapPosition.timestamp
                }
            };
            Object.assign(this, resetValues);

            // Reset Kalman filter
            if (tracking?.filter?.reset) {
                tracking.filter.reset({
                    lat: latitude,
                    lng: longitude,
                    accuracy: accuracy ?? 50,
                    heading: heading ?? 0,
                    speed: speed ?? 0,
                    timestamp: snapPosition.timestamp
                });
            }

            // Restart services
            startAnimationLoop();
            if (usingGeolocationSensorAPI && geolocationSensor) {
                geolocationSensor.start();
            }

            // Update UI
            if (updateDistanceBox) updateDistanceBox();
            followUser = true;
            map.invalidateSize();
        } catch (error) {
            console.error("Snap location update error:", error);
        }
    };

    const handleError = (error, stage = 'quick') => {
        if (error.code === error.TIMEOUT) {
            console.log(`Timeout during ${stage} attempt (expected indoors)`);
        } else {
            console.error(`${stage} attempt failed:`, error);
        }

        const nextAttempt = {
            quick: { stage: 'accurate', options: accurateOptions },
            accurate: { stage: 'fallback', options: fallbackOptions },
            fallback: null
        }[stage];

        if (nextAttempt) {
            navigator.geolocation.getCurrentPosition(
                pos => handleSuccess(pos, nextAttempt.stage),
                err => handleError(err, nextAttempt.stage),
                nextAttempt.options
            );
        } else {
            console.warn("All location attempts completed");
            // Fallback to last known position if available
            if (lastKnownPosition) {
                handleSuccess({
                    coords: {
                        latitude: lastKnownPosition.lat,
                        longitude: lastKnownPosition.lng,
                        accuracy: 50,
                        heading: 0,
                        speed: 0
                    },
                    timestamp: Date.now()
                }, 'fallback');
            }
        }
    };

    // Start the process
    navigator.geolocation.getCurrentPosition(
        pos => handleSuccess(pos, 'quick'),
        err => handleError(err, 'quick'),
        quickOptions
    );
}
        
// Helper function to validate position data
function isValidPosition(pos) {
  return (
    pos &&
    typeof pos.lat === "number" &&
    !isNaN(pos.lat) &&
    typeof pos.lng === "number" &&
    !isNaN(pos.lng) &&
    typeof pos.accuracy === "number" &&
    !isNaN(pos.accuracy)
  )
}

// Linear interpolation helper
function lerp(a, b, t) {
  if (typeof a !== "number" || typeof b !== "number" || typeof t !== "number") {
    return a
  }

  return a + (b - a) * Math.max(0, Math.min(1, t))
}

// Update position buffer with new position
function updatePositionBuffer(position) {
  if (!isValidPosition(position)) {
    return
  }

  // Add new position to buffer
  positionBuffer.push({
    lat: position.lat,
    lng: position.lng,
    accuracy: position.accuracy,
    heading: position.heading,
    timestamp: position.timestamp,
    speedMPS: position.speedMPS,
  })

  // Remove old positions if buffer exceeds maxSize
  while (positionBuffer.length > MAX_BUFFER_SIZE) {
    positionBuffer.shift()
  }
}

// Update position history for jump detection
function updatePositionHistory(position) {
  if (!isValidPosition(position)) {
    return
  }

  // Add new position to history
  positionHistory.push({
    lat: position.lat,
    lng: position.lng,
    accuracy: position.accuracy,
    heading: position.heading,
    timestamp: position.timestamp,
    speedMPS: position.speedMPS,
  })

  // Keep only recent positions
  while (positionHistory.length > 10) {
    positionHistory.shift()
  }
}

// Enhanced function to check if we're in a stationary state
function checkStationaryState(newPosition, motionDetected) {
  const currentTime = newPosition.timestamp;
  
  // If in stationary state, evaluate if we should exit
  if (isStationary) {
    // Only exit stationary mode if we have consistent evidence of motion
    if (motionDetected) {
      const recentPositions = positionHistory.slice(-3);
      const consistentMotion = recentPositions.length >= 3 && 
                               recentPositions.every(pos => pos.speedMPS > MIN_CONSISTENT_MOTION);
      
      if (consistentMotion || newPosition.speedMPS > STRONG_MOTION_THRESHOLD) {
        isStationary = false;
        stationaryStartTime = null;
        stationaryCount = 0;
        stationaryPositionHistory = [];
        stationaryPositionLocked = false;
        tracking.filter.setStationaryMode(false);
        console.log("Exiting stationary state due to consistent motion");
      }
      return;
    }
    
    // While in stationary state, keep collecting position samples for variance calculation
    stationaryPositionHistory.push(newPosition);
    // Limit history size
    if (stationaryPositionHistory.length > 10) {
      stationaryPositionHistory.shift();
    }
    
    // Update position variance for adaptive thresholds
    updateStationaryVariance(newPosition);
    return;
  }
  
  // Not in stationary state yet, check if we should enter
  if (!motionDetected) {
    // Initialize or continue stationary detection
    if (!stationaryStartTime) {
      stationaryStartTime = currentTime;
      stationaryPositionHistory = [newPosition];
      stationaryCount = 1;
    } else {
      // Add to stationary history
      stationaryPositionHistory.push(newPosition);
      stationaryCount++;
      
      // Limit history size
      if (stationaryPositionHistory.length > 10) {
        stationaryPositionHistory.shift();
      }
      
      // Check if we've been stationary long enough
      const stationaryDuration = currentTime - stationaryStartTime;
      
      // Require more samples with higher accuracy to enter stationary state
      const highAccuracySamples = stationaryPositionHistory.filter(p => p.accuracy < 20).length;
      
      if (stationaryDuration > 5000 && stationaryCount >= 3 && highAccuracySamples >= 2) {
        // Enter stationary state
        isStationary = true;
        
        // Calculate optimal stationary position (weighted median of recent positions)
        lastStationaryPosition = calculateMedianPosition(stationaryPositionHistory);
        
        // Initialize variance calculation
        updateStationaryVariance(newPosition);
        
        // Schedule stationary position lock with a longer delay for stability
        if (!stationaryLockTimeout) {
          stationaryLockTimeout = setTimeout(() => {
            if (isStationary) {
              stationaryPositionLocked = true;
              tracking.filter.setStationaryMode(true);
              console.log("Stationary position locked");
            }
            stationaryLockTimeout = null;
          }, 3000);
        }
      }
    }
  } else {
    // Reset stationary detection on motion
    stationaryStartTime = null;
    stationaryCount = 0;
    stationaryPositionHistory = [];
  }
}

// Main location update function with enhanced map centering
function updateUserLocation(position, forceUpdate = false) {
  // Validate input position
  if (!position?.coords?.latitude || !position?.coords?.longitude) {
    console.warn("Invalid position data received");
    return;
  }

  const currentTime = Date.now();
  const timeDelta = lastUpdateTime ? (currentTime - lastUpdateTime) / 1000 : 0;

  // Create position object with enhanced metadata
  const newPosition = {
    lat: position.coords.latitude,
    lng: position.coords.longitude,
    accuracy: position.coords.accuracy || 20,
    heading: position.coords.heading !== null ? position.coords.heading : lastHeadingValue || undefined,
    timestamp: currentTime,
    speedMPS: position.coords.speed !== null ? position.coords.speed : 
      (lastPosition ? calculateDistance(lastPosition, {lat: position.coords.latitude, lng: position.coords.longitude}) / Math.max(0.1, timeDelta) : 0)
  };

  // Update speed samples for dynamic zoom
  updateSpeedSamples(newPosition);

  // First position initialization
  if (!lastPosition) {
    initializeFirstPosition(newPosition);
    centerMapOnPosition(newPosition, true); // Force immediate centering on first position
    return;
  }

  // Calculate distance from last position
  const distance = calculateDistance(lastPosition, newPosition);
  
  // Calculate adaptive threshold based on accuracy and speed
  const adaptiveThreshold = Math.max(
    EXTENDED_DISTANCE_THRESHOLD * 0.5,
    Math.min(EXTENDED_DISTANCE_THRESHOLD * 2, newPosition.accuracy * 3)
  );

  // Adjust movement detection threshold based on speed (faster = higher threshold)
  const movementThreshold = Math.max(2, Math.min(10, newPosition.speedMPS * 2));

  // Check for sudden movements with adaptive sensitivity
  const isJump = !forceUpdate && detectSuddenMovement(newPosition, lastPosition, movementThreshold);

  // If we're stationary and a jump is detected, verify with additional checks
  if (isJump && isStationary && stationaryPositionLocked) {
    // Consider heading and speed for jump validation
    const isValidJump = validatePositionJump(newPosition, lastPosition);
    
    if (!isValidJump) {
      console.log("Position jump detected while stationary, ignoring update");
      isJumpDetected = true;
      
      // Schedule a check in case this was actually the start of movement
      if (!stationaryCheckTimeout) {
        stationaryCheckTimeout = setTimeout(() => {
          navigator.geolocation.getCurrentPosition(
            pos => updateUserLocation(pos, true),
            err => console.warn("Position verification error:", err),
            {enableHighAccuracy: true, maximumAge: 0, timeout: 10000}
          );
          stationaryCheckTimeout = null;
        }, 2000);
      }
      return;
    }
  }

  // Handle large position changes or forced updates with immediate map centering
  if (distance > adaptiveThreshold || forceUpdate) {
    handleLargePositionChange(newPosition);
    centerMapOnPosition(newPosition, true); // Force immediate centering on large position changes
    return;
  }

  // Skip updates with poor accuracy or unrealistic movement using adaptive thresholds
  if (
    !forceUpdate &&
    (newPosition.accuracy > MAX_ACCEPTABLE_ACCURACY * (1 + newPosition.speedMPS/10) || 
     (timeDelta > 0 && distance / timeDelta > 40))
  ) {
    console.log("Skipping update due to poor accuracy or unrealistic movement");
    return;
  }

  try {
    // Enhanced motion detection with speed and position history
    const motionDetected = detectMotion(newPosition, lastPosition, timeDelta);

    // Improved stationary state detection
    checkStationaryState(newPosition, motionDetected);

    // Enhanced stationary handling with jitter elimination
    if (isStationary && stationaryPositionLocked && lastStationaryPosition) {
      // Calculate the distance from locked stationary position
      const driftDistance = calculateDistance(lastStationaryPosition, newPosition);
      
      // Only update on significant changes exceeding noise threshold based on accuracy
      const minDriftThreshold = Math.max(MIN_STATIONARY_DRIFT_THRESHOLD, lastStationaryPosition.accuracy * 0.25);
      
      if (driftDistance < minDriftThreshold && !forceUpdate) {
        // Even in stationary mode, check if map needs recentering
        centerMapOnPosition(lastStationaryPosition, false);
        
        // Continue with standard stationary updates
        updateDistanceBox();
        checkProximityForZoom();
        optimizeUpdateFrequency(true);
        return;
      }
      
      // For movements just above threshold, apply stronger smoothing to reduce jitter
      if (driftDistance < minDriftThreshold * 2) {
        // Apply heavy damping (95% old position, 5% new position)
        newPosition = {
          lat: lastStationaryPosition.lat * STATIONARY_DAMPING_FACTOR + newPosition.lat * (1 - STATIONARY_DAMPING_FACTOR),
          lng: lastStationaryPosition.lng * STATIONARY_DAMPING_FACTOR + newPosition.lng * (1 - STATIONARY_DAMPING_FACTOR),
          accuracy: newPosition.accuracy,
          heading: newPosition.heading,
          speedMPS: newPosition.speedMPS,
          timestamp: newPosition.timestamp
        };
      }
    }

    // Apply enhanced tracking with adaptive filtering
    const smoothedPosition = enhancedTracking(newPosition, motionDetected);

    // Update position buffer and history
    updatePositionBuffer(smoothedPosition);
    updatePositionHistory(smoothedPosition);

    // Add to position update queue for animation frame processing
    requestAnimationFrame(() => {
      // Update marker position
      positionUpdateQueue.push(smoothedPosition);
      processPositionUpdateQueue();
      
      // Ensure map stays centered on user with speed-adaptive logic
      centerMapOnPosition(smoothedPosition, smoothedPosition.speedMPS > 25);
    });
    
    lastPosition = smoothedPosition;
    lastValidPosition = smoothedPosition;
    lastUpdateTime = currentTime;
    lastUpdateTimestamp = currentTime;
    
    updateDistanceBox();
    
    // Optimize update frequency based on movement state
    optimizeUpdateFrequency(smoothedPosition.speedMPS > 15 ? false : isStationary);
    
    // Check proximity after normal position update
    checkProximityForZoom();
    updateDynamicZoom(smoothedPosition.speedMPS);
  } catch (error) {
    console.error("Location update error:", error);
    
    // Enhanced fallback with error recovery
    const fallbackPosition = applyFallbackFilter(newPosition);
    
    requestAnimationFrame(() => {
      updateUserMarkerPosition(fallbackPosition);
      // Even in error cases, keep the map centered
      centerMapOnPosition(fallbackPosition, false);
    });
    
    lastPosition = fallbackPosition;
    lastValidPosition = fallbackPosition;
    lastRenderPosition = fallbackPosition;
    updateDistanceBox();
    
    // Check proximity even in error case
    checkProximityForZoom();
    updateDynamicZoom();
  }
}

// New function to handle map centering with adaptive behavior
function centerMapOnPosition(position, forceImmediate = false) {
  // Get current map center and viewport dimensions
  const currentCenter = map.getCenter();
  const mapBounds = map.getBounds();
  
  if (!currentCenter || !mapBounds) return;
  
  // Calculate distance between current map center and user position
  const distanceFromCenter = calculateDistance(
    {lat: currentCenter.lat(), lng: currentCenter.lng()}, 
    position
  );
  
  // Calculate viewport dimensions
  const viewportWidth = mapBounds.getEast() - mapBounds.getWest();
  const viewportHeight = mapBounds.getNorth() - mapBounds.getSouth();
  
  // Calculate centering threshold based on speed and viewport size
  // Faster speed = smaller threshold (quicker recentering)
  const speedFactor = Math.max(0.1, Math.min(0.45, 0.45 - (position.speedMPS * 0.01)));
  const centeringThreshold = Math.min(
    viewportWidth * speedFactor,
    viewportHeight * speedFactor
  );
  
  // Determine if recentering is needed
  const needsRecentering = 
    forceImmediate || 
    distanceFromCenter > centeringThreshold || 
    position.speedMPS > 20;
  
  if (needsRecentering) {
    // Calculate animation duration - faster speed = quicker animation
    const animationDuration = forceImmediate ? 0 : 
      Math.max(50, 500 - (position.speedMPS * 20));
    
    // At high speeds, predict ahead position for smoother centering
    let targetPosition = {...position};
    if (position.speedMPS > 10 && position.heading !== undefined && !isStationary) {
      // Predict ahead based on speed (higher speed = look further ahead)
      const lookAheadFactor = Math.min(0.3, position.speedMPS * 0.015);
      const headingRad = (position.heading * Math.PI) / 180;
      
      // Calculate prediction offset (varies by speed)
      const latOffset = Math.cos(headingRad) * lookAheadFactor;
      const lngOffset = Math.sin(headingRad) * lookAheadFactor;
      
      targetPosition = {
        lat: position.lat + latOffset,
        lng: position.lng + lngOffset,
        accuracy: position.accuracy,
        heading: position.heading,
        speedMPS: position.speedMPS,
        timestamp: position.timestamp
      };
    }
    
    // Apply centering with appropriate animation
    map.panTo({lat: targetPosition.lat, lng: targetPosition.lng}, {
      animate: !forceImmediate,
      duration: animationDuration
    });
  }
}

// Helper functions for the optimized updateUserLocation

function initializeFirstPosition(newPosition) {
  lastPosition = newPosition
  lastValidPosition = newPosition
  
  // Initialize tracking system
  tracking.filter.reset(newPosition)
  
  lastUpdateTime = newPosition.timestamp
  stationaryStartTime = newPosition.timestamp
  positionBuffer = [newPosition]
  positionHistory = [newPosition]
  lastStationaryPosition = newPosition
  lastRenderPosition = newPosition

  // Update UI with request animation frame for smoother initial rendering
  requestAnimationFrame(() => {
    // Set initial zoom based on stationary state
    const initialZoom = calculateZoomLevel(0)
    zoomTransitionInProgress = true
    map.setView([newPosition.lat, newPosition.lng], initialZoom, { animate: false })
    
    // Reset the flag after a brief delay
    setTimeout(() => { zoomTransitionInProgress = false }, 100)
    
    updateUserMarkerPosition(newPosition)
    updateDistanceBox()
  })
  
  // Initialize proximity check variables
  lastProximityCheck = 0
  lastZoomChangeTime = 0
  isNearLocation = false
  
  // Check proximity after initial position is set
  checkProximityForZoom()
}

function validatePositionJump(newPosition, lastPosition) {
  // Consider the jump valid if:
  // 1. The accuracy is very good
  // 2. The heading is consistent with the movement direction
  // 3. The speed is reasonable
  
  if (newPosition.accuracy < 10) return true
  
  // Check if heading is consistent with movement direction
  if (newPosition.heading !== undefined && lastPosition.heading !== undefined) {
    const movementBearing = calculateBearing(lastPosition, newPosition)
    const headingDiff = Math.abs(movementBearing - newPosition.heading)
    const normalizedDiff = headingDiff > 180 ? 360 - headingDiff : headingDiff
    
    // If heading matches movement direction, consider it valid
    if (normalizedDiff < 45) return true
  }
  
  // Check if speed is consistent
  const distance = calculateDistance(lastPosition, newPosition)
  const timeDelta = (newPosition.timestamp - lastPosition.timestamp) / 1000
  const calculatedSpeed = timeDelta > 0 ? distance / timeDelta : 0
  
  // If reported speed is similar to calculated speed, it's likely valid
  if (newPosition.speedMPS > 0 && 
      Math.abs(calculatedSpeed - newPosition.speedMPS) / newPosition.speedMPS < 0.5) {
    return true
  }
  
  // Default to invalid for safety
  return false
}

function calculateBearing(from, to) {
  // Convert to radians
  const lat1 = from.lat * Math.PI / 180
  const lat2 = to.lat * Math.PI / 180
  const dLon = (to.lng - from.lng) * Math.PI / 180
  
  const y = Math.sin(dLon) * Math.cos(lat2)
  const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon)
  
  let bearing = Math.atan2(y, x) * 180 / Math.PI
  bearing = (bearing + 360) % 360
  
  return bearing
}

function handleLargePositionChange(newPosition) {
  // Clear any pending timeouts
  if (stationaryCheckTimeout) {
    clearTimeout(stationaryCheckTimeout)
    stationaryCheckTimeout = null
  }

  if (stationaryLockTimeout) {
    clearTimeout(stationaryLockTimeout)
    stationaryLockTimeout = null
  }

  // Reset stationary state
  isStationary = false
  stationaryStartTime = null
  stationaryCount = 0
  stationaryPositionHistory = []
  lastStationaryPosition = null
  stationaryPositionLocked = false
  isJumpDetected = false

  // Reset tracking with adaptive parameters
  tracking.filter.reset(newPosition)
  tracking.filter.setStationaryMode(false)
  
  // Create transition with animation
  transitionToNewPosition(newPosition)
  
  // Update state variables
  lastPosition = newPosition
  lastValidPosition = newPosition
  positionBuffer = [newPosition]
  positionHistory = [newPosition]
  lastVelocity = { lat: 0, lng: 0 }
  lastSmoothedPosition = null
  
  lastUpdateTime = newPosition.timestamp
  lastUpdateTimestamp = newPosition.timestamp
  updateDistanceBox()

  if (map._container) {
    map._onResize()
  }
  
  // Reset proximity state on large position changes
  if (isNearLocation) {
    isNearLocation = false
  }
  
  // Check proximity after large position change
  checkProximityForZoom()
}

function transitionToNewPosition(newPosition) {
  // Create a smooth transition to the new position
  const duration = 300 // ms
  
  // Use animation frame for smoother rendering
  let startTime = null
  const lastPos = lastRenderPosition || lastPosition
  
  const animate = (timestamp) => {
    if (!startTime) startTime = timestamp
    const progress = Math.min(1, (timestamp - startTime) / duration)
    
    // Apply easing function for smoother motion
    const easedProgress = 1 - Math.pow(1 - progress, 3) // cubic ease out
    
    // Calculate intermediate position
    const intermediatePosition = {
      lat: lastPos.lat + (newPosition.lat - lastPos.lat) * easedProgress,
      lng: lastPos.lng + (newPosition.lng - lastPos.lng) * easedProgress,
      accuracy: lastPos.accuracy + (newPosition.accuracy - lastPos.accuracy) * easedProgress,
      heading: newPosition.heading,
      speedMPS: newPosition.speedMPS,
      timestamp: newPosition.timestamp
    }
    
    // Update marker position
    updateUserMarkerPosition(intermediatePosition)
    
    // Update map view gradually
    const zoomLevel = calculateZoomLevel(intermediatePosition.speedMPS)
    
    if (!zoomTransitionInProgress) {
      zoomTransitionInProgress = true
      map.setView([intermediatePosition.lat, intermediatePosition.lng], zoomLevel, {
        animate: true,
        duration: 50
      })
    } else {
      map.panTo([intermediatePosition.lat, intermediatePosition.lng], {
        animate: true,
        duration: 50
      })
    }
    
    // Continue animation if not complete
    if (progress < 1) {
      lastRenderPosition = intermediatePosition
      requestAnimationFrame(animate)
    } else {
      // Finalize transition
      lastRenderPosition = newPosition
      zoomTransitionInProgress = false
    }
  }
  
  // Start animation
  requestAnimationFrame(animate)
}

function detectMotion(newPosition, lastPosition, timeDelta) {
  // Combine multiple motion detection methods for more reliable results
  
  // Hardware motion detection when available
  const hardwareMotion = deviceMotion && isDeviceInMotion()
  
  // Enhanced motion detection
  const enhancedMotion = enhancedMotionDetection()
  
  // Speed-based detection (most reliable with good GPS)
  const speedMotion = newPosition.speedMPS > 0.8
  
  // Position-based detection (analyze recent movement)
  const positions = positionHistory.slice(-5)
  let positionMotion = false
  
  if (positions.length >= 3) {
    let totalDistance = 0
    for (let i = 1; i < positions.length; i++) {
      totalDistance += calculateDistance(positions[i-1], positions[i])
    }
    
    const avgDistance = totalDistance / (positions.length - 1)
    positionMotion = avgDistance > 2 // meters
  }
  
  // Combined detection with hierarchy of reliability
  return speedMotion || hardwareMotion || enhancedMotion || positionMotion
}

function checkStationaryState(newPosition, motionDetected) {
  const currentTime = newPosition.timestamp
  
  // If clear motion is detected, exit stationary state
  if (motionDetected && isStationary) {
    isStationary = false
    stationaryStartTime = null
    stationaryCount = 0
    stationaryPositionHistory = []
    stationaryPositionLocked = false
    tracking.filter.setStationaryMode(false)
    return
  }
  
  // If motion detected, reset stationary detection
  if (motionDetected) {
    stationaryStartTime = null
    stationaryCount = 0
    stationaryPositionHistory = []
    return
  }
  
  // No motion detected, check if we should enter/maintain stationary state
  if (!stationaryStartTime) {
    // Initialize stationary detection
    stationaryStartTime = currentTime
    stationaryPositionHistory = [newPosition]
    stationaryCount = 1
  } else {
    // Add to stationary history
    stationaryPositionHistory.push(newPosition)
    stationaryCount++
    
    // Limit history size
    if (stationaryPositionHistory.length > 10) {
      stationaryPositionHistory.shift()
    }
    
    // Check if we've been stationary long enough
    const stationaryDuration = currentTime - stationaryStartTime
    
    if (stationaryDuration > 5000 && stationaryCount >= 3) {
      // Enter stationary state if not already
      if (!isStationary) {
        isStationary = true
        
        // Calculate optimal stationary position (median of recent positions)
        lastStationaryPosition = calculateMedianPosition(stationaryPositionHistory)
        
        // Schedule stationary position lock
        if (!stationaryLockTimeout) {
          stationaryLockTimeout = setTimeout(() => {
            if (isStationary) {
              stationaryPositionLocked = true
              tracking.filter.setStationaryMode(true)
            }
            stationaryLockTimeout = null
          }, 3000)
        }
      }
    }
  }
}

function calculateMedianPosition(positions) {
  if (!positions || positions.length === 0) return null;
  
  // Filter positions with acceptable accuracy
  const validPositions = positions.filter(p => p.accuracy < MAX_ACCEPTABLE_ACCURACY);
  
  if (validPositions.length === 0) return positions[positions.length - 1];
  
  // Sort by accuracy (lower is better)
  validPositions.sort((a, b) => a.accuracy - b.accuracy);
  
  // Return the position with best accuracy or a weighted average of top positions
  if (validPositions.length >= 3) {
    // Use weighted average of top 3 most accurate positions
    const top3 = validPositions.slice(0, 3);
    const totalWeight = top3.reduce((sum, p) => sum + (1/p.accuracy), 0);
    
    return {
      lat: top3.reduce((sum, p) => sum + (p.lat * (1/p.accuracy)), 0) / totalWeight,
      lng: top3.reduce((sum, p) => sum + (p.lng * (1/p.accuracy)), 0) / totalWeight,
      accuracy: top3[0].accuracy, // Use best accuracy
      heading: top3[0].heading,
      speedMPS: 0,
      timestamp: positions[positions.length - 1].timestamp
    };
  }
  
  return validPositions[0]; // Return most accurate position
}

// Function to calculate and update position variance during stationary periods
function updateStationaryVariance(newPosition) {
  if (!isStationary || stationaryPositionHistory.length < 3) return;
  
  // Calculate variance in stationary positions
  const latSum = stationaryPositionHistory.reduce((sum, pos) => sum + pos.lat, 0);
  const lngSum = stationaryPositionHistory.reduce((sum, pos) => sum + pos.lng, 0);
  const latMean = latSum / stationaryPositionHistory.length;
  const lngMean = lngSum / stationaryPositionHistory.length;
  
  const latVariance = stationaryPositionHistory.reduce((sum, pos) => 
    sum + Math.pow(pos.lat - latMean, 2), 0) / stationaryPositionHistory.length;
  const lngVariance = stationaryPositionHistory.reduce((sum, pos) => 
    sum + Math.pow(pos.lng - lngMean, 2), 0) / stationaryPositionHistory.length;
  
  stationaryPositionVariance = { lat: latVariance, lng: lngVariance };
}
        
function optimizeUpdateFrequency(isStationary) {
  // Adjust geolocation watch settings based on movement state
  if (navigator.geolocation && positionWatchId !== null) {
    const settings = {
      enableHighAccuracy: true,
      timeout: isStationary ? 30000 : 15000,
      maximumAge: isStationary ? 5000 : 2000
    }
    
    // Only update if settings have changed significantly
    if ((isStationary !== wasStationary) || !watchSettings || 
        Math.abs(watchSettings.timeout - settings.timeout) > 5000) {
      
      navigator.geolocation.clearWatch(positionWatchId)
      
      positionWatchId = navigator.geolocation.watchPosition(
        handlePositionUpdate,
        handlePositionError,
        settings
      )
      
      watchSettings = settings
      wasStationary = isStationary
    }
  }
}

function applyFallbackFilter(newPosition) {
  // Simple fallback filtering when normal tracking fails
  if (positionHistory.length > 0) {
    const prevPosition = positionHistory[positionHistory.length - 1]
    
    // Simple weighted average (70% current, 30% previous)
    return {
      lat: newPosition.lat * 0.7 + prevPosition.lat * 0.3,
      lng: newPosition.lng * 0.7 + prevPosition.lng * 0.3,
      accuracy: newPosition.accuracy,
      heading: newPosition.heading,
      speedMPS: newPosition.speedMPS,
      timestamp: newPosition.timestamp
    }
  }
  
  return newPosition
}
        
// Predict position based on heading and speed
function predictPositionFromHeading(position, heading, distance) {
  // Input validation
  if (
    !position ||
    typeof heading !== "number" ||
    typeof distance !== "number" ||
    !position.lat ||
    !position.lng ||
    isNaN(heading) ||
    isNaN(distance)
  ) {
    return position
  }

  // Normalize heading to 0-360 range
  heading = ((heading % 360) + 360) % 360

  // Earth's radius in meters
  const R = 6371e3

  // Convert to radians
  const d = distance / R
  const θ = (heading * Math.PI) / 180
  const φ1 = (position.lat * Math.PI) / 180
  const λ1 = (position.lng * Math.PI) / 180

  // Calculate predicted position with error handling
  try {
    const sinφ1 = Math.sin(φ1)
    const cosφ1 = Math.cos(φ1)
    const cosd = Math.cos(d)
    const sind = Math.sin(d)
    const cosθ = Math.cos(θ)

    const φ2 = Math.asin(sinφ1 * cosd + cosφ1 * sind * cosθ)

    const λ2 = λ1 + Math.atan2(Math.sin(θ) * sind * cosφ1, cosd - sinφ1 * Math.sin(φ2))

    // Convert back to degrees with bounds checking
    const newLat = Math.max(-90, Math.min(90, (φ2 * 180) / Math.PI))
    const newLng = (((λ2 * 180) / Math.PI + 540) % 360) - 180

    return {
      lat: newLat,
      lng: newLng,
    }
  } catch (error) {
    // Fallback to original position if calculation fails
    return position
  }
}

function isMarkerNearEdge(map, marker, options = {}) {
    // Default options
    const {
        isStrict = false,
        enableSpeedAdaptive = false,
        enableAutoRecenter = false,
        safetyMarginPixels = 30
    } = options;

    // Validate inputs
    if (!map || !marker) {
        return {
            isNearEdge: false,
            edges: { north: false, south: false, east: false, west: false },
            proximities: { north: 1, south: 1, east: 1, west: 1 }
        };
    }

    // Speed calculation (if enabled)
    let speed = 0;
    const now = Date.now();
    const currentPos = marker.getLatLng();

    if (enableSpeedAdaptive && window._lastEdgeCheckPos && window._lastEdgeCheckTime) {
        const dist = map.distance(window._lastEdgeCheckPos, currentPos);
        const timeDiff = (now - window._lastEdgeCheckTime) / 1000;
        speed = timeDiff > 0 ? dist / timeDiff : 0;
    }

    // Store current position for next call
    if (enableSpeedAdaptive) {
        window._lastEdgeCheckPos = currentPos;
        window._lastEdgeCheckTime = now;
    }

    // Calculate edge proximities
    const bounds = map.getBounds();
    const proximities = {
        north: Math.abs(currentPos.lat - bounds.getNorth()) / (bounds.getNorth() - bounds.getSouth()),
        south: Math.abs(currentPos.lat - bounds.getSouth()) / (bounds.getNorth() - bounds.getSouth()),
        east: Math.abs(currentPos.lng - bounds.getEast()) / (bounds.getEast() - bounds.getWest()),
        west: Math.abs(currentPos.lng - bounds.getWest()) / (bounds.getEast() - bounds.getWest())
    };

    // Determine threshold
    let threshold = isStrict ? 0.12 : 0.25; // Default edge threshold percentage
    if (enableSpeedAdaptive) {
        threshold = Math.min(0.35, threshold + (speed * 0.005)); // Scale with speed
    }

    // Check pixel proximity if enabled
    let isPixelClose = false;
    if (safetyMarginPixels > 0) {
        const pxPos = map.latLngToContainerPoint(currentPos);
        const pxSize = map.getSize();
        isPixelClose = (
            pxPos.x < safetyMarginPixels ||
            pxPos.y < safetyMarginPixels ||
            pxPos.x > (pxSize.x - safetyMarginPixels) ||
            pxPos.y > (pxSize.y - safetyMarginPixels)
        );
    }

    // Edge detection
    const edges = {
        north: proximities.north < threshold,
        south: proximities.south < threshold,
        east: proximities.east < threshold,
        west: proximities.west < threshold
    };

    const isNearEdge = Object.values(edges).some(Boolean) || isPixelClose;

    // Optional auto-recenter
    if (isNearEdge && enableAutoRecenter) {
        map.setView(currentPos, map.getZoom(), {
            animate: true,
            duration: 0.5,
            easeLinearity: 0.25
        });
    }

    // Return results
    return {
        isNearEdge,
        edges,
        proximities,
        ...(enableSpeedAdaptive && { currentSpeed: speed }),
        ...(safetyMarginPixels > 0 && { isPixelClose })
    };
}

// Calculate proximity to map edges
function calculateEdgeProximity(map, point) {
  const bounds = map.getBounds();
  const latSpan = bounds.getNorth() - bounds.getSouth();
  const lngSpan = bounds.getEast() - bounds.getWest();
  
  // Add pixel-based proximity calculation for more accurate edge detection
  const mapSize = map.getSize();
  const pixelPoint = map.latLngToContainerPoint(point);
  
  return {
    north: Math.abs(point.lat - bounds.getNorth()) / latSpan,
    south: Math.abs(point.lat - bounds.getSouth()) / latSpan,
    east: Math.abs(point.lng - bounds.getEast()) / lngSpan,
    west: Math.abs(point.lng - bounds.getWest()) / lngSpan,
    // Add pixel-based proximities
    northPx: pixelPoint.y / mapSize.y,
    southPx: (mapSize.y - pixelPoint.y) / mapSize.y,
    eastPx: (mapSize.x - pixelPoint.x) / mapSize.x,
    westPx: pixelPoint.x / mapSize.x
  };
}

// Determine if map should recenter
function shouldRecenter(map, marker) {
  // Fail-fast if invalid inputs
  if (!map?.getBounds || !marker?.getLatLng) {
    console.warn('shouldRecenter: Invalid map or marker');
    return { needsRecenter: false, reason: 'invalid_input' };
  }
  
  // Check if user is actively moving via GPS
  const currentSpeed = lastPosition?.speedMPS || 0;
  const isUserMoving = isDeviceInMotion() || (currentSpeed > 0.5); // 0.5 m/s threshold
  
  // Only allow manual navigation to override recentering when NOT actively moving
  if (userIsManuallyNavigating && !isUserMoving) {
    return { needsRecenter: false, reason: 'manual_navigation_while_stationary' };
  }
  
  // Dynamic thresholds based on speed
  const baseEdgeThreshold = typeof EDGE_THRESHOLD_PERCENTAGE !== 'undefined' 
    ? EDGE_THRESHOLD_PERCENTAGE 
    : 0.25;
  
  const baseCriticalThreshold = typeof CRITICAL_EDGE_THRESHOLD !== 'undefined'
    ? CRITICAL_EDGE_THRESHOLD
    : baseEdgeThreshold * 0.5;
  
  // Adjust thresholds based on speed - higher speeds need more visibility ahead
  const speedFactor = Math.min(3.0, 1.0 + (currentSpeed / 10)); // Cap at 3x normal threshold
  const edgeThreshold = baseEdgeThreshold * speedFactor;
  const criticalThreshold = baseCriticalThreshold * speedFactor;
  
  // Dynamic cooldown based on speed - faster movement needs quicker recentering
  const baseCooldown = typeof RECENTER_COOLDOWN !== 'undefined'
    ? RECENTER_COOLDOWN
    : 1500;
  
  // Reduce cooldown for higher speeds to ensure more responsive recentering
  const cooldown = isUserMoving ? Math.max(300, baseCooldown / speedFactor) : baseCooldown;
  
  const lastRecenter = typeof lastRecenterTime !== 'undefined'
    ? lastRecenterTime
    : 0;
  
  try {
    const position = marker.getLatLng();
    const proximity = calculateEdgeProximity(map, position);
    
    // Safely extract proximity values with Infinity fallbacks
    const {
      north = Infinity, south = Infinity,
      east = Infinity, west = Infinity,
      pixelNorth = Infinity, pixelSouth = Infinity,
      pixelEast = Infinity, pixelWest = Infinity
    } = proximity || {};
    
    // Calculate closest edge
    const minProximity = Math.min(north, south, east, west);
    const minPixelProximity = Math.min(pixelNorth, pixelSouth, pixelEast, pixelWest);
    
    // Determine closest edge direction
    const edgeInfo = {
      isNorth: north === minProximity,
      isSouth: south === minProximity,
      isEast: east === minProximity,
      isWest: west === minProximity,
      pixelProximity: minPixelProximity,
      speed: currentSpeed
    };
    
    // Threshold checks with speed adjustments
    const needsRecenter = minProximity < edgeThreshold;
    const isEmergency = minProximity < criticalThreshold;
    const canRecenter = Date.now() - lastRecenter > cooldown;
    
    // For high speeds, consider directional bias (we need more space in the direction of movement)
    let directionalUrgency = false;
    if (currentSpeed > 5.0 && lastPosition?.heading !== undefined) {
      const heading = lastPosition.heading;
      // Check if we're approaching an edge in our direction of travel
      if ((heading > 315 || heading < 45) && north < edgeThreshold * 1.2) {
        directionalUrgency = true; // Moving north and north edge is close
      } else if (heading >= 45 && heading < 135 && east < edgeThreshold * 1.2) {
        directionalUrgency = true; // Moving east and east edge is close
      } else if (heading >= 135 && heading < 225 && south < edgeThreshold * 1.2) {
        directionalUrgency = true; // Moving south and south edge is close
      } else if (heading >= 225 && heading < 315 && west < edgeThreshold * 1.2) {
        directionalUrgency = true; // Moving west and west edge is close
      }
    }
    
    if ((needsRecenter || directionalUrgency) && canRecenter) {
      lastRecenterTime = Date.now(); // Update global
      
      // Log recenter event with speed info for debugging
      console.log(`Recentering at speed ${currentSpeed.toFixed(1)} m/s, threshold: ${edgeThreshold.toFixed(2)}, cooldown: ${cooldown}ms`);
      
      return { 
        needsRecenter: true,
        isEmergency: isEmergency || (currentSpeed > 10.0 && directionalUrgency),
        edgeInfo,
        reason: directionalUrgency ? 'high_speed_directional' : 
                (isUserMoving ? 'moving_near_edge' : 
                (isEmergency ? 'critical_edge' : 'near_edge'))
      };
    }
    
    return { 
      needsRecenter: false,
      reason: !needsRecenter ? 'within_bounds' : 'cooldown_active'
    };
  } catch (error) {
    console.error('shouldRecenter failed:', error);
    return { needsRecenter: false, reason: 'calculation_error' };
  }
}
     
// Calculate optimal center point
function calculateOptimalCenter(map, markerPosition, edgeInfo, speed = 0) {
  // At high speeds, simply center on the marker position
  if (speed > 30) { // 30 m/s threshold (108 km/h)
    return markerPosition;
  }
  
  const bounds = map.getBounds();
  
  // Calculate offsets based on which edges are being approached
  let latOffset = 0;
  let lngOffset = 0;
  
  // Apply stronger offset for the closest edge
  const proximities = edgeInfo.proximities;
  const edges = edgeInfo.edges;
  
  // Get viewport dimensions
  const viewportWidth = mapViewportWidth || map._container.clientWidth;
  const viewportHeight = mapViewportHeight || map._container.clientHeight;
  
  // Calculate aspect ratio to adjust offsets
  const aspectRatio = viewportWidth / viewportHeight;
  
  // Adjust offsets based on viewport dimensions
  const latSpan = bounds.getNorth() - bounds.getSouth();
  const lngSpan = bounds.getEast() - bounds.getWest();
  
  // For medium-high speeds, reduce the offset to keep marker more centered
  const speedFactor = Math.max(0.5, 1 - (speed * 0.01));
  
  // Calculate offsets with consideration for viewport aspect ratio
  if (edges.north) {
    latOffset = -1 * latSpan * 0.25 * (1 / aspectRatio) * speedFactor;
  }
  if (edges.south) {
    latOffset = latSpan * 0.25 * (1 / aspectRatio) * speedFactor;
  }
  if (edges.east) {
    lngOffset = -1 * lngSpan * 0.25 * aspectRatio * speedFactor;
  }
  if (edges.west) {
    lngOffset = lngSpan * 0.25 * aspectRatio * speedFactor;
  }
  
  // Find the closest edge and apply extra offset
  const minProximity = Math.min(
    edges.north ? proximities.north : 1,
    edges.south ? proximities.south : 1,
    edges.east ? proximities.east : 1,
    edges.west ? proximities.west : 1
  );
  
  if (minProximity === proximities.north && edges.north) {
    latOffset *= 1.5;
  } else if (minProximity === proximities.south && edges.south) {
    latOffset *= 1.5;
  } else if (minProximity === proximities.east && edges.east) {
    lngOffset *= 1.5;
  } else if (minProximity === proximities.west && edges.west) {
    lngOffset *= 1.5;
  }
  
  return {
    lat: markerPosition.lat + latOffset,
    lng: markerPosition.lng + lngOffset
  };
}
        
function updateDistanceBox() {
  const distanceBox = document.getElementById("distanceBox");
  if (!distanceBox) return;
  
  // Schedule DOM update
  domUpdateManager.schedule("distanceBox", () => {
    // Initial validation
    if (!userMarker || !gameLocations || gameLocations.length === 0) {
      distanceBox.innerText = "Initializing...";
      distanceBox.classList.remove("at-location"); // Remove highlight if present
      return;
    }
    
    // Get user coordinates
    const userLatLng = userMarker.getLatLng();
    let userLat = userLatLng.lat;
    let userLng = userLatLng.lng;
    
    // Coordinate validation
    if (!isFinite(userLat) || !isFinite(userLng)) {
      console.warn("Invalid user coordinates:", userLat, userLng);
      distanceBox.innerText = "Initializing...";
      distanceBox.classList.remove("at-location"); // Remove highlight if present
      return;
    }
    
    // Use map center if at origin
    if (userLat === 0 && userLng === 0) {
      const center = map.getCenter();
      userLat = center.lat;
      userLng = center.lng;
    }
    
    // Find closest location
    let closestDistance = Number.POSITIVE_INFINITY;
    let closestLocation = null;
    const userPos = { lat: userLat, lng: userLng };
    
    for (const location of gameLocations) {
      if (!location || typeof location.lat !== "number" || typeof location.lng !== "number") {
        console.warn("Invalid location data:", location);
        continue;
      }
      const locationPos = { lat: location.lat, lng: location.lng };
      const distance = calculateDistance(userPos, locationPos);
      if (isFinite(distance) && distance < closestDistance) {
        closestDistance = distance;
        closestLocation = location;
      }
    }
    
    // Validate final distance calculation
    if (!isFinite(closestDistance) || closestDistance === Number.POSITIVE_INFINITY) {
      console.warn("Invalid distance calculation:", closestDistance);
      distanceBox.innerText = "Initializing...";
      distanceBox.classList.remove("at-location"); // Remove highlight if present
      return;
    }
    
    // Calculate and display distance
    const distanceFeet = Math.round(closestDistance * 3.28084);
    const distanceText =
      distanceFeet < 5280 ? `${distanceFeet.toLocaleString()} feet` : `${(distanceFeet / 5280).toFixed(2)} miles`;
    distanceBox.innerText = `Closest Stop: ${distanceText}`;
    
    // Add or remove highlight class based on proximity
    if (distanceFeet <= DISTANCE_THRESHOLD) {
      distanceBox.classList.add("at-location"); // Add red border class
    } else {
      distanceBox.classList.remove("at-location"); // Remove highlight if present
    }
    
    // Check if we should show location hunt
    if (distanceFeet <= DISTANCE_THRESHOLD && !isLocationHuntVisible && closestLocation) {
      showLocationHunt(closestLocation);
    }
  });
}

const MAX_RETRIES = 3
const RETRY_DELAY = 1000

function getGeolocationOptions(retryNumber) {
  // High accuracy only on first attempt (GPS + WiFi), then fall back to balanced
  const enableHighAccuracy = retryNumber === 0;

  // Timeout strategy:
  // - First attempt: 10s (fast if GPS is available)
  // - Second attempt: 20s (more time for weak GPS)
  // - Third attempt: 30s (fallback to network-based location)
  const timeout = 10000 + (retryNumber * 10000);

  // Allow slightly stale positions on retries (0s, 30s, 60s)
  // But cap at 5 minutes to avoid very outdated data
  const maximumAge = Math.min(retryNumber * 30000, 300000);

  return {
    enableHighAccuracy,
    timeout,
    maximumAge,
    // (Optional) Future-proof for when browsers support the "priority" option
    priority: enableHighAccuracy ? 'high' : 'balanced'
  };
}
        
function handleLocationError(error) {
 console.warn("Error getting user location:", error)
 if (retryCount < MAX_RETRIES) {
   retryCount++
   console.log(`Retrying to get location (Attempt ${retryCount} of ${MAX_RETRIES})`)
   setTimeout(() => {
     navigator.geolocation.getCurrentPosition(
       (position) => {
         console.log("Location retrieved successfully after retry")
         hideLoadingMessage()
         updateUserLocation(position, true)
         retryCount = 0
       },
       handleLocationError,
       getGeolocationOptions(retryCount),
     )
   }, RETRY_DELAY * Math.pow(2, retryCount - 1)) // Exponential backoff
   return
 }
 retryCount = 0
 hideLoadingMessage()
 let errorMessage = "An error occurred while getting your location."
 if (error && error.code) {
   switch (error.code) {
     case 1:
       errorMessage = "Please allow access to your location to use this feature."
       // Try to continue with limited functionality
       notifyAppLocationDenied()
       break
     case 2:
       errorMessage = "Your location is currently unavailable. Please try again later."
       // Check if we have a cached location we can use temporarily
       if (localStorage.getItem('lastKnownLocation')) {
         const cachedLocation = JSON.parse(localStorage.getItem('lastKnownLocation'))
         updateUserLocation(cachedLocation, false)
         errorMessage += " Using your last known location for now."
       }
       break
     case 3:
       errorMessage = "Getting your location took too long. Please try again."
       // Register to check when device might have better signal
       if (navigator.connection) {
         navigator.connection.addEventListener('change', checkForReconnection)
       }
       break
   }
 }
 // Log the failure for analytics
 showPopup("Location Error", errorMessage)
}

function showPopup(title, message, type = "info", callback = null) {
  const popup = document.createElement("div")
  popup.classList.add("popup")
  popup.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: white;
        padding: 24px;
        border-radius: 16px;
        box-shadow: var(--shadow-lg);
        z-index: 2000;
        text-align: center;
        max-width: 80%;
    `

  const titleElement = document.createElement("h3")
  titleElement.textContent = title
  titleElement.style.cssText = `
        margin-bottom: 16px;
        font-size: 20px;
        font-weight: 600;
        color: var(--dark);
    `

  const messageElement = document.createElement("p")
  messageElement.textContent = message
  messageElement.style.cssText = `
        margin-bottom: 24px;
        font-size: 16px;
        line-height: 1.5;
    `

  const buttonContainer = document.createElement("div")
  buttonContainer.style.cssText = `
        display: flex;
        justify-content: center;
        gap: 12px;
    `

  const okButton = document.createElement("button")
  okButton.textContent = "OK"
  okButton.style.cssText = `
        padding: 10px 24px;
        background-color: var(--primary);
        color: white;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-weight: 500;
        transition: var(--transition-normal);
    `

  okButton.addEventListener("click", () => {
    document.body.removeChild(popup)
    if (callback) callback()
  })

  buttonContainer.appendChild(okButton)

  if (type === "info") {
    const cancelButton = document.createElement("button")
    cancelButton.textContent = "Cancel"
    cancelButton.style.cssText = `
            padding: 10px 24px;
            background-color: #f2f2f2;
            color: var(--dark);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: var(--transition-normal);
        `

    cancelButton.addEventListener("click", () => {
      document.body.removeChild(popup)
    })

    buttonContainer.appendChild(cancelButton)
  }

  popup.appendChild(titleElement)
  popup.appendChild(messageElement)
  popup.appendChild(buttonContainer)
  document.body.appendChild(popup)
}

//Handles notification when location access is denied by the user
function notifyAppLocationDenied() {
  console.log("Location access denied by user");
  
  // Update app state
  const locationStatusElement = document.getElementById('location-status');
  if (locationStatusElement) {
    locationStatusElement.textContent = 'Location access denied';
    locationStatusElement.classList.add('error');
  }
  
  // Store the denied state
  localStorage.setItem('locationPermissionDenied', 'true');
  
  // Show a message to the user
  showPopup("Location Required", "This app needs location access to function properly. Please enable location services in your browser settings.");
}        

// Checks if network conditions have improved to try getting location again
function checkForReconnection() {
  console.log("Network connection changed, checking if we can get location now");
  
  // Only attempt to get location again if we're not already trying
  if (retryCount === 0) {
    // Remove the event listener to avoid multiple calls
    if (navigator.connection) {
      navigator.connection.removeEventListener('change', checkForReconnection);
    }
    
    // Try to get location again
    navigator.geolocation.getCurrentPosition(
      (position) => {
        console.log("Location retrieved successfully after network change");
        updateUserLocation(position, true);
      },
      (error) => {
        console.warn("Still unable to get location after network change:", error);
      },
      {
        enableHighAccuracy: true,
        timeout: 15000,
        maximumAge: 0
      }
    );
  }
}
        
function recenterMap() {
  const recenterButton = document.getElementById("recenterButton")
  recenterButton.style.backgroundColor = "var(--primary)"
  recenterButton.style.color = "var(--white)"

  // Force map to center on user marker immediately
  if (userMarker && userMarker.getLatLng()) {
    map.closePopup()

    // Get dynamic zoom level based on current speed
    const dynamicZoom = calculateZoomLevel(currentSpeed)

    // Use flyTo instead of setView for smoother animation
    map.flyTo(userMarker.getLatLng(), dynamicZoom, {
      duration: 0.5,
    })

    followUser = true

    setTimeout(() => {
      recenterButton.style.backgroundColor = "var(--white)"
      recenterButton.style.color = "var(--primary)"
    }, 500)
  }
}

function addUIEventListeners() {
  document.getElementById("recenterButton").addEventListener("click", () => {
    recenterMap()
    resetInactivityTimer()
  })
  document.getElementById("returnButton").addEventListener("click", () => {
    returnToIndex()
    resetInactivityTimer()
  })
  document.getElementById("tipsButton").addEventListener("click", () => {
    toggleNavigationTips()
    resetInactivityTimer()
  })
  document.querySelector(".navigation-tips .close-button").addEventListener("click", () => {
    closeNavigationTips()
    resetInactivityTimer()
  })
}

function addMapEventListeners() {
  const startInteraction = () => {
    isMapInteracting = true
    userIsInteracting = true
    followUser = false
    resetInactivityTimer()
  }

  map.on("movestart zoomstart dragstart", startInteraction)
}

// Reset inactivity timer
function resetInactivityTimer() {
  clearTimeout(inactivityTimer)
  inactivityTimer = setTimeout(checkInactivity, INACTIVITY_TIMEOUT)
}

// Check for user inactivity
function checkInactivity() {
  console.log("Inactivity timer triggered")
  isMapInteracting = false
  userIsInteracting = false

  // Close any open popups
  map.closePopup()
  map.eachLayer((layer) => {
    if (layer.getPopup && layer.getPopup()?.isOpen()) {
      layer.closePopup()
    }
  })

  if (!isMapInteracting && !userIsInteracting) {
    recenterMap()
  }
}

let lastVisitTime = 0
const cooldownPeriod = 3 * 60 * 1000

function showLocationHunt(location) {
  const now = performance.now()
  if (location.id === lastVisitedLocationId && now - lastVisitTime < 180000) {
    console.log(`Location ${location.id} is on cooldown. Skipping.`)
    return
  }

  lastVisitedLocationId = location.id
  lastVisitTime = now
  isLocationHuntVisible = true

  domUpdateManager.schedule("locationHunt", () => {
    const lochuntContainer = document.querySelector(".lochunt-container")
    if (!lochuntContainer) return

    lochuntContainer.innerHTML = ""
    lochuntContainer.style.cssText = `
      display: flex;
      flex-direction: column;
      height: 100%;
      overflow: hidden;
      background-color: #fff;
      max-width: 1200px;
      margin: 0 auto;
      box-shadow: 0 2px 20px rgba(0,0,0,0.025);
      will-change: transform;
    `

    const scrollableContent = document.createElement("div")
    scrollableContent.style.cssText = `
      flex: 1;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      scroll-behavior: smooth;
      will-change: scroll-position;
    `

    const locationImage = document.createElement("img")
    if (preloadedImages.has(location.image)) {
      locationImage.src = location.image
    } else {
      locationImage.src = location.image
      const img = new Image()
      img.crossOrigin = "anonymous"
      img.src = location.image
      preloadedImages.set(location.image, img)
    }
    locationImage.alt = location.name
    locationImage.style.cssText = `
      width: 100%;
      height: 45vh;
      object-fit: cover;
      object-position: center;
    `

    scrollableContent.appendChild(locationImage)

    const contentContainer = document.createElement("div")
    contentContainer.classList.add("lochunt-content")
    contentContainer.style.cssText = `
      padding: 24px;
      display: flex;
      flex-direction: column;
      align-items: center;
      max-width: 800px;
      margin: 0 auto;
    `
    const locationInfo = document.createElement("div")
    locationInfo.classList.add("lochunt-info")
    locationInfo.style.cssText = `
      text-align: center;
      width: 100%;
      margin-bottom: 15px;
    `
    const locationName = document.createElement("h1")
    locationName.textContent = location.name
    locationName.style.cssText = `
      font-size: clamp(1.8rem, 4vw, 2.5rem);
      font-weight: 700;
      color: #1a1a1a;
      margin-bottom: 8px;
      line-height: 1.2;
    `
    const locationCity = document.createElement("p")
    locationCity.textContent = `${location.city}`
    locationCity.style.cssText = `
      font-size: clamp(1.1rem, 2vw, 1.3rem);
      color: #ff0000;
      font-weight: 600;
      margin-bottom: 4px;
    `
    const locationCreator = document.createElement("p")
    locationCreator.textContent = `Created by: ${location.creator}`
    locationCreator.style.cssText = `
      font-size: calc(0.9rem + 0.4vw);
      color: #666666;
      font-weight: 500;
    `
    locationInfo.appendChild(locationName)
    locationInfo.appendChild(locationCity)
    locationInfo.appendChild(locationCreator)
    contentContainer.appendChild(locationInfo)
    const audioPlayerContainer = createAudioPlayer(location.audio)
    contentContainer.appendChild(audioPlayerContainer)
    scrollableContent.appendChild(contentContainer)
    lochuntContainer.appendChild(scrollableContent)
    const blueBar = createBlueBar(location)
    blueBar.style.cssText += `
      position: sticky;
      bottom: 0;
      width: 100%;
    `
    lochuntContainer.appendChild(blueBar)

    requestAnimationFrame(initAudioPlayer)
  })
}

function createAudioPlayer(audioSrc) {
  const audioPlayerContainer = document.createElement("div")
  audioPlayerContainer.classList.add("audio-player")
  audioPlayerContainer.style.cssText = `
    width: 100%;
    max-width: 400px;
    margin-bottom: 15px;
  `

  const audio = document.createElement("audio")
  audio.id = "locationAudio"

  if (preloadedAudio.has(audioSrc)) {
    audio.src = audioSrc
  } else {
    audio.src = audioSrc
    const audioPreload = new Audio()
    audioPreload.preload = "auto"
    audioPreload.src = audioSrc
    preloadedAudio.set(audioSrc, audioPreload)
  }

  const audioProgress = document.createElement("div")
  audioProgress.classList.add("audio-progress")
  audioProgress.style.cssText = `
    width: 100%;
    margin-bottom: 15px;
  `

  const progressContainer = document.createElement("div")
  progressContainer.classList.add("progress")
  progressContainer.style.cssText = `
    height: 8px;
    background-color: #e2e8f0;
    border-radius: 4px;
    cursor: pointer;
    margin-bottom: 12px;
    overflow: hidden;
  `

  const progressBar = document.createElement("div")
  progressBar.id = "progressBar"
  progressBar.classList.add("progress-bar")
  progressBar.style.cssText = `
    height: 100%;
    background-color: #ff0000;
    width: 0%;
    transition: width 0.1s linear;
  `

  progressContainer.appendChild(progressBar)
  audioProgress.appendChild(progressContainer)

  const timeInfo = document.createElement("div")
  timeInfo.classList.add("audio-time")
  timeInfo.style.cssText = `
    display: flex;
    justify-content: space-between;
    color: #4a5568;
    font-size: 0.875rem;
    margin-bottom: 16px;
    font-weight: 500;
  `

  const currentTimeSpan = document.createElement("span")
  currentTimeSpan.id = "currentTime"
  currentTimeSpan.textContent = "0:00"

  const durationSpan = document.createElement("span")
  durationSpan.id = "duration"
  durationSpan.textContent = "0:00"

  timeInfo.appendChild(currentTimeSpan)
  timeInfo.appendChild(durationSpan)

  const audioControls = document.createElement("div")
  audioControls.classList.add("audio-controls")
  audioControls.style.cssText = `
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 24px;
  `

  const rewindBtn = createAudioButton("skip-backward", "rewindBtn")
  const playPauseBtn = createAudioButton("play", "playPauseBtn")
  const forwardBtn = createAudioButton("skip-forward", "forwardBtn")

  audioControls.appendChild(rewindBtn)
  audioControls.appendChild(playPauseBtn)
  audioControls.appendChild(forwardBtn)

  audioPlayerContainer.appendChild(audio)
  audioPlayerContainer.appendChild(audioProgress)
  audioPlayerContainer.appendChild(timeInfo)
  audioPlayerContainer.appendChild(audioControls)

  return audioPlayerContainer
}

function createAudioButton(iconName, id) {
  const button = document.createElement("button")
  button.id = id
  button.classList.add("audio-button")
  button.innerHTML = `<i class="bi bi-${iconName}"></i>`
  button.style.cssText = `
    background-color: white;
    color: #0000ff;
    border: 2px solid #0000ff;
    border-radius: 50%;
    width: 55px;
    height: 55px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.3s ease;
  `

  button.addEventListener("mouseover", () => {
    button.style.backgroundColor = "rgba(0, 0, 255, 0.1)"
  })

  button.addEventListener("mouseout", () => {
    button.style.backgroundColor = "white"
  })

  button.addEventListener("click", () => {
    button.style.backgroundColor = "#0000ff"
    button.style.color = "white"
    button.style.transform = "scale(0.95)"

    setTimeout(() => {
      button.style.backgroundColor = "white"
      button.style.color = "#0000ff"
      button.style.transform = "scale(1)"
    }, 200)
  })

  return button
}

function createBlueBar(location) {
  const blueBar = document.createElement("div")
  blueBar.style.cssText = `
    width: 100%;
    height: 60px;
    background: linear-gradient(to right, #0a1f80, #0f2bab);
    margin-top: auto;
    box-shadow: 0 -2px 10px rgba(0,0,0,0.025);
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0 24px;
    position: sticky;
    bottom: 0;
  `

  const infoButton = document.createElement("button")
  infoButton.innerHTML = '<i class="bi bi-info-circle-fill text-white" style="font-size: 1.5rem; z-index: 2500;"></i>'
  infoButton.classList.add("btn", "btn-sm", "me-2")
  infoButton.onclick = () => {
    if (location && location.imageSource) {
      showPopup("Image Source", location.imageSource)
    } else {
      showPopup("Image Source", "Image source information is not available")
    }
  }

  const feedbackButton = document.createElement("a")
  feedbackButton.href = "mailto:mattreicher@protonmail.com?subject=Feedback"
  feedbackButton.target = "_blank"
  feedbackButton.rel = "noopener noreferrer"
  feedbackButton.innerHTML = '<i class="bi bi-envelope-fill text-white" style="font-size: 1.5rem;"></i>'
  feedbackButton.classList.add("btn", "btn-sm")

  blueBar.appendChild(infoButton)
  blueBar.appendChild(feedbackButton)
  return blueBar
}

function initAudioPlayer() {
  const audio = document.getElementById("locationAudio")
  const playPauseBtn = document.getElementById("playPauseBtn")
  const rewindBtn = document.getElementById("rewindBtn")
  const forwardBtn = document.getElementById("forwardBtn")
  const progressBar = document.getElementById("progressBar")
  const progressContainer = document.querySelector(".progress")
  const currentTimeSpan = document.getElementById("currentTime")
  const durationSpan = document.getElementById("duration")

  if (
    !audio ||
    !playPauseBtn ||
    !rewindBtn ||
    !forwardBtn ||
    !progressBar ||
    !progressContainer ||
    !currentTimeSpan ||
    !durationSpan
  ) {
    console.warn("Audio player elements not found, retrying...")
    requestAnimationFrame(initAudioPlayer)
    return
  }

  let lastProgressUpdate = 0
  const PROGRESS_UPDATE_INTERVAL = 250

  playPauseBtn.addEventListener("click", togglePlay)
  rewindBtn.addEventListener("click", () => seek(-10))
  forwardBtn.addEventListener("click", () => seek(10))

  audio.addEventListener("timeupdate", () => {
    const now = Date.now()
    if (now - lastProgressUpdate > PROGRESS_UPDATE_INTERVAL) {
      lastProgressUpdate = now
      updateProgress()
    }
  })

  audio.addEventListener("loadedmetadata", setDuration)
  audio.addEventListener("ended", () => {
    domUpdateManager.schedule("playPauseBtn", () => {
      playPauseBtn.innerHTML = '<i class="bi bi-play"></i>'
    })
    showAdditionalInfo()
  })

  progressContainer.addEventListener("click", setProgress)

  function togglePlay() {
    if (audio.paused) {
      const playPromise = audio.play()
      if (playPromise !== undefined) {
        playPromise
          .then(() => {
            domUpdateManager.schedule("playPauseBtn", () => {
              playPauseBtn.innerHTML = '<i class="bi bi-pause"></i>'
            })
          })
          .catch((error) => {
            console.error("Audio playback failed:", error)
          })
      }
    } else {
      audio.pause()
      domUpdateManager.schedule("playPauseBtn", () => {
        playPauseBtn.innerHTML = '<i class="bi bi-play"></i>'
      })
    }
  }

  function seek(seconds) {
    audio.currentTime = Math.max(0, Math.min(audio.currentTime + seconds, audio.duration))
  }

  function updateProgress() {
    const percent = (audio.currentTime / audio.duration) * 100
    domUpdateManager.schedule("audioProgress", () => {
      progressBar.style.width = `${percent}%`
      currentTimeSpan.textContent = formatTime(audio.currentTime)
    })
  }

  function setProgress(e) {
    const width = this.clientWidth
    const clickX = e.offsetX
    const duration = audio.duration
    audio.currentTime = (clickX / width) * duration
  }

  function setDuration() {
    domUpdateManager.schedule("audioDuration", () => {
      durationSpan.textContent = formatTime(audio.duration)
    })
  }

  function formatTime(time) {
    const minutes = Math.floor(time / 60)
    const seconds = Math.floor(time % 60)
    return `${minutes}:${seconds.toString().padStart(2, "0")}`
  }
}

function showAdditionalInfo() {
    // Find the location using lastVisitedLocationId
    const location = gameLocations.find(loc => loc.id === lastVisitedLocationId);
    console.log('Current location:', location);
    
    // Set flag to indicate we're returning from exhibit
    isReturningFromExhibit = true;
    
    domUpdateManager.schedule('additionalInfo', () => {
        const additionalInfoContainer = document.querySelector('.additional-info-container');
        if (!additionalInfoContainer) {
            console.error("Additional info container not found");
            return;
        }
        
        additionalInfoContainer.style.display = 'block';
        
        // Add transition class
        additionalInfoContainer.classList.add('location-transition');
        
        // Trigger reflow to ensure transition works
        void additionalInfoContainer.offsetWidth;
        
        // Make visible with transition
        additionalInfoContainer.classList.add('visible');
        
        const additionalInfoElement = document.getElementById('additionalInfo');
        if (additionalInfoElement && location) {
            additionalInfoElement.textContent = location.additionalInfo;
        }

        const continueButton = document.getElementById('continueButton');
        if (continueButton) {
            continueButton.onclick = () => {
                // Fade out with transition
                additionalInfoContainer.classList.remove('visible');
                
                // Hide after transition completes
                setTimeout(() => {
                    additionalInfoContainer.style.display = 'none';
                    
                    // Also hide location hunt container with transition
                    const lochuntContainer = document.querySelector('.lochunt-container');
                    if (lochuntContainer) {
                        lochuntContainer.classList.remove('visible');
                        
                        setTimeout(() => {
                            lochuntContainer.style.display = 'none';
                            isLocationHuntVisible = false;
                            updateDistanceBox();
                        }, 500);
                    }
                }, 500);
            };
        }
    });
}

function showDirectionsModal(lat, lng) {
    const modal = document.getElementById('directionsModal');
    if (!modal) {
        console.error("Directions modal not found");
        return;
    }
    
    modal.style.display = 'block';

    const mapBtn = document.getElementById('mapButton');
    const cancelBtn = document.getElementById('cancelButton');

    if (mapBtn) {
        mapBtn.onclick = () => {
            window.open(`https://www.google.com/maps/dir/?api=1&destination=${lat},${lng}`, '_blank');
            modal.style.display = 'none';
        };
    }

    if (cancelBtn) {
        cancelBtn.onclick = () => {
            modal.style.display = 'none';
        };
    }

    window.onclick = (event) => {
        if (event.target == modal) {
            modal.style.display = 'none';
        }
    };
}

function showErrorMessage(message) {
    const errorContainer = document.createElement('div');
    errorContainer.className = 'error-message';
    errorContainer.style.cssText = `
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background-color: #ff3b30;
        color: white;
        padding: 12px 20px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        z-index: 2000;
        max-width: 90%;
        text-align: center;
        font-weight: 500;
    `;
    errorContainer.textContent = message;
    
    document.body.appendChild(errorContainer);
    
    // Auto-dismiss after 5 seconds
    setTimeout(() => {
        errorContainer.style.opacity = '0';
        errorContainer.style.transition = 'opacity 0.5s ease';
        
        setTimeout(() => {
            if (errorContainer.parentNode) {
                errorContainer.parentNode.removeChild(errorContainer);
            }
        }, 500);
    }, 5000);
}

function toggleNavigationTips() {
  const tipsElement = document.querySelector(".navigation-tips")
  const computedStyle = window.getComputedStyle(tipsElement)

  if (computedStyle.display === "none") {
    tipsElement.style.display = "block"
  } else {
    tipsElement.style.display = "none"
  }

  document.getElementById("tipsButton").classList.toggle("active")
}

function closeNavigationTips() {
  document.querySelector(".navigation-tips").style.display = "none"
  document.getElementById("tipsButton").classList.remove("active")
}

// Wait for both DOM and window load events to be safe
document.addEventListener('DOMContentLoaded', function() {
  startPreloader();
});

function startPreloader() {
  // Check if elements exist to prevent errors
  const preloader = document.getElementById('preloader');
  const progressBar = document.getElementById('preloaderProgress');
  
  if (!preloader || !progressBar) {
    console.error('Preloader elements not found');
    return;
  }
  
  // Make sure the preloader is visible
  preloader.style.display = 'flex';
  preloader.style.opacity = '1';
  
  console.log('Preloader started at:', new Date().toISOString());
  
  // Record exact start time
  const startTime = Date.now();
  const EXACT_DURATION = 10000; //10 seconds in milliseconds
  
  // Reset progress bar
  progressBar.style.width = '0%';
  
  // Transition for smoother animation
  progressBar.style.transition = 'width 0.3s cubic-bezier(0.4, 0.0, 0.2, 1)';
  
  // Use requestAnimationFrame for smoother animation
  let animationId;
  let lastTimestamp = 0;
  
  function updateProgress(timestamp) {
    // Calculate elapsed time since start
    const elapsedTime = Date.now() - startTime;
    
    // Calculate what percentage of our 10 seconds has elapsed
    let progressPercentage = Math.min((elapsedTime / EXACT_DURATION) * 100, 99);
    
    // Update progress bar width
    progressBar.style.width = progressPercentage + '%';
    
    // Continue animation if we haven't reached 10 seconds yet
    if (elapsedTime < EXACT_DURATION) {
      animationId = requestAnimationFrame(updateProgress);
    }
  }
  
  // Start the animation
  animationId = requestAnimationFrame(updateProgress);
  
  // Force the preloader to stay for EXACTLY 10 seconds
  setTimeout(function() {
    // Cancel any ongoing animation
    if (animationId) {
      cancelAnimationFrame(animationId);
    }
    
    // Log the exact time when we're completing
    const actualDuration = Date.now() - startTime;
    console.log('Preloader completing after:', actualDuration, 'ms');
    
    // Ensure progress bar is at 100%
    progressBar.style.width = '100%';
    
    // Wait a small amount of time for the progress bar to reach 100%
    setTimeout(function() {
      // Fade out the preloader
      preloader.style.opacity = '0';
      
      // Remove from DOM after fade completes
      setTimeout(function() {
        preloader.style.display = 'none';
        console.log('Preloader hidden at:', new Date().toISOString());
      }, 500);
    }, 200);
  }, EXACT_DURATION); // Exactly 10 seconds
  
  // Additional safeguard - force check at 10.5 seconds to ensure it's completed
  setTimeout(function() {
    const finalDuration = Date.now() - startTime;
    console.log('Final safeguard check after:', finalDuration, 'ms');
    
    if (preloader.style.opacity !== '0') {
      console.log('Forcing preloader completion');
      preloader.style.opacity = '0';
      
      setTimeout(function() {
        preloader.style.display = 'none';
      }, 500);
    }
  }, EXACT_DURATION + 500); // 10.5 seconds
}

function getMarkerColor(tours) {
  switch (tours.toLowerCase()) {
    case "person":
      return "#FFA500"
    case "gangster":
      return "#3f9b0b"
    case "event":
      return "#8B0000"
    case "place":
      return "#0f2bab"
    default:
      return "#0f2bab"
  }
}

function loadAllLocations() {
    gameLocations.forEach((location, index) => {
        const markerColor = getMarkerColor(location.tours);
        
        const locationMarker = L.marker([location.lat, location.lng], {
            icon: L.divIcon({
                className: 'custom-pin-icon',
                html: `<div class="pin-head" style="background-color: ${markerColor};">
                       </div>`,
                iconSize: [30, 30],
                iconAnchor: [15, 30],
            })
        });
                
        const popupContent = `
            <div class="popup-content">
                <img src="${location.image}" alt="${location.name}" class="location-image">
                <h4 class="location-name">
                    <a href="${location.link}" target="_blank" rel="noopener noreferrer" style="text-decoration: none; color: inherit;">${location.name}</a>
                </h4>
                <div class="popup-buttons">
                    <button class="button route-button" data-lat="${location.lat}" data-lng="${location.lng}">Directions</button>
                    <button class="button summary-button" data-location-id="${location.id}">Summary</button>
                </div>
            </div>
        `;
        locationMarker.bindPopup(popupContent, {
            offset: L.point(0, -25),
            className: 'custom-popup'
        });
        
        locationMarker.on('popupopen', function(e) {
            const popup = e.popup._contentNode;
            const routeButton = popup.querySelector('.route-button');
            const summaryButton = popup.querySelector('.summary-button');
            
            if (routeButton) {
                routeButton.addEventListener('click', function(event) {
                    event.preventDefault();
                    const lat = this.getAttribute('data-lat');
                    const lng = this.getAttribute('data-lng');
                    
                    // Create and show the modal
                    const modal = document.createElement('div');
                    modal.className = 'modal';
                    modal.innerHTML = `
                        <div class="modal-content">
                            <h3>Choose your preferred navigation app:</h3>
                            <div class="modal-buttons">
                                <button class="modal-button google-maps">
                                    Google Maps
                                </button>
                                <button class="modal-button waze">
                                    Waze
                                </button>
                                <button class="modal-button apple-maps">
                                    Apple Maps
                                </button>
                                <button class="modal-button cancel">Cancel</button>
                            </div>
                        </div>
                    `;

// direction modal styles
if (!document.querySelector('#modal-styles')) {
    const style = document.createElement('style');
    style.id = 'modal-styles';
    style.textContent = `
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.75);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            padding: 16px;
            backdrop-filter: blur(4px);
        }
        .modal-content {
            background: white;
            padding: 24px 16px;
            border-radius: 16px;
            width: 100%;
            max-width: 320px;
            text-align: center;
            box-shadow: 0 20px 40px rgba(0,0,0,0.2);
        }
        .modal-buttons {
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            align-items: center;
        }
        .modal-button {
            padding: 16px;
            border-radius: 12px;
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: 500;
            border: none;
            cursor: pointer;
            transition: transform 0.15s ease;
        }
        .modal-button:active {
            transform: scale(0.98);
        }
        .google-maps {
            background: #4285F4;
            color: white;
            box-shadow: 0 2px 8px rgba(66,133,244,0.3);
        }
        .waze {
            background: #33ccff;
            color: white;
            box-shadow: 0 2px 8px rgba(51,204,255,0.3);
        }
        .apple-maps {
            background: #000000;
            color: white;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
        .cancel {
            background: #f2f2f2;
            color: #666;
        }
    `;
    document.head.appendChild(style);
}

                    document.body.appendChild(modal);

                    // Handle button clicks
                    modal.querySelector('.google-maps').addEventListener('click', () => {
                        window.location.href = `https://www.google.com/maps/dir/?api=1&destination=${lat},${lng}`;
                        modal.remove();
                    });

                    modal.querySelector('.waze').addEventListener('click', () => {
                        window.location.href = `https://www.waze.com/ul?ll=${lat}%2C${lng}&navigate=yes`;
                        modal.remove();
                    });

                    modal.querySelector('.apple-maps').addEventListener('click', () => {
                        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
                        if (isIOS) {
                            window.location.href = `maps://maps.apple.com/?daddr=${lat},${lng}`;
                            modal.remove();
                        } else {
                            const alertEl = document.createElement('div');
                            alertEl.className = 'modal';
                            alertEl.innerHTML = `
                                <div class="modal-content">
                                    <p>Apple Maps is only available on iOS devices</p>
                                    <button class="modal-button">OK</button>
                                </div>
                            `;
                            document.body.appendChild(alertEl);
                            alertEl.querySelector('button').onclick = () => {
                                alertEl.remove();
                                // Don't remove the original modal when showing the alert
                                return false;
                            };
                        }
                    });
                    
                    modal.querySelector('.cancel').addEventListener('click', () => {
                        modal.remove();
                    });

                    // Close modal if clicking outside
                    modal.addEventListener('click', (e) => {
                        if (e.target === modal) {
                            modal.remove();
                        }
                    });
                });
            }
            
            if (summaryButton) {
                summaryButton.addEventListener('click', function(event) {
                    event.preventDefault();
                    const locationId = this.getAttribute('data-location-id');
                    showLocationSummary(locationId);
                });
            }
        });
        
        markerClusterGroup.addLayer(locationMarker);
    });
    map.addLayer(markerClusterGroup);
    updateDistanceBox();
    resetInactivityTimer();
} 

function returnToIndex() {
  // Create popup with proper centering and animation
  const popupDiv = document.createElement("div");
  popupDiv.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,0.6);
    backdrop-filter: blur(4px);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
    opacity: 0;
    transition: opacity 0.3s ease;
  `;
  // Using #1a3a8a as the dark blue color
  const darkBlue = "#1a3a8a";
  const darkBlueHover = "#0d2c6e";
  popupDiv.innerHTML = `
    <div class="modal-container" style="
      background-color: white;
      border-radius: 16px;
      padding: 28px;
      width: 90%;
      max-width: 420px;
      max-height: 90vh;
      box-shadow: 0 15px 40px rgba(0,0,0,0.2);
      margin: auto;
      transform: translateY(20px);
      transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      overflow: hidden;
      display: flex;
      flex-direction: column;
    ">
      <div style="
        text-align: center;
        margin-bottom: 25px;
      ">
        <svg width="50" height="50" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <circle cx="12" cy="12" r="10" stroke="${darkBlue}" stroke-width="1.5"/>
          <path d="M12 8V13" stroke="${darkBlue}" stroke-width="2" stroke-linecap="round"/>
          <circle cx="12" cy="16" r="1" fill="${darkBlue}"/>
        </svg>
      </div>
      <h3 style="
        text-align: center;
        margin: 0 0 15px 0;
        color: #2c3e50;
        font-size: 1.5rem;
        font-weight: 600;
      ">Ready to Leave?</h3>
      <div style="flex-grow: 1; overflow-y: auto; padding: 0 10px;">
        <p style="
          text-align: center;
          margin: 0 0 30px 0;
          color: #5c6c7c;
          line-height: 1.5;
          font-size: 1rem;
        ">Are you sure you want to return to the main page?</p>
      </div>
      <div style="
        display: flex;
        justify-content: center;
        gap: 15px;
        margin-bottom: 15px;
      ">
        <button class="confirm-btn" style="
          padding: 14px 24px;
          background-color: ${darkBlue};
          color: white;
          border: none;
          border-radius: 10px;
          cursor: pointer;
          font-size: 1rem;
          font-weight: 600;
          min-width: 130px;
          transition: all 0.2s ease;
        ">Yes, Exit</button>
        <button class="cancel-btn" style="
          padding: 14px 24px;
          background-color: transparent;
          color: ${darkBlue};
          border: 1.5px solid ${darkBlue};
          border-radius: 10px;
          cursor: pointer;
          font-size: 1rem;
          font-weight: 600;
          min-width: 130px;
          transition: all 0.2s ease;
        ">Stay Here</button>
      </div>
      <div style="text-align: center; margin-top: 15px;">
        <a href="#" class="credits-link" style="
          display: inline-block;
          text-align: center;
          color: #64748b;
          text-decoration: none;
          font-size: 0.9rem;
          padding: 8px 20px;
          border-radius: 100px;
          border: 1px solid rgba(100, 116, 139, 0.2);
          background-color: rgba(100, 116, 139, 0.05);
          transition: all 0.2s ease;
        ">View Acknowledgements</a>
      </div>
    </div>
  `;
  document.body.appendChild(popupDiv);
  // Trigger animation
  setTimeout(() => {
    popupDiv.style.opacity = "1";
    popupDiv.querySelector(".modal-container").style.transform = "translateY(0)";
  }, 10);
  // Button hover effects
  const confirmBtn = popupDiv.querySelector(".confirm-btn");
  confirmBtn.addEventListener("mouseover", function() {
    this.style.backgroundColor = darkBlueHover;
  });
  confirmBtn.addEventListener("mouseout", function() {
    this.style.backgroundColor = darkBlue;
  });
  const cancelBtn = popupDiv.querySelector(".cancel-btn");
  cancelBtn.addEventListener("mouseover", function() {
    this.style.backgroundColor = "rgba(26, 58, 138, 0.05)";
  });
  cancelBtn.addEventListener("mouseout", function() {
    this.style.backgroundColor = "transparent";
  });
  const creditsLink = popupDiv.querySelector(".credits-link");
  creditsLink.addEventListener("mouseover", function() {
    this.style.backgroundColor = "rgba(100, 116, 139, 0.1)";
    this.style.borderColor = "rgba(100, 116, 139, 0.3)";
  });
  creditsLink.addEventListener("mouseout", function() {
    this.style.backgroundColor = "rgba(100, 116, 139, 0.05)";
    this.style.borderColor = "rgba(100, 116, 139, 0.2)";
  });
  // Event listeners
  confirmBtn.addEventListener("click", function() {
    popupDiv.style.opacity = "0";
    popupDiv.querySelector(".modal-container").style.transform = "translateY(20px)";
    setTimeout(() => {
      document.body.removeChild(popupDiv);
      window.location.href = "/index.html";
    }, 300);
  });
  cancelBtn.addEventListener("click", function() {
    popupDiv.style.opacity = "0";
    popupDiv.querySelector(".modal-container").style.transform = "translateY(20px)";
    setTimeout(() => {
      document.body.removeChild(popupDiv);
    }, 300);
  });
  creditsLink.addEventListener("click", function(e) {
    e.preventDefault();
    // Simplified credits popup with dark blue
    const creditsPopup = document.createElement("div");
    creditsPopup.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.7);
      backdrop-filter: blur(6px);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1001;
      opacity: 0;
      transition: opacity 0.3s ease;
    `;
    creditsPopup.innerHTML = `
      <div class="credits-container" style="
        background-color: white;
        border-radius: 16px;
        width: 92%;
        max-width: 450px;
        max-height: 80vh;
        box-shadow: 0 20px 50px rgba(0,0,0,0.25);
        margin: auto;
        transform: translateY(20px);
        transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        overflow: hidden;
        display: flex;
        flex-direction: column;
      ">
        <div style="
          background-color: ${darkBlue};
          padding: 20px;
          color: white;
          text-align: center;
        ">
          <h3 style="margin: 0; font-size: 1.5rem; font-weight: 600;">Acknowledgements</h3>
        </div>
        <div style="
          padding: 20px;
          flex-grow: 1;
          overflow-y: auto;
        ">
          <ul style="list-style-type: none; padding: 0; margin: 0;">
            <li style="margin-bottom: 20px;">
              <strong style="color: #1e293b; font-size: 1.05rem;">OpenStreetMap</strong>
              <p style="color: #64748b; margin: 5px 0 0 0; font-size: 0.9rem; line-height: 1.5;">
                Providing the map data and tiles for this interactive experience.
              </p>
            </li>
            <li style="margin-bottom: 20px;">
              <strong style="color: #1e293b; font-size: 1.05rem;">Minnesota Historical Society</strong>
              <p style="color: #64748b; margin: 5px 0 0 0; font-size: 0.9rem; line-height: 1.5;">
                For their invaluable historical data, photographs, and archive materials.
              </p>
            </li>
            <li style="margin-bottom: 20px;">
              <strong style="color: #1e293b; font-size: 1.05rem;">Metropolitan State University</strong>
              <p style="color: #64748b; margin: 5px 0 0 0; font-size: 0.9rem; line-height: 1.5;">
                For fostering a passion for history and research methodology.
              </p>
            </li>
            <li style="margin-bottom: 20px;">
              <strong style="color: #1e293b; font-size: 1.05rem;">Leaflet.js</strong>
              <p style="color: #64748b; margin: 5px 0 0 0; font-size: 0.9rem; line-height: 1.5;">
                The open-source JavaScript library that powers the mapping features.
              </p>
            </li>
            <li>
              <strong style="color: #1e293b; font-size: 1.05rem;">All Contributors</strong>
              <p style="color: #64748b; margin: 5px 0 0 0; font-size: 0.9rem; line-height: 1.5;">
                Researchers, testers, and developers who made this project possible.
              </p>
            </li>
          </ul>
        </div>
        <div style="padding: 15px; text-align: center; border-top: 1px solid #eee;">
          <button class="close-credits-btn" style="
            padding: 12px 30px;
            background-color: ${darkBlue};
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 0.95rem;
            font-weight: 600;
            transition: background-color 0.2s ease;
          ">Close</button>
        </div>
      </div>
    `;
    document.body.appendChild(creditsPopup);
    // Trigger animation
    setTimeout(() => {
      creditsPopup.style.opacity = "1";
      creditsPopup.querySelector(".credits-container").style.transform = "translateY(0)";
    }, 10);
    // Close button interaction
    const closeBtn = creditsPopup.querySelector(".close-credits-btn");
    closeBtn.addEventListener("mouseover", function() {
      this.style.backgroundColor = darkBlueHover;
    });
    closeBtn.addEventListener("mouseout", function() {
      this.style.backgroundColor = darkBlue;
    });
    closeBtn.addEventListener("click", function() {
      creditsPopup.style.opacity = "0";
      creditsPopup.querySelector(".credits-container").style.transform = "translateY(20px)";
      setTimeout(() => {
        document.body.removeChild(creditsPopup);
      }, 300);
    });
  });
  document.getElementById("returnButton").classList.remove("active");
}
        
function showLocationSummary(locationId) {
    console.log("Showing summary for location ID:", locationId);
    
    const location = gameLocations.find(loc => loc.id === locationId);
    console.log("Found location:", location);
    
    if (location && location.summary) {
        domUpdateManager.schedule('summaryModal', () => {
            const modal = document.getElementById('summaryModal');
            const summaryContent = document.getElementById('summaryContent');
            
            if (!modal || !summaryContent) {
                console.error("Summary modal elements not found");
                return;
            }
            
            // Get marker color or use default
            const markerColor = location.tours ? getMarkerColor(location.tours) : "#0f2bab";
            const lightColor = adjustColor(markerColor, 90); // Create a lighter shade for accents
            
            // Modal background with subtle animation
            modal.style.backgroundColor = 'rgba(0, 0, 0, 0.75)';
            modal.style.display = 'flex';
            modal.style.justifyContent = 'center';
            modal.style.alignItems = 'center';
            modal.style.backdropFilter = 'blur(5px)';
            modal.style.transition = 'opacity 0.3s ease';
            modal.style.opacity = '0';
            setTimeout(() => { modal.style.opacity = '1'; }, 10);
            
            const modalContent = modal.querySelector('.modal-content');
            if (modalContent) {
                modalContent.style.cssText = `
                    background-color: white;
                    padding: 0;
                    border-radius: 16px;
                    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
                    max-width: 500px;
                    width: 90%;
                    max-height: 85vh;
                    overflow-y: auto;
                    position: relative;
                    transform: translateY(0);
                    transition: transform 0.3s ease-out;
                `;
            }
            
            const closeBtn = modal.querySelector('.close');
            if (closeBtn) {
                closeBtn.remove();
            }
            
            summaryContent.style.textAlign = 'left';
            summaryContent.innerHTML = `
                <div class="location-header" style="
                    background: ${markerColor};
                    border-radius: 16px 16px 0 0;
                    padding: 24px 20px;
                    position: relative;
                ">
                    <h3 class="summary-heading" style="
                        font-size: 22px;
                        margin: 0;
                        color: white;
                        text-align: center;
                        font-weight: 600;
                        letter-spacing: 0.02em;
                    ">${location.name}</h3>
                </div>
                
<div style="padding: 20px 24px;">
    <p style="
        line-height: 1.7;
        margin-bottom: 20px;
        color: #333;
        font-size: 18px;
        font-weight: 400;
    ">
        ${location.summary}
    </p>
    
    <div style="
        background: white;
        padding: 16px;
        border-radius: 12px;
        border: 3px solid ${markerColor};
        margin-bottom: 24px;
        display: flex;
        align-items: center;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
    ">
        <div style="
            background: ${markerColor};
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 14px;
        ">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M12 13C13.6569 13 15 11.6569 15 10C15 8.34315 13.6569 7 12 7C10.3431 7 9 8.34315 9 10C9 11.6569 10.3431 13 12 13Z" fill="white"/>
                <path d="M12 2C7.589 2 4 5.589 4 10C4 14.4 7.589 18 12 18C16.411 18 20 14.4 20 10C20 5.589 16.411 2 12 2ZM12 15C10.6739 15 9.40215 14.4732 8.46447 13.5355C7.52678 12.5979 7 11.3261 7 10C7 8.67392 7.52678 7.40215 8.46447 6.46447C9.40215 5.52678 10.6739 5 12 5C13.3261 5 14.5979 5.52678 15.5355 6.46447C16.4732 7.40215 17 8.67392 17 10C17 11.3261 16.4732 12.5979 15.5355 13.5355C14.5979 14.4732 13.3261 15 12 15Z" fill="white"/>
                <path d="M12 20L6.4 16.8C5.4 17.3 4.6 18 4.6 19C4.6 20.7 7.9 22 12 22C16.1 22 19.4 20.7 19.4 19C19.4 18 18.6 17.3 17.6 16.8L12 20Z" fill="white"/>
            </svg>
        </div>
        <div>
            <p style="
                line-height: 1.6;
                margin: 0;
                font-size: 16px;
                color: #333;
            ">
                <strong style="color: ${markerColor};">Location:</strong>
                <span style="margin-left: 6px;">${location.today || "Current Position"}</span>
            </p>
        </div>
    </div>
                    
                    <button id="summaryCloseBtn" style="
                        display: block;
                        width: 100%;
                        padding: 14px;
                        color: white;
                        background-color: ${markerColor};
                        border: none;
                        border-radius: 12px;
                        cursor: pointer;
                        font-size: 16px;
                        font-weight: 600;
                        transition: all 0.25s ease;
                        margin: 0 0 6px 0;
                        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
                    ">Continue</button>
                </div>
            `;
            
            const continueButton = document.getElementById('summaryCloseBtn');
            if (continueButton) {
                continueButton.onmouseover = function() {
                    this.style.transform = 'translateY(-2px)';
                    this.style.boxShadow = '0 6px 12px rgba(0, 0, 0, 0.2)';
                    this.style.backgroundColor = adjustColor(markerColor, -10); // Slightly darker on hover
                };
                
                continueButton.onmouseout = function() {
                    this.style.transform = 'translateY(0)';
                    this.style.boxShadow = '0 4px 10px rgba(0, 0, 0, 0.15)';
                    this.style.backgroundColor = markerColor;
                };
                
                continueButton.onclick = function() {
                    modal.style.opacity = '0';
                    setTimeout(() => { modal.style.display = 'none'; }, 300);
                };
            }
            
            // Close on clicking outside
            window.onclick = function(event) {
                if (event.target === modal) {
                    modal.style.opacity = '0';
                    setTimeout(() => { modal.style.display = 'none'; }, 300);
                }
            };
        });
    } else {
        console.log("Location or summary not found. Location ID:", locationId);
        console.log("Available IDs:", gameLocations.map(loc => loc.id));
        showPopup("Error", "Summary not available for this location.");
    }
}

// Helper function to create lighter/darker color variations
function adjustColor(hex, percent) {
    // Convert hex to RGB
    let r = parseInt(hex.substring(1, 3), 16);
    let g = parseInt(hex.substring(3, 5), 16);
    let b = parseInt(hex.substring(5, 7), 16);

    // Make lighter or darker
    r = Math.min(255, Math.max(0, r + percent));
    g = Math.min(255, Math.max(0, g + percent));
    b = Math.min(255, Math.max(0, b + percent));

    // Convert back to hex
    return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
}
        
function startHunt() {
    // Check network status before starting
    if (!navigator.onLine) {
        showErrorMessage("No internet connection. Please connect to the internet and try again.");
        
        // Use a single setTimeout that will only trigger if online
        setTimeout(() => navigator.onLine && startHunt(), 5000);
        return;
    }
    
    try {
        // Simplified check and assignment with fallback
        gameLocations = (typeof locations !== 'undefined' && Array.isArray(locations)) 
            ? locations.sort((a, b) => a.id - b.id) 
            : [];
        
        if (!gameLocations.length) {
            console.warn("Locations data is not available");
        }
        
        // Reset game state
        currentLocationIndex = 0;
        locationCooldowns = {};
        lastVisitedLocationId = null;
        
        // Preload all location images before starting
        preloadImages(gameLocations)
            .then(() => {
                // Hide preloader when images are loaded
                const preloader = document.getElementById('preloader');
                if (preloader) {
                    preloader.style.opacity = '0';
                    preloader.style.transition = 'opacity 0.5s ease';
                    setTimeout(() => preloader?.parentNode?.removeChild(preloader), 500);
                }
                
                loadAllLocations();
            })
            .catch(error => {
                console.error("Error preloading images:", error);
                showErrorMessage("Error loading resources. Please check your connection and try again.");
                
                // Try to continue anyway after a delay
                setTimeout(loadAllLocations, 3000);
            });
    } catch (error) {
        console.error("Error starting hunt:", error);
        showErrorMessage("Error opening the museum. Please reload the page.");
    }
}

// Initialize the map when the DOM is loaded
document.addEventListener("DOMContentLoaded", () => {
  // Initialize the map and start preloading images
  initMap()
  addUIEventListeners()
  addMapEventListeners()
})

// Export the main functions and classes for testing
if (typeof module !== 'undefined' && module.exports) {
  module.exports = {
    KalmanFilter,
    PositionInterpolator,
    AdaptiveKalmanFilterFactory,
    calculateDistance,
    calculateZoomLevel,
    checkProximityForZoom,
    processPositionUpdate,
    updateUserLocation,
    enhancedMotionDetection,
    predictNextPosition
  };
}

document.addEventListener("DOMContentLoaded", function() {
    const facts = [
        "Did you know? Minnesota became the 32nd U.S. state on May 11, 1858.",
        "Northern Minnesota's Iron Range was once a world-leading iron ore producer.",
        "The first Greyhound bus line began in Hibbing, Minnesota in 1914.",
        "The Mayo Clinic in Rochester is one of the world's most prestigious medical facilities.",
        "The Minneapolis Skyway System is the largest contiguous skyway system in the world.",
        "Minnesota's official state bird is the common loon.",
        "The Minnesota State Fair began in 1859 and is one of the largest state fairs in the United States."
    ];
    
    // Get elements
    const factElement = document.getElementById("loadingFacts").querySelector("p");
    const factsContainer = document.getElementById("loadingFacts");
    const progressBar = document.getElementById("preloaderProgress");
    
    // Set initial fact
    let currentFact = 0;
    factElement.textContent = facts[currentFact];
    
    // Responsive styles with improved progress bar transition
    const style = document.createElement('style');
    style.textContent = `
        /* Progress bar styles - improved transition */
        #preloaderProgress {
            transition: width 0.3s cubic-bezier(0.4, 0.0, 0.2, 1) !important;
            will-change: width !important;
        }
        
        /* Facts container styles */
        #loadingFacts {
            border-left: none !important;
            background-color: transparent !important;
            width: 100% !important;
            max-width: 600px !important;
            height: 120px !important; /* Fixed height */
            margin: 0 auto !important;
            padding: 10px 15px !important;
            box-sizing: border-box !important;
            display: flex !important;
            flex-direction: column !important;
            justify-content: center !important;
            align-items: flex-start !important; 
            overflow: hidden !important; 
        }
        
        /* Facts text styles */
        #loadingFacts p {
            width: 100% !important;
            text-align: left !important; 
            font-size: 22px !important; 
            font-weight: 500 !important;
            line-height: 1.4 !important;
            margin: 0 !important;
            padding: 0 !important;
            transition: opacity 0.5s ease !important;
        }
        
        /* Responsive adjustments */
        @media (max-width: 768px) {
            #loadingFacts {
                height: 140px !important; /* Slightly taller on mobile */
                max-width: 90% !important; /* Responsive width */
            }
            
            #loadingFacts p {
                font-size: 22px !important; 
            }
        }
        
        @media (max-width: 480px) {
            #loadingFacts {
                height: 160px !important; 
            }
            
            #loadingFacts p {
                font-size: 18px !important; 
            }
        }
    `;
    document.head.appendChild(style);
    
    // Progress bar animation setup
    const startTime = new Date().getTime();
    const minimumLoadTime = 10000; // 10 seconds minimum 
    const duration = 10000; // 10 seconds for the animation 
    let animationStartTime;
    
    // Use requestAnimationFrame for smoother animation
    function animateProgressBar(timestamp) {
        if (!animationStartTime) animationStartTime = timestamp;
        
        const elapsed = timestamp - animationStartTime;
        const progress = Math.min(elapsed / duration * 100, 100);
        
        // Update progress bar width
        progressBar.style.width = progress + "%";
        
        // Continue animation if not complete
        if (progress < 100) {
            requestAnimationFrame(animateProgressBar);
        } else {
            // Animation complete
            const currentTime = new Date().getTime();
            const totalElapsed = currentTime - startTime;
            
            if (totalElapsed < minimumLoadTime) {
                // Ensure we wait until the full 10 seconds have passed
                setTimeout(() => {
                    console.log("Loading complete - minimum time of 10 seconds reached");
                }, minimumLoadTime - totalElapsed);
            } else {
                console.log("Loading complete - exceeded minimum time of 10 seconds");
            }
        }
    }
    
    // Start the smooth animation
    requestAnimationFrame(animateProgressBar);
    
    // Rotate facts with fade transition
    // With a 10-second loading time, we'll show about 2 facts during the loading period
    setInterval(() => {
        // Fade out
        factElement.style.opacity = 0;
        
        // Change text and fade in
        setTimeout(() => {
            currentFact = (currentFact + 1) % facts.length;
            factElement.textContent = facts[currentFact];
            factElement.style.opacity = 1;
        }, 500);
    }, 5000);
});

document.addEventListener('visibilitychange', () => {
  if (!document.hidden) {
    // Flag that we're coming from background
    const wasHidden = true;
    
    // More generous timeout to allow layout to settle
    setTimeout(() => {
      map.invalidateSize({animate: false, pan: false});
      
      // If we have a valid user position, center on it immediately
      if (userMarker && lastRenderPosition) {
        // Skip all animations when centering
        map.setView([lastRenderPosition.lat, lastRenderPosition.lng], map.getZoom(), {
          animate: false,
          noMoveStart: true,
          duration: 0
        });
        
        // Force marker to exact position without smoothing
        userMarker.setLatLng([lastRenderPosition.lat, lastRenderPosition.lng]);
      }
    }, 250); // Slightly longer timeout
  }
});
        
console.log("Kalman filter implementation optimized successfully!");
    </script>
  </body>
</html>
