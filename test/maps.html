<!doctype html>
<html lang="en">
<head> 
    <!-- Primary Meta Tags -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Minnesota Then | Museum Without Walls</title>
    <meta name="description" content="Explore Minnesota history on interactive mapsâ€”GPS-guided, offline-ready tours with historic photos, audio, and spatial analysis.">
    <meta name="keywords" content="Minnesota history tours, interactive map, location-based museum, offline GIS, historical audio tours, mobile history app">
    
    <!-- Favicon -->
    <link rel="shortcut icon" type="image/x-icon" href="https://www.mnthen.com/images/mnthenfav.ico">
    
    <!-- Enhanced PWA Manifest -->
    <link rel="manifest" href="/manifest.json">
    <meta name="theme-color" content="#2c5282">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Minnesota Then">

    <!-- Enterprise Security Headers -->
    <meta http-equiv="X-Content-Type-Options" content="nosniff">
    <meta http-equiv="X-Frame-Options" content="SAMEORIGIN">
    <meta http-equiv="X-XSS-Protection" content="1; mode=block">
    <meta http-equiv="Referrer-Policy" content="strict-origin-when-cross-origin">
    <meta http-equiv="Permissions-Policy" content="geolocation=(self), camera=(), microphone=(), payment=(), usb=()">
    <meta http-equiv="Cross-Origin-Embedder-Policy" content="unsafe-none">
    <meta http-equiv="Cross-Origin-Opener-Policy" content="same-origin">
    <meta http-equiv="Strict-Transport-Security" content="max-age=31536000; includeSubDomains; preload">
    
    <meta name="referrer" content="strict-origin-when-cross-origin">
    <meta name="color-scheme" content="light">
    
    <!-- Open Graph / Facebook Meta Tags -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://www.mnthen.com/">
    <meta property="og:title" content="Minnesota Then | Museum Without Walls">
    <meta property="og:description" content="Enterprise-grade historical GIS platform with advanced spatial analysis and offline capabilities.">
    <meta property="og:image" content="https://mnthen.com/images/index/index_1.jpg">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    
    <!-- Twitter Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@MinnesotaThen">
    <meta name="twitter:title" content="Minnesota Then | Museum Without Walls">
    <meta name="twitter:description" content="Enterprise-grade historical GIS platform with advanced spatial analysis capabilities.">
    <meta name="twitter:image" content="https://mnthen.com/images/index/index_1.jpg">
    
    <!-- Canonical URL -->
    <link rel="canonical" href="https://www.mnthen.com/">

    <!-- Resource hints for faster connections -->
    <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
    <link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
    <link rel="preconnect" href="https://unpkg.com" crossorigin>
    <link rel="preconnect" href="https://www.mnthen.com" crossorigin>

    <!-- DNS Prefetch for additional domains -->
    <link rel="dns-prefetch" href="//tile.openstreetmap.org">
    <link rel="dns-prefetch" href="//a.tile.openstreetmap.org">
    <link rel="dns-prefetch" href="//b.tile.openstreetmap.org">
    <link rel="dns-prefetch" href="//c.tile.openstreetmap.org">
    <link rel="dns-prefetch" href="//fonts.googleapis.com">
    <link rel="dns-prefetch" href="//fonts.gstatic.com">

    <!-- Critical CSS - Load synchronously to prevent FOUC -->
    <link rel="stylesheet" href="https://www.mnthen.com/css/mainmap.css">
    <link rel="stylesheet" href="https://www.mnthen.com/css/mnthen_main_map2.css">

    <!-- Framework CSS - Load synchronously -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" crossorigin>

    <!-- Icon fonts - Load synchronously -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css" crossorigin>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.css" crossorigin>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" crossorigin>
    
    <!-- Standard CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css">
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css">
    
    <!-- Structured Data -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebApplication",
      "name": "Minnesota Then",
      "alternateName": "Minnesota Then Enterprise GIS",
      "url": "https://www.mnthen.com",
      "description": "Enterprise-grade historical GIS platform for Minnesota with advanced spatial analysis and offline capabilities.",
      "applicationCategory": ["ProductivityApplication", "EducationApplication"],
      "operatingSystem": "Web",
      "browserRequirements": "Requires JavaScript. Compatible with modern browsers.",
      "softwareVersion": "2.0",
      "datePublished": "2024-01-01",
      "dateModified": "2025-01-05",
      "inLanguage": "en-US",
      "isAccessibleForFree": true,
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "USD",
        "availability": "https://schema.org/InStock"
      },
      "creator": {
        "@type": "Organization",
        "name": "Minnesota Then",
        "url": "https://www.mnthen.com"
      },
      "featureList": [
        "Interactive historical maps",
        "Location-based tours",
        "Offline map capabilities",
        "Spatial analysis tools",
        "Historical content exploration"
      ],
      "screenshot": "https://www.mnthen.com/images/social-share.jpg",
      "aggregateRating": {
        "@type": "AggregateRating",
        "ratingValue": "4.8",
        "ratingCount": "150"
      }
    }
    </script>

    <!-- Geolocation Schema -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "TouristDestination",
      "name": "Minnesota Historical Sites",
      "description": "Explore historical locations across Minnesota with enterprise GIS capabilities",
      "geo": {
        "@type": "GeoCoordinates",
        "latitude": "46.7296",
        "longitude": "-94.6859"
      },
      "containedInPlace": {
        "@type": "State",
        "name": "Minnesota",
        "addressCountry": "US"
      },
      "touristType": [
        "History enthusiasts",
        "Educational groups",
        "Cultural tourists"
      ],
      "availableLanguage": "en-US"
    }
    </script>

    <!-- Organization Schema -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Organization",
      "name": "Minnesota Then",
      "url": "https://www.mnthen.com",
      "logo": "https://www.mnthen.com/images/mnthenfav.ico",
      "sameAs": [
        "https://twitter.com/MinnesotaThen"
      ],
      "foundingDate": "2024",
      "description": "Digital platform preserving and sharing Minnesota's historical heritage through interactive mapping technology.",
      "knowsAbout": [
        "Minnesota History",
        "Historical GIS",
        "Digital Heritage",
        "Interactive Maps"
      ]
    }
    </script>

<style>
/* ==========================================================================
   0. FOUC-PROOF RENDER LOCK
   ========================================================================== */
/* Hide the entire document until every stylesheet & font is ready.
   The .unlock class is added by inline JS once window.load fires. */
html {
  visibility: hidden !important;
}
html.unlock {
  visibility: visible !important;
}

/* ==========================================================================
   1. DESIGN TOKENS
   ========================================================================== */
:root {
  --primary-color:       #0066cc;
  --hover-color:         #e6f0ff;
  --dark-blue:           #1a3a8a;
  --dark-blue-hover:     #0d2c6e;
  --success-color:       #28a745;
  --warning-color:       #ffc107;
  --error-color:         #dc3545;
}

/* ==========================================================================
   2. RESET & GLOBAL HELPERS
   ========================================================================== */
*,
*::before,
*::after { box-sizing: border-box; }

body {
  margin: 0;
  padding: 0;
  font-family: Inter, system-ui, Avenir, Helvetica, Arial, sans-serif;
  background-color: #f8f9fa;
  /* Removed opacity/visibility overrides; handled by html.unlock */
}

/* ==========================================================================
   3. MAP CANVAS
   ========================================================================== */
#map {
  position: fixed;
  top: 0;
  left: 0;
  z-index: 1;
  width: 100vw;
  height: 100vh;       /* fallback */
  height: 100dvh;      /* modern dynamic viewport */
  touch-action: none;
  -webkit-user-select: none;
  user-select: none;
  will-change: transform;
}

/* iOS 100vh fix */
@supports (-webkit-touch-callout: none) {
  #map,
  .lochunt-container {
    height: -webkit-fill-available;
  }
}

/* dvh fallback */
@supports not (height: 100dvh) {
  #map { height: 100vh; }
}

/* ==========================================================================
   4. COMPONENTS
   ========================================================================== */

/* 4.1 Distance indicator */
#distanceBox {
  position: fixed;
  top: 20px;
  right: 20px;
  z-index: 1003;
  background: white;
  padding: 12px 24px;
  border-radius: 50px;
  font-weight: 600;
  font-size: 20px;
  text-align: center;
  min-width: 200px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
  border: 3px solid var(--dark-blue);
  transition: all 0.3s ease;
  opacity: 0;           /* hidden until hydrated */
  visibility: hidden;
}

#distanceBox.show {
  opacity: 1;
  visibility: visible;
}

#distanceBox.proximity-close {
  background: linear-gradient(135deg, #28a745, #20c997);
  color: white;
  animation: pulse 1.5s infinite;
}

#distanceBox.proximity-medium {
  background: linear-gradient(135deg, #ffc107, #fd7e14);
  color: white;
}

#distanceBox.proximity-far {
  background: white;
  color: var(--dark-blue);
  border-color: var(--dark-blue);
}

/* 4.2 Map action buttons */
.map-buttons {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  display: flex;
  justify-content: space-evenly;
  align-items: center;
  gap: 0.5rem;
  margin-bottom: 20px;
}

/* 4.3 Markers */
.user-marker-icon {
  width: 20px;
  height: 20px;
  background: radial-gradient(circle, #dc3545 0%, #a71e2a 70%);
  border: 3px solid white;
  border-radius: 50%;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
  transition: all 0.3s ease;
  z-index: 2000 !important; /* Above clusters */
}

.user-marker-icon.moving {
  animation: pulse 2s infinite;
}

.marker-cluster-custom {
  background: rgba(44, 82, 130, 0.9);
  border-radius: 50%;
  color: white;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 600;
}

.marker-cluster-custom div {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
}

/* ==========================================================================
   5. ANIMATIONS
   ========================================================================== */
@keyframes pulse {
  0%, 100% { opacity: 0.8; }
  50% { opacity: 1; }
}

@keyframes gradientShift {
  0% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes fadeOut {
  from { opacity: 1; }
  to { opacity: 0; }
}

.fade-in { animation: fadeIn 0.3s ease forwards; }
.fade-out { animation: fadeOut 0.3s ease forwards; }

/* ==========================================================================
   6. UTILITIES
   ========================================================================== */
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border: 0;
}

/* ==========================================================================
   7. RESPONSIVE LOADING MESSAGE
   ========================================================================== */
@media (max-width: 500px) {
  #loadingMessage > div {
    width: 85% !important;
    height: auto !important;
    min-height: 480px !important;
    padding: 25px 20px !important;
  }
}
</style>

<!-- FOUC unlock script (inline, no network trip) -->
<script>
(function () {
  function unlock() {
    document.documentElement.classList.add('unlock');
  }
  if (document.readyState === 'complete') {
    unlock();
  } else {
    window.addEventListener('load', unlock);
  }
})();
</script>
</head>
<body>
    <noscript>
        <div style="padding: 2rem; text-align: center; font-family: sans-serif; background: var(--neutral-50); color: var(--neutral-900); min-height: 100vh; display: flex; flex-direction: column; align-items: center; justify-content: center;">
            <h2 style="color: var(--error-color); margin-bottom: 1rem;">JavaScript Required</h2>
            <p style="max-width: 400px; line-height: 1.6;">This interactive map requires JavaScript to function properly. Please enable JavaScript in your browser settings and reload the page.</p>
        </div>
    </noscript>
    
    <!-- Map container -->
    <div id="map" aria-label="Interactive historical map of Minnesota"></div>
    
    <!-- Distance indicator -->
    <div id="distanceBox" role="status" aria-live="polite">Initializing...</div>

    <!-- Location experience container -->
    <div class="lochunt-container" role="dialog" aria-labelledby="location-title" aria-hidden="true">
        <div class="lochunt-content">
            <div class="lochunt-info">
                <h2 id="location-title" class="mb-2 text-primary"></h2>
                <p id="location-city" class="text-muted mb-1"></p>
                <p id="location-creator" class="text-muted mb-3"></p>
            </div>
            <div class="audio-player">
                <div class="audio-progress">
                    <div class="progress" role="progressbar" aria-label="Audio progress">
                        <div id="progressBar" class="progress-bar"></div>
                    </div>
                </div>
                <div class="audio-time">
                    <span id="currentTime">0:00</span>
                    <span id="duration">0:00</span>
                </div>
                <div class="audio-controls">
                    <button id="rewindBtn" class="audio-button" aria-label="Rewind 10 seconds">
                        <i class="bi bi-skip-backward" aria-hidden="true"></i>
                    </button>
                    <button id="playPauseBtn" class="audio-button" aria-label="Play audio">
                        <i class="bi bi-play" aria-hidden="true"></i>
                    </button>
                    <button id="forwardBtn" class="audio-button" aria-label="Forward 10 seconds">
                        <i class="bi bi-skip-forward" aria-hidden="true"></i>
                    </button>
                </div>
                <audio id="locationAudio" preload="metadata" crossorigin="anonymous"></audio>
            </div>
        </div>
    </div>

    <!-- Additional info container -->
    <div class="additional-info-container" role="dialog" aria-labelledby="additional-info-title" aria-hidden="true">
        <h3 id="additional-info-title" class="mb-3 text-primary text-center">Did You Know?</h3>
        <p id="additionalInfo" class="mb-3 fs-6"></p>
        <div class="d-flex justify-content-center">
            <button id="continueButton" class="btn btn-primary">Continue</button>
        </div>
    </div>
    
    <!-- Map control buttons -->
    <div class="map-buttons">
        <button id="recenterButton" class="map-button" aria-label="Recenter map on your location">
            <i class="fas fa-crosshairs" aria-hidden="true"></i>
        </button>
        <button id="returnButton" class="map-button" aria-label="Return to main page">
            <i class="fas fa-home" aria-hidden="true"></i>
        </button>
        <button id="tipsButton" class="map-button" aria-label="Show navigation tips">
            <i class="fas fa-question-circle" aria-hidden="true"></i>
        </button>
    </div>

    <!-- Accessibility announcements -->
    <div id="accessibility-announcements" class="sr-only" aria-live="polite" aria-atomic="true"></div>
    <div id="proximity-announcements" class="sr-only" aria-live="assertive" aria-atomic="true"></div>

    <!-- Load scripts with optimized loading -->
    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js" defer></script>
    <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js" defer></script>
    <script src="/locations_main.js?v=1.0.3" defer></script>

    <script>
    // Minnesota Then - Optimized Enterprise Application
    // Complete JavaScript implementation with performance optimizations and enhanced UX

    // ===== PERFORMANCE OPTIMIZATIONS =====
    
    // Service Worker for PWA functionality
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('/sw.js')
        .then(registration => {
          console.log('Service Worker registered:', registration);
          // Keep SW engaged for install prompt
          const pingWorker = () => registration.active?.postMessage({ type: 'PING' });
          pingWorker();
          window.addEventListener('popstate', pingWorker);
          document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'visible') pingWorker();
          });
        })
        .catch(error => console.error('Service Worker registration failed:', error));
    }

    // ===== PERFORMANCE MONITORING =====
    
    class PerformanceMonitor {
      constructor() {
        this.metrics = {
          fps: 0,
          memory: 0,
          loadTime: 0,
          renderTime: 0,
          networkRequests: 0
        };
        this.startTime = performance.now();
        this.frameCount = 0;
        this.lastFrameTime = performance.now();
      }

      startMonitoring() {
        this.monitorFPS();
        this.monitorMemory();
        this.monitorLoad();
      }

      monitorFPS() {
        const tick = (timestamp) => {
          this.frameCount++;
          const elapsed = timestamp - this.lastFrameTime;
          
          if (elapsed >= 1000) {
            this.metrics.fps = Math.round((this.frameCount * 1000) / elapsed);
            this.frameCount = 0;
            this.lastFrameTime = timestamp;
          }
          
          requestAnimationFrame(tick);
        };
        requestAnimationFrame(tick);
      }

      monitorMemory() {
        if (performance.memory) {
          setInterval(() => {
            this.metrics.memory = Math.round(performance.memory.usedJSHeapSize / 1024 / 1024);
          }, 5000);
        }
      }

      monitorLoad() {
        window.addEventListener('load', () => {
          this.metrics.loadTime = performance.now() - this.startTime;
        });
      }

      getMetrics() {
        return this.metrics;
      }
    }

    // ===== CACHE MANAGEMENT =====
    
    class CacheManager {
      constructor() {
        this.prefix = 'mnthen-cache-';
        this.maxAge = 7 * 24 * 60 * 60 * 1000; // 7 days
        this.maxSize = 50 * 1024 * 1024; // 50MB
        this.cryptoKey = null;
        this.textEncoder = new TextEncoder();
        this.textDecoder = new TextDecoder();
      }

      async init() {
        await this.cleanupExpired();
        setInterval(() => this.cleanupExpired(), 60 * 60 * 1000); // Cleanup every hour
      }

      async cacheData(key, data, userPosition = null) {
        const payload = JSON.stringify({
          data,
          timestamp: Date.now(),
          userPosition,
          version: '2.0'
        });

        try {
          const encrypted = await this.encrypt(payload);
          localStorage.setItem(this.prefix + key, encrypted);
          console.log(`Cached: ${key}`);
        } catch (error) {
          console.warn('Cache write failed:', error);
        }
      }

      async getCachedData(key) {
        try {
          const encrypted = localStorage.getItem(this.prefix + key);
          if (!encrypted) return null;

          const decrypted = await this.decrypt(encrypted);
          const payload = JSON.parse(decrypted);
          
          if (Date.now() - payload.timestamp > this.maxAge) {
            localStorage.removeItem(this.prefix + key);
            return null;
          }

          return payload.data;
        } catch (error) {
          console.warn('Cache read failed:', error);
          return null;
        }
      }

      async encrypt(data) {
        if (!crypto.subtle) return btoa(data);

        if (!this.cryptoKey) {
          this.cryptoKey = await crypto.subtle.generateKey(
            { name: 'AES-GCM', length: 256 },
            false,
            ['encrypt', 'decrypt']
          );
        }

        const iv = crypto.getRandomValues(new Uint8Array(12));
        const encodedData = this.textEncoder.encode(data);
        const encrypted = await crypto.subtle.encrypt(
          { name: 'AES-GCM', iv },
          this.cryptoKey,
          encodedData
        );

        const combined = new Uint8Array(iv.length + encrypted.byteLength);
        combined.set(iv);
        combined.set(new Uint8Array(encrypted), iv.length);
        
        return btoa(String.fromCharCode(...combined));
      }

      async decrypt(encryptedData) {
        if (!crypto.subtle) return atob(encryptedData);

        const combined = new Uint8Array(
          atob(encryptedData).split('').map(char => char.charCodeAt(0))
        );
        
        const iv = combined.slice(0, 12);
        const data = combined.slice(12);

        const decrypted = await crypto.subtle.decrypt(
          { name: 'AES-GCM', iv },
          this.cryptoKey,
          data
        );

        return this.textDecoder.decode(decrypted);
      }

      async cleanupExpired() {
        const now = Date.now();
        const keysToRemove = [];

        for (let i = 0; i < localStorage.length; i++) {
          const key = localStorage.key(i);
          if (key?.startsWith(this.prefix)) {
            try {
              const data = await this.getCachedData(key.substring(this.prefix.length));
              if (!data) keysToRemove.push(key);
            } catch {
              keysToRemove.push(key);
            }
          }
        }

        keysToRemove.forEach(key => localStorage.removeItem(key));
        if (keysToRemove.length > 0) {
          console.log(`Cleaned up ${keysToRemove.length} expired cache entries`);
        }
      }
    }

    // ===== CONFIGURATION =====
    
    const CONFIG = {
      // Distance thresholds
      DISTANCE_THRESHOLD: 20,
      EXTENDED_DISTANCE_THRESHOLD: 100,
      MIN_DISTANCE_THRESHOLD: 2,
      PROXIMITY_THRESHOLD: 50,
      JITTER_THRESHOLD: 5,
      MICRO_MOVEMENT_THRESHOLD: 0.3,
      
      // Time thresholds
      BACKGROUND_THRESHOLD: 25000,
      INACTIVITY_TIMEOUT: 30000,
      UPDATE_INTERVAL: 50,
      MIN_CENTERING_INTERVAL: 1000,
      STATIONARY_TIME_THRESHOLD: 5000,
      STATIONARY_CHECK_INTERVAL: 2500,
      SIGNIFICANT_MOVEMENT_COOLDOWN: 2000,
      RETRY_DELAY: 1000,
      ZOOM_COOLDOWN: 10000,
      MIN_RECENTER_INTERVAL: 2000,
      
      // Buffer sizes
      MAX_BUFFER_SIZE: 5,
      STATIONARY_BUFFER_SIZE: 10,
      
      // Accuracy thresholds
      MAX_ACCEPTABLE_ACCURACY: 39,
      STATIONARY_ACCURACY_MULTIPLIER: 1.1,
      STATIONARY_ACCURACY_WEIGHT: 0.7,
      MAX_ACCURACY_THRESHOLD: 2500,
      TARGET_ACCURACY_THRESHOLD: 100,
      
      // Movement thresholds
      MAX_SPEED: 50,
      VELOCITY_DECAY: 0.85,
      BEARING_WEIGHT: 0.3,
      SMOOTHING_FACTOR: 0.35,
      STATIONARY_THRESHOLD: 2,
      STATIONARY_SMOOTHING: 0.97,
      STATIONARY_THRESHOLDB: 3,
      MAX_ALPHA: 0.25,
      MIN_ALPHA: 0.02,
      MAX_RETRIES: 3,
      
      // Edge thresholds
      EDGE_THRESHOLD_PERCENTAGE: 0.25,
      STRICT_EDGE_THRESHOLD_PERCENTAGE: 0.15,
      CRITICAL_EDGE_THRESHOLD_PERCENTAGE: 0.07,
      
      // Zoom levels
      OVERVIEW_ZOOM: 15,
      EXPLORATION_ZOOM: 17,
      DETAIL_ZOOM: 18,
      BASE_ZOOM: 17,
      CLOSE_ZOOM: 18,
      
      // Kalman filter
      BASE_PROCESS_NOISE: 0.008,
      
      // Speed-based zoom
      SPEED_ZOOM_THRESHOLDS: [
        { speed: 35, zoom: 15 },
        { speed: 25, zoom: 16 },
        { speed: 15, zoom: 16 },
        { speed: 10, zoom: 17 },
        { speed: 0, zoom: 17 }
      ],
      
      // Location triggering
      BEARING_TOLERANCE: 30,
      DWELL_TIME: 1500,
      LOCATION_COOLDOWN: 120000, // 2 minutes
      
      // Prediction
      PREDICTION_ENABLED: true,
      VELOCITY_PREDICTION_FACTOR: 0.35,
      ACCELERATION_DAMPING: 0.75
    };

    // ===== GLOBAL STATE =====
    
    let map, userMarker, markerClusterGroup;
    let tracking = false;
    let currentLocationIndex = 0;
    let visitedLocations = [];
    let gameLocations = [];
    let isLocationHuntVisible = false;
    let lastPosition = null;
    let positionBuffer = [];
    let filteredPosition = null;
    let followUser = true;
    let lastVisitedLocationId = null;
    let lastKnownPosition = null;
    let isTransitioning = false;
    let lastVelocity = { lat: 0, lng: 0 };
    let isMapInteracting = false;
    let isStationary = false;
    let stationaryStartTime = null;
    let stationaryCheckTimeout = null;
    let lastUpdateTime = null;
    let lastUpdateTimestamp = null;
    let stationaryBuffer = [];
    let stationaryPosition = null;
    let stationaryCount = 0;
    let lastSmoothedPosition = null;
    let lastHiddenTime = 0;
    let retryCount = 0;
    let inactivityTimer;
    let animationFrameId = null;
    let loadingMessageMinDisplayTime = 8000;
    let lastCenteringTime = 0;
    let lastZoomChangeTime = 0;
    let isNearLocation = false;
    let lastMapUpdateTime = 0;
    let lastVisitTime = 0;
    let lastSignificantMovement = Date.now();
    let lastPositionForJitter = null;

    // Enhanced tracking state
    let enhancedTrackingState = {
      velocity: { lat: 0, lng: 0 },
      acceleration: { lat: 0, lng: 0 },
      lastVelocityUpdate: 0,
      speedMPS: 0,
      heading: null,
      isMoving: false,
      stationaryStartTime: null
    };

    // Zoom state management
    let zoomState = {
      currentTier: 'exploration',
      lastTierChange: 0,
      hysteresisBuffer: [],
      proximityOverride: false
    };

    // Location triggering state
    let locationTriggerState = {
      cooldowns: new Map(),
      dwellTimers: new Map(),
      lastBearing: null,
      approachingLocations: new Set(),
      lastVibrations: new Map()
    };

    // Accessibility state
    let accessibilityState = {
      highContrast: localStorage.getItem('highContrast') === 'true',
      lastAnnouncement: '',
      proximityAlerts: new Set()
    };

    // Cache DOM elements
    let cachedElements = {};

    // Initialize systems
    const performanceMonitor = new PerformanceMonitor();
    const cacheManager = new CacheManager();

    // ===== UTILITY FUNCTIONS =====
    
    function cacheElements() {
      cachedElements = {
        distanceBox: document.getElementById('distanceBox'),
        recenterButton: document.getElementById('recenterButton'),
        returnButton: document.getElementById('returnButton'),
        tipsButton: document.getElementById('tipsButton'),
        lochuntContainer: document.querySelector('.lochunt-container'),
        additionalInfoContainer: document.querySelector('.additional-info-container'),
        accessibilityAnnouncements: document.getElementById('accessibility-announcements'),
        proximityAnnouncements: document.getElementById('proximity-announcements')
      };
    }

    function announceToScreenReader(message, priority = 'polite') {
      const element = priority === 'assertive' 
        ? cachedElements.proximityAnnouncements 
        : cachedElements.accessibilityAnnouncements;
      
      if (!element || message === accessibilityState.lastAnnouncement) return;
      
      element.textContent = message;
      accessibilityState.lastAnnouncement = message;
      
      clearTimeout(element._clearTimer);
      element._clearTimer = setTimeout(() => {
        if (element.textContent === message) element.textContent = '';
      }, 1000);
    }

    function toggleHighContrast() {
      accessibilityState.highContrast = !accessibilityState.highContrast;
      localStorage.setItem('highContrast', accessibilityState.highContrast);
      
      if (accessibilityState.highContrast) {
        document.body.classList.add('high-contrast');
        announceToScreenReader('High contrast mode enabled');
      } else {
        document.body.classList.remove('high-contrast');
        announceToScreenReader('High contrast mode disabled');
      }
    }

    function triggerHapticFeedback(pattern = [100]) {
      if ('vibrate' in navigator) {
        navigator.vibrate(pattern);
      }
    }

    function calculateDistance(pos1, pos2) {
      if (!pos1 || !pos2 || 
          typeof pos1.lat !== 'number' || typeof pos1.lng !== 'number' || 
          typeof pos2.lat !== 'number' || typeof pos2.lng !== 'number') {
        return Infinity;
      }
      
      const R = 6371000; // Earth's radius in meters
      const lat1 = pos1.lat * Math.PI / 180;
      const lat2 = pos2.lat * Math.PI / 180;
      const deltaLat = (pos2.lat - pos1.lat) * Math.PI / 180;
      const deltaLng = (pos2.lng - pos1.lng) * Math.PI / 180;

      const a = Math.sin(deltaLat/2) * Math.sin(deltaLat/2) +
              Math.cos(lat1) * Math.cos(lat2) *
              Math.sin(deltaLng/2) * Math.sin(deltaLng/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

      return R * c;
    }

    function calculateBearing(pos1, pos2) {
      const DEG2RAD = Math.PI / 180;
      const lat1 = pos1.lat * DEG2RAD;
      const lat2 = pos2.lat * DEG2RAD;
      const deltaLng = (pos2.lng - pos1.lng) * DEG2RAD;

      const y = Math.sin(deltaLng) * Math.cos(lat2);
      const x = Math.cos(lat1) * Math.sin(lat2) -
                Math.sin(lat1) * Math.cos(lat2) * Math.cos(deltaLng);

      return (Math.atan2(y, x) * 180 / Math.PI + 450) % 360;
    }

    function isValidPosition(pos) {
      return pos != null &&
             typeof pos.lat === 'number' && !isNaN(pos.lat) &&
             typeof pos.lng === 'number' && !isNaN(pos.lng);
    }

    function throttle(func, limit) {
      let inThrottle;
      return function() {
        const args = arguments;
        const context = this;
        if (!inThrottle) {
          func.apply(context, args);
          inThrottle = true;
          setTimeout(() => inThrottle = false, limit);
        }
      };
    }

    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    // ===== KALMAN FILTER =====
    
    const enhancedKalmanFilter = (() => {
      const DEG = Math.PI / 180;
      const INV_DEG = 180 / Math.PI;
      const tmp = { dxM: 0, dyM: 0, predX: 0, predY: 0, peX: 0, peY: 0, gX: 0, gY: 0 };

      const state = {
        x: { est: 0, err: 1, vel: 0 },
        y: { est: 0, err: 1, vel: 0 },
        q: CONFIG.BASE_PROCESS_NOISE,
        r: 1,
        lastT: null,
        stationary: { count: 0, flag: false, thresh: 8, radius: 0.5 }
      };

      function _dist(lat1, lng1, lat2, lng2) {
        const cosLat = Math.cos(lat1 * DEG);
        tmp.dxM = (lng2 - lng1) * 111320 * cosLat;
        tmp.dyM = (lat2 - lat1) * 111320;
        return Math.sqrt(tmp.dxM * tmp.dxM + tmp.dyM * tmp.dyM);
      }

      return {
        update(measurement) {
          const { lat, lng, accuracy = 10, heading = null, speedMPS = 0 } = measurement;
          const now = measurement.timestamp || performance.now();
          const dt = state.lastT ? (now - state.lastT) / 1000 : 0;

          if (!state.lastT) {
            state.x.est = lng;
            state.y.est = lat;
            state.lastT = now;
            return { ...measurement };
          }

          if (dt <= 0 || dt >= 10) {
            this.reset(measurement);
            return { ...measurement };
          }

          const d = _dist(state.y.est, state.x.est, lat, lng);
          const st = state.stationary;
          st.count = d < st.radius ? st.count + 1 : 0;
          st.flag = st.count >= st.thresh;

          const decay = st.flag ? 0.95 : 0.85;
          state.x.vel = state.x.vel * decay + ((lng - state.x.est) / dt) * (1 - decay);
          state.y.vel = state.y.vel * decay + ((lat - state.y.est) / dt) * (1 - decay);
          const speed = Math.hypot(state.x.vel, state.y.vel) * 111320;

          let q = state.q * (st.flag ? 0.05 : (speed > 2.24 ? 1 + speed * 0.08 : speed < 0.13 ? 0.15 : 1));
          let r = state.r * (accuracy / 10) * (st.flag ? 2.5 : 1);

          tmp.predX = state.x.est + state.x.vel * dt;
          tmp.predY = state.y.est + state.y.vel * dt;

          tmp.peX = state.x.err + q;
          tmp.gX = tmp.peX / (tmp.peX + r);
          state.x.est += tmp.gX * (lng - tmp.predX);
          state.x.err *= (1 - tmp.gX);

          tmp.peY = state.y.err + q;
          tmp.gY = tmp.peY / (tmp.peY + r);
          state.y.est += tmp.gY * (lat - tmp.predY);
          state.y.err *= (1 - tmp.gY);

          state.lastT = now;
          return {
            lat: state.y.est,
            lng: state.x.est,
            accuracy,
            timestamp: now,
            heading,
            speedMPS,
            isStationary: st.flag
          };
        },

        reset(measurement) {
          state.x.est = measurement.lng;
          state.y.est = measurement.lat;
          state.x.err = state.y.err = 1;
          state.x.vel = state.y.vel = 0;
          state.lastT = measurement.timestamp || performance.now();
          state.stationary.count = 0;
          state.stationary.flag = false;
        }
      };
    })();

    // ===== ZOOM MANAGEMENT =====
    
    const zoomRingBuffer = {
      ring: Array(200),
      head: 0,
      size: 0,
      sum: 0
    };

    function calculateIntelligentZoom(speedMPS, distanceToClosest) {
      const now = Date.now();
      const mph = speedMPS * 2.23694;
      
      const old = zoomRingBuffer.ring[zoomRingBuffer.head];
      zoomRingBuffer.sum += mph - (old || 0);
      zoomRingBuffer.ring[zoomRingBuffer.head] = mph;
      zoomRingBuffer.head = (zoomRingBuffer.head + 1) % zoomRingBuffer.ring.length;
      if (zoomRingBuffer.size < zoomRingBuffer.ring.length) zoomRingBuffer.size++;

      const avgSpeed = zoomRingBuffer.sum / zoomRingBuffer.size;
      const isProximity = distanceToClosest <= CONFIG.PROXIMITY_THRESHOLD;
      const tier = isProximity ? 0 : (avgSpeed > 10 ? 2 : 1);
      const zoom = isProximity ? CONFIG.DETAIL_ZOOM : 
                  (avgSpeed > 10 ? CONFIG.OVERVIEW_ZOOM : CONFIG.EXPLORATION_ZOOM);

      const changed = tier !== (zoomState.currentTier === 'detail' ? 0 :
                               zoomState.currentTier === 'exploration' ? 1 : 2);
      
      if (changed && now - zoomState.lastTierChange > CONFIG.ZOOM_COOLDOWN) {
        const tierNames = ['detail', 'exploration', 'overview'];
        zoomState.currentTier = tierNames[tier];
        zoomState.lastTierChange = now;
        zoomState.proximityOverride = isProximity;
        announceToScreenReader(`Map zoom changed to ${tierNames[tier]} view`);
        return zoom;
      }

      return map ? map.getZoom() : CONFIG.EXPLORATION_ZOOM;
    }

    // ===== LOADING SCREEN =====
    
    function showLoadingMessage() {
      const existingMessage = document.getElementById('loadingMessage');
      if (existingMessage) return;
      
      loadingMessageMinDisplayTime = Date.now() + 8000;
      
      const loadingMessage = document.createElement('div');
      loadingMessage.id = 'loadingMessage';
      loadingMessage.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        z-index: 10000;
        font-family: inherit;
        transition: opacity 0.5s ease;
      `;
      
      const contentContainer = document.createElement('div');
      contentContainer.style.cssText = `
        display: grid;
        grid-template-rows: auto auto 1fr auto auto;
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        padding: 40px 32px;
        border-radius: 24px;
        box-shadow: 0 25px 50px rgba(0, 0, 0, 0.2);
        width: 90%;
        max-width: 460px;
        height: 520px;
        text-align: center;
        border: 1px solid rgba(255, 255, 255, 0.3);
      `;
      
      const logoImage = document.createElement('img');
      logoImage.src = 'https://mnthen.com/images/logo.webp';
      logoImage.alt = 'Minnesota Then Logo';
      logoImage.style.cssText = `
        width: 180px;
        height: auto;
        margin: 0 auto 20px;
        border-radius: 12px;
        object-fit: contain;
        filter: drop-shadow(0 4px 8px rgba(0, 40, 85, 0.15));
      `;
      
      const mainTitle = document.createElement('h1');
      mainTitle.style.cssText = `
        margin: 0 0 8px 0;
        font-size: 24px;
        font-weight: 700;
        color: var(--neutral-900);
        text-align: center;
        line-height: 1.2;
        letter-spacing: -0.02em;
      `;
      mainTitle.textContent = 'The Museum Without Walls';
      
      const welcomeMessage = document.createElement('h2');
      welcomeMessage.style.cssText = `
        margin: 0 0 40px 0;
        font-size: 18px;
        font-weight: 500;
        color: var(--primary-color);
        text-align: center;
        line-height: 1.3;
        letter-spacing: 0.01em;
        opacity: 0.9;
      `;
      welcomeMessage.textContent = 'Where Every Step Tells A Story';
      
      const statusTextContainer = document.createElement('div');
      statusTextContainer.style.cssText = `
        min-height: 60px;
        display: flex;
        align-items: center;
        justify-content: center;
        margin-bottom: 20px;
      `;
      
      const statusText = document.createElement('p');
      statusText.id = 'loadingStatusText';
      statusText.style.cssText = `
        margin: 0;
        font-size: 18px;
        font-weight: 500;
        text-align: center;
        color: var(--primary-color);
        line-height: 1.4;
        animation: pulse 2s infinite;
        letter-spacing: 0.01em;
      `;
      statusText.textContent = 'Initializing your experience...';
      statusTextContainer.appendChild(statusText);
      
      const progressContainer = document.createElement('div');
      progressContainer.style.cssText = `
        width: 100%;
        height: 12px;
        background: var(--neutral-200);
        border-radius: 6px;
        overflow: hidden;
        margin-bottom: 16px;
        box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
      `;
      
      const progressBar = document.createElement('div');
      progressBar.id = 'loadingProgressBar';
      progressBar.style.cssText = `
        height: 100%;
        width: 0%;
        background: linear-gradient(90deg, var(--primary-color), var(--dark-blue));
        border-radius: 6px;
        transition: width 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
        box-shadow: 0 0 12px rgba(0, 102, 204, 0.4);
      `;
      
      progressContainer.appendChild(progressBar);
      
      const noteContainer = document.createElement('div');
      noteContainer.style.cssText = `
        min-height: 50px;
        display: flex;
        align-items: center;
        justify-content: center;
      `;
      
      const loadingNote = document.createElement('p');
      loadingNote.style.cssText = `
        margin: 0;
        font-size: 16px;
        color: var(--neutral-600);
        font-weight: 500;
        opacity: 0.8;
      `;
      loadingNote.textContent = 'Preparing your historical journey...';
      noteContainer.appendChild(loadingNote);
      
      contentContainer.appendChild(logoImage);
      contentContainer.appendChild(mainTitle);
      contentContainer.appendChild(welcomeMessage);
      contentContainer.appendChild(statusTextContainer);
      contentContainer.appendChild(progressContainer);
      contentContainer.appendChild(noteContainer);
      
      loadingMessage.appendChild(contentContainer);
      document.body.appendChild(loadingMessage);
      
      // Enhanced progress animation
      const totalDuration = 10000;
      const updateInterval = 100;
      const steps = totalDuration / updateInterval;
      let progress = 0;
      
      const animations = [
        "Establishing secure connection...",
        "Loading historical data...",
        "Calibrating GPS systems...",
        "Preparing interactive content...",
        "Optimizing for your device...",
        "Finalizing experience..."
      ];
      
      const progressInterval = setInterval(() => {
        progress += (100 / steps);
        
        if (progressBar) {
          progressBar.style.width = `${Math.min(progress, 100)}%`;
        }
        
        if (statusText) {
          const animationIndex = Math.min(
            Math.floor(progress / (100 / animations.length)),
            animations.length - 1
          );
          statusText.textContent = animations[animationIndex];
        }
        
        if (progress >= 100) {
          clearInterval(progressInterval);
          tryHideLoadingMessage();
        }
      }, updateInterval);
      
      loadingMessage.dataset.progressInterval = progressInterval;
    }

    function tryHideLoadingMessage() {
      if (Date.now() >= loadingMessageMinDisplayTime) {
        fadeOutLoadingMessage();
      } else {
        const timeRemaining = loadingMessageMinDisplayTime - Date.now();
        setTimeout(fadeOutLoadingMessage, timeRemaining + 100);
      }
    }

    function fadeOutLoadingMessage() {
      const loadingMessage = document.getElementById('loadingMessage');
      if (!loadingMessage) return;
      
      if (loadingMessage.dataset.progressInterval) {
        clearInterval(parseInt(loadingMessage.dataset.progressInterval));
      }
      
      const progressBar = document.getElementById('loadingProgressBar');
      if (progressBar) {
        progressBar.style.width = '100%';
      }
      
      const distanceBox = cachedElements.distanceBox;
      if (distanceBox) {
        distanceBox.classList.add('show');
      }
      
      loadingMessage.style.opacity = '0';
      setTimeout(() => {
        if (loadingMessage.parentNode) {
          loadingMessage.parentNode.removeChild(loadingMessage);
        }
      }, 500);
    }

    function hideLoadingMessage() {
      tryHideLoadingMessage();
    }

    // ===== MAP INITIALIZATION =====
    
    function initMap() {
      // Clear storage
      ['lastKnownPos', 'routeHistory', 'userPrefs'].forEach(key => {
        try {
          localStorage.removeItem(key);
          sessionStorage.removeItem(key);
        } catch (e) {
          // Ignore errors
        }
      });

      // Clear caches
      if ('caches' in window) {
        caches.keys()
          .then(keys => Promise.all(keys.map(key => caches.delete(key))))
          .catch(() => {});
      }

      // Create map
      map = L.map('map', {
        zoomControl: false,
        attributionControl: false,
        zoomSnap: 0.1,
        zoomDelta: 0.5,
        wheelDebounceTime: 100,
        tapTolerance: 15,
        bounceAtZoomLimits: false,
        preferCanvas: true,
        renderer: L.canvas({ padding: 0.5 }),
        fadeAnimation: true,
        zoomAnimationThreshold: 4,
        markerZoomAnimation: true,
        worldCopyJump: true
      }).fitWorld();

      // Add tile layer
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        minZoom: 7,
        maxZoom: 19,
        attribution: '',
        updateWhenIdle: false,
        updateWhenZooming: false,
        keepBuffer: 3,
        className: 'map-tiles',
        crossOrigin: true
      }).addTo(map);

      // Create cluster group
      markerClusterGroup = L.markerClusterGroup({
        showCoverageOnHover: false,
        zoomToBoundsOnClick: true,
        spiderfyOnMaxZoom: true,
        animate: true,
        animateAddingMarkers: false,
        chunkedLoading: true,
        chunkProgress: (processed, total) => {
          if (processed === total) {
            console.log(`Loaded ${processed} markers`);
          }
        },
        maxClusterRadius: zoom => zoom > 16 ? 35 : 75,
        iconCreateFunction: cluster => L.divIcon({
          html: `<div><span>${cluster.getChildCount()}</span></div>`,
          className: 'marker-cluster-custom',
          iconSize: [40, 40]
        })
      }).addTo(map);

      // Create user marker
      userMarker = L.marker([0, 0], {
        icon: L.divIcon({
          className: 'user-marker',
          html: '<div class="user-marker-icon"></div>',
          iconSize: [24, 24],
          iconAnchor: [12, 12]
        }),
        zIndexOffset: 2000
      }).addTo(map);

      // Initialize geolocation
      showLoadingMessage();
      if ('geolocation' in navigator) {
        const options = { 
          enableHighAccuracy: true, 
          timeout: 45000, 
          maximumAge: 0 
        };
        
        navigator.geolocation.getCurrentPosition(
          initializeUserLocation,
          error => {
            // Fallback with less accurate position
            navigator.geolocation.getCurrentPosition(
              initializeUserLocation,
              handleLocationError,
              { ...options, enableHighAccuracy: false, timeout: 30000 }
            );
          },
          options
        );
      } else {
        handleLocationError(new Error('Geolocation not supported'));
      }
    }

    function initializeUserLocation(position) {
      if (!position?.coords?.latitude || !position?.coords?.longitude) {
        handleLocationError(new Error('Invalid initial position'));
        return;
      }

      const { latitude: lat, longitude: lng, accuracy = 20 } = position.coords;

      try {
        userMarker.setLatLng([lat, lng]);
        map.setView([lat, lng], 17);

        enhancedKalmanFilter.reset({ 
          lat, 
          lng, 
          accuracy, 
          timestamp: Date.now() 
        });
        
        announceToScreenReader('Location acquired successfully. Map is ready for navigation.');
        hideLoadingMessage();
        startPositionUpdates();
        startHunt();

        // Visual feedback
        const box = cachedElements.distanceBox;
        if (box) {
          box.classList.add('pulse');
          setTimeout(() => box.classList.remove('pulse'), 3000);
        }
      } catch (error) {
        console.error('Error setting initial location:', error);
        handleLocationError(error);
      }
    }

    function startPositionUpdates() {
      const options = { 
        enableHighAccuracy: true, 
        maximumAge: 1000, 
        timeout: 10000 
      };

      const restart = () => {
        if (window.positionWatchId) {
          navigator.geolocation.clearWatch(window.positionWatchId);
          window.positionWatchId = navigator.geolocation.watchPosition(
            handlePositionUpdate,
            handleLocationError,
            options
          );
        }
      };

      window.positionWatchId = navigator.geolocation.watchPosition(
        handlePositionUpdate,
        handleLocationError,
        options
      );

      window.addEventListener('online', restart);
      return window.positionWatchId;
    }

    function handlePositionUpdate(position) {
      const { coords, timestamp = Date.now() } = position || {};
      
      if (!coords || !isValidPosition({ lat: coords.latitude, lng: coords.longitude })) {
        console.warn('Invalid position data received');
        return;
      }

      const now = Date.now();
      if (now - timestamp > 30000) {
        console.warn('Position data too old, ignoring');
        return;
      }

      const accuracy = coords.accuracy || 0;
      window.lastPositionAccuracy = accuracy;
      window.lastValidPosition = { 
        lat: coords.latitude, 
        lng: coords.longitude, 
        timestamp, 
        accuracy 
      };

      updateUserLocation(position);
    }

    function handleLocationError(error) {
      console.warn("Location error:", error);
      
      if (retryCount < CONFIG.MAX_RETRIES) {
        retryCount++;
        console.log(`Retrying location (${retryCount}/${CONFIG.MAX_RETRIES})`);
        
        setTimeout(() => {
          navigator.geolocation.getCurrentPosition(
            position => {
              hideLoadingMessage();
              updateUserLocation(position, true);
              retryCount = 0;
            },
            handleLocationError,
            {
              enableHighAccuracy: retryCount < 2,
              timeout: 10000 + (retryCount * 5000),
              maximumAge: retryCount * 5000
            }
          );
        }, CONFIG.RETRY_DELAY * retryCount);
        return;
      }
      
      retryCount = 0;
      hideLoadingMessage();
      
      let errorMessage = "Unable to determine your location.";
      if (error?.code) {
        switch (error.code) {
          case 1:
            errorMessage = "Please allow location access to use this feature.";
            break;
          case 2:
            errorMessage = "Location service unavailable. Please try again.";
            break;
          case 3:
            errorMessage = "Location request timed out. Please try again.";
            break;
        }
      }
      
      showPopup("Location Error", errorMessage);
    }

    // ===== POSITION TRACKING =====
    
    function updateUserLocation(position, forceUpdate = false) {
      if (!position?.coords?.latitude || !position?.coords?.longitude) {
        console.warn('Invalid position data');
        return;
      }

      const clearPending = () => {
        if (animationFrameId) {
          cancelAnimationFrame(animationFrameId);
          animationFrameId = null;
        }
        if (stationaryCheckTimeout) {
          clearTimeout(stationaryCheckTimeout);
          stationaryCheckTimeout = null;
        }
      };

      clearPending();

      const now = Date.now();
      const dt = lastUpdateTime ? (now - lastUpdateTime) / 1000 : 0;
      const { latitude: lat, longitude: lng, accuracy = 20, heading = null, speed = 0 } = position.coords;

      const pos = { lat, lng, accuracy, heading, timestamp: now, speedMPS: speed };

      // Cache location data
      if (gameLocations?.length) {
        gameLocations.forEach(loc => cacheManager.cacheData(`location_${loc.id}`, loc, pos));
      }

      // First position
      if (!lastPosition) {
        lastPosition = pos;
        userMarker.setLatLng([lat, lng]);
        enhancedKalmanFilter.reset(pos);
        stationaryStartTime = now;
        positionBuffer = [pos];
        
        const zoom = calculateIntelligentZoom(speed, Infinity);
        if (zoom) map.setZoom(zoom, { animate: false });
        map.setView([lat, lng], map.getZoom(), { animate: false });
        
        updateDistanceBox();
        return;
      }

      const distance = calculateDistance(lastPosition, pos);
      const speedFactor = Math.min(Math.max(speed / 10, 0.1), 1);
      const microThreshold = CONFIG.MICRO_MOVEMENT_THRESHOLD * 0.5;

      // Large jump or force update
      if (distance > CONFIG.EXTENDED_DISTANCE_THRESHOLD || forceUpdate) {
        clearPending();
        isStationary = false;
        stationaryStartTime = null;

        const zoom = calculateIntelligentZoom(speed, Infinity);
        if (zoom) map.setZoom(zoom, { animate: false });
        
        map.setView([lat, lng], map.getZoom(), { animate: false });
        userMarker.setLatLng([lat, lng], { animate: false });
        
        lastPosition = pos;
        positionBuffer = [pos];
        lastVelocity = { lat: 0, lng: 0 };
        enhancedKalmanFilter.reset(pos);
        
        lastUpdateTime = now;
        updateDistanceBox();
        return;
      }

      // Stationary handling
      if (distance < microThreshold && !forceUpdate) {
        if (!isStationary) {
          stationaryStartTime = stationaryStartTime || now;
          if (now - stationaryStartTime >= CONFIG.STATIONARY_TIME_THRESHOLD * 0.7) {
            isStationary = true;
            const smoothedPos = enhancedKalmanFilter.update({
              ...pos,
              accuracy: Math.min(lastPosition.accuracy, pos.accuracy) * CONFIG.STATIONARY_ACCURACY_MULTIPLIER,
              speedMPS: 0
            });
            
            userMarker.setLatLng([smoothedPos.lat, smoothedPos.lng], { animate: false });
            lastPosition = smoothedPos;
            positionBuffer = [smoothedPos];
            
            stationaryCheckTimeout = setTimeout(() => {
              if (isStationary) {
                const refined = enhancedKalmanFilter.update(pos);
                if (calculateDistance(lastPosition, refined) < microThreshold / 3) {
                  userMarker.setLatLng([refined.lat, refined.lng], { animate: false });
                  lastPosition = refined;
                }
              }
            }, CONFIG.STATIONARY_CHECK_INTERVAL);
            
            updateDistanceBox();
            return;
          }
        }
        
        if (isStationary && pos.accuracy < lastPosition.accuracy * 0.95) {
          const refined = enhancedKalmanFilter.update(pos);
          if (calculateDistance(lastPosition, refined) < microThreshold / 3) {
            userMarker.setLatLng([refined.lat, refined.lng], { animate: false });
            lastPosition = refined;
            updateDistanceBox();
          }
        }
        return;
      }

      // Skip low-quality updates
      if (!forceUpdate) {
        const badAccuracy = pos.accuracy > CONFIG.MAX_ACCEPTABLE_ACCURACY;
        const badDistance = distance < CONFIG.MIN_DISTANCE_THRESHOLD;
        const badSpeed = dt > 0 && distance / dt > CONFIG.MAX_SPEED;
        
        if (badAccuracy || badDistance || badSpeed) return;
      }

      // Process with Kalman filter and smoothing
      try {
        const filtered = enhancedKalmanFilter.update(pos);
        positionBuffer.push(filtered);
        
        if (positionBuffer.length > CONFIG.MAX_BUFFER_SIZE) {
          positionBuffer.shift();
        }
        
        const final = calculateWeightedPosition(positionBuffer);
        if (!final) throw new Error('Position calculation failed');
        
        const predicted = calculateEnhancedVelocityFilter(final, lastPosition, dt, speed);
        
        const speedMPH = speed * 2.23694;
        const smoothingFactor = isStationary ? 0.05 : 
          Math.min(Math.max(0.35 + speedFactor * 0.35, 0.25), 0.9);
        
        const smoothed = {
          lat: lastPosition.lat * (1 - smoothingFactor) + predicted.lat * smoothingFactor,
          lng: lastPosition.lng * (1 - smoothingFactor) + predicted.lng * smoothingFactor,
          accuracy: predicted.accuracy,
          heading: predicted.heading,
          timestamp: now,
          speedMPS: predicted.speedMPS
        };
        
        const animationDuration = isStationary ? 0.6 : 
          Math.min(Math.max(0.25 / (1 + speedFactor), 0.1), 0.4);
        
        userMarker.setLatLng([smoothed.lat, smoothed.lng], { 
          animate: true, 
          duration: animationDuration 
        });
        
        // Update map view
        if (now - lastMapUpdateTime > 300 || distance > 15) {
          updateMapView(smoothed, predicted, speed);
          lastMapUpdateTime = now;
        }
        
        lastPosition = smoothed;
        lastUpdateTime = now;
        updateDistanceBox();
        
      } catch (error) {
        console.error('Location update error:', error);
        // Fallback
        const fallbackPos = enhancedKalmanFilter.update(pos);
        userMarker.setLatLng([fallbackPos.lat, fallbackPos.lng], { animate: true });
        lastPosition = fallbackPos;
        updateDistanceBox();
      }
    }

    function updateMapView(smoothed, predicted, speed) {
      if (!followUser || isMapInteracting) return;
      
      const lookAheadFactor = isStationary ? 0.05 : 
        Math.min(Math.max(speed * 0.025, 0), 0.4);
      
      const lookAhead = {
        lat: smoothed.lat + (predicted.lat - lastPosition.lat) * lookAheadFactor,
        lng: smoothed.lng + (predicted.lng - lastPosition.lng) * lookAheadFactor
      };
      
      animationFrameId = requestAnimationFrame(() => {
        map.panTo([lookAhead.lat, lookAhead.lng], {
          animate: true,
          duration: isStationary ? 0.8 : 0.5,
          easeLinearity: 0.4
        });
        
        // Update zoom if needed
        const closestDistance = findClosestLocationDistance(smoothed);
        const zoom = calculateIntelligentZoom(speed, closestDistance);
        
        if (zoom && Math.abs(map.getZoom() - zoom) >= 1) {
          map.setZoom(zoom, { animate: true, duration: 1.2 });
        }
        
        animationFrameId = null;
      });
    }

    function calculateWeightedPosition(positions, smoothingFactor = 0.8) {
      if (!Array.isArray(positions) || positions.length === 0) return null;
      
      const validPositions = positions.filter(pos => 
        pos && isValidPosition(pos)
      );
      
      if (validPositions.length === 0) return null;
      
      let sumLat = 0, sumLng = 0, totalWeight = 0;
      
      for (let i = 0; i < validPositions.length; i++) {
        const position = validPositions[i];
        const weight = Math.pow(smoothingFactor, validPositions.length - i - 1);
        sumLat += position.lat * weight;
        sumLng += position.lng * weight;
        totalWeight += weight;
      }
      
      const latest = validPositions[validPositions.length - 1];
      return {
        lat: sumLat / totalWeight,
        lng: sumLng / totalWeight,
        accuracy: Math.min(...validPositions.map(p => p.accuracy || 20)),
        timestamp: latest.timestamp,
        heading: latest.heading,
        speedMPS: latest.speedMPS
      };
    }

    function calculateEnhancedVelocityFilter(currentPosition, lastPosition, timeDelta, speed) {
      if (!timeDelta || timeDelta <= 0) return currentPosition;
      
      const currentVelocity = {
        lat: (currentPosition.lat - lastPosition.lat) / timeDelta,
        lng: (currentPosition.lng - lastPosition.lng) / timeDelta
      };
      
      if (!lastVelocity) {
        lastVelocity = currentVelocity;
      }
      
      const acceleration = {
        lat: (currentVelocity.lat - lastVelocity.lat) / timeDelta,
        lng: (currentVelocity.lng - lastVelocity.lng) / timeDelta
      };
      
      const accelerationDamping = Math.min(1, Math.max(0.2, 1 - (speed / 20)));
      const dampedAcceleration = {
        lat: acceleration.lat * accelerationDamping,
        lng: acceleration.lng * accelerationDamping
      };
      
      lastVelocity = currentVelocity;
      
      const predictionTimeFactor = Math.min(0.5, Math.max(0.1, timeDelta));
      
      return {
        lat: currentPosition.lat + (currentVelocity.lat * predictionTimeFactor) + 
             (0.5 * dampedAcceleration.lat * predictionTimeFactor * predictionTimeFactor),
        lng: currentPosition.lng + (currentVelocity.lng * predictionTimeFactor) + 
             (0.5 * dampedAcceleration.lng * predictionTimeFactor * predictionTimeFactor),
        accuracy: currentPosition.accuracy,
        heading: currentPosition.heading,
        timestamp: currentPosition.timestamp,
        speedMPS: speed
      };
    }

    function findClosestLocationDistance(position) {
      if (!gameLocations || gameLocations.length === 0) return Infinity;
      
      let closestDistance = Infinity;
      for (const location of gameLocations) {
        if (location?.lat && location?.lng) {
          const distance = calculateDistance(position, location);
          if (distance < closestDistance) {
            closestDistance = distance;
          }
        }
      }
      
      return closestDistance * 3.28084; // Convert to feet
    }

    // ===== DISTANCE BOX =====
    
    function updateDistanceBox() {
      const box = cachedElements.distanceBox;
      if (!box) return;

      if (!userMarker || !gameLocations?.length) {
        box.textContent = 'Initializing...';
        return;
      }

      const { lat, lng } = userMarker.getLatLng();
      const userPos = { lat, lng };

      let minDistance = Infinity;
      let closest = null;

      for (const location of gameLocations) {
        if (!location?.lat || !location?.lng) continue;
        const distance = calculateDistance(userPos, location);
        if (distance < minDistance) {
          minDistance = distance;
          closest = location;
        }
      }

      if (!isFinite(minDistance)) {
        box.textContent = 'Initializing...';
        return;
      }

      const feet = Math.round(minDistance * 3.28084);
      const distanceText = feet < 5280 
        ? `${feet.toLocaleString()} ft` 
        : `${(feet / 5280).toFixed(2)} mi`;
      
      box.textContent = `Closest: ${distanceText}`;

      // Update styling based on proximity
      box.className = 'show';
      if (feet <= 50) {
        box.classList.add('proximity-close');
      } else if (feet <= 200) {
        box.classList.add('proximity-medium');
      } else {
        box.classList.add('proximity-far');
      }

      // Haptic feedback for close proximity
      if (feet <= 20 && navigator.vibrate) {
        const locationId = closest.id;
        const lastVibration = locationTriggerState.lastVibrations?.get(locationId) || 0;
        if (Date.now() - lastVibration > 5000) {
          navigator.vibrate(200);
          (locationTriggerState.lastVibrations ||= new Map()).set(locationId, Date.now());
        }
      }

      // Trigger location hunt
      if (feet <= CONFIG.DISTANCE_THRESHOLD && !isLocationHuntVisible) {
        const now = Date.now();
        const locationId = closest.id;
        const lastTrigger = locationTriggerState.cooldowns.get(locationId);
        
        if (!lastTrigger || now - lastTrigger >= CONFIG.LOCATION_COOLDOWN) {
          if (!locationTriggerState.dwellTimers.has(locationId)) {
            locationTriggerState.dwellTimers.set(locationId, now);
          } else if (now - locationTriggerState.dwellTimers.get(locationId) >= CONFIG.DWELL_TIME) {
            locationTriggerState.cooldowns.set(locationId, now);
            locationTriggerState.dwellTimers.delete(locationId);
            showLocationHunt(closest);
          }
        } else {
          locationTriggerState.dwellTimers.delete(locationId);
        }
      } else {
        locationTriggerState.dwellTimers.clear();
      }
    }

    // ===== LOCATION HUNT =====
    
    function showLocationHunt(location) {
      const now = Date.now();
      const debounceTime = 150;
      
      if (now - (showLocationHunt.lastCall || 0) < debounceTime) {
        return;
      }
      showLocationHunt.lastCall = now;

      lastVisitedLocationId = location.id;
      isLocationHuntVisible = true;
      
      const container = cachedElements.lochuntContainer;
      container.innerHTML = '';
      container.style.display = 'flex';
      container.classList.add('fade-in');
      
      announceToScreenReader(`Opened location: ${location.name}`);
      
      const scrollableContent = document.createElement('div');
      scrollableContent.style.cssText = `
        flex: 1;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
        scroll-behavior: smooth;
        will-change: scroll-position;
      `;
      
      const locationImage = document.createElement('img');
      locationImage.src = location.image;
      locationImage.alt = location.name;
      locationImage.style.cssText = `
        width: 100%;
        height: 45vh;
        object-fit: cover;
        object-position: center;
      `;
      locationImage.loading = "eager";
      scrollableContent.appendChild(locationImage);
      
      const contentContainer = document.createElement('div');
      contentContainer.classList.add('lochunt-content');
      
      const locationInfo = document.createElement('div');
      locationInfo.classList.add('lochunt-info');
      
      const locationName = document.createElement('h1');
      locationName.textContent = location.name;
      
      const locationCity = document.createElement('p');
      locationCity.textContent = location.city;
      
      const locationCreator = document.createElement('p');
      locationCreator.textContent = `Created by: ${location.creator}`;
      
      locationInfo.appendChild(locationName);
      locationInfo.appendChild(locationCity);
      locationInfo.appendChild(locationCreator);
      contentContainer.appendChild(locationInfo);
      
      const audioPlayerContainer = createAudioPlayer(location.audio);
      contentContainer.appendChild(audioPlayerContainer);
      scrollableContent.appendChild(contentContainer);
      container.appendChild(scrollableContent);
      
      const bottomActionBar = createBottomActionBar(location);
      container.appendChild(bottomActionBar);
      
      // Initialize audio player
      setTimeout(() => {
        window.audioPlayerCleanup = initAudioPlayer();
      }, 100);
      
      // Prefetch nearby content
      if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
        const userPos = userMarker ? userMarker.getLatLng() : null;
        if (userPos && gameLocations) {
          navigator.serviceWorker.controller.postMessage({
            type: 'PREFETCH_AUDIO',
            data: {
              userLocation: { lat: userPos.lat, lng: userPos.lng },
              locations: gameLocations
            }
          });
        }
      }
    }

    function createAudioPlayer(audioSrc) {
      const container = document.createElement('div');
      container.classList.add('audio-player');

      const audio = document.createElement('audio');
      audio.id = 'locationAudio';
      audio.src = audioSrc;
      audio.preload = "metadata";
      audio.crossOrigin = "anonymous";

      const progressContainer = document.createElement('div');
      progressContainer.classList.add('audio-progress');

      const progress = document.createElement('div');
      progress.classList.add('progress');
      progress.setAttribute('role', 'progressbar');
      progress.setAttribute('aria-label', 'Audio progress');

      const progressBar = document.createElement('div');
      progressBar.id = 'progressBar';
      progressBar.classList.add('progress-bar');

      progress.appendChild(progressBar);
      progressContainer.appendChild(progress);

      const timeInfo = document.createElement('div');
      timeInfo.classList.add('audio-time');

      const currentTime = document.createElement('span');
      currentTime.id = 'currentTime';
      currentTime.textContent = '0:00';

      const duration = document.createElement('span');
      duration.id = 'duration';
      duration.textContent = '0:00';

      timeInfo.appendChild(currentTime);
      timeInfo.appendChild(duration);

      const controls = document.createElement('div');
      controls.classList.add('audio-controls');

      const rewindBtn = createAudioButton('skip-backward', 'rewindBtn', 'Rewind 10 seconds');
      const playPauseBtn = createAudioButton('play', 'playPauseBtn', 'Play audio');
      const forwardBtn = createAudioButton('skip-forward', 'forwardBtn', 'Forward 10 seconds');

      controls.appendChild(rewindBtn);
      controls.appendChild(playPauseBtn);
      controls.appendChild(forwardBtn);

      container.appendChild(audio);
      container.appendChild(progressContainer);
      container.appendChild(timeInfo);
      container.appendChild(controls);

      return container;
    }

    function createAudioButton(iconName, id, ariaLabel) {
      const button = document.createElement('button');
      button.id = id;
      button.classList.add('audio-button');
      button.setAttribute('aria-label', ariaLabel);
      button.innerHTML = `<i class="bi bi-${iconName}" aria-hidden="true"></i>`;
      return button;
    }

    function createBottomActionBar(location) {
      const actionBar = document.createElement('div');
      actionBar.classList.add('location-action-bar');
      
      const infoBtn = document.createElement('button');
      infoBtn.innerHTML = '<i class="bi bi-info-circle-fill" aria-hidden="true"></i>';
      infoBtn.setAttribute('aria-label', 'Image source information');
      infoBtn.addEventListener('click', () => {
        const source = location.imageSource || 'Image source information not available';
        showSourcePopup('Image Source', source);
      });

      const feedbackBtn = document.createElement('a');
      feedbackBtn.href = 'mailto:mattreicher@protonmail.com?subject=Feedback';
      feedbackBtn.target = '_blank';
      feedbackBtn.rel = 'noopener noreferrer';
      feedbackBtn.setAttribute('aria-label', 'Send feedback email');
      feedbackBtn.innerHTML = '<i class="bi bi-envelope-fill" aria-hidden="true"></i>';

      actionBar.appendChild(infoBtn);
      actionBar.appendChild(feedbackBtn);
      return actionBar;
    }

// Completely new implementation of showPopup focused on image source
function showSourcePopup(title, content) {
    // Remove any existing popups first
    const existingPopup = document.getElementById('sourceInfoPopup');
    if (existingPopup) {
        document.body.removeChild(existingPopup);
    }
    
    // Create overlay container that covers the entire screen
    const overlay = document.createElement('div');
    overlay.id = 'sourceInfoPopup';
    overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 9999;
        backdrop-filter: blur(3px);
    `;

    // Create the popup content box
    const popup = document.createElement('div');
    popup.classList.add('source-info-content');
    popup.style.cssText = `
        background-color: white;
        border-radius: 8px;
        padding: 24px;
        width: 90%;
        max-width: 500px;
        max-height: 80vh;
        overflow-y: auto;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
        display: flex;
        flex-direction: column;
    `;

    // Create title
    const popupTitle = document.createElement('h3');
    popupTitle.textContent = title;
    popupTitle.style.cssText = `
        font-size: 1.5rem;
        font-weight: 600;
        color: #2c5282;
        margin-bottom: 16px;
        border-bottom: 1px solid #e2e8f0;
        padding-bottom: 12px;
    `;

    // Create content
    const popupContent = document.createElement('div');
    popupContent.style.cssText = `
        margin-bottom: 20px;
        line-height: 1.6;
        font-size: 1rem;
    `;
    popupContent.textContent = content;

    // Create close button
    const closeButton = document.createElement('button');
    closeButton.textContent = 'Close';
    closeButton.classList.add('source-close-button', 'btn');
    closeButton.style.cssText = `
        background: linear-gradient(to right, #2c5282, #2b6cb0);
        border: none;
        color: white;
        padding: 8px 24px;
        border-radius: 4px;
        font-weight: 500;
        cursor: pointer;
        align-self: flex-end;
        transition: all 0.2s ease;
    `;
    
    closeButton.addEventListener('mouseover', () => {
        closeButton.style.opacity = '0.9';
    });
    
    closeButton.addEventListener('mouseout', () => {
        closeButton.style.opacity = '1';
    });
    
    closeButton.addEventListener('click', () => {
        document.body.removeChild(overlay);
    });

    // Add click event to close when clicking outside the popup
    overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
            document.body.removeChild(overlay);
        }
    });

    // Assemble popup
    popup.appendChild(popupTitle);
    popup.appendChild(popupContent);
    popup.appendChild(closeButton);
    overlay.appendChild(popup);
    document.body.appendChild(overlay);

    // Add animation
    overlay.style.opacity = '0';
    popup.style.transform = 'translateY(20px)';
    popup.style.transition = 'transform 0.3s ease, opacity 0.3s ease';
    overlay.style.transition = 'opacity 0.3s ease';
    
    // Trigger animation
    setTimeout(() => {
        overlay.style.opacity = '1';
        popup.style.transform = 'translateY(0)';
    }, 10);
}

    // ===== AUDIO PLAYER =====
    
    function initAudioPlayer() {
      const audio = document.getElementById('locationAudio');
      const playPauseBtn = document.getElementById('playPauseBtn');
      const rewindBtn = document.getElementById('rewindBtn');
      const forwardBtn = document.getElementById('forwardBtn');
      const progressBar = document.getElementById('progressBar');
      const progressContainer = document.querySelector('.progress');
      const currentTimeSpan = document.getElementById('currentTime');
      const durationSpan = document.getElementById('duration');

      if (!audio || !playPauseBtn || !progressBar) {
        console.error("Audio player elements not found");
        return;
      }

      // State management
      let wakeLock = null;
      let audioContext = null;
      let isPlayerActive = true;
      let retryCount = 0;
      const maxRetries = 3;
      let lastPlaybackPosition = 0;
      let recoveryInProgress = false;
      let wasPlayingWhenHidden = false;
      let screenWentAway = false;

      // Initialize audio context
      function initAudioContext() {
        if (!audioContext && isPlayerActive) {
          try {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const source = audioContext.createMediaElementSource(audio);
            source.connect(audioContext.destination);
          } catch (error) {
            console.log('AudioContext not available:', error);
          }
        }
        return audioContext;
      }

      // Wake lock management
      async function requestWakeLock() {
        try {
          if ('wakeLock' in navigator && !wakeLock && isPlayerActive) {
            wakeLock = await navigator.wakeLock.request('screen');
            
            wakeLock.addEventListener('release', () => {
              wakeLock = null;
              if (!audio.paused) {
                screenWentAway = true;
                wasPlayingWhenHidden = true;
              }
            });
          }
        } catch (error) {
          console.warn('Wake lock failed:', error);
        }
      }

      async function releaseWakeLock() {
        if (wakeLock) {
          try {
            await wakeLock.release();
            wakeLock = null;
          } catch (error) {
            console.warn('Wake lock release failed:', error);
          }
        }
      }

      // Visibility handling
      document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
          if (!audio.paused) {
            wasPlayingWhenHidden = true;
            screenWentAway = true;
          }
        } else {
          if (wasPlayingWhenHidden && audio.paused && screenWentAway) {
            setTimeout(() => {
              showSourcePopup(
                "Audio Restarted", 
                "Audio was interrupted when the tab became inactive. Keep this tab active to prevent interruptions."
              );
              screenWentAway = false;
              wasPlayingWhenHidden = false;
            }, 100);
          }
        }
      });

      // Error recovery
      function recoverAudioSource() {
        if (recoveryInProgress || !isPlayerActive) return;
        
        recoveryInProgress = true;
        
        if (!isNaN(audio.currentTime)) {
          lastPlaybackPosition = audio.currentTime;
        }
        
        audio.load();
        
        audio.addEventListener('loadedmetadata', function restorePosition() {
          if (lastPlaybackPosition > 0 && !screenWentAway) {
            audio.currentTime = lastPlaybackPosition;
          } else if (screenWentAway) {
            audio.currentTime = 0;
          }
          recoveryInProgress = false;
          retryCount = 0;
          audio.removeEventListener('loadedmetadata', restorePosition);
        }, { once: true });
      }

      // Error handling
      function handleAudioError(error) {
        if (!isPlayerActive) return;
        
        console.error("Audio error:", error);
        releaseWakeLock();
        
        if (screenWentAway || wasPlayingWhenHidden) {
          const resumePosition = lastPlaybackPosition || 0;
          showSourcePopup(
            "Audio Interrupted", 
            `Audio was paused when you left the screen. Click play to resume from ${Math.floor(resumePosition / 60)}:${String(Math.floor(resumePosition % 60)).padStart(2, '0')}.`
          );
          
          audio.dataset.resumePosition = resumePosition.toString();
          recoverAudioSource();
          screenWentAway = false;
          wasPlayingWhenHidden = false;
        } else if (retryCount < maxRetries && isPlayerActive) {
          retryCount++;
          setTimeout(() => {
            recoverAudioSource();
          }, 1000 * retryCount);
        } else {
          playPauseBtn.innerHTML = '<i class="bi bi-exclamation-triangle"></i>';
          showSourcePopup("Audio Error", "Unable to play audio. Please try refreshing the page.");
        }
        
        playPauseBtn.innerHTML = '<i class="bi bi-play"></i>';
        playPauseBtn.setAttribute('aria-label', 'Play');
      }

      // Play/pause control
      async function togglePlay() {
        if (!isPlayerActive) return;
        
        try {
          if (audio.paused) {
            const resumePosition = audio.dataset.resumePosition;
            if (resumePosition && parseFloat(resumePosition) > 0) {
              audio.currentTime = parseFloat(resumePosition);
              delete audio.dataset.resumePosition;
            }
            
            const ctx = initAudioContext();
            if (ctx && ctx.state === 'suspended') {
              await ctx.resume();
            }
            
            const playPromise = audio.play();
            if (playPromise !== undefined) {
              playPromise.then(async () => {
                playPauseBtn.innerHTML = '<i class="bi bi-pause"></i>';
                playPauseBtn.setAttribute('aria-label', 'Pause');
                await requestWakeLock();
                retryCount = 0;
                announceToScreenReader('Audio playback started');
              }).catch(handleAudioError);
            }
          } else {
            audio.pause();
            playPauseBtn.innerHTML = '<i class="bi bi-play"></i>';
            playPauseBtn.setAttribute('aria-label', 'Play');
            await releaseWakeLock();
            announceToScreenReader('Audio playback paused');
          }
        } catch (error) {
          handleAudioError(error);
        }
      }

      // Seek control
      function seek(seconds) {
        if (!isPlayerActive) return;
        audio.currentTime = Math.max(0, Math.min(audio.currentTime + seconds, audio.duration));
        
        const direction = seconds > 0 ? 'forward' : 'backward';
        announceToScreenReader(`Skipped ${Math.abs(seconds)} seconds ${direction}`);
      }

      // Progress updates
      function updateProgress() {
        if (!isPlayerActive || !isFinite(audio.duration)) return;
        
        const percent = (audio.currentTime / audio.duration) * 100;
        progressBar.style.width = `${percent}%`;
        currentTimeSpan.textContent = formatTime(audio.currentTime);
      }

      // Progress bar interaction
      function setProgress(e) {
        if (!isPlayerActive || !isFinite(audio.duration)) return;
        
        const rect = this.getBoundingClientRect();
        const clickX = e.clientX - rect.left;
        const width = rect.width;
        
        if (width > 0) {
          audio.currentTime = (clickX / width) * audio.duration;
          announceToScreenReader(`Jumped to ${formatTime(audio.currentTime)}`);
        }
      }

      // Duration display
      function setDuration() {
        if (!isPlayerActive || !isFinite(audio.duration)) return;
        durationSpan.textContent = formatTime(audio.duration);
      }

      // Time formatting
      function formatTime(time) {
        if (!isFinite(time)) return "0:00";
        
        const minutes = Math.floor(time / 60);
        const seconds = Math.floor(time % 60);
        return `${minutes}:${seconds.toString().padStart(2, '0')}`;
      }

      // Position tracking
      audio.addEventListener('timeupdate', () => {
        if (!isNaN(audio.currentTime) && isPlayerActive && audio.currentTime > 0) {
          lastPlaybackPosition = audio.currentTime;
          try {
            localStorage.setItem('audioPosition', audio.currentTime.toString());
          } catch (error) {
            // Ignore localStorage errors
          }
        }
      });

      // Visibility change handling
      document.addEventListener('visibilitychange', () => {
        if (document.hidden && audio && !audio.paused) {
          if (!isNaN(audio.currentTime)) {
            lastPlaybackPosition = audio.currentTime;
            try {
              localStorage.setItem('audioPosition', audio.currentTime.toString());
            } catch (error) {
              // Ignore localStorage errors
            }
          }
          
          wasPlayingWhenHidden = true;
          screenWentAway = true;
          audio.pause();
          playPauseBtn.innerHTML = '<i class="bi bi-play"></i>';
          playPauseBtn.setAttribute('aria-label', 'Play');
        }
      });

      // Network recovery
      window.addEventListener('online', () => {
        if (audio.error && isPlayerActive) {
          recoverAudioSource();
        }
      });

      // Event listeners
      playPauseBtn.addEventListener('click', togglePlay);
      rewindBtn.addEventListener('click', () => seek(-10));
      forwardBtn.addEventListener('click', () => seek(10));
      audio.addEventListener('timeupdate', updateProgress);
      audio.addEventListener('loadedmetadata', setDuration);
      audio.addEventListener('ended', async () => {
        playPauseBtn.innerHTML = '<i class="bi bi-play"></i>';
        playPauseBtn.setAttribute('aria-label', 'Play');
        await releaseWakeLock();
        
        try {
          localStorage.removeItem('audioPosition');
        } catch (error) {
          // Ignore localStorage errors
        }
        
        audio.currentTime = 0;
        progressBar.style.width = '0%';
        
        announceToScreenReader('Audio playback completed');
        showAdditionalInfo();
      });
      
      audio.addEventListener('pause', releaseWakeLock);
      audio.addEventListener('error', handleAudioError);

      if (progressContainer) {
        progressContainer.addEventListener('click', setProgress);
      }

      // Restore saved position
      audio.addEventListener('loadedmetadata', () => {
        try {
          const savedPosition = localStorage.getItem('audioPosition');
          if (savedPosition && !isNaN(savedPosition) && parseFloat(savedPosition) > 0 && 
              !screenWentAway && !wasPlayingWhenHidden) {
            audio.currentTime = parseFloat(savedPosition);
          }
        } catch (error) {
          // Ignore localStorage errors
        }
      });

      // Preload audio
      audio.load();

      // Cleanup function
      return function cleanup() {
        releaseWakeLock();
        isPlayerActive = false;
        if (audioContext) {
          audioContext.close();
        }
      };
    }

    function showAdditionalInfo() {
      const location = gameLocations.find(loc => loc.id === lastVisitedLocationId);
      if (!location) return;
      
      const container = cachedElements.additionalInfoContainer;
      container.style.display = 'flex';
      container.classList.add('fade-in');
      
      document.getElementById('additionalInfo').textContent = 
        location.additionalInfo || "No additional information available.";

      announceToScreenReader('Additional information is now available');

      document.getElementById('continueButton').onclick = () => {
        container.classList.add('fade-out');
        setTimeout(() => {
          container.style.display = 'none';
          container.classList.remove('fade-out');
          
          const lochuntContainer = cachedElements.lochuntContainer;
          lochuntContainer.classList.add('fade-out');
          setTimeout(() => {
            lochuntContainer.style.display = 'none';
            lochuntContainer.classList.remove('fade-out');
            isLocationHuntVisible = false;
            
            announceToScreenReader('Returned to map view');
            updateDistanceBox();
            
            if (window.audioPlayerCleanup) {
              window.audioPlayerCleanup();
              window.audioPlayerCleanup = null;
            }
          }, 300);
        }, 300);
      };
    }

    // ===== MARKERS AND LOCATIONS =====
    
    function startHunt() {
      gameLocations = locations.sort((a, b) => a.id - b.id);
      currentLocationIndex = 0;
      locationTriggerState.cooldowns.clear();
      lastVisitedLocationId = null;
      loadAllLocations();
    }

    function getMarkerColor(tours) {
      if (!tours) return '#0066cc';
      
      switch (tours.toLowerCase()) {
        case 'person': return '#FF6B35';
        case 'gangster': return '#4ECDC4';
        case 'event': return '#FF3366';
        case 'place': return '#8B5CF6';
        default: return '#0066cc';
      }
    }

    let markersCreated = false;
    let activePopups = new Set();

    function loadAllLocations() {
      if (!gameLocations || !Array.isArray(gameLocations) || gameLocations.length === 0) {
        console.warn("No locations available");
        return;
      }

      createMarkersOnly();
      updateDistanceBox();
      resetInactivityTimer();
    }

    function createMarkersOnly() {
      if (markerClusterGroup) {
        markerClusterGroup.clearLayers();
      }

      activePopups.clear();

      gameLocations.forEach((location) => {
        if (!location || !isValidPosition(location)) return;

        const markerColor = getMarkerColor(location.tours);
        location.markerColor = markerColor;
        
        const locationMarker = L.marker([location.lat, location.lng], {
          icon: L.divIcon({
            className: 'custom-pin-icon',
            html: `<div class="pin-head" style="background-color: ${markerColor};"></div>`,
            iconSize: [30, 30],
            iconAnchor: [15, 30],
          })
        });

        const popupContent = `
          <div class="popup-content">
            <img loading="lazy" src="${location.image}" alt="${location.name}" class="location-image">
            <h4 class="location-name">
              <a href="${location.link}" target="_blank" rel="noopener noreferrer">${location.name}</a>
            </h4>
            <div class="popup-buttons">
              <button class="button route-button" data-lat="${location.lat}" data-lng="${location.lng}">Directions</button>
              <button class="button summary-button" data-location-id="${location.id}">Summary</button>
            </div>
          </div>
        `;

        locationMarker.bindPopup(popupContent, {
          offset: L.point(0, -25),
          className: 'custom-popup',
          maxWidth: 300,
          closeButton: true,
          autoClose: true,
          closeOnClick: true
        });

        locationMarker.on('popupopen', function(e) {
          activePopups.add(locationMarker);
          attachPopupEventListeners(e.popup._contentNode, location);
        });

        locationMarker.on('popupclose', function(e) {
          activePopups.delete(locationMarker);
        });

        markerClusterGroup.addLayer(locationMarker);
      });

      if (!map.hasLayer(markerClusterGroup)) {
        map.addLayer(markerClusterGroup);
      }
      
      markersCreated = true;
    }

    function attachPopupEventListeners(popupElement, location) {
      const routeButton = popupElement.querySelector('.route-button');
      const summaryButton = popupElement.querySelector('.summary-button');

      if (routeButton && !routeButton.hasAttribute('data-listener-attached')) {
        routeButton.setAttribute('data-listener-attached', 'true');
        routeButton.addEventListener('click', function(event) {
          event.preventDefault();
          event.stopPropagation();
          showNavigationModal(location.lat, location.lng);
        });
      }

      if (summaryButton && !summaryButton.hasAttribute('data-listener-attached')) {
        summaryButton.setAttribute('data-listener-attached', 'true');
        summaryButton.addEventListener('click', function(event) {
          event.preventDefault();
          event.stopPropagation();
          showLocationSummary(location.id);
        });
      }
    }

    function closeAllPopups() {
      activePopups.forEach(marker => {
        if (marker.isPopupOpen()) {
          marker.closePopup();
        }
      });
      activePopups.clear();
    }

    // ===== NAVIGATION MODAL =====
    
    function showNavigationModal(destinationLat, destinationLng) {
      closeAllPopups();
      
      const existingModals = document.querySelectorAll('.modal');
      existingModals.forEach(modal => modal.remove());
      
      const modal = document.createElement("div");
      modal.className = "modal";
      modal.style.display = "flex";
      
      modal.innerHTML = `
        <div class="modal-content">
          <h3>Choose your navigation app:</h3>
          <div class="modal-buttons">
            <button class="modal-button google-maps">
              <i class="fab fa-google"></i>
              <span>Google Maps</span>
              <div class="loading-spinner" style="display: none;"></div>
            </button>
            <button class="modal-button waze">
              <i class="fas fa-route"></i>
              <span>Waze</span>
              <div class="loading-spinner" style="display: none;"></div>
            </button>
            <button class="modal-button apple-maps">
              <i class="fab fa-apple"></i>
              <span>Apple Maps</span>
              <div class="loading-spinner" style="display: none;"></div>
            </button>
            <button class="modal-button cancel">Cancel</button>
          </div>
        </div>
      `;
      
      document.body.appendChild(modal);
      
      // Show modal
      requestAnimationFrame(() => {
        modal.classList.add('show');
      });
      
      // Get user location
      let userLat = null;
      let userLng = null;
      
      const getUserLocation = () => {
        return new Promise((resolve) => {
          if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(
              (position) => {
                userLat = position.coords.latitude;
                userLng = position.coords.longitude;
                resolve();
              },
              () => resolve(),
              { timeout: 5000, enableHighAccuracy: false }
            );
          } else {
            resolve();
          }
        });
      };
      
      const closeModal = () => {
        modal.classList.remove('show');
        setTimeout(() => {
          if (modal.parentNode) {
            modal.remove();
          }
        }, 300);
      };
      
      const showReminderModal = (navigationUrl) => {
        const reminderModal = document.createElement("div");
        reminderModal.className = "modal";
        reminderModal.style.display = "flex";
        
        reminderModal.innerHTML = `
          <div class="modal-content">
            <div style="text-align: center; margin-bottom: 20px;">
              <div style="width: 60px; height: 60px; background: var(--primary-color); border-radius: 50%; display: flex; align-items: center; justify-content: center; margin: 0 auto 20px;">
                <i class="fas fa-map-marker-alt" style="color: white; font-size: 24px;"></i>
              </div>
              <h3>Navigation Reminder</h3>
              <p>Remember to return to this map when you arrive at your destination to continue exploring!</p>
              <button class="btn btn-primary" onclick="window.open('${navigationUrl}', '_blank'); this.closest('.modal').remove();">
                Got it!
              </button>
            </div>
          </div>
        `;
        
        document.body.appendChild(reminderModal);
        
        requestAnimationFrame(() => {
          reminderModal.classList.add('show');
        });
      };
      
      const handleNavigation = async (button, appType) => {
        const spinner = button.querySelector('.loading-spinner');
        const span = button.querySelector('span');
        
        spinner.style.display = 'inline-block';
        button.style.opacity = '0.7';
        span.textContent = 'Getting location...';
        
        await getUserLocation();
        
        let navigationUrl;
        if (appType === 'google') {
          navigationUrl = userLat && userLng ? 
            `https://www.google.com/maps/dir/${userLat},${userLng}/${destinationLat},${destinationLng}` :
            `https://www.google.com/maps/dir/?api=1&destination=${destinationLat},${destinationLng}`;
        } else if (appType === 'waze') {
          navigationUrl = userLat && userLng ?
            `https://www.waze.com/ul?ll=${destinationLat}%2C${destinationLng}&navigate=yes&from=${userLat}%2C${userLng}` :
            `https://www.waze.com/ul?ll=${destinationLat}%2C${destinationLng}&navigate=yes`;
        } else if (appType === 'apple') {
          const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
          if (!isIOS) {
            closeModal();
            showPopup('Info', 'Apple Maps is only available on iOS devices');
            return;
          }
          navigationUrl = userLat && userLng ?
            `maps://maps.apple.com/?saddr=${userLat},${userLng}&daddr=${destinationLat},${destinationLng}` :
            `maps://maps.apple.com/?daddr=${destinationLat},${destinationLng}`;
        }
        
        closeModal();
        showReminderModal(navigationUrl);
      };
      
      // Event listeners
      modal.querySelector('.google-maps').addEventListener('click', () => handleNavigation(modal.querySelector('.google-maps'), 'google'));
      modal.querySelector('.waze').addEventListener('click', () => handleNavigation(modal.querySelector('.waze'), 'waze'));
      modal.querySelector('.apple-maps').addEventListener('click', () => handleNavigation(modal.querySelector('.apple-maps'), 'apple'));
      modal.querySelector('.cancel').addEventListener('click', closeModal);
      
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          closeModal();
        }
      });
      
      // Start getting location immediately
      getUserLocation();
    }

    // ===== LOCATION SUMMARY =====
    
function showLocationSummary(locationId) {
    const location = locations.find(loc => String(loc.id) === String(locationId));
    
    if (location && location.summary) {
        // Create popup modal from scratch to match returnToIndex style
        const popupDiv = document.createElement("div");
        popupDiv.id = 'summaryModal';
        popupDiv.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.6);
            backdrop-filter: blur(4px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease;
        `;
        
        // Using the same dark blue color
        const darkBlue = "#1a3a8a";
        const darkBlueHover = "#0d2c6e";
        
        popupDiv.innerHTML = `
            <div class="modal-container" style="
                background-color: white;
                border-radius: 16px;
                overflow: hidden;
                width: 90%;
                max-width: 420px;
                max-height: 80vh;
                box-shadow: 0 15px 40px rgba(0,0,0,0.2);
                margin: auto;
                transform: translateY(20px);
                transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
                display: flex;
                flex-direction: column;
            ">
                <!-- Dark blue title bar with white text -->
                <div style="
                    background-color: ${darkBlue};
                    padding: 18px 28px;
                    color: white;
                    text-align: center;
                ">
                    <h3 style="
                        margin: 0;
                        font-size: 1.5rem;
                        font-weight: 600;
                    ">${location.name}</h3>
                </div>
                
                <!-- Content area -->
                <div style="
                    flex-grow: 1;
                    overflow-y: auto;
                    padding: 28px;
                ">
                    <!-- Summary content -->
                    <div id="summaryContent" style="
                        color: #5c6c7c;
                        line-height: 1.6;
                        font-size: 1rem;
                        margin-bottom: 25px;
                    ">
                        <p>${location.summary}</p>
                    </div>
                    
                    <!-- Location today in styled box with left-right layout -->
                    <div style="
                        border: 2px solid ${darkBlue};
                        border-radius: 12px;
                        padding: 16px;
                        background-color: rgba(26, 58, 138, 0.05);
                        margin-bottom: 25px;
                        display: flex;
                        align-items: center;
                    ">
                        <div style="
                            font-weight: 600;
                            color: #2c3e50;
                            padding-right: 15px;
                            min-width: 80px;
                        ">Location:</div>
                        <div style="
                            flex: 1;
                            color: #2c3e50;
                            font-weight: normal;
                            border-left: 1px solid rgba(26, 58, 138, 0.2);
                            padding-left: 15px;
                            line-height: 1.4;
                        ">${location.today || "Information not available"}</div>
                    </div>
                    
                    <!-- Continue button -->
                    <div style="
                        display: flex;
                        justify-content: center;
                    ">
                        <button class="continue-btn" style="
                            padding: 14px 24px;
                            background-color: ${darkBlue};
                            color: white;
                            border: none;
                            border-radius: 10px;
                            cursor: pointer;
                            font-size: 1rem;
                            font-weight: 600;
                            min-width: 130px;
                            transition: all 0.2s ease;
                        ">Continue</button>
                    </div>
                </div>
            </div>
        `;
        
        document.body.appendChild(popupDiv);
        
        // Trigger animation
        setTimeout(() => {
            popupDiv.style.opacity = "1";
            popupDiv.querySelector(".modal-container").style.transform = "translateY(0)";
        }, 10);
        
        // Button hover effects
        const continueBtn = popupDiv.querySelector(".continue-btn");
        continueBtn.addEventListener("mouseover", function() {
            this.style.backgroundColor = darkBlueHover;
        });
        continueBtn.addEventListener("mouseout", function() {
            this.style.backgroundColor = darkBlue;
        });
        
        // Close button event
        continueBtn.addEventListener("click", function() {
            popupDiv.style.opacity = "0";
            popupDiv.querySelector(".modal-container").style.transform = "translateY(20px)";
            setTimeout(() => {
                document.body.removeChild(popupDiv);
            }, 300);
        });

                // Close modal when clicking outside
        popupDiv.addEventListener("click", function(event) {
            if (event.target === popupDiv) {
                popupDiv.style.opacity = "0";
                popupDiv.querySelector(".modal-container").style.transform = "translateY(20px)";
                setTimeout(() => {
                    document.body.removeChild(popupDiv);
                }, 300);
            }
        });
    } else {
        console.log("Location or summary not found. Location ID:", locationId);
        showPopup("Error", "Summary not available for this location.");
    }
}

    // ===== UTILITY FUNCTIONS =====
    
    function showPopup(title, message, type = "info", callback = null) {
      const existingPopups = document.querySelectorAll(".popup-overlay");
      existingPopups.forEach(popup => popup.remove());

      const overlay = document.createElement("div");
      overlay.className = "popup-overlay";
      overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        backdrop-filter: blur(8px);
        z-index: 10000;
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0;
        transition: opacity 0.3s ease;
      `;
      
      const popup = document.createElement("div");
      popup.style.cssText = `
        background: white;
        border-radius: var(--border-radius-xl);
        padding: 32px;
        width: 90%;
        max-width: 400px;
        box-shadow: var(--shadow-xl);
        transform: scale(0.9);
        transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      `;
      
      popup.innerHTML = `
        <h3 style="margin: 0 0 16px 0; text-align: center; color: var(--neutral-900); font-size: 1.5rem; font-weight: 600;">${title}</h3>
        <p style="margin: 0 0 24px 0; text-align: center; color: var(--neutral-700); line-height: 1.6;">${message}</p>
        <div style="text-align: center;">
          <button class="btn btn-primary" onclick="this.closest('.popup-overlay').remove(); ${callback ? 'callback()' : ''}">OK</button>
        </div>
      `;
      
      overlay.appendChild(popup);
      document.body.appendChild(overlay);
      
      requestAnimationFrame(() => {
        overlay.style.opacity = "1";
        popup.style.transform = "scale(1)";
      });
      
      overlay.addEventListener("click", (e) => {
        if (e.target === overlay) {
          overlay.remove();
        }
      });
    }

//Updated Navigation Tips Modal
function showNavigationTips() {
   // Hide the distance box when overlay appears
   const distanceBox = document.querySelector('#distanceBox'); 
   if (distanceBox) {
       distanceBox.style.display = 'none';
   }

   // Create modal overlay with proper centering
   const modalOverlay = document.createElement("div");
   modalOverlay.className = "navigation-tips-overlay";
   modalOverlay.style.cssText = `
       position: fixed;
       top: 0;
       left: 0;
       width: 100%;
       height: 100%;
       background-color: rgba(0, 0, 0, 0.6);
       backdrop-filter: blur(4px);
       display: flex;
       justify-content: center;
       align-items: center;
       z-index: 1000;
       opacity: 0;
       transition: opacity 0.3s ease;
   `;
   
   // Define colors
   const darkBlue = "var(--dark-blue)";
   const darkBlueHover = "var(--dark-blue-hover)";
   
   // Create modal content with improved styling and proper centering
   const modalContent = document.createElement("div");
   modalContent.className = "navigation-tips-content";
   modalContent.style.cssText = `
       background-color: white;
       border-radius: 16px;
       width: 90%;
       max-width: 450px;
       max-height: 95vh;
       box-shadow: 0 15px 40px rgba(0, 0, 0, 0.25);
       transform: translateY(20px);
       transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
       overflow: hidden;
       display: flex !important;
       flex-direction: column !important;
       position: relative;
   `;
   
   // Create header
   const header = document.createElement("div");
   header.style.cssText = `
       text-align: center;
       padding: 20px 28px 0;
   `;
   
   header.innerHTML = `
       <h3 style="
           margin: 0 0 10px 0;
           color: ${darkBlue};
           font-size: 1.5rem;
           font-weight: 600;
       ">Navigation Tips</h3>
   `;
   
   // Create content area with tips - reduced vertical spacing
   const contentArea = document.createElement("div");
   contentArea.style.cssText = `
       padding: 0 28px;
       color: #5c6c7c;
       line-height: 1.4;
       font-size: 0.9rem;
   `;
   
   contentArea.innerHTML = `
       <ul style="
           list-style-type: none;
           padding: 0;
           margin: 0 0 10px 0;
       ">
           <li style="margin-bottom: 8px; display: flex; align-items: flex-start;">
               <span style="color: ${darkBlue}; margin-right: 10px; font-size: 1.1rem;">â€¢</span>
               <span>Use the map to navigate to the marked locations.</span>
           </li>
           <li style="margin-bottom: 8px; display: flex; align-items: flex-start;">
               <span style="color: ${darkBlue}; margin-right: 10px; font-size: 1.1rem;">â€¢</span>
               <span>Tap the recenter button to focus on your current position.</span>
           </li>
           <li style="margin-bottom: 8px; display: flex; align-items: flex-start;">
               <span style="color: ${darkBlue}; margin-right: 10px; font-size: 1.1rem;">â€¢</span>
               <span>The distance box shows how far you are from the closest location.</span>
           </li>
           <li style="margin-bottom: 8px; display: flex; align-items: flex-start;">
               <span style="color: ${darkBlue}; margin-right: 10px; font-size: 1.1rem;">â€¢</span>
               <span>When you're within 20 feet of a location, you'll be able to interact with it.</span>
           </li>
           <li style="margin-bottom: 8px; display: flex; align-items: flex-start;">
               <span style="color: ${darkBlue}; margin-right: 10px; font-size: 1.1rem;">â€¢</span>
               <span>Listen to the audio information for each location.</span>
           </li>
           <li style="margin-bottom: 0; display: flex; align-items: flex-start;">
               <span style="color: ${darkBlue}; margin-right: 10px; font-size: 1.1rem;">â€¢</span>
               <span>After the audio, you'll see additional information about the location.</span>
           </li>
       </ul>
   `;
   
   
   // Create footer with close button
   const footer = document.createElement("div");
   footer.style.cssText = `
       padding: 15px 28px 20px !important;
       text-align: center !important;
       border-top: 1px solid rgba(0, 0, 0, 0.05);
       margin-top: 10px !important;
       display: flex !important;
       justify-content: center !important;
       align-items: center !important;
       position: relative !important;
       bottom: 0 !important;
       width: 100% !important;
       box-sizing: border-box !important;
   `;
   
   const closeButton = document.createElement("button");
   closeButton.className = "close-button";
   closeButton.textContent = "Close";
   closeButton.style.cssText = `
       padding: 10px 24px !important;
       background-color: ${darkBlue};
       color: white;
       border: none;
       border-radius: 10px;
       cursor: pointer;
       font-size: 1rem;
       font-weight: 600;
       width: 100% !important;
       max-width: 200px !important;
       transition: all 0.2s ease;
       margin: 0 auto !important;
       display: block !important;
       position: relative !important;
       left: 0 !important;
       right: 0 !important;
   `;
   
   footer.appendChild(closeButton);
   
   // Assemble modal - ensure proper order
   modalContent.appendChild(header);
   modalContent.appendChild(contentArea);
   modalContent.appendChild(footer);
   modalOverlay.appendChild(modalContent);
   document.body.appendChild(modalOverlay);
   
   // Trigger animation after a brief delay
   setTimeout(() => {
       modalOverlay.style.opacity = "1";
       modalContent.style.transform = "translateY(0)";
   }, 10);
   
   // Button hover effects
   closeButton.addEventListener("mouseover", function() {
       this.style.backgroundColor = darkBlueHover;
   });
   
   closeButton.addEventListener("mouseout", function() {
       this.style.backgroundColor = darkBlue;
   });
   
   // Close button event
   closeButton.addEventListener("click", function() {
       modalOverlay.style.opacity = "0";
       modalContent.style.transform = "translateY(20px)";
       setTimeout(() => {
           document.body.removeChild(modalOverlay);
           // Show the distance box again when modal is closed
           if (distanceBox) {
               distanceBox.style.display = 'block';
           }
       }, 300);
   });
   
   // Close when clicking outside
   modalOverlay.addEventListener("click", function(e) {
       if (e.target === modalOverlay) {
           modalOverlay.style.opacity = "0";
           modalContent.style.transform = "translateY(20px)";
           setTimeout(() => {
               document.body.removeChild(modalOverlay);
               // Show the distance box again when modal is closed by clicking outside
               if (distanceBox) {
                   distanceBox.style.display = 'block';
               }
           }, 300);
       }
   });
}

function returnToIndex() {
   // Hide the distance box when overlay appears
   const distanceBox = document.querySelector('#distanceBox'); 
   if (distanceBox) {
       distanceBox.style.display = 'none';
   }

   // Create popup with proper centering and animation
   const popupDiv = document.createElement("div");
   popupDiv.style.cssText = `
       position: fixed;
       top: 0;
       left: 0;
       width: 100%;
       height: 100%;
       background-color: rgba(0,0,0,0.6);
       backdrop-filter: blur(4px);
       display: flex;
       justify-content: center;
       align-items: center;
       z-index: 1000;
       opacity: 0;
       transition: opacity 0.3s ease;
   `;
   // Using var(--dark-blue) as the dark blue color
   const darkBlue = "var(--dark-blue)";
   const darkBlueHover = "var(--dark-blue-hover)";
   popupDiv.innerHTML = `
       <div class="modal-container" style="
       background-color: white;
       border-radius: 16px;
       padding: 28px;
       width: 90%;
       max-width: 420px;
       max-height: 90vh;
       box-shadow: 0 15px 40px rgba(0,0,0,0.2);
       margin: auto;
       transform: translateY(20px);
       transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
       overflow: hidden;
       display: flex;
       flex-direction: column;
       ">
       <div style="
           text-align: center;
           margin-bottom: 25px;
       ">
                           <svg width="50" height="50" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
           <circle cx="12" cy="12" r="10" stroke="${darkBlue}" stroke-width="1.5"/>
           <path d="M12 8V13" stroke="${darkBlue}" stroke-width="2" stroke-linecap="round"/>
           <circle cx="12" cy="16" r="1" fill="${darkBlue}"/>
           </svg>
       </div>
       <h3 style="
           text-align: center;
           margin: 0 0 15px 0;
           color: #2c3e50;
           font-size: 1.5rem;
           font-weight: 600;
       ">Ready to Leave?</h3>
       <div style="flex-grow: 1; overflow-y: auto; padding: 0 10px;">
           <p style="
           text-align: center;
           margin: 0 0 30px 0;
           color: #5c6c7c;
           line-height: 1.5;
           font-size: 1rem;
           ">Are you sure you want to return to the main page?</p>
       </div>
       <div style="
           display: flex;
           justify-content: center;
           gap: 15px;
           margin-bottom: 15px;
       ">
           <button class="confirm-btn" style="
           padding: 14px 24px;
           background-color: ${darkBlue};
           color: white;
           border: none;
           border-radius: 10px;
           cursor: pointer;
           font-size: 1rem;
           font-weight: 600;
           min-width: 130px;
           transition: all 0.2s ease;
           ">Yes, Exit</button>
           <button class="cancel-btn" style="
           padding: 14px 24px;
           background-color: transparent;
           color: ${darkBlue};
           border: 1.5px solid ${darkBlue};
           border-radius: 10px;
           cursor: pointer;
           font-size: 1rem;
           font-weight: 600;
           min-width: 130px;
           transition: all 0.2s ease;
           ">Stay Here</button>
       </div>
       <div style="text-align: center; margin-top: 15px;">
           <a href="#" class="credits-link" style="
           display: inline-block;
           text-align: center;
           color: #64748b;
           text-decoration: none;
           font-size: 0.9rem;
           padding: 8px 20px;
           border-radius: 100px;
           border: 1px solid rgba(100, 116, 139, 0.2);
           background-color: rgba(100, 116, 139, 0.05);
           transition: all 0.2s ease;
           ">View Acknowledgements</a>
       </div>
       </div>
   `;
   document.body.appendChild(popupDiv);
   // Trigger animation
   setTimeout(() => {
       popupDiv.style.opacity = "1";
       popupDiv.querySelector(".modal-container").style.transform = "translateY(0)";
   }, 10);
   // Button hover effects
   const confirmBtn = popupDiv.querySelector(".confirm-btn");
   confirmBtn.addEventListener("mouseover", function() {
       this.style.backgroundColor = darkBlueHover;
   });
   confirmBtn.addEventListener("mouseout", function() {
       this.style.backgroundColor = darkBlue;
   });
   const cancelBtn = popupDiv.querySelector(".cancel-btn");
   cancelBtn.addEventListener("mouseover", function() {
       this.style.backgroundColor = "rgba(26, 58, 138, 0.05)";
   });
   cancelBtn.addEventListener("mouseout", function() {
       this.style.backgroundColor = "transparent";
   });
   const creditsLink = popupDiv.querySelector(".credits-link");
   creditsLink.addEventListener("mouseover", function() {
       this.style.backgroundColor = "rgba(100, 116, 139, 0.1)";
       this.style.borderColor = "rgba(100, 116, 139, 0.3)";
   });
   creditsLink.addEventListener("mouseout", function() {
       this.style.backgroundColor = "rgba(100, 116, 139, 0.05)";
       this.style.borderColor = "rgba(100, 116, 139, 0.2)";
   });
   // Event listeners
   confirmBtn.addEventListener("click", function() {
       popupDiv.style.opacity = "0";
       popupDiv.querySelector(".modal-container").style.transform = "translateY(20px)";
       setTimeout(() => {
           document.body.removeChild(popupDiv);
           window.location.href = "/index.html";
       }, 300);
   });
   cancelBtn.addEventListener("click", function() {
       popupDiv.style.opacity = "0";
       popupDiv.querySelector(".modal-container").style.transform = "translateY(20px)";
       setTimeout(() => {
           document.body.removeChild(popupDiv);
           // Show the distance box again when user cancels
           if (distanceBox) {
               distanceBox.style.display = 'block';
           }
       }, 300);
   });
   creditsLink.addEventListener("click", function(e) {
       e.preventDefault();
       // Simplified credits popup with dark blue
       const creditsPopup = document.createElement("div");
       creditsPopup.style.cssText = `
           position: fixed;
           top: 0;
           left: 0;
           width: 100%;
           height: 100%;
           background-color: rgba(0,0,0,0.7);
           backdrop-filter: blur(6px);
           display: flex;
           justify-content: center;
           align-items: center;
           z-index: 1001;
           opacity: 0;
           transition: opacity 0.3s ease;
       `;
       creditsPopup.innerHTML = `
           <div class="credits-container" style="
               background-color: white;
               border-radius: 16px;
               width: 92%;
               max-width: 450px;
               max-height: 80vh;
               box-shadow: 0 20px 50px rgba(0,0,0,0.25);
               margin: auto;
               transform: translateY(20px);
               transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
               overflow: hidden;
               display: flex;
               flex-direction: column;
           ">
               <div style="
                   background-color: ${darkBlue};
                   padding: 20px;
                   color: white;
                   text-align: center;
               ">
                   <h3 style="margin: 0; font-size: 1.5rem; font-weight: 600;">Acknowledgements</h3>
               </div>
               <div style="
                   padding: 20px;
                   flex-grow: 1;
                   overflow-y: auto;
               ">
                   <ul style="list-style-type: none; padding: 0; margin: 0;">
                       <li style="margin-bottom: 20px;">
                           <strong style="color: #1e293b; font-size: 1.05rem;">OpenStreetMap</strong>
                           <p style="color: #64748b; margin: 5px 0 0 0; font-size: 0.9rem; line-height: 1.5;">
                               Providing the map data and tiles for this interactive experience.
                           </p>
                       </li>
                       <li style="margin-bottom: 20px;">
                           <strong style="color: #1e293b; font-size: 1.05rem;">Minnesota Historical Society</strong>
                           <p style="color: #64748b; margin: 5px 0 0 0; font-size: 0.9rem; line-height: 1.5;">
                               For their invaluable historical data, photographs, and archive materials.
                           </p>
                       </li>
                       <li style="margin-bottom: 20px;">
                           <strong style="color: #1e293b; font-size: 1.05rem;">Metropolitan State University</strong>
                           <p style="color: #64748b; margin: 5px 0 0 0; font-size: 0.9rem; line-height: 1.5;">
                               For fostering a passion for history and research methodology.
                           </p>
                       </li>
                       <li style="margin-bottom: 20px;">
                           <strong style="color: #1e293b; font-size: 1.05rem;">Leaflet.js</strong>
                           <p style="color: #64748b; margin: 5px 0 0 0; font-size: 0.9rem; line-height: 1.5;">
                               The open-source JavaScript library that powers the mapping features.
                           </p>
                       </li>
                       <li>
                           <strong style="color: #1e293b; font-size: 1.05rem;">All Contributors</strong>
                           <p style="color: #64748b; margin: 5px 0 0 0; font-size: 0.9rem; line-height: 1.5;">
                               Researchers, testers, and developers who made this project possible.
                           </p>
                       </li>
                   </ul>
               </div>
               <div style="padding: 15px; text-align: center; border-top: 1px solid #eee;">
                   <button class="close-credits-btn" style="
                       padding: 12px 30px;
                       background-color: ${darkBlue};
                       color: white;
                       border: none;
                       border-radius: 10px;
                       cursor: pointer;
                       font-size: 0.95rem;
                       font-weight: 600;
                       transition: background-color 0.2s ease;
                   ">Close</button>
               </div>
           </div>
       `;
       document.body.appendChild(creditsPopup);
       // Trigger animation
       setTimeout(() => {
           creditsPopup.style.opacity = "1";
           creditsPopup.querySelector(".credits-container").style.transform = "translateY(0)";
       }, 10);
       // Close button interaction
       const closeBtn = creditsPopup.querySelector(".close-credits-btn");
       closeBtn.addEventListener("mouseover", function() {
           this.style.backgroundColor = darkBlueHover;
       });
       closeBtn.addEventListener("mouseout", function() {
           this.style.backgroundColor = darkBlue;
       });
       closeBtn.addEventListener("click", function() {
           creditsPopup.style.opacity = "0";
           creditsPopup.querySelector(".credits-container").style.transform = "translateY(20px)";
           setTimeout(() => {
               document.body.removeChild(creditsPopup);
           }, 300);
       });
       // Close when clicking outside
       creditsPopup.addEventListener("click", function(e) {
           if (e.target === creditsPopup) {
               creditsPopup.style.opacity = "0";
               creditsPopup.querySelector(".credits-container").style.transform = "translateY(20px)";
               setTimeout(() => {
                   document.body.removeChild(creditsPopup);
               }, 300);
           }
       });
   });
   // Close when clicking outside
   popupDiv.addEventListener("click", function(e) {
       if (e.target === popupDiv) {
           popupDiv.style.opacity = "0";
           popupDiv.querySelector(".modal-container").style.transform = "translateY(20px)";
           setTimeout(() => {
               document.body.removeChild(popupDiv);
               // Show the distance box again when user clicks outside
               if (distanceBox) {
                   distanceBox.style.display = 'block';
               }
           }, 300);
       }
   });
}

    function recenterMap() {
      const button = cachedElements.recenterButton;
      if (button) {
        button.style.transform = 'scale(0.95)';
        setTimeout(() => {
          button.style.transform = 'scale(1)';
        }, 150);
      }
      
      if (userMarker && userMarker.getLatLng()) {
        map.closePopup();
        map.panTo(userMarker.getLatLng(), {
          animate: true,
          duration: 0.5,
          easeLinearity: 0.25
        });
        followUser = true;
        announceToScreenReader('Map recentered on your location');
      }
    }

    function resetInactivityTimer(explicit = true) {
      clearTimeout(inactivityTimer);
      inactivityTimer = setTimeout(() => {
        if (!isMapInteracting && userMarker) {
          followUser = true;
          map.flyTo(userMarker.getLatLng(), map.getZoom(), { duration: 1 });
        }
      }, CONFIG.INACTIVITY_TIMEOUT);
      
      if (explicit) {
        isMapInteracting = false;
      }
    }

    // ===== EVENT LISTENERS =====
    
    function setupEventListeners() {
      // Map interaction events
      map.on('dragstart', () => {
        followUser = false;
        isMapInteracting = true;
        clearTimeout(inactivityTimer);
      });
      
      map.on('dragend', () => {
        isMapInteracting = false;
        resetInactivityTimer();
      });
      
      map.on('zoomstart', () => {
        isMapInteracting = true;
        clearTimeout(inactivityTimer);
      });
      
      map.on('zoomend', () => {
        isMapInteracting = false;
        resetInactivityTimer();
      });
      
      // Touch handling
      let touchStartTime = 0;
      let touchStartPos = null;
      let isTouchMoving = false;
      
      document.addEventListener('touchstart', (e) => {
        touchStartTime = Date.now();
        touchStartPos = {
          x: e.touches[0].clientX,
          y: e.touches[0].clientY
        };
        isTouchMoving = false;
      }, { passive: true });
      
      document.addEventListener('touchmove', (e) => {
        if (!touchStartPos) return;
        
        const current = {
          x: e.touches[0].clientX,
          y: e.touches[0].clientY
        };
        
        const distance = Math.sqrt(
          Math.pow(current.x - touchStartPos.x, 2) + 
          Math.pow(current.y - touchStartPos.y, 2)
        );
        
        if (distance > 10) {
          isTouchMoving = true;
          isMapInteracting = true;
          followUser = false;
          clearTimeout(inactivityTimer);
        }
      }, { passive: true });
      
      document.addEventListener('touchend', () => {
        const touchDuration = Date.now() - touchStartTime;
        touchStartPos = null;
        
        if (touchDuration > 300 || isTouchMoving) {
          isMapInteracting = false;
          resetInactivityTimer();
        }
      }, { passive: true });
      
      // Button events
      cachedElements.recenterButton.addEventListener('click', recenterMap);
      cachedElements.returnButton.addEventListener('click', returnToIndex);
      cachedElements.tipsButton.addEventListener('click', showNavigationTips);
      
      // Visibility change
      document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
          lastHiddenTime = Date.now();
          lastKnownPosition = userMarker?.getLatLng() || null;
        } else {
          const hiddenDuration = Date.now() - lastHiddenTime;
          if (hiddenDuration > CONFIG.BACKGROUND_THRESHOLD) {
            // Update location after being in background
            if (navigator.geolocation) {
              navigator.geolocation.getCurrentPosition(
                (position) => {
                  updateUserLocation(position, true);
                },
                (error) => {
                  console.warn('Background location update failed:', error);
                }
              );
            }
          } else {
            map.invalidateSize();
          }
        }
        resetInactivityTimer();
      });
      
      // Window resize
      window.addEventListener('resize', debounce(() => {
        if (map) {
          map.invalidateSize();
          updateDistanceBox();
        }
      }, 250));
      
      // High contrast toggle
      if (accessibilityState.highContrast) {
        document.body.classList.add('high-contrast');
      }
    }

    // ===== INITIALIZATION =====
    
    document.addEventListener('DOMContentLoaded', async () => {
      // Initialize systems
      await cacheManager.init();
      performanceMonitor.startMonitoring();
      
      // Cache DOM elements
      cacheElements();
      
      // Initialize map
      initMap();
      
      // Setup event listeners
      setupEventListeners();
      
      // Initialize containers
      const additionalInfoContainer = cachedElements.additionalInfoContainer;
      if (additionalInfoContainer) {
        additionalInfoContainer.style.display = 'none';
      }
      
      const lochuntContainer = cachedElements.lochuntContainer;
      if (lochuntContainer) {
        lochuntContainer.style.display = 'none';
      }
      
      // Performance monitoring
      console.log('App initialized, monitoring performance...');
      setInterval(() => {
        const metrics = performanceMonitor.getMetrics();
        if (metrics.fps < 30 || metrics.memory > 100) {
          console.warn('Performance warning:', metrics);
        }
      }, 10000);
    });

    // Export for debugging
    window.DEBUG = {
      config: CONFIG,
      state: {
        gameLocations,
        userMarker,
        map,
        isLocationHuntVisible,
        followUser,
        lastPosition
      },
      metrics: () => performanceMonitor.getMetrics(),
      cache: cacheManager,
      kalman: enhancedKalmanFilter
    };
    </script>
</body>
</html>
