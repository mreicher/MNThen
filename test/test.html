<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Minnesota Then | Self-Guided Tours</title>
    <link rel="shortcut icon" type="image/x-icon" href="https://www.mnthen.com/images/mnthenfav.ico">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css">
    <link rel="stylesheet" href="https://www.mnthen.com/css/mnthen_tour_gangster.css">
    <style>
        :root {
            --primary-color: #005f9e;
            --hover-color: #e6f2ff;
            --shadow-color: rgba(0, 0, 0, 0.1);
        }
        
        .user-marker-icon {
            width: 20px;
            height: 20px;
            background: #4285F4;
            border: 3px solid white;
            border-radius: 50%;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }
        
        .custom-pin-icon .pin-head {
            width: 30px;
            height: 30px;
            background: #e74c3c;
            border: 3px solid white;
            border-radius: 50% 50% 50% 0;
            transform: rotate(-45deg);
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }
        
        .inactive-pin .pin-head {
            background: #95a5a6;
        }
        
        .speed-indicator {
            position: fixed;
            top: 70px;
            right: 10px;
            background: rgba(255,255,255,0.95);
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.15);
            z-index: 1000;
            display: none;
        }
        
        .speed-indicator.centered-mode {
            border-left: 3px solid #4285F4;
        }
        
        .speed-indicator.roaming-mode {
            border-left: 3px solid #34a853;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <div id="distanceBox">Initializing...</div>
    <div id="speedIndicator" class="speed-indicator"></div>
    
    <div class="show-all-switch">
        <label class="switch">
            <input type="checkbox" id="showAllLocations">
            <span class="slider round"></span>
        </label>
    </div>
    
    <div class="lochunt-container">
        <img id="locationImage" src="/placeholder.svg" alt="Location Image">
        <div class="lochunt-content">
            <div class="lochunt-info">
                <h2 id="locationTitle" class="mb-2 text-primary"></h2>
                <p id="locationCity" class="text-muted mb-1"></p>
                <p id="locationCreator" class="text-muted mb-3"></p>
            </div>
            <div class="audio-player">
                <div class="audio-progress">
                    <div class="progress">
                        <div id="progressBar" class="progress-bar" role="progressbar" style="width: 0%"></div>
                    </div>
                </div>
                <div class="audio-time">
                    <span id="currentTime">0:00</span>
                    <span id="duration">0:00</span>
                </div>
                <div class="audio-controls">
                    <button id="rewindBtn" class="audio-button"><i class="fas fa-backward"></i></button>
                    <button id="playPauseBtn" class="audio-button"><i class="fas fa-play"></i></button>
                    <button id="forwardBtn" class="audio-button"><i class="fas fa-forward"></i></button>
                </div>
                <audio id="locationAudio" src="/placeholder.svg"></audio>
            </div>
        </div>
    </div>
    
    <div class="trivia-container">
        <h3 class="mb-3 text-primary">Trivia Question</h3>
        <p id="triviaQuestion" class="mb-3 fw-bold"></p>
        <div id="triviaOptions" class="d-grid gap-2"></div>
    </div>
    
    <div class="map-buttons">
        <button id="recenterButton" class="map-button"><i class="fas fa-crosshairs"></i></button>
        <button id="returnButton" class="map-button"><i class="fas fa-sign-out-alt"></i></button>
        <button id="tipsButton" class="map-button"><i class="fas fa-question-circle"></i></button>
    </div>
    
    <div class="navigation-tips">
        <button class="close-button">&times;</button>
        <h3>Navigation Tips</h3>
        <ul>
            <li>Enable the toggle to see every stop on the tour.</li>
            <li>Use the map to navigate to the marked locations.</li>
            <li>The distance box shows how far you are from the current location.</li>
            <li>Tap the recenter button to focus on your position.</li>
            <li>When you're within 20 feet of a location, you'll be able to interact with it.</li>
            <li>Complete the trivia question to move to the next location.</li>
        </ul>
    </div>
    
    <div id="congratulations">
        <h2>Congratulations!</h2>
        <p>You have successfully completed the Minnesota Then Gangster History Tour!</p>
        <button onclick="endTour()">Return to the Home Page</button>
    </div>
    
    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <script src="locations_h.js?v=1.0.2"></script>
    <script>
// ============================================================================
// CONFIGURATION CONSTANTS
// ============================================================================
const CONFIG = {
    // Speed thresholds (in meters per second)
    SPEED_CENTER_THRESHOLD: 6.7056,  // 15 mph in m/s - above this, always center
    SPEED_SMOOTH_MIN: 2.2352,        // 5 mph - below this, very relaxed following
    
    // Edge detection thresholds (as percentage of viewport)
    EDGE_SOFT: 0.25,      // Start gentle recentering at 25% from edge
    EDGE_MEDIUM: 0.15,    // More urgent recentering at 15% from edge
    EDGE_HARD: 0.08,      // Critical recentering at 8% from edge
    EDGE_EMERGENCY: 0.03, // Emergency snap at 3% from edge
    
    // Animation durations (in seconds)
    ANIM_FAST: 0.2,
    ANIM_NORMAL: 0.35,
    ANIM_SLOW: 0.5,
    
    // Position filtering
    BUFFER_SIZE: 8,
    MIN_ACCURACY: 50,           // Ignore readings worse than 50m
    MIN_MOVEMENT: 0.5,          // Minimum movement in meters to register
    MAX_TELEPORT_DISTANCE: 100, // Reset filter if jumped more than 100m
    
    // Map behavior
    DEFAULT_ZOOM: 18,
    INACTIVITY_TIMEOUT: 25000,
    DISTANCE_THRESHOLD: 20,     // Feet - proximity to trigger location hunt
    
    // Update intervals
    MIN_UPDATE_INTERVAL: 100,   // Minimum ms between position updates
};

// ============================================================================
// STATE MANAGEMENT
// ============================================================================
const state = {
    // Map and markers
    map: null,
    userMarker: null,
    locationMarker: null,
    allLocationMarkers: [],
    
    // Position tracking
    currentPosition: null,
    lastPosition: null,
    positionBuffer: [],
    lastUpdateTime: 0,
    currentSpeed: 0,
    currentHeading: null,
    
    // Viewport management
    isUserInteracting: false,
    followUser: true,
    lastRecenterTime: 0,
    viewportMode: 'roaming', // 'roaming' or 'centered'
    
    // Tour state
    currentLocationIndex: 0,
    visitedLocations: [],
    gameLocations: [],
    isLocationHuntVisible: false,
    showingAllLocations: false,
    
    // Timers
    inactivityTimer: null,
};

// ============================================================================
// POSITION FILTER - Kalman-inspired smoothing
// ============================================================================
const PositionFilter = {
    estimate: null,
    errorEstimate: 1,
    processNoise: 0.01,
    
    reset(position) {
        this.estimate = { lat: position.lat, lng: position.lng };
        this.errorEstimate = 1;
    },
    
    update(measurement) {
        if (!this.estimate) {
            this.reset(measurement);
            return measurement;
        }
        
        // Measurement noise based on GPS accuracy
        const measurementNoise = Math.max(0.1, measurement.accuracy / 50);
        
        // Prediction step
        const predictedError = this.errorEstimate + this.processNoise;
        
        // Update step
        const kalmanGain = predictedError / (predictedError + measurementNoise);
        
        this.estimate = {
            lat: this.estimate.lat + kalmanGain * (measurement.lat - this.estimate.lat),
            lng: this.estimate.lng + kalmanGain * (measurement.lng - this.estimate.lng)
        };
        
        this.errorEstimate = (1 - kalmanGain) * predictedError;
        
        return {
            lat: this.estimate.lat,
            lng: this.estimate.lng,
            accuracy: measurement.accuracy
        };
    }
};

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================
function calculateDistance(pos1, pos2) {
    const R = 6371000; // Earth's radius in meters
    const lat1 = pos1.lat * Math.PI / 180;
    const lat2 = pos2.lat * Math.PI / 180;
    const deltaLat = (pos2.lat - pos1.lat) * Math.PI / 180;
    const deltaLng = (pos2.lng - pos1.lng) * Math.PI / 180;
    
    const a = Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) +
              Math.cos(lat1) * Math.cos(lat2) *
              Math.sin(deltaLng / 2) * Math.sin(deltaLng / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    
    return R * c;
}

function metersPerSecondToMph(mps) {
    return mps * 2.23694;
}

function lerp(start, end, factor) {
    return start + (end - start) * factor;
}

function clamp(value, min, max) {
    return Math.min(Math.max(value, min), max);
}

function isPopupOpen() {
    return document.querySelector('.popup') !== null ||
           document.querySelector('.leaflet-popup') !== null ||
           document.querySelector('.custom-popup.leaflet-popup-content-wrapper') !== null;
}

// ============================================================================
// VIEWPORT MANAGEMENT - Core of the improved movement system
// ============================================================================
const ViewportManager = {
    // Get edge proximities as percentages (0 = at edge, 1 = at center)
    getEdgeProximities(position) {
        const bounds = state.map.getBounds();
        const latSpan = bounds.getNorth() - bounds.getSouth();
        const lngSpan = bounds.getEast() - bounds.getWest();
        
        return {
            north: (bounds.getNorth() - position.lat) / latSpan,
            south: (position.lat - bounds.getSouth()) / latSpan,
            east: (bounds.getEast() - position.lng) / lngSpan,
            west: (position.lng - bounds.getWest()) / lngSpan
        };
    },
    
    // Get the minimum edge proximity (closest edge)
    getMinEdgeProximity(position) {
        const proximities = this.getEdgeProximities(position);
        return Math.min(proximities.north, proximities.south, proximities.east, proximities.west);
    },
    
    // Determine urgency level based on edge proximity
    getUrgencyLevel(position) {
        const minProximity = this.getMinEdgeProximity(position);
        
        if (minProximity < CONFIG.EDGE_EMERGENCY) return 'emergency';
        if (minProximity < CONFIG.EDGE_HARD) return 'hard';
        if (minProximity < CONFIG.EDGE_MEDIUM) return 'medium';
        if (minProximity < CONFIG.EDGE_SOFT) return 'soft';
        return 'none';
    },
    
    // Calculate optimal center point based on current position and direction of travel
    calculateOptimalCenter(position, velocity) {
        const bounds = state.map.getBounds();
        const latSpan = bounds.getNorth() - bounds.getSouth();
        const lngSpan = bounds.getEast() - bounds.getWest();
        
        // If moving fast enough, offset center in direction of travel
        const speed = Math.sqrt(velocity.lat * velocity.lat + velocity.lng * velocity.lng);
        
        let offsetLat = 0;
        let offsetLng = 0;
        
        if (speed > 0.00001) {
            // Normalize velocity and apply offset (look ahead)
            const lookAheadFactor = Math.min(0.15, speed * 1000);
            offsetLat = (velocity.lat / speed) * latSpan * lookAheadFactor;
            offsetLng = (velocity.lng / speed) * lngSpan * lookAheadFactor;
        }
        
        return {
            lat: position.lat - offsetLat,
            lng: position.lng - offsetLng
        };
    },
    
    // Main update function - determines if/how to move the viewport
    updateViewport(position, speed, velocity) {
        if (state.isUserInteracting) return;
        
        const speedMph = metersPerSecondToMph(speed);
        const urgency = this.getUrgencyLevel(position);
        
        // Update mode indicator
        this.updateModeIndicator(speedMph, urgency);
        
        // HIGH SPEED MODE: Always keep centered
        if (speedMph >= 15) {
            state.viewportMode = 'centered';
            const optimalCenter = this.calculateOptimalCenter(position, velocity);
            state.map.setView([optimalCenter.lat, optimalCenter.lng], state.map.getZoom(), {
                animate: true,
                duration: CONFIG.ANIM_FAST
            });
            return;
        }
        
        // ROAMING MODE: Only recenter when approaching edges
        state.viewportMode = 'roaming';
        
        switch (urgency) {
            case 'emergency':
                // Snap immediately to prevent leaving viewport
                state.map.setView([position.lat, position.lng], state.map.getZoom(), {
                    animate: true,
                    duration: CONFIG.ANIM_FAST
                });
                break;
                
            case 'hard':
                // Quick recenter
                this.smoothRecenter(position, velocity, CONFIG.ANIM_NORMAL, 0.7);
                break;
                
            case 'medium':
                // Moderate recenter based on speed
                const mediumFactor = clamp(speedMph / 10, 0.3, 0.5);
                this.smoothRecenter(position, velocity, CONFIG.ANIM_NORMAL, mediumFactor);
                break;
                
            case 'soft':
                // Gentle nudge only if moving toward edge
                if (this.isMovingTowardEdge(position, velocity)) {
                    const softFactor = clamp(speedMph / 15, 0.1, 0.3);
                    this.smoothRecenter(position, velocity, CONFIG.ANIM_SLOW, softFactor);
                }
                break;
                
            case 'none':
                // No action needed - user can roam freely
                break;
        }
    },
    
    // Check if user is moving toward the nearest edge
    isMovingTowardEdge(position, velocity) {
        const proximities = this.getEdgeProximities(position);
        
        // Check each direction
        if (proximities.north < CONFIG.EDGE_SOFT && velocity.lat > 0) return true;
        if (proximities.south < CONFIG.EDGE_SOFT && velocity.lat < 0) return true;
        if (proximities.east < CONFIG.EDGE_SOFT && velocity.lng > 0) return true;
        if (proximities.west < CONFIG.EDGE_SOFT && velocity.lng < 0) return true;
        
        return false;
    },
    
    // Smooth recenter with configurable intensity
    smoothRecenter(position, velocity, duration, intensity) {
        const now = Date.now();
        if (now - state.lastRecenterTime < 200) return; // Throttle recenters
        state.lastRecenterTime = now;
        
        const currentCenter = state.map.getCenter();
        const optimalCenter = this.calculateOptimalCenter(position, velocity);
        
        // Interpolate between current center and optimal center
        const newCenter = {
            lat: lerp(currentCenter.lat, optimalCenter.lat, intensity),
            lng: lerp(currentCenter.lng, optimalCenter.lng, intensity)
        };
        
        state.map.setView([newCenter.lat, newCenter.lng], state.map.getZoom(), {
            animate: true,
            duration: duration
        });
    },
    
    // Ensure marker never leaves viewport - emergency containment
    ensureContainment(position) {
        const bounds = state.map.getBounds();
        const padding = 0.02; // 2% padding from absolute edge
        
        const latSpan = bounds.getNorth() - bounds.getSouth();
        const lngSpan = bounds.getEast() - bounds.getWest();
        
        const minLat = bounds.getSouth() + latSpan * padding;
        const maxLat = bounds.getNorth() - latSpan * padding;
        const minLng = bounds.getWest() + lngSpan * padding;
        const maxLng = bounds.getEast() - lngSpan * padding;
        
        // Check if position is outside safe bounds
        if (position.lat < minLat || position.lat > maxLat ||
            position.lng < minLng || position.lng > maxLng) {
            // Emergency recenter
            state.map.setView([position.lat, position.lng], state.map.getZoom(), {
                animate: true,
                duration: CONFIG.ANIM_FAST
            });
            return true;
        }
        return false;
    },
    
    // Update the speed/mode indicator
    updateModeIndicator(speedMph, urgency) {
        const indicator = document.getElementById('speedIndicator');
        if (!indicator) return;
        
        indicator.style.display = 'block';
        indicator.className = 'speed-indicator ' + 
            (state.viewportMode === 'centered' ? 'centered-mode' : 'roaming-mode');
        
        const modeText = speedMph >= 15 ? 'Centered' : 'Roaming';
        indicator.innerHTML = `${speedMph.toFixed(1)} mph • ${modeText}`;
    }
};

// ============================================================================
// POSITION TRACKING
// ============================================================================
function processPosition(position) {
    const now = Date.now();
    
    // Throttle updates
    if (now - state.lastUpdateTime < CONFIG.MIN_UPDATE_INTERVAL) return;
    
    const coords = position.coords;
    const newPosition = {
        lat: coords.latitude,
        lng: coords.longitude,
        accuracy: coords.accuracy,
        heading: coords.heading,
        speed: coords.speed,
        timestamp: now
    };
    
    // Validate coordinates
    if (isNaN(newPosition.lat) || isNaN(newPosition.lng)) return;
    
    // Reject poor accuracy readings
    if (newPosition.accuracy > CONFIG.MIN_ACCURACY) return;
    
    // Initialize if first position
    if (!state.currentPosition) {
        initializePosition(newPosition);
        return;
    }
    
    // Calculate distance moved
    const distance = calculateDistance(state.currentPosition, newPosition);
    
    // Handle teleportation (GPS jump)
    if (distance > CONFIG.MAX_TELEPORT_DISTANCE) {
        console.log('GPS teleport detected, resetting filter');
        initializePosition(newPosition);
        return;
    }
    
    // Reject tiny movements (GPS jitter)
    if (distance < CONFIG.MIN_MOVEMENT && newPosition.accuracy >= state.currentPosition.accuracy) {
        return;
    }
    
    // Calculate speed and velocity
    const timeDelta = (now - state.lastUpdateTime) / 1000;
    let speed = 0;
    let velocity = { lat: 0, lng: 0 };
    
    if (timeDelta > 0 && timeDelta < 10) {
        // Use GPS speed if available, otherwise calculate
        if (coords.speed !== null && coords.speed >= 0) {
            speed = coords.speed;
        } else {
            speed = distance / timeDelta;
        }
        
        // Calculate velocity vector
        velocity = {
            lat: (newPosition.lat - state.currentPosition.lat) / timeDelta,
            lng: (newPosition.lng - state.currentPosition.lng) / timeDelta
        };
    }
    
    // Reject unrealistic speeds (> 100 mph)
    if (speed > 44.7) return;
    
    // Apply Kalman filter
    const filteredPosition = PositionFilter.update(newPosition);
    
    // Add to buffer for additional smoothing
    state.positionBuffer.push(filteredPosition);
    if (state.positionBuffer.length > CONFIG.BUFFER_SIZE) {
        state.positionBuffer.shift();
    }
    
    // Calculate weighted average from buffer
    const smoothedPosition = calculateBufferAverage();
    
    // Update state
    state.lastPosition = state.currentPosition;
    state.currentPosition = smoothedPosition;
    state.currentSpeed = speed;
    state.currentHeading = newPosition.heading;
    state.lastUpdateTime = now;
    
    // Update marker position
    updateMarkerPosition(smoothedPosition);
    
    // Update viewport (the improved part!)
    if (!isPopupOpen()) {
        ViewportManager.ensureContainment(smoothedPosition);
        ViewportManager.updateViewport(smoothedPosition, speed, velocity);
    }
    
    // Update distance display
    updateDistanceBox();
}

function initializePosition(position) {
    state.currentPosition = position;
    state.lastPosition = position;
    state.positionBuffer = [position];
    state.lastUpdateTime = Date.now();
    state.currentSpeed = 0;
    
    PositionFilter.reset(position);
    
    state.userMarker.setLatLng([position.lat, position.lng]);
    state.map.setView([position.lat, position.lng], CONFIG.DEFAULT_ZOOM);
}

function calculateBufferAverage() {
    if (state.positionBuffer.length === 0) return state.currentPosition;
    
    let totalWeight = 0;
    let sumLat = 0;
    let sumLng = 0;
    
    // More recent positions get higher weight
    state.positionBuffer.forEach((pos, index) => {
        const recencyWeight = (index + 1) / state.positionBuffer.length;
        const accuracyWeight = 1 / (1 + (pos.accuracy || 10) / 20);
        const weight = recencyWeight * accuracyWeight;
        
        sumLat += pos.lat * weight;
        sumLng += pos.lng * weight;
        totalWeight += weight;
    });
    
    return {
        lat: sumLat / totalWeight,
        lng: sumLng / totalWeight,
        accuracy: state.positionBuffer[state.positionBuffer.length - 1].accuracy
    };
}

function updateMarkerPosition(position) {
    const currentLatLng = state.userMarker.getLatLng();
    
    // Smooth marker movement using CSS transitions
    state.userMarker.setLatLng([position.lat, position.lng]);
    
    // Update heading if available
    if (state.currentHeading !== null && !isNaN(state.currentHeading)) {
        const markerIcon = state.userMarker.getElement()?.querySelector('.user-marker-icon');
        if (markerIcon) {
            markerIcon.style.transition = 'transform 0.3s ease-out';
            markerIcon.style.transform = `rotate(${state.currentHeading}deg)`;
        }
    }
}

// ============================================================================
// MAP INITIALIZATION
// ============================================================================
function initMap() {
    state.map = L.map('map', {
        zoomControl: false,
        attributionControl: false,
        zoomSnap: 0.1,
        zoomDelta: 0.5,
        wheelDebounceTime: 100
    }).fitWorld();
    
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: '© OpenStreetMap contributors'
    }).addTo(state.map);
    
    // Create user marker
    state.userMarker = L.marker([0, 0], {
        icon: L.divIcon({
            className: 'user-marker',
            html: '<div class="user-marker-icon"></div>',
            iconSize: [20, 20],
            iconAnchor: [10, 10]
        }),
        zIndexOffset: 1000
    }).addTo(state.map);
    
    // Map interaction handlers
    state.map.on('dragstart zoomstart', () => {
        state.isUserInteracting = true;
        state.followUser = false;
    });
    
    state.map.on('dragend zoomend', () => {
        state.isUserInteracting = false;
        resetInactivityTimer();
    });
    
    state.map.on('movestart', resetInactivityTimer);
    state.map.on('click', resetInactivityTimer);
    
    // Enable touch interactions
    state.map.touchZoom.enable();
    state.map.doubleClickZoom.enable();
    
    // Start geolocation
    if ("geolocation" in navigator) {
        navigator.geolocation.getCurrentPosition(
            (position) => {
                processPosition(position);
                startContinuousTracking();
                startHunt();
            },
            handleLocationError,
            {
                enableHighAccuracy: true,
                timeout: 30000,
                maximumAge: 0
            }
        );
    } else {
        showPopup("Geolocation is not supported by your browser");
        state.map.setView([44.9778, -93.2650], CONFIG.DEFAULT_ZOOM);
        startHunt();
    }
}

function startContinuousTracking() {
    navigator.geolocation.watchPosition(
        processPosition,
        handleLocationError,
        {
            enableHighAccuracy: true,
            maximumAge: 0,
            timeout: 30000
        }
    );
}

function handleLocationError(error) {
    console.warn("Location error:", error);
    
    let message;
    switch (error.code) {
        case error.PERMISSION_DENIED:
            message = "Location permission denied. Please enable location services.";
            break;
        case error.POSITION_UNAVAILABLE:
            message = "Location unavailable. Retrying...";
            setTimeout(startContinuousTracking, 2000);
            break;
        case error.TIMEOUT:
            message = "Location request timed out. Retrying...";
            setTimeout(startContinuousTracking, 2000);
            break;
        default:
            message = "Unknown location error.";
    }
    
    document.getElementById('distanceBox').innerText = message;
}

// ============================================================================
// TOUR MANAGEMENT
// ============================================================================
function startHunt() {
    state.gameLocations = locations_h.sort((a, b) => a.id - b.id);
    state.currentLocationIndex = 0;
    loadNextLocation();
}

function loadNextLocation() {
    if (state.currentLocationIndex >= state.gameLocations.length) {
        showCongratulations();
        return;
    }
    
    const location = state.gameLocations[state.currentLocationIndex];
    
    // Remove existing location marker
    if (state.locationMarker) {
        state.map.removeLayer(state.locationMarker);
    }
    
    // Create new location marker
    state.locationMarker = L.marker([location.lat, location.lng], {
        icon: L.divIcon({
            className: 'custom-pin-icon',
            html: `<div class="pin-head" data-id="${location.id}"></div>`,
            iconSize: [30, 30],
            iconAnchor: [15, 30]
        })
    }).addTo(state.map);
    
    // Update all locations toggle if active
    if (state.showingAllLocations) {
        toggleAllLocations(true);
    }
    
    // Bind popup
    const popupContent = `
        <div class="popup-content">
            <img src="${location.image}" alt="${location.name}" class="location-image">
            <h4 class="location-name">
                <a href="${location.link}" target="_blank" rel="noopener noreferrer" style="text-decoration: none; color: inherit;">${location.name}</a>
            </h4>
            <div class="popup-buttons">
                <button class="button route-button" data-lat="${location.lat}" data-lng="${location.lng}">Directions</button>
                <button class="button bypass-button">Bypass</button>
            </div>
        </div>
    `;
    
    state.locationMarker.bindPopup(popupContent, {
        offset: L.point(0, -25),
        className: 'custom-popup'
    });
    
    state.locationMarker.on('popupopen', setupPopupHandlers);
    
    updateDistanceBox();
    resetInactivityTimer();
}

function setupPopupHandlers() {
    const routeButton = document.querySelector('.route-button');
    const bypassButton = document.querySelector('.bypass-button');
    
    if (routeButton) {
        routeButton.addEventListener('click', function(e) {
            e.preventDefault();
            const lat = this.getAttribute('data-lat');
            const lng = this.getAttribute('data-lng');
            showNavigationModal(lat, lng);
        });
    }
    
    if (bypassButton) {
        bypassButton.addEventListener('click', function() {
            state.currentLocationIndex++;
            state.locationMarker.closePopup();
            loadNextLocation();
        });
    }
}

function showNavigationModal(lat, lng) {
    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.innerHTML = `
        <div class="modal-content">
            <h3>Choose your navigation app:</h3>
            <div class="modal-buttons">
                <button class="modal-button google-maps">Google Maps</button>
                <button class="modal-button waze">Waze</button>
                <button class="modal-button apple-maps">Apple Maps</button>
                <button class="modal-button cancel">Cancel</button>
            </div>
        </div>
    `;
    
    addModalStyles();
    document.body.appendChild(modal);
    
    modal.querySelector('.google-maps').addEventListener('click', () => {
        window.location.href = `https://www.google.com/maps/dir/?api=1&destination=${lat},${lng}`;
        modal.remove();
    });
    
    modal.querySelector('.waze').addEventListener('click', () => {
        window.location.href = `https://www.waze.com/ul?ll=${lat}%2C${lng}&navigate=yes`;
        modal.remove();
    });
    
    modal.querySelector('.apple-maps').addEventListener('click', () => {
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
        if (isIOS) {
            window.location.href = `maps://maps.apple.com/?daddr=${lat},${lng}`;
            modal.remove();
        } else {
            showPopup('Apple Maps is only available on iOS devices');
        }
    });
    
    modal.querySelector('.cancel').addEventListener('click', () => modal.remove());
    modal.addEventListener('click', (e) => {
        if (e.target === modal) modal.remove();
    });
}

function addModalStyles() {
    if (document.querySelector('#modal-styles')) return;
    
    const style = document.createElement('style');
    style.id = 'modal-styles';
    style.textContent = `
        .modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.75); display: flex; justify-content: center; align-items: center; z-index: 2000; padding: 16px; backdrop-filter: blur(4px); }
        .modal-content { background: white; padding: 24px 16px; border-radius: 16px; width: 100%; max-width: 320px; text-align: center; box-shadow: 0 20px 40px rgba(0,0,0,0.2); }
        .modal-buttons { margin-top: 20px; display: flex; flex-direction: column; gap: 12px; align-items: center; }
        .modal-button { padding: 16px; border-radius: 12px; width: 100%; display: flex; align-items: center; justify-content: center; font-size: 16px; font-weight: 500; border: none; cursor: pointer; transition: transform 0.15s ease; }
        .modal-button:active { transform: scale(0.98); }
        .google-maps { background: #4285F4; color: white; }
        .waze { background: #33ccff; color: white; }
        .apple-maps { background: #000000; color: white; }
        .cancel { background: #f2f2f2; color: #666; }
    `;
    document.head.appendChild(style);
}

function updateDistanceBox() {
    if (!state.userMarker || !state.locationMarker || !state.currentPosition) return;
    
    const userLatLng = state.userMarker.getLatLng();
    const locationLatLng = state.locationMarker.getLatLng();
    
    if (userLatLng.lat === 0 && userLatLng.lng === 0) return;
    
    const distance = calculateDistance(
        { lat: userLatLng.lat, lng: userLatLng.lng },
        { lat: locationLatLng.lat, lng: locationLatLng.lng }
    );
    
    const distanceFeet = Math.round(distance * 3.28084);
    const distanceText = distanceFeet < 5280 
        ? `${distanceFeet} feet` 
        : `${(distanceFeet / 5280).toFixed(2)} miles`;
    
    document.getElementById('distanceBox').innerText = `Next Stop: ${distanceText}`;
    
    if (distanceFeet <= CONFIG.DISTANCE_THRESHOLD && !state.isLocationHuntVisible) {
        showLocationHunt();
    }
}

function toggleAllLocations(show) {
    // Remove existing markers
    state.allLocationMarkers.forEach(marker => {
        if (marker) state.map.removeLayer(marker);
    });
    state.allLocationMarkers = [];
    
    if (show) {
        state.gameLocations.forEach((location, index) => {
            if (index !== state.currentLocationIndex) {
                const marker = L.marker([location.lat, location.lng], {
                    icon: L.divIcon({
                        className: 'custom-pin-icon inactive-pin',
                        html: `<div class="pin-head" data-id="${location.id}" style="opacity: 0.4;"></div>`,
                        iconSize: [30, 30],
                        iconAnchor: [15, 30]
                    })
                }).addTo(state.map);
                state.allLocationMarkers.push(marker);
            }
        });
    }
}

// ============================================================================
// LOCATION HUNT UI
// ============================================================================
function showLocationHunt() {
    state.isLocationHuntVisible = true;
    const location = state.gameLocations[state.currentLocationIndex];
    const container = document.querySelector('.lochunt-container');
    
    container.innerHTML = '';
    container.style.cssText = 'display: flex; flex-direction: column; height: 100%; overflow: hidden;';
    
    const scrollableContent = document.createElement('div');
    scrollableContent.style.cssText = 'flex: 1; overflow-y: auto; -webkit-overflow-scrolling: touch;';
    
    // Location image
    const locationImage = document.createElement('img');
    locationImage.src = location.image;
    locationImage.alt = location.name;
    locationImage.style.cssText = 'width: 100%; height: 40vh; object-fit: cover; object-position: center;';
    scrollableContent.appendChild(locationImage);
    
    // Content container
    const contentContainer = document.createElement('div');
    contentContainer.classList.add('lochunt-content');
    contentContainer.style.cssText = 'padding: 20px; display: flex; flex-direction: column; align-items: center;';
    
    // Location info
    const locationInfo = document.createElement('div');
    locationInfo.classList.add('lochunt-info');
    locationInfo.style.cssText = 'text-align: center; margin-bottom: 15px;';
    
    const locationName = document.createElement('h1');
    locationName.textContent = location.name;
    locationName.style.cssText = 'font-size: calc(1.5rem + 1.5vw); font-weight: bold; color: #333;';
    
    const locationCity = document.createElement('p');
    locationCity.textContent = location.city;
    locationCity.style.cssText = 'font-size: calc(1rem + 0.5vw); color: #00008B; font-weight: bold; margin-bottom: 0px;';
    
    const locationCreator = document.createElement('p');
    locationCreator.textContent = `Created by: ${location.creator}`;
    locationCreator.style.cssText = 'font-size: calc(0.9rem + 0.4vw); color: #666;';
    
    locationInfo.appendChild(locationName);
    locationInfo.appendChild(locationCity);
    locationInfo.appendChild(locationCreator);
    contentContainer.appendChild(locationInfo);
    
    // Audio player
    const audioPlayer = createAudioPlayer(location.audio);
    contentContainer.appendChild(audioPlayer);
    
    scrollableContent.appendChild(contentContainer);
    
    // Trivia container
    const triviaContainer = createTriviaContainer();
    scrollableContent.appendChild(triviaContainer);
    
    container.appendChild(scrollableContent);
    
    // Bottom bar
    const blueBar = createBottomBar(location);
    blueBar.style.cssText += 'position: sticky; bottom: 0; width: 100%;';
    container.appendChild(blueBar);
    
    initAudioPlayer();
}

function createAudioPlayer(audioSrc) {
    const container = document.createElement('div');
    container.classList.add('audio-player');
    container.style.cssText = 'width: 100%; max-width: 400px; margin-bottom: 15px;';
    
    const audio = document.createElement('audio');
    audio.id = 'locationAudio';
    audio.src = audioSrc;
    
    const progressContainer = document.createElement('div');
    progressContainer.classList.add('audio-progress');
    progressContainer.style.cssText = 'width: 100%; margin-bottom: 15px;';
    
    const progress = document.createElement('div');
    progress.classList.add('progress');
    progress.style.cssText = 'height: 6px; background-color: #d1d1d1; cursor: pointer;';
    
    const progressBar = document.createElement('div');
    progressBar.id = 'progressBar';
    progressBar.classList.add('progress-bar');
    progressBar.style.cssText = 'background-color: var(--primary-color); width: 0%;';
    
    progress.appendChild(progressBar);
    progressContainer.appendChild(progress);
    
    const timeInfo = document.createElement('div');
    timeInfo.classList.add('audio-time');
    timeInfo.style.cssText = 'display: flex; justify-content: space-between; font-size: 16px; color: #666; margin-bottom: 10px;';
    
    const currentTime = document.createElement('span');
    currentTime.id = 'currentTime';
    currentTime.textContent = '0:00';
    
    const duration = document.createElement('span');
    duration.id = 'duration';
    duration.textContent = '0:00';
    
    timeInfo.appendChild(currentTime);
    timeInfo.appendChild(duration);
    
    const controls = document.createElement('div');
    controls.classList.add('audio-controls');
    controls.style.cssText = 'display: flex; justify-content: space-between; align-items: center; font-size: 24px;';
    
    controls.appendChild(createAudioButton('skip-backward', 'rewindBtn'));
    controls.appendChild(createAudioButton('play', 'playPauseBtn'));
    controls.appendChild(createAudioButton('skip-forward', 'forwardBtn'));
    
    container.appendChild(audio);
    container.appendChild(progressContainer);
    container.appendChild(timeInfo);
    container.appendChild(controls);
    
    return container;
}

function createAudioButton(iconName, id) {
    const button = document.createElement('button');
    button.id = id;
    button.classList.add('audio-button');
    button.innerHTML = `<i class="bi bi-${iconName}"></i>`;
    button.style.cssText = `
        background-color: white;
        color: var(--primary-color);
        border: 2px solid var(--primary-color);
        border-radius: 50%;
        width: 55px;
        height: 55px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.3s ease;
    `;
    
    button.addEventListener('mouseover', () => button.style.backgroundColor = 'var(--hover-color)');
    button.addEventListener('mouseout', () => button.style.backgroundColor = 'white');
    button.addEventListener('click', () => {
        button.style.backgroundColor = 'var(--primary-color)';
        button.style.color = 'white';
        button.style.transform = 'scale(0.95)';
        setTimeout(() => {
            button.style.backgroundColor = 'white';
            button.style.color = 'var(--primary-color)';
            button.style.transform = 'scale(1)';
        }, 200);
    });
    
    return button;
}

function createTriviaContainer() {
    const container = document.createElement('div');
    container.classList.add('trivia-container');
    container.style.cssText = `
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: white;
        padding: 30px;
        border-radius: 12px;
        box-shadow: 0 4px 15px var(--shadow-color);
        border: 2px solid var(--primary-color);
        width: 90%;
        max-width: 600px;
        z-index: 2001;
        font-size: 22px;
    `;
    container.innerHTML = `
        <h2 class="card-title text-center mb-4" id="triviaQuestion"></h2>
        <div id="triviaOptions" class="d-grid gap-2"></div>
    `;
    return container;
}

function createBottomBar(location) {
    const bar = document.createElement('div');
    bar.style.cssText = `
        width: 100%;
        height: 55px;
        background-color: #005f9e;
        margin-top: auto;
        box-shadow: 0 -2px 5px rgba(0,0,0,0.025);
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0 10px;
    `;
    
    const infoButton = document.createElement('button');
    infoButton.innerHTML = '<i class="bi bi-info-circle-fill text-white" style="font-size: 1.5rem;"></i>';
    infoButton.classList.add('btn', 'btn-sm', 'me-2');
    infoButton.onclick = () => {
        const source = location?.imageSource || 'Image source information is not available';
        showPopup('Image source: ' + source);
    };
    
    const feedbackButton = document.createElement('a');
    feedbackButton.href = 'mailto:mattreicher@protonmail.com?subject=Feedback';
    feedbackButton.target = '_blank';
    feedbackButton.rel = 'noopener noreferrer';
    feedbackButton.innerHTML = '<i class="bi bi-envelope-fill text-white" style="font-size: 1.5rem;"></i>';
    feedbackButton.classList.add('btn', 'btn-sm');
    
    bar.appendChild(infoButton);
    bar.appendChild(feedbackButton);
    
    return bar;
}

function initAudioPlayer() {
    const audio = document.getElementById('locationAudio');
    const playPauseBtn = document.getElementById('playPauseBtn');
    const rewindBtn = document.getElementById('rewindBtn');
    const forwardBtn = document.getElementById('forwardBtn');
    const progressBar = document.getElementById('progressBar');
    const progressContainer = document.querySelector('.progress');
    const currentTimeSpan = document.getElementById('currentTime');
    const durationSpan = document.getElementById('duration');
    
    function formatTime(time) {
        const minutes = Math.floor(time / 60);
        const seconds = Math.floor(time % 60);
        return `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }
    
    playPauseBtn.addEventListener('click', () => {
        if (audio.paused) {
            audio.play();
            playPauseBtn.innerHTML = '<i class="bi bi-pause"></i>';
        } else {
            audio.pause();
            playPauseBtn.innerHTML = '<i class="bi bi-play"></i>';
        }
    });
    
    rewindBtn.addEventListener('click', () => {
        audio.currentTime = Math.max(0, audio.currentTime - 10);
    });
    
    forwardBtn.addEventListener('click', () => {
        audio.currentTime = Math.min(audio.duration, audio.currentTime + 10);
    });
    
    audio.addEventListener('timeupdate', () => {
        const percent = (audio.currentTime / audio.duration) * 100;
        progressBar.style.width = `${percent}%`;
        currentTimeSpan.textContent = formatTime(audio.currentTime);
    });
    
    audio.addEventListener('loadedmetadata', () => {
        durationSpan.textContent = formatTime(audio.duration);
    });
    
    audio.addEventListener('ended', () => {
        playPauseBtn.innerHTML = '<i class="bi bi-play"></i>';
        showTriviaQuestion();
    });
    
    progressContainer.addEventListener('click', (e) => {
        const width = progressContainer.clientWidth;
        const clickX = e.offsetX;
        audio.currentTime = (clickX / width) * audio.duration;
    });
}

// ============================================================================
// TRIVIA
// ============================================================================
function showTriviaQuestion() {
    const location = state.gameLocations[state.currentLocationIndex];
    const container = document.querySelector('.trivia-container');
    
    container.style.display = 'block';
    document.getElementById('triviaQuestion').textContent = location.trivia.question;
    
    const optionsContainer = document.getElementById('triviaOptions');
    optionsContainer.innerHTML = '';
    
    location.trivia.options.forEach((option, index) => {
        const button = document.createElement('button');
        button.textContent = option;
        button.classList.add('btn', 'mb-3');
        button.style.cssText = `
            font-size: 1.3rem;
            color: #000000;
            background-color: white;
            border: 2px solid #00008b;
            border-radius: 8px;
            padding: 12px 20px;
            width: 100%;
            transition: all 0.3s ease;
        `;
        
        button.onmouseover = () => {
            button.style.backgroundColor = '#00008b';
            button.style.color = 'white';
        };
        button.onmouseout = () => {
            button.style.backgroundColor = 'white';
            button.style.color = '#00008b';
        };
        button.onclick = () => checkAnswer(index);
        
        optionsContainer.appendChild(button);
    });
}

function checkAnswer(selectedIndex) {
    const location = state.gameLocations[state.currentLocationIndex];
    const isFinal = state.currentLocationIndex === state.gameLocations.length - 1;
    
    if (selectedIndex === location.trivia.answer) {
        state.visitedLocations.push(state.currentLocationIndex);
        
        if (isFinal) {
            showCongratulations();
        } else {
            showPopup('Correct! Moving to the next location.', 'success', () => {
                state.currentLocationIndex++;
                document.querySelector('.lochunt-container').style.display = 'none';
                document.querySelector('.trivia-container').style.display = 'none';
                state.isLocationHuntVisible = false;
                loadNextLocation();
            });
        }
    } else {
        showPopup('Incorrect. Please try again.', 'danger');
    }
}

// ============================================================================
// UI UTILITIES
// ============================================================================
function showPopup(content, type = 'info', callback) {
    const popup = document.createElement('div');
    popup.classList.add('popup', `popup-${type}`);
    
    const styles = `
        .popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #ffffff;
            padding: clamp(1.5rem, 5vw, 3rem);
            border-radius: 1rem;
            box-shadow: 0 0.5rem 2rem rgba(0, 0, 0, 0.1);
            z-index: 10000;
            width: clamp(280px, 90%, 500px);
            text-align: center;
            font-family: 'Arial', sans-serif;
            color: #333333;
            animation: fadeIn 0.3s ease-out;
        }
        .popup-content {
            font-size: clamp(1.125rem, 3vw, 1.35rem);
            line-height: 1.5;
            margin-bottom: 1.5rem;
        }
        .popup-button {
            font-size: clamp(1rem, 2.5vw, 1.125rem);
            padding: 0.875em 1.75em;
            min-width: clamp(140px, 50%, 200px);
            border: none;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.1s;
        }
        .popup-button:hover { transform: translateY(-2px); }
        .popup-button:active { transform: translateY(0); }
        .popup-info .popup-button { background-color: #007bff; color: white; }
        .popup-success .popup-button { background-color: #28a745; color: white; }
        .popup-warning .popup-button { background-color: #ffc107; color: #212529; }
        .popup-danger .popup-button { background-color: #dc3545; color: white; }
        @keyframes fadeIn {
            from { opacity: 0; transform: translate(-50%, -48%); }
            to { opacity: 1; transform: translate(-50%, -50%); }
        }
        @keyframes fadeOut {
            from { opacity: 1; transform: translate(-50%, -50%); }
            to { opacity: 0; transform: translate(-50%, -52%); }
        }
    `;
    
    const styleElement = document.createElement('style');
    styleElement.textContent = styles;
    document.head.appendChild(styleElement);
    
    popup.innerHTML = `<div class="popup-content">${content}</div>`;
    document.body.appendChild(popup);
    
    const continueButton = popup.querySelector('#continueButton') || (() => {
        const button = document.createElement('button');
        button.classList.add('popup-button');
        button.textContent = 'OK';
        popup.appendChild(button);
        return button;
    })();
    
    continueButton.addEventListener('click', () => {
        popup.style.animation = 'fadeOut 0.3s ease-in forwards';
        setTimeout(() => {
            document.body.removeChild(popup);
            document.head.removeChild(styleElement);
            if (callback) callback();
        }, 300);
    });
}

function showCongratulations() {
    const content = `
        <div class="congrats-container">
            <h2>Congratulations!</h2>
            <p>You've completed the entire tour. Well done!</p>
            <button id="continueButton" class="btn btn-primary">Start Over</button>
        </div>
    `;
    
    showPopup(content, 'success');
    
    const continueButton = document.getElementById('continueButton');
    if (continueButton) {
        continueButton.addEventListener('click', () => {
            continueButton.textContent = 'Returning to homepage...';
            continueButton.disabled = true;
            setTimeout(endTour, 1000);
        });
    }
}

function endTour() {
    state.currentLocationIndex = 0;
    state.visitedLocations = [];
    
    const popup = document.querySelector('.popup');
    if (popup) popup.remove();
    
    localStorage.removeItem('currentStopIndex');
    localStorage.removeItem('tourProgress');
    window.location.href = 'https://www.mnthen.com/index.html';
}

function resetInactivityTimer() {
    clearTimeout(state.inactivityTimer);
    state.inactivityTimer = setTimeout(() => {
        if (state.userMarker && state.currentPosition) {
            state.map.closePopup();
            state.map.setView([state.currentPosition.lat, state.currentPosition.lng], state.map.getZoom(), {
                animate: true,
                duration: 0.5
            });
            state.followUser = true;
        }
    }, CONFIG.INACTIVITY_TIMEOUT);
}

function recenterMap() {
    const button = document.getElementById('recenterButton');
    button.style.backgroundColor = '#005f9e';
    button.style.color = 'white';
    
    if (state.currentPosition) {
        state.map.setView([state.currentPosition.lat, state.currentPosition.lng], state.map.getZoom(), {
            animate: true,
            duration: 0.3
        });
        state.followUser = true;
        state.isUserInteracting = false;
    }
    
    setTimeout(() => {
        button.style.backgroundColor = 'white';
        button.style.color = '#005f9e';
    }, 500);
}

function returnToIndex() {
    showPopup("End the tour and return to the main page?", 'info', () => {
        window.location.href = "/index.html";
    });
}

function toggleNavigationTips() {
    const tips = document.querySelector('.navigation-tips');
    const isHidden = window.getComputedStyle(tips).display === 'none';
    tips.style.display = isHidden ? 'block' : 'none';
    document.getElementById('tipsButton').classList.toggle('active', isHidden);
}

function closeNavigationTips() {
    document.querySelector('.navigation-tips').style.display = 'none';
    document.getElementById('tipsButton').classList.remove('active');
}

// ============================================================================
// EVENT LISTENERS
// ============================================================================
document.addEventListener('DOMContentLoaded', function() {
    initMap();
    
    // Button handlers
    document.getElementById('recenterButton').addEventListener('click', () => {
        recenterMap();
        resetInactivityTimer();
    });
    
    document.getElementById('returnButton').addEventListener('click', () => {
        returnToIndex();
        resetInactivityTimer();
    });
    
    document.getElementById('tipsButton').addEventListener('click', () => {
        toggleNavigationTips();
        resetInactivityTimer();
    });
    
    document.getElementById('showAllLocations').addEventListener('change', function(e) {
        state.showingAllLocations = e.target.checked;
        toggleAllLocations(state.showingAllLocations);
        resetInactivityTimer();
    });
    
    document.querySelector('.navigation-tips .close-button').addEventListener('click', () => {
        closeNavigationTips();
        resetInactivityTimer();
    });
});
    </script>
</body>
</html>
