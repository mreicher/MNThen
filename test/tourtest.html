<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, viewport-fit=cover">
    <title>Minnesota Then | Self-Guided Tours</title>
    <link rel="shortcut icon" type="image/x-icon" href="https://www.mnthen.com/images/mnthenfav.ico">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    
 <style>
 /* Base styles */
 :root {
 --primary-color: #2c5282;
 --primary-light: #3182ce;
 --primary-dark: #1a365d;
 --secondary-color: #e53e3e;
 --secondary-light: #fc8181;
 --secondary-dark: #c53030;
 --accent-color: #38a169;
 --accent-light: #68d391;
 --accent-dark: #276749;
 --text-color: #2d3748;
 --text-light: #4a5568;
 --text-lighter: #718096;
 --bg-color: #ffffff;
 --bg-light: #f7fafc;
 --bg-dark: #edf2f7;
 --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
 --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
 --shadow-md: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
 --shadow-lg: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
 --radius-sm: 0.125rem;
 --radius: 0.25rem;
 --radius-md: 0.375rem;
 --radius-lg: 0.5rem;
 --radius-xl: 1rem;
 --radius-2xl: 1.5rem;
 --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
 --transition-fast: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
 --transition-slow: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
 --font-sans: 'Segoe UI', -apple-system, BlinkMacSystemFont, 'Helvetica Neue', Arial, sans-serif;
 }

 * {
 margin: 0;
 padding: 0;
 box-sizing: border-box;
 }
 
 body {
 margin: 0;
 padding: 0;
 font-family: var(--font-sans);
 overflow: hidden;
 height: 100vh;
 width: 100vw;
 position: relative;
 color: var(--text-color);
 background-color: var(--bg-color);
 -webkit-font-smoothing: antialiased;
 -moz-osx-font-smoothing: grayscale;
 touch-action: manipulation;
 }
 
 #map {
 height: 100vh;
 width: 100%;
 z-index: 1;
 }
 
 /* Enhanced Distance box */
 #distanceBox {
 position: absolute;
 top: 16px;
 left: 16px;
 background-color: rgba(255, 255, 255, 0.98);
 padding: 16px 20px;
 border-radius: var(--radius-lg);
 box-shadow: var(--shadow-md);
 z-index: 1000;
 font-size: 20px;
 font-weight: 600;
 color: var(--text-color);
 min-width: 200px;
 max-width: 320px;
 transition: var(--transition);
 border-left: 6px solid var(--primary-color);
 display: flex;
 align-items: center;
 backdrop-filter: blur(5px);
 transform: translateZ(0);
 will-change: transform, opacity;
 }

 #distanceBox .location-icon {
 margin-right: 15px;
 color: var(--primary-color);
 font-size: 24px;
 }

 #distanceBox .distance-info {
 display: flex;
 flex-direction: column;
 font-size: 20px;
 }

 #distanceBox .location-name {
 font-weight: 700;
 margin-bottom: 4px;
 color: var(--primary-color);
 font-size: 20px;
 }

 #distanceBox .distance-value {
 font-size: 16px;
 color: var(--text-light);
 font-weight: 500;
 }

 /* Location hunt container */
 .lochunt-container {
 position: fixed;
 bottom: 0;
 left: 0;
 width: 100%;
 height: 80%;
 background-color: var(--bg-color);
 z-index: 1500;
 border-radius: var(--radius-2xl) var(--radius-2xl) 0 0;
 box-shadow: var(--shadow-lg);
 transform: translateY(100%);
 transition: transform 0.5s cubic-bezier(0.16, 1, 0.3, 1);
 overflow: hidden;
 display: none;
 will-change: transform;
 }
 
 .lochunt-container.active {
 transform: translateY(0);
 display: block;
 }
 
 .lochunt-content {
 padding: 24px;
 overflow-y: auto;
 height: calc(100% - 200px);
 -webkit-overflow-scrolling: touch;
 }
 
 #locationImage {
 width: 100%;
 height: 200px;
 object-fit: cover;
 object-position: center;
 will-change: transform;
 transform: translateZ(0);
 }
 
 .lochunt-info {
 margin-bottom: 24px;
 }
 
 .lochunt-info h2 {
 color: var(--primary-color);
 margin-bottom: 8px;
 font-weight: 700;
 }
 
 .lochunt-info p {
 line-height: 1.6;
 margin-bottom: 16px;
 }
 
 .text-muted {
 color: var(--text-lighter);
 font-size: 14px;
 }
 
 /* Audio player */
 .audio-player {
 margin-top: 24px;
 padding: 20px;
 background-color: var(--bg-light);
 border-radius: var(--radius-lg);
 box-shadow: var(--shadow-sm);
 }
 
 .audio-progress {
 margin-bottom: 12px;
 }
 
 .progress {
 height: 6px;
 background-color: var(--bg-dark);
 border-radius: var(--radius-xl);
 overflow: hidden;
 }
 
 .progress-bar {
 background-color: var(--primary-color);
 height: 100%;
 border-radius: var(--radius-xl);
 transition: width 0.1s linear;
 will-change: width;
 }
 
 .audio-time {
 display: flex;
 justify-content: space-between;
 font-size: 12px;
 color: var(--text-lighter);
 margin-bottom: 12px;
 }
 
 .audio-controls {
 display: flex;
 justify-content: space-between;
 align-items: center;
 max-width: 200px;
 margin: 0 auto;
 }
 
 .audio-button {
 background-color: var(--bg-color);
 border: 2px solid var(--primary-color);
 color: var(--primary-color);
 width: 44px;
 height: 44px;
 border-radius: 50%;
 display: flex;
 align-items: center;
 justify-content: center;
 cursor: pointer;
 transition: var(--transition-fast);
 -webkit-tap-highlight-color: transparent;
 will-change: transform, background-color, color;
 }
 
 .audio-button:hover, .audio-button:active {
 background-color: var(--primary-color);
 color: var(--bg-color);
 transform: translateY(-2px);
 }
 
 /* Trivia container */
 .trivia-container {
 position: fixed;
 bottom: 0;
 left: 0;
 width: 100%;
 background-color: var(--bg-color);
 z-index: 1500;
 border-radius: var(--radius-2xl) var(--radius-2xl) 0 0;
 box-shadow: var(--shadow-lg);
 padding: 24px;
 transform: translateY(100%);
 transition: transform 0.5s cubic-bezier(0.16, 1, 0.3, 1);
 display: none;
 will-change: transform;
 }
 
 .trivia-container.active {
 transform: translateY(0);
 display: block;
 }
 
 .trivia-container h3 {
 color: var(--primary-color);
 margin-bottom: 16px;
 font-weight: 700;
 }
 
 .trivia-option {
 background-color: var(--bg-light);
 border: 2px solid var(--bg-dark);
 border-radius: var(--radius-lg);
 padding: 16px;
 margin-bottom: 12px;
 cursor: pointer;
 transition: var(--transition-fast);
 font-weight: 500;
 text-align: left;
 width: 100%;
 color: var(--text-color);
 will-change: transform, background-color;
 }
 
 .trivia-option:hover, .trivia-option:active {
 background-color: var(--bg-dark);
 transform: translateY(-2px);
 }
 
 .trivia-option.correct {
 background-color: var(--accent-light);
 border-color: var(--accent-color);
 color: var(--accent-dark);
 }
 
 .trivia-option.incorrect {
 background-color: var(--secondary-light);
 border-color: var(--secondary-color);
 color: var(--secondary-dark);
 }
 
 /* Map buttons: horizontal and centered at bottom */
 .map-buttons {
 position: fixed; 
 bottom: 40px; 
 left: 50%;
 transform: translateX(-50%);
 display: flex;
 flex-direction: row;
 gap: 16px;
 z-index: 1000;
 background-color: rgba(255, 255, 255, 0.9);
 padding: 12px 16px;
 border-radius: var(--radius-xl);
 box-shadow: var(--shadow-md);
 backdrop-filter: blur(5px);
 width: auto; /* Ensure width is based on content */
 max-width: 90%; /* Prevent overflow on very small screens */
 will-change: transform;
 }
 
 .map-button {
 width: 50px;
 height: 50px;
 border-radius: 50%;
 background-color: var(--bg-color);
 border: none;
 box-shadow: var(--shadow);
 display: flex;
 align-items: center;
 justify-content: center;
 font-size: 22px;
 color: var(--primary-color);
 cursor: pointer;
 transition: var(--transition-fast);
 -webkit-tap-highlight-color: transparent;
 will-change: transform, background-color, color;
 }
 
 .map-button:hover, .map-button:active {
 background-color: var(--primary-color);
 color: var(--bg-color);
 transform: scale(1.05);
 box-shadow: var(--shadow-md);
 }
 
 .map-button.active {
 background-color: var(--primary-color);
 color: var(--bg-color);
 }
 
 /* Navigation tips */
 .navigation-tips {
 position: fixed;
 top: 50%;
 left: 50%;
 transform: translate(-50%, -50%);
 background-color: var(--bg-color);
 border-radius: var(--radius-lg);
 box-shadow: var(--shadow-lg);
 padding: 24px;
 z-index: 2000;
 max-width: 90%;
 width: 350px;
 display: none;
 }
 
 .navigation-tips h3 {
 margin-bottom: 16px;
 color: var(--primary-color);
 font-weight: 700;
 }
 
 .navigation-tips ul {
 padding-left: 20px;
 }
 
 .navigation-tips li {
 margin-bottom: 12px;
 line-height: 1.5;
 }
 
 .close-button {
 position: absolute;
 top: 12px;
 right: 12px;
 background: none;
 border: none;
 font-size: 20px;
 cursor: pointer;
 color: var(--text-lighter);
 transition: var(--transition-fast);
 -webkit-tap-highlight-color: transparent;
 }
 
 .close-button:hover, .close-button:active {
 color: var(--text-color);
 }
 
 /* Congratulations */
 #congratulations {
 position: fixed;
 top: 0;
 left: 0;
 width: 100%;
 height: 100%;
 background-color: rgba(0, 0, 0, 0.85);
 display: flex;
 flex-direction: column;
 align-items: center;
 justify-content: center;
 z-index: 3000;
 color: var(--bg-color);
 text-align: center;
 padding: 24px;
 display: none;
 backdrop-filter: blur(5px);
 }
 
 #congratulations h2 {
 font-size: 36px;
 margin-bottom: 24px;
 font-weight: 800;
 }
 
 #congratulations p {
 font-size: 18px;
 margin-bottom: 32px;
 max-width: 600px;
 line-height: 1.6;
 }
 
 #congratulations button {
 background-color: var(--primary-color);
 color: var(--bg-color);
 border: none;
 padding: 16px 32px;
 border-radius: var(--radius-xl);
 font-size: 18px;
 font-weight: 600;
 cursor: pointer;
 transition: var(--transition);
 box-shadow: var(--shadow);
 will-change: transform, background-color;
 }
 
 #congratulations button:hover, #congratulations button:active {
 background-color: var(--primary-dark);
 transform: translateY(-3px);
 box-shadow: var(--shadow-md);
 }
 
 /* Enhanced user marker styles */
 .user-marker-icon {
 width: 24px;
 height: 24px;
 background-color: var(--secondary-color);
 border: 3px solid white;
 border-radius: 50%;
 box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
 position: relative;
 transition: all 0.2s cubic-bezier(0.25, 0.1, 0.25, 1);
 will-change: transform;
 transform-origin: center center;
 }
 
 .user-marker-icon::after {
 content: '';
 position: absolute;
 top: 50%;
 left: 50%;
 width: 36px;
 height: 36px;
 background-color: rgba(229, 62, 62, 0.2);
 border-radius: 50%;
 transform: translate(-50%, -50%);
 animation: pulse 2s infinite;
 will-change: transform, opacity;
 }
 
 @keyframes pulse {
 0% {
 transform: translate(-50%, -50%) scale(1);
 opacity: 1;
 }
 100% {
 transform: translate(-50%, -50%) scale(2);
 opacity: 0;
 }
 }
 
 /* Stationary indicator */
 .user-marker-stationary .user-marker-icon {
 border-color: var(--accent-color);
 transition: border-color 0.5s ease-out;
 }
 
 .user-marker-stationary .user-marker-icon::after {
 background-color: rgba(56, 161, 105, 0.15);
 animation: stationaryPulse 3s infinite;
 }
 
 @keyframes stationaryPulse {
 0% {
 transform: translate(-50%, -50%) scale(1);
 opacity: 0.6;
 }
 50% {
 transform: translate(-50%, -50%) scale(1.3);
 opacity: 0.3;
 }
 100% {
 transform: translate(-50%, -50%) scale(1);
 opacity: 0.6;
 }
 }
 
 /* Optimize for hardware acceleration */
 #map, .user-marker-icon, .lochunt-container, .trivia-container {
 transform: translateZ(0);
 backface-visibility: hidden;
 perspective: 1000px;
 }
 
 /* Stabilizing modal */
 .stabilizing-modal {
 position: fixed;
 top: 50%;
 left: 50%;
 transform: translate(-50%, -50%);
 background-color: var(--bg-color);
 padding: 24px;
 border-radius: var(--radius-lg);
 box-shadow: var(--shadow-lg);
 z-index: 2000;
 text-align: center;
 max-width: 80%;
 display: flex;
 flex-direction: column;
 align-items: center;
 }
 
 .stabilizing-modal h3 {
 margin-bottom: 16px;
 color: var(--primary-color);
 font-weight: 700;
 }
 
 .stabilizing-modal p {
 margin-bottom: 20px;
 line-height: 1.5;
 }
 
 .stabilizing-modal .spinner {
 width: 48px;
 height: 48px;
 border: 4px solid rgba(44, 82, 130, 0.2);
 border-top: 4px solid var(--primary-color);
 border-radius: 50%;
 margin-bottom: 24px;
 animation: spin 1s linear infinite;
 will-change: transform;
 }
 
 @keyframes spin {
 0% { transform: rotate(0deg); }
 100% { transform: rotate(360deg); }
 }
 
 /* Preloader styles */
 #preloader {
 position: fixed;
 top: 0;
 left: 0;
 width: 100%;
 height: 100%;
 background-color: var(--bg-color);
 display: flex;
 flex-direction: column;
 justify-content: center;
 align-items: center;
 z-index: 9999;
 }

 #preloader .spinner {
 width: 60px;
 height: 60px;
 border: 5px solid rgba(44, 82, 130, 0.2);
 border-top: 5px solid var(--primary-color);
 border-radius: 50%;
 margin-bottom: 24px;
 animation: spin 1s linear infinite;
 will-change: transform;
 }

 #preloader p {
 font-size: 18px;
 color: var(--text-color);
 margin-top: 16px;
 font-weight: 500;
 }

 #preloader .progress-container {
 width: 80%;
 max-width: 300px;
 height: 8px;
 background-color: var(--bg-dark);
 border-radius: var(--radius-xl);
 margin-top: 20px;
 overflow: hidden;
 }

 #preloader .progress-bar {
 height: 100%;
 background-color: var(--primary-color);
 width: 0%;
 transition: width 0.3s ease;
 border-radius: var(--radius-xl);
 will-change: width;
 }
 
 /* Popup styles */
 #popup {
 position: fixed;
 top: 0;
 left: 0;
 width: 100%;
 height: 100%;
 background-color: rgba(0, 0, 0, 0.5);
 display: flex;
 align-items: center;
 justify-content: center;
 z-index: 3000;
 display: none;
 backdrop-filter: blur(3px);
 }
 
 .popup-content {
 background-color: var(--bg-color);
 border-radius: var(--radius-lg);
 padding: 24px;
 max-width: 90%;
 width: 350px;
 text-align: center;
 box-shadow: var(--shadow-lg);
 }
 
 #popupMessage {
 margin-bottom: 24px;
 line-height: 1.5;
 }
 
 .popup-button {
 background-color: var(--primary-color);
 color: var(--bg-color);
 border: none;
 padding: 12px 24px;
 border-radius: var(--radius-lg);
 font-weight: 600;
 cursor: pointer;
 transition: var(--transition);
 will-change: transform, background-color;
 }
 
 .popup-button:hover, .popup-button:active {
 background-color: var(--primary-dark);
 transform: translateY(-2px);
 }
 
 /* Enhanced Location marker styles with numbering */
 .location-marker-icon {
 width: 40px;
 height: 40px;
 background-color: #006400;
 border: 3px solid white;
 border-radius: 50%;
 box-shadow: var(--shadow);
 position: relative;
 transition: var(--transition);
 display: flex;
 align-items: center;
 justify-content: center;
 color: white;
 font-weight: bold;
 font-size: 16px;
 will-change: transform;
 }
 
 .location-marker-icon:hover {
 transform: scale(1.1);
 background-color: var(--primary-dark);
 }
 
 /* Enhanced Marker popup styles */
 .marker-popup {
 max-width: 300px;
 padding: 0;
 }
 
 .marker-popup-image {
 width: 100%;
 height: 150px;
 object-fit: cover;
 border-radius: var(--radius-lg) var(--radius-lg) 0 0;
 margin-bottom: 0;
 }
 
 .marker-popup-content {
 padding: 16px;
 }
 
 .marker-popup-title {
 font-size: 18px;
 font-weight: bold;
 margin-bottom: 8px;
 color: var(--primary-color);
 }
 
 .marker-popup-description {
 font-size: 14px;
 margin-bottom: 16px;
 color: var(--text-light);
 line-height: 1.5;
 }
 
 .marker-popup-actions {
 display: flex;
 justify-content: space-between;
 gap: 12px;
 }
 
 .popup-btn {
 padding: 10px 16px;
 border-radius: var(--radius);
 font-size: 14px;
 font-weight: 600;
 cursor: pointer;
 text-align: center;
 transition: var(--transition-fast);
 display: flex;
 align-items: center;
 justify-content: center;
 gap: 8px;
 flex: 1;
 will-change: transform, background-color;
 }
 
 .popup-btn.directions {
 background-color: var(--primary-color);
 color: white;
 border: none;
 }
 
 .popup-btn.directions:hover, .popup-btn.directions:active {
 background-color: var(--primary-dark);
 transform: translateY(-2px);
 }
 
 .popup-btn.skip {
 background-color: var(--bg-light);
 color: var(--text-light);
 border: 1px solid var(--bg-dark);
 }
 
 .popup-btn.skip:hover, .popup-btn.skip:active {
 background-color: var(--bg-dark);
 transform: translateY(-2px);
 }
 
 /* Directions modal */
 #directionsModal {
 position: fixed;
 top: 0;
 left: 0;
 width: 100%;
 height: 100%;
 background-color: rgba(0, 0, 0, 0.5);
 display: flex;
 align-items: center;
 justify-content: center;
 z-index: 3000;
 display: none;
 backdrop-filter: blur(3px);
 }
 
 .directions-modal-content {
 background-color: var(--bg-color);
 border-radius: var(--radius-lg);
 padding: 24px;
 max-width: 90%;
 width: 320px;
 box-shadow: var(--shadow-lg);
 }
 
 .directions-modal-title {
 font-size: 18px;
 font-weight: 700;
 margin-bottom: 20px;
 color: var(--text-color);
 text-align: center;
 }
 
 .directions-buttons {
 display: flex;
 flex-direction: column;
 gap: 12px;
 margin-bottom: 20px;
 }
 
 .direction-btn {
 padding: 14px;
 border-radius: var(--radius);
 font-size: 16px;
 font-weight: 600;
 cursor: pointer;
 text-align: center;
 transition: var(--transition-fast);
 display: flex;
 align-items: center;
 justify-content: center;
 gap: 12px;
 text-decoration: none;
 will-change: transform, box-shadow;
 }
 
 .direction-btn.google {
 background-color: #4285F4;
 color: white;
 border: none;
 }
 
 .direction-btn.apple {
 background-color: #000000;
 color: white;
 border: none;
 }
 
 .direction-btn.waze {
 background-color: #33CCFF;
 color: white;
 border: none;
 }
 
 .direction-btn:hover, .direction-btn:active {
 transform: translateY(-2px);
 box-shadow: var(--shadow);
 }
 
 .cancel-btn {
 background-color: var(--bg-light);
 color: var(--text-light);
 border: 1px solid var(--bg-dark);
 padding: 12px;
 border-radius: var(--radius);
 font-size: 16px;
 font-weight: 600;
 cursor: pointer;
 text-align: center;
 transition: var(--transition-fast);
 width: 100%;
 will-change: background-color;
 }
 
 .cancel-btn:hover, .cancel-btn:active {
 background-color: var(--bg-dark);
 }
 
 /* Leaflet popup customization */
 .leaflet-popup-content-wrapper {
 padding: 0;
 overflow: hidden;
 border-radius: var(--radius-lg);
 box-shadow: var(--shadow-md);
 }
 
 .leaflet-popup-content {
 margin: 0;
 width: 280px !important;
 }
 
 .leaflet-popup-tip-container {
 margin-top: -1px;
 }
 
 .leaflet-popup-close-button {
 color: white !important;
 top: 5px !important;
 right: 5px !important;
 font-size: 20px !important;
 text-shadow: 0 0 3px rgba(0, 0, 0, 0.5);
 }
 
 /* Navigation buttons */
 .marker-popup-navigation {
 display: flex;
 flex-direction: column;
 gap: 10px;
 margin-top: 16px;
 }
 
 .nav-button {
 display: flex;
 align-items: center;
 justify-content: center;
 gap: 8px;
 padding: 10px;
 border-radius: var(--radius);
 text-decoration: none;
 font-weight: 600;
 font-size: 14px;
 transition: var(--transition-fast);
 will-change: transform, box-shadow;
 }
 
 .nav-button.google {
 background-color: #4285F4;
 color: white;
 }
 
 .nav-button.apple {
 background-color: #000000;
 color: white;
 }
 
 .nav-button.waze {
 background-color: #33CCFF;
 color: white;
 }
 
 .nav-button:hover, .nav-button:active {
 transform: translateY(-2px);
 box-shadow: var(--shadow);
 }
 
 /* Responsive adjustments */
 @media (max-width: 768px) {
 .map-buttons {
 bottom: 30px; /* Adjust for medium screens */
 padding: 10px 14px;
 gap: 12px;
 }
 
 .map-button {
 width: 46px;
 height: 46px;
 font-size: 20px;
 }
 
 #distanceBox {
 max-width: 280px;
 padding: 14px 16px;
 }
 }
 
 @media (max-width: 480px) {
 .map-buttons {
 bottom: 25px; /* Increase from 20px to 25px for small screens */
 padding: 8px 12px;
 gap: 10px;
 }
 
 .map-button {
 width: 40px; /* Slightly smaller buttons on very small screens */
 height: 40px;
 font-size: 16px;
 }
 
 #distanceBox {
 max-width: 260px;
 padding: 12px 14px;
 left: 12px;
 top: 12px;
 font-size: 18px;
 }
 
 #distanceBox .location-icon {
 font-size: 20px;
 margin-right: 10px;
 }
 
 #distanceBox .location-name {
 font-size: 18px;
 }
 
 #distanceBox .distance-value {
 font-size: 16px;
 }
 
 .marker-popup {
 max-width: 260px;
 }
 
 .marker-popup-image {
 height: 130px;
 }
 }

 /* Add a new media query for very small screens or devices with unusual interfaces */
 @media (max-height: 600px), (max-width: 360px) {
 .map-buttons {
 bottom: 15px; /* Even more compact for very small screens */
 }
 
 .map-button {
 width: 36px;
 height: 36px;
 font-size: 14px;
 }
 }

 /* Add a safe area inset for iOS devices with notches */
 @supports (padding-bottom: env(safe-area-inset-bottom)) {
 .map-buttons {
 bottom: calc(25px + env(safe-area-inset-bottom));
 }
 }
 </style>

</head>
<body>
    <!-- Preloader -->
    <div id="preloader">
        <div class="spinner"></div>
        <p>Loading Minnesota Then Tours...</p>
        <div class="progress-container">
            <div class="progress-bar" id="preloaderProgress"></div>
        </div>
    </div>

    <div id="map"></div>
    
    <!-- Enhanced Distance Box -->
    <div id="distanceBox">
        <div class="location-icon">
            <i class="fas fa-map-marker-alt"></i>
        </div>
        <div class="distance-info">
            <div class="location-name">Initializing...</div>
            <div class="distance-value">Finding your location</div>
        </div>
    </div>
    
    <div class="lochunt-container">
        <img id="locationImage" src="/placeholder.svg?height=200&width=400" alt="Location Image">
        <div class="lochunt-content">
            <div class="lochunt-info">
                <h2 id="locationTitle" class="mb-2"></h2>
                <p id="locationCity" class="text-muted mb-1"></p>
                <p id="locationCreator" class="text-muted mb-3"></p>
                <p id="locationDescription" class="mb-3"></p>
                
                <div class="marker-popup-navigation">
                    <a href="#" id="googleMapsLink" class="nav-button google" target="_blank">
                        <i class="fab fa-google"></i> Google Maps
                    </a>
                    <a href="#" id="appleMapsLink" class="nav-button apple" target="_blank">
                        <i class="fab fa-apple"></i> Apple Maps
                    </a>
                    <a href="#" id="wazeLink" class="nav-button waze" target="_blank">
                        <i class="fab fa-waze"></i> Waze
                    </a>
                </div>
            </div>
            <div class="audio-player">
                <div class="audio-progress">
                    <div class="progress">
                        <div id="progressBar" class="progress-bar" role="progressbar" style="width: 0%"></div>
                    </div>
                </div>
                <div class="audio-time">
                    <span id="currentTime">0:00</span>
                    <span id="duration">0:00</span>
                </div>
                <div class="audio-controls">
                    <button id="rewindBtn" class="audio-button"><i class="fas fa-backward"></i></button>
                    <button id="playPauseBtn" class="audio-button"><i class="fas fa-play"></i></button>
                    <button id="forwardBtn" class="audio-button"><i class="fas fa-forward"></i></button>
                </div>
                <audio id="locationAudio" src="/placeholder.svg"></audio>
            </div>
        </div>
    </div>
    
    <div class="trivia-container">
        <h3 class="mb-3">Trivia Question</h3>
        <p id="triviaQuestion" class="mb-3 fw-bold"></p>
        <div id="triviaOptions" class="d-grid gap-2"></div>
    </div>
    
    <!-- Enhanced Map Buttons: Horizontal and centered at bottom -->
    <div class="map-buttons">
        <button id="recenterButton" class="map-button" aria-label="Recenter map"><i class="fas fa-crosshairs"></i></button>
        <button id="returnButton" class="map-button" aria-label="Return to home"><i class="fas fa-sign-out-alt"></i></button>
        <button id="tipsButton" class="map-button" aria-label="Show tips"><i class="fas fa-question-circle"></i></button>
    </div>
    
    <div class="navigation-tips">
        <button class="close-button" aria-label="Close tips">&times;</button>
        <h3>Navigation Tips</h3>
        <ul>
            <li>Numbered markers show your tour stops in sequence.</li>
            <li>After visiting a location, the next stop will appear.</li>
            <li>Tap on a marker to see details and navigation options.</li>
            <li>The distance box shows how far you are from the current location.</li>
            <li>Tap the recenter button to focus on your position.</li>
            <li>When you're within 20 feet of a location, you'll be able to interact with it.</li>
            <li>Complete the trivia question to move to the next location.</li>
            <li>The map will automatically zoom in when you get closer to a location.</li>
        </ul>
    </div>
    
    <div id="congratulations">
        <h2>Congratulations!</h2>
        <p>You have successfully completed the Minnesota Then Gangster History Tour!</p>
        <button onclick="endTour()">Return to the Home Page</button>
    </div>
    
    <div id="popup">
        <div class="popup-content">
            <p id="popupMessage"></p>
            <button class="popup-button" onclick="closePopup()">OK</button>
        </div>
    </div>
    
    <!-- Directions Modal -->
    <div id="directionsModal">
        <div class="directions-modal-content">
            <div class="directions-modal-title">Choose Navigation App</div>
            <div class="directions-buttons">
                <a href="#" id="googleMapsBtn" class="direction-btn google" target="_blank">
                    <i class="fab fa-google"></i> Google Maps
                </a>
                <a href="#" id="appleMapsBtn" class="direction-btn apple" target="_blank">
                    <i class="fab fa-apple"></i> Apple Maps
                </a>
                <a href="#" id="wazeBtn" class="direction-btn waze" target="_blank">
                    <i class="fab fa-waze"></i> Waze
                </a>
            </div>
            <button class="cancel-btn" onclick="closeDirectionsModal()">Cancel</button>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    
    <script>
        // Sample locations data (replace with your actual data)
        const locations = [
            {
                id: 1,
                name: "Landmark Center",
                city: "St. Paul",
                creator: "Minnesota Historical Society",
                lat: 44.9448,
                lng: -93.0962,
                image: "https://www.mnthen.com/images/landmark-center.jpg",
                audio: "https://www.mnthen.com/audio/landmark-center.mp3",
                description: "The Landmark Center, completed in 1902, originally served as the Federal Court House and Post Office for the Upper Midwest. This Richardsonian Romanesque building was where many famous gangsters were tried during the 1930s.",
                trivia: {
                    question: "What was the Landmark Center originally built as?",
                    options: [
                        "A hotel",
                        "A federal courthouse and post office",
                        "A train station",
                        "A department store"
                    ],
                    answer: 1
                }
            },
            {
                id: 2,
                name: "Wabasha Street Caves",
                city: "St. Paul",
                creator: "Minnesota Historical Society",
                lat: 44.9338,
                lng: -93.1059,
                image: "https://www.mnthen.com/images/wabasha-caves.jpg",
                audio: "https://www.mnthen.com/audio/wabasha-caves.mp3",
                description: "The Wabasha Street Caves were originally mined for silica in the 1840s. During Prohibition, the caves became a speakeasy known as the Castle Royal. Gangsters like John Dillinger and Ma Barker were rumored to frequent the establishment.",
                trivia: {
                    question: "What illegal activity took place in the Wabasha Street Caves during Prohibition?",
                    options: [
                        "Counterfeiting money",
                        "Illegal gambling",
                        "Speakeasy and nightclub",
                        "All of the above"
                    ],
                    answer: 3
                }
            },
            {
                id: 3,
                name: "Nina's Coffee Cafe",
                city: "St. Paul",
                creator: "Minnesota Historical Society",
                lat: 44.9463,
                lng: -93.1032,
                image: "https://www.mnthen.com/images/ninas-cafe.jpg",
                audio: "https://www.mnthen.com/audio/ninas-cafe.mp3",
                description: "Nina's Coffee Cafe is located in the historic Blair Flats building. The building is rumored to have been a hideout for Al Capone during his visits to St. Paul. The cafe now serves as a popular community gathering spot.",
                trivia: {
                    question: "Which famous gangster was rumored to have a hideout above what is now Nina's Coffee Cafe?",
                    options: [
                        "Al Capone",
                        "John Dillinger",
                        "Ma Barker",
                        "Baby Face Nelson"
                    ],
                    answer: 0
                }
            }
        ];

        // Global variables
        let map, userMarker;
        let currentLocationIndex = 0;
        let visitedLocations = [];
        let gameLocations = [];
        let inactivityTimer;
        let isLocationHuntVisible = false;
        let lastPosition = null;
        let positionBuffer = [];
        const MAX_BUFFER_SIZE = 20; // Increased buffer size for smoother tracking
        const DISTANCE_THRESHOLD = 20; // 20 feet to measure threshold distance to marker before opening location page
        const PROXIMITY_THRESHOLD = 100; // 100 feet to trigger zoom level change
        const velocity = { lat: 0, lng: 0 };
        let isMapInteracting = false;
        let followUser = true; // Always true to keep user centered
        let allLocationMarkers = [];
        let showingAllLocations = false;
        let userIsInteracting = false;
        const preloadedImages = new Map(); // Map to store preloaded images
        const preloadedAudio = new Map(); // Map to store preloaded audio
        let currentSpeed = 0; // Current speed in meters per second
        let lastZoomLevel = 17; // Default zoom level
        let stationaryPositionHistory = []; // Array to store stationary positions for averaging
        let deviceOrientation = null; // Store device orientation data
        let deviceMotion = null; // Store device motion data
        let orientationPermissionGranted = false;
        let activeMarkers = []; // Track currently visible markers
        let currentDirectionsLocation = null; // Store current location for directions modal
        let lastProximityState = null; // Track last proximity state for zoom changes
        let isWithinProximity = false; // Flag to track if user is within proximity of a location
        let audioContext = null; // Audio context for better audio handling

        // Enhanced constants for better stabilization
        const MICRO_MOVEMENT_THRESHOLD = 0.25; // Meters - threshold for detecting micro-movements (reduced for better stability)
        const STATIONARY_ACCURACY_MULTIPLIER = 1.01; // Tighter accuracy bounds
        const MAX_ACCEPTABLE_ACCURACY = 20; // meters - stricter accuracy requirement
        const STATIONARY_THRESHOLD = 4; // Number of consecutive stationary positions to consider user as stationary
        const STATIONARY_TIME_THRESHOLD = 1500; // ms - time to consider user stationary
        const STATIONARY_CHECK_INTERVAL = 800; // ms - interval to check if still stationary
        const VELOCITY_DECAY = 0.94; // Higher value for smoother velocity transitions
        const MIN_DISTANCE_THRESHOLD = 0.5; // meters - minimum distance to consider movement
        const EXTENDED_DISTANCE_THRESHOLD = 60; // meters - distance to consider a significant position change
        const UPDATE_INTERVAL = 16; // ms - more frequent updates for smoother animation (approx 60fps)
        const STATIONARY_POSITION_HISTORY_SIZE = 20; // Number of positions to keep for stationary averaging
        const STATIONARY_POSITION_WEIGHT_DECAY = 0.92; // Weight decay for older positions in stationary average

        // Background handling constants
        const BACKGROUND_THRESHOLD = 15000; // ms - time to consider app was in background
        const INACTIVITY_TIMEOUT = 20000; // ms - time to consider user inactive

        // Kalman filter parameters - optimized for better stationary stability
        const KALMAN_PROCESS_NOISE = 0.0025; // Lower value for smoother tracking
        const KALMAN_MEASUREMENT_NOISE_BASE = 1.0; // Base measurement noise
        const KALMAN_STATIONARY_NOISE = 0.01; // Lower noise when stationary

        // Animation parameters
        const ANIMATION_DURATION = 150; // ms - duration of position animation (reduced for more responsive feel)
        const HEADING_SMOOTHING = 0.92; // Heading smoothing factor

        // Dynamic zoom level parameters - enhanced for better speed adaptation
        const MAX_ZOOM_LEVEL = 18; // Maximum zoom level (stationary)
        const MIN_ZOOM_LEVEL = 13; // Minimum zoom level (high speed)
        const DEFAULT_ZOOM_LEVEL = 17; // Default zoom level for walking speed
        const PROXIMITY_ZOOM_LEVEL = 18; // Zoom level when in proximity to a location
        const WALKING_SPEED_THRESHOLD = 1.5; // m/s - threshold for walking speed
        const RUNNING_SPEED_THRESHOLD = 4.0; // m/s - threshold for running speed
        const DRIVING_SPEED_THRESHOLD = 8.0; // m/s - threshold for driving speed
        const HIGH_SPEED_THRESHOLD = 20.0; // m/s - threshold for high speed
        const ZOOM_TRANSITION_DURATION = 0.4; // seconds - duration of zoom transition
        const ZOOM_UPDATE_INTERVAL = 800; // ms - interval to update zoom level

        // Motion detection parameters
        const MOTION_THRESHOLD = 0.5; // Threshold for detecting significant motion
        const MOTION_SAMPLE_SIZE = 10; // Number of motion samples to keep
        const MOTION_CHECK_INTERVAL = 80; // ms - interval to check motion

        // Edge detection parameters - updated for better recentering
        const EDGE_THRESHOLD_PERCENTAGE = 0.15; // Percentage from edge to trigger recenter
        const STRICT_EDGE_THRESHOLD_PERCENTAGE = 0.1; // Stricter threshold for edge detection
        const CRITICAL_EDGE_THRESHOLD_PERCENTAGE = 0.05; // Critical threshold for immediate recenter
        const RECENTER_COOLDOWN = 400; // ms - cooldown between recenters to prevent excessive recentering

        // Dynamic recentering parameters
        const SPEED_RECENTER_THRESHOLD = 5.0; // m/s - speed threshold to adjust recenter behavior
        const RECENTER_OFFSET_FACTOR = 0.3; // Factor to offset the center point ahead of user when moving fast

        // State variables
        let lastUpdateTime = null;
        let lastVelocity = { lat: 0, lng: 0 };
        let isStationary = false;
        let stationaryStartTime = null;
        let stationaryCheckTimeout = null;
        let lastUpdateTimestamp = null;
        let lastHiddenTime = 0;
        let stationaryCount = 0;
        let lastRecenterTime = Date.now();
        let stationaryBuffer = [];
        let isStabilizing = true; // Flag to track initial stabilization
        let lastStationaryPosition = null; // Last stable position when stationary
        let motionSamples = []; // Array to store motion samples
        let deviceStationaryTime = 0; // Time device has been stationary based on motion sensors
        let animationFrameId = null; // Store requestAnimationFrame ID
        let renderTimestamp = null; // Last render timestamp
        let positionUpdateQueue = []; // Queue for position updates to be processed
        let lastHeadingValue = null; // Last heading value
        let headingBuffer = []; // Buffer for heading values
        let isFirstPositionUpdate = true; // Flag for first position update
        let lastRenderPosition = null; // Last rendered position
        let positionInterpolator = null; // Position interpolator for smooth transitions
        let lastRawPosition = null; // Last raw position from GPS
        let consecutiveStationaryUpdates = 0; // Count consecutive stationary updates
        let lastDeviceMotionTimestamp = 0; // Last device motion timestamp
        let deviceMotionBuffer = []; // Buffer for device motion data
        let isDeviceStable = false; // Flag for device stability
        let lastAccuracy = null; // Last position accuracy
        let accuracyTrend = []; // Track accuracy trend
        let lastHeadingUpdateTime = 0; // Last heading update time
        let lastPositionUpdateTime = 0; // Last position update time
        let lastZoomUpdateTime = 0; // Last zoom update time
        let targetZoomLevel = DEFAULT_ZOOM_LEVEL; // Target zoom level for smooth transitions
        let lastSpeedForZoom = 0; // Last speed used for zoom calculation
        let speedSamples = []; // Array to store speed samples for zoom calculation
        let lastRecenterCheckTime = 0; // Last time we checked for recentering
        let lastProximityCheckTime = 0; // Last time we checked for proximity
        let proximityZoomActive = false; // Flag to track if proximity zoom is active
        let forceCenteringActive = false; // Flag to force centering regardless of other conditions
        let centeringPriority = 0; // Priority level for centering (0-10)
        let mapTiles = null; // Store map tiles for better performance
        let isAudioPlaying = false; // Track audio playback state
        let audioPlaybackPosition = 0; // Track audio playback position
        let isPreloadComplete = false; // Track preload completion
        let mapReady = false; // Track map readiness
        let locationDataReady = false; // Track location data readiness
        let deviceReadyForLocation = false; // Track device readiness for location
        let lastMapMoveTime = 0; // Last time map was moved
        let lastMapZoomTime = 0; // Last time map was zoomed
        let mapInteractionTimeout = null; // Timeout for map interaction
        let userMarkerElement = null; // Store user marker element for performance
        let userMarkerIconElement = null; // Store user marker icon element for performance
        let lastHeadingRotation = 0; // Last heading rotation value
        let headingUpdateNeeded = false; // Flag to track if heading update is needed
        let positionUpdateNeeded = false; // Flag to track if position update is needed
        let lastFrameTime = 0; // Last frame time for animation
        let frameCount = 0; // Frame count for performance monitoring
        let lastFpsUpdateTime = 0; // Last time FPS was updated
        let currentFps = 0; // Current FPS
        let isHighPerformanceDevice = true; // Flag to track if device is high performance
        let devicePerformanceChecked = false; // Flag to track if device performance has been checked
        let renderQuality = 'high'; // Render quality setting (high, medium, low)
        let lastRenderQualityCheckTime = 0; // Last time render quality was checked
        let renderQualityCheckInterval = 5000; // Interval to check render quality
        let consecutiveLowFpsFrames = 0; // Count consecutive low FPS frames
        let consecutiveHighFpsFrames = 0; // Count consecutive high FPS frames
        let isReducedMotion = false; // Flag to track if reduced motion is enabled
        let hasActiveGesture = false; // Flag to track if user has an active gesture
        let lastTouchTime = 0; // Last time user touched the screen
        let isTouchActive = false; // Flag to track if touch is active
        let touchStartPosition = null; // Starting position of touch
        let isLongTouch = false; // Flag to track if touch is long
        let longTouchTimeout = null; // Timeout for long touch
        let lastPinchDistance = 0; // Last pinch distance
        let isPinchActive = false; // Flag to track if pinch is active
        let lastPanPosition = null; // Last pan position
        let isPanActive = false; // Flag to track if pan is active
        let gestureStartTime = 0; // Start time of gesture
        let isGestureRecognized = false; // Flag to track if gesture is recognized
        let lastGestureEndTime = 0; // Last time gesture ended
        let isMapGestureActive = false; // Flag to track if map gesture is active
        let mapGestureTimeout = null; // Timeout for map gesture
        let lastMapInteractionTime = 0; // Last time user interacted with map
        let mapInteractionCount = 0; // Count map interactions
        let isMapDragging = false; // Flag to track if map is being dragged
        let mapDragStartPosition = null; // Starting position of map drag
        let mapDragTimeout = null; // Timeout for map drag
        let isMapZooming = false; // Flag to track if map is being zoomed
        let mapZoomStartLevel = null; // Starting zoom level of map zoom
        let mapZoomTimeout = null; // Timeout for map zoom
        let isMapAnimating = false; // Flag to track if map is animating
        let mapAnimationStartTime = 0; // Start time of map animation
        let mapAnimationDuration = 0; // Duration of map animation
        let mapAnimationStartPosition = null; // Starting position of map animation
        let mapAnimationEndPosition = null; // Ending position of map animation
        let mapAnimationStartZoom = null; // Starting zoom level of map animation
        let mapAnimationEndZoom = null; // Ending zoom level of map animation
        let mapAnimationProgress = 0; // Progress of map animation
        let mapAnimationFrame = null; // Animation frame for map animation
        let isMapAnimationCancelled = false; // Flag to track if map animation is cancelled
        let lastMapAnimationTime = 0; // Last time map animation was updated
        let mapAnimationUpdateInterval = 16; // Interval to update map animation
        let isMapAnimationComplete = false; // Flag to track if map animation is complete
        let mapAnimationCompleteTime = 0; // Time map animation completed
        let mapAnimationCompleteTimeout = null; // Timeout for map animation complete
        let isMapAnimationInterrupted = false; // Flag to track if map animation is interrupted
        let mapAnimationInterruptTime = 0; // Time map animation was interrupted
        let mapAnimationInterruptTimeout = null; // Timeout for map animation interrupt
        let isMapAnimationResumed = false; // Flag to track if map animation is resumed
        let mapAnimationResumeTime = 0; // Time map animation was resumed
        let mapAnimationResumeTimeout = null; // Timeout for map animation resume
        let isMapAnimationPaused = false; // Flag to track if map animation is paused
        let mapAnimationPauseTime = 0; // Time map animation was paused
        let mapAnimationPauseTimeout = null; // Timeout for map animation pause
        let isMapAnimationRestarted = false; // Flag to track if map animation is restarted
        let mapAnimationRestartTime = 0; // Time map animation was restarted
        let mapAnimationRestartTimeout = null; // Timeout for map animation restart
        let isMapAnimationStopped = false; // Flag to track if map animation is stopped
        let mapAnimationStopTime = 0; // Time map animation was stopped
        let mapAnimationStopTimeout = null; // Timeout for map animation stop
        let isMapAnimationStarted = false; // Flag to track if map animation is started
        let mapAnimationStartTime2 = 0; // Time map animation was started
        let mapAnimationStartTimeout = null; // Timeout for map animation start
        let isMapAnimationEnded = false; // Flag to track if map animation is ended
        let mapAnimationEndTime = 0; // Time map animation ended
        let mapAnimationEndTimeout = null; // Timeout for map animation end
        let isMapAnimationCanceled = false; // Flag to track if map animation is canceled
        let mapAnimationCancelTime = 0; // Time map animation was canceled
        let mapAnimationCancelTimeout = null; // Timeout for map animation cancel
        let isMapAnimationFinished = false; // Flag to track if map animation is finished
        let mapAnimationFinishTime = 0; // Time map animation finished
        let mapAnimationFinishTimeout = null; // Timeout for map animation finish
        let isMapAnimationDone = false; // Flag to track if map animation is done
        let mapAnimationDoneTime = 0; // Time map animation was done
        let mapAnimationDoneTimeout = null; // Timeout for map animation done
        let isMapAnimationCompleted = false; // Flag to track if map animation is completed
        let mapAnimationCompleteTime2 = 0; // Time map animation was completed
        let mapAnimationCompleteTimeout2 = null; // Timeout for map animation complete
        let isMapAnimationFinalized = false; // Flag to track if map animation is finalized
        let mapAnimationFinalizeTime = 0; // Time map animation was finalized
        let mapAnimationFinalizeTimeout = null; // Timeout for map animation finalize
        let isMapAnimationTerminated = false; // Flag to track if map animation is terminated
        let mapAnimationTerminateTime = 0; // Time map animation was terminated
        let mapAnimationTerminateTimeout = null; // Timeout for map animation terminate
        let isMapAnimationAborted = false; // Flag to track if map animation is aborted
        let mapAnimationAbortTime = 0; // Time map animation was aborted
        let mapAnimationAbortTimeout = null; // Timeout for map animation abort
        let isMapAnimationHalted = false; // Flag to track if map animation is halted
        let mapAnimationHaltTime = 0; // Time map animation was halted
        let mapAnimationHaltTimeout = null; // Timeout for map animation halt
        let isMapAnimationSuspended = false; // Flag to track if map animation is suspended
        let mapAnimationSuspendTime = 0; // Time map animation was suspended
        let mapAnimationSuspendTimeout = null; // Timeout for map animation suspend
        let isMapAnimationReactivated = false; // Flag to track if map animation is reactivated
        let mapAnimationReactivateTime = 0; // Time map animation was reactivated
        let mapAnimationReactivateTimeout = null; // Timeout for map animation reactivate
        let isMapAnimationRevived = false; // Flag to track if map animation is revived
        let mapAnimationReviveTime = 0; // Time map animation was revived
        let mapAnimationReviveTimeout = null; // Timeout for map animation revive
        let isMapAnimationRenewed = false; // Flag to track if map animation is renewed
        let mapAnimationRenewTime = 0; // Time map animation was renewed
        let mapAnimationRenewTimeout = null; // Timeout for map animation renew
        let isMapAnimationReinitiated = false; // Flag to track if map animation is reinitiated
        let mapAnimationReinitiateTime = 0; // Time map animation was reinitiated
        let mapAnimationReinitiateTimeout = null; // Timeout for map animation reinitiate
        let isMapAnimationReestablished = false; // Flag to track if map animation is reestablished
        let mapAnimationReestablishTime = 0; // Time map animation was reestablished
        let mapAnimationReestablishTimeout = null; // Timeout for map animation reestablish
        let isMapAnimationReconstituted = false; // Flag to track if map animation is reconstituted
        let mapAnimationReconstituteTime = 0; // Time map animation was reconstituted
        let mapAnimationReconstituteTimeout = null; // Timeout for map animation reconstitute
        let isMapAnimationReconstructed = false; // Flag to track if map animation is reconstructed
        let mapAnimationReconstructTime = 0; // Time map animation was reconstructed
        let mapAnimationReconstructTimeout = null; // Timeout for map animation reconstruct
        let isMapAnimationRebuilt = false; // Flag to track if map animation is rebuilt
        let mapAnimationRebuildTime = 0; // Time  // Flag to track if map animation is rebuilt
        let mapAnimationRebuildTime = 0; // Time map animation was rebuilt
        let mapAnimationRebuildTimeout = null; // Timeout for map animation rebuild

        // Enhanced Kalman Filter implementation
        class KalmanFilter {
            constructor() {
                // State variables
                this.x = 0; // Longitude estimate
                this.y = 0; // Latitude estimate
                this.vx = 0; // Longitude velocity
                this.vy = 0; // Latitude velocity

                // Error covariance matrix
                this.P = [
                    [100, 0, 0, 0], // Initial high uncertainty
                    [0, 100, 0, 0],
                    [0, 0, 10, 0],
                    [0, 0, 0, 10],
                ];

                // Process noise
                this.Q = KALMAN_PROCESS_NOISE;

                // Measurement noise (will be adjusted based on GPS accuracy)
                this.R = KALMAN_MEASUREMENT_NOISE_BASE;

                // Time delta
                this.dt = 1.0;

                // Initialized flag
                this.initialized = false;

                // Heading and accuracy tracking
                this.lastHeading = null;
                this.headingConfidence = 0;

                // Stationary mode flag
                this.stationaryMode = false;

                // Last timestamp
                this.lastTimestamp = null;

                // Adaptive noise parameters
                this.adaptiveNoiseMin = 0.001;
                this.adaptiveNoiseMax = 0.01;
                this.adaptiveNoiseFactor = 1.0;

                // Accuracy history
                this.accuracyHistory = [];
                this.maxAccuracyHistorySize = 5;

                // Jitter detection
                this.positionHistory = [];
                this.maxPositionHistorySize = 5;
                this.jitterThreshold = 0.3; // meters

                // Heading stability
                this.headingHistory = [];
                this.maxHeadingHistorySize = 8;
            }

            // Initialize the filter with first position
            reset(position) {
                if (!position || typeof position.lat !== "number" || typeof position.lng !== "number") {
                    console.error("Invalid position for Kalman filter reset");
                    return;
                }

                this.x = position.lng;
                this.y = position.lat;
                this.vx = 0;
                this.vy = 0;

                // Reset covariance matrix with high initial uncertainty
                this.P = [
                    [100, 0, 0, 0],
                    [0, 100, 0, 0],
                    [0, 0, 10, 0],
                    [0, 0, 0, 10],
                ];

                this.initialized = true;
                this.lastHeading = position.heading || null;
                this.headingConfidence = 0;
                this.stationaryMode = false;
                this.lastTimestamp = position.timestamp || Date.now();
                this.adaptiveNoiseFactor = 1.0;
                this.accuracyHistory = [];
                this.positionHistory = [];
                this.headingHistory = [];

                // Add initial position to history
                this.addToPositionHistory(position);
                if (position.accuracy) {
                    this.addToAccuracyHistory(position.accuracy);
                }
                if (position.heading !== null && position.heading !== undefined) {
                    this.addToHeadingHistory(position.heading);
                }
            }

            // Add position to history
            addToPositionHistory(position) {
                this.positionHistory.push({
                    lat: position.lat,
                    lng: position.lng,
                    timestamp: position.timestamp || Date.now(),
                });

                while (this.positionHistory.length > this.maxPositionHistorySize) {
                    this.positionHistory.shift();
                }
            }

            // Add accuracy to history
            addToAccuracyHistory(accuracy) {
                this.accuracyHistory.push(accuracy);

                while (this.accuracyHistory.length > this.maxAccuracyHistorySize) {
                    this.accuracyHistory.shift();
                }
            }

            // Add heading to history
            addToHeadingHistory(heading) {
                // Normalize heading to 0-360 range
                heading = ((heading % 360) + 360) % 360;

                this.headingHistory.push({
                    heading: heading,
                    timestamp: Date.now(),
                });

                while (this.headingHistory.length > this.maxHeadingHistorySize) {
                    this.headingHistory.shift();
                }
            }

            // Get median accuracy from history
            getMedianAccuracy() {
                if (this.accuracyHistory.length === 0) return 20;

                const sortedAccuracies = [...this.accuracyHistory].sort((a, b) => a - b);
                const mid = Math.floor(sortedAccuracies.length / 2);

                if (sortedAccuracies.length % 2 === 0) {
                    return (sortedAccuracies[mid - 1] + sortedAccuracies[mid]) / 2;
                } else {
                    return sortedAccuracies[mid];
                }
            }

            // Detect jitter in position history
            detectJitter() {
                if (this.positionHistory.length < 3) return false;

                // Calculate distances between consecutive positions
                const distances = [];
                for (let i = 1; i < this.positionHistory.length; i++) {
                    const p1 = this.positionHistory[i - 1];
                    const p2 = this.positionHistory[i];

                    // Calculate distance in meters
                    const distance = calculateDistance(p1, p2);

                    // Calculate time delta in seconds
                    const timeDelta = (p2.timestamp - p1.timestamp) / 1000;

                    // Calculate speed in m/s
                    const speed = timeDelta > 0 ? distance / timeDelta : 0;

                    distances.push({ distance, speed });
                }

                // Check for rapid direction changes (jitter)
                if (distances.length >= 2) {
                    const lastDistance = distances[distances.length - 1].distance;
                    const prevDistance = distances[distances.length - 2].distance;

                    // If both distances are small but non-zero, it might be jitter
                    if (
                        lastDistance > 0 &&
                        lastDistance < this.jitterThreshold &&
                        prevDistance > 0 &&
                        prevDistance < this.jitterThreshold
                    ) {
                        return true;
                    }
                }

                return false;
            }

            // Get stable heading from history
            getStableHeading() {
                if (this.headingHistory.length < 3) {
                    return this.lastHeading;
                }

                // Get recent headings (last 3)
                const recentHeadings = this.headingHistory.slice(-3).map((h) => h.heading);

                // Check if headings are stable (within 15 degrees of each other)
                let isStable = true;
                for (let i = 1; i < recentHeadings.length; i++) {
                    const diff = Math.abs(recentHeadings[i] - recentHeadings[i - 1]);
                    const normalizedDiff = Math.min(diff, 360 - diff);
                    if (normalizedDiff > 15) {
                        isStable = false;
                        break;
                    }
                }

                if (isStable) {
                    // Return median heading
                    const sortedHeadings = [...recentHeadings].sort((a, b) => a - b);
                    return sortedHeadings[Math.floor(sortedHeadings.length / 2)];
                }

                return this.lastHeading;
            }

            // Set stationary mode
            setStationaryMode(isStationary) {
                this.stationaryMode = isStationary;

                // When entering stationary mode, reduce velocity to zero
                if (isStationary) {
                    this.vx = 0;
                    this.vy = 0;

                    // Reduce process noise for stationary mode
                    this.Q = KALMAN_STATIONARY_NOISE;
                    this.adaptiveNoiseFactor = 0.3; // Reduce noise in stationary mode
                } else {
                    // Reset to normal process noise when moving
                    this.Q = KALMAN_PROCESS_NOISE;
                    this.adaptiveNoiseFactor = 1.0; // Normal noise when moving
                }
            }

            // Adjust process noise based on accuracy and motion
            adjustProcessNoise(accuracy, motionDetected) {
                // Base noise level depends on GPS accuracy
                let noiseLevel =
                    this.adaptiveNoiseMin + (this.adaptiveNoiseMax - this.adaptiveNoiseMin) * Math.min(1.0, accuracy / 40.0);

                // Reduce noise when stationary
                if (this.stationaryMode) {
                    noiseLevel *= 0.3;
                }

                // Increase noise when motion is detected
                if (motionDetected && !this.stationaryMode) {
                    noiseLevel *= 1.5;
                }

                // Reduce noise when jitter is detected
                if (this.detectJitter()) {
                    noiseLevel *= 0.4; // Reduce noise to smooth out jitter
                }

                // Apply adaptive factor
                noiseLevel *= this.adaptiveNoiseFactor;

                // Set process noise
                this.Q = noiseLevel;
            }

            // Update the filter with new measurement
            update(position, motionDetected = false) {
                if (!this.initialized) {
                    this.reset(position);
                    return position;
                }

                if (!position || typeof position.lat !== "number" || typeof position.lng !== "number") {
                    console.warn("Invalid position input to Kalman filter");
                    return {
                        lat: this.y,
                        lng: this.x,
                        accuracy: position?.accuracy || 20,
                        heading: this.lastHeading,
                        timestamp: position?.timestamp || Date.now(),
                    };
                }

                // Add to position history
                this.addToPositionHistory(position);

                // Add to accuracy history
                if (position.accuracy) {
                    this.addToAccuracyHistory(position.accuracy);
                }

                // Add to heading history
                if (position.heading !== null && position.heading !== undefined) {
                    this.addToHeadingHistory(position.heading);
                }

                // Calculate time delta
                const timestamp = position.timestamp || Date.now();
                if (this.lastTimestamp) {
                    this.dt = Math.min(Math.max((timestamp - this.lastTimestamp) / 1000, 0.01), 1.0);
                }
                this.lastTimestamp = timestamp;

                // Adjust measurement noise based on GPS accuracy
                const accuracy = position.accuracy || 20;
                const medianAccuracy = this.getMedianAccuracy();
                this.R = Math.max(KALMAN_MEASUREMENT_NOISE_BASE, medianAccuracy / 10);

                // If in stationary mode, increase measurement noise to reduce jitter
                if (this.stationaryMode) {
                    this.R *= 1.5;
                }

                // Adjust process noise based on accuracy and motion
                this.adjustProcessNoise(accuracy, motionDetected);

                // State transition matrix
                const F = [
                    [1, 0, this.dt, 0],
                    [0, 1, 0, this.dt],
                    [0, 0, 1, 0],
                    [0, 0, 0, 1],
                ];

                // Predict step
                // x = F * x
                const predictedX = this.x + this.dt * this.vx;
                const predictedY = this.y + this.dt * this.vy;
                const predictedVx = this.stationaryMode ? 0 : this.vx;
                const predictedVy = this.stationaryMode ? 0 : this.vy;

                // P = F * P * F' + Q
                const Q = [
                    [(this.Q * this.dt * this.dt * this.dt * this.dt) / 4, 0, (this.Q * this.dt * this.dt * this.dt) / 2, 0],
                    [0, (this.Q * this.dt * this.dt * this.dt * this.dt) / 4, 0, (this.Q * this.dt * this.dt * this.dt) / 2],
                    [(this.Q * this.dt * this.dt * this.dt) / 2, 0, this.Q * this.dt * this.dt, 0],
                    [0, (this.Q * this.dt * this.dt * this.dt) / 2, 0, this.Q * this.dt * this.dt],
                ];

                // Matrix multiplication F * P
                const FP = [
                    [
                        this.P[0][0] + this.dt * this.P[2][0],
                        this.P[0][1] + this.dt * this.P[2][1],
                        this.P[0][2] + this.dt * this.P[2][2],
                        this.P[0][3] + this.dt * this.P[2][3],
                    ],
                    [
                        this.P[1][0] + this.dt * this.P[3][0],
                        this.P[1][1] + this.dt * this.P[3][1],
                        this.P[1][2] + this.dt * this.P[3][2],
                        this.P[1][3] + this.dt * this.P[3][3],
                    ],
                    [this.P[2][0], this.P[2][1], this.P[2][2], this.P[2][3]],
                    [this.P[3][0], this.P[3][1], this.P[3][2], this.P[3][3]],
                ];

                // Matrix multiplication FP * F'
                const predictedP = [
                    [
                        FP[0][0] + this.dt * FP[0][2] + Q[0][0],
                        FP[0][1] + this.dt * FP[0][3] + Q[0][1],
                        FP[0][2] + Q[0][2],
                        FP[0][3] + Q[0][3],
                    ],
                    [
                        FP[1][0] + this.dt * FP[1][2] + Q[1][0],
                        FP[1][1] + this.dt * FP[1][3] + Q[1][1],
                        FP[1][2] + Q[1][2],
                        FP[1][3] + Q[1][3],
                    ],
                    [FP[2][0] + Q[2][0], FP[2][1] + Q[2][1], FP[2][2] + Q[2][2], FP[2][3] + Q[2][3]],
                    [FP[3][0] + Q[3][0], FP[3][1] + Q[3][1], FP[3][2] + Q[3][2], FP[3][3] + Q[3][3]],
                ];

                // Update step
                // y = z - H * x
                const measurementResidualX = position.lng - predictedX;
                const measurementResidualY = position.lat - predictedY;

                // S = H * P * H' + R
                const S = [
                    [predictedP[0][0] + this.R, predictedP[0][1]],
                    [predictedP[1][0], predictedP[1][1] + this.R],
                ];

                // Calculate determinant of S
                const detS = S[0][0] * S[1][1] - S[0][1] * S[1][0];

                // Calculate inverse of S
                const invS = [
                    [S[1][1] / detS, -S[0][1] / detS],
                    [-S[1][0] / detS, S[0][0] / detS],
                ];

                // K = P * H' * inv(S)
                const K = [
                    [
                        predictedP[0][0] * invS[0][0] + predictedP[0][1] * invS[1][0],
                        predictedP[0][0] * invS[0][1] + predictedP[0][1] * invS[1][1],
                    ],
                    [
                        predictedP[1][0] * invS[0][0] + predictedP[1][1] * invS[1][0],
                        predictedP[1][0] * invS[0][1] + predictedP[1][1] * invS[1][1],
                    ],
                    [
                        predictedP[2][0] * invS[0][0] + predictedP[2][1] * invS[1][0],
                        predictedP[2][0] * invS[0][1] + predictedP[2][1] * invS[1][1],
                    ],
                    [
                        predictedP[3][0] * invS[0][0] + predictedP[3][1] * invS[1][0],
                        predictedP[3][0] * invS[0][1] + predictedP[3][1] * invS[1][1],
                    ],
                ];

                // x = x + K * y
                this.x = predictedX + K[0][0] * measurementResidualX + K[0][1] * measurementResidualY;
                this.y = predictedY + K[1][0] * measurementResidualX + K[1][1] * measurementResidualY;

                // In stationary mode, keep velocity at zero
                if (this.stationaryMode) {
                    this.vx = 0;
                    this.vy = 0;
                } else {
                    this.vx = predictedVx + K[2][0] * measurementResidualX + K[2][1] * measurementResidualY;
                    this.vy = predictedVy + K[3][0] * measurementResidualX + K[3][1] * measurementResidualY;
                }

                // P = (I - K * H) * P
                this.P = [
                    [
                        predictedP[0][0] - (K[0][0] * predictedP[0][0] + K[0][1] * predictedP[1][0]),
                        predictedP[0][1] - (K[0][0] * predictedP[0][1] + K[0][1] * predictedP[1][1]),
                        predictedP[0][2] - (K[0][0] * predictedP[0][2] + K[0][1] * predictedP[1][2]),
                        predictedP[0][3] - (K[0][0] * predictedP[0][3] + K[0][1] * predictedP[1][3]),
                    ],
                    [
                        predictedP[1][0] - (K[1][0] * predictedP[0][0] + K[1][1] * predictedP[1][0]),
                        predictedP[1][1] - (K[1][0] * predictedP[0][1] + K[1][1] * predictedP[1][1]),
                        predictedP[1][2] - (K[1][0] * predictedP[0][2] + K[1][1] * predictedP[1][2]),
                        predictedP[1][3] - (K[1][0] * predictedP[0][3] + K[1][1] * predictedP[1][3]),
                    ],
                    [
                        predictedP[2][0] - (K[2][0] * predictedP[0][0] + K[2][1] * predictedP[1][0]),
                        predictedP[2][1] - (K[2][0] * predictedP[0][1] + K[2][1] * predictedP[1][1]),
                        predictedP[2][2] - (K[2][0] * predictedP[0][2] + K[2][1] * predictedP[1][2]),
                        predictedP[2][3] - (K[2][0] * predictedP[0][3] + K[2][1] * predictedP[1][3]),
                    ],
                    [
                        predictedP[3][0] - (K[3][0] * predictedP[0][0] + K[3][1] * predictedP[1][0]),
                        predictedP[3][1] - (K[3][0] * predictedP[0][1] + K[3][1] * predictedP[1][1]),
                        predictedP[3][2] - (K[3][0] * predictedP[0][2] + K[3][1] * predictedP[1][2]),
                        predictedP[3][3] - (K[3][0] * predictedP[0][3] + K[3][1] * predictedP[1][3]),
                    ],
                ];

                // Process heading data
                let smoothedHeading = position.heading;
                if (position.heading !== null && position.heading !== undefined) {
                    // Get stable heading from history
                    smoothedHeading = this.getStableHeading();

                    // If no stable heading yet, use current heading
                    if (smoothedHeading === null) {
                        smoothedHeading = position.heading;
                    }

                    this.lastHeading = smoothedHeading;
                }

                // Calculate speed from velocity components
                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);

                return {
                    lat: this.y,
                    lng: this.x,
                    accuracy: position.accuracy,
                    heading: smoothedHeading,
                    timestamp: position.timestamp,
                    speedMPS: this.stationaryMode ? 0 : speed * 111000, // Convert from degrees/second to meters/second (approximate)
                };
            }
        }

        // Position interpolator for smooth transitions
        class PositionInterpolator {
            constructor() {
                this.startPosition = null;
                this.targetPosition = null;
                this.startTime = null;
                this.duration = 0;
                this.isActive = false;
                this.lastInterpolatedPosition = null;
            }

            start(startPos, targetPos, duration) {
                if (!startPos || !targetPos) return;

                // Don't interpolate if positions are too close
                const distance = calculateDistance(startPos, targetPos);
                if (distance < 0.1) {
                    this.isActive = false;
                    this.lastInterpolatedPosition = targetPos;
                    return;
                }

                this.startPosition = { ...startPos };
                this.targetPosition = { ...targetPos };
                this.startTime = performance.now();
                this.duration = duration;
                this.isActive = true;
            }

            update() {
                if (!this.isActive) return this.lastInterpolatedPosition || this.targetPosition;

                const now = performance.now();
                const elapsed = now - this.startTime;

                if (elapsed >= this.duration) {
                    this.isActive = false;
                    this.lastInterpolatedPosition = this.targetPosition;
                    return this.targetPosition;
                }

                // Calculate progress with easing
                const t = elapsed / this.duration;
                const easedT = this.easeOutCubic(t);

                // Interpolate position
                const interpolatedPosition = {
                    lat: this.startPosition.lat + (this.targetPosition.lat - this.startPosition.lat) * easedT,
                    lng: this.startPosition.lng + (this.targetPosition.lng - this.startPosition.lng) * easedT,
                    accuracy: this.targetPosition.accuracy,
                    heading: this.targetPosition.heading,
                    timestamp: now,
                    speedMPS: this.targetPosition.speedMPS,
                };

                this.lastInterpolatedPosition = interpolatedPosition;
                return interpolatedPosition;
            }

            // Cubic easing function for smoother motion
            easeOutCubic(t) {
                return 1 - Math.pow(1 - t, 3);
            }

            isInterpolating() {
                return this.isActive;
            }

            cancel() {
                this.isActive = false;
            }

            getLastPosition() {
                return this.lastInterpolatedPosition || this.targetPosition;
            }
        }

        // Create Kalman filter instance
        const kalmanFilter = new KalmanFilter();

        // Create position interpolator
        positionInterpolator = new PositionInterpolator();

        // Calculate distance between two points using Haversine formula
        function calculateDistance(pos1, pos2) {
            if (
                !pos1 ||
                !pos2 ||
                typeof pos1.lat !== "number" ||
                typeof pos1.lng !== "number" ||
                typeof pos2.lat !== "number" ||
                typeof pos2.lng !== "number"
            ) {
                return Number.POSITIVE_INFINITY;
            }

            const R = 6371000; // Earth's radius in meters
            const lat1 = (pos1.lat * Math.PI) / 180;
            const lat2 = (pos2.lat * Math.PI) / 180;
            const deltaLat = ((pos2.lat - pos1.lat) * Math.PI) / 180;
            const deltaLng = ((pos2.lng - pos1.lng) * Math.PI) / 180;

            const a =
                Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) +
                Math.cos(lat1) * Math.cos(lat2) * Math.sin(deltaLng / 2) * Math.sin(deltaLng / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

            return R * c;
        }

        // Check if device is in motion based on motion sensors
        function isDeviceInMotion() {
            if (!motionSamples || motionSamples.length < 3) {
                return false;
            }

            // Calculate average motion magnitude
            const avgMotion =
                motionSamples.reduce((sum, sample) => {
                    return sum + Math.sqrt(sample.x * sample.x + sample.y * sample.y + sample.z * sample.z);
                }, 0) / motionSamples.length;

            return avgMotion > MOTION_THRESHOLD;
        }

        // Process device motion data
        function handleDeviceMotion(event) {
            if (!event || !event.acceleration) return;

            const now = Date.now();
            // Throttle motion updates for better performance
            if (now - lastDeviceMotionTimestamp < 50) return;
            lastDeviceMotionTimestamp = now;

            const motion = {
                x: event.acceleration.x || 0,
                y: event.acceleration.y || 0,
                z: event.acceleration.z || 0,
                timestamp: now,
            };

            // Add to motion samples
            motionSamples.push(motion);

            // Keep only recent samples
            while (motionSamples.length > MOTION_SAMPLE_SIZE) {
                motionSamples.shift();
            }

            // Update device motion state
            deviceMotion = motion;

            // Add to device motion buffer for stability detection
            deviceMotionBuffer.push({
                magnitude: Math.sqrt(motion.x * motion.x + motion.y * motion.y + motion.z * motion.z),
                timestamp: now,
            });

            // Keep buffer at reasonable size
            while (deviceMotionBuffer.length > 10) {
                deviceMotionBuffer.shift();
            }

            // Check if device is stationary based on motion
            const inMotion = isDeviceInMotion();

            if (!inMotion) {
                deviceStationaryTime += 50; // Increment by throttle time
            } else {
                deviceStationaryTime = 0;
            }
        }

        // Process device orientation data
        function handleDeviceOrientation(event) {
            if (!event || event.alpha === null) return;

            const now = Date.now();
            // Throttle heading updates
            if (now - lastHeadingUpdateTime < 100) return;
            lastHeadingUpdateTime = now;

            deviceOrientation = {
                alpha: event.alpha, // z-axis rotation [0,360)
                beta: event.beta, // x-axis rotation [-180,180)
                gamma: event.gamma, // y-axis rotation [-90,90)
                timestamp: now,
            };

            // Update heading buffer if we have a compass heading
            if (event.webkitCompassHeading !== undefined) {
                const heading = event.webkitCompassHeading;

                // Add to heading buffer
                headingBuffer.push(heading);

                // Keep only recent headings
                while (headingBuffer.length > 8) {
                    headingBuffer.shift();
                }

                // Calculate median heading to filter outliers
                if (headingBuffer.length >= 3) {
                    const sortedHeadings = [...headingBuffer].sort((a, b) => a - b);
                    lastHeadingValue = sortedHeadings[Math.floor(sortedHeadings.length / 2)];
                    headingUpdateNeeded = true;
                }
            }
        }

        // Request device motion and orientation permissions
        function requestMotionPermission() {
            if (typeof DeviceMotionEvent !== "undefined" && typeof DeviceMotionEvent.requestPermission === "function") {
                DeviceMotionEvent.requestPermission()
                    .then((response) => {
                        if (response === "granted") {
                            window.addEventListener("devicemotion", handleDeviceMotion, true);
                        }
                    })
                    .catch(console.error);
            } else {
                window.addEventListener("devicemotion", handleDeviceMotion, true);
            }

            if (typeof DeviceOrientationEvent !== "undefined" && typeof DeviceOrientationEvent.requestPermission === "function") {
                DeviceOrientationEvent.requestPermission()
                    .then((response) => {
                        if (response === "granted") {
                            orientationPermissionGranted = true;
                            window.addEventListener("deviceorientation", handleDeviceOrientation, true);
                        }
                    })
                    .catch(console.error);
            } else {
                window.addEventListener("deviceorientation", handleDeviceOrientation, true);
                orientationPermissionGranted = true;
            }
        }

        // Animation loop for smooth rendering
        function startAnimationLoop() {
            function animate(timestamp) {
                // Calculate delta time
                const deltaTime = renderTimestamp ? (timestamp - renderTimestamp) / 1000 : 0;
                renderTimestamp = timestamp;

                // Track frame rate
                frameCount++;
                if (timestamp - lastFpsUpdateTime > 1000) {
                    currentFps = Math.round((frameCount * 1000) / (timestamp - lastFpsUpdateTime));
                    frameCount = 0;
                    lastFpsUpdateTime = timestamp;
                    
                    // Check device performance
                    if (!devicePerformanceChecked && currentFps > 0) {
                        isHighPerformanceDevice = currentFps > 40;
                        devicePerformanceChecked = true;
                        
                        // Adjust render quality based on device performance
                        if (!isHighPerformanceDevice) {
                            renderQuality = currentFps > 30 ? 'medium' : 'low';
                        }
                    }
                }

                // Process position updates
                processPositionUpdateQueue();

                // Update interpolated position
                if (positionInterpolator && positionInterpolator.isInterpolating()) {
                    const interpolatedPosition = positionInterpolator.update();
                    if (interpolatedPosition) {
                        // Update marker position
                        userMarker.setLatLng([interpolatedPosition.lat, interpolatedPosition.lng]);
                        lastRenderPosition = interpolatedPosition;

                        // Update marker rotation if heading is available and needs update
                        if (interpolatedPosition.heading !== null && interpolatedPosition.heading !== undefined && headingUpdateNeeded) {
                            updateMarkerRotation(interpolatedPosition.heading);
                            headingUpdateNeeded = false;
                        }
                    }
                }

                // Always keep user centered - key improvement
                if (followUser && !isMapInteracting) {
                    if (userMarker && userMarker.getLatLng()) {
                        map.setView(userMarker.getLatLng(), map.getZoom(), {
                            animate: true,
                            duration: 0.3,
                            noMoveStart: true
                        });
                    }
                }

                // Update zoom level based on speed and proximity
                updateDynamicZoom();

                // Check for proximity to locations
                if (Date.now() - lastProximityCheckTime > 500) {
                    checkProximityForZoom();
                    lastProximityCheckTime = Date.now();
                }

                // Request next frame
                animationFrameId = requestAnimationFrame(animate);
            }

            // Start animation loop
            animationFrameId = requestAnimationFrame(animate);
        }

        // Update marker rotation based on heading
        function updateMarkerRotation(heading) {
            if (Math.abs(heading - lastHeadingRotation) < 2) {
                return; // Skip tiny rotation changes
            }
            
            lastHeadingRotation = heading;
            
            if (!userMarkerIconElement) {
                const markerElement = userMarker.getElement();
                if (markerElement) {
                    userMarkerIconElement = markerElement.querySelector(".user-marker-icon");
                }
            }
            
            if (userMarkerIconElement) {
                userMarkerIconElement.style.transform = `rotate(${heading}deg)`;
            }
        }

        // Process position update queue
        function processPositionUpdateQueue() {
            if (positionUpdateQueue.length === 0) return;

            // Process all updates in queue
            while (positionUpdateQueue.length > 0) {
                const update = positionUpdateQueue.shift();
                processPositionUpdate(update);
            }
        }

        function processPositionUpdate(position) {
            // Validate position
            if (!position || typeof position.lat !== "number" || typeof position.lng !== "number") {
                return;
            }

            // Update tracking variables
            lastPosition = position;
            currentSpeed = position.speedMPS || 0;
            
            // Maintain speed samples (5-point buffer)
            speedSamples.push(currentSpeed);
            if (speedSamples.length > 5) speedSamples.shift();

            // Update marker stationary state
            if (!userMarkerElement) {
                userMarkerElement = userMarker.getElement();
            }
            
            if (userMarkerElement) {
                userMarkerElement.classList.toggle("user-marker-stationary", isStationary);
            }

            // Calculate movement distance if we have previous position
            const distance = lastRenderPosition ? calculateDistance(lastRenderPosition, position) : 0;

            // Handle position update
            if (!lastRenderPosition || isFirstPositionUpdate) {
                // Initial position - set directly
                userMarker.setLatLng([position.lat, position.lng]);
                lastRenderPosition = position;
                isFirstPositionUpdate = false;
            } 
            else if (distance > EXTENDED_DISTANCE_THRESHOLD) {
                // Large movement - update immediately without animation
                userMarker.setLatLng([position.lat, position.lng]);
                lastRenderPosition = position;
                
                // Cancel any ongoing animation
                if (positionInterpolator) {
                    positionInterpolator.cancel();
                }
            }
            else {
                // Normal movement - apply smooth interpolation
                const animDuration = isStationary ? 
                    (distance < 0.5 ? 500 : 300) : // Longer duration for stationary micro-movements
                    ANIMATION_DURATION;
                
                positionInterpolator.start(lastRenderPosition, position, animDuration);
            }

            // Update marker rotation if heading available
            if (position.heading !== null && position.heading !== undefined) {
                updateMarkerRotation(position.heading);
            }

            // Always keep user centered - key improvement
            if (followUser && !isMapInteracting) {
                map.setView([position.lat, position.lng], map.getZoom(), {
                    animate: true,
                    duration: 0.3
                });
            }
            
            // Check nearby points of interest
            checkNearbyLocations();
        }
        
        // Check for proximity to locations for zoom level adjustment
        function checkProximityForZoom() {
            if (!lastPosition || !gameLocations || gameLocations.length === 0) return;
            
            // Only check the current location
            const location = gameLocations[currentLocationIndex];
            if (!location) return;
            
            // Calculate distance to current location
            const distance = calculateDistance(
                { lat: lastPosition.lat, lng: lastPosition.lng },
                { lat: location.lat, lng: location.lng }
            );
            
            // Convert to feet
            const distanceFeet = Math.round(distance * 3.28084);
            
            // Check if user is within proximity threshold
            const withinProximity = distanceFeet <= PROXIMITY_THRESHOLD;
            
            // Only update if proximity state has changed
            if (withinProximity !== isWithinProximity) {
                isWithinProximity = withinProximity;
                
                // Adjust zoom level based on proximity
                if (isWithinProximity && !proximityZoomActive) {
                    // Zoom in when entering proximity
                    proximityZoomActive = true;
                    if (map && followUser) {
                        map.setZoom(PROXIMITY_ZOOM_LEVEL, {
                            animate: true,
                            duration: 1.0,
                            noMoveStart: true
                        });
                    }
                } else if (!isWithinProximity && proximityZoomActive) {
                    // Zoom out when leaving proximity
                    proximityZoomActive = false;
                    if (map && followUser) {
                        map.setZoom(DEFAULT_ZOOM_LEVEL, {
                            animate: true,
                            duration: 1.0,
                            noMoveStart: true
                        });
                    }
                }
            }
        }

        // Check for nearby locations
        function checkNearbyLocations() {
            if (!lastPosition || !gameLocations || isLocationHuntVisible) return;
            
            // Only check the current location (progressive display)
            const location = gameLocations[currentLocationIndex];
            if (!location) return;
            
            // Skip if already visited
            if (visitedLocations.includes(location.id)) return;
            
            const distance = calculateDistance(
                { lat: lastPosition.lat, lng: lastPosition.lng },
                { lat: location.lat, lng: location.lng }
            );
            
            // Convert to feet
            const distanceFeet = Math.round(distance * 3.28084);
            
            // Update distance box
            updateDistanceBox(location, distanceFeet);
            
            // Check if user is close enough to interact
            if (distanceFeet <= DISTANCE_THRESHOLD) {
                showLocationHunt(location);
            }
        }
        
        // Update distance box with location info
        function updateDistanceBox(location, distanceFeet) {
            const distanceBox = document.getElementById('distanceBox');
            if (distanceBox) {
                const locationNameElement = distanceBox.querySelector('.location-name');
                const distanceValueElement = distanceBox.querySelector('.distance-value');
                
                if (locationNameElement && distanceValueElement) {
                    locationNameElement.textContent = location.name;
                    
                    // Format distance based on value
                    let distanceText;
                    if (distanceFeet > 5280) {
                        // Convert to miles and round to 1 decimal place
                        const distanceMiles = (distanceFeet / 5280).toFixed(1);
                        distanceText = `${distanceMiles} miles away`;
                    } else if (distanceFeet === 5280) {
                        distanceText = "1 mile away";
                    } else {
                        distanceText = `${distanceFeet} feet away`;
                    }
                    
                    distanceValueElement.textContent = distanceText;
                }
            }
        }

        // Create navigation links for a location
        function createNavigationLinks(location) {
            // Google Maps
            const googleMapsLink = document.getElementById('googleMapsLink');
            if (googleMapsLink) {
                googleMapsLink.href = `https://www.google.com/maps/dir/?api=1&destination=${location.lat},${location.lng}&travelmode=walking`;
            }
            
            // Apple Maps (iOS only)
            const appleMapsLink = document.getElementById('appleMapsLink');
            if (appleMapsLink) {
                appleMapsLink.href = `maps://maps.apple.com/?daddr=${location.lat},${location.lng}&dirflg=w`;
                
                // Hide Apple Maps link on non-iOS devices
                const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
                appleMapsLink.style.display = isIOS ? 'flex' : 'none';
            }
            
            // Waze
            const wazeLink = document.getElementById('wazeLink');
            if (wazeLink) {
                wazeLink.href = `https://waze.com/ul?ll=${location.lat},${location.lng}&navigate=yes`;
            }
        }
        
        // Set up directions modal links
        function setupDirectionsModal(location) {
            currentDirectionsLocation = location;
            
            // Google Maps
            const googleMapsBtn = document.getElementById('googleMapsBtn');
            if (googleMapsBtn) {
                googleMapsBtn.href = `https://www.google.com/maps/dir/?api=1&destination=${location.lat},${location.lng}&travelmode=walking`;
            }
            
            // Apple Maps (iOS only)
            const appleMapsBtn = document.getElementById('appleMapsBtn');
            if (appleMapsBtn) {
                appleMapsBtn.href = `maps://maps.apple.com/?daddr=${location.lat},${location.lng}&dirflg=w`;
                
                // Hide Apple Maps button on non-iOS devices
                const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
                appleMapsBtn.style.display = isIOS ? 'flex' : 'none';
            }
            
            // Waze
            const wazeBtn = document.getElementById('wazeBtn');
            if (wazeBtn) {
                wazeBtn.href = `https://waze.com/ul?ll=${location.lat},${location.lng}&navigate=yes`;
            }
        }
        
        // Show directions modal
        function showDirectionsModal(location) {
            setupDirectionsModal(location);
            document.getElementById('directionsModal').style.display = 'flex';
        }
        
        // Close directions modal
        function closeDirectionsModal() {
            document.getElementById('directionsModal').style.display = 'none';
        }
        
        // Skip to next location
        function skipToNextLocation() {
            // Close any open popups
            map.closePopup();
            
            // Remove the current marker from the map
            if (currentLocationIndex < allLocationMarkers.length) {
                map.removeLayer(allLocationMarkers[currentLocationIndex]);
            }
            
            // Move to next location
            currentLocationIndex++;
            
            // Check if we've reached the end
            if (currentLocationIndex >= gameLocations.length) {
                showCongratulations();
            } else {
                // Update visible markers
                updateVisibleMarkers();
                
                // Update distance box for new location
                const location = gameLocations[currentLocationIndex];
                if (location && lastPosition) {
                    const distance = calculateDistance(
                        { lat: lastPosition.lat, lng: lastPosition.lng },
                        { lat: location.lat, lng: location.lng }
                    );
                    const distanceFeet = Math.round(distance * 3.28084);
                    updateDistanceBox(location, distanceFeet);
                }
                
                // Reset proximity state
                isWithinProximity = false;
                proximityZoomActive = false;
            }
        }

        // Calculate optimal zoom level based on speed
        function calculateOptimalZoom(speed) {
            // If proximity zoom is active, prioritize it
            if (proximityZoomActive) {
                return PROXIMITY_ZOOM_LEVEL;
            }
            
            // Default to walking zoom level
            if (speed === undefined || speed === null) {
                return DEFAULT_ZOOM_LEVEL;
            }

            // Stationary or very slow
            if (speed < 0.5) {
                return MAX_ZOOM_LEVEL;
            }
            // Walking speed
            else if (speed < WALKING_SPEED_THRESHOLD) {
                return DEFAULT_ZOOM_LEVEL;
            }
            // Running speed
            else if (speed < RUNNING_SPEED_THRESHOLD) {
                return DEFAULT_ZOOM_LEVEL - 1;
            }
            // Driving speed
            else if (speed < DRIVING_SPEED_THRESHOLD) {
                return DEFAULT_ZOOM_LEVEL - 2;
            }
            // High speed
            else if (speed < HIGH_SPEED_THRESHOLD) {
                return DEFAULT_ZOOM_LEVEL - 3;
            }
            // Very high speed
            else {
                return MIN_ZOOM_LEVEL;
            }
        }

        // Update zoom level based on speed
        function updateDynamicZoom() {
            const now = Date.now();
            if (now - lastZoomUpdateTime < ZOOM_UPDATE_INTERVAL) return;
            lastZoomUpdateTime = now;

            // Skip if user is interacting with map
            if (isMapInteracting || userIsInteracting) return;

            // Calculate average speed from samples
            let avgSpeed = 0;
            if (speedSamples.length > 0) {
                avgSpeed = speedSamples.reduce((sum, speed) => sum + speed, 0) / speedSamples.length;
            } else if (lastPosition) {
                avgSpeed = lastPosition.speedMPS || 0;
            }

            // Smooth speed changes
            const smoothedSpeed = lastSpeedForZoom * 0.7 + avgSpeed * 0.3;
            lastSpeedForZoom = smoothedSpeed;

            // Calculate optimal zoom level
            const optimalZoom = calculateOptimalZoom(smoothedSpeed);

            // Only update if zoom level needs to change
            if (Math.abs(optimalZoom - targetZoomLevel) >= 0.1) {
                targetZoomLevel = optimalZoom;

                // Apply zoom change with smooth animation
                if (map && followUser) {
                    const currentZoom = map.getZoom();
                    const zoomDiff = Math.abs(currentZoom - targetZoomLevel);

                    // Use faster transition for larger zoom changes
                    const duration = zoomDiff > 1 ? 0.3 : ZOOM_TRANSITION_DURATION;

                    map.setZoom(targetZoomLevel, {
                        animate: true,
                        duration: duration,
                        noMoveStart: true,
                    });
                }
            }
        }

        // Linear interpolation helper
        function lerp(a, b, t) {
            if (typeof a !== "number" || typeof b !== "number" || typeof t !== "number") {
                return a;
            }

            return a + (b - a) * Math.max(0, Math.min(1, t));
        }

        // Calculate stationary position
        function calculateStationaryPosition(buffer) {
            if (!buffer || buffer.length === 0) {
                return null;
            }
            // Sort by accuracy (best first)
            const sortedBuffer = [...buffer].sort((a, b) => a.accuracy - b.accuracy);
            // Take weighted average of best positions
            const topPositions = sortedBuffer.slice(0, Math.ceil(buffer.length / 2));
            const weights = topPositions.map((pos) => 1 / Math.max(1, pos.accuracy));
            const totalWeight = weights.reduce((sum, w) => sum + w, 0);
            if (totalWeight === 0) {
                return sortedBuffer[0];
            }
            // Calculate weighted average
            const avgPosition = {
                lat: topPositions.reduce((sum, pos, i) => sum + pos.lat * weights[i], 0) / totalWeight,
                lng: topPositions.reduce((sum, pos, i) => sum + pos.lng * weights[i], 0) / totalWeight,
                accuracy: topPositions[0].accuracy,
                heading: topPositions[0].heading,
                timestamp: Date.now(),
                speedMPS: 0,
            };
            // If we have a previous stationary position, blend with it for stability
            if (lastStationaryPosition) {
                const blendFactor = 0.85; // 85% previous, 15% new for extreme stability
                return {
                    lat: lastStationaryPosition.lat * blendFactor + avgPosition.lat * (1 - blendFactor),
                    lng: lastStationaryPosition.lng * blendFactor + avgPosition.lng * (1 - blendFactor),
                    accuracy: avgPosition.accuracy,
                    heading: avgPosition.heading,
                    timestamp: avgPosition.timestamp,
                    speedMPS: 0
                };
            }
            return avgPosition;
        }

        // Update stationary position history
        function updateStationaryHistory(position) {
            // Add new position to history
            stationaryPositionHistory.push(position);

            // Keep history at maximum size
            while (stationaryPositionHistory.length > STATIONARY_POSITION_HISTORY_SIZE) {
                stationaryPositionHistory.shift();
            }

            // Calculate weighted average of positions
            let totalWeight = 0;
            let weightedLat = 0;
            let weightedLng = 0;

            // Newer positions have higher weight
            for (let i = 0; i < stationaryPositionHistory.length; i++) {
                const pos = stationaryPositionHistory[i];
                const weight = Math.pow(STATIONARY_POSITION_WEIGHT_DECAY, stationaryPositionHistory.length - i - 1);
                totalWeight += weight;
                weightedLat += pos.lat * weight;
                weightedLng += pos.lng * weight;
            }

            return {
                lat: weightedLat / totalWeight,
                lng: weightedLng / totalWeight,
                accuracy: position.accuracy,
                heading: position.heading,
                timestamp: position.timestamp,
                speedMPS: 0,
            };
        }

        // Update position buffer with new position
        function updatePositionBuffer(position) {
            if (!position || typeof position.lat !== "number" || typeof position.lng !== "number") {
                return;
            }

            // Add new position to buffer
            positionBuffer.push({
                lat: position.lat,
                lng: position.lng,
                accuracy: position.accuracy,
                heading: position.heading,
                timestamp: position.timestamp,
                speedMPS: position.speedMPS,
            });

            // Remove old positions if buffer exceeds maxSize
            while (positionBuffer.length > MAX_BUFFER_SIZE) {
                positionBuffer.shift();
            }
        }

        // Check if user is stationary
        function checkStationaryState(newPosition) {
            if (!lastPosition) return;

            const distance = calculateDistance(lastPosition, newPosition);

            if (distance >= MICRO_MOVEMENT_THRESHOLD) {
                isStationary = false;
                stationaryStartTime = null;
                console.debug("Movement detected, resuming normal updates");

                // Update Kalman filter stationary mode
                kalmanFilter.setStationaryMode(false);

                // Update marker class
                if (userMarkerElement) {
                    userMarkerElement.classList.remove("user-marker-stationary");
                }
            }

            if (stationaryCheckTimeout) {
                clearTimeout(stationaryCheckTimeout);
                stationaryCheckTimeout = null;
            }

            if (isStationary) {
                stationaryCheckTimeout = setTimeout(() => checkStationaryState(newPosition), STATIONARY_CHECK_INTERVAL);
            }
        }

        // Predict position based on heading and speed
        function predictPositionFromHeading(position, heading, distance) {
            // Input validation
            if (
                !position ||
                typeof heading !== "number" ||
                typeof distance !== "number" ||
                !position.lat ||
                !position.lng ||
                isNaN(heading) ||
                isNaN(distance)
            ) {
                return position;
            }

            // Normalize heading to 0-360 range
            heading = ((heading % 360) + 360) % 360;

            // Earth's radius in meters
            const R = 6371e3;

            // Convert to radians
            const d = distance / R;
            const  = (heading * Math.PI) / 180;
            const 1 = (position.lat * Math.PI) / 180;
            const 1 = (position.lng * Math.PI) / 180;

            // Calculate predicted position with error handling
            try {
                const sin1 = Math.sin(1);
                const cos1 = Math.cos(1);
                const cosd = Math.cos(d);
                const sind = Math.sin(d);
                const cos = Math.cos();

                const 2 = Math.asin(sin1 * cosd + cos1 * sind * cos);

                const 2 = 1 + Math.atan2(Math.sin() * sind * cos1, cosd - sin1 * Math.sin(2));

                // Convert back to degrees with bounds checking
                const newLat = Math.max(-90, Math.min(90, (2 * 180) / Math.PI));
                const newLng = (((2 * 180) / Math.PI + 540) % 360) - 180;

                return {
                    lat: newLat,
                    lng: newLng,
                };
            } catch (error) {
                // Fallback to original position if calculation fails
                return position;
            }
        }

        // Main function to update user location
        function updateUserLocation(position, forceUpdate = false) {
            // Validate input position
            if (!position?.coords) {
                console.warn("Invalid position data received");
                return;
            }

            const currentTime = Date.now();

            // Throttle updates for performance
            if (!forceUpdate && currentTime - lastPositionUpdateTime < 16) {
                return;
            }
            lastPositionUpdateTime = currentTime;

            const timeDelta = lastUpdateTime ? (currentTime - lastUpdateTime) / 1000 : 0;

            // Create position object
            const newPosition = {
                lat: position.coords.latitude,
                lng: position.coords.longitude,
                accuracy: position.coords.accuracy || 20,
                heading: position.coords.heading !== null ? position.coords.heading : lastHeadingValue || undefined,
                timestamp: currentTime,
                speedMPS: position.coords.speed !== null ? position.coords.speed : 0,
            };

            if (isNaN(newPosition.lat) || isNaN(newPosition.lng)) {
                console.warn("Invalid coordinates received");
                return;
            }

            // Store raw position for comparison
            lastRawPosition = newPosition;

            // Track accuracy trend
            if (lastAccuracy !== null) {
                accuracyTrend.push(newPosition.accuracy - lastAccuracy);
                while (accuracyTrend.length > 5) accuracyTrend.shift();
            }
            lastAccuracy = newPosition.accuracy;

            // First position initialization
            if (!lastPosition) {
                lastPosition = newPosition;
                userMarker.setLatLng([newPosition.lat, newPosition.lng]);
                kalmanFilter.reset(newPosition);
                lastUpdateTime = currentTime;
                stationaryStartTime = currentTime;
                positionBuffer = [newPosition];
                lastStationaryPosition = newPosition;
                lastRenderPosition = newPosition;
                return;
            }

            // Calculate distance from last position
            const distance = calculateDistance(lastPosition, newPosition);

            // Handle large position changes or forced updates
            if (distance > EXTENDED_DISTANCE_THRESHOLD || forceUpdate) {
                if (stationaryCheckTimeout) {
                    clearTimeout(stationaryCheckTimeout);
                    stationaryCheckTimeout = null;
                }
                isStationary = false;
                stationaryStartTime = null;
                stationaryCount = 0;
                stationaryPositionHistory = [];
                lastStationaryPosition = null;
                consecutiveStationaryUpdates = 0;

                // Immediate visual update - no animation
                userMarker.setLatLng([newPosition.lat, newPosition.lng]);
                
                // Always recenter map to keep user centered
                if (followUser || forceCenteringActive) {
                    map.setView([newPosition.lat, newPosition.lng], map.getZoom(), {
                        animate: true,
                        duration: 0.3
                    });
                }

                // Reset tracking variables
                lastPosition = newPosition;
                lastRenderPosition = newPosition;
                positionBuffer = [newPosition];
                kalmanFilter.reset(newPosition);
                kalmanFilter.setStationaryMode(false);
                lastVelocity = { lat: 0, lng: 0 };

                // Cancel any active interpolation
                if (positionInterpolator) {
                    positionInterpolator.cancel();
                }

                // Clear any queued position updates
                positionUpdateQueue = [];

                lastUpdateTime = currentTime;
                lastUpdateTimestamp = currentTime;
                checkNearbyLocations();
                return;
            }

            // Skip updates with poor accuracy or unrealistic movement
            if (
                !forceUpdate &&
                (newPosition.accuracy > MAX_ACCEPTABLE_ACCURACY || (timeDelta > 0 && distance / timeDelta > 50))
            ) {
                console.debug("Skipping update due to poor accuracy or unrealistic movement");
                return;
            }

            try {
                // Check if device is in motion based on motion sensors
                const motionDetected = deviceMotion && isDeviceInMotion();

                // Enhanced stationary detection
                if (distance < MICRO_MOVEMENT_THRESHOLD && (!motionDetected || deviceStationaryTime > STATIONARY_TIME_THRESHOLD)) {
                    stationaryCount++;
                    consecutiveStationaryUpdates++;

                    if (!isStationary && stationaryCount >= STATIONARY_THRESHOLD) {
                        isStationary = true;
                        console.log("User is now stationary");

                        // Set Kalman filter to stationary mode
                        kalmanFilter.setStationaryMode(true);

                        // Update marker class
                        if (userMarkerElement) {
                            userMarkerElement.classList.add("user-marker-stationary");
                        }

                        // Calculate stable position from buffer
                        const stablePosition = calculateStationaryPosition(positionBuffer);
                        if (stablePosition) {
                            // Add to position update queue
                            positionUpdateQueue.push(stablePosition);
                            lastPosition = stablePosition;
                            lastStationaryPosition = stablePosition;
                        }

                        if (stationaryCheckTimeout) clearTimeout(stationaryCheckTimeout);
                        stationaryCheckTimeout = setTimeout(() => checkStationaryState(newPosition), STATIONARY_CHECK_INTERVAL);

                        checkNearbyLocations();
                        return;
                    }
                } else {
                    stationaryCount = Math.max(0, stationaryCount - 1);
                    consecutiveStationaryUpdates = 0;
                    if (isStationary && stationaryCount < STATIONARY_THRESHOLD / 2) {
                        isStationary = false;
                        kalmanFilter.setStationaryMode(false);

                        // Update marker class
                        if (userMarkerElement) {
                            userMarkerElement.classList.remove("user-marker-stationary");
                        }

                        console.log("User is moving again");
                    }
                }

                // Apply Kalman filter with motion detection
                const filteredPosition = kalmanFilter.update(newPosition, motionDetected);

                // Update position buffer
                updatePositionBuffer(filteredPosition);

                // Apply different smoothing based on movement state
                let finalPosition;

                if (isStationary) {
                    // When stationary, use the stable position with minimal updates
                    if (lastStationaryPosition) {
                        // Only update if accuracy significantly improves or after several updates
                        if (newPosition.accuracy < lastStationaryPosition.accuracy * 0.8 || consecutiveStationaryUpdates > 5) {
                            // Update stationary position history
                            updateStationaryHistory(filteredPosition);

                            // Calculate new stable position
                            const stablePosition = calculateStationaryPosition(positionBuffer);
                            if (stablePosition) {
                                // Smooth transition to new stable position
                                finalPosition = {
                                    lat: lerp(lastStationaryPosition.lat, stablePosition.lat, 0.1),
                                    lng: lerp(lastStationaryPosition.lng, stablePosition.lng, 0.1),
                                    accuracy: stablePosition.accuracy,
                                    heading: stablePosition.heading,
                                    timestamp: currentTime,
                                    speedMPS: 0,
                                };

                                // Add to position update queue
                                positionUpdateQueue.push(finalPosition);
                                lastPosition = finalPosition;
                                lastStationaryPosition = finalPosition;
                                consecutiveStationaryUpdates = 0;
                            } else {
                                finalPosition = lastStationaryPosition;
                            }
                        } else {
                            // Use existing stable position
                            finalPosition = lastStationaryPosition;
                        }
                    } else {
                        // If no stable position yet, calculate one
                        const stablePosition = calculateStationaryPosition(positionBuffer);
                        if (stablePosition) {
                            finalPosition = stablePosition;
                            lastStationaryPosition = stablePosition;

                            // Add to position update queue
                            positionUpdateQueue.push(finalPosition);
                        } else {
                            finalPosition = filteredPosition;

                            // Add to position update queue
                            positionUpdateQueue.push(finalPosition);
                        }
                        lastPosition = finalPosition;
                    }
                } else {
                    // Smooth movement when active
                    finalPosition = filteredPosition;

                    // Apply heading-based prediction for smoother movement
                    if (finalPosition.heading !== undefined && finalPosition.speedMPS > 0.5) {
                        const predictedPosition = predictPositionFromHeading(
                            finalPosition,
                            finalPosition.heading,
                            finalPosition.speedMPS * 0.3, // Predict slightly ahead
                        );

                        // Blend predicted and filtered positions
                        finalPosition = {
                            lat: lerp(finalPosition.lat, predictedPosition.lat, 0.2),
                            lng: lerp(finalPosition.lng, predictedPosition.lng, 0.2),
                            accuracy: finalPosition.accuracy,
                            heading: finalPosition.heading,
                            timestamp: currentTime,
                            speedMPS: finalPosition.speedMPS,
                        };
                    }

                    // Add to position update queue
                    positionUpdateQueue.push(finalPosition);
                    lastPosition = finalPosition;
                }

                lastUpdateTime = currentTime;
                lastUpdateTimestamp = currentTime;
                checkNearbyLocations();
            } catch (error) {
                console.error("Location update error:", error);
                // Fallback with basic filtering
                userMarker.setLatLng([newPosition.lat, newPosition.lng]);
                lastPosition = newPosition;
                lastRenderPosition = newPosition;
                checkNearbyLocations();
            }
        }

        // Handle position updates from geolocation API
        function handlePositionUpdate(position) {
            if (!position?.coords?.latitude || !position?.coords?.longitude) {
                console.warn("Invalid position data received");
                return;
            }

            const currentTime = Date.now();
            if (currentTime - lastUpdateTime >= 100 && !isPopupOpen()) {
                updateUserLocation(position);
                lastUpdateTime = currentTime;
            }
        }

        // Start position updates with high frequency
        function startPositionUpdates() {
            navigator.geolocation.watchPosition(handlePositionUpdate, handleLocationError, {
                enableHighAccuracy: true,
                maximumAge: 0,
                timeout: 10000,
            });
        }

        // Initialize map with enhanced settings
        function initMap() {
            map = L.map("map", {
                zoomControl: false,
                attributionControl: false,
                zoomSnap: 0.1,
                zoomDelta: 0.5,
                wheelDebounceTime: 100,
                tapTolerance: 15,
                bounceAtZoomLimits: false,
                preferCanvas: true, // Use canvas renderer for better performance
                renderer: L.canvas({ padding: 0.5 }),
            }).fitWorld();

            // Use a variable to store the tile layer for better performance
            mapTiles = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
                maxZoom: 19,
                attribution: " OpenStreetMap contributors",
                updateWhenIdle: true,
                updateWhenZooming: false,
                keepBuffer: 2,
            }).addTo(map);

            // Create user icon with custom styling for direction indication
            const userIcon = L.divIcon({
                className: "user-marker",
                html: '<div class="user-marker-icon"></div>',
                iconSize: [24, 24],
                iconAnchor: [12, 12],
            });

            userMarker = L.marker([0, 0], {
                icon: userIcon,
                zIndexOffset: 1000, // Ensure user marker is on top
                interactive: false, // Prevent marker from being clickable
            }).addTo(map);

            // Show preloader
            showPreloader();

            // Request motion and orientation permissions
            requestMotionPermission();

            if ("geolocation" in navigator) {
                const options = {
                    enableHighAccuracy: true,
                    timeout: 45000,
                    maximumAge: 0,
                };

                // Try first time
                navigator.geolocation.getCurrentPosition(
                    initializeUserLocation,
                    (error) => {
                        // On error, try one more time before falling back
                        navigator.geolocation.getCurrentPosition(initializeUserLocation, handleLocationError, options);
                    },
                    options
                );
            } else {
                showPopup("Geolocation is not supported by your browser");
                map.setView([44.9778, -93.265], 18);
                hidePreloader();
            }

            document.addEventListener("visibilitychange", handleVisibilityChange);

            map.on("movestart zoomstart", () => {
                isMapInteracting = true;
                userIsInteracting = true;
                lastMapMoveTime = Date.now();
                lastMapZoomTime = Date.now();
            });

            map.on("moveend zoomend", () => {
                // Delay setting isMapInteracting to false to prevent immediate recentering
                setTimeout(() => {
                    isMapInteracting = false;
                    userIsInteracting = false;
                    resetInactivityTimer();
                    
                    // Always re-enable follow mode after user interaction
                    setTimeout(() => {
                        followUser = true;
                    }, 500);
                }, 100);
            });

            // Start animation loop for smooth rendering
            startAnimationLoop();

            // Load tour locations
            loadLocations();
            
            // Set map as ready
            mapReady = true;
            
            // Check if we can hide preloader
            checkPreloadComplete();
        }

        // Check if preload is complete
        function checkPreloadComplete() {
            if (mapReady && locationDataReady && deviceReadyForLocation) {
                isPreloadComplete = true;
                hidePreloader();
            }
        }

        // Load tour locations
        function loadLocations() {
            gameLocations = locations;
            
            // Create markers for all locations
            gameLocations.forEach((location, index) => {
                // Create numbered marker icon
                const locationIcon = L.divIcon({
                    className: 'location-marker',
                    html: `<div class="location-marker-icon">${index + 1}</div>`,
                    iconSize: [40, 40],
                    iconAnchor: [20, 20]
                });
                
                const marker = L.marker([location.lat, location.lng], {
                    icon: locationIcon
                });
                
                // Add popup with location info
                const popupContent = `
                    <div class="marker-popup">
                        <img src="${location.image || '/placeholder.svg?height=150&width=280'}" class="marker-popup-image" alt="${location.name}">
                        <div class="marker-popup-content">
                            <div class="marker-popup-title">${location.name}</div>
                            <div class="marker-popup-description">${location.description.substring(0, 100)}...</div>
                            <div class="marker-popup-actions">
                                <button class="popup-btn directions" onclick="showDirectionsModal(gameLocations[${index}])">
                                    <i class="fas fa-directions"></i> Directions
                                </button>
                                <button class="popup-btn skip" onclick="skipToNextLocation()">
                                    <i class="fas fa-forward"></i> Skip
                                </button>
                            </div>
                        </div>
                    </div>
                `;
                
                const popup = L.popup({
                    closeButton: true,
                    autoClose: false,
                    closeOnEscapeKey: true,
                    closeOnClick: false,
                    className: 'custom-popup',
                    maxWidth: 300
                }).setContent(popupContent);
                
                marker.bindPopup(popup);
                
                // Add click event to marker
                marker.on('click', () => {
                    marker.openPopup();
                });
                
                allLocationMarkers.push(marker);
            });
            
            // Only show the first marker initially
            updateVisibleMarkers();
            
            // Set location data as ready
            locationDataReady = true;
            
            // Check if we can hide preloader
            checkPreloadComplete();
            
            // Preload images and audio
            preloadAssets();
        }
        
        // Preload images and audio
        function preloadAssets() {
            // Preload images
            gameLocations.forEach(location => {
                if (location.image) {
                    const img = new Image();
                    img.src = location.image;
                    img.onload = () => {
                        preloadedImages.set(location.id, img);
                    };
                }
                
                // Preload audio
                if (location.audio) {
                    const audio = new Audio();
                    audio.src = location.audio;
                    audio.preload = 'auto';
                    audio.load();
                    preloadedAudio.set(location.id, audio);
                }
            });
        }
        
        // Update visible markers based on current progress
        function updateVisibleMarkers() {
            // Remove all existing markers from map
            activeMarkers.forEach(marker => {
                map.removeLayer(marker);
            });
            activeMarkers = [];
            
            // Show only the current marker
            if (currentLocationIndex < allLocationMarkers.length) {
                allLocationMarkers[currentLocationIndex].addTo(map);
                activeMarkers.push(allLocationMarkers[currentLocationIndex]);
            }
        }

        // Initialize user location
        function initializeUserLocation(position) {
            if (!position?.coords) {
                handleLocationError({ code: 2, message: "Invalid position data" });
                return;
            }

            try {
                const initialPosition = {
                    lat: position.coords.latitude,
                    lng: position.coords.longitude,
                    accuracy: position.coords.accuracy || 20,
                    heading: position.coords.heading,
                    timestamp: Date.now(),
                    speedMPS: position.coords.speed || 0,
                };

                // Set initial marker position
                userMarker.setLatLng([initialPosition.lat, initialPosition.lng]);

                // Initialize Kalman filter
                kalmanFilter.reset(initialPosition);

                // Set map view
                map.setView([initialPosition.lat, initialPosition.lng], DEFAULT_ZOOM_LEVEL);

                // Initialize tracking variables
                lastPosition = initialPosition;
                lastRenderPosition = initialPosition;
                lastUpdateTime = Date.now();
                lastUpdateTimestamp = Date.now();

                // Start position updates
                startPositionUpdates();
                
                // Set device as ready for location
                deviceReadyForLocation = true;
                
                // Check if we can hide preloader
                checkPreloadComplete();

                // Update distance box
                checkNearbyLocations();

                // Show stabilizing modal
                showStabilizingModal();

                console.log("Location initialized successfully");
            } catch (error) {
                console.error("Error initializing location:", error);
                handleLocationError({ code: 2, message: "Error initializing location" });
            }
        }

        // Show stabilizing modal
        function showStabilizingModal() {
            const modal = document.createElement('div');
            modal.className = 'stabilizing-modal';
            modal.innerHTML = `
                <div class="spinner"></div>
                <h3>Stabilizing Your Location</h3>
                <p>Please wait while we fine-tune your position.</p>
            `;
            document.body.appendChild(modal);
            
            // Auto-dismiss after 5 seconds
            setTimeout(() => {
                modal.style.opacity = '0';
                modal.style.transition = 'opacity 0.5s ease';
                setTimeout(() => {
                    if (modal.parentNode) {
                        modal.parentNode.removeChild(modal);
                    }
                    isStabilizing = false;
                }, 500);
            }, 5000);
        }

        // Show location hunt
        function showLocationHunt(location) {
            isLocationHuntVisible = true;
            
            // Set location information
            document.getElementById('locationTitle').textContent = location.name;
            document.getElementById('locationCity').textContent = location.city;
            document.getElementById('locationCreator').textContent = `Created by: ${location.creator}`;
            document.getElementById('locationImage').src = location.image || '/placeholder.svg?height=200&width=400';
            document.getElementById('locationAudio').src = location.audio;
            document.getElementById('locationDescription').textContent = location.description;
            
            // Create navigation links
            createNavigationLinks(location);
            
            // Show location hunt container
            const lochuntContainer = document.querySelector('.lochunt-container');
            lochuntContainer.classList.add('active');
            
            // Initialize audio player
            initAudioPlayer();
            
            // Add to visited locations if not already visited
            if (!visitedLocations.includes(location.id)) {
                visitedLocations.push(location.id);
            }
        }

        // Initialize audio player
        function initAudioPlayer() {
            const audio = document.getElementById('locationAudio');
            const playPauseBtn = document.getElementById('playPauseBtn');
            const rewindBtn = document.getElementById('rewindBtn');
            const forwardBtn = document.getElementById('forwardBtn');
            const progressBar = document.getElementById('progressBar');
            const currentTimeSpan = document.getElementById('currentTime');
            const durationSpan = document.getElementById('duration');
            
            // Initialize audio context for better performance
            if (!audioContext && window.AudioContext) {
                try {
                    audioContext = new AudioContext();
                } catch (e) {
                    console.warn("AudioContext not supported");
                }
            }
            
            // Set up event listeners
            playPauseBtn.addEventListener('click', togglePlay);
            rewindBtn.addEventListener('click', () => seek(-10));
            forwardBtn.addEventListener('click', () => seek(10));
            audio.addEventListener('timeupdate', updateProgress);
            audio.addEventListener('loadedmetadata', setDuration);
            audio.addEventListener('ended', showTrivia);
            
            // Play/pause function
            function togglePlay() {
                if (audio.paused) {
                    // Resume AudioContext if it was suspended
                    if (audioContext && audioContext.state === 'suspended') {
                        audioContext.resume();
                    }
                    
                    audio.play()
                        .then(() => {
                            isAudioPlaying = true;
                            playPauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
                        })
                        .catch(err => {
                            console.error("Error playing audio:", err);
                            playPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
                        });
                } else {
                    audio.pause();
                    isAudioPlaying = false;
                    playPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
                    
                    // Store current position
                    audioPlaybackPosition = audio.currentTime;
                }
            }
            
            // Seek function
            function seek(seconds) {
                audio.currentTime = Math.max(0, Math.min(audio.currentTime + seconds, audio.duration));
                audioPlaybackPosition = audio.currentTime;
            }
            
            // Update progress bar
            function updateProgress() {
                const percent = (audio.currentTime / audio.duration) * 100;
                progressBar.style.width = `${percent}%`;
                currentTimeSpan.textContent = formatTime(audio.currentTime);
                audioPlaybackPosition = audio.currentTime;
            }
            
            // Set duration
            function setDuration() {
                durationSpan.textContent = formatTime(audio.duration);
            }
            
            // Format time (convert seconds to MM:SS format)
            function formatTime(time) {
                const minutes = Math.floor(time / 60);
                const seconds = Math.floor(time % 60);
                return `${minutes}:${seconds.toString().padStart(2, '0')}`;
            }
        }

        // Show trivia question
        function showTrivia() {
            // Hide location hunt container
            document.querySelector('.lochunt-container').classList.remove('active');
            
            // Get current location
            const currentLocation = gameLocations[currentLocationIndex];
            
            // Set trivia question
            document.getElementById('triviaQuestion').textContent = currentLocation.trivia.question;
            
            // Create trivia options
            const triviaOptions = document.getElementById('triviaOptions');
            triviaOptions.innerHTML = '';
            
            currentLocation.trivia.options.forEach((option, index) => {
                const button = document.createElement('button');
                button.className = 'trivia-option';
                button.textContent = option;
                button.dataset.index = index;
                button.addEventListener('click', checkAnswer);
                triviaOptions.appendChild(button);
            });
            
            // Show trivia container
            document.querySelector('.trivia-container').classList.add('active');
        }

        // Check trivia answer
        function checkAnswer(event) {
            const selectedIndex = parseInt(event.target.dataset.index);
            const currentLocation = gameLocations[currentLocationIndex];
            
            // Disable all buttons
            const buttons = document.querySelectorAll('.trivia-option');
            buttons.forEach(button => {
                button.disabled = true;
            });
            
            // Mark correct and incorrect answers
            buttons.forEach(button => {
                const index = parseInt(button.dataset.index);
                if (index === currentLocation.trivia.answer) {
                    button.classList.add('correct');
                } else if (index === selectedIndex) {
                    button.classList.add('incorrect');
                }
            });
            
            // Wait 2 seconds before proceeding
            setTimeout(() => {
                // Hide trivia container
                document.querySelector('.trivia-container').classList.remove('active');
                
                // Remove the current marker from the map
                if (currentLocationIndex < allLocationMarkers.length) {
                    map.removeLayer(allLocationMarkers[currentLocationIndex]);
                }
                
                // Move to next location or show congratulations
                currentLocationIndex++;
                isLocationHuntVisible = false;
                
                if (currentLocationIndex >= gameLocations.length) {
                    showCongratulations();
                } else {
                    // Update visible markers for the next location
                    updateVisibleMarkers();
                    
                    // Update distance box for new location
                    if (lastPosition) {
                        const location = gameLocations[currentLocationIndex];
                        const distance = calculateDistance(
                            { lat: lastPosition.lat, lng: lastPosition.lng },
                            { lat: location.lat, lng: location.lng }
                        );
                        const distanceFeet = Math.round(distance * 3.28084);
                        updateDistanceBox(location, distanceFeet);
                    }
                    
                    // Reset proximity state
                    isWithinProximity = false;
                    proximityZoomActive = false;
                }
            }, 2000);
        }

        // Show congratulations screen
        function showCongratulations() {
            document.getElementById('congratulations').style.display = 'flex';
        }

        // End tour function
        function endTour() {
            window.location.href = 'index.html';
        }

        // Show preloader
        function showPreloader() {
            const preloader = document.getElementById('preloader');
            if (preloader) {
                preloader.style.display = 'flex';
                
                // Animate progress bar
                const progressBar = document.getElementById('preloaderProgress');
                let progress = 0;
                const interval = setInterval(() => {
                    progress += 1;
                    if (progressBar) progressBar.style.width = `${progress}%`;
                    if (progress >= 100) clearInterval(interval);
                }, 50);
            }
        }

        // Hide preloader
        function hidePreloader() {
            const preloader = document.getElementById('preloader');
            if (preloader) {
                preloader.style.opacity = '0';
                preloader.style.transition = 'opacity 0.5s ease';
                setTimeout(() => {
                    preloader.style.display = 'none';
                }, 500);
            }
        }

        // Show popup
        function showPopup(message) {
            const popup = document.getElementById('popup');
            const popupMessage = document.getElementById('popupMessage');
            
            if (popup && popupMessage) {
                popupMessage.textContent = message;
                popup.style.display = 'flex';
            } else {
                alert(message);
            }
        }

        // Close popup
        function closePopup() {
            const popup = document.getElementById('popup');
            if (popup) {
                popup.style.display = 'none';
            }
        }

        // Check if popup is open
        function isPopupOpen() {
            const popup = document.getElementById('popup');
            return popup ? popup.style.display === 'flex' : false;
        }

        // Handle location errors
        function handleLocationError(error) {
            console.error("Geolocation error:", error);
            hidePreloader();
            
            let message = "Unable to access your location. ";
            
            switch(error.code) {
                case 1:
                    message += "Please enable location services for this website.";
                    break;
                case 2:
                    message += "Location information is unavailable.";
                    break;
                case 3:
                    message += "The request to get your location timed out.";
                    break;
                default:
                    message += "An unknown error occurred.";
            }
            
            showPopup(message);
        }

        // Handle visibility change
        function handleVisibilityChange() {
            if (document.hidden) {
                lastHiddenTime = Date.now();
                
                // Pause any active animations when app goes to background
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
                
                // Pause audio if playing
                if (isAudioPlaying) {
                    const audio = document.getElementById('locationAudio');
                    if (audio && !audio.paused) {
                        audio.pause();
                        audioPlaybackPosition = audio.currentTime;
                    }
                }
            } else {
                const hiddenDuration = Date.now() - lastHiddenTime;
                
                // Restart animation loop
                if (!animationFrameId) {
                    startAnimationLoop();
                }
                
                // Resume audio if it was playing
                if (isAudioPlaying) {
                    const audio = document.getElementById('locationAudio');
                    if (audio && audio.paused) {
                        audio.currentTime = audioPlaybackPosition;
                        audio.play().catch(err => console.error("Error resuming audio:", err));
                    }
                }
                
                if (hiddenDuration > BACKGROUND_THRESHOLD) {
                    // App was in background for significant time, reset tracking
                    if (userMarker && lastPosition) {
                        // Force position update
                        updateUserLocation({
                            coords: {
                                latitude: lastPosition.lat,
                                longitude: lastPosition.lng,
                                accuracy: lastPosition.accuracy,
                                heading: lastPosition.heading,
                                speed: lastPosition.speedMPS
                            }
                        }, true);
                        
                        // Force recentering
                        forceCenteringActive = true;
                        setTimeout(() => {
                            forceCenteringActive = false;
                        }, 2000);
                    }
                }
            }
        }

        // Reset inactivity timer
        function resetInactivityTimer() {
            if (inactivityTimer) {
                clearTimeout(inactivityTimer);
            }
            
            inactivityTimer = setTimeout(() => {
                if (!isMapInteracting && !userIsInteracting) {
                    followUser = true;
                    if (userMarker && userMarker.getLatLng()) {
                        map.setView(userMarker.getLatLng(), targetZoomLevel, {
                            animate: true,
                            duration: 0.5
                        });
                    }
                }
            }, INACTIVITY_TIMEOUT);
        }

        // Recenter map
        function recenterMap() {
            const recenterButton = document.getElementById('recenterButton');
            if (recenterButton) {
                recenterButton.style.backgroundColor = "var(--primary-color)";
                recenterButton.style.color = "white";
            }
            
            if (userMarker && userMarker.getLatLng()) {
                map.setView(userMarker.getLatLng(), targetZoomLevel, {
                    animate: true,
                    duration: 0.5
                });
                followUser = true;
                
                // Force centering for a short period
                forceCenteringActive = true;
                setTimeout(() => {
                    forceCenteringActive = false;
                }, 2000);
            }
            
            setTimeout(() => {
                if (recenterButton) {
                    recenterButton.style.backgroundColor = "var(--bg-color)";
                    recenterButton.style.color = "var(--primary-color)";
                }
            }, 500);
        }

        // Toggle navigation tips
        function toggleNavigationTips() {
            const tipsElement = document.querySelector('.navigation-tips');
            tipsElement.style.display = tipsElement.style.display === 'none' || tipsElement.style.display === '' ? 'block' : 'none';
        }

        // Close navigation tips
        function closeNavigationTips() {
            document.querySelector('.navigation-tips').style.display = 'none';
        }

        // Make functions available globally for event handlers
        window.showDirectionsModal = showDirectionsModal;
        window.closeDirectionsModal = closeDirectionsModal;
        window.skipToNextLocation = skipToNextLocation;
        window.closePopup = closePopup;
        window.endTour = endTour;

        // Add event listeners when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize map
            initMap();
            
            // Add event listeners for UI elements
            document.getElementById('recenterButton').addEventListener('click', recenterMap);
            document.getElementById('returnButton').addEventListener('click', () => showPopup('Are you sure you want to exit the tour?'));
            document.getElementById('tipsButton').addEventListener('click', toggleNavigationTips);
            document.querySelector('.navigation-tips .close-button').addEventListener('click', closeNavigationTips);
            
            // Initialize inactivity timer
            resetInactivityTimer();
            
            // Check for reduced motion preference
            if (window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                isReducedMotion = true;
            }
            
            // Add touch event listeners for better gesture detection
            document.addEventListener('touchstart', handleTouchStart, { passive: true });
            document.addEventListener('touchmove', handleTouchMove, { passive: true });
            document.addEventListener('touchend', handleTouchEnd, { passive: true });
        });
        
        // Touch event handlers for better gesture detection
        function handleTouchStart(event) {
            isTouchActive = true;
            lastTouchTime = Date.now();
            
            if (event.touches.length === 1) {
                touchStartPosition = {
                    x: event.touches[0].clientX,
                    y: event.touches[0].clientY
                };
                
                // Set timeout for long touch
                longTouchTimeout = setTimeout(() => {
                    isLongTouch = true;
                }, 500);
            } else if (event.touches.length === 2) {
                // Pinch gesture start
                isPinchActive = true;
                lastPinchDistance = Math.hypot(
                    event.touches[0].clientX - event.touches[1].clientX,
                    event.touches[0].clientY - event.touches[1].clientY
                );
            }
            
            gestureStartTime = Date.now();
            isGestureRecognized = false;
        }
        
        function handleTouchMove(event) {
            if (!isTouchActive) return;
            
            // Clear long touch timeout if moved
            if (longTouchTimeout) {
                clearTimeout(longTouchTimeout);
                longTouchTimeout = null;
            }
            
            if (event.touches.length === 1 && touchStartPosition) {
                // Pan gesture
                const currentPosition = {
                    x: event.touches[0].clientX,
                    y: event.touches[0].clientY
                };
                
                const deltaX = currentPosition.x - touchStartPosition.x;
                const deltaY = currentPosition.y - touchStartPosition.y;
                
                if (Math.abs(deltaX) > 10 || Math.abs(deltaY) > 10) {
                    isPanActive = true;
                    isGestureRecognized = true;
                    lastPanPosition = currentPosition;
                }
            } else if (event.touches.length === 2) {
                // Pinch gesture
                const currentPinchDistance = Math.hypot(
                    event.touches[0].clientX - event.touches[1].clientX,
                    event.touches[0].clientY - event.touches[1].clientY
                );
                
                if (Math.abs(currentPinchDistance - lastPinchDistance) > 10) {
                    isGestureRecognized = true;
                }
                
                lastPinchDistance = currentPinchDistance;
            }
        }
        
        function handleTouchEnd(event) {
            isTouchActive = false;
            
            // Clear long touch timeout
            if (longTouchTimeout) {
                clearTimeout(longTouchTimeout);
                longTouchTimeout = null;
            }
            
            // Reset touch state
            touchStartPosition = null;
            isPanActive = false;
            isPinchActive = false;
            isLongTouch = false;
            
            lastGestureEndTime = Date.now();
            
            // Reset map interaction after a short delay
            setTimeout(() => {
                isMapGestureActive = false;
            }, 300);
        }
    </script>
</body>
</html>
