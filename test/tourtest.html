<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Minnesota Then | Self-Guided Tours</title>
    <link rel="shortcut icon" type="image/x-icon" href="https://www.mnthen.com/images/mnthenfav.ico">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css">
    
    <style>
        /* Base styles */
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            position: relative;
        }
        
        #map {
            height: 100%;
            width: 100%;
            z-index: 1;
        }
        
        /* Enhanced Distance box - Improved for mobile readability */
        #distanceBox {
            position: absolute;
            top: 15px;
            left: 15px;
            background-color: rgba(255, 255, 255, 0.98);
            padding: 16px 20px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            font-size: 18px;
            font-weight: 600;
            color: #333;
            min-width: 200px;
            max-width: 320px;
            transition: all 0.3s ease;
            border-left: 6px solid #005f9e;
            display: flex;
            align-items: center;
            backdrop-filter: blur(5px);
        }

        #distanceBox .location-icon {
            margin-right: 15px;
            color: #005f9e;
            font-size: 24px;
        }

        #distanceBox .distance-info {
            display: flex;
            flex-direction: column;
        }

        #distanceBox .location-name {
            font-weight: 700;
            margin-bottom: 4px;
            color: #005f9e;
            font-size: 18px;
        }

        #distanceBox .distance-value {
            font-size: 16px;
            color: #444;
            font-weight: 500;
        }

        @media (max-width: 480px) {
            #distanceBox {
                max-width: 280px;
                padding: 14px 16px;
                left: 10px;
                top: 10px;
                font-size: 16px;
            }
            
            #distanceBox .location-icon {
                font-size: 22px;
                margin-right: 12px;
            }
            
            #distanceBox .location-name {
                font-size: 16px;
            }
            
            #distanceBox .distance-value {
                font-size: 14px;
            }
        }
        
        /* Location hunt container */
        .lochunt-container {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 80%;
            background-color: white;
            z-index: 1500;
            border-radius: 20px 20px 0 0;
            box-shadow: 0 -5px 20px rgba(0, 0, 0, 0.15);
            transform: translateY(100%);
            transition: transform 0.5s cubic-bezier(0.19, 1, 0.22, 1);
            overflow: hidden;
            display: none;
        }
        
        .lochunt-container.active {
            transform: translateY(0);
            display: block;
        }
        
        .lochunt-content {
            padding: 20px;
            overflow-y: auto;
            height: calc(100% - 200px);
        }
        
        #locationImage {
            width: 100%;
            height: 200px;
            object-fit: cover;
        }
        
        .lochunt-info {
            margin-bottom: 20px;
        }
        
        /* Audio player */
        .audio-player {
            margin-top: 20px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 10px;
        }
        
        .audio-progress {
            margin-bottom: 10px;
        }
        
        .audio-time {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #666;
            margin-bottom: 10px;
        }
        
        .audio-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .audio-button {
            background-color: white;
            border: 2px solid #005f9e;
            color: #005f9e;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .audio-button:hover {
            background-color: #005f9e;
            color: white;
        }
        
        /* Trivia container */
        .trivia-container {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background-color: white;
            z-index: 1500;
            border-radius: 20px 20px 0 0;
            box-shadow: 0 -5px 20px rgba(0, 0, 0, 0.15);
            padding: 20px;
            transform: translateY(100%);
            transition: transform 0.5s cubic-bezier(0.19, 1, 0.22, 1);
            display: none;
        }
        
        .trivia-container.active {
            transform: translateY(0);
            display: block;
        }
        
        .trivia-option {
            background-color: #f8f9fa;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .trivia-option:hover {
            background-color: #e9ecef;
        }
        
        .trivia-option.correct {
            background-color: #d4edda;
            border-color: #c3e6cb;
        }
        
        .trivia-option.incorrect {
            background-color: #f8d7da;
            border-color: #f5c6cb;
        }
        
        /* Map buttons */
        .map-buttons {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 1000;
        }
        
        .map-button {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background-color: white;
            border: none;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            color: #005f9e;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .map-button:hover {
            background-color: #f8f9fa;
            transform: scale(1.05);
        }
        
        .map-button.active {
            background-color: #005f9e;
            color: white;
        }
        
        /* Navigation tips */
        .navigation-tips {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
            padding: 20px;
            z-index: 2000;
            max-width: 90%;
            width: 350px;
            display: none;
        }
        
        .navigation-tips h3 {
            margin-bottom: 15px;
            color: #005f9e;
        }
        
        .navigation-tips ul {
            padding-left: 20px;
        }
        
        .navigation-tips li {
            margin-bottom: 10px;
        }
        
        .close-button {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: #666;
        }
        
        /* Congratulations */
        #congratulations {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 3000;
            color: white;
            text-align: center;
            padding: 20px;
            display: none;
        }
        
        #congratulations h2 {
            font-size: 32px;
            margin-bottom: 20px;
        }
        
        #congratulations p {
            font-size: 18px;
            margin-bottom: 30px;
            max-width: 600px;
        }
        
        #congratulations button {
            background-color: #005f9e;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 30px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        #congratulations button:hover {
            background-color: #004b7d;
            transform: scale(1.05);
        }
        
        /* Enhanced user marker styles */
        .user-marker-icon {
            width: 20px;
            height: 20px;
            background-color: #ff0000; /* Red user icon */
            border: 3px solid white;
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            position: relative;
            transition: transform 0.2s cubic-bezier(0.25, 0.1, 0.25, 1);
            will-change: transform;
        }
        
        .user-marker-icon::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 30px;
            height: 30px;
            background-color: rgba(255, 0, 0, 0.2); /* Red with opacity */
            border-radius: 50%;
            transform: translate(-50%, -50%);
            animation: pulse 2s infinite;
            will-change: transform, opacity;
        }
        
        @keyframes pulse {
            0% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
            100% {
                transform: translate(-50%, -50%) scale(2);
                opacity: 0;
            }
        }
        
        /* Stationary indicator */
        .user-marker-stationary .user-marker-icon {
            border-color: #00cc00;
            transition: border-color 0.5s ease-out;
        }
        
        .user-marker-stationary .user-marker-icon::after {
            background-color: rgba(0, 204, 0, 0.15);
            animation: stationaryPulse 3s infinite;
        }
        
        @keyframes stationaryPulse {
            0% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0.6;
            }
            50% {
                transform: translate(-50%, -50%) scale(1.3);
                opacity: 0.3;
            }
            100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0.6;
            }
        }
        
        /* Optimize for hardware acceleration */
        #map, .user-marker-icon, .lochunt-container, .trivia-container {
            transform: translateZ(0);
            backface-visibility: hidden;
            perspective: 1000px;
        }
        
        /* Stabilizing modal */
        .stabilizing-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            z-index: 2000;
            text-align: center;
            max-width: 80%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .stabilizing-modal h3 {
            margin-bottom: 15px;
            color: #005f9e; /* Blue */
        }
        
        .stabilizing-modal p {
            margin-bottom: 20px;
        }
        
        .stabilizing-modal .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(0, 95, 158, 0.2); /* Blue with opacity */
            border-top: 4px solid #005f9e; /* Blue */
            border-radius: 50%;
            margin-bottom: 20px;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Preloader styles */
        #preloader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }

        #preloader .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(0, 95, 158, 0.2);
            border-top: 5px solid #005f9e;
            border-radius: 50%;
            margin-bottom: 20px;
            animation: spin 1s linear infinite;
        }

        #preloader p {
            font-size: 18px;
            color: #333;
            margin-top: 15px;
        }

        #preloader .progress-container {
            width: 80%;
            max-width: 300px;
            height: 10px;
            background-color: #f0f0f0;
            border-radius: 5px;
            margin-top: 15px;
            overflow: hidden;
        }

        #preloader .progress-bar {
            height: 100%;
            background-color: #005f9e;
            width: 0%;
            transition: width 0.3s ease;
        }
        
        /* Popup styles */
        #popup {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 3000;
            display: none;
        }
        
        .popup-content {
            background-color: white;
            border-radius: 10px;
            padding: 20px;
            max-width: 90%;
            width: 350px;
            text-align: center;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
        }
        
        #popupMessage {
            margin-bottom: 20px;
        }
        
        .popup-button {
            background-color: #005f9e;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .popup-button:hover {
            background-color: #004b7d;
        }
        
        /* Enhanced Location marker styles with numbering */
        .location-marker-icon {
            width: 36px;
            height: 36px;
            background-color: #005f9e;
            border: 3px solid white;
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            position: relative;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 16px;
        }
        
        .location-marker-icon:hover {
            transform: scale(1.1);
            background-color: #004b7d;
        }
        
        /* Enhanced Marker popup styles */
        .marker-popup {
            max-width: 300px;
            padding: 0;
        }
        
        .marker-popup-image {
            width: 100%;
            height: 150px;
            object-fit: cover;
            border-radius: 8px 8px 0 0;
            margin-bottom: 0;
        }
        
        .marker-popup-content {
            padding: 15px;
        }
        
        .marker-popup-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 5px;
            color: #005f9e;
        }
        
        .marker-popup-description {
            font-size: 14px;
            margin-bottom: 15px;
            color: #444;
            line-height: 1.4;
        }
        
        .marker-popup-actions {
            display: flex;
            justify-content: space-between;
            gap: 10px;
        }
        
        .popup-btn {
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            flex: 1;
        }
        
        .popup-btn.directions {
            background-color: #005f9e;
            color: white;
            border: none;
        }
        
        .popup-btn.directions:hover {
            background-color: #004b7d;
        }
        
        .popup-btn.skip {
            background-color: #f8f9fa;
            color: #666;
            border: 1px solid #dee2e6;
        }
        
        .popup-btn.skip:hover {
            background-color: #e9ecef;
        }
        
        /* Directions modal */
        #directionsModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 3000;
            display: none;
        }
        
        .directions-modal-content {
            background-color: white;
            border-radius: 12px;
            padding: 20px;
            max-width: 90%;
            width: 320px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
        }
        
        .directions-modal-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 15px;
            color: #333;
            text-align: center;
        }
        
        .directions-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .direction-btn {
            padding: 12px;
            border-radius: 8px;
            font-size: 15px;
            font-weight: 500;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            text-decoration: none;
        }
        
        .direction-btn.google {
            background-color: #4285F4;
            color: white;
            border: none;
        }
        
        .direction-btn.apple {
            background-color: #000000;
            color: white;
            border: none;
        }
        
        .direction-btn.waze {
            background-color: #33CCFF;
            color: white;
            border: none;
        }
        
        .direction-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        
        .cancel-btn {
            background-color: #f8f9fa;
            color: #666;
            border: 1px solid #dee2e6;
            padding: 10px;
            border-radius: 8px;
            font-size: 15px;
            font-weight: 500;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s ease;
            width: 100%;
        }
        
        .cancel-btn:hover {
            background-color: #e9ecef;
        }
        
        /* Leaflet popup customization */
        .leaflet-popup-content-wrapper {
            padding: 0;
            overflow: hidden;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
        }
        
        .leaflet-popup-content {
            margin: 0;
            width: 280px !important;
        }
        
        .leaflet-popup-tip-container {
            margin-top: -1px;
        }
        
        .leaflet-popup-close-button {
            color: white !important;
            top: 5px !important;
            right: 5px !important;
            font-size: 20px !important;
            text-shadow: 0 0 3px rgba(0, 0, 0, 0.5);
        }
        
        /* Responsive adjustments */
        @media (max-width: 768px) {
            .lochunt-container {
                height: 90%;
            }
            
            .map-buttons {
                bottom: 15px;
                right: 15px;
            }
            
            .map-button {
                width: 45px;
                height: 45px;
                font-size: 18px;
            }
            
            #distanceBox {
                max-width: 250px;
                padding: 12px 15px;
            }
            
        }
        
        @media (max-width: 480px) {
            .lochunt-container {
                height: 95%;
            }
            
            .navigation-tips {
                width: 90%;
                padding: 15px;
            }
            
            .map-buttons {
                bottom: 10px;
                right: 10px;
                gap: 8px;
            }
            
            .map-button {
                width: 40px;
                height: 40px;
                font-size: 16px;
            }
            
            #distanceBox {
                max-width: 280px;
                padding: 14px 16px;
                left: 10px;
                top: 10px;
                font-size: 16px;
            }
            
            #distanceBox .location-icon {
                font-size: 22px;
                margin-right: 12px;
            }
            
            #distanceBox .location-name {
                font-size: 16px;
            }
            
            #distanceBox .distance-value {
                font-size: 14px;
            }
            
            
        
            .marker-popup {
                max-width: 260px;
            }
            
            .marker-popup-image {
                height: 130px;
            }
        }
    </style>
</head>
<body>
    <!-- Preloader -->
    <div id="preloader">
        <div class="spinner"></div>
        <p>Loading Minnesota Then Tours...</p>
        <div class="progress-container">
            <div class="progress-bar" id="preloaderProgress"></div>
        </div>
    </div>

    <div id="map"></div>
    
    <!-- Enhanced Distance Box -->
    <div id="distanceBox">
        <div class="location-icon">
            <i class="fas fa-map-marker-alt"></i>
        </div>
        <div class="distance-info">
            <div class="location-name">Initializing...</div>
            <div class="distance-value">Finding your location</div>
        </div>
    </div>

    

    <div class="lochunt-container">
        <img id="locationImage" src="/placeholder.svg" alt="Location Image">
        <div class="lochunt-content">
            <div class="lochunt-info">
                <h2 id="locationTitle" class="mb-2 text-primary"></h2>
                <p id="locationCity" class="text-muted mb-1"></p>
                <p id="locationCreator" class="text-muted mb-3"></p>
                <p id="locationDescription" class="mb-3"></p>
                
                <div class="marker-popup-navigation">
                    <a href="#" id="googleMapsLink" class="nav-button google" target="_blank">
                        <i class="fab fa-google"></i> Google Maps
                    </a>
                    <a href="#" id="appleMapsLink" class="nav-button apple" target="_blank">
                        <i class="fab fa-apple"></i> Apple Maps
                    </a>
                    <a href="#" id="wazeLink" class="nav-button waze" target="_blank">
                        <i class="fab fa-waze"></i> Waze
                    </a>
                </div>
            </div>
            <div class="audio-player">
                <div class="audio-progress">
                    <div class="progress">
                        <div id="progressBar" class="progress-bar" role="progressbar" style="width: 0%"></div>
                    </div>
                </div>
                <div class="audio-time">
                    <span id="currentTime">0:00</span>
                    <span id="duration">0:00</span>
                </div>
                <div class="audio-controls">
                    <button id="rewindBtn" class="audio-button"><i class="fas fa-backward"></i></button>
                    <button id="playPauseBtn" class="audio-button"><i class="fas fa-play"></i></button>
                    <button id="forwardBtn" class="audio-button"><i class="fas fa-forward"></i></button>
                </div>
                <audio id="locationAudio" src="/placeholder.svg"></audio>
            </div>
        </div>
    </div>
    
    <div class="trivia-container">
        <h3 class="mb-3 text-primary">Trivia Question</h3>
        <p id="triviaQuestion" class="mb-3 fw-bold"></p>
        <div id="triviaOptions" class="d-grid gap-2"></div>
    </div>
    
    <div class="map-buttons">
        <button id="recenterButton" class="map-button"><i class="fas fa-crosshairs"></i></button>
        <button id="returnButton" class="map-button"><i class="fas fa-sign-out-alt"></i></button>
        <button id="tipsButton" class="map-button"><i class="fas fa-question-circle"></i></button>
    </div>
    
    <div class="navigation-tips">
        <button class="close-button">&times;</button>
        <h3>Navigation Tips</h3>
        <ul>
            <li>Numbered markers show your tour stops in sequence.</li>
            <li>After visiting a location, the next stop will appear.</li>
            <li>Tap on a marker to see details and navigation options.</li>
            <li>The distance box shows how far you are from the current location.</li>
            <li>Tap the recenter button to focus on your position.</li>
            <li>When you're within 20 feet of a location, you'll be able to interact with it.</li>
            <li>Complete the trivia question to move to the next location.</li>
        </ul>
    </div>
    
    <div id="congratulations">
        <h2>Congratulations!</h2>
        <p>You have successfully completed the Minnesota Then Gangster History Tour!</p>
        <button onclick="endTour()">Return to the Home Page</button>
    </div>
    
    <div id="popup">
        <div class="popup-content">
            <p id="popupMessage"></p>
            <button class="popup-button" onclick="closePopup()">OK</button>
        </div>
    </div>
    
    <!-- Directions Modal -->
    <div id="directionsModal">
        <div class="directions-modal-content">
            <div class="directions-modal-title">Choose Navigation App</div>
            <div class="directions-buttons">
                <a href="#" id="googleMapsBtn" class="direction-btn google" target="_blank">
                    <i class="fab fa-google"></i> Google Maps
                </a>
                <a href="#" id="appleMapsBtn" class="direction-btn apple" target="_blank">
                    <i class="fab fa-apple"></i> Apple Maps
                </a>
                <a href="#" id="wazeBtn" class="direction-btn waze" target="_blank">
                    <i class="fab fa-waze"></i> Waze
                </a>
            </div>
            <button class="cancel-btn" onclick="closeDirectionsModal()">Cancel</button>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    
    <script>
        // Sample locations data (replace with your actual data)
        const locations = [
            {
                id: 1,
                name: "Landmark Center",
                city: "St. Paul",
                creator: "Minnesota Historical Society",
                lat: 44.9448,
                lng: -93.0962,
                image: "https://www.mnthen.com/images/landmark-center.jpg",
                audio: "https://www.mnthen.com/audio/landmark-center.mp3",
                description: "The Landmark Center, completed in 1902, originally served as the Federal Court House and Post Office for the Upper Midwest. This Richardsonian Romanesque building was where many famous gangsters were tried during the 1930s.",
                trivia: {
                    question: "What was the Landmark Center originally built as?",
                    options: [
                        "A hotel",
                        "A federal courthouse and post office",
                        "A train station",
                        "A department store"
                    ],
                    answer: 1
                }
            },
            {
                id: 2,
                name: "Wabasha Street Caves",
                city: "St. Paul",
                creator: "Minnesota Historical Society",
                lat: 44.9338,
                lng: -93.1059,
                image: "https://www.mnthen.com/images/wabasha-caves.jpg",
                audio: "https://www.mnthen.com/audio/wabasha-caves.mp3",
                description: "The Wabasha Street Caves were originally mined for silica in the 1840s. During Prohibition, the caves became a speakeasy known as the Castle Royal. Gangsters like John Dillinger and Ma Barker were rumored to frequent the establishment.",
                trivia: {
                    question: "What illegal activity took place in the Wabasha Street Caves during Prohibition?",
                    options: [
                        "Counterfeiting money",
                        "Illegal gambling",
                        "Speakeasy and nightclub",
                        "All of the above"
                    ],
                    answer: 3
                }
            },
            {
                id: 3,
                name: "Nina's Coffee Cafe",
                city: "St. Paul",
                creator: "Minnesota Historical Society",
                lat: 44.9463,
                lng: -93.1032,
                image: "https://www.mnthen.com/images/ninas-cafe.jpg",
                audio: "https://www.mnthen.com/audio/ninas-cafe.mp3",
                description: "Nina's Coffee Cafe is located in the historic Blair Flats building. The building is rumored to have been a hideout for Al Capone during his visits to St. Paul. The cafe now serves as a popular community gathering spot.",
                trivia: {
                    question: "Which famous gangster was rumored to have a hideout above what is now Nina's Coffee Cafe?",
                    options: [
                        "Al Capone",
                        "John Dillinger",
                        "Ma Barker",
                        "Baby Face Nelson"
                    ],
                    answer: 0
                }
            }
        ];

        // Global variables
        let map, userMarker;
        let currentLocationIndex = 0;
        let visitedLocations = [];
        let gameLocations = [];
        let inactivityTimer;
        let isLocationHuntVisible = false;
        let lastPosition = null;
        let positionBuffer = [];
        const MAX_BUFFER_SIZE = 15; // Increased buffer size for smoother tracking
        const DISTANCE_THRESHOLD = 20; // 20 feet to measure threshold distance to marker before opening location page
        const velocity = { lat: 0, lng: 0 };
        let isMapInteracting = false;
        let followUser = true;
        let allLocationMarkers = [];
        let showingAllLocations = false; // Always false now that we've removed the toggle
        let userIsInteracting = false;
        const preloadedImages = new Map(); // Map to store preloaded images
        const preloadedAudio = new Map(); // Map to store preloaded audio
        let currentSpeed = 0; // Current speed in meters per second
        let lastZoomLevel = 18; // Default zoom level
        let stationaryPositionHistory = []; // Array to store stationary positions for averaging
        let deviceOrientation = null; // Store device orientation data
        let deviceMotion = null; // Store device motion data
        let orientationPermissionGranted = false;
        let activeMarkers = []; // Track currently visible markers
        let currentDirectionsLocation = null; // Store current location for directions modal

        // Enhanced constants for better stabilization
        const MICRO_MOVEMENT_THRESHOLD = 0.3; // Meters - threshold for detecting micro-movements
        const STATIONARY_ACCURACY_MULTIPLIER = 1.02; // Tighter accuracy bounds
        const MAX_ACCEPTABLE_ACCURACY = 25; // meters - stricter accuracy requirement
        const STATIONARY_THRESHOLD = 5; // Number of consecutive stationary positions to consider user as stationary
        const STATIONARY_TIME_THRESHOLD = 2000; // ms - time to consider user stationary
        const STATIONARY_CHECK_INTERVAL = 1000; // ms - interval to check if still stationary
        const VELOCITY_DECAY = 0.92; // Higher value for smoother velocity transitions
        const MIN_DISTANCE_THRESHOLD = 0.8; // meters - minimum distance to consider movement
        const EXTENDED_DISTANCE_THRESHOLD = 80; // meters - distance to consider a significant position change
        const UPDATE_INTERVAL = 16; // ms - more frequent updates for smoother animation (approx 60fps)
        const STATIONARY_POSITION_HISTORY_SIZE = 15; // Number of positions to keep for stationary averaging
        const STATIONARY_POSITION_WEIGHT_DECAY = 0.9; // Weight decay for older positions in stationary average

        // Background handling constants
        const BACKGROUND_THRESHOLD = 20000; // ms - time to consider app was in background
        const INACTIVITY_TIMEOUT = 25000; // ms - time to consider user inactive

        // Kalman filter parameters - optimized for better stationary stability
        const KALMAN_PROCESS_NOISE = 0.004; // Lower value for smoother tracking
        const KALMAN_MEASUREMENT_NOISE_BASE = 1.2; // Increased base measurement noise
        const KALMAN_STATIONARY_NOISE = 0.02; // Lower noise when stationary

        // Animation parameters
        const ANIMATION_DURATION = 180; // ms - duration of position animation
        const HEADING_SMOOTHING = 0.9; // Heading smoothing factor

        // Dynamic zoom level parameters - enhanced for better speed adaptation
        const MAX_ZOOM_LEVEL = 19; // Maximum zoom level (stationary)
        const MIN_ZOOM_LEVEL = 14; // Minimum zoom level (high speed)
        const DEFAULT_ZOOM_LEVEL = 18; // Default zoom level for walking speed
        const WALKING_SPEED_THRESHOLD = 1.5; // m/s - threshold for walking speed
        const RUNNING_SPEED_THRESHOLD = 4.0; // m/s - threshold for running speed
        const DRIVING_SPEED_THRESHOLD = 8.0; // m/s - threshold for driving speed
        const HIGH_SPEED_THRESHOLD = 20.0; // m/s - threshold for high speed
        const ZOOM_TRANSITION_DURATION = 0.5; // seconds - duration of zoom transition
        const ZOOM_UPDATE_INTERVAL = 1000; // ms - interval to update zoom level

        // Motion detection parameters
        const MOTION_THRESHOLD = 0.6; // Threshold for detecting significant motion
        const MOTION_SAMPLE_SIZE = 8; // Number of motion samples to keep
        const MOTION_CHECK_INTERVAL = 100; // ms - interval to check motion

        // Edge detection parameters - updated for better recentering
        const EDGE_THRESHOLD_PERCENTAGE = 0.15; // Percentage from edge to trigger recenter
        const STRICT_EDGE_THRESHOLD_PERCENTAGE = 0.1; // Stricter threshold for edge detection
        const CRITICAL_EDGE_THRESHOLD_PERCENTAGE = 0.05; // Critical threshold for immediate recenter
        const RECENTER_COOLDOWN = 500; // ms - cooldown between recenters to prevent excessive recentering

        // Dynamic recentering parameters
        const SPEED_RECENTER_THRESHOLD = 5.0; // m/s - speed threshold to adjust recenter behavior
        const RECENTER_OFFSET_FACTOR = 0.3; // Factor to offset the center point ahead of user when moving fast

        // State variables
        let lastUpdateTime = null;
        let lastVelocity = { lat: 0, lng: 0 };
        let isStationary = false;
        let stationaryStartTime = null;
        let stationaryCheckTimeout = null;
        let lastUpdateTimestamp = null;
        let lastHiddenTime = 0;
        let stationaryCount = 0;
        let lastRecenterTime = Date.now();
        let stationaryBuffer = [];
        let isStabilizing = true; // Flag to track initial stabilization
        let lastStationaryPosition = null; // Last stable position when stationary
        let motionSamples = []; // Array to store motion samples
        let deviceStationaryTime = 0; // Time device has been stationary based on motion sensors
        let animationFrameId = null; // Store requestAnimationFrame ID
        let renderTimestamp = null; // Last render timestamp
        let positionUpdateQueue = []; // Queue for position updates to be processed
        let lastHeadingValue = null; // Last heading value
        let headingBuffer = []; // Buffer for heading values
        let isFirstPositionUpdate = true; // Flag for first position update
        let lastRenderPosition = null; // Last rendered position
        let positionInterpolator = null; // Position interpolator for smooth transitions
        let lastRawPosition = null; // Last raw position from GPS
        let consecutiveStationaryUpdates = 0; // Count consecutive stationary updates
        let lastDeviceMotionTimestamp = 0; // Last device motion timestamp
        let deviceMotionBuffer = []; // Buffer for device motion data
        let isDeviceStable = false; // Flag for device stability
        let lastAccuracy = null; // Last position accuracy
        let accuracyTrend = []; // Track accuracy trend
        let lastHeadingUpdateTime = 0; // Last heading update time
        let lastPositionUpdateTime = 0; // Last position update time
        let lastZoomUpdateTime = 0; // Last zoom update time
        let targetZoomLevel = DEFAULT_ZOOM_LEVEL; // Target zoom level for smooth transitions
        let lastSpeedForZoom = 0; // Last speed used for zoom calculation
        let speedSamples = []; // Array to store speed samples for zoom calculation
        let lastRecenterCheckTime = 0; // Last time we checked for recentering

        // Enhanced Kalman Filter implementation
        class KalmanFilter {
            constructor() {
                // State variables
                this.x = 0; // Longitude estimate
                this.y = 0; // Latitude estimate
                this.vx = 0; // Longitude velocity
                this.vy = 0; // Latitude velocity

                // Error covariance matrix
                this.P = [
                    [100, 0, 0, 0], // Initial high uncertainty
                    [0, 100, 0, 0],
                    [0, 0, 10, 0],
                    [0, 0, 0, 10],
                ];

                // Process noise
                this.Q = KALMAN_PROCESS_NOISE;

                // Measurement noise (will be adjusted based on GPS accuracy)
                this.R = KALMAN_MEASUREMENT_NOISE_BASE;

                // Time delta
                this.dt = 1.0;

                // Initialized flag
                this.initialized = false;

                // Heading and accuracy tracking
                this.lastHeading = null;
                this.headingConfidence = 0;

                // Stationary mode flag
                this.stationaryMode = false;

                // Last timestamp
                this.lastTimestamp = null;

                // Adaptive noise parameters
                this.adaptiveNoiseMin = 0.002;
                this.adaptiveNoiseMax = 0.015;
                this.adaptiveNoiseFactor = 1.0;

                // Accuracy history
                this.accuracyHistory = [];
                this.maxAccuracyHistorySize = 5;

                // Jitter detection
                this.positionHistory = [];
                this.maxPositionHistorySize = 5;
                this.jitterThreshold = 0.5; // meters

                // Heading stability
                this.headingHistory = [];
                this.maxHeadingHistorySize = 8;
            }

            // Initialize the filter with first position
            reset(position) {
                if (!position || typeof position.lat !== "number" || typeof position.lng !== "number") {
                    console.error("Invalid position for Kalman filter reset");
                    return;
                }

                this.x = position.lng;
                this.y = position.lat;
                this.vx = 0;
                this.vy = 0;

                // Reset covariance matrix with high initial uncertainty
                this.P = [
                    [100, 0, 0, 0],
                    [0, 100, 0, 0],
                    [0, 0, 10, 0],
                    [0, 0, 0, 10],
                ];

                this.initialized = true;
                this.lastHeading = position.heading || null;
                this.headingConfidence = 0;
                this.stationaryMode = false;
                this.lastTimestamp = position.timestamp || Date.now();
                this.adaptiveNoiseFactor = 1.0;
                this.accuracyHistory = [];
                this.positionHistory = [];
                this.headingHistory = [];

                // Add initial position to history
                this.addToPositionHistory(position);
                if (position.accuracy) {
                    this.addToAccuracyHistory(position.accuracy);
                }
                if (position.heading !== null && position.heading !== undefined) {
                    this.addToHeadingHistory(position.heading);
                }
            }

            // Add position to history
            addToPositionHistory(position) {
                this.positionHistory.push({
                    lat: position.lat,
                    lng: position.lng,
                    timestamp: position.timestamp || Date.now(),
                });

                while (this.positionHistory.length > this.maxPositionHistorySize) {
                    this.positionHistory.shift();
                }
            }

            // Add accuracy to history
            addToAccuracyHistory(accuracy) {
                this.accuracyHistory.push(accuracy);

                while (this.accuracyHistory.length > this.maxAccuracyHistorySize) {
                    this.accuracyHistory.shift();
                }
            }

            // Add heading to history
            addToHeadingHistory(heading) {
                // Normalize heading to 0-360
                heading = ((heading % 360) + 360) % 360;

                this.headingHistory.push({
                    heading: heading,
                    timestamp: Date.now(),
                });

                while (this.headingHistory.length > this.maxHeadingHistorySize) {
                    this.headingHistory.shift();
                }
            }

            // Get median accuracy from history
            getMedianAccuracy() {
                if (this.accuracyHistory.length === 0) return 20;

                const sortedAccuracies = [...this.accuracyHistory].sort((a, b) => a - b);
                const mid = Math.floor(sortedAccuracies.length / 2);

                if (sortedAccuracies.length % 2 === 0) {
                    return (sortedAccuracies[mid - 1] + sortedAccuracies[mid]) / 2;
                } else {
                    return sortedAccuracies[mid];
                }
            }

            // Detect jitter in position history
            detectJitter() {
                if (this.positionHistory.length < 3) return false;

                // Calculate distances between consecutive positions
                const distances = [];
                for (let i = 1; i < this.positionHistory.length; i++) {
                    const p1 = this.positionHistory[i - 1];
                    const p2 = this.positionHistory[i];

                    // Calculate distance in meters
                    const distance = calculateDistance(p1, p2);

                    // Calculate time delta in seconds
                    const timeDelta = (p2.timestamp - p1.timestamp) / 1000;

                    // Calculate speed in m/s
                    const speed = timeDelta > 0 ? distance / timeDelta : 0;

                    distances.push({ distance, speed });
                }

                // Check for rapid direction changes (jitter)
                if (distances.length >= 2) {
                    const lastDistance = distances[distances.length - 1].distance;
                    const prevDistance = distances[distances.length - 2].distance;

                    // If both distances are small but non-zero, it might be jitter
                    if (
                        lastDistance > 0 &&
                        lastDistance < this.jitterThreshold &&
                        prevDistance > 0 &&
                        prevDistance < this.jitterThreshold
                    ) {
                        return true;
                    }
                }

                return false;
            }

            // Get stable heading from history
            getStableHeading() {
                if (this.headingHistory.length < 3) {
                    return this.lastHeading;
                }

                // Get recent headings (last 3)
                const recentHeadings = this.headingHistory.slice(-3).map((h) => h.heading);

                // Check if headings are stable (within 15 degrees of each other)
                let isStable = true;
                for (let i = 1; i < recentHeadings.length; i++) {
                    const diff = Math.abs(recentHeadings[i] - recentHeadings[i - 1]);
                    const normalizedDiff = Math.min(diff, 360 - diff);
                    if (normalizedDiff > 15) {
                        isStable = false;
                        break;
                    }
                }

                if (isStable) {
                    // Return median heading
                    const sortedHeadings = [...recentHeadings].sort((a, b) => a - b);
                    return sortedHeadings[Math.floor(sortedHeadings.length / 2)];
                }

                return this.lastHeading;
            }

            // Set stationary mode
            setStationaryMode(isStationary) {
                this.stationaryMode = isStationary;

                // When entering stationary mode, reduce velocity to zero
                if (isStationary) {
                    this.vx = 0;
                    this.vy = 0;

                    // Reduce process noise for stationary mode
                    this.Q = KALMAN_STATIONARY_NOISE;
                    this.adaptiveNoiseFactor = 0.4; // Reduce noise in stationary mode
                } else {
                    // Reset to normal process noise when moving
                    this.Q = KALMAN_PROCESS_NOISE;
                    this.adaptiveNoiseFactor = 1.0; // Normal noise when moving
                }
            }

            // Adjust process noise based on accuracy and motion
            adjustProcessNoise(accuracy, motionDetected) {
                // Base noise level depends on GPS accuracy
                let noiseLevel =
                    this.adaptiveNoiseMin + (this.adaptiveNoiseMax - this.adaptiveNoiseMin) * Math.min(1.0, accuracy / 40.0);

                // Reduce noise when stationary
                if (this.stationaryMode) {
                    noiseLevel *= 0.4;
                }

                // Increase noise when motion is detected
                if (motionDetected && !this.stationaryMode) {
                    noiseLevel *= 1.8;
                }

                // Increase noise when jitter is detected
                if (this.detectJitter()) {
                    noiseLevel *= 0.5; // Reduce noise to smooth out jitter
                }

                // Apply adaptive factor
                noiseLevel *= this.adaptiveNoiseFactor;

                // Set process noise
                this.Q = noiseLevel;
            }

            // Update the filter with new measurement
            update(position, motionDetected = false) {
                if (!this.initialized) {
                    this.reset(position);
                    return position;
                }

                if (!position || typeof position.lat !== "number" || typeof position.lng !== "number") {
                    console.warn("Invalid position input to Kalman filter");
                    return {
                        lat: this.y,
                        lng: this.x,
                        accuracy: position?.accuracy || 20,
                        heading: this.lastHeading,
                        timestamp: position?.timestamp || Date.now(),
                    };
                }

                // Add to position history
                this.addToPositionHistory(position);

                // Add to accuracy history
                if (position.accuracy) {
                    this.addToAccuracyHistory(position.accuracy);
                }

                // Add to heading history
                if (position.heading !== null && position.heading !== undefined) {
                    this.addToHeadingHistory(position.heading);
                }

                // Calculate time delta
                const timestamp = position.timestamp || Date.now();
                if (this.lastTimestamp) {
                    this.dt = Math.min(Math.max((timestamp - this.lastTimestamp) / 1000, 0.01), 1.0);
                }
                this.lastTimestamp = timestamp;

                // Adjust measurement noise based on GPS accuracy
                const accuracy = position.accuracy || 20;
                const medianAccuracy = this.getMedianAccuracy();
                this.R = Math.max(KALMAN_MEASUREMENT_NOISE_BASE, medianAccuracy / 10);

                // If in stationary mode, increase measurement noise to reduce jitter
                if (this.stationaryMode) {
                    this.R *= 2.0;
                }

                // Adjust process noise based on accuracy and motion
                this.adjustProcessNoise(accuracy, motionDetected);

                // State transition matrix
                const F = [
                    [1, 0, this.dt, 0],
                    [0, 1, 0, this.dt],
                    [0, 0, 1, 0],
                    [0, 0, 0, 1],
                ];

                // Predict step
                // x = F * x
                const predictedX = this.x + this.dt * this.vx;
                const predictedY = this.y + this.dt * this.vy;
                const predictedVx = this.stationaryMode ? 0 : this.vx;
                const predictedVy = this.stationaryMode ? 0 : this.vy;

                // P = F * P * F' + Q
                const Q = [
                    [(this.Q * this.dt * this.dt * this.dt * this.dt) / 4, 0, (this.Q * this.dt * this.dt * this.dt) / 2, 0],
                    [0, (this.Q * this.dt * this.dt * this.dt * this.dt) / 4, 0, (this.Q * this.dt * this.dt * this.dt) / 2],
                    [(this.Q * this.dt * this.dt * this.dt) / 2, 0, this.Q * this.dt * this.dt, 0],
                    [0, (this.Q * this.dt * this.dt * this.dt) / 2, 0, this.Q * this.dt * this.dt],
                ];

                // Matrix multiplication F * P
                const FP = [
                    [
                        this.P[0][0] + this.dt * this.P[2][0],
                        this.P[0][1] + this.dt * this.P[2][1],
                        this.P[0][2] + this.dt * this.P[2][2],
                        this.P[0][3] + this.dt * this.P[2][3],
                    ],
                    [
                        this.P[1][0] + this.dt * this.P[3][0],
                        this.P[1][1] + this.dt * this.P[3][1],
                        this.P[1][2] + this.dt * this.P[3][2],
                        this.P[1][3] + this.dt * this.P[3][3],
                    ],
                    [this.P[2][0], this.P[2][1], this.P[2][2], this.P[2][3]],
                    [this.P[3][0], this.P[3][1], this.P[3][2], this.P[3][3]],
                ];

                // Matrix multiplication FP * F'
                const predictedP = [
                    [
                        FP[0][0] + this.dt * FP[0][2] + Q[0][0],
                        FP[0][1] + this.dt * FP[0][3] + Q[0][1],
                        FP[0][2] + Q[0][2],
                        FP[0][3] + Q[0][3],
                    ],
                    [
                        FP[1][0] + this.dt * FP[1][2] + Q[1][0],
                        FP[1][1] + this.dt * FP[1][3] + Q[1][1],
                        FP[1][2] + Q[1][2],
                        FP[1][3] + Q[1][3],
                    ],
                    [FP[2][0] + Q[2][0], FP[2][1] + Q[2][1], FP[2][2] + Q[2][2], FP[2][3] + Q[2][3]],
                    [FP[3][0] + Q[3][0], FP[3][1] + Q[3][1], FP[3][2] + Q[3][2], FP[3][3] + Q[3][3]],
                ];

                // Update step
                // y = z - H * x
                const measurementResidualX = position.lng - predictedX;
                const measurementResidualY = position.lat - predictedY;

                // S = H * P * H' + R
                const S = [
                    [predictedP[0][0] + this.R, predictedP[0][1]],
                    [predictedP[1][0], predictedP[1][1] + this.R],
                ];

                // Calculate determinant of S
                const detS = S[0][0] * S[1][1] - S[0][1] * S[1][0];

                // Calculate inverse of S
                const invS = [
                    [S[1][1] / detS, -S[0][1] / detS],
                    [-S[1][0] / detS, S[0][0] / detS],
                ];

                // K = P * H' * inv(S)
                const K = [
                    [
                        predictedP[0][0] * invS[0][0] + predictedP[0][1] * invS[1][0],
                        predictedP[0][0] * invS[0][1] + predictedP[0][1] * invS[1][1],
                    ],
                    [
                        predictedP[1][0] * invS[0][0] + predictedP[1][1] * invS[1][0],
                        predictedP[1][0] * invS[0][1] + predictedP[1][1] * invS[1][1],
                    ],
                    [
                        predictedP[2][0] * invS[0][0] + predictedP[2][1] * invS[1][0],
                        predictedP[2][0] * invS[0][1] + predictedP[2][1] * invS[1][1],
                    ],
                    [
                        predictedP[3][0] * invS[0][0] + predictedP[3][1] * invS[1][0],
                        predictedP[3][0] * invS[0][1] + predictedP[3][1] * invS[1][1],
                    ],
                ];

                // x = x + K * y
                this.x = predictedX + K[0][0] * measurementResidualX + K[0][1] * measurementResidualY;
                this.y = predictedY + K[1][0] * measurementResidualX + K[1][1] * measurementResidualY;

                // In stationary mode, keep velocity at zero
                if (this.stationaryMode) {
                    this.vx = 0;
                    this.vy = 0;
                } else {
                    this.vx = predictedVx + K[2][0] * measurementResidualX + K[2][1] * measurementResidualY;
                    this.vy = predictedVy + K[3][0] * measurementResidualX + K[3][1] * measurementResidualY;
                }

                // P = (I - K * H) * P
                this.P = [
                    [
                        predictedP[0][0] - (K[0][0] * predictedP[0][0] + K[0][1] * predictedP[1][0]),
                        predictedP[0][1] - (K[0][0] * predictedP[0][1] + K[0][1] * predictedP[1][1]),
                        predictedP[0][2] - (K[0][0] * predictedP[0][2] + K[0][1] * predictedP[1][2]),
                        predictedP[0][3] - (K[0][0] * predictedP[0][3] + K[0][1] * predictedP[1][3]),
                    ],
                    [
                        predictedP[1][0] - (K[1][0] * predictedP[0][0] + K[1][1] * predictedP[1][0]),
                        predictedP[1][1] - (K[1][0] * predictedP[0][1] + K[1][1] * predictedP[1][1]),
                        predictedP[1][2] - (K[1][0] * predictedP[0][2] + K[1][1] * predictedP[1][2]),
                        predictedP[1][3] - (K[1][0] * predictedP[0][3] + K[1][1] * predictedP[1][3]),
                    ],
                    [
                        predictedP[2][0] - (K[2][0] * predictedP[0][0] + K[2][1] * predictedP[1][0]),
                        predictedP[2][1] - (K[2][0] * predictedP[0][1] + K[2][1] * predictedP[1][1]),
                        predictedP[2][2] - (K[2][0] * predictedP[0][2] + K[2][1] * predictedP[1][2]),
                        predictedP[2][3] - (K[2][0] * predictedP[0][3] + K[2][1] * predictedP[1][3]),
                    ],
                    [
                        predictedP[3][0] - (K[3][0] * predictedP[0][0] + K[3][1] * predictedP[1][0]),
                        predictedP[3][1] - (K[3][0] * predictedP[0][1] + K[3][1] * predictedP[1][1]),
                        predictedP[3][2] - (K[3][0] * predictedP[0][2] + K[3][1] * predictedP[1][2]),
                        predictedP[3][3] - (K[3][0] * predictedP[0][3] + K[3][1] * predictedP[1][3]),
                    ],
                ];

                // Process heading data
                let smoothedHeading = position.heading;
                if (position.heading !== null && position.heading !== undefined) {
                    // Get stable heading from history
                    smoothedHeading = this.getStableHeading();

                    // If no stable heading yet, use current heading
                    if (smoothedHeading === null) {
                        smoothedHeading = position.heading;
                    }

                    this.lastHeading = smoothedHeading;
                }

                // Calculate speed from velocity components
                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);

                return {
                    lat: this.y,
                    lng: this.x,
                    accuracy: position.accuracy,
                    heading: smoothedHeading,
                    timestamp: position.timestamp,
                    speedMPS: this.stationaryMode ? 0 : speed * 111000, // Convert from degrees/second to meters/second (approximate)
                };
            }
        }

        // Position interpolator for smooth transitions
        class PositionInterpolator {
            constructor() {
                this.startPosition = null;
                this.targetPosition = null;
                this.startTime = null;
                this.duration = 0;
                this.isActive = false;
                this.lastInterpolatedPosition = null;
            }

            start(startPos, targetPos, duration) {
                if (!startPos || !targetPos) return;

                // Don't interpolate if positions are too close
                const distance = calculateDistance(startPos, targetPos);
                if (distance < 0.1) {
                    this.isActive = false;
                    this.lastInterpolatedPosition = targetPos;
                    return;
                }

                this.startPosition = { ...startPos };
                this.targetPosition = { ...targetPos };
                this.startTime = performance.now();
                this.duration = duration;
                this.isActive = true;
            }

            update() {
                if (!this.isActive) return this.lastInterpolatedPosition || this.targetPosition;

                const now = performance.now();
                const elapsed = now - this.startTime;

                if (elapsed >= this.duration) {
                    this.isActive = false;
                    this.lastInterpolatedPosition = this.targetPosition;
                    return this.targetPosition;
                }

                // Calculate progress with easing
                const t = elapsed / this.duration;
                const easedT = this.easeOutCubic(t);

                // Interpolate position
                const interpolatedPosition = {
                    lat: this.startPosition.lat + (this.targetPosition.lat - this.startPosition.lat) * easedT,
                    lng: this.startPosition.lng + (this.targetPosition.lng - this.startPosition.lng) * easedT,
                    accuracy: this.targetPosition.accuracy,
                    heading: this.targetPosition.heading,
                    timestamp: now,
                    speedMPS: this.targetPosition.speedMPS,
                };

                this.lastInterpolatedPosition = interpolatedPosition;
                return interpolatedPosition;
            }

            // Cubic easing function for smoother motion
            easeOutCubic(t) {
                return 1 - Math.pow(1 - t, 3);
            }

            isInterpolating() {
                return this.isActive;
            }

            cancel() {
                this.isActive = false;
            }

            getLastPosition() {
                return this.lastInterpolatedPosition || this.targetPosition;
            }
        }

        // Create Kalman filter instance
        const kalmanFilter = new KalmanFilter();

        // Create position interpolator
        positionInterpolator = new PositionInterpolator();

        // Calculate distance between two points using Haversine formula
        function calculateDistance(pos1, pos2) {
            if (
                !pos1 ||
                !pos2 ||
                typeof pos1.lat !== "number" ||
                typeof pos1.lng !== "number" ||
                typeof pos2.lat !== "number" ||
                typeof pos2.lng !== "number"
            ) {
                return Number.POSITIVE_INFINITY;
            }

            const R = 6371000; // Earth's radius in meters
            const lat1 = (pos1.lat * Math.PI) / 180;
            const lat2 = (pos2.lat * Math.PI) / 180;
            const deltaLat = ((pos2.lat - pos1.lat) * Math.PI) / 180;
            const deltaLng = ((pos2.lng - pos1.lng) * Math.PI) / 180;

            const a =
                Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) +
                Math.cos(lat1) * Math.cos(lat2) * Math.sin(deltaLng / 2) * Math.sin(deltaLng / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

            return R * c;
        }

        // Check if device is in motion based on motion sensors
        function isDeviceInMotion() {
            if (!motionSamples || motionSamples.length < 3) {
                return false;
            }

            // Calculate average motion magnitude
            const avgMotion =
                motionSamples.reduce((sum, sample) => {
                    return sum + Math.sqrt(sample.x * sample.x + sample.y * sample.y + sample.z * sample.z);
                }, 0) / motionSamples.length;

            return avgMotion > MOTION_THRESHOLD;
        }

        // Process device motion data
        function handleDeviceMotion(event) {
            if (!event || !event.acceleration) return;

            const now = Date.now();
            // Throttle motion updates for better performance
            if (now - lastDeviceMotionTimestamp < 50) return;
            lastDeviceMotionTimestamp = now;

            const motion = {
                x: event.acceleration.x || 0,
                y: event.acceleration.y || 0,
                z: event.acceleration.z || 0,
                timestamp: now,
            };

            // Add to motion samples
            motionSamples.push(motion);

            // Keep only recent samples
            while (motionSamples.length > MOTION_SAMPLE_SIZE) {
                motionSamples.shift();
            }

            // Update device motion state
            deviceMotion = motion;

            // Add to device motion buffer for stability detection
            deviceMotionBuffer.push({
                magnitude: Math.sqrt(motion.x * motion.x + motion.y * motion.y + motion.z * motion.z),
                timestamp: now,
            });

            // Keep buffer at reasonable size
            while (deviceMotionBuffer.length > 10) {
                deviceMotionBuffer.shift();
            }

            // Check if device is stationary based on motion
            const inMotion = isDeviceInMotion();

            if (!inMotion) {
                deviceStationaryTime += 50; // Increment by throttle time
            } else {
                deviceStationaryTime = 0;
            }
        }

        // Process device orientation data
        function handleDeviceOrientation(event) {
            if (!event || event.alpha === null) return;

            const now = Date.now();
            // Throttle heading updates
            if (now - lastHeadingUpdateTime < 100) return;
            lastHeadingUpdateTime = now;

            deviceOrientation = {
                alpha: event.alpha, // z-axis rotation [0,360)
                beta: event.beta, // x-axis rotation [-180,180)
                gamma: event.gamma, // y-axis rotation [-90,90)
                timestamp: now,
            };

            // Update heading buffer if we have a compass heading
            if (event.webkitCompassHeading !== undefined) {
                const heading = event.webkitCompassHeading;

                // Add to heading buffer
                headingBuffer.push(heading);

                // Keep only recent headings
                while (headingBuffer.length > 8) {
                    headingBuffer.shift();
                }

                // Calculate median heading to filter outliers
                if (headingBuffer.length >= 3) {
                    const sortedHeadings = [...headingBuffer].sort((a, b) => a - b);
                    lastHeadingValue = sortedHeadings[Math.floor(sortedHeadings.length / 2)];
                }
            }
        }

        // Request device motion and orientation permissions
        function requestMotionPermission() {
            if (typeof DeviceMotionEvent !== "undefined" && typeof DeviceMotionEvent.requestPermission === "function") {
                DeviceMotionEvent.requestPermission()
                    .then((response) => {
                        if (response === "granted") {
                            window.addEventListener("devicemotion", handleDeviceMotion, true);
                        }
                    })
                    .catch(console.error);
            } else {
                window.addEventListener("devicemotion", handleDeviceMotion, true);
            }

            if (typeof DeviceOrientationEvent !== "undefined" && typeof DeviceOrientationEvent.requestPermission === "function") {
                DeviceOrientationEvent.requestPermission()
                    .then((response) => {
                        if (response === "granted") {
                            orientationPermissionGranted = true;
                            window.addEventListener("deviceorientation", handleDeviceOrientation, true);
                        }
                    })
                    .catch(console.error);
            } else {
                window.addEventListener("deviceorientation", handleDeviceOrientation, true);
                orientationPermissionGranted = true;
            }
        }

        // Animation loop for smooth rendering
        function startAnimationLoop() {
            function animate(timestamp) {
                // Calculate delta time
                const deltaTime = renderTimestamp ? (timestamp - renderTimestamp) / 1000 : 0;
                renderTimestamp = timestamp;

                // Process position updates
                processPositionUpdateQueue();

                // Update interpolated position
                if (positionInterpolator && positionInterpolator.isInterpolating()) {
                    const interpolatedPosition = positionInterpolator.update();
                    if (interpolatedPosition) {
                        // Update marker position
                        userMarker.setLatLng([interpolatedPosition.lat, interpolatedPosition.lng]);
                        lastRenderPosition = interpolatedPosition;

                        // Update marker rotation if heading is available
                        if (interpolatedPosition.heading !== null && interpolatedPosition.heading !== undefined) {
                            updateMarkerRotation(interpolatedPosition.heading);
                        }
                    }
                }

                // Check for recentering based on edge proximity
                if (followUser && !isMapInteracting && Date.now() - lastRecenterCheckTime > 200) {
                    checkAndRecenterMap();
                    lastRecenterCheckTime = Date.now();
                }

                // Update zoom level based on speed
                updateDynamicZoom();

                // Request next frame
                animationFrameId = requestAnimationFrame(animate);
            }

            // Start animation loop
            animationFrameId = requestAnimationFrame(animate);
        }

        // Update marker rotation based on heading
        function updateMarkerRotation(heading) {
            const markerElement = userMarker.getElement();
            if (markerElement) {
                const iconElement = markerElement.querySelector(".user-marker-icon");
                if (iconElement) {
                    iconElement.style.transform = `rotate(${heading}deg)`;
                }
            }
        }

        // Process position update queue
        function processPositionUpdateQueue() {
            if (positionUpdateQueue.length === 0) return;

            // Process all updates in queue
            while (positionUpdateQueue.length > 0) {
                const update = positionUpdateQueue.shift();
                processPositionUpdate(update);
            }
        }

        // Process position update
        function processPositionUpdate(position) {
            // Skip if invalid position
            if (!position || typeof position.lat !== "number" || typeof position.lng !== "number") {
                return;
            }

            // Update last position
            lastPosition = position;

            // Update current speed for zoom calculations
            currentSpeed = position.speedMPS || 0;

            // Add to speed samples for zoom calculation
            speedSamples.push(currentSpeed);
            while (speedSamples.length > 5) {
                speedSamples.shift();
            }

            // Update marker class based on stationary state
            const markerElement = userMarker.getElement();
            if (markerElement) {
                if (isStationary) {
                    markerElement.classList.add("user-marker-stationary");
                } else {
                    markerElement.classList.remove("user-marker-stationary");
                }
            }

            // Start interpolation to new position
            if (lastRenderPosition && !isFirstPositionUpdate) {
                // Calculate appropriate animation duration based on movement and stationary state
                let animDuration = isStationary ? 400 : ANIMATION_DURATION;

                // For very small movements when stationary, use longer duration for stability
                if (isStationary) {
                    const distance = calculateDistance(lastRenderPosition, position);
                    if (distance < 0.5) {
                        animDuration = 600; // Slower for tiny movements when stationary
                    }
                }

                positionInterpolator.start(lastRenderPosition, position, animDuration);
            } else {
                // First update, just set position directly
                userMarker.setLatLng([position.lat, position.lng]);
                lastRenderPosition = position;
                isFirstPositionUpdate = false;
            }

            // Update marker rotation if heading is available
            if (position.heading !== null && position.heading !== undefined) {
                updateMarkerRotation(position.heading);
            }

            // Auto-recenter map if following user
            if (followUser && !isMapInteracting) {
                checkAndRecenterMap();
            }
            
            // Check for nearby locations
            checkNearbyLocations();
        }
        
        // Check for nearby locations
        function checkNearbyLocations() {
            if (!lastPosition || !gameLocations || isLocationHuntVisible) return;
            
            // Only check the current location (progressive display)
            const location = gameLocations[currentLocationIndex];
            if (!location) return;
            
            // Skip if already visited
            if (visitedLocations.includes(location.id)) return;
            
            const distance = calculateDistance(
                { lat: lastPosition.lat, lng: lastPosition.lng },
                { lat: location.lat, lng: location.lng }
            );
            
            // Convert to feet
            const distanceFeet = Math.round(distance * 3.28084);
            
            // Update distance box
            updateDistanceBox(location, distanceFeet);
            
            // Check if user is close enough to interact
            if (distanceFeet <= DISTANCE_THRESHOLD) {
                showLocationHunt(location);
            }
        }
        
        // Update distance box with location info
        function updateDistanceBox(location, distanceFeet) {
            const distanceBox = document.getElementById('distanceBox');
            if (distanceBox) {
                const locationNameElement = distanceBox.querySelector('.location-name');
                const distanceValueElement = distanceBox.querySelector('.distance-value');
                
                if (locationNameElement && distanceValueElement) {
                    locationNameElement.textContent = location.name;
                    distanceValueElement.textContent = `${distanceFeet} feet away`;
                }
            }
        }

        // Create navigation links for a location
        function createNavigationLinks(location) {
            // Google Maps
            const googleMapsLink = document.getElementById('googleMapsLink');
            if (googleMapsLink) {
                googleMapsLink.href = `https://www.google.com/maps/dir/?api=1&destination=${location.lat},${location.lng}&travelmode=walking`;
            }
            
            // Apple Maps (iOS only)
            const appleMapsLink = document.getElementById('appleMapsLink');
            if (appleMapsLink) {
                appleMapsLink.href = `maps://maps.apple.com/?daddr=${location.lat},${location.lng}&dirflg=w`;
                
                // Hide Apple Maps link on non-iOS devices
                const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
                appleMapsLink.style.display = isIOS ? 'flex' : 'none';
            }
            
            // Waze
            const wazeLink = document.getElementById('wazeLink');
            if (wazeLink) {
                wazeLink.href = `https://waze.com/ul?ll=${location.lat},${location.lng}&navigate=yes`;
            }
        }
        
        // Set up directions modal links
        function setupDirectionsModal(location) {
            currentDirectionsLocation = location;
            
            // Google Maps
            const googleMapsBtn = document.getElementById('googleMapsBtn');
            if (googleMapsBtn) {
                googleMapsBtn.href = `https://www.google.com/maps/dir/?api=1&destination=${location.lat},${location.lng}&travelmode=walking`;
            }
            
            // Apple Maps (iOS only)
            const appleMapsBtn = document.getElementById('appleMapsBtn');
            if (appleMapsBtn) {
                appleMapsBtn.href = `maps://maps.apple.com/?daddr=${location.lat},${location.lng}&dirflg=w`;
                
                // Hide Apple Maps button on non-iOS devices
                const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
                appleMapsBtn.style.display = isIOS ? 'flex' : 'none';
            }
            
            // Waze
            const wazeBtn = document.getElementById('wazeBtn');
            if (wazeBtn) {
                wazeBtn.href = `https://waze.com/ul?ll=${location.lat},${location.lng}&navigate=yes`;
            }
        }
        
        // Show directions modal
        function showDirectionsModal(location) {
            setupDirectionsModal(location);
            document.getElementById('directionsModal').style.display = 'flex';
        }
        
        // Close directions modal
        function closeDirectionsModal() {
            document.getElementById('directionsModal').style.display = 'none';
        }
        
        // Skip to next location
        function skipToNextLocation() {
            // Close any open popups
            map.closePopup();
            
            // Remove the current marker from the map
            if (currentLocationIndex < allLocationMarkers.length) {
                map.removeLayer(allLocationMarkers[currentLocationIndex]);
            }
            
            // Move to next location
            currentLocationIndex++;
            
            // Check if we've reached the end
            if (currentLocationIndex >= gameLocations.length) {
                showCongratulations();
            } else {
                // Update visible markers
                updateVisibleMarkers();
                
                // Update distance box for new location
                const location = gameLocations[currentLocationIndex];
                if (location && lastPosition) {
                    const distance = calculateDistance(
                        { lat: lastPosition.lat, lng: lastPosition.lng },
                        { lat: location.lat, lng: location.lng }
                    );
                    const distanceFeet = Math.round(distance * 3.28084);
                    updateDistanceBox(location, distanceFeet);
                }
            }
        }

        // Calculate edge proximity to map bounds
        function calculateEdgeProximity(map, point) {
            const bounds = map.getBounds();
            const latSpan = bounds.getNorth() - bounds.getSouth();
            const lngSpan = bounds.getEast() - bounds.getWest();

            return {
                north: Math.abs(point.lat - bounds.getNorth()) / latSpan,
                south: Math.abs(point.lat - bounds.getSouth()) / latSpan,
                east: Math.abs(point.lng - bounds.getEast()) / lngSpan,
                west: Math.abs(point.lng - bounds.getWest()) / lngSpan,
            };
        }

        // Check if marker is near edge of map
        function isMarkerNearEdge(map, marker, isStrict = false) {
            const bounds = map.getBounds();
            const point = marker.getLatLng();
            const proximities = calculateEdgeProximity(map, point);

            const thresholdPercentage = isStrict ? STRICT_EDGE_THRESHOLD_PERCENTAGE : EDGE_THRESHOLD_PERCENTAGE;

            const edges = {
                north: proximities.north < thresholdPercentage,
                south: proximities.south < thresholdPercentage,
                east: proximities.east < thresholdPercentage,
                west: proximities.west < thresholdPercentage,
            };

            return {
                isNearEdge: Object.values(edges).some((edge) => edge),
                edges: edges,
                proximities: proximities,
            };
        }

        // Calculate optimal center point for map view
        function calculateOptimalCenter(map, markerPosition, edgeInfo) {
            const bounds = map.getBounds();

            let latOffset = 0;
            let lngOffset = 0;

            // Basic edge offset
            if (edgeInfo.edges.north) latOffset = -1 * (bounds.getNorth() - bounds.getSouth()) * 0.2;
            if (edgeInfo.edges.south) latOffset = (bounds.getNorth() - bounds.getSouth()) * 0.2;
            if (edgeInfo.edges.east) lngOffset = -1 * (bounds.getEast() - bounds.getWest()) * 0.2;
            if (edgeInfo.edges.west) lngOffset = (bounds.getEast() - bounds.getWest()) * 0.2;

            // If user is moving fast, offset center point in direction of movement
            if (
                lastPosition &&
                lastPosition.speedMPS > SPEED_RECENTER_THRESHOLD &&
                lastPosition.heading !== null &&
                lastPosition.heading !== undefined
            ) {
                // Calculate offset factor based on speed
                const speedFactor = Math.min(
                    1.0,
                    (lastPosition.speedMPS - SPEED_RECENTER_THRESHOLD) / (DRIVING_SPEED_THRESHOLD - SPEED_RECENTER_THRESHOLD),
                );

                // Convert heading to radians
                const headingRad = (lastPosition.heading * Math.PI) / 180;

                // Calculate additional offset in direction of movement
                const additionalLatOffset =
                    Math.cos(headingRad) * RECENTER_OFFSET_FACTOR * speedFactor * (bounds.getNorth() - bounds.getSouth());
                const additionalLngOffset =
                    Math.sin(headingRad) * RECENTER_OFFSET_FACTOR * speedFactor * (bounds.getEast() - bounds.getWest());

                latOffset += additionalLatOffset;
                lngOffset += additionalLngOffset;
            }

            return {
                lat: markerPosition.lat + latOffset,
                lng: markerPosition.lng + lngOffset,
            };
        }

        // Determine if map should recenter
        function shouldRecenter(map, marker) {
            const now = Date.now();
            if (now - lastRecenterTime < RECENTER_COOLDOWN) {
                return { needsRecenter: false };
            }

            const edgeInfo = isMarkerNearEdge(map, marker);
            const proximities = edgeInfo.proximities;

            const isCritical = Object.values(proximities).some((proximity) => proximity < CRITICAL_EDGE_THRESHOLD_PERCENTAGE);

            if (isCritical) {
                lastRecenterTime = now;
                return {
                    needsRecenter: true,
                    isEmergency: true,
                    edgeInfo: edgeInfo,
                };
            }

            if (edgeInfo.isNearEdge) {
                lastRecenterTime = now;
                return {
                    needsRecenter: true,
                    isEmergency: false,
                    edgeInfo: edgeInfo,
                };
            }

            return {
                needsRecenter: false,
                isEmergency: false,
                edgeInfo: edgeInfo,
            };
        }

        // Check and recenter map if needed
        function checkAndRecenterMap() {
            if (!userMarker || !map || !followUser || isMapInteracting) return;

            const recenterInfo = shouldRecenter(map, userMarker);
            if (recenterInfo.needsRecenter) {
                const optimalCenter = calculateOptimalCenter(map, userMarker.getLatLng(), recenterInfo.edgeInfo);

                // Use smooth animation for non-emergency recenters
                map.setView([optimalCenter.lat, optimalCenter.lng], map.getZoom(), {
                    animate: true,
                    duration: recenterInfo.isEmergency ? 0.2 : 0.5,
                    noMoveStart: true,
                });
            }
        }

        // Calculate optimal zoom level based on speed
        function calculateOptimalZoom(speed) {
            // Default to walking zoom level
            if (speed === undefined || speed === null) {
                return DEFAULT_ZOOM_LEVEL;
            }

            // Stationary or very slow
            if (speed < 0.5) {
                return MAX_ZOOM_LEVEL;
            }
            // Walking speed
            else if (speed < WALKING_SPEED_THRESHOLD) {
                return DEFAULT_ZOOM_LEVEL;
            }
            // Running speed
            else if (speed < RUNNING_SPEED_THRESHOLD) {
                return DEFAULT_ZOOM_LEVEL - 1;
            }
            // Driving speed
            else if (speed < DRIVING_SPEED_THRESHOLD) {
                return DEFAULT_ZOOM_LEVEL - 2;
            }
            // High speed
            else if (speed < HIGH_SPEED_THRESHOLD) {
                return DEFAULT_ZOOM_LEVEL - 3;
            }
            // Very high speed
            else {
                return MIN_ZOOM_LEVEL;
            }
        }

        // Update zoom level based on speed
        function updateDynamicZoom() {
            const now = Date.now();
            if (now - lastZoomUpdateTime < ZOOM_UPDATE_INTERVAL) return;
            lastZoomUpdateTime = now;

            // Skip if user is interacting with map
            if (isMapInteracting || userIsInteracting) return;

            // Calculate average speed from samples
            let avgSpeed = 0;
            if (speedSamples.length > 0) {
                avgSpeed = speedSamples.reduce((sum, speed) => sum + speed, 0) / speedSamples.length;
            } else if (lastPosition) {
                avgSpeed = lastPosition.speedMPS || 0;
            }

            // Smooth speed changes
            const smoothedSpeed = lastSpeedForZoom * 0.7 + avgSpeed * 0.3;
            lastSpeedForZoom = smoothedSpeed;

            // Calculate optimal zoom level
            const optimalZoom = calculateOptimalZoom(smoothedSpeed);

            // Only update if zoom level needs to change
            if (Math.abs(optimalZoom - targetZoomLevel) >= 0.1) {
                targetZoomLevel = optimalZoom;

                // Apply zoom change with smooth animation
                if (map && followUser) {
                    const currentZoom = map.getZoom();
                    const zoomDiff = Math.abs(currentZoom - targetZoomLevel);

                    // Use faster transition for larger zoom changes
                    const duration = zoomDiff > 1 ? 0.3 : ZOOM_TRANSITION_DURATION;

                    map.setZoom(targetZoomLevel, {
                        animate: true,
                        duration: duration,
                        noMoveStart: true,
                    });
                }
            }
        }

        // Linear interpolation helper
        function lerp(a, b, t) {
            if (typeof a !== "number" || typeof b !== "number" || typeof t !== "number") {
                return a;
            }

            return a + (b - a) * Math.max(0, Math.min(1, t));
        }

        // Calculate stationary position
        function calculateStationaryPosition(buffer) {
            if (!buffer || buffer.length === 0) {
                return null;
            }
            // Sort by accuracy (best first)
            const sortedBuffer = [...buffer].sort((a, b) => a.accuracy - b.accuracy);
            // Take weighted average of best positions
            const topPositions = sortedBuffer.slice(0, Math.ceil(buffer.length / 2));
            const weights = topPositions.map((pos) => 1 / Math.max(1, pos.accuracy));
            const totalWeight = weights.reduce((sum, w) => sum + w, 0);
            if (totalWeight === 0) {
                return sortedBuffer[0];
            }
            // Calculate weighted average
            const avgPosition = {
                lat: topPositions.reduce((sum, pos, i) => sum + pos.lat * weights[i], 0) / totalWeight,
                lng: topPositions.reduce((sum, pos, i) => sum + pos.lng * weights[i], 0) / totalWeight,
                accuracy: topPositions[0].accuracy,
                heading: topPositions[0].heading,
                timestamp: Date.now(),
                speedMPS: 0,
            };
            // If we have a previous stationary position, blend with it for stability
            if (lastStationaryPosition) {
                const blendFactor = 0.85; // 85% previous, 15% new for extreme stability
                return {
                    lat: lastStationaryPosition.lat * blendFactor + avgPosition.lat * (1 - blendFactor),
                    lng: lastStationaryPosition.lng * blendFactor + avgPosition.lng * (1 - blendFactor),
                    accuracy: avgPosition.accuracy,
                    heading: avgPosition.heading,
                    timestamp: avgPosition.timestamp,
                    speedMPS: 0
                };
            }
            return avgPosition;
        }

        // Update stationary position history
        function updateStationaryHistory(position) {
            // Add new position to history
            stationaryPositionHistory.push(position);

            // Keep history at maximum size
            while (stationaryPositionHistory.length > STATIONARY_POSITION_HISTORY_SIZE) {
                stationaryPositionHistory.shift();
            }

            // Calculate weighted average of positions
            let totalWeight = 0;
            let weightedLat = 0;
            let weightedLng = 0;

            // Newer positions have higher weight
            for (let i = 0; i < stationaryPositionHistory.length; i++) {
                const pos = stationaryPositionHistory[i];
                const weight = Math.pow(STATIONARY_POSITION_WEIGHT_DECAY, stationaryPositionHistory.length - i - 1);
                totalWeight += weight;
                weightedLat += pos.lat * weight;
                weightedLng += pos.lng * weight;
            }

            return {
                lat: weightedLat / totalWeight,
                lng: weightedLng / totalWeight,
                accuracy: position.accuracy,
                heading: position.heading,
                timestamp: position.timestamp,
                speedMPS: 0,
            };
        }

        // Update position buffer with new position
        function updatePositionBuffer(position) {
            if (!position || typeof position.lat !== "number" || typeof position.lng !== "number") {
                return;
            }

            // Add new position to buffer
            positionBuffer.push({
                lat: position.lat,
                lng: position.lng,
                accuracy: position.accuracy,
                heading: position.heading,
                timestamp: position.timestamp,
                speedMPS: position.speedMPS,
            });

            // Remove old positions if buffer exceeds maxSize
            while (positionBuffer.length > MAX_BUFFER_SIZE) {
                positionBuffer.shift();
            }
        }

        // Check if user is stationary
        function checkStationaryState(newPosition) {
            if (!lastPosition) return;

            const distance = calculateDistance(lastPosition, newPosition);

            if (distance >= MICRO_MOVEMENT_THRESHOLD) {
                isStationary = false;
                stationaryStartTime = null;
                console.debug("Movement detected, resuming normal updates");

                // Update Kalman filter stationary mode
                kalmanFilter.setStationaryMode(false);

                // Update marker class
                const markerElement = userMarker.getElement();
                if (markerElement) {
                    markerElement.classList.remove("user-marker-stationary");
                }
            }

            if (stationaryCheckTimeout) {
                clearTimeout(stationaryCheckTimeout);
                stationaryCheckTimeout = null;
            }

            if (isStationary) {
                stationaryCheckTimeout = setTimeout(() => checkStationaryState(newPosition), STATIONARY_CHECK_INTERVAL);
            }
        }

        // Predict position based on heading and speed
        function predictPositionFromHeading(position, heading, distance) {
            // Input validation
            if (
                !position ||
                typeof heading !== "number" ||
                typeof distance !== "number" ||
                !position.lat ||
                !position.lng ||
                isNaN(heading) ||
                isNaN(distance)
            ) {
                return position;
            }

            // Normalize heading to 0-360 range
            heading = ((heading % 360) + 360) % 360;

            // Earth's radius in meters
            const R = 6371e3;

            // Convert to radians
            const d = distance / R;
            const θ = (heading * Math.PI) / 180;
            const φ1 = (position.lat * Math.PI) / 180;
            const λ1 = (position.lng * Math.PI) / 180;

            // Calculate predicted position with error handling
            try {
                const sinφ1 = Math.sin(φ1);
                const cosφ1 = Math.cos(φ1);
                const cosd = Math.cos(d);
                const sind = Math.sin(d);
                const cosθ = Math.cos(θ);

                const φ2 = Math.asin(sinφ1 * cosd + cosφ1 * sind * cosθ);

                const λ2 = λ1 + Math.atan2(Math.sin(θ) * sind * cosφ1, cosd - sinφ1 * Math.sin(φ2));

                // Convert back to degrees with bounds checking
                const newLat = Math.max(-90, Math.min(90, (φ2 * 180) / Math.PI));
                const newLng = (((λ2 * 180) / Math.PI + 540) % 360) - 180;

                return {
                    lat: newLat,
                    lng: newLng,
                };
            } catch (error) {
                // Fallback to original position if calculation fails
                return position;
            }
        }

        // Main function to update user location
        function updateUserLocation(position, forceUpdate = false) {
            // Validate input position
            if (!position?.coords) {
                console.warn("Invalid position data received");
                return;
            }

            const currentTime = Date.now();

            // Throttle updates for performance
            if (!forceUpdate && currentTime - lastPositionUpdateTime < 16) {
                return;
            }
            lastPositionUpdateTime = currentTime;

            const timeDelta = lastUpdateTime ? (currentTime - lastUpdateTime) / 1000 : 0;

            // Create position object
            const newPosition = {
                lat: position.coords.latitude,
                lng: position.coords.longitude,
                accuracy: position.coords.accuracy || 20,
                heading: position.coords.heading !== null ? position.coords.heading : lastHeadingValue || undefined,
                timestamp: currentTime,
                speedMPS: position.coords.speed !== null ? position.coords.speed : 0,
            };

            if (isNaN(newPosition.lat) || isNaN(newPosition.lng)) {
                console.warn("Invalid coordinates received");
                return;
            }

            // Store raw position for comparison
            lastRawPosition = newPosition;

            // Track accuracy trend
            if (lastAccuracy !== null) {
                accuracyTrend.push(newPosition.accuracy - lastAccuracy);
                while (accuracyTrend.length > 5) accuracyTrend.shift();
            }
            lastAccuracy = newPosition.accuracy;

            // First position initialization
            if (!lastPosition) {
                lastPosition = newPosition;
                userMarker.setLatLng([newPosition.lat, newPosition.lng]);
                kalmanFilter.reset(newPosition);
                lastUpdateTime = currentTime;
                stationaryStartTime = currentTime;
                positionBuffer = [newPosition];
                lastStationaryPosition = newPosition;
                lastRenderPosition = newPosition;
                return;
            }

            // Calculate distance from last position
            const distance = calculateDistance(lastPosition, newPosition);

            // Handle large position changes or forced updates
            if (distance > EXTENDED_DISTANCE_THRESHOLD || forceUpdate) {
                if (stationaryCheckTimeout) {
                    clearTimeout(stationaryCheckTimeout);
                    stationaryCheckTimeout = null;
                }
                isStationary = false;
                stationaryStartTime = null;
                stationaryCount = 0;
                stationaryPositionHistory = [];
                lastStationaryPosition = null;
                consecutiveStationaryUpdates = 0;

                // Reset tracking variables
                userMarker.setLatLng([newPosition.lat, newPosition.lng]);
                lastPosition = newPosition;
                lastRenderPosition = newPosition;
                positionBuffer = [newPosition];
                kalmanFilter.reset(newPosition);
                kalmanFilter.setStationaryMode(false);
                lastVelocity = { lat: 0, lng: 0 };

                // Cancel any active interpolation
                if (positionInterpolator) {
                    positionInterpolator.cancel();
                }

                lastUpdateTime = currentTime;
                lastUpdateTimestamp = currentTime;
                checkNearbyLocations();
                return;
            }

            // Skip updates with poor accuracy or unrealistic movement
            if (
                !forceUpdate &&
                (newPosition.accuracy > MAX_ACCEPTABLE_ACCURACY || (timeDelta > 0 && distance / timeDelta > 50))
            ) {
                console.debug("Skipping update due to poor accuracy or unrealistic movement");
                return;
            }

            try {
                // Check if device is in motion based on motion sensors
                const motionDetected = deviceMotion && isDeviceInMotion();

                // Enhanced stationary detection
                if (distance < MICRO_MOVEMENT_THRESHOLD && (!motionDetected || deviceStationaryTime > STATIONARY_TIME_THRESHOLD)) {
                    stationaryCount++;
                    consecutiveStationaryUpdates++;

                    if (!isStationary && stationaryCount >= STATIONARY_THRESHOLD) {
                        isStationary = true;
                        console.log("User is now stationary");

                        // Set Kalman filter to stationary mode
                        kalmanFilter.setStationaryMode(true);

                        // Update marker class
                        const markerElement = userMarker.getElement();
                        if (markerElement) {
                            markerElement.classList.add("user-marker-stationary");
                        }

                        // Calculate stable position from buffer
                        const stablePosition = calculateStationaryPosition(positionBuffer);
                        if (stablePosition) {
                            // Add to position update queue
                            positionUpdateQueue.push(stablePosition);
                            lastPosition = stablePosition;
                            lastStationaryPosition = stablePosition;
                        }

                        if (stationaryCheckTimeout) clearTimeout(stationaryCheckTimeout);
                        stationaryCheckTimeout = setTimeout(() => checkStationaryState(newPosition), STATIONARY_CHECK_INTERVAL);

                        checkNearbyLocations();
                        return;
                    }
                } else {
                    stationaryCount = Math.max(0, stationaryCount - 1);
                    consecutiveStationaryUpdates = 0;
                    if (isStationary && stationaryCount < STATIONARY_THRESHOLD / 2) {
                        isStationary = false;
                        kalmanFilter.setStationaryMode(false);

                        // Update marker class
                        const markerElement = userMarker.getElement();
                        if (markerElement) {
                            markerElement.classList.remove("user-marker-stationary");
                        }

                        console.log("User is moving again");
                    }
                }

                // Apply Kalman filter with motion detection
                const filteredPosition = kalmanFilter.update(newPosition, motionDetected);

                // Update position buffer
                updatePositionBuffer(filteredPosition);

                // Apply different smoothing based on movement state
                let finalPosition;

                if (isStationary) {
                    // When stationary, use the stable position with minimal updates
                    if (lastStationaryPosition) {
                        // Only update if accuracy significantly improves or after several updates
                        if (newPosition.accuracy < lastStationaryPosition.accuracy * 0.8 || consecutiveStationaryUpdates > 5) {
                            // Update stationary position history
                            updateStationaryHistory(filteredPosition);

                            // Calculate new stable position
                            const stablePosition = calculateStationaryPosition(positionBuffer);
                            if (stablePosition) {
                                // Smooth transition to new stable position
                                finalPosition = {
                                    lat: lerp(lastStationaryPosition.lat, stablePosition.lat, 0.1),
                                    lng: lerp(lastStationaryPosition.lng, stablePosition.lng, 0.1),
                                    accuracy: stablePosition.accuracy,
                                    heading: stablePosition.heading,
                                    timestamp: currentTime,
                                    speedMPS: 0,
                                };

                                // Add to position update queue
                                positionUpdateQueue.push(finalPosition);
                                lastPosition = finalPosition;
                                lastStationaryPosition = finalPosition;
                                consecutiveStationaryUpdates = 0;
                            } else {
                                finalPosition = lastStationaryPosition;
                            }
                        } else {
                            // Use existing stable position
                            finalPosition = lastStationaryPosition;
                        }
                    } else {
                        // If no stable position yet, calculate one
                        const stablePosition = calculateStationaryPosition(positionBuffer);
                        if (stablePosition) {
                            finalPosition = stablePosition;
                            lastStationaryPosition = stablePosition;

                            // Add to position update queue
                            positionUpdateQueue.push(finalPosition);
                        } else {
                            finalPosition = filteredPosition;

                            // Add to position update queue
                            positionUpdateQueue.push(finalPosition);
                        }
                        lastPosition = finalPosition;
                    }
                } else {
                    // Smooth movement when active
                    finalPosition = filteredPosition;

                    // Apply heading-based prediction for smoother movement
                    if (finalPosition.heading !== undefined && finalPosition.speedMPS > 0.5) {
                        const predictedPosition = predictPositionFromHeading(
                            finalPosition,
                            finalPosition.heading,
                            finalPosition.speedMPS * 0.3, // Predict slightly ahead
                        );

                        // Blend predicted and filtered positions
                        finalPosition = {
                            lat: lerp(finalPosition.lat, predictedPosition.lat, 0.2),
                            lng: lerp(finalPosition.lng, predictedPosition.lng, 0.2),
                            accuracy: finalPosition.accuracy,
                            heading: finalPosition.heading,
                            timestamp: currentTime,
                            speedMPS: finalPosition.speedMPS,
                        };
                    }

                    // Add to position update queue
                    positionUpdateQueue.push(finalPosition);
                    lastPosition = finalPosition;
                }

                lastUpdateTime = currentTime;
                lastUpdateTimestamp = currentTime;
                checkNearbyLocations();
            } catch (error) {
                console.error("Location update error:", error);
                // Fallback with basic filtering
                userMarker.setLatLng([newPosition.lat, newPosition.lng]);
                lastPosition = newPosition;
                lastRenderPosition = newPosition;
                checkNearbyLocations();
            }
        }

        // Handle position updates from geolocation API
        function handlePositionUpdate(position) {
            if (!position?.coords?.latitude || !position?.coords?.longitude) {
                console.warn("Invalid position data received");
                return;
            }

            const currentTime = Date.now();
            if (currentTime - lastUpdateTime >= 100 && !isPopupOpen()) {
                updateUserLocation(position);
                lastUpdateTime = currentTime;
            }
        }

        // Start position updates with high frequency
        function startPositionUpdates() {
            navigator.geolocation.watchPosition(handlePositionUpdate, handleLocationError, {
                enableHighAccuracy: true,
                maximumAge: 0,
                timeout: 10000,
            });
        }

        // Initialize map with enhanced settings
        function initMap() {
            map = L.map("map", {
                zoomControl: false,
                attributionControl: false,
                zoomSnap: 0.1,
                zoomDelta: 0.5,
                wheelDebounceTime: 100,
                tapTolerance: 15,
                bounceAtZoomLimits: false,
                preferCanvas: true, // Use canvas renderer for better performance
                renderer: L.canvas({ padding: 0.5 }),
            }).fitWorld();

            L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
                maxZoom: 19,
                attribution: "© OpenStreetMap contributors",
                updateWhenIdle: true,
                updateWhenZooming: false,
                keepBuffer: 2,
            }).addTo(map);

            // Create user icon with custom styling for direction indication
            const userIcon = L.divIcon({
                className: "user-marker",
                html: '<div class="user-marker-icon"></div>',
                iconSize: [20, 20],
                iconAnchor: [10, 10],
            });

            userMarker = L.marker([0, 0], {
                icon: userIcon,
                zIndexOffset: 1000, // Ensure user marker is on top
                interactive: false, // Prevent marker from being clickable
            }).addTo(map);

            // Show preloader
            showPreloader();

            // Request motion and orientation permissions
            requestMotionPermission();

            if ("geolocation" in navigator) {
                const options = {
                    enableHighAccuracy: true,
                    timeout: 45000,
                    maximumAge: 0,
                };

                // Try first time
                navigator.geolocation.getCurrentPosition(
                    initializeUserLocation,
                    (error) => {
                        // On error, try one more time before falling back
                        navigator.geolocation.getCurrentPosition(initializeUserLocation, handleLocationError, options);
                    },
                    options
                );
            } else {
                showPopup("Geolocation is not supported by your browser");
                map.setView([44.9778, -93.265], 18);
                hidePreloader();
            }

            document.addEventListener("visibilitychange", handleVisibilityChange);

            map.on("movestart zoomstart", () => {
                followUser = false;
                isMapInteracting = true;
                userIsInteracting = true;
            });

            map.on("moveend zoomend", () => {
                isMapInteracting = false;
                userIsInteracting = false;
                resetInactivityTimer();
            });

            // Start animation loop for smooth rendering
            startAnimationLoop();

            // Load tour locations
            loadLocations();
        }

        // Load tour locations
        function loadLocations() {
            gameLocations = locations;
            
            // Create markers for all locations
            gameLocations.forEach((location, index) => {
                // Create numbered marker icon
                const locationIcon = L.divIcon({
                    className: 'location-marker',
                    html: `<div class="location-marker-icon">${index + 1}</div>`,
                    iconSize: [36, 36],
                    iconAnchor: [18, 18]
                });
                
                const marker = L.marker([location.lat, location.lng], {
                    icon: locationIcon
                });
                
                // Add popup with location info
                const popupContent = `
                    <div class="marker-popup">
                        <img src="${location.image || '/placeholder.svg?height=150&width=280'}" class="marker-popup-image" alt="${location.name}">
                        <div class="marker-popup-content">
                            <div class="marker-popup-title">${location.name}</div>
                            <div class="marker-popup-description">${location.description.substring(0, 100)}...</div>
                            <div class="marker-popup-actions">
                                <button class="popup-btn directions" onclick="showDirectionsModal(gameLocations[${index}])">
                                    <i class="fas fa-directions"></i> Directions
                                </button>
                                <button class="popup-btn skip" onclick="skipToNextLocation()">
                                    <i class="fas fa-forward"></i> Skip
                                </button>
                            </div>
                        </div>
                    </div>
                `;
                
                const popup = L.popup({
                    closeButton: true,
                    autoClose: false,
                    closeOnEscapeKey: true,
                    closeOnClick: false,
                    className: 'custom-popup',
                    maxWidth: 300
                }).setContent(popupContent);
                
                marker.bindPopup(popup);
                
                // Add click event to marker
                marker.on('click', () => {
                    marker.openPopup();
                });
                
                allLocationMarkers.push(marker);
            });
            
            // Only show the first marker initially
            updateVisibleMarkers();
            
            
        }
        
        // Update visible markers based on current progress
        function updateVisibleMarkers() {
            // Remove all existing markers from map
            activeMarkers.forEach(marker => {
                map.removeLayer(marker);
            });
            activeMarkers = [];
            
            // Show only the current marker
            if (currentLocationIndex < allLocationMarkers.length) {
                allLocationMarkers[currentLocationIndex].addTo(map);
                activeMarkers.push(allLocationMarkers[currentLocationIndex]);
            }
        }

        // Initialize user location
        function initializeUserLocation(position) {
            if (!position?.coords) {
                handleLocationError({ code: 2, message: "Invalid position data" });
                return;
            }

            try {
                const initialPosition = {
                    lat: position.coords.latitude,
                    lng: position.coords.longitude,
                    accuracy: position.coords.accuracy || 20,
                    heading: position.coords.heading,
                    timestamp: Date.now(),
                    speedMPS: position.coords.speed || 0,
                };

                // Set initial marker position
                userMarker.setLatLng([initialPosition.lat, initialPosition.lng]);

                // Initialize Kalman filter
                kalmanFilter.reset(initialPosition);

                // Set map view
                map.setView([initialPosition.lat, initialPosition.lng], DEFAULT_ZOOM_LEVEL);

                // Initialize tracking variables
                lastPosition = initialPosition;
                lastRenderPosition = initialPosition;
                lastUpdateTime = Date.now();
                lastUpdateTimestamp = Date.now();

                // Start position updates
                startPositionUpdates();

                // Hide preloader
                hidePreloader();

                // Update distance box
                checkNearbyLocations();

                // Show stabilizing modal
                showStabilizingModal();

                console.log("Location initialized successfully");
            } catch (error) {
                console.error("Error initializing location:", error);
                handleLocationError({ code: 2, message: "Error initializing location" });
            }
        }

        // Show stabilizing modal
        function showStabilizingModal() {
            const modal = document.createElement('div');
            modal.className = 'stabilizing-modal';
            modal.innerHTML = `
                <div class="spinner"></div>
                <h3>Stabilizing Your Location</h3>
                <p>Please wait while we fine-tune your position.</p>
            `;
            document.body.appendChild(modal);
            
            // Auto-dismiss after 5 seconds
            setTimeout(() => {
                modal.style.opacity = '0';
                modal.style.transition = 'opacity 0.5s ease';
                setTimeout(() => {
                    if (modal.parentNode) {
                        modal.parentNode.removeChild(modal);
                    }
                    isStabilizing = false;
                }, 500);
            }, 5000);
        }

        // Show location hunt
        function showLocationHunt(location) {
            isLocationHuntVisible = true;
            
            // Set location information
            document.getElementById('locationTitle').textContent = location.name;
            document.getElementById('locationCity').textContent = location.city;
            document.getElementById('locationCreator').textContent = `Created by: ${location.creator}`;
            document.getElementById('locationImage').src = location.image || '/placeholder.svg?height=200&width=400';
            document.getElementById('locationAudio').src = location.audio;
            document.getElementById('locationDescription').textContent = location.description;
            
            // Create navigation links
            createNavigationLinks(location);
            
            // Show location hunt container
            const lochuntContainer = document.querySelector('.lochunt-container');
            lochuntContainer.classList.add('active');
            
            // Initialize audio player
            initAudioPlayer();
            
            // Add to visited locations if not already visited
            if (!visitedLocations.includes(location.id)) {
                visitedLocations.push(location.id);
            }
        }

        // Initialize audio player
        function initAudioPlayer() {
            const audio = document.getElementById('locationAudio');
            const playPauseBtn = document.getElementById('playPauseBtn');
            const rewindBtn = document.getElementById('rewindBtn');
            const forwardBtn = document.getElementById('forwardBtn');
            const progressBar = document.getElementById('progressBar');
            const currentTimeSpan = document.getElementById('currentTime');
            const durationSpan = document.getElementById('duration');
            
            // Set up event listeners
            playPauseBtn.addEventListener('click', togglePlay);
            rewindBtn.addEventListener('click', () => seek(-10));
            forwardBtn.addEventListener('click', () => seek(10));
            audio.addEventListener('timeupdate', updateProgress);
            audio.addEventListener('loadedmetadata', setDuration);
            audio.addEventListener('ended', showTrivia);
            
            // Play/pause function
            function togglePlay() {
                if (audio.paused) {
                    audio.play();
                    playPauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
                } else {
                    audio.pause();
                    playPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
                }
            }
            
            // Seek function
            function seek(seconds) {
                audio.currentTime = Math.max(0, Math.min(audio.currentTime + seconds, audio.duration));
            }
            
            // Update progress bar
            function updateProgress() {
                const percent = (audio.currentTime / audio.duration) * 100;
                progressBar.style.width = `${percent}%`;
                currentTimeSpan.textContent = formatTime(audio.currentTime);
            }
            
            // Set duration
            function setDuration() {
                durationSpan.textContent = formatTime(audio.duration);
            }
            
            // Format time (convert seconds to MM:SS format)
            function formatTime(time) {
                const minutes = Math.floor(time / 60);
                const seconds = Math.floor(time % 60);
                return `${minutes}:${seconds.toString().padStart(2, '0')}`;
            }
        }

        // Show trivia question
        function showTrivia() {
            // Hide location hunt container
            document.querySelector('.lochunt-container').classList.remove('active');
            
            // Get current location
            const currentLocation = gameLocations[currentLocationIndex];
            
            // Set trivia question
            document.getElementById('triviaQuestion').textContent = currentLocation.trivia.question;
            
            // Create trivia options
            const triviaOptions = document.getElementById('triviaOptions');
            triviaOptions.innerHTML = '';
            
            currentLocation.trivia.options.forEach((option, index) => {
                const button = document.createElement('button');
                button.className = 'trivia-option';
                button.textContent = option;
                button.dataset.index = index;
                button.addEventListener('click', checkAnswer);
                triviaOptions.appendChild(button);
            });
            
            // Show trivia container
            document.querySelector('.trivia-container').classList.add('active');
        }

        // Check trivia answer
        function checkAnswer(event) {
            const selectedIndex = parseInt(event.target.dataset.index);
            const currentLocation = gameLocations[currentLocationIndex];
            
            // Disable all buttons
            const buttons = document.querySelectorAll('.trivia-option');
            buttons.forEach(button => {
                button.disabled = true;
            });
            
            // Mark correct and incorrect answers
            buttons.forEach(button => {
                const index = parseInt(button.dataset.index);
                if (index === currentLocation.trivia.answer) {
                    button.classList.add('correct');
                } else if (index === selectedIndex) {
                    button.classList.add('incorrect');
                }
            });
            
            // Wait 2 seconds before proceeding
            setTimeout(() => {
                // Hide trivia container
                document.querySelector('.trivia-container').classList.remove('active');
                
                // Remove the current marker from the map
                if (currentLocationIndex < allLocationMarkers.length) {
                    map.removeLayer(allLocationMarkers[currentLocationIndex]);
                }
                
                // Move to next location or show congratulations
                currentLocationIndex++;
                isLocationHuntVisible = false;
                
                if (currentLocationIndex >= gameLocations.length) {
                    showCongratulations();
                } else {
                    // Update visible markers for the next location
                    updateVisibleMarkers();
                    
                    // Update distance box for new location
                    if (lastPosition) {
                        const location = gameLocations[currentLocationIndex];
                        const distance = calculateDistance(
                            { lat: lastPosition.lat, lng: lastPosition.lng },
                            { lat: location.lat, lng: location.lng }
                        );
                        const distanceFeet = Math.round(distance * 3.28084);
                        updateDistanceBox(location, distanceFeet);
                    }
                }
            }, 2000);
        }

        // Show congratulations screen
        function showCongratulations() {
            document.getElementById('congratulations').style.display = 'flex';
        }

        // End tour function
        function endTour() {
            window.location.href = 'index.html';
        }

        // Show preloader
        function showPreloader() {
            const preloader = document.getElementById('preloader');
            if (preloader) {
                preloader.style.display = 'flex';
                
                // Animate progress bar
                const progressBar = document.getElementById('preloaderProgress');
                let progress = 0;
                const interval = setInterval(() => {
                    progress += 1;
                    if (progressBar) progressBar.style.width = `${progress}%`;
                    if (progress >= 100) clearInterval(interval);
                }, 50);
            }
        }

        // Hide preloader
        function hidePreloader() {
            const preloader = document.getElementById('preloader');
            if (preloader) {
                preloader.style.opacity = '0';
                preloader.style.transition = 'opacity 0.5s ease';
                setTimeout(() => {
                    preloader.style.display = 'none';
                }, 500);
            }
        }

        // Show popup
        function showPopup(message) {
            const popup = document.getElementById('popup');
            const popupMessage = document.getElementById('popupMessage');
            
            if (popup && popupMessage) {
                popupMessage.textContent = message;
                popup.style.display = 'flex';
            } else {
                alert(message);
            }
        }

        // Close popup
        function closePopup() {
            const popup = document.getElementById('popup');
            if (popup) {
                popup.style.display = 'none';
            }
        }

        // Check if popup is open
        function isPopupOpen() {
            const popup = document.getElementById('popup');
            return popup ? popup.style.display === 'flex' : false;
        }

        // Handle location errors
        function handleLocationError(error) {
            console.error("Geolocation error:", error);
            hidePreloader();
            
            let message = "Unable to access your location. ";
            
            switch(error.code) {
                case 1:
                    message += "Please enable location services for this website.";
                    break;
                case 2:
                    message += "Location information is unavailable.";
                    break;
                case 3:
                    message += "The request to get your location timed out.";
                    break;
                default:
                    message += "An unknown error occurred.";
            }
            
            showPopup(message);
        }

        // Handle visibility change
        function handleVisibilityChange() {
            if (document.hidden) {
                lastHiddenTime = Date.now();
            } else {
                const hiddenDuration = Date.now() - lastHiddenTime;
                if (hiddenDuration > BACKGROUND_THRESHOLD) {
                    // App was in background for significant time, reset tracking
                    if (userMarker && lastPosition) {
                        // Force position update
                        updateUserLocation({
                            coords: {
                                latitude: lastPosition.lat,
                                longitude: lastPosition.lng,
                                accuracy: lastPosition.accuracy,
                                heading: lastPosition.heading,
                                speed: lastPosition.speedMPS
                            }
                        }, true);
                    }
                }
            }
        }

        // Reset inactivity timer
        function resetInactivityTimer() {
            if (inactivityTimer) {
                clearTimeout(inactivityTimer);
            }
            
            inactivityTimer = setTimeout(() => {
                if (!isMapInteracting && !userIsInteracting) {
                    followUser = true;
                    if (userMarker && userMarker.getLatLng()) {
                        map.setView(userMarker.getLatLng(), targetZoomLevel);
                    }
                }
            }, INACTIVITY_TIMEOUT);
        }

        // Recenter map
        function recenterMap() {
            const recenterButton = document.getElementById('recenterButton');
            if (recenterButton) {
                recenterButton.style.backgroundColor = "#005f9e";
                recenterButton.style.color = "white";
            }
            
            if (userMarker && userMarker.getLatLng()) {
                map.setView(userMarker.getLatLng(), targetZoomLevel);
                followUser = true;
            }
            
            setTimeout(() => {
                if (recenterButton) {
                    recenterButton.style.backgroundColor = "white";
                    recenterButton.style.color = "#005f9e";
                }
            }, 500);
        }

        // Toggle navigation tips
        function toggleNavigationTips() {
            const tipsElement = document.querySelector('.navigation-tips');
            tipsElement.style.display = tipsElement.style.display === 'none' || tipsElement.style.display === '' ? 'block' : 'none';
        }

        // Close navigation tips
        function closeNavigationTips() {
            document.querySelector('.navigation-tips').style.display = 'none';
        }

        // Make functions available globally for event handlers
        window.showDirectionsModal = showDirectionsModal;
        window.closeDirectionsModal = closeDirectionsModal;
        window.skipToNextLocation = skipToNextLocation;
        window.closePopup = closePopup;
        window.endTour = endTour;

        // Add event listeners when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize map
            initMap();
            
            // Add event listeners for UI elements
            document.getElementById('recenterButton').addEventListener('click', recenterMap);
            document.getElementById('returnButton').addEventListener('click', () => showPopup('Are you sure you want to exit the tour?'));
            document.getElementById('tipsButton').addEventListener('click', toggleNavigationTips);
            document.querySelector('.navigation-tips .close-button').addEventListener('click', closeNavigationTips);
            
            // Initialize inactivity timer
            resetInactivityTimer();
        });
    </script>
</body>
</html>
