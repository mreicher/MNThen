<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, viewport-fit=cover">
    <title>Minnesota Then | Self-Guided Tours</title>
    <link rel="shortcut icon" type="image/x-icon" href="https://www.mnthen.com/images/mnthenfav.ico">
    
    <!-- Resource hints for faster connections -->
    <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
    <link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
    <link rel="dns-prefetch" href="https://tile.openstreetmap.org">
    
    <!-- Optimized CSS loading with preload -->
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css"></noscript>
    
    <!-- Other stylesheets with preload for critical resources -->
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <noscript>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.css">
    </noscript>
    
    <!-- Async load non-critical CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" media="print" onload="this.media='all'">
    
 <style>
 /* Base styles */
 :root {
 --primary-color: #2c5282;
 --primary-light: #3182ce;
 --primary-dark: #1a365d;
 --secondary-color: #e53e3e;
 --secondary-light: #fc8181;
 --secondary-dark: #c53030;
 --accent-color: #38a169;
 --accent-light: #68d391;
 --accent-dark: #276749;
 --text-color: #2d3748;
 --text-light: #4a5568;
 --text-lighter: #718096;
 --bg-color: #ffffff;
 --bg-light: #f7fafc;
 --bg-dark: #edf2f7;
 --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
 --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
 --shadow-md: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
 --shadow-lg: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
 --radius-sm: 0.125rem;
 --radius: 0.25rem;
 --radius-md: 0.375rem;
 --radius-lg: 0.5rem;
 --radius-xl: 1rem;
 --radius-2xl: 1.5rem;
 --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
 --transition-fast: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
 --transition-slow: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
 --font-sans: 'Segoe UI', -apple-system, BlinkMacSystemFont, 'Helvetica Neue', Arial, sans-serif;
 }

 * {
 margin: 0;
 padding: 0;
 box-sizing: border-box;
 }
 
 body {
 margin: 0;
 padding: 0;
 font-family: var(--font-sans);
 overflow: hidden;
 height: 100vh;
 width: 100vw;
 position: relative;
 color: var(--text-color);
 background-color: var(--bg-color);
 -webkit-font-smoothing: antialiased;
 -moz-osx-font-smoothing: grayscale;
 touch-action: manipulation;
 overscroll-behavior: none; /* Prevent pull-to-refresh */
 }
 
 #map {
 height: 100vh;
 width: 100%;
 z-index: 1;
 touch-action: none; /* Prevent default touch behaviors */
 -webkit-user-select: none;
 user-select: none;
 will-change: transform; /* Optimize for animations */
 contain: strict; /* Improve performance */
 }
 
 /* Enhanced Distance box */
 #distanceBox {
 position: absolute;
 top: 16px;
 left: 16px;
 background-color: rgba(255, 255, 255, 0.98);
 padding: 16px 20px;
 border-radius: var(--radius-lg);
 box-shadow: var(--shadow-md);
 z-index: 1000;
 font-size: 20px;
 font-weight: 600;
 color: var(--text-color);
 min-width: 200px;
 max-width: 320px;
 transition: var(--transition);
 border-left: 6px solid var(--primary-color);
 display: flex;
 align-items: center;
 backdrop-filter: blur(5px);
 transform: translateZ(0);
 will-change: transform, opacity;
 }

 #distanceBox .location-icon {
 margin-right: 15px;
 color: var(--primary-color);
 font-size: 24px;
 }

 #distanceBox .distance-info {
 display: flex;
 flex-direction: column;
 font-size: 20px;
 }

 #distanceBox .location-name {
 font-weight: 700;
 margin-bottom: 4px;
 color: var(--primary-color);
 font-size: 20px;
 }

 #distanceBox .distance-value {
 font-size: 16px;
 color: var(--text-light);
 font-weight: 500;
 }

 /* Location hunt container */
 .lochunt-container {
 position: fixed;
 bottom: 0;
 left: 0;
 width: 100%;
 height: 80%;
 background-color: var(--bg-color);
 z-index: 1500;
 border-radius: var(--radius-2xl) var(--radius-2xl) 0 0;
 box-shadow: var(--shadow-lg);
 transform: translateY(100%);
 transition: transform 0.5s cubic-bezier(0.16, 1, 0.3, 1);
 overflow: hidden;
 display: none;
 will-change: transform;
 }
 
 .lochunt-container.active {
 transform: translateY(0);
 display: block;
 }
 
 .lochunt-content {
 padding: 24px;
 overflow-y: auto;
 height: calc(100% - 200px);
 -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
 }
 
 #locationImage {
 width: 100%;
 height: 200px;
 object-fit: cover;
 object-position: center;
 will-change: transform; /* Optimize for animations */
 }
 
 .lochunt-info {
 margin-bottom: 24px;
 }
 
 .lochunt-info h2 {
 color: var(--primary-color);
 margin-bottom: 8px;
 font-weight: 700;
 }
 
 .lochunt-info p {
 line-height: 1.6;
 margin-bottom: 16px;
 }
 
 .text-muted {
 color: var(--text-lighter);
 font-size: 14px;
 }
 
 /* Audio player */
 .audio-player {
 margin-top: 24px;
 padding: 20px;
 background-color: var(--bg-light);
 border-radius: var(--radius-lg);
 box-shadow: var(--shadow-sm);
 }
 
 .audio-progress {
 margin-bottom: 12px;
 }
 
 .progress {
 height: 6px;
 background-color: var(--bg-dark);
 border-radius: var(--radius-xl);
 overflow: hidden;
 cursor: pointer;
 }
 
 .progress-bar {
 background-color: var(--primary-color);
 height: 100%;
 border-radius: var(--radius-xl);
 transition: width 0.1s linear;
 will-change: width; /* Optimize for animations */
 }
 
 .audio-time {
 display: flex;
 justify-content: space-between;
 font-size: 12px;
 color: var(--text-lighter);
 margin-bottom: 12px;
 }
 
 .audio-controls {
 display: flex;
 justify-content: space-between;
 align-items: center;
 max-width: 200px;
 margin: 0 auto;
 }
 
 .audio-button {
 background-color: var(--bg-color);
 border: 2px solid var(--primary-color);
 color: var(--primary-color);
 width: 44px;
 height: 44px;
 border-radius: 50%;
 display: flex;
 align-items: center;
 justify-content: center;
 cursor: pointer;
 transition: var(--transition-fast);
 -webkit-tap-highlight-color: transparent;
 will-change: transform, background-color, color; /* Optimize for animations */
 }
 
 .audio-button:hover, .audio-button:active {
 background-color: var(--primary-color);
 color: var(--bg-color);
 transform: translateY(-2px);
 }
 
 /* Trivia container */
 .trivia-container {
 position: fixed;
 bottom: 0;
 left: 0;
 width: 100%;
 background-color: var(--bg-color);
 z-index: 1500;
 border-radius: var(--radius-2xl) var(--radius-2xl) 0 0;
 box-shadow: var(--shadow-lg);
 padding: 24px;
 transform: translateY(100%);
 transition: transform 0.5s cubic-bezier(0.16, 1, 0.3, 1);
 display: none;
 will-change: transform;
 }
 
 .trivia-container.active {
 transform: translateY(0);
 display: block;
 }
 
 .trivia-container h3 {
 color: var(--primary-color);
 margin-bottom: 16px;
 font-weight: 700;
 }
 
 .trivia-option {
 background-color: var(--bg-light);
 border: 2px solid var(--bg-dark);
 border-radius: var(--radius-lg);
 padding: 16px;
 margin-bottom: 12px;
 cursor: pointer;
 transition: var(--transition-fast);
 font-weight: 500;
 text-align: left;
 width: 100%;
 color: var(--text-color);
 will-change: transform, background-color; /* Optimize for animations */
 }
 
 .trivia-option:hover, .trivia-option:active {
 background-color: var(--bg-dark);
 transform: translateY(-2px);
 }
 
 .trivia-option.correct {
 background-color: var(--accent-light);
 border-color: var(--accent-color);
 color: var(--accent-dark);
 }
 
 .trivia-option.incorrect {
 background-color: var(--secondary-light);
 border-color: var(--secondary-color);
 color: var(--secondary-dark);
 }
 
 /* Map buttons: horizontal and centered at bottom */
 .map-buttons {
 position: fixed; 
 bottom: 40px; 
 left: 50%;
 transform: translateX(-50%);
 display: flex;
 flex-direction: row;
 gap: 16px;
 z-index: 1000;
 background-color: rgba(255, 255, 255, 0.9);
 padding: 12px 16px;
 border-radius: var(--radius-xl);
 box-shadow: var(--shadow-md);
 backdrop-filter: blur(5px);
 width: auto; /* Ensure width is based on content */
 max-width: 90%; /* Prevent overflow on very small screens */
 will-change: transform; /* Optimize for animations */
 }
 
 .map-button {
 width: 50px;
 height: 50px;
 border-radius: 50%;
 background-color: var(--bg-color);
 border: none;
 box-shadow: var(--shadow);
 display: flex;
 align-items: center;
 justify-content: center;
 font-size: 22px;
 color: var(--primary-color);
 cursor: pointer;
 transition: var(--transition-fast);
 -webkit-tap-highlight-color: transparent;
 will-change: transform, background-color, color; /* Optimize for animations */
 }
 
 .map-button:hover, .map-button:active {
 background-color: var(--primary-color);
 color: var(--bg-color);
 transform: scale(1.05);
 box-shadow: var(--shadow-md);
 }
 
 .map-button.active {
 background-color: var(--primary-color);
 color: var(--bg-color);
 }
 
 /* Navigation tips */
 .navigation-tips {
 position: fixed;
 top: 50%;
 left: 50%;
 transform: translate(-50%, -50%);
 background-color: var(--bg-color);
 border-radius: var(--radius-lg);
 box-shadow: var(--shadow-lg);
 padding: 24px;
 z-index: 2000;
 max-width: 90%;
 width: 350px;
 display: none;
 }
 
 .navigation-tips h3 {
 margin-bottom: 16px;
 color: var(--primary-color);
 font-weight: 700;
 }
 
 .navigation-tips ul {
 padding-left: 20px;
 }
 
 .navigation-tips li {
 margin-bottom: 12px;
 line-height: 1.5;
 }
 
 .close-button {
 position: absolute;
 top: 12px;
 right: 12px;
 background: none;
 border: none;
 font-size: 20px;
 cursor: pointer;
 color: var(--text-lighter);
 transition: var(--transition-fast);
 -webkit-tap-highlight-color: transparent;
 }
 
 .close-button:hover, .close-button:active {
 color: var(--text-color);
 }
 
 /* Congratulations */
 #congratulations {
 position: fixed;
 top: 0;
 left: 0;
 width: 100%;
 height: 100%;
 background-color: rgba(0, 0, 0, 0.85);
 display: flex;
 flex-direction: column;
 align-items: center;
 justify-content: center;
 z-index: 3000;
 color: var(--bg-color);
 text-align: center;
 padding: 24px;
 display: none;
 backdrop-filter: blur(5px);
 }
 
 #congratulations h2 {
 font-size: 36px;
 margin-bottom: 24px;
 font-weight: 800;
 }
 
 #congratulations p {
 font-size: 18px;
 margin-bottom: 32px;
 max-width: 600px;
 line-height: 1.6;
 }
 
 #congratulations button {
 background-color: var(--primary-color);
 color: var(--bg-color);
 border: none;
 padding: 16px 32px;
 border-radius: var(--radius-xl);
 font-size: 18px;
 font-weight: 600;
 cursor: pointer;
 transition: var(--transition);
 box-shadow: var(--shadow);
 }
 
 #congratulations button:hover, #congratulations button:active {
 background-color: var(--primary-dark);
 transform: translateY(-3px);
 box-shadow: var(--shadow-md);
 }
 
 /* Enhanced user marker styles */
 .user-marker-icon {
 width: 24px;
 height: 24px;
 background-color: var(--secondary-color);
 border: 3px solid white;
 border-radius: 50%;
 box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
 position: relative;
 transition: transform 0.2s cubic-bezier(0.25, 0.1, 0.25, 1);
 will-change: transform;
 }
 
 .user-marker-icon::after {
 content: '';
 position: absolute;
 top: 50%;
 left: 50%;
 width: 36px;
 height: 36px;
 background-color: rgba(229, 62, 62, 0.2);
 border-radius: 50%;
 transform: translate(-50%, -50%);
 animation: pulse 2s infinite;
 will-change: transform, opacity;
 }
 
 @keyframes pulse {
 0% {
 transform: translate(-50%, -50%) scale(1);
 opacity: 1;
 }
 100% {
 transform: translate(-50%, -50%) scale(2);
 opacity: 0;
 }
 }
 
 /* Stationary indicator */
 .user-marker-stationary .user-marker-icon {
 border-color: var(--accent-color);
 transition: border-color 0.5s ease-out;
 }
 
 .user-marker-stationary .user-marker-icon::after {
 background-color: rgba(56, 161, 105, 0.15);
 animation: stationaryPulse 3s infinite;
 }
 
 @keyframes stationaryPulse {
 0% {
 transform: translate(-50%, -50%) scale(1);
 opacity: 0.6;
 }
 50% {
 transform: translate(-50%, -50%) scale(1.3);
 opacity: 0.3;
 }
 100% {
 transform: translate(-50%, -50%) scale(1);
 opacity: 0.6;
 }
 }
 
 /* Optimize for hardware acceleration */
 #map, .user-marker-icon, .lochunt-container, .trivia-container {
 transform: translateZ(0);
 backface-visibility: hidden;
 perspective: 1000px;
 }
 
 /* Stabilizing modal */
 .stabilizing-modal {
 position: fixed;
 top: 50%;
 left: 50%;
 transform: translate(-50%, -50%);
 background-color: var(--bg-color);
 padding: 24px;
 border-radius: var(--radius-lg);
 box-shadow: var(--shadow-lg);
 z-index: 2000;
 text-align: center;
 max-width: 80%;
 display: flex;
 flex-direction: column;
 align-items: center;
 }
 
 .stabilizing-modal h3 {
 margin-bottom: 16px;
 color: var(--primary-color);
 font-weight: 700;
 }
 
 .stabilizing-modal p {
 margin-bottom: 20px;
 line-height: 1.5;
 }
 
 .stabilizing-modal .spinner {
 width: 48px;
 height: 48px;
 border: 4px solid rgba(44, 82, 130, 0.2);
 border-top: 4px solid var(--primary-color);
 border-radius: 50%;
 margin-bottom: 24px;
 animation: spin 1s linear infinite;
 will-change: transform;
 }
 
 @keyframes spin {
 0% { transform: rotate(0deg); }
 100% { transform: rotate(360deg); }
 }
 
 /* Preloader styles */
 #preloader {
 position: fixed;
 top: 0;
 left: 0;
 width: 100%;
 height: 100%;
 background-color: var(--bg-color);
 display: flex;
 flex-direction: column;
 justify-content: center;
 align-items: center;
 z-index: 9999;
 }

 #preloader .spinner {
 width: 60px;
 height: 60px;
 border: 5px solid rgba(44, 82, 130, 0.2);
 border-top: 5px solid var(--primary-color);
 border-radius: 50%;
 margin-bottom: 24px;
 animation: spin 1s linear infinite;
 will-change: transform;
 }

 #preloader p {
 font-size: 18px;
 color: var(--text-color);
 margin-top: 16px;
 font-weight: 500;
 }

 #preloader .progress-container {
 width: 80%;
 max-width: 300px;
 height: 8px;
 background-color: var(--bg-dark);
 border-radius: var(--radius-xl);
 margin-top: 20px;
 overflow: hidden;
 }

 #preloader .progress-bar {
 height: 100%;
 background-color: var(--primary-color);
 width: 0%;
 transition: width 0.3s ease;
 border-radius: var(--radius-xl);
 will-change: width;
 }
 
 /* Popup styles */
 #popup {
 position: fixed;
 top: 0;
 left: 0;
 width: 100%;
 height: 100%;
 background-color: rgba(0, 0, 0, 0.5);
 display: flex;
 align-items: center;
 justify-content: center;
 z-index: 3000;
 display: none;
 backdrop-filter: blur(3px);
 }
 
 .popup-content {
 background-color: var(--bg-color);
 border-radius: var(--radius-lg);
 padding: 24px;
 max-width: 90%;
 width: 350px;
 text-align: center;
 box-shadow: var(--shadow-lg);
 }
 
 #popupMessage {
 margin-bottom: 24px;
 line-height: 1.5;
 }
 
 .popup-button {
 background-color: var(--primary-color);
 color: var(--bg-color);
 border: none;
 padding: 12px 24px;
 border-radius: var(--radius-lg);
 font-weight: 600;
 cursor: pointer;
 transition: var(--transition);
 }
 
 .popup-button:hover, .popup-button:active {
 background-color: var(--primary-dark);
 transform: translateY(-2px);
 }
 
 /* Enhanced Location marker styles with numbering */
 .location-marker-icon {
 width: 40px;
 height: 40px;
 background-color: #006400;
 border: 3px solid white;
 border-radius: 50%;
 box-shadow: var(--shadow);
 position: relative;
 transition: var(--transition);
 display: flex;
 align-items: center;
 justify-content: center;
 color: white;
 font-weight: bold;
 font-size: 16px;
 will-change: transform;
 }
 
 .location-marker-icon:hover {
 transform: scale(1.1);
 background-color: var(--primary-dark);
 }
 
 /* Enhanced Marker popup styles */
 .marker-popup {
 max-width: 300px;
 padding: 0;
 }
 
 .marker-popup-image {
 width: 100%;
 height: 150px;
 object-fit: cover;
 border-radius: var(--radius-lg) var(--radius-lg) 0 0;
 margin-bottom: 0;
 }
 
 .marker-popup-content {
 padding: 16px;
 }
 
 .marker-popup-title {
 font-size: 18px;
 font-weight: bold;
 margin-bottom: 8px;
 color: var(--primary-color);
 }
 
 .marker-popup-description {
 font-size: 14px;
 margin-bottom: 16px;
 color: var(--text-light);
 line-height: 1.5;
 }
 
 .marker-popup-actions {
 display: flex;
 justify-content: space-between;
 gap: 12px;
 }
 
 .popup-btn {
 padding: 10px 16px;
 border-radius: var(--radius);
 font-size: 14px;
 font-weight: 600;
 cursor: pointer;
 text-align: center;
 transition: var(--transition-fast);
 display: flex;
 align-items: center;
 justify-content: center;
 gap: 8px;
 flex: 1;
 }
 
 .popup-btn.directions {
 background-color: var(--primary-color);
 color: white;
 border: none;
 }
 
 .popup-btn.directions:hover, .popup-btn.directions:active {
 background-color: var(--primary-dark);
 transform: translateY(-2px);
 }
 
 .popup-btn.skip {
 background-color: var(--bg-light);
 color: var(--text-light);
 border: 1px solid var(--bg-dark);
 }
 
 .popup-btn.skip:hover, .popup-btn.skip:active {
 background-color: var(--bg-dark);
 transform: translateY(-2px);
 }
 
 /* Directions modal */
 #directionsModal {
 position: fixed;
 top: 0;
 left: 0;
 width: 100%;
 height: 100%;
 background-color: rgba(0, 0, 0, 0.5);
 display: flex;
 align-items: center;
 justify-content: center;
 z-index: 3000;
 display: none;
 backdrop-filter: blur(3px);
 }
 
 .directions-modal-content {
 background-color: var(--bg-color);
 border-radius: var(--radius-lg);
 padding: 24px;
 max-width: 90%;
 width: 320px;
 box-shadow: var(--shadow-lg);
 }
 
 .directions-modal-title {
 font-size: 18px;
 font-weight: 700;
 margin-bottom: 20px;
 color: var(--text-color);
 text-align: center;
 }
 
 .directions-buttons {
 display: flex;
 flex-direction: column;
 gap: 12px;
 margin-bottom: 20px;
 }
 
 .direction-btn {
 padding: 14px;
 border-radius: var(--radius);
 font-size: 16px;
 font-weight: 600;
 cursor: pointer;
 text-align: center;
 transition: var(--transition-fast);
 display: flex;
 align-items: center;
 justify-content: center;
 gap: 12px;
 text-decoration: none;
 }
 
 .direction-btn.google {
 background-color: #4285F4;
 color: white;
 border: none;
 }
 
 .direction-btn.apple {
 background-color: #000000;
 color: white;
 border: none;
 }
 
 .direction-btn.waze {
 background-color: #33CCFF;
 color: white;
 border: none;
 }
 
 .direction-btn:hover, .direction-btn:active {
 transform: translateY(-2px);
 box-shadow: var(--shadow);
 }
 
 .cancel-btn {
 background-color: var(--bg-light);
 color: var(--text-light);
 border: 1px solid var(--bg-dark);
 padding: 12px;
 border-radius: var(--radius);
 font-size: 16px;
 font-weight: 600;
 cursor: pointer;
 text-align: center;
 transition: var(--transition-fast);
 width: 100%;
 }
 
 .cancel-btn:hover, .cancel-btn:active {
 background-color: var(--bg-dark);
 }
 
 /* Leaflet popup customization */
 .leaflet-popup-content-wrapper {
 padding: 0;
 overflow: hidden;
 border-radius: var(--radius-lg);
 box-shadow: var(--shadow-md);
 }
 
 .leaflet-popup-content {
 margin: 0;
 width: 280px !important;
 }
 
 .leaflet-popup-tip-container {
 margin-top: -1px;
 }
 
 .leaflet-popup-close-button {
 color: white !important;
 top: 5px !important;
 right: 5px !important;
 font-size: 20px !important;
 text-shadow: 0 0 3px rgba(0, 0, 0, 0.5);
 }
 
 /* Navigation buttons */
 .marker-popup-navigation {
 display: flex;
 flex-direction: column;
 gap: 10px;
 margin-top: 16px;
 }
 
 .nav-button {
 display: flex;
 align-items: center;
 justify-content: center;
 gap: 8px;
 padding: 10px;
 border-radius: var(--radius);
 text-decoration: none;
 font-weight: 600;
 font-size: 14px;
 transition: var(--transition-fast);
 }
 
 .nav-button.google {
 background-color: #4285F4;
 color: white;
 }
 
 .nav-button.apple {
 background-color: #000000;
 color: white;
 }
 
 .nav-button.waze {
 background-color: #33CCFF;
 color: white;
 }
 
 .nav-button:hover, .nav-button:active {
 transform: translateY(-2px);
 box-shadow: var(--shadow);
 }
 
 /* Fix for iOS Safari 100vh issue */
 @supports (-webkit-touch-callout: none) {
 #map, .lochunt-container {
     height: -webkit-fill-available;
 }
 }
 
 /* Responsive adjustments */
 @media (max-width: 768px) {
 .map-buttons {
 bottom: 30px; /* Adjust for medium screens */
 padding: 10px 14px;
 gap: 12px;
 }
 
 .map-button {
 width: 46px;
 height: 46px;
 font-size: 20px;
 }
 
 #distanceBox {
 max-width: 280px;
 padding: 14px 16px;
 }
 }
 
 @media (max-width: 480px) {
 .map-buttons {
 bottom: 25px; /* Increase from 20px to 25px for small screens */
 padding: 8px 12px;
 gap: 10px;
 }
 
 .map-button {
 width: 40px; /* Slightly smaller buttons on very small screens */
 height: 40px;
 font-size: 16px;
 }
 
 #distanceBox {
 max-width: 260px;
 padding: 12px 14px;
 left: 12px;
 top: 12px;
 font-size: 18px;
 }
 
 #distanceBox .location-icon {
 font-size: 20px;
 margin-right: 10px;
 }
 
 #distanceBox .location-name {
 font-size: 18px;
 }
 
 #distanceBox .distance-value {
 font-size: 16px;
 }
 
 .marker-popup {
 max-width: 260px;
 }
 
 .marker-popup-image {
 height: 130px;
 }
 }

 /* Add a new media query for very small screens or devices with unusual interfaces */
 @media (max-height: 600px), (max-width: 360px) {
 .map-buttons {
 bottom: 15px; /* Even more compact for very small screens */
 }
 
 .map-button {
 width: 36px;
 height: 36px;
 font-size: 14px;
 }
 }

 /* Add a safe area inset for iOS devices with notches */
 @supports (padding-bottom: env(safe-area-inset-bottom)) {
 .map-buttons {
 bottom: calc(25px + env(safe-area-inset-bottom));
 }
 }
 </style>

</head>
<body>
    <!-- Preloader -->
    <div id="preloader">
        <div class="spinner"></div>
        <p>Loading Minnesota Then Tours...</p>
        <div class="progress-container">
            <div class="progress-bar" id="preloaderProgress"></div>
        </div>
    </div>

    <div id="map" role="application" aria-label="Interactive map of historical locations"></div>
    
    <!-- Enhanced Distance Box -->
    <div id="distanceBox" aria-live="polite">
        <div class="location-icon">
            <i class="fas fa-map-marker-alt"></i>
        </div>
        <div class="distance-info">
            <div class="location-name">Initializing...</div>
            <div class="distance-value">Finding your location</div>
        </div>
    </div>
    
    <div class="lochunt-container" aria-hidden="true">
        <img id="locationImage" src="/placeholder.svg?height=200&width=400" alt="Location Image">
        <div class="lochunt-content">
            <div class="lochunt-info">
                <h2 id="locationTitle" class="mb-2"></h2>
                <p id="locationCity" class="text-muted mb-1"></p>
                <p id="locationCreator" class="text-muted mb-3"></p>
                <p id="locationDescription" class="mb-3"></p>
                
                <div class="marker-popup-navigation">
                    <a href="#" id="googleMapsLink" class="nav-button google" target="_blank" rel="noopener noreferrer">
                        <i class="fab fa-google"></i> Google Maps
                    </a>
                    <a href="#" id="appleMapsLink" class="nav-button apple" target="_blank" rel="noopener noreferrer">
                        <i class="fab fa-apple"></i> Apple Maps
                    </a>
                    <a href="#" id="wazeLink" class="nav-button waze" target="_blank" rel="noopener noreferrer">
                        <i class="fab fa-waze"></i> Waze
                    </a>
                </div>
            </div>
            <div class="audio-player">
                <div class="audio-progress">
                    <div class="progress">
                        <div id="progressBar" class="progress-bar" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" style="width: 0%"></div>
                    </div>
                </div>
                <div class="audio-time">
                    <span id="currentTime">0:00</span>
                    <span id="duration">0:00</span>
                </div>
                <div class="audio-controls">
                    <button id="rewindBtn" class="audio-button" aria-label="Rewind 10 seconds"><i class="fas fa-backward"></i></button>
                    <button id="playPauseBtn" class="audio-button" aria-label="Play"><i class="fas fa-play"></i></button>
                    <button id="forwardBtn" class="audio-button" aria-label="Forward 10 seconds"><i class="fas fa-forward"></i></button>
                </div>
                <audio id="locationAudio" src="/placeholder.svg" preload="metadata"></audio>
            </div>
        </div>
    </div>
    
    <div class="trivia-container" aria-hidden="true">
        <h3 class="mb-3">Trivia Question</h3>
        <p id="triviaQuestion" class="mb-3 fw-bold"></p>
        <div id="triviaOptions" class="d-grid gap-2"></div>
    </div>
    
    <!-- Enhanced Map Buttons: Horizontal and centered at bottom -->
    <div class="map-buttons">
        <button id="recenterButton" class="map-button" aria-label="Recenter map"><i class="fas fa-crosshairs"></i></button>
        <button id="returnButton" class="map-button" aria-label="Return to home"><i class="fas fa-sign-out-alt"></i></button>
        <button id="tipsButton" class="map-button" aria-label="Show tips"><i class="fas fa-question-circle"></i></button>
    </div>
    
    <div class="navigation-tips" aria-hidden="true">
        <button class="close-button" aria-label="Close tips">&times;</button>
        <h3>Navigation Tips</h3>
        <ul>
            <li>Numbered markers show your tour stops in sequence.</li>
            <li>After visiting a location, the next stop will appear.</li>
            <li>Tap on a marker to see details and navigation options.</li>
            <li>The distance box shows how far you are from the current location.</li>
            <li>Tap the recenter button to focus on your position.</li>
            <li>When you're within 20 feet of a location, you'll be able to interact with it.</li>
            <li>Complete the trivia question to move to the next location.</li>
            <li>The map will automatically zoom in when you get closer to a location.</li>
        </ul>
    </div>
    
    <div id="congratulations" aria-hidden="true">
        <h2>Congratulations!</h2>
        <p>You have successfully completed the Minnesota Then Gangster History Tour!</p>
        <button onclick="endTour()">Return to the Home Page</button>
    </div>
    
    <div id="popup" aria-hidden="true">
        <div class="popup-content">
            <p id="popupMessage"></p>
            <button class="popup-button" onclick="closePopup()">OK</button>
        </div>
    </div>
    
    <!-- Directions Modal -->
    <div id="directionsModal" aria-hidden="true">
        <div class="directions-modal-content">
            <div class="directions-modal-title">Choose Navigation App</div>
            <div class="directions-buttons">
                <a href="#" id="googleMapsBtn" class="direction-btn google" target="_blank" rel="noopener noreferrer">
                    <i class="fab fa-google"></i> Google Maps
                </a>
                <a href="#" id="appleMapsBtn" class="direction-btn apple" target="_blank" rel="noopener noreferrer">
                    <i class="fab fa-apple"></i> Apple Maps
                </a>
                <a href="#" id="wazeBtn" class="direction-btn waze" target="_blank" rel="noopener noreferrer">
                    <i class="fab fa-waze"></i> Waze
                </a>
            </div>
            <button class="cancel-btn" onclick="closeDirectionsModal()">Cancel</button>
        </div>
    </div>

    <!-- Load scripts with defer to improve page load performance -->
    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js" defer></script>
    
    <script>
        // Sample locations data (replace with your actual data)
        const locations = [
            {
                id: 1,
                name: "Landmark Center",
                city: "St. Paul",
                creator: "Minnesota Historical Society",
                lat: 44.9448,
                lng: -93.0962,
                image: "https://www.mnthen.com/images/landmark-center.jpg",
                audio: "https://www.mnthen.com/audio/landmark-center.mp3",
                description: "The Landmark Center, completed in 1902, originally served as the Federal Court House and Post Office for the Upper Midwest. This Richardsonian Romanesque building was where many famous gangsters were tried during the 1930s.",
                trivia: {
                    question: "What was the Landmark Center originally built as?",
                    options: [
                        "A hotel",
                        "A federal courthouse and post office",
                        "A train station",
                        "A department store"
                    ],
                    answer: 1
                }
            },
            {
                id: 2,
                name: "Wabasha Street Caves",
                city: "St. Paul",
                creator: "Minnesota Historical Society",
                lat: 44.9338,
                lng: -93.1059,
                image: "https://www.mnthen.com/images/wabasha-caves.jpg",
                audio: "https://www.mnthen.com/audio/wabasha-caves.mp3",
                description: "The Wabasha Street Caves were originally mined for silica in the 1840s. During Prohibition, the caves became a speakeasy known as the Castle Royal. Gangsters like John Dillinger and Ma Barker were rumored to frequent the establishment.",
                trivia: {
                    question: "What illegal activity took place in the Wabasha Street Caves during Prohibition?",
                    options: [
                        "Counterfeiting money",
                        "Illegal gambling",
                        "Speakeasy and nightclub",
                        "All of the above"
                    ],
                    answer: 3
                }
            },
            {
                id: 3,
                name: "Nina's Coffee Cafe",
                city: "St. Paul",
                creator: "Minnesota Historical Society",
                lat: 44.9463,
                lng: -93.1032,
                image: "https://www.mnthen.com/images/ninas-cafe.jpg",
                audio: "https://www.mnthen.com/audio/ninas-cafe.mp3",
                description: "Nina's Coffee Cafe is located in the historic Blair Flats building. The building is rumored to have been a hideout for Al Capone during his visits to St. Paul. The cafe now serves as a popular community gathering spot.",
                trivia: {
                    question: "Which famous gangster was rumored to have a hideout above what is now Nina's Coffee Cafe?",
                    options: [
                        "Al Capone",
                        "John Dillinger",
                        "Ma Barker",
                        "Baby Face Nelson"
                    ],
                    answer: 0
                }
            }
        ];

        // Global variables
        let map, userMarker;
        let currentLocationIndex = 0;
        let visitedLocations = [];
        let gameLocations = [];
        let inactivityTimer;
        let isLocationHuntVisible = false;
        let lastPosition = null;
        let positionBuffer = [];
        const MAX_BUFFER_SIZE = 15; // Increased buffer size for smoother tracking
        const DISTANCE_THRESHOLD = 20; // 20 feet to measure threshold distance to marker before opening location page
        const PROXIMITY_THRESHOLD = 100; // 100 feet to trigger zoom level change
        const velocity = { lat: 0, lng: 0 };
        let isMapInteracting = false;
        let followUser = true; // Always true to keep user centered
        let allLocationMarkers = [];
        let showingAllLocations = false;
        let userIsInteracting = false;
        const preloadedImages = new Map(); // Map to store preloaded images
        const preloadedAudio = new Map(); // Map to store preloaded audio
        let currentSpeed = 0; // Current speed in meters per second
        let lastZoomLevel = 17; // Default zoom level
        let stationaryPositionHistory = []; // Array to store stationary positions for averaging
        let deviceOrientation = null; // Store device orientation data
        let deviceMotion = null; // Store device motion data
        let orientationPermissionGranted = false;
        let activeMarkers = []; // Track currently visible markers
        let currentDirectionsLocation = null; // Store current location for directions modal
        let lastProximityState = null; // Track last proximity state for zoom changes
        let isWithinProximity = false; // Flag to track if user is within proximity of a location

        // Enhanced constants for better stabilization
        const MICRO_MOVEMENT_THRESHOLD = 0.3; // Meters - threshold for detecting micro-movements
        const STATIONARY_ACCURACY_MULTIPLIER = 1.02; // Tighter accuracy bounds
        const MAX_ACCEPTABLE_ACCURACY = 25; // meters - stricter accuracy requirement
        const STATIONARY_THRESHOLD = 5; // Number of consecutive stationary positions to consider user as stationary
        const STATIONARY_TIME_THRESHOLD = 2000; // ms - time to consider user stationary
        const STATIONARY_CHECK_INTERVAL = 1000; // ms - interval to check if still stationary
        const VELOCITY_DECAY = 0.92; // Higher value for smoother velocity transitions
        const MIN_DISTANCE_THRESHOLD = 0.8; // meters - minimum distance to consider movement
        const EXTENDED_DISTANCE_THRESHOLD = 80; // meters - distance to consider a significant position change
        const UPDATE_INTERVAL = 16; // ms - more frequent updates for smoother animation (approx 60fps)
        const STATIONARY_POSITION_HISTORY_SIZE = 15; // Number of positions to keep for stationary averaging
        const STATIONARY_POSITION_WEIGHT_DECAY = 0.9; // Weight decay for older positions in stationary average

        // Background handling constants
        const BACKGROUND_THRESHOLD = 20000; // ms - time to consider app was in background
        const INACTIVITY_TIMEOUT = 25000; // ms - time to consider user inactive

        // Kalman filter parameters - optimized for better stationary stability
        const KALMAN_PROCESS_NOISE = 0.004; // Lower value for smoother tracking
        const KALMAN_MEASUREMENT_NOISE_BASE = 1.2; // Increased base measurement noise
        const KALMAN_STATIONARY_NOISE = 0.02; // Lower noise when stationary

        // Animation parameters
        const ANIMATION_DURATION = 180; // ms - duration of position animation
        const HEADING_SMOOTHING = 0.9; // Heading smoothing factor

        // Dynamic zoom level parameters - enhanced for better speed adaptation
        const MAX_ZOOM_LEVEL = 17; // Maximum zoom level (stationary)
        const MIN_ZOOM_LEVEL = 13; // Minimum zoom level (high speed)
        const DEFAULT_ZOOM_LEVEL = 17; // Default zoom level for walking speed
        const PROXIMITY_ZOOM_LEVEL = 18; // Zoom level when in proximity to a location
        const WALKING_SPEED_THRESHOLD = 1.5; // m/s - threshold for walking speed
        const RUNNING_SPEED_THRESHOLD = 4.0; // m/s - threshold for running speed
        const DRIVING_SPEED_THRESHOLD = 8.0; // m/s - threshold for driving speed
        const HIGH_SPEED_THRESHOLD = 20.0; // m/s - threshold for high speed
        const ZOOM_TRANSITION_DURATION = 0.5; // seconds - duration of zoom transition
        const ZOOM_UPDATE_INTERVAL = 1000; // ms - interval to update zoom level

        // Motion detection parameters
        const MOTION_THRESHOLD = 0.6; // Threshold for detecting significant motion
        const MOTION_SAMPLE_SIZE = 8; // Number of motion samples to keep
        const MOTION_CHECK_INTERVAL = 100; // ms - interval to check motion

        // Edge detection parameters - updated for better recentering
        const EDGE_THRESHOLD_PERCENTAGE = 0.15; // Percentage from edge to trigger recenter
        const STRICT_EDGE_THRESHOLD_PERCENTAGE = 0.1; // Stricter threshold for edge detection
        const CRITICAL_EDGE_THRESHOLD_PERCENTAGE = 0.05; // Critical threshold for immediate recenter
        const RECENTER_COOLDOWN = 500; // ms - cooldown between recenters to prevent excessive recentering

        // Dynamic recentering parameters
        const SPEED_RECENTER_THRESHOLD = 5.0; // m/s - speed threshold to adjust recenter behavior
        const RECENTER_OFFSET_FACTOR = 0.3; // Factor to offset the center point ahead of user when moving fast

        // State variables
        let lastUpdateTime = null;
        let lastVelocity = { lat: 0, lng: 0 };
        let isStationary = false;
        let stationaryStartTime = null;
        let stationaryCheckTimeout = null;
        let lastUpdateTimestamp = null;
        let lastHiddenTime = 0;
        let stationaryCount = 0;
        let lastRecenterTime = Date.now();
        let stationaryBuffer = [];
        let isStabilizing = true; // Flag to track initial stabilization
        let lastStationaryPosition = null; // Last stable position when stationary
        let motionSamples = []; // Array to store motion samples
        let deviceStationaryTime = 0; // Time device has been stationary based on motion sensors
        let animationFrameId = null; // Store requestAnimationFrame ID
        let renderTimestamp = null; // Last render timestamp
        let positionUpdateQueue = []; // Queue for position updates to be processed
        let lastHeadingValue = null; // Last heading value
        let headingBuffer = []; // Buffer for heading values
        let isFirstPositionUpdate = true; // Flag for first position update
        let lastRenderPosition = null; // Last rendered position
        let positionInterpolator = null; // Position interpolator for smooth transitions
        let lastRawPosition = null; // Last raw position from GPS
        let consecutiveStationaryUpdates = 0; // Count consecutive stationary updates
        let lastDeviceMotionTimestamp = 0; // Last device motion timestamp
        let deviceMotionBuffer = []; // Buffer for device motion data
        let isDeviceStable = false; // Flag for device stability
        let lastAccuracy = null; // Last position accuracy
        let accuracyTrend = []; // Track accuracy trend
        let lastHeadingUpdateTime = 0; // Last heading update time
        let lastPositionUpdateTime = 0; // Last position update time
        let lastZoomUpdateTime = 0; // Last zoom update time
        let targetZoomLevel = DEFAULT_ZOOM_LEVEL; // Target zoom level for smooth transitions
        let lastSpeedForZoom = 0; // Last speed used for zoom calculation
        let speedSamples = []; // Array to store speed samples for zoom calculation
        let lastRecenterCheckTime = 0; // Last time we checked for recentering
        let lastProximityCheckTime = 0; // Last time we checked for proximity
        let proximityZoomActive = false; // Flag to track if proximity zoom is active
        let forceCenteringActive = false; // Flag to force centering regardless of other conditions
        let centeringPriority = 0; // Priority level for centering (0-10)
        let lastCenteringTime = 0; // Last time we centered the map
        let mapCenteringInterval = null; // Interval for continuous map centering
        let mapCenteringActive = false; // Flag to track if continuous centering is active

        // Enhanced Kalman Filter implementation
        class KalmanFilter {
            constructor() {
                // State variables
                this.x = 0; // Longitude estimate
                this.y = 0; // Latitude estimate
                this.vx = 0; // Longitude velocity
                this.vy = 0; // Latitude velocity

                // Error covariance matrix
                this.P = [
                    [100, 0, 0, 0], // Initial high uncertainty
                    [0, 100, 0, 0],
                    [0, 0, 10, 0],
                    [0, 0, 0, 10],
                ];

                // Process noise
                this.Q = KALMAN_PROCESS_NOISE;

                // Measurement noise (will be adjusted based on GPS accuracy)
                this.R = KALMAN_MEASUREMENT_NOISE_BASE;

                // Time delta
                this.dt = 1.0;

                // Initialized flag
                this.initialized = false;

                // Heading and accuracy tracking
                this.lastHeading = null;
                this.headingConfidence = 0;

                // Stationary mode flag
                this.stationaryMode = false;

                // Last timestamp
                this.lastTimestamp = null;

                // Adaptive noise parameters
                this.adaptiveNoiseMin = 0.002;
                this.adaptiveNoiseMax = 0.015;
                this.adaptiveNoiseFactor = 1.0;

                // Accuracy history
                this.accuracyHistory = [];
                this.maxAccuracyHistorySize = 5;

                // Jitter detection
                this.positionHistory = [];
                this.maxPositionHistorySize = 5;
                this.jitterThreshold = 0.5; // meters

                // Heading stability
                this.headingHistory = [];
                this.maxHeadingHistorySize = 8;
            }

            // Initialize the filter with first position
            reset(position) {
                if (!position || typeof position.lat !== "number" || typeof position.lng !== "number") {
                    console.error("Invalid position for Kalman filter reset");
                    return;
                }

                this.x = position.lng;
                this.y = position.lat;
                this.vx = 0;
                this.vy = 0;

                // Reset covariance matrix with high initial uncertainty
                this.P = [
                    [100, 0, 0, 0],
                    [0, 100, 0, 0],
                    [0, 0, 10, 0],
                    [0, 0, 0, 10],
                ];

                this.initialized = true;
                this.lastHeading = position.heading || null;
                this.headingConfidence = 0;
                this.stationaryMode = false;
                this.lastTimestamp = position.timestamp || Date.now();
                this.adaptiveNoiseFactor = 1.0;
                this.accuracyHistory = [];
                this.positionHistory = [];
                this.headingHistory = [];

                // Add initial position to history
                this.addToPositionHistory(position);
                if (position.accuracy) {
                    this.addToAccuracyHistory(position.accuracy);
                }
                if (position.heading !== null && position.heading !== undefined) {
                    this.addToHeadingHistory(position.heading);
                }
            }

            // Add position to history
            addToPositionHistory(position) {
                this.positionHistory.push({
                    lat: position.lat,
                    lng: position.lng,
                    timestamp: position.timestamp || Date.now(),
                });

                while (this.positionHistory.length > this.maxPositionHistorySize) {
                    this.positionHistory.shift();
                }
            }

            // Add accuracy to history
            addToAccuracyHistory(accuracy) {
                this.accuracyHistory.push(accuracy);

                while (this.accuracyHistory.length > this.maxAccuracyHistorySize) {
                    this.accuracyHistory.shift();
                }
            }

            // Add heading to history
            addToHeadingHistory(heading) {
                // Normalize heading to 0-360 range
                heading = ((heading % 360) + 360) % 360;

                this.headingHistory.push({
                    heading: heading,
                    timestamp: Date.now(),
                });

                while (this.headingHistory.length > this.maxHeadingHistorySize) {
                    this.headingHistory.shift();
                }
            }

            // Get median accuracy from history
            getMedianAccuracy() {
                if (this.accuracyHistory.length === 0) return 20;

                const sortedAccuracies = [...this.accuracyHistory].sort((a, b) => a - b);
                const mid = Math.floor(sortedAccuracies.length / 2);

                if (sortedAccuracies.length % 2 === 0) {
                    return (sortedAccuracies[mid - 1] + sortedAccuracies[mid]) / 2;
                } else {
                    return sortedAccuracies[mid];
                }
            }

            // Detect jitter in position history
            detectJitter() {
                if (this.positionHistory.length < 3) return false;

                // Calculate distances between consecutive positions
                const distances = [];
                for (let i = 1; i < this.positionHistory.length; i++) {
                    const p1 = this.positionHistory[i - 1];
                    const p2 = this.positionHistory[i];

                    // Calculate distance in meters
                    const distance = calculateDistance(p1, p2);

                    // Calculate time delta in seconds
                    const timeDelta = (p2.timestamp - p1.timestamp) / 1000;

                    // Calculate speed in m/s
                    const speed = timeDelta > 0 ? distance / timeDelta : 0;

                    distances.push({ distance, speed });
                }

                // Check for rapid direction changes (jitter)
                if (distances.length >= 2) {
                    const lastDistance = distances[distances.length - 1].distance;
                    const prevDistance = distances[distances.length - 2].distance;

                    // If both distances are small but non-zero, it might be jitter
                    if (
                        lastDistance > 0 &&
                        lastDistance < this.jitterThreshold &&
                        prevDistance > 0 &&
                        prevDistance < this.jitterThreshold
                    ) {
                        return true;
                    }
                }

                return false;
            }

            // Get stable heading from history
            getStableHeading() {
                if (this.headingHistory.length < 3) {
                    return this.lastHeading;
                }

                // Get recent headings (last 3)
                const recentHeadings = this.headingHistory.slice(-3).map((h) => h.heading);

                // Check if headings are stable (within 15 degrees of each other)
                let isStable = true;
                for (let i = 1; i < recentHeadings.length; i++) {
                    const diff = Math.abs(recentHeadings[i] - recentHeadings[i - 1]);
                    const normalizedDiff = Math.min(diff, 360 - diff);
                    if (normalizedDiff > 15) {
                        isStable = false;
                        break;
                    }
                }

                if (isStable) {
                    // Return median heading
                    const sortedHeadings = [...recentHeadings].sort((a, b) => a - b);
                    return sortedHeadings[Math.floor(sortedHeadings.length / 2)];
                }

                return this.lastHeading;
            }

            // Set stationary mode
            setStationaryMode(isStationary) {
                this.stationaryMode = isStationary;

                // When entering stationary mode, reduce velocity to zero
                if (isStationary) {
                    this.vx = 0;
                    this.vy = 0;

                    // Reduce process noise for stationary mode
                    this.Q = KALMAN_STATIONARY_NOISE;
                } else {
                    // Reset process noise for moving mode
                    this.Q = KALMAN_PROCESS_NOISE;
                }
            }

            // Update the filter with a new measurement
            update(measurement) {
                if (!this.initialized) {
                    this.reset(measurement);
                    return {
                        lat: this.y,
                        lng: this.x,
                        accuracy: measurement.accuracy || 20,
                        heading: measurement.heading,
                        timestamp: measurement.timestamp || Date.now(),
                        speedMPS: measurement.speedMPS || 0
                    };
                }

                // Calculate time delta
                const timestamp = measurement.timestamp || Date.now();
                this.dt = (timestamp - this.lastTimestamp) / 1000; // Convert to seconds
                this.lastTimestamp = timestamp;

                // Limit dt to reasonable values
                if (this.dt <= 0 || this.dt > 5) {
                    this.dt = 0.1; // Default to 100ms if time delta is unreasonable
                }

                // Add to position history for jitter detection
                this.addToPositionHistory(measurement);

                // Add to accuracy history
                if (measurement.accuracy) {
                    this.addToAccuracyHistory(measurement.accuracy);
                }

                // Add to heading history if available
                if (measurement.heading !== null && measurement.heading !== undefined) {
                    this.addToHeadingHistory(measurement.heading);
                }

                // Detect jitter
                const isJittery = this.detectJitter();

                // Adjust measurement noise based on accuracy and jitter
                const accuracyFactor = measurement.accuracy ? Math.max(1, measurement.accuracy / 10) : 1;
                this.R = KALMAN_MEASUREMENT_NOISE_BASE * accuracyFactor;

                // Increase measurement noise if jitter is detected
                if (isJittery) {
                    this.R *= 2;
                }

                // Adjust process noise based on speed
                if (measurement.speedMPS !== undefined && measurement.speedMPS !== null) {
                    // Higher speed = higher process noise (more trust in measurements)
                    const speedFactor = Math.min(3, Math.max(0.5, 1 + measurement.speedMPS / 10));
                    this.adaptiveNoiseFactor = this.stationaryMode ? 0.2 : speedFactor;
                } else {
                    this.adaptiveNoiseFactor = this.stationaryMode ? 0.2 : 1.0;
                }

                // Apply adaptive noise factor
                const adaptiveQ = this.Q * this.adaptiveNoiseFactor;

                // Prediction step
                // State transition matrix F
                const F = [
                    [1, 0, this.dt, 0],
                    [0, 1, 0, this.dt],
                    [0, 0, 1, 0],
                    [0, 0, 0, 1]
                ];

                // Predicted state
                const x_pred = this.x + this.vx * this.dt;
                const y_pred = this.y + this.vy * this.dt;
                const vx_pred = this.vx;
                const vy_pred = this.vy;

                // Process noise matrix Q
                const Q = [
                    [adaptiveQ * Math.pow(this.dt, 4) / 4, 0, adaptiveQ * Math.pow(this.dt, 3) / 2, 0],
                    [0, adaptiveQ * Math.pow(this.dt, 4) / 4, 0, adaptiveQ * Math.pow(this.dt, 3) / 2],
                    [adaptiveQ * Math.pow(this.dt, 3) / 2, 0, adaptiveQ * Math.pow(this.dt, 2), 0],
                    [0, adaptiveQ * Math.pow(this.dt, 3) / 2, 0, adaptiveQ * Math.pow(this.dt, 2)]
                ];

                // Predicted covariance
                const P_pred = [
                    [0, 0, 0, 0],
                    [0, 0, 0, 0],
                    [0, 0, 0, 0],
                    [0, 0, 0, 0]
                ];

                // P_pred = F * P * F^T + Q
                for (let i = 0; i < 4; i++) {
                    for (let j = 0; j < 4; j++) {
                        let sum = 0;
                        for (let k = 0; k < 4; k++) {
                            for (let l = 0; l < 4; l++) {
                                sum += F[i][k] * this.P[k][l] * F[j][l];
                            }
                        }
                        P_pred[i][j] = sum + Q[i][j];
                    }
                }

                // Update step
                // Measurement matrix H
                const H = [
                    [1, 0, 0, 0],
                    [0, 1, 0, 0]
                ];

                // Measurement
                const z = [measurement.lng, measurement.lat];

                // Innovation (measurement residual)
                const y = [z[0] - x_pred, z[1] - y_pred];

                // Innovation covariance
                const S = [
                    [P_pred[0][0] + this.R, P_pred[0][1]],
                    [P_pred[1][0], P_pred[1][1] + this.R]
                ];

                // Determinant of S
                const detS = S[0][0] * S[1][1] - S[0][1] * S[1][0];

                // Inverse of S
                const S_inv = [
                    [S[1][1] / detS, -S[0][1] / detS],
                    [-S[1][0] / detS, S[0][0] / detS]
                ];

                // Kalman gain
                const K = [
                    [0, 0],
                    [0, 0],
                    [0, 0],
                    [0, 0]
                ];

                // K = P_pred * H^T * S^-1
                for (let i = 0; i < 4; i++) {
                    for (let j = 0; j < 2; j++) {
                        let sum = 0;
                        for (let k = 0; k < 2; k++) {
                            sum += P_pred[i][k] * S_inv[k][j];
                        }
                        K[i][j] = sum;
                    }
                }

                // Updated state
                this.x = x_pred + K[0][0] * y[0] + K[0][1] * y[1];
                this.y = y_pred + K[1][0] * y[0] + K[1][1] * y[1];
                this.vx = vx_pred + K[2][0] * y[0] + K[2][1] * y[1];
                this.vy = vy_pred + K[3][0] * y[0] + K[3][1] * y[1];

                // Updated covariance
                // P = (I - K * H) * P_pred
                const I_KH = [
                    [1 - K[0][0], -K[0][1], 0, 0],
                    [-K[1][0], 1 - K[1][1], 0, 0],
                    [-K[2][0], -K[2][1], 1, 0],
                    [-K[3][0], -K[3][1], 0, 1]
                ];

                this.P = [
                    [0, 0, 0, 0],
                    [0, 0, 0, 0],
                    [0, 0, 0, 0],
                    [0, 0, 0, 0]
                ];

                for (let i = 0; i < 4; i++) {
                    for (let j = 0; j < 4; j++) {
                        let sum = 0;
                        for (let k = 0; k < 4; k++) {
                            sum += I_KH[i][k] * P_pred[k][j];
                        }
                        this.P[i][j] = sum;
                    }
                }

                // Update heading
                if (measurement.heading !== null && measurement.heading !== undefined) {
                    // Get stable heading
                    const stableHeading = this.getStableHeading();
                    this.lastHeading = stableHeading !== null ? stableHeading : measurement.heading;
                }

                // Calculate speed from velocity components
                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy) * 111000; // Convert to m/s (approx)

                // Return filtered position
                return {
                    lat: this.y,
                    lng: this.x,
                    accuracy: this.getMedianAccuracy(),
                    heading: this.lastHeading,
                    timestamp: timestamp,
                    speedMPS: measurement.speedMPS !== undefined ? measurement.speedMPS : speed,
                    isFiltered: true
                };
            }
        }

        // Position interpolator for smooth transitions
        class PositionInterpolator {
            constructor() {
                this.startPosition = null;
                this.endPosition = null;
                this.startTime = 0;
                this.duration = 300; // Default duration in ms
                this.isActive = false;
                this.easing = this.easeOutCubic; // Default easing function
            }

            // Start a new interpolation
            start(startPosition, endPosition, duration = 300) {
                if (!startPosition || !endPosition) return;

                this.startPosition = { ...startPosition };
                this.endPosition = { ...endPosition };
                this.startTime = performance.now();
                this.duration = duration;
                this.isActive = true;
            }

            // Get interpolated position at current time
            getCurrentPosition() {
                if (!this.isActive || !this.startPosition || !this.endPosition) {
                    return null;
                }

                const currentTime = performance.now();
                const elapsed = currentTime - this.startTime;

                if (elapsed >= this.duration) {
                    this.isActive = false;
                    return { ...this.endPosition };
                }

                const progress = this.easing(elapsed / this.duration);

                return {
                    lat: this.startPosition.lat + (this.endPosition.lat - this.startPosition.lat) * progress,
                    lng: this.startPosition.lng + (this.endPosition.lng - this.startPosition.lng) * progress,
                    accuracy: this.endPosition.accuracy,
                    heading: this.endPosition.heading,
                    timestamp: currentTime,
                    speedMPS: this.endPosition.speedMPS
                };
            }

            // Cubic easing function for smooth transitions
            easeOutCubic(t) {
                return 1 - Math.pow(1 - t, 3);
            }
        }

        // Initialize Kalman filter
        const kalmanFilter = new KalmanFilter();

        // Initialize position interpolator
        positionInterpolator = new PositionInterpolator();

        // Calculate distance between two points using Haversine formula
        function calculateDistance(pos1, pos2) {
            if (!pos1 || !pos2 || 
                typeof pos1.lat !== 'number' || typeof pos1.lng !== 'number' || 
                typeof pos2.lat !== 'number' || typeof pos2.lng !== 'number') {
                return Infinity;
            }
            
            // Haversine formula implementation
            const R = 6371000; // Earth's radius in meters
            const lat1 = pos1.lat * Math.PI / 180;
            const lat2 = pos2.lat * Math.PI / 180;
            const deltaLat = (pos2.lat - pos1.lat) * Math.PI / 180;
            const deltaLng = (pos2.lng - pos1.lng) * Math.PI / 180;

            const a = Math.sin(deltaLat/2) * Math.sin(deltaLat/2) +
                    Math.cos(lat1) * Math.cos(lat2) *
                    Math.sin(deltaLng/2) * Math.sin(deltaLng/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

            return R * c;
        }

        // Calculate bearing between two points
        function calculateBearing(pos1, pos2) {
            if (!pos1 || !pos2) return 0;
            
            const lat1 = pos1.lat * Math.PI / 180;
            const lat2 = pos2.lat * Math.PI / 180;
            const lng1 = pos1.lng * Math.PI / 180;
            const lng2 = pos2.lng * Math.PI / 180;
            
            const y = Math.sin(lng2 - lng1) * Math.cos(lat2);
            const x = Math.cos(lat1) * Math.sin(lat2) -
                    Math.sin(lat1) * Math.cos(lat2) * Math.cos(lng2 - lng1);
            
            let bearing = Math.atan2(y, x) * 180 / Math.PI;
            bearing = (bearing + 360) % 360; // Normalize to 0-360
            
            return bearing;
        }

        // Format distance for display
        function formatDistance(meters) {
            const feet = meters * 3.28084;
            
            if (feet < 1000) {
                return `${Math.round(feet)} feet`;
            } else {
                const miles = feet / 5280;
                return `${miles.toFixed(2)} miles`;
            }
        }

        // Format time for audio player
        function formatTime(seconds) {
            if (!isFinite(seconds)) return "0:00";
            
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.floor(seconds % 60);
            
            return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
        }

        // Throttle function to limit execution frequency
        function throttle(func, limit) {
            let inThrottle;
            return function() {
                const args = arguments;
                const context = this;
                
                if (!inThrottle) {
                    func.apply(context, args);
                    inThrottle = true;
                    setTimeout(() => inThrottle = false, limit);
                }
            };
        }

        // Debounce function to delay execution until after a pause
        function debounce(func, wait) {
            let timeout;
            return function() {
                const context = this;
                const args = arguments;
                
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(context, args), wait);
            };
        }

        // Show popup message
        function showPopup(message) {
            const popup = document.getElementById('popup');
            const popupMessage = document.getElementById('popupMessage');
            
            popupMessage.textContent = message;
            popup.style.display = 'flex';
            popup.setAttribute('aria-hidden', 'false');
        }

        // Close popup
        function closePopup() {
            const popup = document.getElementById('popup');
            popup.style.display = 'none';
            popup.setAttribute('aria-hidden', 'true');
        }

        // Show directions modal
        function showDirectionsModal(location) {
            const modal = document.getElementById('directionsModal');
            const googleBtn = document.getElementById('googleMapsBtn');
            const appleBtn = document.getElementById('appleMapsBtn');
            const wazeBtn = document.getElementById('wazeBtn');
            
            // Store current location for directions
            currentDirectionsLocation = location;
            
            // Set up navigation links
            if (userMarker) {
                const userPos = userMarker.getLatLng();
                
                // Google Maps
                googleBtn.href = `https://www.google.com/maps/dir/?api=1&origin=${userPos.lat},${userPos.lng}&destination=${location.lat},${location.lng}&travelmode=walking`;
                
                // Apple Maps (works on iOS)
                appleBtn.href = `maps://maps.apple.com/maps?saddr=${userPos.lat},${userPos.lng}&daddr=${location.lat},${location.lng}&dirflg=w`;
                
                // Waze
                wazeBtn.href = `https://waze.com/ul?ll=${location.lat},${location.lng}&navigate=yes`;
            }
            
            modal.style.display = 'flex';
            modal.setAttribute('aria-hidden', 'false');
        }

        // Close directions modal
        function closeDirectionsModal() {
            const modal = document.getElementById('directionsModal');
            modal.style.display = 'none';
            modal.setAttribute('aria-hidden', 'true');
        }

        // Update navigation links in location hunt container
        function updateNavigationLinks(location) {
            const googleMapsLink = document.getElementById('googleMapsLink');
            const appleMapsLink = document.getElementById('appleMapsLink');
            const wazeLink = document.getElementById('wazeLink');
            
            if (userMarker) {
                const userPos = userMarker.getLatLng();
                
                // Google Maps
                googleMapsLink.href = `https://www.google.com/maps/dir/?api=1&origin=${userPos.lat},${userPos.lng}&destination=${location.lat},${location.lng}&travelmode=walking`;
                
                // Apple Maps (works on iOS)
                appleMapsLink.href = `maps://maps.apple.com/maps?saddr=${userPos.lat},${userPos.lng}&daddr=${location.lat},${location.lng}&dirflg=w`;
                
                // Waze
                wazeLink.href = `https://waze.com/ul?ll=${location.lat},${location.lng}&navigate=yes`;
            }
        }

        // Show location hunt container
        function showLocationHunt(location) {
            if (isLocationHuntVisible) return;
            
            isLocationHuntVisible = true;
            
            const container = document.querySelector('.lochunt-container');
            const locationImage = document.getElementById('locationImage');
            const locationTitle = document.getElementById('locationTitle');
            const locationCity = document.getElementById('locationCity');
            const locationCreator = document.getElementById('locationCreator');
            const locationDescription = document.getElementById('locationDescription');
            const locationAudio = document.getElementById('locationAudio');
            
            // Set location details
            locationImage.src = location.image;
            locationImage.alt = location.name;
            locationTitle.textContent = location.name;
            locationCity.textContent = location.city;
            locationCreator.textContent = `Created by: ${location.creator}`;
            locationDescription.textContent = location.description;
            locationAudio.src = location.audio;
            
            // Update navigation links
            updateNavigationLinks(location);
            
            // Show container with animation
            container.style.display = 'block';
            setTimeout(() => {
                container.classList.add('active');
            }, 10);
            
            container.setAttribute('aria-hidden', 'false');
            
            // Initialize audio player
            initAudioPlayer();
            
            // Mark location as visited
            if (!visitedLocations.includes(location.id)) {
                visitedLocations.push(location.id);
            }
            
            // Update marker appearance
            updateMarkerAppearance();
        }

        // Hide location hunt container
        function hideLocationHunt() {
            const container = document.querySelector('.lochunt-container');
            
            container.classList.remove('active');
            
            setTimeout(() => {
                container.style.display = 'none';
                container.setAttribute('aria-hidden', 'true');
                
                // Pause audio if playing
                const audio = document.getElementById('locationAudio');
                if (audio && !audio.paused) {
                    audio.pause();
                }
                
                isLocationHuntVisible = false;
            }, 500);
        }

        // Show trivia question
        function showTriviaQuestion(location) {
            if (!location.trivia) return;
            
            const container = document.querySelector('.trivia-container');
            const question = document.getElementById('triviaQuestion');
            const options = document.getElementById('triviaOptions');
            
            // Set question
            question.textContent = location.trivia.question;
            
            // Clear previous options
            options.innerHTML = '';
            
            // Add options
            location.trivia.options.forEach((option, index) => {
                const button = document.createElement('button');
                button.className = 'trivia-option';
                button.textContent = option;
                button.dataset.index = index;
                
                button.addEventListener('click', () => {
                    // Check answer
                    const isCorrect = index === location.trivia.answer;
                    
                    // Add appropriate class
                    button.classList.add(isCorrect ? 'correct' : 'incorrect');
                    
                    // If correct, show next location after delay
                    if (isCorrect) {
                        setTimeout(() => {
                            hideTriviaQuestion();
                            
                            // Move to next location if available
                            currentLocationIndex++;
                            
                            if (currentLocationIndex < gameLocations.length) {
                                // Show next location
                                updateActiveLocation();
                            } else {
                                // Tour completed
                                showCongratulations();
                            }
                        }, 1500);
                    }
                });
                
                options.appendChild(button);
            });
            
            // Show container with animation
            container.style.display = 'block';
            setTimeout(() => {
                container.classList.add('active');
            }, 10);
            
            container.setAttribute('aria-hidden', 'false');
        }

        // Hide trivia question
        function hideTriviaQuestion() {
            const container = document.querySelector('.trivia-container');
            
            container.classList.remove('active');
            
            setTimeout(() => {
                container.style.display = 'none';
                container.setAttribute('aria-hidden', 'true');
            }, 500);
        }

        // Show congratulations screen
        function showCongratulations() {
            const container = document.getElementById('congratulations');
            
            container.style.display = 'flex';
            container.setAttribute('aria-hidden', 'false');
        }

        // End tour and return to home page
        function endTour() {
            window.location.href = 'https://www.mnthen.com';
        }

        // Initialize audio player
        function initAudioPlayer() {
            const audio = document.getElementById('locationAudio');
            const playPauseBtn = document.getElementById('playPauseBtn');
            const rewindBtn = document.getElementById('rewindBtn');
            const forwardBtn = document.getElementById('forwardBtn');
            const progressBar = document.getElementById('progressBar');
            const progressContainer = document.querySelector('.progress');
            const currentTimeSpan = document.getElementById('currentTime');
            const durationSpan = document.getElementById('duration');
            
            // Reset UI
            playPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
            playPauseBtn.setAttribute('aria-label', 'Play');
            progressBar.style.width = '0%';
            currentTimeSpan.textContent = '0:00';
            durationSpan.textContent = '0:00';
            
            // Set up event listeners
            playPauseBtn.addEventListener('click', togglePlay);
            rewindBtn.addEventListener('click', () => seek(-10));
            forwardBtn.addEventListener('click', () => seek(10));
            audio.addEventListener('timeupdate', updateProgress);
            audio.addEventListener('loadedmetadata', setDuration);
            audio.addEventListener('ended', () => {
                playPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
                playPauseBtn.setAttribute('aria-label', 'Play');
                
                // Show trivia question after audio ends
                const currentLocation = gameLocations[currentLocationIndex];
                if (currentLocation && currentLocation.trivia) {
                    hideLocationHunt();
                    setTimeout(() => {
                        showTriviaQuestion(currentLocation);
                    }, 500);
                }
            });
            
            if (progressContainer) {
                progressContainer.addEventListener('click', setProgress);
            }
            
            // Preload audio
            audio.load();
            
            // Toggle play/pause
            function togglePlay() {
                if (audio.paused) {
                    const playPromise = audio.play();
                    
                    if (playPromise !== undefined) {
                        playPromise.then(() => {
                            playPauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
                            playPauseBtn.setAttribute('aria-label', 'Pause');
                        }).catch(error => {
                            console.error("Audio play error:", error);
                            showPopup("There was a problem playing the audio. Please try again.");
                        });
                    }
                } else {
                    audio.pause();
                    playPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
                    playPauseBtn.setAttribute('aria-label', 'Play');
                }
            }
            
            // Seek forward or backward
            function seek(seconds) {
                audio.currentTime = Math.max(0, Math.min(audio.currentTime + seconds, audio.duration));
            }
            
            // Update progress bar
            function updateProgress() {
                if (!isFinite(audio.duration)) return;
                
                const percent = (audio.currentTime / audio.duration) * 100;
                progressBar.style.width = `${percent}%`;
                progressBar.setAttribute('aria-valuenow', percent.toFixed(0));
                currentTimeSpan.textContent = formatTime(audio.currentTime);
            }
            
            // Set duration when metadata is loaded
            function setDuration() {
                if (isFinite(audio.duration)) {
                    durationSpan.textContent = formatTime(audio.duration);
                }
            }
            
            // Set progress when clicking on progress bar
            function setProgress(e) {
                const width = this.clientWidth;
                const clickX = e.offsetX;
                const duration = audio.duration;
                
                if (isFinite(duration) && width > 0) {
                    audio.currentTime = (clickX / width) * duration;
                }
            }
        }

        // Update marker appearance based on visited status
        function updateMarkerAppearance() {
            allLocationMarkers.forEach(marker => {
                const locationId = marker.options.locationId;
                const isVisited = visitedLocations.includes(locationId);
                const isActive = locationId === gameLocations[currentLocationIndex]?.id;
                
                // Get marker element
                const markerElement = marker.getElement();
                
                if (markerElement) {
                    // Update marker appearance based on status
                    if (isVisited) {
                        markerElement.classList.add('visited');
                    } else {
                        markerElement.classList.remove('visited');
                    }
                    
                    if (isActive) {
                        markerElement.classList.add('active');
                    } else {
                        markerElement.classList.remove('active');
                    }
                }
            });
        }

        // Update active location
        function updateActiveLocation() {
            const currentLocation = gameLocations[currentLocationIndex];
            
            if (!currentLocation) return;
            
            // Update distance box
            updateDistanceBox();
            
            // Update marker appearance
            updateMarkerAppearance();
            
            // Center map on active location if not following user
            if (!followUser && map) {
                map.setView([currentLocation.lat, currentLocation.lng], map.getZoom());
            }
        }

        // Update distance box with current location info
        function updateDistanceBox() {
            const distanceBox = document.getElementById('distanceBox');
            const locationNameElement = distanceBox.querySelector('.location-name');
            const distanceValueElement = distanceBox.querySelector('.distance-value');
            
            // If no user marker or no locations, show initializing
            if (!userMarker || !gameLocations || gameLocations.length === 0) {
                locationNameElement.textContent = 'Initializing...';
                distanceValueElement.textContent = 'Finding your location';
                return;
            }
            
            // Get current location
            const currentLocation = gameLocations[currentLocationIndex];
            
            if (!currentLocation) {
                locationNameElement.textContent = 'Tour Complete';
                distanceValueElement.textContent = 'All locations visited';
                return;
            }
            
            // Get user position
            const userPos = userMarker.getLatLng();
            
            // Calculate distance
            const distance = calculateDistance(
                { lat: userPos.lat, lng: userPos.lng },
                { lat: currentLocation.lat, lng: currentLocation.lng }
            );
            
            // Update distance box
            locationNameElement.textContent = currentLocation.name;
            distanceValueElement.textContent = formatDistance(distance);
            
            // Check if user is close enough to interact
            const distanceFeet = distance * 3.28084;
            
            if (distanceFeet <= DISTANCE_THRESHOLD && !isLocationHuntVisible) {
                showLocationHunt(currentLocation);
            }
            
            // Check proximity for zoom level adjustment
            checkProximityForZoom(distance);
        }

        // Check proximity to location for zoom level adjustment
        function checkProximityForZoom(distance) {
            // Skip if too soon since last check
            const now = Date.now();
            if (now - lastProximityCheckTime < 1000) return;
            lastProximityCheckTime = now;
            
            // Convert to feet
            const distanceFeet = distance * 3.28084;
            
            // Determine if within proximity
            const wasWithinProximity = isWithinProximity;
            isWithinProximity = distanceFeet <= PROXIMITY_THRESHOLD;
            
            // Only adjust zoom if proximity state changed
            if (wasWithinProximity !== isWithinProximity) {
                if (isWithinProximity) {
                    // Entering proximity zone - zoom in
                    proximityZoomActive = true;
                    targetZoomLevel = PROXIMITY_ZOOM_LEVEL;
                    
                    if (!isMapInteracting && map) {
                        map.flyTo(userMarker.getLatLng(), PROXIMITY_ZOOM_LEVEL, {
                            duration: ZOOM_TRANSITION_DURATION,
                            easeLinearity: 0.5
                        });
                    }
                } else {
                    // Exiting proximity zone - zoom out
                    proximityZoomActive = false;
                    targetZoomLevel = DEFAULT_ZOOM_LEVEL;
                    
                    if (!isMapInteracting && map) {
                        map.flyTo(userMarker.getLatLng(), DEFAULT_ZOOM_LEVEL, {
                            duration: ZOOM_TRANSITION_DURATION,
                            easeLinearity: 0.5
                        });
                    }
                }
            }
        }

        // Calculate speed-based zoom level
        function calculateSpeedBasedZoom(speedMPS) {
            // Skip if proximity zoom is active
            if (proximityZoomActive) return -1;
            
            // Add speed to samples
            speedSamples.push(speedMPS);
            
            // Keep only last 5 samples
            if (speedSamples.length > 5) {
                speedSamples.shift();
            }
            
            // Calculate median speed
            const sortedSpeeds = [...speedSamples].sort((a, b) => a - b);
            const medianSpeed = sortedSpeeds[Math.floor(sortedSpeeds.length / 2)];
            
            // Skip if speed hasn't changed significantly
            if (Math.abs(medianSpeed - lastSpeedForZoom) < 0.5) return -1;
            lastSpeedForZoom = medianSpeed;
            
            // Calculate zoom level based on speed
            let zoom;
            
            if (medianSpeed < WALKING_SPEED_THRESHOLD) {
                zoom = DEFAULT_ZOOM_LEVEL; // Walking or stationary
            } else if (medianSpeed < RUNNING_SPEED_THRESHOLD) {
                zoom = 16; // Running
            } else if (medianSpeed < DRIVING_SPEED_THRESHOLD) {
                zoom = 15; // Slow driving
            } else if (medianSpeed < HIGH_SPEED_THRESHOLD) {
                zoom = 14; // Driving
            } else {
                zoom = 13; // High speed
            }
            
            return zoom;
        }

        // Update user location with smooth transitions
        function updateUserLocation(position) {
            // Validate position data
            if (!position || !position.coords || 
                isNaN(position.coords.latitude) || 
                isNaN(position.coords.longitude)) {
                console.warn("Invalid position data received");
                return;
            }
            
            // Extract position data
            const { latitude, longitude, accuracy, heading, speed } = position.coords;
            const timestamp = position.timestamp || Date.now();
            
            // Create position object
            const newPosition = {
                lat: latitude,
                lng: longitude,
                accuracy: accuracy || 20,
                heading: heading !== null ? heading : lastHeadingValue,
                timestamp: timestamp,
                speedMPS: speed !== null ? speed : 0
            };
            
            // Store last heading value
            if (heading !== null) {
                lastHeadingValue = heading;
            }
            
            // Store last raw position
            lastRawPosition = { ...newPosition };
            
            // First position initialization
            if (isFirstPositionUpdate) {
                lastPosition = newPosition;
                kalmanFilter.reset(newPosition);
                lastUpdateTime = timestamp;
                isFirstPositionUpdate = false;
                
                // Initialize user marker
                if (!userMarker) {
                    initializeUserMarker(newPosition);
                } else {
                    userMarker.setLatLng([newPosition.lat, newPosition.lng]);
                }
                
                // Center map on user
                if (map) {
                    map.setView([newPosition.lat, newPosition.lng], DEFAULT_ZOOM_LEVEL);
                }
                
                // Update distance box
                updateDistanceBox();
                
                // Hide preloader
                hidePreloader();
                
                return;
            }
            
            // Calculate time delta
            const timeDelta = lastUpdateTime ? (timestamp - lastUpdateTime) / 1000 : 0;
            lastUpdateTime = timestamp;
            
            // Skip updates with unrealistic time deltas
            if (timeDelta > 10 || timeDelta <= 0) {
                console.warn("Unrealistic time delta:", timeDelta);
                return;
            }
            
            // Calculate distance from last position
            const distance = calculateDistance(lastPosition, newPosition);
            
            // Skip updates with unrealistic distances
            if (distance > 100 && timeDelta < 5) {
                console.warn("Unrealistic distance:", distance);
                return;
            }
            
            // Apply Kalman filter
            const filteredPosition = kalmanFilter.update(newPosition);
            
            // Update position buffer
            updatePositionBuffer(filteredPosition);
            
            // Calculate current speed
            currentSpeed = filteredPosition.speedMPS;
            
            // Check if stationary
            checkStationaryState(filteredPosition, distance);
            
            // Update user marker with smooth transition
            updateUserMarkerPosition(filteredPosition);
            
            // Update map center if following user
            if (followUser && !isMapInteracting) {
                updateMapCenter(filteredPosition);
            }
            
            // Update distance box
            updateDistanceBox();
            
            // Update last position
            lastPosition = filteredPosition;
            
            // Reset inactivity timer
            resetInactivityTimer();
        }

        // Initialize user marker
        function initializeUserMarker(position) {
            // Create custom icon
            const userIcon = L.divIcon({
                className: 'user-marker',
                html: '<div class="user-marker-icon"></div>',
                iconSize: [24, 24],
                iconAnchor: [12, 12]
            });
            
            // Create marker
            userMarker = L.marker([position.lat, position.lng], {
                icon: userIcon,
                zIndexOffset: 1000
            }).addTo(map);
        }

        // Update position buffer
        function updatePositionBuffer(position) {
            // Add position to buffer
            positionBuffer.push({
                lat: position.lat,
                lng: position.lng,
                accuracy: position.accuracy,
                heading: position.heading,
                timestamp: position.timestamp,
                speedMPS: position.speedMPS
            });
            
            // Remove old positions
            while (positionBuffer.length > MAX_BUFFER_SIZE) {
                positionBuffer.shift();
            }
        }

        // Check if user is stationary
        function checkStationaryState(position, distance) {
            // If distance is very small, might be stationary
            if (distance < MICRO_MOVEMENT_THRESHOLD) {
                // Increment stationary count
                stationaryCount++;
                
                // If stationary for enough updates, mark as stationary
                if (!isStationary && stationaryCount >= STATIONARY_THRESHOLD) {
                    isStationary = true;
                    stationaryStartTime = Date.now();
                    
                    // Set Kalman filter to stationary mode
                    kalmanFilter.setStationaryMode(true);
                    
                    // Add stationary class to user marker
                    if (userMarker) {
                        const markerElement = userMarker.getElement();
                        if (markerElement) {
                            markerElement.classList.add('user-marker-stationary');
                        }
                    }
                    
                    // Store stationary position
                    lastStationaryPosition = { ...position };
                    
                    // Clear stationary position history
                    stationaryPositionHistory = [];
                }
                
                // If already stationary, update stationary position history
                if (isStationary) {
                    // Add position to stationary history
                    stationaryPositionHistory.push({
                        lat: position.lat,
                        lng: position.lng,
                        accuracy: position.accuracy,
                        timestamp: position.timestamp,
                        weight: 1.0 // Initial weight
                    });
                    
                    // Keep only last N positions
                    if (stationaryPositionHistory.length > STATIONARY_POSITION_HISTORY_SIZE) {
                        stationaryPositionHistory.shift();
                    }
                    
                    // Update weights based on age
                    let totalWeight = 0;
                    for (let i = 0; i < stationaryPositionHistory.length; i++) {
                        const age = stationaryPositionHistory.length - i - 1;
                        const weight = Math.pow(STATIONARY_POSITION_WEIGHT_DECAY, age);
                        stationaryPositionHistory[i].weight = weight;
                        totalWeight += weight;
                    }
                    
                    // Calculate weighted average position
                    let weightedLat = 0;
                    let weightedLng = 0;
                    
                    for (const pos of stationaryPositionHistory) {
                        weightedLat += pos.lat * pos.weight / totalWeight;
                        weightedLng += pos.lng * pos.weight / totalWeight;
                    }
                    
                    // Update stationary position
                    lastStationaryPosition = {
                        lat: weightedLat,
                        lng: weightedLng,
                        accuracy: position.accuracy,
                        heading: position.heading,
                        timestamp: position.timestamp,
                        speedMPS: 0
                    };
                }
            } else {
                // Reset stationary count
                stationaryCount = 0;
                
                // If was stationary, mark as moving
                if (isStationary) {
                    isStationary = false;
                    
                    // Set Kalman filter to moving mode
                    kalmanFilter.setStationaryMode(false);
                    
                    // Remove stationary class from user marker
                    if (userMarker) {
                        const markerElement = userMarker.getElement();
                        if (markerElement) {
                            markerElement.classList.remove('user-marker-stationary');
                        }
                    }
                    
                    // Clear stationary position history
                    stationaryPositionHistory = [];
                    lastStationaryPosition = null;
                }
            }
        }

        // Update user marker position with smooth transition
        function updateUserMarkerPosition(position) {
            if (!userMarker) return;
            
            // If stationary, use stationary position
            const finalPosition = isStationary && lastStationaryPosition ? 
                lastStationaryPosition : position;
            
            // If first update or large distance, skip animation
            if (!lastRenderPosition || calculateDistance(lastRenderPosition, finalPosition) > 50) {
                userMarker.setLatLng([finalPosition.lat, finalPosition.lng]);
                lastRenderPosition = { ...finalPosition };
                return;
            }
            
            // Start position interpolation
            positionInterpolator.start(lastRenderPosition, finalPosition, ANIMATION_DURATION);
            
            // Use requestAnimationFrame for smooth animation
            function animate() {
                // Get interpolated position
                const interpolatedPosition = positionInterpolator.getCurrentPosition();
                
                if (interpolatedPosition) {
                    // Update marker position
                    userMarker.setLatLng([interpolatedPosition.lat, interpolatedPosition.lng]);
                    
                    // Store last render position
                    lastRenderPosition = { ...interpolatedPosition };
                    
                    // Continue animation if active
                    if (positionInterpolator.isActive) {
                        animationFrameId = requestAnimationFrame(animate);
                    }
                }
            }
            
            // Start animation
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            
            animationFrameId = requestAnimationFrame(animate);
        }

        // Update map center based on user position
        function updateMapCenter(position) {
            if (!map || !userMarker) return;
            
            // Skip if too soon since last check
            const now = Date.now();
            if (now - lastRecenterCheckTime < 200 && !forceCenteringActive) return;
            lastRecenterCheckTime = now;
            
            // Get current map bounds
            const bounds = map.getBounds();
            
            // Calculate edge proximity
            const edgeProximity = calculateEdgeProximity(position);
            
            // Check if user is near edge
            const isNearEdge = Object.values(edgeProximity).some(value => value < EDGE_THRESHOLD_PERCENTAGE);
            
            // Check if user is critically near edge
            const isCriticallyNearEdge = Object.values(edgeProximity).some(value => value < CRITICAL_EDGE_THRESHOLD_PERCENTAGE);
            
            // If near edge or force centering is active, recenter map
            if (isNearEdge || forceCenteringActive) {
                // Calculate optimal center point
                const centerPoint = calculateOptimalCenter(position);
                
                // Recenter map with animation
                map.panTo(centerPoint, {
                    animate: true,
                    duration: isCriticallyNearEdge ? 0.3 : 0.8,
                    easeLinearity: 0.5
                });
                
                // Update last recenter time
                lastRecenterTime = now;
            }
            
            // Check if zoom level should be updated based on speed
            if (now - lastZoomUpdateTime > ZOOM_UPDATE_INTERVAL && !proximityZoomActive) {
                const speedZoom = calculateSpeedBasedZoom(position.speedMPS);
                
                if (speedZoom !== -1 && Math.abs(map.getZoom() - speedZoom) > 0.5) {
                    map.flyTo(userMarker.getLatLng(), speedZoom, {
                        duration: ZOOM_TRANSITION_DURATION,
                        easeLinearity: 0.5
                    });
                    
                    lastZoomUpdateTime = now;
                }
            }
        }

        // Calculate edge proximity
        function calculateEdgeProximity(position) {
            if (!map) return { top: 1, right: 1, bottom: 1, left: 1 };
            
            const bounds = map.getBounds();
            const north = bounds.getNorth();
            const south = bounds.getSouth();
            const east = bounds.getEast();
            const west = bounds.getWest();
            
            const latRange = north - south;
            const lngRange = east - west;
            
            return {
                top: (north - position.lat) / latRange,
                right: (east - position.lng) / lngRange,
                bottom: (position.lat - south) / latRange,
                left: (position.lng - west) / lngRange
            };
        }

        // Calculate optimal center point
        function calculateOptimalCenter(position) {
            // If stationary, just use position
            if (isStationary) {
                return [position.lat, position.lng];
            }
            
            // If moving fast, offset center point in direction of movement
            if (position.speedMPS > SPEED_RECENTER_THRESHOLD && position.heading !== null) {
                // Calculate offset based on speed
                const offsetFactor = Math.min(0.3, position.speedMPS * 0.01);
                
                // Convert heading to radians
                const headingRad = position.heading * Math.PI / 180;
                
                // Calculate offset
                const latOffset = Math.cos(headingRad) * offsetFactor * 0.001;
                const lngOffset = Math.sin(headingRad) * offsetFactor * 0.001;
                
                // Return offset center point
                return [position.lat + latOffset, position.lng + lngOffset];
            }
            
            // Default to position
            return [position.lat, position.lng];
        }

        // Reset inactivity timer
        function resetInactivityTimer() {
            if (inactivityTimer) {
                clearTimeout(inactivityTimer);
            }
            
            inactivityTimer = setTimeout(() => {
                // If user hasn't interacted for a while, force centering
                if (!userIsInteracting) {
                    followUser = true;
                    forceCenteringActive = true;
                    
                    // Recenter map
                    recenterMap();
                    
                    // Reset force centering after a delay
                    setTimeout(() => {
                        forceCenteringActive = false;
                    }, 2000);
                }
            }, INACTIVITY_TIMEOUT);
        }

        // Recenter map on user
        function recenterMap() {
            if (!map || !userMarker) return;
            
            // Visual feedback
            const recenterButton = document.getElementById('recenterButton');
            recenterButton.classList.add('active');
            
            // Enable follow user
            followUser = true;
            
            // Center map on user
            map.flyTo(userMarker.getLatLng(), map.getZoom(), {
                animate: true,
                duration: 0.8,
                easeLinearity: 0.5
            });
            
            // Reset button after animation
            setTimeout(() => {
                recenterButton.classList.remove('active');
            }, 800);
        }

        // Show navigation tips
        function showNavigationTips() {
            const tips = document.querySelector('.navigation-tips');
            tips.style.display = 'block';
            tips.setAttribute('aria-hidden', 'false');
        }

        // Hide navigation tips
        function hideNavigationTips() {
            const tips = document.querySelector('.navigation-tips');
            tips.style.display = 'none';
            tips.setAttribute('aria-hidden', 'true');
        }

        // Hide preloader
        function hidePreloader() {
            const preloader = document.getElementById('preloader');
            
            // Fade out
            preloader.style.opacity = '0';
            
            // Remove after animation
            setTimeout(() => {
                preloader.style.display = 'none';
            }, 500);
        }

        // Initialize map
        function initMap() {
            // Create map
            map = L.map('map', {
                zoomControl: false,
                attributionControl: false,
                maxBounds: [
                    [44.8, -93.3], // Southwest
                    [45.1, -92.9]  // Northeast
                ],
                minZoom: 12,
                maxZoom: 19,
                zoomSnap: 0.5,
                zoomDelta: 0.5,
                wheelDebounceTime: 100,
                tapTolerance: 15,
                bounceAtZoomLimits: false,
                preferCanvas: true
            }).setView([44.95, -93.1], DEFAULT_ZOOM_LEVEL);
            
            // Add tile layer
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                maxZoom: 19,
                minZoom: 12
            }).addTo(map);
            
            // Add event listeners
            map.on('dragstart', () => {
                isMapInteracting = true;
                userIsInteracting = true;
                followUser = false;
            });
            
            map.on('dragend', () => {
                isMapInteracting = false;
                
                // Reset user interaction after delay
                setTimeout(() => {
                    userIsInteracting = false;
                }, 5000);
            });
            
            map.on('zoomstart', () => {
                isMapInteracting = true;
                userIsInteracting = true;
            });
            
            map.on('zoomend', () => {
                isMapInteracting = false;
                
                // Reset user interaction after delay
                setTimeout(() => {
                    userIsInteracting = false;
                }, 5000);
            });
            
            // Initialize location markers
            initLocationMarkers();
            
            // Start geolocation
            startGeolocation();
            
            // Initialize event listeners
            initEventListeners();
            
            // Start preloader progress
            startPreloaderProgress();
        }

        // Initialize location markers
        function initLocationMarkers() {
            // Clear existing markers
            allLocationMarkers = [];
            
            // Add markers for all locations
            gameLocations.forEach((location, index) => {
                // Create custom icon
                const markerIcon = L.divIcon({
                    className: 'location-marker',
                    html: `<div class="location-marker-icon">${index + 1}</div>`,
                    iconSize: [40, 40],
                    iconAnchor: [20, 20]
                });
                
                // Create marker
                const marker = L.marker([location.lat, location.lng], {
                    icon: markerIcon,
                    locationId: location.id
                }).addTo(map);
                
                // Add popup
                marker.bindPopup(createMarkerPopup(location), {
                    className: 'marker-popup',
                    maxWidth: 300,
                    closeButton: true
                });
                
                // Add click handler
                marker.on('click', () => {
                    // Check if user is close enough
                    if (userMarker) {
                        const userPos = userMarker.getLatLng();
                        const distance = calculateDistance(
                            { lat: userPos.lat, lng: userPos.lng },
                            { lat: location.lat, lng: location.lng }
                        );
                        
                        const distanceFeet = distance * 3.28084;
                        
                        if (distanceFeet <= DISTANCE_THRESHOLD) {
                            // Close popup
                            marker.closePopup();
                            
                            // Show location hunt
                            showLocationHunt(location);
                        }
                    }
                });
                
                // Store marker
                allLocationMarkers.push(marker);
            });
            
            // Update marker appearance
            updateMarkerAppearance();
        }

        // Create marker popup content
        function createMarkerPopup(location) {
            // Create popup content
            const content = document.createElement('div');
            
            // Add image if available
            if (location.image) {
                const img = document.createElement('img');
                img.src = location.image;
                img.alt = location.name;
                img.className = 'marker-popup-image';
                content.appendChild(img);
            }
            
            // Add content container
            const contentDiv = document.createElement('div');
            contentDiv.className = 'marker-popup-content';
            
            // Add title
            const title = document.createElement('div');
            title.className = 'marker-popup-title';
            title.textContent = location.name;
            contentDiv.appendChild(title);
            
            // Add description
            const description = document.createElement('div');
            description.className = 'marker-popup-description';
            description.textContent = location.city;
            contentDiv.appendChild(description);
            
            // Add actions
            const actions = document.createElement('div');
            actions.className = 'marker-popup-actions';
            
            // Add directions button
            const directionsBtn = document.createElement('button');
            directionsBtn.className = 'popup-btn directions';
            directionsBtn.innerHTML = '<i class="fas fa-directions"></i> Directions';
            directionsBtn.onclick = (e) => {
                e.stopPropagation();
                showDirectionsModal(location);
            };
            actions.appendChild(directionsBtn);
            
            // Add skip button
            const skipBtn = document.createElement('button');
            skipBtn.className = 'popup-btn skip';
            skipBtn.innerHTML = '<i class="fas fa-times"></i> Close';
            skipBtn.onclick = (e) => {
                e.stopPropagation();
                map.closePopup();
            };
            actions.appendChild(skipBtn);
            
            contentDiv.appendChild(actions);
            content.appendChild(contentDiv);
            
            return content;
        }

        // Start geolocation
        function startGeolocation() {
            if ('geolocation' in navigator) {
                // Get initial position
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        // Update user location
                        updateUserLocation(position);
                        
                        // Start watching position
                        navigator.geolocation.watchPosition(
                            updateUserLocation,
                            handleGeolocationError,
                            {
                                enableHighAccuracy: true,
                                maximumAge: 0,
                                timeout: 10000
                            }
                        );
                    },
                    handleGeolocationError,
                    {
                        enableHighAccuracy: true,
                        maximumAge: 0,
                        timeout: 10000
                    }
                );
                
                // Request device orientation permission
                requestDeviceOrientationPermission();
            } else {
                showPopup("Geolocation is not supported by your browser");
            }
        }

// Handle geolocation error
function handleGeolocationError(error) {
    console.error("Geolocation error:", error);
    
    let message = "An error occurred while getting your location.";
    
    switch (error.code) {
        case error.PERMISSION_DENIED:
            message = "You denied permission to access your location. Please enable location services to use this app.";
            break;
        case error.POSITION_UNAVAILABLE:
            message = "Location information is unavailable. Please check your device settings.";
            break;
        case error.TIMEOUT:
            message = "The request to get your location timed out. Please try again.";
            break;
    }
    
    // Display the error message to the user
    displayErrorMessage(message);
}

// Function to display error message to the user
function displayErrorMessage(message) {
    // Create or update an error element
    let errorElement = document.getElementById('location-error') || document.createElement('div');
    errorElement.id = 'location-error';
    errorElement.className = 'error-message';
    errorElement.textContent = message;
    
    // Add to the document if it doesn't exist
    if (!document.getElementById('location-error')) {
        document.body.appendChild(errorElement);
    }
}

        // Request device orientation permission
        function requestDeviceOrientationPermission() {
            if (typeof DeviceOrientationEvent !== 'undefined' && 
                typeof DeviceOrientationEvent.requestPermission === 'function') {
                // iOS 13+ requires permission
                DeviceOrientationEvent.requestPermission()
                    .then(permissionState => {
                        if (permissionState === 'granted') {
                            // Permission granted, add event listener
                            window.addEventListener('deviceorientation', handleDeviceOrientation);
                            orientationPermissionGranted = true;
                        }
                    })
                    .catch(console.error);
            } else {
                // Other browsers don't require permission
                window.addEventListener('deviceorientation', handleDeviceOrientation);
                orientationPermissionGranted = true;
            }
            
            // Add device motion listener
            if (typeof DeviceMotionEvent !== 'undefined' && 
                typeof DeviceMotionEvent.requestPermission === 'function') {
                // iOS 13+ requires permission
                DeviceMotionEvent.requestPermission()
                    .then(permissionState => {
                        if (permissionState === 'granted') {
                            // Permission granted, add event listener
                            window.addEventListener('devicemotion', handleDeviceMotion);
                        }
                    })
                    .catch(console.error);
            } else {
                // Other browsers don't require permission
                window.addEventListener('devicemotion', handleDeviceMotion);
            }
        }

        // Handle device orientation
        function handleDeviceOrientation(event) {
            // Store orientation data
            deviceOrientation = {
                alpha: event.alpha, // Z-axis rotation (compass direction)
                beta: event.beta,   // X-axis rotation (front-to-back tilt)
                gamma: event.gamma, // Y-axis rotation (side-to-side tilt)
                timestamp: Date.now()
            };
            
            // If we have a valid compass heading (alpha), use it
            if (event.alpha !== null && event.alpha !== undefined) {
                // Convert alpha to heading (0-360)
                let heading = 360 - event.alpha;
                
                // Adjust for device orientation
                if (window.orientation) {
                    switch (window.orientation) {
                        case 90:
                            heading = (heading + 90) % 360;
                            break;
                        case -90:
                            heading = (heading - 90 + 360) % 360;
                            break;
                        case 180:
                            heading = (heading + 180) % 360;
                            break;
                    }
                }
                
                // Store heading in buffer
                headingBuffer.push(heading);
                
                // Keep buffer size limited
                if (headingBuffer.length > 10) {
                    headingBuffer.shift();
                }
                
                // Calculate median heading
                const sortedHeadings = [...headingBuffer].sort((a, b) => a - b);
                const medianHeading = sortedHeadings[Math.floor(sortedHeadings.length / 2)];
                
                // Update last heading value
                lastHeadingValue = medianHeading;
            }
        }

        // Handle device motion
        function handleDeviceMotion(event) {
            // Store motion data
            deviceMotion = {
                x: event.accelerationIncludingGravity.x,
                y: event.accelerationIncludingGravity.y,
                z: event.accelerationIncludingGravity.z,
                timestamp: Date.now()
            };
            
            // Add to motion buffer
            deviceMotionBuffer.push({
                x: event.accelerationIncludingGravity.x,
                y: event.accelerationIncludingGravity.y,
                z: event.accelerationIncludingGravity.z,
                timestamp: Date.now()
            });
            
            // Keep buffer size limited
            if (deviceMotionBuffer.length > 10) {
                deviceMotionBuffer.shift();
            }
            
            // Check if device is stable
            checkDeviceStability();
        }

        // Check device stability
        function checkDeviceStability() {
            if (deviceMotionBuffer.length < 5) return;
            
            // Calculate motion variance
            let sumX = 0, sumY = 0, sumZ = 0;
            let sumX2 = 0, sumY2 = 0, sumZ2 = 0;
            
            for (const motion of deviceMotionBuffer) {
                sumX += motion.x;
                sumY += motion.y;
                sumZ += motion.z;
                
                sumX2 += motion.x * motion.x;
                sumY2 += motion.y * motion.y;
                sumZ2 += motion.z * motion.z;
            }
            
            const n = deviceMotionBuffer.length;
            const meanX = sumX / n;
            const meanY = sumY / n;
            const meanZ = sumZ / n;
            
            const varX = sumX2 / n - meanX * meanX;
            const varY = sumY2 / n - meanY * meanY;
            const varZ = sumZ2 / n - meanZ * meanZ;
            
            const totalVariance = Math.sqrt(varX * varX + varY * varY + varZ * varZ);
            
            // Update device stability
            isDeviceStable = totalVariance < 0.5;
            
            // If device is stable, increment stationary time
            if (isDeviceStable) {
                deviceStationaryTime += 100; // Assuming this is called every 100ms
            } else {
                deviceStationaryTime = 0;
            }
        }

        // Initialize event listeners
        function initEventListeners() {
            // Recenter button
            document.getElementById('recenterButton').addEventListener('click', recenterMap);
            
            // Return button
            document.getElementById('returnButton').addEventListener('click', () => {
                window.location.href = 'https://www.mnthen.com';
            });
            
            // Tips button
            document.getElementById('tipsButton').addEventListener('click', showNavigationTips);
            
            // Close tips button
            document.querySelector('.navigation-tips .close-button').addEventListener('click', hideNavigationTips);
            
            // Handle visibility changes
            document.addEventListener('visibilitychange', handleVisibilityChange);
            
            // Handle orientation changes
            window.addEventListener('orientationchange', handleOrientationChange);
        }

        // Handle visibility change
        function handleVisibilityChange() {
            if (document.hidden) {
                // App going to background
                lastHiddenTime = Date.now();
            } else {
                // App coming to foreground
                const hiddenDuration = Date.now() - lastHiddenTime;
                
                if (hiddenDuration > BACKGROUND_THRESHOLD) {
                    // App was in background for a while, refresh location
                    if ('geolocation' in navigator) {
                         navigator.geolocation.getCurrentPosition(
                            updateUserLocation,
                            handleGeolocationError,
                            {
                                enableHighAccuracy: true,
                                maximumAge: 0,
                                timeout: 10000
                            }
                        );
                    }
                    
                    // Refresh map
                    if (map) {
                        map.invalidateSize();
                    }
                }
            }
        }

        // Handle orientation change
        function handleOrientationChange() {
            // Refresh map size
            if (map) {
                setTimeout(() => {
                    map.invalidateSize();
                }, 200);
            }
        }

        // Start preloader progress
        function startPreloaderProgress() {
            const progressBar = document.getElementById('preloaderProgress');
            let progress = 0;
            
            const interval = setInterval(() => {
                progress += 1;
                
                if (progressBar) {
                    progressBar.style.width = `${Math.min(progress, 100)}%`;
                }
                
                if (progress >= 100) {
                    clearInterval(interval);
                }
            }, 50);
        }

        // Initialize the app
        function init() {
            // Set game locations
            gameLocations = [...locations];
            
            // Initialize map
            initMap();
            
            // Preload assets
            preloadAssets();
        }

        // Preload assets
        function preloadAssets() {
            // Preload images
            gameLocations.forEach(location => {
                if (location.image) {
                    const img = new Image();
                    img.src = location.image;
                    preloadedImages.set(location.id, img);
                }
                
                if (location.audio) {
                    const audio = new Audio();
                    audio.src = location.audio;
                    audio.preload = 'metadata';
                    preloadedAudio.set(location.id, audio);
                }
            });
        }

        // Start the app when DOM is loaded
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>         
