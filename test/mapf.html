<!DOCTYPE html>
<html lang="en">
<head> 
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Minnesota Then | Museum Without Walls</title>
    <link rel="shortcut icon" type="image/x-icon" href="https://www.mnthen.com/images/mnthenfav.ico">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css">
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css" />
    <link rel="stylesheet" href="https://www.mnthen.com/css/mainmap.css">
    <style>
        .user-marker-icon {
            width: 20px;
            height: 20px;
            background-color: #ff0000; /* Red user icon */
            border: 3px solid white;
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            position: relative;
            transition: transform 0.3s cubic-bezier(0.25, 0.1, 0.25, 1);
            will-change: transform;
        }
        
        .user-marker-icon::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 30px;
            height: 30px;
            background-color: rgba(255, 0, 0, 0.2); /* Red with opacity */
            border-radius: 50%;
            transform: translate(-50%, -50%);
            animation: pulse 2s infinite;
            will-change: transform, opacity;
        }
        
        @keyframes pulse {
            0% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
            100% {
                transform: translate(-50%, -50%) scale(2);
                opacity: 0;
            }
        }
        
        .stabilizing-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            z-index: 2000;
            text-align: center;
            max-width: 80%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .stabilizing-modal h3 {
            margin-bottom: 15px;
            color: #ff0000; /* Red */
        }
        
        .stabilizing-modal p {
            margin-bottom: 20px;
        }
        
        .stabilizing-modal .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255, 0, 0, 0.2); /* Red with opacity */
            border-top: 4px solid #ff0000; /* Red */
            border-radius: 50%;
            margin-bottom: 20px;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Preloader styles */
        #preloader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }

        #preloader .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(255, 0, 0, 0.2);
            border-top: 5px solid #ff0000;
            border-radius: 50%;
            margin-bottom: 20px;
            animation: spin 1s linear infinite;
        }

        #preloader p {
            font-size: 18px;
            color: #333;
            margin-top: 15px;
        }

        #preloader .progress-container {
            width: 80%;
            max-width: 300px;
            height: 10px;
            background-color: #f0f0f0;
            border-radius: 5px;
            margin-top: 15px;
            overflow: hidden;
        }

        #preloader .progress-bar {
            height: 100%;
            background-color: #ff0000;
            width: 0%;
            transition: width 0.3s ease;
        }

        /* Dark blue color for summary elements */
        .summary-heading {
            color: #0f2bab !important;
        }

        .summary-button {
            background-color: #0f2bab !important;
        }

        .summary-button:hover {
            background-color: #0a1f80 !important;
        }
        
        /* Optimize for hardware acceleration */
        #map, .user-marker-icon, .lochunt-container, .additional-info-container {
            transform: translateZ(0);
            backface-visibility: hidden;
            perspective: 1000px;
        }
        
        /* Stationary indicator - removed green glow and modified for consistent appearance */
        .user-marker-stationary .user-marker-icon {
            /* Keep the same red color and white border */
            border-color: white;
        }
        
        .user-marker-stationary .user-marker-icon::after {
            /* Keep the same red pulse effect */
            background-color: rgba(255, 0, 0, 0.2);
            animation: pulse 2s infinite;
        }
        
        /* Center the "Did you know?" modal */
        .additional-info-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            z-index: 2000;
            text-align: center;
            max-width: 80%;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            display: none;
        }
        
/* Green route button and dark blue summary button */
.button.route-button {
    background-color: #1b5e20 !important; /* Dark green color */
    color: white !important;
    border: none !important;
    padding: 8px 15px !important;
    border-radius: 0px !important;
    cursor: pointer !important;
    font-weight: 500 !important;
    transition: background-color 0.3s ease !important;
}

.button.summary-button {
    background-color: #0f2bab !important; /* Dark blue color */
    color: white !important;
    border: none !important;
    padding: 8px 15px !important;
    border-radius: 0px !important;
    cursor: pointer !important;
    font-weight: 500 !important;
    transition: background-color 0.3s ease !important;
}

.button.route-button:hover {
    background-color: #0d3c12 !important; /* Darker green on hover */
}

.button.summary-button:hover {
    background-color: #0a1f80 !important; /* Darker blue on hover */
}
        
        .custom-popup .popup-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
        }

        /* Error message styles */
        .error-message {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(255, 59, 48, 0.9);
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 2500;
            max-width: 90%;
            text-align: center;
            font-weight: 500;
            animation: fadeInOut 5s forwards;
            pointer-events: none;
        }

        @keyframes fadeInOut {
            0% { opacity: 0; transform: translate(-50%, -20px); }
            10% { opacity: 1; transform: translate(-50%, 0); }
            90% { opacity: 1; transform: translate(-50%, 0); }
            100% { opacity: 0; transform: translate(-50%, -20px); }
        }

        /* Location transition styles */
        .location-transition {
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .location-transition.visible {
            opacity: 1;
        }

/* Confidence indicator styles */
#accuracyIndicator {
    position: fixed;
    top: 10px;
    left: 10px;
    background-color: rgba(255, 255, 255, 0.8);
    padding: 5px 10px;
    border-radius: 15px;
    font-size: 12px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    z-index: 1000;
    display: flex;
    align-items: center;
    pointer-events: none;
}
.accuracy-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    margin-right: 5px;
}
.accuracy-high {
    background-color: #4CD964; /* Green */
}
.accuracy-medium {
    background-color: #FFCC00; /* Yellow */
}
.accuracy-low {
    background-color: #FF3B30; /* Red */
}
    </style>
</head>
<body>
    <!-- Preloader -->
    <div id="preloader">
        <div class="spinner"></div>
        <p>Loading Minnesota Then...</p>
        <div class="progress-container">
            <div class="progress-bar" id="preloaderProgress"></div>
        </div>
    </div>

    <div id="map"></div>
    <div id="distanceBox">Initializing...</div>
    <div id="networkStatus" title="Network Status"></div>
    <div id="accuracyIndicator"><span class="accuracy-dot accuracy-medium"></span><span id="accuracyText">GPS Signal</span></div>

    <div class="lochunt-container location-transition">
        <img id="locationImage" src="" alt="Location Image">
        <div class="lochunt-content">
            <div class="lochunt-info">
                <h2 id="locationTitle" class="mb-2 text-primary"></h2>
                <p id="locationCity" class="text-muted mb-1"></p>
                <p id="locationCreator" class="text-muted mb-3"></p>
            </div>
            <div class="audio-player">
                <div class="audio-progress">
                    <div class="progress">
                        <div id="progressBar" class="progress-bar" role="progressbar" style="width: 0%"></div>
                    </div>
                </div>
                <div class="audio-time">
                    <span id="currentTime">0:00</span>
                    <span id="duration">0:00</span>
                </div>
                <div class="audio-controls">
                    <button id="rewindBtn" class="audio-button"><i class="fas fa-backward"></i></button>
                    <button id="playPauseBtn" class="audio-button"><i class="fas fa-play"></i></button>
                    <button id="forwardBtn" class="audio-button"><i class="fas fa-forward"></i></button>
                </div>
                <audio id="locationAudio" src=""></audio>
            </div>
        </div>
    </div>
    
    <div class="additional-info-container location-transition">
       <h3 class="mb-3 text-primary text-center">Did You Know?</h3>
       <p id="additionalInfo" class="mb-3 fs-6"></p>
       <div class="d-flex justify-content-center">
           <button id="continueButton" class="btn btn-primary">Continue</button>
       </div>
    </div>
    
    <div class="map-buttons">
        <button id="recenterButton" class="map-button"><i class="fas fa-crosshairs"></i></button>
        <button id="returnButton" class="map-button"><i class="fas fa-sign-out-alt"></i></button>
        <button id="tipsButton" class="map-button"><i class="fas fa-question-circle"></i></button>
    </div>

    <div class="navigation-tips">
        <button class="close-button">&times;</button>
        <h3>Navigation Tips</h3>
        <ul>
            <li>Use the map to navigate to the marked locations.</li>
            <li>The distance box shows how far you are from the current location.</li>
            <li>Tap the recenter button to focus on your current position.</li>
            <li>When you're within 20 feet of a location, you'll be able to interact with it.</li>
            <li>Listen to the audio information for each location.</li>
            <li>After the audio, you'll see additional information about the location.</li>
        </ul>
    </div>

    <div id="summaryModal" class="modal" style="display: none;">
        <div class="modal-content">
            <p id="summaryContent"></p>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"></script>
    <script src="/locations_test.js?v=1.0.4"></script>
 
    <script>
// Global variables
let map, userMarker, markerClusterGroup
const currentLocationIndex = 0
const visitedLocations = []
let gameLocations = []
let inactivityTimer
let isLocationHuntVisible = false
let lastPosition = null
let positionBuffer = []
const MAX_BUFFER_SIZE = 20 // Increased buffer size for smoother tracking
const DISTANCE_THRESHOLD = 20 // 20 feet threshold for opening location page

//initial location notification constants
const GEOFENCE_RADIUS_FEET = 0 // 90 feet
const FEET_TO_METERS = 0.3048 // 1 foot = 0.3048 meters
const GEOFENCE_RADIUS_METERS = GEOFENCE_RADIUS_FEET * FEET_TO_METERS // ~27.432 meters

const PROXIMITY_THRESHOLD = 40 // 40 feet threshold for zoom changes
let velocity = { lat: 0, lng: 0 }
let isMapInteracting = false
let followUser = true
const locationCooldowns = {}
let userIsInteracting = false
const preloadedImages = new Map() // Map to store preloaded images
const preloadedAudio = new Map() // Map to store preloaded audio
let currentSpeed = 0 // Current speed in meters per second
let lastZoomLevel = 18 // Default zoom level
let stationaryPositionHistory = [] // Array to store stationary positions for averaging
let deviceOrientation = null // Store device orientation data
let deviceMotion = null // Store device motion data
let orientationPermissionGranted = false
let geolocationSensor = null // Store GeolocationSensor instance
let isNearLocation = false // Flag to track if user is near a location
let lastProximityCheck = 0 // Last time proximity was checked
let isReturningFromExhibit = false // Flag to track if returning from exhibit

// Enhanced constants for better stabilization
const MICRO_MOVEMENT_THRESHOLD = 0.5 // Meters - threshold for detecting micro-movements (increased for better stability)
const STATIONARY_ACCURACY_MULTIPLIER = 1.5 // Looser accuracy bounds to prevent false movement detection
const MAX_ACCEPTABLE_ACCURACY = 30 // meters - more lenient accuracy requirement
const STATIONARY_THRESHOLD = 3 // Number of consecutive stationary positions to consider user as stationary (reduced for faster stabilization)
const STATIONARY_TIME_THRESHOLD = 5000 // ms - time to consider user stationary (increased)
const STATIONARY_CHECK_INTERVAL = 2000 // ms - interval to check if still stationary (increased)
const VELOCITY_DECAY = 0.95 // Higher value for smoother velocity transitions
const MIN_DISTANCE_THRESHOLD = 1.5 // meters - minimum distance to consider movement (increased)
const EXTENDED_DISTANCE_THRESHOLD = 80 // meters - distance to consider a significant position change
const UPDATE_INTERVAL = 100 // ms - less frequent updates for more stability
const STATIONARY_POSITION_HISTORY_SIZE = 10 // Number of positions to keep for stationary averaging (reduced)
const STATIONARY_POSITION_WEIGHT_DECAY = 0.95 // Weight decay for older positions in stationary average (increased)
const SUDDEN_MOVEMENT_THRESHOLD = 1.0 // meters - threshold for detecting sudden movements (increased)
const POSITION_JUMP_THRESHOLD = 3.0 // meters - threshold for detecting position jumps (increased)
const ZOOM_CHANGE_COOLDOWN = 2000 // ms - cooldown between zoom changes

// Background handling constants
const BACKGROUND_THRESHOLD = 20000 // ms - time to consider app was in background
const INACTIVITY_TIMEOUT = 39000 // ms - time to consider user inactive (changed to 39 seconds)

// Kalman filter parameters - optimized for better stationary stability
const KALMAN_PROCESS_NOISE = 0.001 // Lower value for smoother tracking
const KALMAN_MEASUREMENT_NOISE_BASE = 2.0 // Higher base measurement noise to reduce jitter
const KALMAN_STATIONARY_NOISE = 0.0005 // Lower noise when stationary (reduced to minimize jitter)

// Animation parameters
const ANIMATION_DURATION = 300 // ms - increased duration of position animation for smoother transitions
const HEADING_SMOOTHING = 0.95 // Increased heading smoothing factor

// Zoom level parameters
const MAX_ZOOM_LEVEL = 18 // Maximum zoom level (stationary)
const MIN_ZOOM_LEVEL = 14 // Minimum zoom level (high speed)
const WALKING_ZOOM_LEVEL = 18 // Zoom level for walking speed
const WALKING_SPEED_THRESHOLD = 1.5 // m/s - threshold for walking speed
const RUNNING_SPEED_THRESHOLD = 4.0 // m/s - threshold for running speed
const DRIVING_SPEED_THRESHOLD = 10.0 // m/s - threshold for driving speed
const ZOOM_TRANSITION_DURATION = 0.8 // seconds - increased duration of zoom transition

// Motion detection parameters
const MOTION_THRESHOLD = 1.0 // Increased threshold for detecting significant motion
const MOTION_SAMPLE_SIZE = 10 // Increased number of motion samples to keep
const MOTION_CHECK_INTERVAL = 300 // ms - increased interval to check motion

// Edge recenter parameters - optimized for better edge recentering
const EDGE_THRESHOLD_PERCENTAGE = 0.15 // Percentage of viewport to trigger recenter (15%)
const CRITICAL_EDGE_THRESHOLD = 0.15 // Critical threshold for emergency recenter (15%)
const RECENTER_COOLDOWN = 500 // ms - reduced minimum time between recenters for more responsive recentering

// Error handling constants
const MAX_LOCATION_RETRIES = 5 // Maximum number of retries for location
const LOCATION_RETRY_DELAY = 2000 // Delay between location retries in ms
const NETWORK_CHECK_INTERVAL = 5000 // Interval to check network status in ms
const GPS_CONFIDENCE_THRESHOLD_HIGH = 10 // meters - high confidence threshold
const GPS_CONFIDENCE_THRESHOLD_MEDIUM = 25 // meters - medium confidence threshold
const GPS_SIGNAL_CHECK_INTERVAL = 3000 // Interval to check GPS signal quality in ms
const PERMISSION_DENIED_ERROR = 1 // Error code for permission denied
const POSITION_UNAVAILABLE_ERROR = 2 // Error code for position unavailable
const TIMEOUT_ERROR = 3 // Error code for timeout
const UNKNOWN_ERROR = 4 // Error code for unknown error

// State variables
let lastUpdateTime = null
let lastVelocity = { lat: 0, lng: 0 }
let isStationary = false
let stationaryStartTime = null
let stationaryCheckTimeout = null
let lastUpdateTimestamp = null
let lastHiddenTime = 0
let lastKnownPosition = null
const isTransitioning = false
let lastVisitedLocationId = null
let stationaryCount = 0
let lastSmoothedPosition = null
let lastRecenterTime = Date.now()
let retryCount = 0
const stationaryBuffer = []
const stationaryPosition = null
let isStabilizing = true // Flag to track initial stabilization
let lastStationaryPosition = null // Last stable position when stationary
const motionSamples = [] // Array to store motion samples
const lastMotionTimestamp = 0 // Last time motion was detected
let deviceStationaryTime = 0 // Time device has been stationary based on motion sensors
let animationFrameId = null // Store requestAnimationFrame ID
let renderTimestamp = null // Last render timestamp
const positionUpdateQueue = [] // Queue for position updates to be processed
let lastHeadingValue = null // Last heading value
const headingBuffer = [] // Buffer for heading values
let isFirstPositionUpdate = true // Flag for first position update
let lastRenderPosition = null // Last rendered position
let positionInterpolator = null // Position interpolator for smooth transitions
let mapViewportWidth = 0 // Store map viewport width
let mapViewportHeight = 0 // Store map viewport height
let lastMapCenter = null // Last map center position
let lastMapZoom = null // Last map zoom level
let edgeRecenterInProgress = false // Flag to track edge recentering
const domUpdateScheduled = false // Flag to track scheduled DOM updates
const pendingDomUpdates = new Map() // Map to store pending DOM updates
let usingGeolocationSensorAPI = false // Flag to track which geolocation API is being used
const lockStationaryPosition = false // Flag to lock stationary position and prevent jitter
let positionHistory = [] // Array to store recent position history for jump detection
const lastPositionTimestamp = 0 // Last time a position was processed
let suddenMovementCount = 0 // Counter for consecutive sudden movements
let isJumpDetected = false // Flag to track if a position jump is detected
let stationaryPositionLocked = false // Flag to indicate if stationary position is locked
let stationaryPositionLockTime = 0 // Time when stationary position was locked
let lastValidPosition = null // Last valid position before a jump
let stationaryLockTimeout = null // Timeout for locking stationary position
const positionStabilityCounter = 0 // Counter for position stability
let lastZoomChangeTime = 0 // Last time zoom was changed due to proximity
let lastProximityDistance = Number.POSITIVE_INFINITY // Last distance to nearest location
let isOnline = navigator.onLine // Track online status
const lastGpsSignalCheck = 0 // Last time GPS signal was checked
let gpsConfidenceScore = 0.5 // GPS confidence score (0-1)
let permissionDenied = false // Flag to track if location permission was denied
let locationErrorCount = 0 // Counter for location errors
let networkErrorCount = 0 // Counter for network errors
let lastNetworkErrorTime = 0 // Last time a network error occurred
let isLocationAvailable = true // Flag to track if location is available
const confidenceScoreHistory = [] // Array to store confidence scores for averaging
const stationaryConfidenceScore = 0 // Confidence score for stationary state (0-1)
const movingConfidenceScore = 0 // Confidence score for moving state (0-1)
const stationaryTransitionState = 0 // Transition state between stationary and moving (0-1)
let lastAccuracyUpdate = 0 // Last time accuracy indicator was updated
let locationWatchId = null // ID for geolocation watch
let permissionRequestInProgress = false // Flag to track if permission request is in progress
let lastPermissionRequest = 0 // Last time permission was requested

// Edge recenter variables
let lastEdgeCheck = 0
const edgeCheckInterval = 500

// Map update throttling variables
let lastMapUpdate = 0
const mapUpdateThrottleInterval = 100

// NEW: User zoom interaction tracking
let isUserZooming = false
let userZoomCooldownTimer = null
let lastUserZoomTime = 0
const USER_ZOOM_COOLDOWN = 3000 // 3 seconds cooldown after manual zoom

// NEW: Dynamic edge threshold variables
let dynamicEdgeThreshold = EDGE_THRESHOLD_PERCENTAGE
let lastOrientationChange = 0
let lastViewportDimensions = { width: 0, height: 0 }

// NEW: Animation frame timing variables
let lastFrameTime = 0
let frameTimeHistory = []
const MAX_FRAME_HISTORY = 10
const frameTimeThreshold = 16.67 // Target 60fps (16.67ms per frame)
let isLowPerformanceMode = false
let performanceCheckCounter = 0
const lastPerformanceCheck = 0
const PERFORMANCE_CHECK_INTERVAL = 5000 // Check performance every 5 seconds

// NEW: Task prioritization
const taskQueue = new Map()
const isProcessingTasks = false
let lastTaskProcessTime = 0
const TASK_PROCESS_INTERVAL = 100 // Process tasks every 100ms
const TASK_PRIORITIES = {
  CRITICAL: 10, // Position updates, edge recentering
  HIGH: 7, // Zoom adjustments
  MEDIUM: 5, // Proximity checks
  LOW: 3, // UI updates
  BACKGROUND: 1, // Analytics, non-essential calculations
}

// NEW: Speed-adaptive parameters
const SPEED_TIERS = {
  STATIONARY: { min: 0, max: 0.5, name: "Stationary" },
  WALKING: { min: 0.5, max: 2, name: "Walking" },
  RUNNING: { min: 2, max: 11, name: "Running" },
  DRIVING: { min: 11, max: Number.POSITIVE_INFINITY, name: "Driving" },
}

// Dummy locations variable for testing
const myLocations = []

// Dummy onMapRecentered variable for testing
const onMapRecentered = () => {}

// Dummy L variable for testing
const L = window.L

// Dummy GeolocationSensor variable for testing
const GeolocationSensor = window.GeolocationSensor

// Enhanced Kalman Filter implementation
class KalmanFilter {
  constructor() {
    // State variables
    this.x = 0 // Longitude estimate
    this.y = 0 // Latitude estimate
    this.vx = 0 // Longitude velocity
    this.vy = 0 // Latitude velocity

    // Error covariance matrix
    this.P = [
      [100, 0, 0, 0], // Initial high uncertainty
      [0, 100, 0, 0],
      [0, 0, 10, 0],
      [0, 0, 0, 10],
    ]

    // Process noise
    this.Q = KALMAN_PROCESS_NOISE

    // Measurement noise (will be adjusted based on GPS accuracy)
    this.R = KALMAN_MEASUREMENT_NOISE_BASE

    // Time delta
    this.dt = 1.0

    // Initialized flag
    this.initialized = false

    // Heading and accuracy tracking
    this.lastHeading = null
    this.headingConfidence = 0

    // Stationary mode flag
    this.stationaryMode = false

    // Last timestamp
    this.lastTimestamp = null

    // Adaptive noise parameters
    this.adaptiveNoiseMin = 0.0005 // Reduced for better stability
    this.adaptiveNoiseMax = 0.005 // Reduced for better stability
    this.adaptiveNoiseFactor = 1.0

    // Position history for jitter detection
    this.positionHistory = []
    this.maxPositionHistory = 5
    this.jitterThreshold = 0.5 // meters - increased to be more tolerant
    this.jitterCount = 0

    // Stationary lock
    this.stationaryLocked = false
    this.stationaryPosition = null

    // New: Enhanced jitter detection with hysteresis
    this.jitterHysteresis = 0
    this.maxJitterHysteresis = 5
    this.jitterConfidence = 0
  }

  // Initialize the filter with first position
  reset(position) {
    if (!position || typeof position.lat !== "number" || typeof position.lng !== "number") {
      console.error("Invalid position for Kalman filter reset")
      return
    }

    this.x = position.lng
    this.y = position.lat
    this.vx = 0
    this.vy = 0

    // Reset covariance matrix with high initial uncertainty
    this.P = [
      [100, 0, 0, 0],
      [0, 100, 0, 0],
      [0, 0, 10, 0],
      [0, 0, 0, 10],
    ]

    this.initialized = true
    this.lastHeading = position.heading || null
    this.headingConfidence = 0
    this.stationaryMode = false
    this.lastTimestamp = position.timestamp || Date.now()
    this.adaptiveNoiseFactor = 1.0
    this.positionHistory = []
    this.jitterCount = 0
    this.stationaryLocked = false
    this.stationaryPosition = null
    this.jitterHysteresis = 0
    this.jitterConfidence = 0
  }

  // Set stationary mode
  setStationaryMode(isStationary) {
    this.stationaryMode = isStationary

    // When entering stationary mode, reduce velocity to zero
    if (isStationary) {
      this.vx = 0
      this.vy = 0

      // Reduce process noise for stationary mode
      this.Q = KALMAN_STATIONARY_NOISE
      this.adaptiveNoiseFactor = 0.03 // Further reduced for even less jitter in stationary mode
    } else {
      // Reset to normal process noise when moving
      this.Q = KALMAN_PROCESS_NOISE
      this.adaptiveNoiseFactor = 1.0 // Normal noise when moving
      this.stationaryLocked = false
      this.stationaryPosition = null
      this.jitterHysteresis = 0
    }
  }

  // Lock stationary position
  lockStationaryPosition(position) {
    if (!this.stationaryMode) return

    this.stationaryLocked = true
    this.stationaryPosition = position
    console.log("Kalman filter: Stationary position locked")
  }

  // Enhanced jitter detection with hysteresis and confidence scoring
  detectJitter(newPosition) {
    if (this.positionHistory.length === 0) {
      this.positionHistory.push(newPosition)
      return false
    }

    const lastPos = this.positionHistory[this.positionHistory.length - 1]
    const distance = calculateDistance(lastPos, newPosition)

    // Add to history
    this.positionHistory.push(newPosition)
    if (this.positionHistory.length > this.maxPositionHistory) {
      this.positionHistory.shift()
    }

    // Check for rapid back-and-forth movement (jitter)
    if (this.positionHistory.length >= 3 && this.stationaryMode) {
      const pos1 = this.positionHistory[this.positionHistory.length - 3]
      const pos2 = this.positionHistory[this.positionHistory.length - 2]
      const pos3 = this.positionHistory[this.positionHistory.length - 1]

      const dist1 = calculateDistance(pos1, pos2)
      const dist2 = calculateDistance(pos2, pos3)

      // If moving back and forth in small distances
      if (dist1 < this.jitterThreshold && dist2 < this.jitterThreshold) {
        // Check for direction change (sign change in lat/lng differences)
        const latDiff1 = pos2.lat - pos1.lat
        const latDiff2 = pos3.lat - pos2.lat
        const lngDiff1 = pos2.lng - pos1.lng
        const lngDiff2 = pos3.lng - pos2.lng

        // If direction changed in either lat or lng
        if (
          (Math.sign(latDiff1) !== Math.sign(latDiff2) &&
            Math.abs(latDiff1) > 0.00001 &&
            Math.abs(latDiff2) > 0.00001) ||
          (Math.sign(lngDiff1) !== Math.sign(lngDiff2) && Math.abs(lngDiff1) > 0.00001 && Math.abs(lngDiff2) > 0.00001)
        ) {
          // Increase jitter hysteresis
          this.jitterHysteresis = Math.min(this.maxJitterHysteresis, this.jitterHysteresis + 1)

          // Increase jitter confidence
          this.jitterConfidence = Math.min(1.0, this.jitterConfidence + 0.2)

          return this.jitterHysteresis > 2 && this.jitterConfidence > 0.5
        }
      }
    }

    // Gradually decrease jitter hysteresis and confidence if no jitter detected
    if (distance > this.jitterThreshold * 1.5) {
      this.jitterHysteresis = Math.max(0, this.jitterHysteresis - 0.5)
      this.jitterConfidence = Math.max(0, this.jitterConfidence - 0.1)
    }

    return false
  }

  // Adjust process noise based on accuracy, motion, and jitter confidence
  adjustProcessNoise(accuracy, motionDetected) {
    // Base noise level depends on GPS accuracy
    let noiseLevel =
      this.adaptiveNoiseMin + (this.adaptiveNoiseMax - this.adaptiveNoiseMin) * Math.min(1.0, accuracy / 40.0)

    // Reduce noise when stationary
    if (this.stationaryMode) {
      noiseLevel *= 0.03 // Further reduced for even less jitter
    }

    // Increase noise when motion is detected
    if (motionDetected && !this.stationaryMode) {
      noiseLevel *= 1.5
    }

    // Reduce noise when jitter is detected (counter-intuitive but effective)
    if (this.jitterConfidence > 0.3) {
      noiseLevel *= 0.01 // Drastically reduce noise to stabilize position
    }

    // Apply adaptive factor
    noiseLevel *= this.adaptiveNoiseFactor

    // Set process noise
    this.Q = noiseLevel
  }

  // Update the filter with new measurement
  update(position, motionDetected = false) {
    if (!this.initialized) {
      this.reset(position)
      return position
    }

    if (!position || typeof position.lat !== "number" || typeof position.lng !== "number") {
      console.warn("Invalid position input to Kalman filter")
      return {
        lat: this.y,
        lng: this.x,
        accuracy: position?.accuracy || 20,
        heading: this.lastHeading,
        timestamp: position?.timestamp || Date.now(),
      }
    }

    // If we're in stationary mode and have a locked position, return the locked position
    if (this.stationaryMode && this.stationaryLocked && this.stationaryPosition) {
      return {
        lat: this.stationaryPosition.lat,
        lng: this.stationaryPosition.lng,
        accuracy: position.accuracy,
        heading: position.heading,
        timestamp: position.timestamp,
        speedMPS: 0,
      }
    }

    // Calculate time delta
    const timestamp = position.timestamp || Date.now()
    if (this.lastTimestamp) {
      this.dt = Math.min(Math.max((timestamp - this.lastTimestamp) / 1000, 0.01), 2.0)
    }
    this.lastTimestamp = timestamp

    // Check for jitter
    const isJittering = this.detectJitter(position)

    // Adjust measurement noise based on GPS accuracy and jitter
    const accuracy = position.accuracy || 20
    this.R = Math.max(KALMAN_MEASUREMENT_NOISE_BASE, accuracy / 5)

    // If in stationary mode, increase measurement noise to reduce jitter
    if (this.stationaryMode) {
      this.R *= 15.0 // Increased to further reduce jitter
    }

    // If jittering is detected, increase measurement noise significantly
    if (isJittering) {
      this.R *= 30.0 // Increased to further reduce jitter
    }

    // Adjust process noise based on accuracy and motion
    this.adjustProcessNoise(accuracy, motionDetected)

    // State transition matrix
    const F = [
      [1, 0, this.dt, 0],
      [0, 1, 0, this.dt],
      [0, 0, 1, 0],
      [0, 0, 0, 1],
    ]

    // Process noise matrix
    const G = [
      [0.5 * this.dt * this.dt, 0],
      [0, 0.5 * this.dt * this.dt, 0],
      [this.dt, 0],
      [0, this.dt],
    ]

    // Measurement matrix
    const H = [
      [1, 0, 0, 0],
      [0, 1, 0, 0],
    ]

    // Predict step
    // x = F * x
    const predictedX = this.x + this.dt * this.vx
    const predictedY = this.y + this.dt * this.vy
    const predictedVx = this.stationaryMode ? 0 : this.vx
    const predictedVy = this.stationaryMode ? 0 : this.vy

    // P = F * P * F' + Q
    const Q = [
      [(this.Q * this.dt * this.dt * this.dt * this.dt) / 4, 0, (this.Q * this.dt * this.dt * this.dt) / 2, 0],
      [0, (this.Q * this.dt * this.dt * this.dt * this.dt) / 4, 0, (this.Q * this.dt * this.dt * this.dt) / 2],
      [(this.Q * this.dt * this.dt * this.dt) / 2, 0, this.Q * this.dt * this.dt, 0],
      [0, (this.Q * this.dt * this.dt * this.dt) / 2, 0, this.Q * this.dt * this.dt],
    ]

    // Matrix multiplication F * P
    const FP = [
      [
        this.P[0][0] + this.dt * this.P[2][0],
        this.P[0][1] + this.dt * this.P[2][1],
        this.P[0][2] + this.dt * this.P[2][2],
        this.P[0][3] + this.dt * this.P[2][3],
      ],
      [
        this.P[1][0] + this.dt * this.P[3][0],
        this.P[1][1] + this.dt * this.P[3][1],
        this.P[1][2] + this.dt * this.P[3][2],
        this.P[1][3] + this.dt * this.P[3][3],
      ],
      [this.P[2][0], this.P[2][1], this.P[2][2], this.P[2][3]],
      [this.P[3][0], this.P[3][1], this.P[3][2], this.P[3][3]],
    ]

    // Matrix multiplication FP * F'
    const predictedP = [
      [
        FP[0][0] + this.dt * FP[0][2] + Q[0][0],
        FP[0][1] + this.dt * FP[0][3] + Q[0][1],
        FP[0][2] + Q[0][2],
        FP[0][3] + Q[0][3],
      ],
      [
        FP[1][0] + this.dt * FP[1][2] + Q[1][0],
        FP[1][1] + this.dt * FP[1][3] + Q[1][1],
        FP[1][2] + Q[1][2],
        FP[1][3] + Q[1][3],
      ],
      [FP[2][0] + Q[2][0], FP[2][1] + Q[2][1], FP[2][2] + Q[2][2], FP[2][3] + Q[2][3]],
      [FP[3][0] + Q[3][0], FP[3][1] + Q[3][1], FP[3][2] + Q[3][2], FP[3][3] + Q[3][3]],
    ]

    // Update step
    // y = z - H * x
    const measurementResidualX = position.lng - predictedX
    const measurementResidualY = position.lat - predictedY

    // S = H * P * H' + R
    const S = [
      [predictedP[0][0] + this.R, predictedP[0][1]],
      [predictedP[1][0], predictedP[1][1] + this.R],
    ]

    // Calculate determinant of S
    const detS = S[0][0] * S[1][1] - S[0][1] * S[1][0]

    // Calculate inverse of S
    const invS = [
      [S[1][1] / detS, -S[0][1] / detS],
      [-S[1][0] / detS, S[0][0] / detS],
    ]

    // K = P * H' * inv(S)
    const K = [
      [
        predictedP[0][0] * invS[0][0] + predictedP[0][1] * invS[1][0],
        predictedP[0][0] * invS[0][1] + predictedP[0][1] * invS[1][1],
      ],
      [
        predictedP[1][0] * invS[0][0] + predictedP[1][1] * invS[1][0],
        predictedP[1][0] * invS[0][1] + predictedP[1][1] * invS[1][1],
      ],
      [
        predictedP[2][0] * invS[0][0] + predictedP[2][1] * invS[1][0],
        predictedP[2][0] * invS[0][1] + predictedP[2][1] * invS[1][1],
      ],
      [
        predictedP[3][0] * invS[0][0] + predictedP[3][1] * invS[1][0],
        predictedP[3][0] * invS[0][1] + predictedP[3][1] * invS[1][1],
      ],
    ]

    // x = x + K * y
    this.x = predictedX + K[0][0] * measurementResidualX + K[0][1] * measurementResidualY
    this.y = predictedY + K[1][0] * measurementResidualX + K[1][1] * measurementResidualY

    // In stationary mode, keep velocity at zero
    if (this.stationaryMode) {
      this.vx = 0
      this.vy = 0
    } else {
      this.vx = predictedVx + K[2][0] * measurementResidualX + K[2][1] * measurementResidualY
      this.vy = predictedVy + K[3][0] * measurementResidualX + K[3][1] * measurementResidualY
    }

    // P = (I - K * H) * P
    this.P = [
      [
        predictedP[0][0] - (K[0][0] * predictedP[0][0] + K[0][1] * predictedP[1][0]),
        predictedP[0][1] - (K[0][0] * predictedP[0][1] + K[0][1] * predictedP[1][1]),
        predictedP[0][2] - (K[0][0] * predictedP[0][2] + K[0][1] * predictedP[1][2]),
        predictedP[0][3] - (K[0][0] * predictedP[0][3] + K[0][1] * predictedP[1][3]),
      ],

      [
        predictedP[1][0] - (K[1][0] * predictedP[0][0] + K[1][1] * predictedP[1][0]),
        predictedP[1][1] - (K[1][0] * predictedP[0][1] + K[1][1] * predictedP[1][1]),
        predictedP[1][2] - (K[1][0] * predictedP[0][2] + K[1][1] * predictedP[1][2]),
        predictedP[1][3] - (K[1][0] * predictedP[0][3] + K[1][1] * predictedP[1][3]),
      ],

      [
        predictedP[2][0] - (K[2][0] * predictedP[0][0] + K[2][1] * predictedP[1][0]),
        predictedP[2][1] - (K[2][0] * predictedP[0][1] + K[2][1] * predictedP[1][1]),
        predictedP[2][2] - (K[2][0] * predictedP[0][2] + K[2][1] * predictedP[1][2]),
        predictedP[2][3] - (K[2][0] * predictedP[0][3] + K[2][1] * predictedP[1][3]),
      ],

      [
        predictedP[3][0] - (K[3][0] * predictedP[0][0] + K[3][1] * predictedP[1][0]),
        predictedP[3][1] - (K[3][0] * predictedP[0][1] + K[3][1] * predictedP[1][1]),
        predictedP[3][2] - (K[3][0] * predictedP[0][2] + K[3][1] * predictedP[1][2]),
        predictedP[3][3] - (K[3][0] * predictedP[0][3] + K[3][1] * predictedP[1][3]),
      ],
    ]

    // Process heading data with enhanced smoothing
    let smoothedHeading = position.heading
    if (position.heading !== null && position.heading !== undefined) {
      if (this.lastHeading !== null) {
        // Normalize headings to 0-360
        const normalizedCurrent = ((position.heading % 360) + 360) % 360
        const normalizedLast = ((this.lastHeading % 360) + 360) % 360

        // Calculate the smallest angle between the two headings
        let diff = normalizedCurrent - normalizedLast
        if (diff > 180) diff -= 360
        if (diff < -180) diff += 360

        // Apply stronger smoothing when stationary, more responsive when moving
        // This is a key improvement for icon movement
        const headingWeight = this.stationaryMode
          ? 0.005
          : // Extremely stable when stationary
            motionDetected
            ? Math.abs(diff) > 30
              ? 0.4
              : 0.2
            : // More responsive to large changes when in motion
              0.1 // Default smoothing

        smoothedHeading = normalizedLast + diff * headingWeight

        // Normalize back to 0-360
        smoothedHeading = ((smoothedHeading % 360) + 360) % 360

        // Increase confidence with consistent headings
        if (Math.abs(diff) < 12) {
          this.headingConfidence = Math.min(1.0, this.headingConfidence + 0.1)
        } else {
          this.headingConfidence = Math.max(0.1, this.headingConfidence - 0.2)
        }
      }
      this.lastHeading = smoothedHeading
    }

    // Calculate speed from velocity components
    const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy)

    // Create filtered position
    const filteredPosition = {
      lat: this.y,
      lng: this.x,
      accuracy: position.accuracy,
      heading: smoothedHeading,
      timestamp: position.timestamp,
      speedMPS: this.stationaryMode ? 0 : speed * 111000, // Convert from degrees/second to meters/second (approximate)
    }

    // If we're in stationary mode and don't have a locked position yet,
    // check if we should lock the position
    if (this.stationaryMode && !this.stationaryLocked) {
      // If we've been stationary for a while, lock the position
      if (Date.now() - stationaryStartTime > 3000) {
        this.lockStationaryPosition(filteredPosition)
      }
    }

    return filteredPosition
  }
}

// Position interpolator for smooth transitions
class PositionInterpolator {
  constructor() {
    this.startPosition = null
    this.targetPosition = null
    this.startTime = null
    this.duration = 0
    this.isActive = false
    this.lastInterpolatedPosition = null // Track last interpolated position
  }

  start(startPos, targetPos, duration) {
    if (!startPos || !targetPos) return

    // If already interpolating, use current interpolated position as start
    if (this.isActive && this.lastInterpolatedPosition) {
      startPos = this.lastInterpolatedPosition
    }

    this.startPosition = { ...startPos }
    this.targetPosition = { ...targetPos }
    this.startTime = performance.now()
    this.duration = duration
    this.isActive = true
  }

  update() {
    if (!this.isActive) return null

    const now = performance.now()
    const elapsed = now - this.startTime

    if (elapsed >= this.duration) {
      this.isActive = false
      this.lastInterpolatedPosition = this.targetPosition
      return this.targetPosition
    }

    // Calculate progress with improved easing
    const t = elapsed / this.duration
    const easedT = this.easeOutCubic(t)

    // Interpolate position
    const interpolatedPosition = {
      lat: this.startPosition.lat + (this.targetPosition.lat - this.startPosition.lat) * easedT,
      lng: this.startPosition.lng + (this.targetPosition.lng - this.startPosition.lng) * easedT,
      accuracy: this.targetPosition.accuracy,
      heading: this.interpolateHeading(this.startPosition.heading, this.targetPosition.heading, easedT),
      timestamp: now,
      speedMPS: this.targetPosition.speedMPS,
    }

    this.lastInterpolatedPosition = interpolatedPosition
    return interpolatedPosition
  }

  // Improved heading interpolation that handles the 0/360 boundary
  interpolateHeading(start, end, t) {
    if (start === undefined || end === undefined || start === null || end === null) {
      return end
    }

    // Normalize headings to 0-360
    start = ((start % 360) + 360) % 360
    end = ((end % 360) + 360) % 360

    // Find the shortest path
    let diff = end - start
    if (diff > 180) diff -= 360
    if (diff < -180) diff += 360

    // Calculate interpolated heading
    const result = start + diff * t

    // Normalize result
    return ((result % 360) + 360) % 360
  }

  // Improved cubic easing function for smoother motion
  easeOutCubic(t) {
    return 1 - Math.pow(1 - t, 3)
  }

  isInterpolating() {
    return this.isActive
  }

  cancel() {
    this.isActive = false
  }
}

// Create Kalman filter instance
const kalmanFilter = new KalmanFilter()

// Create position interpolator
positionInterpolator = new PositionInterpolator()

// DOM Update Manager - Optimized for batching DOM operations
const domUpdateManager = {
  updates: new Map(),
  scheduled: false,
  maxUpdates: 100, // Limit the number of updates to prevent memory bloat
  frameId: null,

  // Schedule a DOM update with optional priority
  schedule(id, updateFn, priority = 0) {
    // Enforce size limit
    if (this.updates.size >= this.maxUpdates) {
      // Instead of warning, just replace lowest priority updates
      if (priority === 0) return

      // Find lowest priority update to replace
      let lowestPriorityId = null
      let lowestPriority = priority

      for (const [updateId, update] of this.updates.entries()) {
        if (update.priority < lowestPriority) {
          lowestPriority = update.priority
          lowestPriorityId = updateId
        }
      }

      if (lowestPriorityId) {
        this.updates.delete(lowestPriorityId)
      } else {
        return // Can't add if all existing updates have higher priority
      }
    }

    // Store the update with its priority
    this.updates.set(id, { updateFn, priority })

    // Schedule a flush if not already scheduled
    if (!this.scheduled) {
      this.scheduled = true
      this.frameId = requestAnimationFrame(() => this.flush())
    }
  },

  // Flush all scheduled DOM updates
  flush() {
    try {
      // Start performance measurement
      const startTime = performance.now()

      // Convert updates to an array and sort by priority (higher priority first)
      const sortedUpdates = Array.from(this.updates.values()).sort((a, b) => b.priority - a.priority)

      // Execute updates
      sortedUpdates.forEach(({ updateFn }) => {
        try {
          updateFn()
        } catch (error) {
          console.error("Error executing DOM update:", error)
        }
      })

      // Measure performance
      const endTime = performance.now()
      const updateTime = endTime - startTime

      // If updates took too long, enter low performance mode
      if (updateTime > 16 && !isLowPerformanceMode) {
        console.log(`DOM updates took ${updateTime.toFixed(2)}ms, entering low performance mode`)
        isLowPerformanceMode = true
      } else if (updateTime < 8 && isLowPerformanceMode) {
        console.log(`DOM updates took ${updateTime.toFixed(2)}ms, exiting low performance mode`)
        isLowPerformanceMode = false
      }
    } catch (error) {
      console.error("Error during DOM update flush:", error)
    } finally {
      // Clear updates and reset state
      this.updates.clear()
      this.scheduled = false
      this.frameId = null
    }
  },

  // Cancel a scheduled update by ID
  cancel(id) {
    this.updates.delete(id)
  },

  // Clear all pending updates
  clear() {
    this.updates.clear()
    this.scheduled = false
    if (this.frameId) {
      cancelAnimationFrame(this.frameId)
      this.frameId = null
    }
  },
}

// NEW: Task Queue Manager for prioritizing operations
const taskManager = {
  tasks: new Map(),
  isProcessing: false,
  processingTimer: null,

  // Add a task to the queue with priority
  addTask(id, taskFn, priority = TASK_PRIORITIES.MEDIUM, debounceTime = 0) {
    const now = performance.now()
    const existingTask = this.tasks.get(id)

    // If task exists and is debounced, update its function but keep the scheduled time
    if (existingTask && debounceTime > 0) {
      if (now - existingTask.lastRun < debounceTime) {
        this.tasks.set(id, {
          ...existingTask,
          fn: taskFn,
          priority,
        })
        return
      }
    }

    // Add or update task
    this.tasks.set(id, {
      fn: taskFn,
      priority,
      lastRun: existingTask?.lastRun || 0,
      debounceTime,
    })

    // Start processing if not already running
    if (!this.isProcessing) {
      this.startProcessing()
    }
  },

  // Start processing tasks
  startProcessing() {
    if (this.isProcessing) return

    this.isProcessing = true
    this.processTasks()
  },

  // Process tasks based on priority
  processTasks() {
    const now = performance.now()

    // Skip if no tasks or if we're throttling in low performance mode
    if (this.tasks.size === 0 || (isLowPerformanceMode && now - lastTaskProcessTime < TASK_PROCESS_INTERVAL * 2)) {
      this.isProcessing = false
      return
    }

    // Update last process time
    lastTaskProcessTime = now

    // Convert tasks to array and sort by priority
    const sortedTasks = Array.from(this.tasks.entries())
      .map(([id, task]) => ({ id, ...task }))
      .sort((a, b) => b.priority - a.priority)

    // Process highest priority task first
    const highestPriorityTask = sortedTasks[0]

    // Check if task is debounced
    if (now - highestPriorityTask.lastRun >= highestPriorityTask.debounceTime) {
      try {
        highestPriorityTask.fn()

        // Update last run time
        this.tasks.set(highestPriorityTask.id, {
          ...highestPriorityTask,
          lastRun: now,
        })

        // Remove one-time tasks
        if (highestPriorityTask.priority === TASK_PRIORITIES.CRITICAL) {
          this.tasks.delete(highestPriorityTask.id)
        }
      } catch (error) {
        console.error("Error executing task:", error)
        this.tasks.delete(highestPriorityTask.id)
      }
    }

    // Schedule next processing
    this.processingTimer = setTimeout(
      () => {
        this.processTasks()
      },
      isLowPerformanceMode ? TASK_PROCESS_INTERVAL * 2 : TASK_PROCESS_INTERVAL,
    )
  },

  // Remove a task from the queue
  removeTask(id) {
    this.tasks.delete(id)
  },

  // Clear all tasks
  clearTasks() {
    this.tasks.clear()
    this.isProcessing = false
    if (this.processingTimer) {
      clearTimeout(this.processingTimer)
      this.processingTimer = null
    }
  },
}

// NEW: Get speed-adaptive parameters based on current speed
function getSpeedAdaptiveParameters(speedMPS) {
  // Determine speed tier
  let tier
  if (speedMPS <= SPEED_TIERS.STATIONARY.max) {
    tier = SPEED_TIERS.STATIONARY
  } else if (speedMPS <= SPEED_TIERS.WALKING.max) {
    tier = SPEED_TIERS.WALKING
  } else if (speedMPS <= SPEED_TIERS.RUNNING.max) {
    tier = SPEED_TIERS.RUNNING
  } else {
    tier = SPEED_TIERS.DRIVING
  }

  // Calculate dynamic edge threshold based on speed
  // Higher speeds need larger thresholds to prevent constant recentering
  const edgeThreshold = Math.min(0.25, 0.15 + speedMPS * 0.005)

  // Calculate flyTo duration based on speed
  // Faster transitions at higher speeds
  const flyToDuration = speedMPS > 5 ? 0.3 : 1.0

  // Calculate zoom level based on speed
  let zoomLevel
  if (tier === SPEED_TIERS.STATIONARY) {
    zoomLevel = 18 // Maximum zoom when stationary
  } else if (speedMPS <= SPEED_TIERS.WALKING.max) {
    // Smooth transition between 17-18 for walking
    const t = (speedMPS - SPEED_TIERS.STATIONARY.max) / (SPEED_TIERS.WALKING.max - SPEED_TIERS.STATIONARY.max)
    zoomLevel = 18 - t
  } else if (speedMPS <= SPEED_TIERS.RUNNING.max) {
    // Smooth transition between 15-17 for running
    const t = (speedMPS - SPEED_TIERS.WALKING.max) / (SPEED_TIERS.RUNNING.max - SPEED_TIERS.WALKING.max)
    zoomLevel = 17 - t * 2
  } else {
    // Driving speed - fixed zoom level
    zoomLevel = 14
  }

  // Return all parameters
  return {
    tier: tier.name,
    edgeThreshold,
    flyToDuration,
    zoomLevel,
    // Add recenter behavior based on speed
    recenterBehavior: tier === SPEED_TIERS.DRIVING ? "immediate" : "smooth",
    // Add animation duration based on speed
    animationDuration: tier === SPEED_TIERS.DRIVING ? 100 : 300,
  }
}

// Calculate appropriate zoom level based on speed
function calculateZoomLevel(speedMPS) {
  // Update current speed for global access
  currentSpeed = speedMPS

  // Get speed-adaptive parameters
  const params = getSpeedAdaptiveParameters(speedMPS)
  let zoomLevel = params.zoomLevel

  // Smooth zoom level changes
  if (lastZoomLevel !== null) {
    // Apply smoothing to avoid abrupt zoom changes
    // More responsive in driving mode, smoother in walking mode
    const smoothingFactor = params.tier === "Driving" ? 0.3 : 0.15
    zoomLevel = lastZoomLevel * (1 - smoothingFactor) + zoomLevel * smoothingFactor
  }

  // Round to one decimal place for smoother transitions
  zoomLevel = Math.round(zoomLevel * 10) / 10

  // Clamp to valid zoom range
  zoomLevel = Math.max(MIN_ZOOM_LEVEL, Math.min(MAX_ZOOM_LEVEL, zoomLevel))

  // Update last zoom level
  lastZoomLevel = zoomLevel

  return zoomLevel
}

// Enhanced stationary position calculation
function calculateStationaryPosition(buffer) {
  if (!buffer || buffer.length === 0) {
    return null
  }

  // Sort by accuracy (best first)
  const sortedBuffer = [...buffer].sort((a, b) => a.accuracy - b.accuracy)

  // Take weighted average of best positions
  const topPositions = sortedBuffer.slice(0, Math.ceil(buffer.length / 2))

  const weights = topPositions.map((pos) => 1 / Math.max(1, pos.accuracy))
  const totalWeight = weights.reduce((sum, w) => sum + w, 0)

  if (totalWeight === 0) {
    return sortedBuffer[0]
  }

  // Calculate weighted average
  const avgPosition = {
    lat: topPositions.reduce((sum, pos, i) => sum + pos.lat * weights[i], 0) / totalWeight,
    lng: topPositions.reduce((sum, pos, i) => sum + pos.lng * weights[i], 0) / totalWeight,
    accuracy: topPositions[0].accuracy,
    heading: topPositions[0].heading,
    timestamp: Date.now(),
    speedMPS: 0,
  }

  // If we have a previous stationary position, blend with it for stability
  if (lastStationaryPosition) {
    // Increased to 99% previous, 1% new for extreme stability when stationary
    const blendFactor = 0.99
    return {
      lat: lastStationaryPosition.lat * blendFactor + avgPosition.lat * (1 - blendFactor),
      lng: lastStationaryPosition.lng * blendFactor + avgPosition.lng * (1 - blendFactor),
      accuracy: avgPosition.accuracy,
      heading: avgPosition.heading,
      timestamp: avgPosition.timestamp,
      speedMPS: 0,
    }
  }

  return avgPosition
}

// Update stationary position history
function updateStationaryHistory(position) {
  // Add new position to history
  stationaryPositionHistory.push(position)

  // Keep history at maximum size
  while (stationaryPositionHistory.length > STATIONARY_POSITION_HISTORY_SIZE) {
    stationaryPositionHistory.shift()
  }

  // Calculate weighted average of positions
  let totalWeight = 0
  let weightedLat = 0
  let weightedLng = 0

  // Newer positions have higher weight
  for (let i = 0; i < stationaryPositionHistory.length; i++) {
    const pos = stationaryPositionHistory[i]
    const weight = Math.pow(STATIONARY_POSITION_WEIGHT_DECAY, stationaryPositionHistory.length - i - 1)
    totalWeight += weight
    weightedLat += pos.lat * weight
    weightedLng += pos.lng * weight
  }

  return {
    lat: weightedLat / totalWeight,
    lng: weightedLng / totalWeight,
    accuracy: position.accuracy,
    heading: position.heading,
    timestamp: position.timestamp,
    speedMPS: 0,
  }
}

// Check if device is in motion based on motion sensors
function isDeviceInMotion() {
  if (!motionSamples || motionSamples.length < 3) {
    return false
  }

  // Calculate average motion magnitude
  const avgMotion =
    motionSamples.reduce((sum, sample) => {
      return sum + Math.sqrt(sample.x * sample.x + sample.y * sample.y + sample.z * sample.z)
    }, 0) / motionSamples.length

  return avgMotion > MOTION_THRESHOLD
}

// Process device motion data
function handleDeviceMotion(event) {
  if (!event || !event.acceleration) return

  const motion = {
    x: event.acceleration.x || 0,
    y: event.acceleration.y || 0,
    z: event.acceleration.z || 0,
    timestamp: Date.now(),
  }

  // Add to motion samples
  motionSamples.push(motion)

  // Keep only recent samples
  while (motionSamples.length > MOTION_SAMPLE_SIZE) {
    motionSamples.shift()
  }

  // Update device motion state
  deviceMotion = motion

  // Check if device is stationary based on motion
  const inMotion = isDeviceInMotion()

  if (!inMotion) {
    deviceStationaryTime += MOTION_CHECK_INTERVAL
  } else {
    deviceStationaryTime = 0
  }
}

// Process device orientation data
function handleDeviceOrientation(event) {
  if (!event || event.alpha === null) return

  deviceOrientation = {
    alpha: event.alpha, // z-axis rotation [0,360)
    beta: event.beta, // x-axis rotation [-180,180)
    gamma: event.gamma, // y-axis rotation [-90,90)
    timestamp: Date.now(),
  }

  // Update heading buffer if we have a compass heading
  if (event.webkitCompassHeading !== undefined) {
    const heading = event.webkitCompassHeading

    // Add to heading buffer
    headingBuffer.push(heading)

    // Keep only recent headings
    while (headingBuffer.length > 5) {
      headingBuffer.shift()
    }

    // Calculate median heading to filter outliers
    if (headingBuffer.length >= 3) {
      const sortedHeadings = [...headingBuffer].sort((a, b) => a - b)
      lastHeadingValue = sortedHeadings[Math.floor(sortedHeadings.length / 2)]
    }
  }
}

// Request device motion and orientation permissions
function requestMotionPermission() {
  if (typeof DeviceMotionEvent !== "undefined" && typeof DeviceMotionEvent.requestPermission === "function") {
    DeviceMotionEvent.requestPermission()
      .then((response) => {
        if (response === "granted") {
          window.addEventListener("devicemotion", handleDeviceMotion, true)
        }
      })
      .catch(console.error)
  } else {
    window.addEventListener("devicemotion", handleDeviceMotion, true)
  }

  if (typeof DeviceOrientationEvent !== "undefined" && typeof DeviceOrientationEvent.requestPermission === "function") {
    DeviceOrientationEvent.requestPermission()
      .then((response) => {
        if (response === "granted") {
          orientationPermissionGranted = true
          window.addEventListener("deviceorientation", handleDeviceOrientation, true)
        }
      })
      .catch(console.error)
  } else {
    window.addEventListener("deviceorientation", handleDeviceOrientation, true)
    orientationPermissionGranted = true
  }
}

// Image preloading function with improved batching
function preloadImages(locationsData) {
  return new Promise((resolve) => {
    if (!locationsData || locationsData.length === 0) {
      resolve()
      return
    }

    const totalImages = locationsData.length
    let loadedImages = 0
    const progressBar = document.getElementById("preloaderProgress")

    // Create preload queue
    const imagePreloadQueue = locationsData
      .filter((location) => location.image && !preloadedImages.has(location.image))
      .map((location) => location.image)

    // Also queue audio files
    const audioPreloadQueue = locationsData
      .filter((location) => location.audio && !preloadedAudio.has(location.audio))
      .map((location) => location.audio)

    // Start preloading
    const preloadStartTime = Date.now()
    let isPreloading = true
    const preloadBatchSize = 5

    // Process next batch
    function processNextBatch() {
      if (imagePreloadQueue.length === 0 && audioPreloadQueue.length === 0) {
        isPreloading = false
        resolve()
        return
      }

      // Process image batch
      const imageBatch = imagePreloadQueue.splice(0, preloadBatchSize)

      // Load images in batch
      Promise.all(
        imageBatch.map((imageUrl) => {
          return new Promise((resolveImage) => {
            const img = new Image()
            img.crossOrigin = "anonymous" // Set crossOrigin for canvas operations

            img.onload = () => {
              preloadedImages.set(imageUrl, img)
              loadedImages++
              updateProgress()
              resolveImage()
            }

            img.onerror = () => {
              console.warn(`Failed to load image: ${imageUrl}`)
              loadedImages++
              updateProgress()
              resolveImage()
            }

            img.src = imageUrl
          })
        }),
      )
        .then(() => {
          // Process audio batch
          const audioBatch = audioPreloadQueue.splice(0, preloadBatchSize)

          // Load audio in batch
          return Promise.all(
            audioBatch.map((audioUrl) => {
              return new Promise((resolveAudio) => {
                const audio = new Audio()
                audio.preload = "auto"

                audio.oncanplaythrough = () => {
                  preloadedAudio.set(audioUrl, audio)
                  resolveAudio()
                }

                audio.onerror = () => {
                  console.warn(`Failed to load audio: ${audioUrl}`)
                  resolveAudio()
                }

                audio.src = audioUrl
              })
            }),
          )
        })
        .then(() => {
          // Continue with next batch after a small delay to prevent UI blocking
          setTimeout(processNextBatch, 10)
        })
        .catch((error) => {
          console.error("Error preloading batch:", error)
          setTimeout(processNextBatch, 10)
        })
    }

    function updateProgress() {
      const percent = (loadedImages / totalImages) * 100
      domUpdateManager.schedule(
        "preloaderProgress",
        () => {
          progressBar.style.width = `${percent}%`
        },
        TASK_PRIORITIES.LOW,
      )
    }

    // Start processing batches
    processNextBatch()
  })
}

// Detect sudden movements or position jumps
function detectSuddenMovement(newPosition, lastPosition) {
  if (!lastPosition || !newPosition) return false

  const distance = calculateDistance(lastPosition, newPosition)
  const timeDelta = (newPosition.timestamp - lastPosition.timestamp) / 1000 // seconds

  // If time delta is too small, consider it a valid update
  if (timeDelta < 0.05) return false

  // Calculate speed in meters per second
  const speed = distance / timeDelta

  // Check for unrealistic speeds (teleportation)
  if (speed > 50) {
    // 50 m/s is about 112 mph
    console.log(`Position jump detected: ${distance.toFixed(2)}m in ${timeDelta.toFixed(2)}s (${speed.toFixed(2)} m/s)`)
    return true
  }

  // Check for sudden movements when stationary
  if (isStationary && distance > POSITION_JUMP_THRESHOLD) {
    console.log(`Sudden movement detected while stationary: ${distance.toFixed(2)}m`)
    return true
  }

  // Check for small sudden movements (jitter)
  if (isStationary && distance > SUDDEN_MOVEMENT_THRESHOLD) {
    suddenMovementCount++
    if (suddenMovementCount >= 2) {
      console.log(`Multiple sudden movements detected: ${distance.toFixed(2)}m`)
      return true
    }
  } else {
    suddenMovementCount = 0
  }

  return false
}

// OPTIMIZED: Check proximity to locations and adjust zoom accordingly
function checkLocationProximity() {
  const now = Date.now()

  // Don't check too frequently - throttled to 10fps as requested
  if (now - lastProximityCheck < 100) return
  lastProximityCheck = now

  // Don't check if zoom was recently changed
  if (now - lastZoomChangeTime < ZOOM_CHANGE_COOLDOWN) return

  // Don't check if user is manually zooming
  if (isUserZooming) return

  // Skip in low performance mode unless it's been a while
  if (isLowPerformanceMode && now - lastProximityCheck < 300) return

  if (!userMarker || !gameLocations || gameLocations.length === 0) return

  const userLatLng = userMarker.getLatLng()
  const userPos = { lat: userLatLng.lat, lng: userLatLng.lng }

  // Find closest location
  let closestDistance = Number.POSITIVE_INFINITY
  let closestLocation = null

  for (const location of gameLocations) {
    if (!location || typeof location.lat !== "number" || typeof location.lng !== "number") continue

    const locationPos = { lat: location.lat, lng: location.lng }
    const distance = calculateDistance(userPos, locationPos)

    if (isFinite(distance) && distance < closestDistance) {
      closestDistance = distance
      closestLocation = location
    }
  }

  // Convert to feet for threshold comparison
  const distanceFeet = Math.round(closestDistance * 3.28084)

  // Constants for hysteresis and thresholds
  const HYSTERESIS_FACTOR = 1.1 // 10% buffer to prevent rapid toggling
  const ZOOM_IN_THRESHOLD = PROXIMITY_THRESHOLD * 0.9 // 90% of PROXIMITY_THRESHOLD
  const ZOOM_OUT_THRESHOLD = PROXIMITY_THRESHOLD * 1.1 // 110% of PROXIMITY_THRESHOLD

  // Check if we need to adjust zoom based on proximity
  if (distanceFeet <= ZOOM_IN_THRESHOLD) {
    // If we weren't near a location before, zoom in
    if (!isNearLocation && Math.abs(lastProximityDistance - closestDistance) > 1) {
      console.log(`User is now within ${ZOOM_IN_THRESHOLD.toFixed(1)} feet of a location, zooming in`)
      isNearLocation = true
      lastZoomChangeTime = now

      // Calculate new zoom level (clamped to MAX_ZOOM_LEVEL)
      const currentZoom = map.getZoom()
      const newZoom = Math.min(currentZoom + 1, MAX_ZOOM_LEVEL)

      // Apply zoom change with smooth animation
      map.setZoom(newZoom, {
        animate: true,
        duration: ZOOM_TRANSITION_DURATION,
      })
    }
  } else if (distanceFeet >= ZOOM_OUT_THRESHOLD && isNearLocation) {
    // If we were near a location but now we're not, zoom out
    console.log(`User is now outside ${ZOOM_OUT_THRESHOLD.toFixed(1)} feet of a location, zooming out`)
    isNearLocation = false
    lastZoomChangeTime = now

    // Calculate new zoom level (clamped to MIN_ZOOM_LEVEL)
    const currentZoom = map.getZoom()
    const newZoom = Math.max(currentZoom - 1, MIN_ZOOM_LEVEL)

    // Apply zoom change with smooth animation
    map.setZoom(newZoom, {
      animate: true,
      duration: ZOOM_TRANSITION_DURATION,
    })
  }

  // Update last proximity distance
  lastProximityDistance = closestDistance
}

function initMap() {
  map = L.map("map", {
    zoomControl: false,
    attributionControl: false,
    zoomSnap: 0.1,
    zoomDelta: 0.5,
    wheelDebounceTime: 100,
    tapTolerance: 15,
    bounceAtZoomLimits: false,
    preferCanvas: true, // Use canvas renderer for better performance
    renderer: L.canvas({ padding: 0.5 }),
  }).fitWorld()

  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    maxZoom: 18,
    attribution: " OpenStreetMap contributors",
    updateWhenIdle: true,
    updateWhenZooming: false,
    keepBuffer: 2,
  }).addTo(map)

  markerClusterGroup = L.markerClusterGroup({
    showCoverageOnHover: false,
    zoomToBoundsOnClick: true,
    spiderfyOnMaxZoom: true,
    animate: true,
    animateAddingMarkers: true,
    disableClusteringAtZoom: 18,
    maxClusterRadius: 60,
    iconCreateFunction: (cluster) =>
      L.divIcon({
        html: "<div><span>" + cluster.getChildCount() + "</span></div>",
        className: "marker-cluster-custom",
        iconSize: L.point(40, 40),
      }),
  })
  map.addLayer(markerClusterGroup)

  // Create user icon with custom styling (red)
  const userIcon = L.divIcon({
    className: "user-marker",
    html: '<div class="user-marker-icon"></div>',
    iconSize: [20, 20],
    iconAnchor: [10, 10],
  })
  userMarker = L.marker([0, 0], {
    icon: userIcon,
    zIndexOffset: 1000, // Ensure user marker is on top
    interactive: false, // Prevent marker from being clickable
  }).addTo(map)

  // Store map viewport dimensions
  updateMapViewportDimensions()

  showLoadingMessage()

  // Request motion and orientation permissions
  requestMotionPermission()

  // Try to use Geolocation Sensor API first, then fall back to standard Geolocation API
  initGeolocation()

  document.addEventListener("visibilitychange", handleVisibilityChange)

  // NEW: Enhanced zoom and drag event handling with user interaction tracking
  map.on("zoomstart", () => {
    isUserZooming = true
    isMapInteracting = true
    followUser = false

    // Clear any existing cooldown timer
    if (userZoomCooldownTimer) {
      clearTimeout(userZoomCooldownTimer)
    }

    // Set cooldown timer
    userZoomCooldownTimer = setTimeout(() => {
      isUserZooming = false
      console.log("User zoom cooldown expired")
    }, USER_ZOOM_COOLDOWN)

    lastUserZoomTime = Date.now()

    // Debug log
    console.log("User zoom detected, blocking auto-zoom for 3s")
  })

  map.on("movestart dragstart", () => {
    followUser = false
    isMapInteracting = true
  })

  map.on("moveend zoomend", () => {
    isMapInteracting = false
    resetInactivityTimer()
    updateMapViewportDimensions()

    // Check if viewport dimensions changed significantly (orientation change)
    const currentDimensions = {
      width: mapViewportWidth,
      height: mapViewportHeight,
    }

    if (
      Math.abs(currentDimensions.width - lastViewportDimensions.width) > 50 ||
      Math.abs(currentDimensions.height - lastViewportDimensions.height) > 50
    ) {
      // Update dynamic edge threshold based on viewport size
      updateDynamicEdgeThreshold()

      lastOrientationChange = Date.now()
      lastViewportDimensions = { ...currentDimensions }

      console.log("Viewport dimensions changed, updated edge threshold:", dynamicEdgeThreshold)
    }
  })

  // Listen for resize events to update viewport dimensions
  window.addEventListener("resize", () => {
    updateMapViewportDimensions()
    updateDynamicEdgeThreshold()
  })

  // Start animation loop for smooth rendering
  startAnimationLoop()

  // Enable touch interactions
  map.touchZoom.enable()
  map.doubleClickZoom.enable()

  // Initialize network status monitoring
  initNetworkMonitoring()
}

// NEW: Update dynamic edge threshold based on viewport size
function updateDynamicEdgeThreshold() {
  // Calculate threshold based on viewport width
  // Smaller screens need larger thresholds (as a percentage) to provide enough room
  dynamicEdgeThreshold = Math.min(0.15, 100 / mapViewportWidth)

  // Ensure minimum threshold
  dynamicEdgeThreshold = Math.max(0.05, dynamicEdgeThreshold)

  // Debug log
  console.log(`Dynamic edge threshold updated: ${dynamicEdgeThreshold.toFixed(3)}`)
}

// Initialize network status monitoring
function initNetworkMonitoring() {
  const networkStatus = document.getElementById("networkStatus")

  // Update network status indicator
  function updateNetworkStatus() {
    if (navigator.onLine) {
      networkStatus.classList.remove("offline")
      networkStatus.title = "Online"
      isOnline = true
    } else {
      networkStatus.classList.add("offline")
      networkStatus.title = "Offline"
      isOnline = false
      showErrorMessage("No internet connection. Some features may not work properly.")
    }
  }

  // Initial status check
  updateNetworkStatus()

  // Listen for network status changes
  window.addEventListener("online", () => {
    updateNetworkStatus()
    showErrorMessage("Internet connection restored.")

    // Retry any failed operations
    if (gameLocations.length === 0) {
      startHunt()
    }
  })

  window.addEventListener("offline", () => {
    updateNetworkStatus()
    showErrorMessage("No internet connection. Some features may not work properly.")
  })

  // Periodically check network status
  setInterval(() => {
    // Check if we can fetch a small resource to verify actual connectivity
    if (navigator.onLine) {
      fetch("https://www.mnthen.com/favicon.ico", {
        method: "HEAD",
        cache: "no-store",
        mode: "no-cors",
        timeout: 3000,
      })
        .then(() => {
          if (!isOnline) {
            isOnline = true
            networkStatus.classList.remove("offline")
            networkStatus.title = "Online"
          }
        })
        .catch((error) => {
          networkErrorCount++
          const now = Date.now()

          // Only show error message if it's been a while since the last one
          if (now - lastNetworkErrorTime > 30000 && networkErrorCount > 2) {
            showErrorMessage("Network connection is unstable.")
            lastNetworkErrorTime = now
          }

          if (networkErrorCount > 5) {
            isOnline = false
            networkStatus.classList.add("offline")
            networkStatus.title = "Connection unstable"
          }
        })
    }
  }, NETWORK_CHECK_INTERVAL)
}

// Update map viewport dimensions
function updateMapViewportDimensions() {
  if (map && map._container) {
    mapViewportWidth = map._container.clientWidth
    mapViewportHeight = map._container.clientHeight

    // Store current map center and zoom
    if (map.getCenter()) {
      lastMapCenter = map.getCenter()
      lastMapZoom = map.getZoom()
    }
  }
}

// Initialize geolocation with priority for Geolocation Sensor API
function initGeolocation() {
  if ("GeolocationSensor" in window) {
    try {
      console.log("Trying GeolocationSensor API")
      geolocationSensor = new GeolocationSensor({ frequency: 1 })

      geolocationSensor.addEventListener("reading", () => {
        const position = {
          coords: {
            latitude: geolocationSensor.latitude,
            longitude: geolocationSensor.longitude,
            accuracy: geolocationSensor.accuracy,
            altitude: geolocationSensor.altitude,
            altitudeAccuracy: geolocationSensor.altitude,
            heading: geolocationSensor.heading,
            speed: geolocationSensor.speed,
          },
          timestamp: geolocationSensor.timestamp,
        }

        if (!lastPosition) {
          initializeUserLocation(position)
        } else {
          handlePositionUpdate(position)
        }
      })

      geolocationSensor.addEventListener("error", (error) => {
        console.warn("GeolocationSensor error:", error)
        // Fall back to standard Geolocation API
        useStandardGeolocation()
      })

      geolocationSensor.start()
      usingGeolocationSensorAPI = true
      console.log("Using GeolocationSensor API")
    } catch (error) {
      console.warn("GeolocationSensor error:", error)
      // Fall back to standard Geolocation API
      useStandardGeolocation()
    }
  } else {
    // Fall back to standard Geolocation API
    useStandardGeolocation()
  }
}

// Standard Geolocation API fallback
function useStandardGeolocation() {
  console.log("Using standard Geolocation API")
  usingGeolocationSensorAPI = false

  if ("geolocation" in navigator) {
    const options = {
      enableHighAccuracy: true,
      timeout: 45000,
      maximumAge: 0,
    }

    // Try first time
    navigator.geolocation.getCurrentPosition(
      initializeUserLocation,
      (error) => {
        // Handle error based on error code
        if (error.code === PERMISSION_DENIED_ERROR) {
          permissionDenied = true
          handleLocationPermissionDenied()
        } else {
          // On other errors, try one more time before falling back
          navigator.geolocation.getCurrentPosition(initializeUserLocation, handleLocationError, options)
        }
      },
      options,
    )
  } else {
    showErrorMessage("Geolocation is not supported by your browser")
    map.setView([44.9778, -93.265], 18)
    hideLoadingMessage()
  }
}

// Handle location permission denied
function handleLocationPermissionDenied() {
  permissionDenied = true
  hideLoadingMessage()

  // Show error message
  showErrorMessage("Location access denied. Please enable location services to use this app.")

  // Show popup with instructions
  showPopup(
    "Location Access Required",
    "This app needs access to your location to guide you to historical sites. " +
      "Please enable location services in your browser settings and reload the page.",
    "error",
    () => {
      // Try to request permission again after a delay
      setTimeout(() => {
        if (!permissionRequestInProgress && Date.now() - lastPermissionRequest > 60000) {
          requestLocationPermission()
        }
      }, 5000)
    },
  )

  // Set default view
  map.setView([44.9778, -93.265], 18)
}

// Request location permission
function requestLocationPermission() {
  if (permissionRequestInProgress) return

  permissionRequestInProgress = true
  lastPermissionRequest = Date.now()

  if ("geolocation" in navigator) {
    const options = {
      enableHighAccuracy: true,
      timeout: 10000,
      maximumAge: 0,
    }

    navigator.geolocation.getCurrentPosition(
      (position) => {
        permissionDenied = false
        permissionRequestInProgress = false
        initializeUserLocation(position)
      },
      (error) => {
        permissionRequestInProgress = false
        if (error.code === PERMISSION_DENIED_ERROR) {
          permissionDenied = true
          showErrorMessage("Location access still denied. Please enable location in your browser settings.")
        } else {
          handleLocationError(error)
        }
      },
      options,
    )
  }
}

// OPTIMIZED: Animation loop for smooth rendering with performance monitoring
function startAnimationLoop() {
  // Initialize performance monitoring
  lastFrameTime = performance.now()
  frameTimeHistory = []

  function animate(timestamp) {
    // Calculate delta time
    const deltaTime = renderTimestamp ? (timestamp - renderTimestamp) / 1000 : 0
    renderTimestamp = timestamp

    // Measure frame time for performance monitoring
    const frameTime = timestamp - lastFrameTime
    lastFrameTime = timestamp

    // Track frame times for performance analysis
    frameTimeHistory.push(frameTime)
    if (frameTimeHistory.length > MAX_FRAME_HISTORY) {
      frameTimeHistory.shift()
    }

    // Periodically check performance and adjust settings
    performanceCheckCounter++
    if (performanceCheckCounter >= 60) {
      // Check every ~1 second (assuming 60fps)
      checkPerformance()
      performanceCheckCounter = 0
    }

    // Process position updates (high priority)
    processPositionUpdateQueue()

    // Update interpolated position (high priority)
    if (positionInterpolator && positionInterpolator.isInterpolating()) {
      const interpolatedPosition = positionInterpolator.update()
      if (interpolatedPosition) {
        // Update marker position
        updateMarkerPosition(interpolatedPosition)
        lastRenderPosition = interpolatedPosition
      }
    }

    // Check if marker is near edge and recenter if needed (medium priority)
    // Skip if user is actively zooming
    if (followUser && !isMapInteracting && !edgeRecenterInProgress && !isUserZooming) {
      const now = Date.now()
      // Only check edge proximity at regular intervals to improve performance
      if (now - lastEdgeCheck > edgeCheckInterval) {
        lastEdgeCheck = now

        // Use dynamic edge threshold based on viewport size and speed
        const speedParams = getSpeedAdaptiveParameters(currentSpeed || 0)
        const effectiveThreshold = Math.max(dynamicEdgeThreshold, speedParams.edgeThreshold)

        const recenterInfo = shouldRecenter(map, userMarker, effectiveThreshold)
        if (recenterInfo.needsRecenter) {
          performEdgeRecenter(recenterInfo, speedParams)
        }
      }
    }

    // Check proximity to locations for zoom adjustments (low priority)
    // Skip in low performance mode or if user is actively zooming
    if (!isLowPerformanceMode && !isUserZooming) {
      checkLocationProximity()
    }

    // Update GPS signal indicator (low priority)
    // Throttle in low performance mode
    const now = Date.now()
    if (!isLowPerformanceMode || now - lastAccuracyUpdate > GPS_SIGNAL_CHECK_INTERVAL * 2) {
      updateGpsSignalIndicator()
    }

    // Request next frame
    animationFrameId = requestAnimationFrame(animate)
  }

  // Start animation loop
  animationFrameId = requestAnimationFrame(animate)
}

// NEW: Check performance and adjust settings
function checkPerformance() {
  if (frameTimeHistory.length < 5) return

  // Calculate average frame time
  const avgFrameTime = frameTimeHistory.reduce((sum, time) => sum + time, 0) / frameTimeHistory.length

  // Check if we need to adjust performance mode
  if (avgFrameTime > frameTimeThreshold * 1.5 && !isLowPerformanceMode) {
    console.log(
      `Average frame time (${avgFrameTime.toFixed(2)}ms) exceeds threshold (${frameTimeThreshold.toFixed(2)}ms), entering low performance mode`,
    )
    isLowPerformanceMode = true

    // Adjust settings for low performance mode
    edgeCheckInterval = 1000 // Check edges less frequently
    mapUpdateThrottleInterval = 200 // Throttle map updates more aggressively
  } else if (avgFrameTime < frameTimeThreshold * 0.8 && isLowPerformanceMode) {
    console.log(
      `Average frame time (${avgFrameTime.toFixed(2)}ms) below threshold (${frameTimeThreshold.toFixed(2)}ms), exiting low performance mode`,
    )
    isLowPerformanceMode = false

    // Restore normal settings
    edgeCheckInterval = 500
    mapUpdateThrottleInterval = 100
  }

  // Log performance metrics for debugging
  console.debug(`Performance: ${avgFrameTime.toFixed(2)}ms/frame (${(1000 / avgFrameTime).toFixed(1)} FPS)`)
}

// Update marker position with throttling
function updateMarkerPosition(position) {
  const now = Date.now()

  // Throttle updates to improve performance
  if (now - lastMapUpdate < mapUpdateThrottleInterval) {
    return
  }

  lastMapUpdate = now
  userMarker.setLatLng([position.lat, position.lng])
}

// Update GPS signal indicator
function updateGpsSignalIndicator() {
  const now = Date.now()

  // Don't update too frequently
  if (now - lastAccuracyUpdate < GPS_SIGNAL_CHECK_INTERVAL) {
    return
  }

  lastAccuracyUpdate = now

  // Get current position accuracy
  let accuracy = 0
  let signalText = ""
  let signalClass = ""

  if (lastPosition && typeof lastPosition.accuracy === "number") {
    accuracy = lastPosition.accuracy

    // Update confidence score history
    confidenceScoreHistory.push(calculateGpsConfidenceScore(accuracy))

    // Keep history at reasonable size
    while (confidenceScoreHistory.length > 5) {
      confidenceScoreHistory.shift()
    }

    // Calculate average confidence score
    gpsConfidenceScore = confidenceScoreHistory.reduce((sum, score) => sum + score, 0) / confidenceScoreHistory.length

    // Determine signal quality
    if (accuracy <= GPS_CONFIDENCE_THRESHOLD_HIGH) {
      signalText = ""
      signalClass = "accuracy-high"
    } else if (accuracy <= GPS_CONFIDENCE_THRESHOLD_MEDIUM) {
      signalText = ""
      signalClass = "accuracy-medium"
    } else {
      signalText = ""
      signalClass = "accuracy-low"
    }
  } else {
    signalText = ""
    signalClass = "accuracy-low"
  }

  // Update indicator
  domUpdateManager.schedule(
    "accuracyIndicator",
    () => {
      const indicator = document.getElementById("accuracyIndicator")
      const dot = indicator.querySelector(".accuracy-dot")
      const text = document.getElementById("accuracyText")

      // Remove all classes
      dot.classList.remove("accuracy-high", "accuracy-medium", "accuracy-low")

      // Add appropriate class
      dot.classList.add(signalClass)

      // Update text
      text.textContent = signalText
    },
    TASK_PRIORITIES.LOW,
  )
}

// Calculate GPS confidence score (0-1)
function calculateGpsConfidenceScore(accuracy) {
  if (!accuracy || accuracy <= 0) return 0

  // Higher accuracy (lower value) means higher confidence
  if (accuracy <= GPS_CONFIDENCE_THRESHOLD_HIGH) {
    return 1.0
  } else if (accuracy <= GPS_CONFIDENCE_THRESHOLD_MEDIUM) {
    // Linear interpolation between high and medium thresholds
    return (
      0.5 +
      (0.5 * (GPS_CONFIDENCE_THRESHOLD_MEDIUM - accuracy)) /
        (GPS_CONFIDENCE_THRESHOLD_MEDIUM - GPS_CONFIDENCE_THRESHOLD_HIGH)
    )
  } else {
    // Linear interpolation between medium threshold and max acceptable
    return Math.max(
      0.1,
      (0.5 * (MAX_ACCEPTABLE_ACCURACY - accuracy)) / (MAX_ACCEPTABLE_ACCURACY - GPS_CONFIDENCE_THRESHOLD_MEDIUM),
    )
  }
}

// Process position update queue
function processPositionUpdateQueue() {
  if (positionUpdateQueue.length === 0) return

  // Process all updates in queue
  while (positionUpdateQueue.length > 0) {
    const update = positionUpdateQueue.shift()
    processPositionUpdate(update)
  }
}

// Process position update
function processPositionUpdate(position) {
  // Skip if invalid position
  if (!position || typeof position.lat !== "number" || typeof position.lng !== "number") {
    return
  }

  // Update last position
  lastPosition = position

  // Start interpolation to new position
  if (lastRenderPosition && !isFirstPositionUpdate) {
    positionInterpolator.start(lastRenderPosition, position, isStationary ? 500 : ANIMATION_DURATION)
  } else {
    // First update, just set position directly
    userMarker.setLatLng([position.lat, position.lng])
    lastRenderPosition = position
    isFirstPositionUpdate = false
  }

  // Auto-recenter map if following user and not manually zooming
  if (followUser && !isMapInteracting && !isUserZooming) {
    const speedParams = getSpeedAdaptiveParameters(position.speedMPS || 0)
    const effectiveThreshold = Math.max(dynamicEdgeThreshold, speedParams.edgeThreshold)

    const recenterInfo = shouldRecenter(map, userMarker, effectiveThreshold)
    if (recenterInfo.needsRecenter) {
      performEdgeRecenter(recenterInfo, speedParams)
    } else if (Math.abs(map.getZoom() - calculateZoomLevel(position.speedMPS)) > 0.5) {
      // If zoom level should change significantly but no recenter needed
      const newZoom = calculateZoomLevel(position.speedMPS)
      map.setZoom(newZoom, {
        animate: true,
        duration: ZOOM_TRANSITION_DURATION,
      })
    }
  }
}

// OPTIMIZED: Perform edge recentering with speed-adaptive parameters
function performEdgeRecenter(recenterInfo, speedParams) {
  // Skip if user is manually zooming
  if (isUserZooming) return

  edgeRecenterInProgress = true

  // Get current position
  const position = userMarker.getLatLng()

  // Calculate appropriate zoom level based on speed
  const dynamicZoom = calculateZoomLevel(lastPosition?.speedMPS || 0)

  // Calculate optimal center point that keeps the user icon away from edges
  const optimalCenter = calculateOptimalCenter(map, position, recenterInfo.edgeInfo)

  // Use speed-adaptive parameters for animation duration
  const animationDuration = speedParams
    ? recenterInfo.isEmergency
      ? 0.2
      : speedParams.flyToDuration
    : recenterInfo.isEmergency
      ? 0.2
      : ZOOM_TRANSITION_DURATION

  // Debug log
  console.log(
    `Edge recenter: speed=${lastPosition?.speedMPS || 0}m/s, duration=${animationDuration}s, zoom=${dynamicZoom}`,
  )

  // Set view with animation
  map.setView([optimalCenter.lat, optimalCenter.lng], dynamicZoom, {
    animate: true,
    duration: animationDuration,
    noMoveStart: true,
    easeLinearity: 0.5,
  })

  // Reset edge recenter flag after animation completes
  setTimeout(
    () => {
      edgeRecenterInProgress = false

      // Notify that map was recentered
      if (typeof onMapRecentered === "function") {
        onMapRecentered()
      }
    },
    recenterInfo.isEmergency ? 300 : animationDuration * 1000,
  )
}

function showLoadingMessage() {
  const loadingMessage = document.createElement("div")
  loadingMessage.id = "loadingMessage"
  loadingMessage.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: rgba(255, 255, 255, 0.9);
        padding: 20px;
        border-radius: 10px;
        z-index: 1000;
        text-align: center;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    `
  loadingMessage.innerHTML = `
        <div style="margin-bottom: 15px;">
            <div style="width: 40px; height: 40px; border: 4px solid rgba(255, 0, 0, 0.2); border-top: 4px solid #ff0000; border-radius: 50%; margin: 0 auto 15px; animation: spin 1s linear infinite;"></div>
        </div>
        <p style="font-weight: 500; color: #333;">Searching for your location...</p>
    `
  document.body.appendChild(loadingMessage)
}

function hideLoadingMessage() {
  const loadingMessage = document.getElementById("loadingMessage")
  if (loadingMessage) {
    document.body.removeChild(loadingMessage)
  }
}

function showStabilizingModal() {
  const modal = document.createElement("div")
  modal.id = "stabilizingModal"
  modal.className = "stabilizing-modal"
  modal.innerHTML = `
        <div class="spinner"></div>
        <h3>Stabilizing Your Location</h3>
        <p>Please wait while we fine-tune your position.</p>
    `
  document.body.appendChild(modal)

  // Auto-dismiss after 5 seconds
  setTimeout(() => {
    const stabilizingModal = document.getElementById("stabilizingModal")
    if (stabilizingModal) {
      stabilizingModal.style.opacity = "0"
      stabilizingModal.style.transition = "opacity 0.5s ease"
      setTimeout(() => {
        if (stabilizingModal && stabilizingModal.parentNode) {
          stabilizingModal.parentNode.removeChild(stabilizingModal)
        }
        isStabilizing = false
      }, 500)
    }
  }, 5000)
}

function initializeUserLocation(position) {
  console.log("Initial position data:", JSON.stringify(position))

  if (!position || !position.coords) {
    console.error("Invalid initial position object")
    handleLocationError(new Error("Invalid initial position"))
    return
  }

  const { latitude: userLat, longitude: userLng, accuracy } = position.coords

  if (isNaN(userLat) || isNaN(userLng)) {
    console.error("Invalid initial coordinates:", { userLat, userLng })
    handleLocationError(new Error("Invalid initial coordinates"))
    return
  }

  console.log("Valid initial position:", { userLat, userLng, accuracy })

  try {
    userMarker.setLatLng([userLat, userLng])
    map.setView([userLat, userLng], 18)

    // Initialize Kalman filter with first position
    kalmanFilter.reset({
      lat: userLat,
      lng: userLng,
      accuracy: accuracy,
      heading: position.coords.heading,
      timestamp: Date.now(),
    })

    // Initialize stationary position
    lastStationaryPosition = {
      lat: userLat,
      lng: userLng,
      accuracy: accuracy,
      heading: position.coords.heading,
      timestamp: Date.now(),
      speedMPS: 0,
    }

    // Initialize last render position
    lastRenderPosition = {
      lat: userLat,
      lng: userLng,
      accuracy: accuracy,
      heading: position.coords.heading,
      timestamp: Date.now(),
      speedMPS: 0,
    }

    // Initialize last valid position
    lastValidPosition = {
      lat: userLat,
      lng: userLng,
      accuracy: accuracy,
      heading: position.coords.heading,
      timestamp: Date.now(),
      speedMPS: 0,
    }

    // Show stabilizing modal
    hideLoadingMessage()
    showStabilizingModal()

    // Start position updates
    startPositionUpdates()
    startHunt()

    // Reset location error count
    locationErrorCount = 0
    isLocationAvailable = true
  } catch (error) {
    console.error("Error setting initial user location:", error)
    handleLocationError(error)
  }
}

function startPositionUpdates() {
  // If already using GeolocationSensor API, don't start again
  if (usingGeolocationSensorAPI) {
    console.log("Position updates already using GeolocationSensor API")
    return
  }

  // Use standard Geolocation API
  locationWatchId = navigator.geolocation.watchPosition(handlePositionUpdate, handleLocationError, {
    enableHighAccuracy: true,
    maximumAge: 1000,
    timeout: 10000,
  })
  console.log("Position updates using standard Geolocation API")
}

function handlePositionUpdate(position) {
  if (!position?.coords?.latitude || !position?.coords?.longitude) {
    console.warn("Invalid position data received")
    return
  }

  // Reset error counters on successful update
  locationErrorCount = 0
  isLocationAvailable = true

  // Update GPS confidence score
  if (position.coords.accuracy) {
    const newScore = calculateGpsConfidenceScore(position.coords.accuracy)
    confidenceScoreHistory.push(newScore)

    // Keep history at reasonable size
    while (confidenceScoreHistory.length > 5) {
      confidenceScoreHistory.shift()
    }

    // Calculate average confidence score
    gpsConfidenceScore = confidenceScoreHistory.reduce((sum, score) => sum + score, 0) / confidenceScoreHistory.length
  }

  updateUserLocation(position)
}

function handleVisibilityChange() {
  if (document.hidden) {
    lastHiddenTime = Date.now()
    lastKnownPosition = userMarker ? userMarker.getLatLng() : null

    // Cancel any active interpolation
    if (positionInterpolator) {
      positionInterpolator.cancel()
    }

    // Cancel animation frame
    if (animationFrameId) {
      cancelAnimationFrame(animationFrameId)
      animationFrameId = null
    }

    // Stop GeolocationSensor if using it
    if (usingGeolocationSensorAPI && geolocationSensor) {
      geolocationSensor.stop()
    }
  } else {
    const hiddenDuration = Date.now() - lastHiddenTime
    if (hiddenDuration > BACKGROUND_THRESHOLD) {
      updateLocationAfterBackground()
    } else {
      map.invalidateSize()

      // Restart animation loop
      if (!animationFrameId) {
        startAnimationLoop()
      }

      // Restart GeolocationSensor if using it
      if (usingGeolocationSensorAPI && geolocationSensor) {
        geolocationSensor.start()
      }

      // If returning from exhibit, ensure movement resumes properly
      if (isReturningFromExhibit) {
        isReturningFromExhibit = false
        // Force a position update to resume tracking
        if (lastValidPosition) {
          updateUserLocation(
            {
              coords: {
                latitude: lastValidPosition.lat,
                longitude: lastValidPosition.lng,
                accuracy: lastValidPosition.accuracy,
                heading: lastValidPosition.heading,
                speed: lastValidPosition.speedMPS,
              },
              timestamp: Date.now(),
            },
            true,
          )
        }
      }
    }
  }
  resetInactivityTimer()
}

function updateLocationAfterBackground() {
  if ("geolocation" in navigator) {
    navigator.geolocation.getCurrentPosition(
      (position) => {
        console.log("Background update raw position:", JSON.stringify(position))
        if (!position || !position.coords) {
          console.warn("Invalid position object in background update")
          return
        }
        const { latitude, longitude, accuracy } = position.coords
        if (isNaN(latitude) || isNaN(longitude)) {
          console.warn("Invalid coordinates in background update:", { latitude, longitude })
          return
        }

        console.log("Valid background position update:", { lat: latitude, lng: longitude })
        try {
          updateUserLocation(position, true)
        } catch (error) {
          console.error("Error in updateUserLocation during background update:", error)
        }

        // Reset tracking variables
        lastPosition = null
        positionBuffer = []
        velocity = { lat: 0, lng: 0 }
        lastVelocity = { lat: 0, lng: 0 }
        isStationary = false
        stationaryStartTime = null
        stationaryCount = 0
        stationaryPositionHistory = []
        lastStationaryPosition = null
        stationaryPositionLocked = false
        positionHistory = []
        suddenMovementCount = 0
        isJumpDetected = false

        // Reset Kalman filter
        kalmanFilter.reset({
          lat: latitude,
          lng: longitude,
          accuracy: accuracy,
          heading: position.coords.heading,
          timestamp: Date.now(),
        })

        // Restart animation loop
        if (!animationFrameId) {
          startAnimationLoop()
        }

        // Restart GeolocationSensor if using it
        if (usingGeolocationSensorAPI && geolocationSensor) {
          geolocationSensor.start()
        }

        updateDistanceBox()
        followUser = true
        map.invalidateSize()
      },
      (error) => {
        console.error("Error getting location after background:", error)
        handleLocationError(error)
      },
      {
        enableHighAccuracy: true,
        timeout: 10000,
        maximumAge: 0,
      },
    )
  } else {
    console.warn("Geolocation is not available")
    showErrorMessage("Unable to update your location after background. Please reload the app.")
  }
}

// Helper function to validate position data
function isValidPosition(pos) {
  return (
    pos &&
    typeof pos.lat === "number" &&
    !isNaN(pos.lat) &&
    typeof pos.lng === "number" &&
    !isNaN(pos.lng) &&
    typeof pos.accuracy === "number" &&
    !isNaN(pos.accuracy)
  )
}

// Calculate distance between two points using Haversine formula
function calculateDistance(pos1, pos2) {
  if (
    !pos1 ||
    !pos2 ||
    typeof pos1.lat !== "number" ||
    typeof pos1.lng !== "number" ||
    typeof pos2.lat !== "number" ||
    typeof pos2.lng !== "number"
  ) {
    return Number.POSITIVE_INFINITY
  }

  const R = 6371000 // Earth's radius in meters
  const lat1 = (pos1.lat * Math.PI) / 180
  const lat2 = (pos2.lat * Math.PI) / 180
  const deltaLat = ((pos2.lat - pos1.lat) * Math.PI) / 180
  const deltaLng = ((pos2.lng - pos1.lng) * Math.PI) / 180

  const a =
    Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) +
    Math.cos(lat1) * Math.cos(lat2) * Math.sin(deltaLng / 2) * Math.sin(deltaLng / 2)
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))

  return R * c
}

// Linear interpolation helper
function lerp(a, b, t) {
  if (typeof a !== "number" || typeof b !== "number" || typeof t !== "number") {
    return a
  }

  return a + (b - a) * Math.max(0, Math.min(1, t))
}

// Update position buffer with new position
function updatePositionBuffer(position) {
  if (!isValidPosition(position)) {
    return
  }

  // Add new position to buffer
  positionBuffer.push({
    lat: position.lat,
    lng: position.lng,
    accuracy: position.accuracy,
    heading: position.heading,
    timestamp: position.timestamp,
    speedMPS: position.speedMPS,
  })

  // Remove old positions if buffer exceeds maxSize
  while (positionBuffer.length > MAX_BUFFER_SIZE) {
    positionBuffer.shift()
  }
}

// Update position history for jump detection
function updatePositionHistory(position) {
  if (!isValidPosition(position)) {
    return
  }

  // Add new position to history
  positionHistory.push({
    lat: position.lat,
    lng: position.lng,
    accuracy: position.accuracy,
    heading: position.heading,
    timestamp: position.timestamp,
    speedMPS: position.speedMPS,
  })

  // Keep only recent positions
  while (positionHistory.length > 10) {
    positionHistory.shift()
  }
}

function initializeFirstPosition(newPosition) {
  lastPosition = newPosition
  lastValidPosition = newPosition
  userMarker.setLatLng([newPosition.lat, newPosition.lng])
  kalmanFilter.reset(newPosition)
  lastUpdateTime = newPosition.timestamp
  stationaryStartTime = newPosition.timestamp
  positionBuffer = [newPosition]
  positionHistory = [newPosition]
  lastStationaryPosition = newPosition
  lastRenderPosition = newPosition

  // Set initial zoom based on stationary state
  const initialZoom = calculateZoomLevel(0)
  map.setView([newPosition.lat, newPosition.lng], initialZoom, { animate: false })
  updateDistanceBox()
}

function handlePositionJump(newPosition) {
  if (isStationary && stationaryPositionLocked) {
    console.log("Position jump detected while stationary, ignoring update")
    isJumpDetected = true
    return
  }
}

function handleLargePositionChange(newPosition) {
  resetStationaryState()
  userMarker.setLatLng([newPosition.lat, newPosition.lng])
  lastPosition = newPosition
  lastValidPosition = newPosition
  lastRenderPosition = newPosition
  positionBuffer = [newPosition]
  positionHistory = [newPosition]
  kalmanFilter.reset(newPosition)
  kalmanFilter.setStationaryMode(false)
  lastVelocity = { lat: 0, lng: 0 }
  lastSmoothedPosition = null

  if (positionInterpolator) {
    positionInterpolator.cancel()
  }

  const zoomLevel = calculateZoomLevel(newPosition.speedMPS)
  map.setView([newPosition.lat, newPosition.lng], zoomLevel, {
    animate: true,
    duration: 0.3,
    noMoveStart: true,
  })

  lastUpdateTime = newPosition.timestamp
  lastUpdateTimestamp = newPosition.timestamp
  updateDistanceBox()

  if (map._container) {
    map._onResize()
  }
}

function resetStationaryState() {
  if (stationaryCheckTimeout) {
    clearTimeout(stationaryCheckTimeout)
    stationaryCheckTimeout = null
  }

  if (stationaryLockTimeout) {
    clearTimeout(stationaryLockTimeout)
    stationaryLockTimeout = null
  }

  isStationary = false
  stationaryStartTime = null
  stationaryCount = 0
  stationaryPositionHistory = []
  lastStationaryPosition = null

  stationaryPositionLocked = false
  isJumpDetected = false
}

function updateStationaryState(newPosition, motionDetected) {
  // Validate input
  if (!newPosition || !lastPosition) return

  // Calculate distance from last position
  const distance = calculateDistance(lastPosition, newPosition)

  // Calculate confidence score for stationary state
  const accuracyScore = Math.max(0, 1 - newPosition.accuracy / MAX_ACCEPTABLE_ACCURACY) // Higher accuracy = higher score
  const motionScore = motionDetected ? 0 : 1 // No motion = higher score
  const historyScore = stationaryPositionHistory.length > 5 ? 1 : 0.5 // More history = higher score

  // Combine scores to get overall confidence
  const stationaryConfidence = (accuracyScore + motionScore + historyScore) / 3

  // Check if the user is likely stationary
  if (distance < MICRO_MOVEMENT_THRESHOLD && stationaryConfidence > 0.8) {
    stationaryCount++

    // Transition to stationary state if confidence is high and threshold is met
    if (!isStationary && stationaryCount >= STATIONARY_THRESHOLD) {
      setStationary(newPosition)
    }
  } else {
    // Decrease stationary count if movement is detected
    stationaryCount = Math.max(0, stationaryCount - 1)

    // Transition to moving state if confidence drops below a threshold
    if (isStationary && stationaryCount < STATIONARY_THRESHOLD / 2) {
      setMoving()
    }
  }

  // Update stationary position history for averaging
  if (isStationary) {
    stationaryPositionHistory.push(newPosition)
    if (stationaryPositionHistory.length > STATIONARY_POSITION_HISTORY_SIZE) {
      stationaryPositionHistory.shift()
    }
  }
}

function setStationary(newPosition) {
  isStationary = true
  console.log("User is now stationary")

  // Enable stationary mode in Kalman filter
  kalmanFilter.setStationaryMode(true)
  stationaryStartTime = newPosition.timestamp

  // Add new position to stationary history
  updateStationaryPositionHistory(newPosition)

  // Calculate stable position using weighted average
  const stablePosition = calculateStationaryWeightedAverage() || newPosition

  if (stablePosition) {
    // Update position queue and state
    positionUpdateQueue.push(stablePosition)
    lastPosition = stablePosition
    lastValidPosition = stablePosition
    lastStationaryPosition = stablePosition

    // Lock the stationary position after a short delay
    stationaryLockTimeout = setTimeout(() => {
      stationaryPositionLocked = true
      stationaryPositionLockTime = Date.now()
      console.log("Stationary position locked after delay")

      // Lock the position in the Kalman filter
      kalmanFilter.lockStationaryPosition(lastStationaryPosition)
    }, 3000) // 3-second delay before locking
  }

  // Schedule the next stationary check
  stationaryCheckTimeout = setTimeout(() => checkStationaryState(newPosition), STATIONARY_CHECK_INTERVAL)

  // Adjust map zoom if following the user
  if (followUser && !isMapInteracting) {
    const stationaryZoom = calculateZoomLevel(0)
    map.setZoom(stationaryZoom, {
      animate: true,
      duration: ZOOM_TRANSITION_DURATION,
    })
  }

  // Update the distance box
  updateDistanceBox()
}

function updateStationaryPositionHistory(newPosition) {
  stationaryPositionHistory.push(newPosition)
  if (stationaryPositionHistory.length > STATIONARY_POSITION_HISTORY_SIZE) {
    stationaryPositionHistory.shift()
  }
}

function calculateStationaryWeightedAverage() {
  if (stationaryPositionHistory.length === 0) return null

  let totalWeight = 0
  let weightedLat = 0
  let weightedLng = 0

  // Calculate weighted average
  stationaryPositionHistory.forEach((pos, index) => {
    const weight = Math.pow(0.8, stationaryPositionHistory.length - index) // Exponential decay
    totalWeight += weight
    weightedLat += pos.lat * weight
    weightedLng += pos.lng * weight
  })

  return {
    lat: weightedLat / totalWeight,
    lng: weightedLng / totalWeight,
    accuracy: stationaryPositionHistory[stationaryPositionHistory.length - 1].accuracy, // Use latest accuracy
    timestamp: Date.now(),
  }
}

function setMoving() {
  isStationary = false
  stationaryPositionLocked = false
  kalmanFilter.setStationaryMode(false)

  if (stationaryLockTimeout) {
    clearTimeout(stationaryLockTimeout)
    stationaryLockTimeout = null
  }

  console.log("User is moving again")
}

function checkStationaryState(newPosition) {
  if (!lastPosition) return

  // Calculate distance between current and last position
  const distance = calculateDistance(lastPosition, newPosition)

  // Check if device motion sensors indicate movement
  const motionDetected = isDeviceInMotion()

  // If significant movement is detected or motion sensors indicate activity
  if (distance >= MICRO_MOVEMENT_THRESHOLD || motionDetected) {
    if (isStationary) {
      console.debug("Movement detected, transitioning to moving state")
      setMoving()
    }

    // Clear the stationary check timeout
    if (stationaryCheckTimeout) {
      clearTimeout(stationaryCheckTimeout)
      stationaryCheckTimeout = null
    }
  } else {
    // If no significant movement, increment stationary count
    stationaryCount++

    // If stationary count exceeds threshold, transition to stationary state
    if (!isStationary && stationaryCount >= STATIONARY_THRESHOLD) {
      setStationary(newPosition)
    }

    // Schedule the next stationary check
    if (isStationary && !stationaryCheckTimeout) {
      stationaryCheckTimeout = setTimeout(() => {
        stationaryCheckTimeout = null
        checkStationaryState(newPosition)
      }, STATIONARY_CHECK_INTERVAL)
    }
  }
}

// Predict position based on heading and speed
function predictPositionFromHeading(position, heading, distance) {
  // Input validation
  if (
    !position ||
    typeof heading !== "number" ||
    typeof distance !== "number" ||
    !position.lat ||
    !position.lng ||
    isNaN(heading) ||
    isNaN(distance)
  ) {
    return position
  }

  // Normalize heading to 0-360 range
  heading = ((heading % 360) + 360) % 360

  // Earth's radius in meters
  const R = 6371e3

  // Convert to radians
  const d = distance / R
  const  = (heading * Math.PI) / 180
  const 1 = (position.lat * Math.PI) / 180
  const 1 = (position.lng * Math.PI) / 180

  // Calculate predicted position with error handling
  try {
    const sin1 = Math.sin(1)
    const cos1 = Math.cos(1)
    const cosd = Math.cos(d)
    const sind = Math.sin(d)
    const cos = Math.cos()

    const 2 = Math.asin(sin1 * cosd + cos1 * sind * cos)

    const 2 = 1 + Math.atan2(Math.sin() * sind * cos1, cosd - sin1 * Math.sin(2))

    // Convert back to degrees with bounds checking
    const newLat = Math.max(-90, Math.min(90, (2 * 180) / Math.PI))
    const newLng = (((2 * 180) / Math.PI + 540) % 360) - 180

    return {
      lat: newLat,
      lng: newLng,
    }
  } catch (error) {
    // Fallback to original position if calculation fails
    return position
  }
}

function checkGeofence(locationPos, locationName) {
  const distance = calculateDistance(userMarker.getLatLng(), locationPos) // Distance in meters
  const notification = document.getElementById("approachNotification")

  if (distance <= GEOFENCE_RADIUS_METERS) {
    // Compare in meters
    if (!notification) {
      showApproachNotification(locationName)
    }
  } else if (notification) {
    // Remove notification if user moves out of the radius
    document.body.removeChild(notification)
  }
}

function showApproachNotification(locationName) {
  // Check if a notification is already shown
  if (document.getElementById("approachNotification")) return

  // Create notification element
  const notification = document.createElement("div")
  notification.id = "approachNotification"
  notification.style.cssText = `
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background-color: white;
        padding: 15px;
        border-radius: 10px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        display: flex;
        align-items: center;
        gap: 10px;
        z-index: 1000;
    `

  // Add message
  const message = document.createElement("span")
  message.textContent = `You are approaching "${locationName}".`
  notification.appendChild(message)

  // Add "Continue" button
  const continueButton = document.createElement("button")
  continueButton.textContent = "Continue"
  continueButton.style.cssText = `
        padding: 5px 10px;
        background-color: #0f2bab;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
    `
  continueButton.onclick = () => {
    document.body.removeChild(notification)
  }
  notification.appendChild(continueButton)

  // Add notification to the DOM
  document.body.appendChild(notification)
}

// OPTIMIZED: Update user location with speed-adaptive parameters
function updateUserLocation(position, forceUpdate = false) {
  // Validate input position
  if (!position?.coords?.latitude || !position?.coords?.longitude) {
    console.warn("Invalid position data received")
    return
  }

  const currentTime = Date.now()
  const timeDelta = lastUpdateTime ? (currentTime - lastUpdateTime) / 1000 : 0

  // Create position object
  const newPosition = {
    lat: position.coords.latitude,
    lng: position.coords.longitude,
    accuracy: position.coords.accuracy || 20,
    heading: position.coords.heading !== null ? position.coords.heading : lastHeadingValue || undefined,
    timestamp: currentTime,
    speedMPS: position.coords.speed !== null ? position.coords.speed : 0,
  }

  // First position initialization
  if (!lastPosition) {
    initializeFirstPosition(newPosition)
    return
  }

  // Calculate distance from last position
  const distance = calculateDistance(lastPosition, newPosition)

  // Check for sudden movements or position jumps
  if (!forceUpdate && detectSuddenMovement(newPosition, lastPosition)) {
    handlePositionJump(newPosition)
    return
  }

  // Handle large position changes or forced updates
  if (distance > EXTENDED_DISTANCE_THRESHOLD || forceUpdate) {
    handleLargePositionChange(newPosition)
    return
  }

  // Skip updates with poor accuracy or unrealistic movement
  if (
    !forceUpdate &&
    (newPosition.accuracy > MAX_ACCEPTABLE_ACCURACY || (timeDelta > 0 && distance / timeDelta > 50))
  ) {
    console.log("Skipping update due to poor accuracy or unrealistic movement")
    return
  }

  try {
    // Check if device is in motion based on motion sensors
    const motionDetected = deviceMotion && isDeviceInMotion()

    // Update stationary state
    updateStationaryState(newPosition, motionDetected)

    // If stationary and position is locked, skip updates
    if (isStationary && stationaryPositionLocked && lastStationaryPosition) {
      updateDistanceBox()
      return
    }

    // Apply Kalman filter with motion detection
    const filteredPosition = kalmanFilter.update(newPosition, motionDetected)

    // Update position buffer and history
    updatePositionBuffer(filteredPosition)
    updateStationaryPositionHistory(filteredPosition) // Use stationary-specific history

    // Determine final position based on movement state
    let finalPosition

    // Get speed tier for adaptive parameters
    const speedParams = getSpeedAdaptiveParameters(filteredPosition.speedMPS)

    if (isStationary) {
      // When stationary, use the stable position with minimal updates
      if (lastStationaryPosition) {
        // Only update if accuracy significantly improves
        if (newPosition.accuracy < lastStationaryPosition.accuracy * 0.8) {
          // Calculate new stable position using weighted average
          const stablePosition = calculateStationaryWeightedAverage()
          if (stablePosition) {
            // Smooth transition to new stable position
            finalPosition = {
              lat: lerp(lastStationaryPosition.lat, stablePosition.lat, 0.01), // Reduced to minimize jitter
              lng: lerp(lastStationaryPosition.lng, stablePosition.lng, 0.01), // Reduced to minimize jitter
              accuracy: stablePosition.accuracy,
              heading: stablePosition.heading,
              timestamp: currentTime,
              speedMPS: 0,
            }

            // Add to position update queue
            positionUpdateQueue.push(finalPosition)
            lastPosition = finalPosition
            lastValidPosition = finalPosition
            lastStationaryPosition = finalPosition
          } else {
            finalPosition = lastStationaryPosition
          }
        } else {
          // Use existing stable position
          finalPosition = lastStationaryPosition
        }
      } else {
        // If no stable position yet, calculate one using weighted average
        const stablePosition = calculateStationaryWeightedAverage()
        if (stablePosition) {
          finalPosition = stablePosition
          lastStationaryPosition = stablePosition
          lastValidPosition = stablePosition

          // Add to position update queue
          positionUpdateQueue.push(finalPosition)
        } else {
          finalPosition = filteredPosition
          lastValidPosition = filteredPosition

          // Add to position update queue
          positionUpdateQueue.push(finalPosition)
        }
        lastPosition = finalPosition
      }
    } else {
      // Smooth movement when active
      finalPosition = filteredPosition
      lastValidPosition = filteredPosition

      // Apply heading-based prediction for smoother movement
      if (finalPosition.heading !== undefined && finalPosition.speedMPS > 0.5) {
        // Use Kalman velocity prediction for higher speeds
        if (speedParams.tier === "Running" || speedParams.tier === "Driving") {
          // Use Kalman filter's velocity for prediction
          const predictedPosition = predictPositionFromHeading(
            finalPosition,
            finalPosition.heading,
            finalPosition.speedMPS * 0.5, // Predict further ahead at higher speeds
          )

          // Blend predicted and filtered positions
          finalPosition = {
            lat: lerp(finalPosition.lat, predictedPosition.lat, 0.3), // More weight to prediction
            lng: lerp(finalPosition.lng, predictedPosition.lng, 0.3),
            accuracy: finalPosition.accuracy,
            heading: finalPosition.heading,
            timestamp: currentTime,
            speedMPS: finalPosition.speedMPS,
          }
        } else {
          // Standard prediction for walking speeds
          const predictedPosition = predictPositionFromHeading(
            finalPosition,
            finalPosition.heading,
            finalPosition.speedMPS * 0.3, // Predict slightly ahead
          )

          // Blend predicted and filtered positions
          finalPosition = {
            lat: lerp(finalPosition.lat, predictedPosition.lat, 0.2),
            lng: lerp(finalPosition.lng, predictedPosition.lng, 0.2),
            accuracy: finalPosition.accuracy,
            heading: finalPosition.heading,
            timestamp: currentTime,
            speedMPS: finalPosition.speedMPS,
          }
        }
      }

      // Add to position update queue
      positionUpdateQueue.push(finalPosition)
      lastPosition = finalPosition
    }

    lastUpdateTime = currentTime
    lastUpdateTimestamp = currentTime

    // Update distance box (existing functionality)
    updateDistanceBox()

    // Check geofence for all locations
    gameLocations.forEach((location) => {
      const locationPos = { lat: location.lat, lng: location.lng }
      checkGeofence(locationPos, location.name)
    })
  } catch (error) {
    console.error("Location update error:", error)
    // Fallback with basic filtering
    userMarker.setLatLng([newPosition.lat, newPosition.lng])
    lastPosition = newPosition
    lastValidPosition = newPosition
    lastRenderPosition = newPosition
    updateDistanceBox()
  }
}

// OPTIMIZED: Check if marker is near edge of map with dynamic thresholds
function isMarkerNearEdge(map, marker, customThreshold = null) {
  if (!map || !marker) return { isNearEdge: false }

  const bounds = map.getBounds()
  const point = marker.getLatLng()
  const proximities = calculateEdgeProximity(map, point)

  // Use custom threshold if provided, otherwise use dynamic threshold
  const thresholdPercentage = customThreshold || dynamicEdgeThreshold

  const edges = {
    north: proximities.north < thresholdPercentage,
    south: proximities.south < thresholdPercentage,
    east: proximities.east < thresholdPercentage,
    west: proximities.west < thresholdPercentage,
  }

  return {
    isNearEdge: Object.values(edges).some((edge) => edge),
    edges: edges,
    proximities: proximities,
  }
}

// Calculate proximity to map edges
function calculateEdgeProximity(map, point) {
  const bounds = map.getBounds()
  const latSpan = bounds.getNorth() - bounds.getSouth()
  const lngSpan = bounds.getEast() - bounds.getWest()

  return {
    north: Math.abs(point.lat - bounds.getNorth()) / latSpan,
    south: Math.abs(point.lat - bounds.getSouth()) / latSpan,
    east: Math.abs(point.lng - bounds.getEast()) / lngSpan,
    west: Math.abs(point.lng - bounds.getWest()) / lngSpan,
  }
}

// OPTIMIZED: Determine if map should recenter with dynamic thresholds
function shouldRecenter(map, marker, customThreshold = null) {
  const now = Date.now()
  if (now - lastRecenterTime < RECENTER_COOLDOWN) {
    return { needsRecenter: false }
  }

  // Skip if user is manually zooming
  if (isUserZooming) {
    return { needsRecenter: false }
  }

  if (!map || !marker) return { needsRecenter: false }

  const edgeInfo = isMarkerNearEdge(map, marker, customThreshold)
  const proximities = edgeInfo.proximities

  // Check for critical edge proximity (very close to edge)
  const isCritical = Object.values(proximities).some((proximity) => proximity < CRITICAL_EDGE_THRESHOLD)

  if (isCritical) {
    lastRecenterTime = now
    return {
      needsRecenter: true,
      isEmergency: true,
      edgeInfo: edgeInfo,
    }
  }

  // Check for normal edge proximity
  if (edgeInfo.isNearEdge) {
    lastRecenterTime = now
    return {
      needsRecenter: true,
      isEmergency: false,
      edgeInfo: edgeInfo,
    }
  }

  return {
    needsRecenter: false,
    isEmergency: false,
    edgeInfo: edgeInfo,
  }
}

// OPTIMIZED: Calculate optimal center point based on speed and edge proximity
function calculateOptimalCenter(map, markerPosition, edgeInfo) {
  const bounds = map.getBounds()

  // Calculate offsets based on which edges are being approached
  let latOffset = 0
  let lngOffset = 0

  // Apply stronger offset for the closest edge
  const proximities = edgeInfo.proximities
  const edges = edgeInfo.edges

  // Get viewport dimensions
  const viewportWidth = mapViewportWidth || map._container.clientWidth
  const viewportHeight = mapViewportHeight || map._container.clientHeight

  // Calculate aspect ratio to adjust offsets
  const aspectRatio = viewportWidth / viewportHeight

  // Adjust offsets based on viewport dimensions
  const latSpan = bounds.getNorth() - bounds.getSouth()
  const lngSpan = bounds.getEast() - bounds.getWest()

  // Get speed-adaptive parameters
  const speedParams = getSpeedAdaptiveParameters(currentSpeed || 0)

  // Adjust offset based on speed tier - larger offsets for higher speeds
  const speedMultiplier = speedParams.tier === "Driving" ? 0.35 : speedParams.tier === "Running" ? 0.3 : 0.25

  // Calculate offsets with consideration for viewport aspect ratio and speed
  if (edges.north) {
    latOffset = -1 * latSpan * speedMultiplier * (1 / aspectRatio)
  }
  if (edges.south) {
    latOffset = latSpan * speedMultiplier * (1 / aspectRatio)
  }
  if (edges.east) {
    lngOffset = -1 * lngSpan * speedMultiplier * aspectRatio
  }
  if (edges.west) {
    lngOffset = lngSpan * speedMultiplier * aspectRatio
  }

  // Debug log
  console.debug(
    `Optimal center calculation: speed=${currentSpeed}m/s, tier=${speedParams.tier}, multiplier=${speedMultiplier}`,
  )

  return {
    lat: markerPosition.lat + latOffset,
    lng: markerPosition.lng + lngOffset,
  }
}

function updateDistanceBox() {
  // Initial validation
  if (!userMarker || !gameLocations || gameLocations.length === 0) {
    document.getElementById("distanceBox").innerText = "Initializing..."
    return
  }

  // Get user coordinates
  const userLatLng = userMarker.getLatLng()
  let userLat = userLatLng.lat
  let userLng = userLatLng.lng

  // Coordinate validation
  if (!isFinite(userLat) || !isFinite(userLng)) {
    console.warn("Invalid user coordinates:", userLat, userLng)
    document.getElementById("distanceBox").innerText = "Initializing..."
    return
  }

  // Use map center if at origin
  if (userLat === 0 && userLng === 0) {
    const center = map.getCenter()
    userLat = center.lat
    userLng = center.lng
  }

  // Find closest location
  let closestDistance = Number.POSITIVE_INFINITY
  let closestLocation = null
  const userPos = { lat: userLat, lng: userLng }

  for (const location of gameLocations) {
    if (!location || typeof location.lat !== "number" || typeof location.lng !== "number") {
      console.warn("Invalid location data:", location)
      continue
    }

    const locationPos = { lat: location.lat, lng: location.lng }
    const distance = calculateDistance(userPos, locationPos)

    if (isFinite(distance) && distance < closestDistance) {
      closestDistance = distance
      closestLocation = location
    }
  }

  // Validate final distance calculation
  if (!isFinite(closestDistance) || closestDistance === Number.POSITIVE_INFINITY) {
    console.warn("Invalid distance calculation:", closestDistance)
    document.getElementById("distanceBox").innerText = "Initializing..."
    return
  }

  // Calculate and display distance
  const distanceFeet = Math.round(closestDistance * 3.28084)
  const distanceText =
    distanceFeet < 5280 ? `${distanceFeet.toLocaleString()} feet` : `${(distanceFeet / 5280).toFixed(2)} miles`

  document.getElementById("distanceBox").innerText = `Closest Stop: ${distanceText}`

  // Check if we should show location hunt - THIS IS THE CRITICAL PART
  if (distanceFeet <= DISTANCE_THRESHOLD && !isLocationHuntVisible && closestLocation) {
    console.log(`User is within threshold distance (${distanceFeet} feet). Opening location page.`)
    showLocationHunt(closestLocation)
  }
}

// Show error message
function showErrorMessage(message) {
  // Remove any existing error messages
  const existingErrors = document.querySelectorAll(".error-message")
  existingErrors.forEach((error) => {
    if (error.parentNode) {
      error.parentNode.removeChild(error)
    }
  })

  // Create new error message
  const errorMessage = document.createElement("div")
  errorMessage.className = "error-message"
  errorMessage.textContent = message
  document.body.appendChild(errorMessage)

  // Auto-remove after animation completes
  setTimeout(() => {
    if (errorMessage.parentNode) {
      errorMessage.parentNode.removeChild(errorMessage)
    }
  }, 5000)
}

const MAX_RETRIES = 3
const RETRY_DELAY = 1000

function getGeolocationOptions(retryNumber) {
  return {
    enableHighAccuracy: retryNumber < 2,
    timeout: 10000 + retryNumber * 5000,
    maximumAge: retryNumber * 5000,
  }
}

function handleLocationError(error) {
  console.warn("Error getting user location:", error)
  locationErrorCount++

  // Check if we've reached the maximum number of retries
  if (retryCount < MAX_RETRIES) {
    retryCount++
    console.log(`Retrying to get location (Attempt ${retryCount} of ${MAX_RETRIES})`)

    setTimeout(() => {
      navigator.geolocation.getCurrentPosition(
        (position) => {
          console.log("Location retrieved successfully after retry")
          hideLoadingMessage()
          updateUserLocation(position, true)
          retryCount = 0
          locationErrorCount = 0
        },
        handleLocationError,
        getGeolocationOptions(retryCount),
      )
    }, RETRY_DELAY)
    return
  }

  retryCount = 0
  hideLoadingMessage()

  // If we've had multiple errors, mark location as unavailable
  if (locationErrorCount > 3) {
    isLocationAvailable = false
  }

  let errorMessage = "An error occurred while getting your location."
  if (error && error.code) {
    switch (error.code) {
      case PERMISSION_DENIED_ERROR:
        errorMessage = "Please allow access to your location to use this feature."
        permissionDenied = true
        handleLocationPermissionDenied()
        break
      case POSITION_UNAVAILABLE_ERROR:
        errorMessage = "Your location is currently unavailable. Please check your GPS signal and try again."
        showErrorMessage(errorMessage)

        // Update GPS signal indicator
        domUpdateManager.schedule(
          "accuracyIndicator",
          () => {
            const indicator = document.getElementById("accuracyIndicator")
            const dot = indicator.querySelector(".accuracy-dot")
            const text = document.getElementById("accuracyText")

            dot.classList.remove("accuracy-high", "accuracy-medium")
            dot.classList.add("accuracy-low")
            text.textContent = "GPS: Signal Lost"
          },
          TASK_PRIORITIES.LOW,
        )
        break
      case TIMEOUT_ERROR:
        errorMessage = "Getting your location took too long. Please check your GPS signal and try again."
        showErrorMessage(errorMessage)
        break
      default:
        showErrorMessage(errorMessage)
        break
    }
  } else {
    showErrorMessage(errorMessage)
  }

  // Try to continue with last known position if available
  if (lastValidPosition) {
    console.log("Using last valid position due to location error")
    userMarker.setLatLng([lastValidPosition.lat, lastValidPosition.lng])
    updateDistanceBox()
  }
}

function showPopup(title, message, type = "info", callback = null) {
  const popup = document.createElement("div")
  popup.classList.add("popup")
  popup.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: white;
        padding: 20px;
        border-radius: 10px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        z-index: 2000;
        text-align: center;
        max-width: 80%;
    `

  const titleElement = document.createElement("h3")
  titleElement.textContent = title
  titleElement.style.cssText = `
        margin-bottom: 10px;
        font-size: 18px;
        font-weight: bold;
    `

  const messageElement = document.createElement("p")
  messageElement.textContent = message
  messageElement.style.cssText = `
        margin-bottom: 20px;
        font-size: 16px;
    `

  const buttonContainer = document.createElement("div")
  buttonContainer.style.cssText = `
        display: flex;
        justify-content: center;
        gap: 10px;
    `

  const okButton = document.createElement("button")
  okButton.textContent = "OK"
  okButton.style.cssText = `
        padding: 10px 20px;
        background-color: #0f2bab;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
    `

  okButton.addEventListener("click", () => {
    document.body.removeChild(popup)
    if (callback) callback()
  })

  buttonContainer.appendChild(okButton)

  if (type === "info") {
    const cancelButton = document.createElement("button")
    cancelButton.textContent = "Cancel"
    cancelButton.style.cssText = `
            padding: 10px 20px;
            background-color: #ccc;
            color: black;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        `

    cancelButton.addEventListener("click", () => {
      document.body.removeChild(popup)
    })

    buttonContainer.appendChild(cancelButton)
  }

  popup.appendChild(titleElement)
  popup.appendChild(messageElement)
  popup.appendChild(buttonContainer)
  document.body.appendChild(popup)
}

// OPTIMIZED: Recenter map with speed-adaptive parameters
function recenterMap() {
  const recenterButton = document.getElementById("recenterButton")
  recenterButton.style.backgroundColor = "#0f2bab"
  recenterButton.style.color = "white"

  // Force map to center on user marker immediately
  if (userMarker && userMarker.getLatLng()) {
    map.closePopup()

    // Get speed-adaptive parameters
    const speedParams = getSpeedAdaptiveParameters(currentSpeed)

    // Get dynamic zoom level based on current speed
    const dynamicZoom = calculateZoomLevel(currentSpeed)

    // Use flyTo instead of setView for smoother animation
    map.flyTo(userMarker.getLatLng(), dynamicZoom, {
      duration: speedParams.flyToDuration,
    })

    followUser = true

    // Reset user zoom flag since this is an explicit user action
    isUserZooming = false
    if (userZoomCooldownTimer) {
      clearTimeout(userZoomCooldownTimer)
      userZoomCooldownTimer = null
    }

    // Make sure any other code knows the map has been recentered
    if (typeof onMapRecentered === "function") {
      onMapRecentered()
    }

    // Debug log
    console.log(
      `Manual recenter: speed=${currentSpeed}m/s, zoom=${dynamicZoom}, duration=${speedParams.flyToDuration}s`,
    )
  }

  setTimeout(() => {
    recenterButton.style.backgroundColor = "white"
    recenterButton.style.color = "#0f2bab"
  }, 500)
}

function addUIEventListeners() {
  document.getElementById("recenterButton").addEventListener("click", () => {
    recenterMap()
    resetInactivityTimer()
  })
  document.getElementById("returnButton").addEventListener("click", () => {
    returnToIndex()
    resetInactivityTimer()
  })
  document.getElementById("tipsButton").addEventListener("click", () => {
    toggleNavigationTips()
    resetInactivityTimer()
  })
  document.querySelector(".navigation-tips .close-button").addEventListener("click", () => {
    closeNavigationTips()
    resetInactivityTimer()
  })
}

function addMapEventListeners() {
  const startInteraction = () => {
    isMapInteracting = true
    userIsInteracting = true
    followUser = false
    resetInactivityTimer()
  }

  map.on("movestart zoomstart dragstart", startInteraction)
}

function resetInactivityTimer() {
  clearTimeout(window.inactivityTimer)
  window.inactivityTimer = setTimeout(checkInactivity, INACTIVITY_TIMEOUT)
}

function checkInactivity() {
  console.log("Inactivity timer triggered")
  isMapInteracting = false
  userIsInteracting = false

  // Close any open popups
  map.closePopup()
  map.eachLayer((layer) => {
    if (layer.getPopup && layer.getPopup()?.isOpen()) {
      layer.closePopup()
    }
  })

  if (!isMapInteracting && !userIsInteracting) {
    recenterMap()
  }
}

function closeAllPopups() {
  if (map) {
    map.closePopup()
  }
}

let lastVisitTime = 0
const cooldownPeriod = 3 * 60 * 1000

function showLocationHunt(location) {
  const now = performance.now()
  if (location.id === lastVisitedLocationId && now - lastVisitTime < cooldownPeriod) {
    console.log(`Location ${location.id} is on cooldown. Skipping.`)
    return
  }

  lastVisitedLocationId = location.id
  lastVisitTime = now
  isLocationHuntVisible = true

  // Use DOM batch updates for better performance
  domUpdateManager.schedule(
    "locationHunt",
    () => {
      const lochuntContainer = document.querySelector(".lochunt-container")
      lochuntContainer.innerHTML = ""
      lochuntContainer.style.cssText = `
            display: flex;
            flex-direction: column;
            height: 100%;
            overflow: hidden;
            background-color: #fff;
            max-width: 1200px;
            margin: 0 auto;
            box-shadow: 0 2px 20px rgba(0,0,0,0.025);
            will-change: transform;
        `

      // Add transition class
      lochuntContainer.classList.add("location-transition")

      // Trigger reflow to ensure transition works
      void lochuntContainer.offsetWidth

      // Make visible with transition
      lochuntContainer.classList.add("visible")

      const scrollableContent = document.createElement("div")
      scrollableContent.style.cssText = `
            flex: 1;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            scroll-behavior: smooth;
            will-change: scroll-position;
        `

      // Use preloaded image if available
      const locationImage = document.createElement("img")
      if (preloadedImages.has(location.image)) {
        locationImage.src = location.image
      } else {
        locationImage.src = location.image
        // Preload for next time
        const img = new Image()
        img.crossOrigin = "anonymous" // Set crossOrigin for canvas operations
        img.src = location.image
        preloadedImages.set(location.image, img)
      }
      locationImage.alt = location.name
      locationImage.style.cssText = `
            width: 100%;
            height: 45vh;
            object-fit: cover;
            object-position: center;
        `

      scrollableContent.appendChild(locationImage)

      const contentContainer = document.createElement("div")
      contentContainer.classList.add("lochunt-content")
      contentContainer.style.cssText = `
            padding: 24px;
            display: flex;
            flex-direction: column;
            align-items: center;
            max-width: 800px;
            margin: 0 auto;
        `
      const locationInfo = document.createElement("div")
      locationInfo.classList.add("lochunt-info")
      locationInfo.style.cssText = `
            text-align: center;
            width: 100%;
            margin-bottom: 15px;
        `
      const locationName = document.createElement("h1")
      locationName.textContent = location.name
      locationName.style.cssText = `
            font-size: clamp(1.8rem, 4vw, 2.5rem);
            font-weight: 700;
            color: #1a1a1a;
            margin-bottom: 8px;
            line-height: 1.2;
        `
      const locationCity = document.createElement("p")
      locationCity.textContent = `${location.city}`
      locationCity.style.cssText = `
           font-size: clamp(1.1rem, 2vw, 1.3rem);
            color: #ff0000;
            font-weight: 600;
            margin-bottom: 4px;
        `
      const locationCreator = document.createElement("p")
      locationCreator.textContent = `Created by: ${location.creator}`
      locationCreator.style.cssText = `
            font-size: calc(0.9rem + 0.4vw);
            color: #666666;
            font-weight: 500;
        `
      locationInfo.appendChild(locationName)
      locationInfo.appendChild(locationCity)
      locationInfo.appendChild(locationCreator)
      contentContainer.appendChild(locationInfo)
      const audioPlayerContainer = createAudioPlayer(location.audio)
      contentContainer.appendChild(audioPlayerContainer)
      scrollableContent.appendChild(contentContainer)
      lochuntContainer.appendChild(scrollableContent)
      const blueBar = createBlueBar(location)
      blueBar.style.cssText += `
            position: sticky;
            bottom: 0;
            width: 100%;
        `
      lochuntContainer.appendChild(blueBar)

      // Initialize audio player after DOM is updated
      requestAnimationFrame(initAudioPlayer)
    },
    TASK_PRIORITIES.MEDIUM,
  )
}

function createAudioPlayer(audioSrc) {
  const audioPlayerContainer = document.createElement("div")
  audioPlayerContainer.classList.add("audio-player")
  audioPlayerContainer.style.cssText = `
        width: 100%;
        max-width: 400px;
        margin-bottom: 15px;
    `

  const audio = document.createElement("audio")
  audio.id = "locationAudio"

  // Use preloaded audio if available
  if (preloadedAudio.has(audioSrc)) {
    audio.src = audioSrc
  } else {
    audio.src = audioSrc
    // Preload for next time
    const audioPreload = new Audio()
    audioPreload.preload = "auto"
    audioPreload.src = audioSrc
    preloadedAudio.set(audioSrc, audioPreload)
  }

  const audioProgress = document.createElement("div")
  audioProgress.classList.add("audio-progress")
  audioProgress.style.cssText = `
        width: 100%;
        margin-bottom: 15px;
    `

  const progressContainer = document.createElement("div")
  progressContainer.classList.add("progress")
  progressContainer.style.cssText = `
        height: 8px;
        background-color: #e2e8f0;
        border-radius: 4px;
        cursor: pointer;
        margin-bottom: 12px;
        overflow: hidden;
    `

  const progressBar = document.createElement("div")
  progressBar.id = "progressBar"
  progressBar.classList.add("progress-bar")
  progressBar.style.cssText = `
        height: 100%;
        background-color: #ff0000;
        width: 0%;
        transition: width 0.1s linear;
    `

  progressContainer.appendChild(progressBar)
  audioProgress.appendChild(progressContainer)

  const timeInfo = document.createElement("div")
  timeInfo.classList.add("audio-time")
  timeInfo.style.cssText = `
        display: flex;
        justify-content: space-between;
        color: #4a5568;
        font-size: 0.875rem;
        margin-bottom: 16px;
        font-weight: 500;
    `

  const currentTimeSpan = document.createElement("span")
  currentTimeSpan.id = "currentTime"
  currentTimeSpan.textContent = "0:00"

  const durationSpan = document.createElement("span")
  durationSpan.id = "duration"
  durationSpan.textContent = "0:00"

  timeInfo.appendChild(currentTimeSpan)
  timeInfo.appendChild(durationSpan)

  const audioControls = document.createElement("div")
  audioControls.classList.add("audio-controls")
  audioControls.style.cssText = `
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 24px;
    `

  const rewindBtn = createAudioButton("skip-backward", "rewindBtn")
  const playPauseBtn = createAudioButton("play", "playPauseBtn")
  const forwardBtn = createAudioButton("skip-forward", "forwardBtn")

  audioControls.appendChild(rewindBtn)
  audioControls.appendChild(playPauseBtn)
  audioControls.appendChild(forwardBtn)

  audioPlayerContainer.appendChild(audio)
  audioPlayerContainer.appendChild(audioProgress)
  audioPlayerContainer.appendChild(timeInfo)
  audioPlayerContainer.appendChild(audioControls)

  return audioPlayerContainer
}

function createAudioButton(iconName, id) {
  const button = document.createElement("button")
  button.id = id
  button.classList.add("audio-button")
  button.innerHTML = `<i class="bi bi-${iconName}"></i>`
  button.style.cssText = `
background-color: white;
color: #0000ff;
border: 2px solid #0000ff;
border-radius: 50%;
width: 55px;
height: 55px;
display: flex;
align-items: center;
justify-content: center;
cursor: pointer;
transition: all 0.3s ease;
    `

  button.addEventListener("mouseover", () => {
    button.style.backgroundColor = "rgba(0, 0, 255, 0.1)"
  })

  button.addEventListener("mouseout", () => {
    button.style.backgroundColor = "white"
  })

  button.addEventListener("click", () => {
    button.style.backgroundColor = "#0000ff"
    button.style.color = "white"
    button.style.transform = "scale(0.95)"

    setTimeout(() => {
      button.style.backgroundColor = "white"
      button.style.color = "#0000ff"
      button.style.transform = "scale(1)"
    }, 200)
  })

  return button
}

function createBlueBar(location) {
  const blueBar = document.createElement("div")
  blueBar.style.cssText = `
        width: 100%;
        height: 60px;
        background: linear-gradient(to right, #0a1f80, #0f2bab);
        margin-top: auto;
        box-shadow: 0 -2px 10px rgba(0,0,0,0.025);
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0 24px;
        position: sticky;
        bottom: 0;
    `

  const infoButton = document.createElement("button")
  infoButton.innerHTML = '<i class="bi bi-info-circle-fill text-white" style="font-size: 1.5rem; z-index: 2500;"></i>'
  infoButton.classList.add("btn", "btn-sm", "me-2")
  infoButton.onclick = () => {
    if (location && location.imageSource) {
      showPopup("Image Source", location.imageSource)
    } else {
      showPopup("Image Source", "Image source information is not available")
    }
  }

  const feedbackButton = document.createElement("a")
  feedbackButton.href = "mailto:mattreicher@protonmail.com?subject=Feedback"
  feedbackButton.target = "_blank"
  feedbackButton.rel = "noopener noreferrer"
  feedbackButton.innerHTML = '<i class="bi bi-envelope-fill text-white" style="font-size: 1.5rem;"></i>'
  feedbackButton.classList.add("btn", "btn-sm")

  blueBar.appendChild(infoButton)
  blueBar.appendChild(feedbackButton)
  return blueBar
}

// OPTIMIZED: Audio player initialization with throttled updates
function initAudioPlayer() {
  const audio = document.getElementById("locationAudio")
  const playPauseBtn = document.getElementById("playPauseBtn")
  const rewindBtn = document.getElementById("rewindBtn")
  const forwardBtn = document.getElementById("forwardBtn")
  const progressBar = document.getElementById("progressBar")
  const progressContainer = document.querySelector(".progress")
  const currentTimeSpan = document.getElementById("currentTime")
  const durationSpan = document.getElementById("duration")

  if (
    !audio ||
    !playPauseBtn ||
    !rewindBtn ||
    !forwardBtn ||
    !progressBar ||
    !progressContainer ||
    !currentTimeSpan ||
    !durationSpan
  ) {
    console.warn("Audio player elements not found, retrying...")
    requestAnimationFrame(initAudioPlayer)
    return
  }

  // Debounce progress updates to reduce DOM operations
  let lastProgressUpdate = 0
  const PROGRESS_UPDATE_INTERVAL = isLowPerformanceMode ? 500 : 250 // ms - throttle more in low performance mode

  playPauseBtn.addEventListener("click", togglePlay)
  rewindBtn.addEventListener("click", () => seek(-10))
  forwardBtn.addEventListener("click", () => seek(10))

  // Use throttled event listener for timeupdate
  audio.addEventListener("timeupdate", () => {
    const now = Date.now()
    if (now - lastProgressUpdate > PROGRESS_UPDATE_INTERVAL) {
      updateProgress()
      lastProgressUpdate = now
    }
  })

  audio.addEventListener("loadedmetadata", () => {
    updateDuration()
  })

  audio.addEventListener("ended", () => {
    playPauseBtn.innerHTML = '<i class="bi bi-play"></i>'
  })

  // Use passive event listeners for better performance
  progressContainer.addEventListener("click", handleProgressClick, { passive: true })

  function togglePlay() {
    if (audio.paused) {
      audio
        .play()
        .then(() => {
          playPauseBtn.innerHTML = '<i class="bi bi-pause"></i>'
        })
        .catch((error) => {
          console.error("Error playing audio:", error)
          showErrorMessage("Error playing audio. Please try again.")
        })
    } else {
      audio.pause()
      playPauseBtn.innerHTML = '<i class="bi bi-play"></i>'
    }
  }

  function seek(seconds) {
    if (!isFinite(audio.duration)) return

    audio.currentTime = Math.max(0, Math.min(audio.duration, audio.currentTime + seconds))
    updateProgress()
  }

  function updateProgress() {
    if (!isFinite(audio.duration) || audio.duration === 0) return

    const percent = (audio.currentTime / audio.duration) * 100
    progressBar.style.width = `${percent}%`

    currentTimeSpan.textContent = formatTime(audio.currentTime)
  }

  function updateDuration() {
    if (!isFinite(audio.duration)) return

    durationSpan.textContent = formatTime(audio.duration)
  }

  function handleProgressClick(e) {
    if (!isFinite(audio.duration) || audio.duration === 0) return

    const rect = progressContainer.getBoundingClientRect()
    const percent = (e.clientX - rect.left) / rect.width
    audio.currentTime = percent * audio.duration
    updateProgress()
  }

  function formatTime(seconds) {
    if (!isFinite(seconds)) return "0:00"

    const mins = Math.floor(seconds / 60)
    const secs = Math.floor(seconds % 60)
    return `${mins}:${secs < 10 ? "0" : ""}${secs}`
  }
}

function startHunt() {
  // Dummy implementation for testing
  gameLocations = myLocations

  // Preload images and audio
  preloadImages(gameLocations).then(() => {
    console.log("Preloading complete")
  })
}

function returnToIndex() {
  // Close location hunt if open
  if (isLocationHuntVisible) {
    const lochuntContainer = document.querySelector(".lochunt-container")

    // Add transition class for smooth exit
    lochuntContainer.classList.remove("visible")

    // Wait for transition to complete
    setTimeout(() => {
      lochuntContainer.innerHTML = ""
      isLocationHuntVisible = false

      // Stop audio if playing
      const audio = document.getElementById("locationAudio")
      if (audio) {
        audio.pause()
      }

      // Flag that we're returning from exhibit
      isReturningFromExhibit = true

      // Force recenter map
      recenterMap()
    }, 300)
  }
}

function toggleNavigationTips() {
  const tips = document.querySelector(".navigation-tips")
  tips.classList.toggle("visible")
}

function closeNavigationTips() {
  const tips = document.querySelector(".navigation-tips")
  tips.classList.remove("visible")
}

// Initialize map when DOM is loaded
document.addEventListener("DOMContentLoaded", () => {
  initMap()
  addUIEventListeners()
  resetInactivityTimer()
})

// Enhanced edge recenter function with dynamic thresholds
function shouldRecenterWithThreshold(map, marker, thresholdPercentage) {
  const now = Date.now()
  if (now - lastRecenterTime < RECENTER_COOLDOWN) {
    return { needsRecenter: false }
  }

  if (!map || !marker) return { needsRecenter: false }

  // Use dynamic threshold based on viewport size
  const viewportBasedThreshold = Math.min(0.15, 100 / Math.max(300, mapViewportWidth))

  // Use the larger of the two thresholds
  const effectiveThreshold = Math.max(thresholdPercentage, viewportBasedThreshold)

  // Get edge proximity with dynamic threshold
  const edgeInfo = isMarkerNearEdge(map, marker, false, effectiveThreshold)
  const proximities = edgeInfo.proximities

  // Check for critical edge proximity (very close to edge)
  const criticalThreshold = effectiveThreshold * 0.7
  const isCritical = Object.values(proximities).some((proximity) => proximity < criticalThreshold)

  if (isCritical) {
    lastRecenterTime = now
    return {
      needsRecenter: true,
      isEmergency: true,
      edgeInfo: edgeInfo,
    }
  }

  // Check for normal edge proximity
  if (edgeInfo.isNearEdge) {
    lastRecenterTime = now
    return {
      needsRecenter: true,
      isEmergency: false,
      edgeInfo: edgeInfo,
    }
  }

  return {
    needsRecenter: false,
    isEmergency: false,
    edgeInfo: edgeInfo,
  }
}

// Enhanced edge detection with dynamic thresholds
function isMarkerNearEdge(map, marker, isStrict = false, customThreshold = null) {
  if (!map || !marker) return { isNearEdge: false }

  const bounds = map.getBounds()
  const point = marker.getLatLng()
  const proximities = calculateEdgeProximity(map, point)

  // Use custom threshold if provided, otherwise use default or strict threshold
  const thresholdPercentage = customThreshold || (isStrict ? 0.12 : EDGE_THRESHOLD_PERCENTAGE)

  const edges = {
    north: proximities.north < thresholdPercentage,
    south: proximities.south < thresholdPercentage,
    east: proximities.east < thresholdPercentage,
    west: proximities.west < thresholdPercentage,
  }

  return {
    isNearEdge: Object.values(edges).some((edge) => edge),
    edges: edges,
    proximities: proximities,
  }
}

// Enhanced edge recenter with speed-adaptive duration
function performEdgeRecenter(recenterInfo, duration = ZOOM_TRANSITION_DURATION) {
  edgeRecenterInProgress = true

  // Get current position
  const position = userMarker.getLatLng()

  // Calculate appropriate zoom level based on speed
  const dynamicZoom = calculateZoomLevel(lastPosition?.speedMPS || 0)

  // Calculate optimal center point that keeps the user icon away from edges
  const optimalCenter = calculateOptimalCenter(map, position, recenterInfo.edgeInfo)

  // Use speed-adaptive duration - faster transitions at higher speeds
  const adaptiveDuration = recenterInfo.isEmergency ? 0.2 : duration

  // Set view with animation
  map.setView([optimalCenter.lat, optimalCenter.lng], dynamicZoom, {
    animate: true,
    duration: adaptiveDuration,
    noMoveStart: true,
    easeLinearity: 0.5,
  })

  // Reset edge recenter flag after animation completes
  setTimeout(
    () => {
      edgeRecenterInProgress = false
    },
    recenterInfo.isEmergency ? 300 : adaptiveDuration * 1000,
  )
}

// Optimized DOM update manager with priority queue
const domUpdateManager = {
  updates: new Map(),
  scheduled: false,
  maxUpdates: 100, // Limit the number of updates to prevent memory bloat
  lastFlushTime: 0,
  minFlushInterval: 16, // Minimum time between flushes (ms)

  // Schedule a DOM update with optional priority
  schedule(id, updateFn, priority = 0) {
    // Enforce size limit
    if (this.updates.size >= this.maxUpdates) {
      // If we're at capacity, only accept higher priority updates
      const lowestPriorityItem = this.getLowestPriorityItem()
      if (lowestPriorityItem && lowestPriorityItem.priority < priority) {
        this.updates.delete(lowestPriorityItem.id)
      } else {
        return // Skip this update
      }
    }

    // Store the update with its priority
    this.updates.set(id, { updateFn, priority, id })

    // Schedule a flush if not already scheduled
    if (!this.scheduled) {
      this.scheduled = true

      // Use requestAnimationFrame for better synchronization with rendering
      requestAnimationFrame(() => this.flush())
    }
  },

  // Get the item with the lowest priority
  getLowestPriorityItem() {
    let lowestPriority = Number.POSITIVE_INFINITY
    let lowestItem = null

    this.updates.forEach((item) => {
      if (item.priority < lowestPriority) {
        lowestPriority = item.priority
        lowestItem = item
      }
    })

    return lowestItem
  },

  // Flush all scheduled DOM updates
  flush() {
    const now = performance.now()

    // Throttle flush frequency
    if (now - this.lastFlushTime < this.minFlushInterval) {
      this.scheduled = false

      // Reschedule flush for next frame
      requestAnimationFrame(() => {
        this.scheduled = true
        this.flush()
      })
      return
    }

    this.lastFlushTime = now

    try {
      // Convert updates to an array and sort by priority (higher priority first)
      const sortedUpdates = Array.from(this.updates.values()).sort((a, b) => b.priority - a.priority)

      // Execute updates with batching
      // Start a "batch" of related DOM operations
      if (typeof document.startViewTransition === "function") {
        // Use View Transitions API if available for smoother updates
        document.startViewTransition(() => {
          this.executeUpdates(sortedUpdates)
        })
      } else {
        // Regular execution
        this.executeUpdates(sortedUpdates)
      }
    } catch (error) {
      console.error("Error during DOM update flush:", error)
    } finally {
      // Clear updates and reset state
      this.updates.clear()
      this.scheduled = false
    }
  },

  // Execute updates with budget monitoring
  executeUpdates(updates) {
    const startTime = performance.now()
    const budget = 8 // 8ms budget for DOM updates

    for (let i = 0; i < updates.length; i++) {
      try {
        updates[i].updateFn()

        // Check if we're exceeding our budget
        if (i % 5 === 0 && i > 0) {
          const elapsed = performance.now() - startTime
          if (elapsed > budget) {
            // Schedule remaining updates for next frame
            const remainingUpdates = updates.slice(i + 1)
            if (remainingUpdates.length > 0) {
              remainingUpdates.forEach((update) => {
                this.schedule(update.id, update.updateFn, update.priority)
              })
              break
            }
          }
        }
      } catch (error) {
        console.error("Error executing DOM update:", error)
      }
    }
  },

  // Cancel a scheduled update by ID
  cancel(id) {
    this.updates.delete(id)
  },

  // Clear all pending updates
  clear() {
    this.updates.clear()
    this.scheduled = false
  },
}

// Optimized location proximity check with throttling
function checkLocationProximity() {
  const now = Date.now()

  // Throttle checks more aggressively - reduced from 1000ms to 100ms
  if (now - lastProximityCheck < 1000) return
  lastProximityCheck = now

  // Don't check if zoom was recently changed
  if (now - lastZoomChangeTime < ZOOM_CHANGE_COOLDOWN) return

  if (!userMarker || !gameLocations || gameLocations.length === 0) return

  const userLatLng = userMarker.getLatLng()
  const userPos = { lat: userLatLng.lat, lng: userLatLng.lng }

  // Find closest location - limit to checking only 5 nearest known locations
  // instead of the entire array each time
  let closestDistance = Number.POSITIVE_INFINITY
  let closestLocation = null

  // Sort locations by last known distance (if available)
  const locationsToCheck = gameLocations.slice(0, 5)

  for (const location of locationsToCheck) {
    if (!location || typeof location.lat !== "number" || typeof location.lng !== "number") continue

    const locationPos = { lat: location.lat, lng: location.lng }
    const distance = calculateDistance(userPos, locationPos)

    if (isFinite(distance) && distance < closestDistance) {
      closestDistance = distance
      closestLocation = location
    }
  }

  // Convert to feet for threshold comparison
  const distanceFeet = Math.round(closestDistance * 3.28084)

  // Constants for hysteresis and thresholds
  const HYSTERESIS_FACTOR = 1.1 // 10% buffer to prevent rapid toggling
  const ZOOM_IN_THRESHOLD = PROXIMITY_THRESHOLD * 0.9 // 90% of PROXIMITY_THRESHOLD
  const ZOOM_OUT_THRESHOLD = PROXIMITY_THRESHOLD * 1.1 // 110% of PROXIMITY_THRESHOLD

  // Check if we need to adjust zoom based on proximity
  if (distanceFeet <= ZOOM_IN_THRESHOLD) {
    // If we weren't near a location before, zoom in
    if (!isNearLocation && Math.abs(lastProximityDistance - closestDistance) > 1) {
      console.log(`User is now within ${ZOOM_IN_THRESHOLD.toFixed(1)} feet of a location, zooming in`)
      isNearLocation = true
      lastZoomChangeTime = now

      // Calculate new zoom level (clamped to MAX_ZOOM_LEVEL)
      const currentZoom = map.getZoom()
      const newZoom = Math.min(currentZoom + 1, MAX_ZOOM_LEVEL)

      // Apply zoom change with smooth animation
      map.setZoom(newZoom, {
        animate: true,
        duration: ZOOM_TRANSITION_DURATION,
      })
    }
  } else if (distanceFeet >= ZOOM_OUT_THRESHOLD && isNearLocation) {
    // If we were near a location but now we're not, zoom out
    console.log(`User is now outside ${ZOOM_OUT_THRESHOLD.toFixed(1)} feet of a location, zooming out`)
    isNearLocation = false
    lastZoomChangeTime = now

    // Calculate new zoom level (clamped to MIN_ZOOM_LEVEL)
    const currentZoom = map.getZoom()
    const newZoom = Math.max(currentZoom - 1, MIN_ZOOM_LEVEL)

    // Apply zoom change with smooth animation
    map.setZoom(newZoom, {
      animate: true,
      duration: ZOOM_TRANSITION_DURATION,
    })
  }

  // Update last proximity distance
  lastProximityDistance = closestDistance
}

// Optimized GPS signal indicator update with reduced frequency
function updateGpsSignalIndicator() {
    const now = Date.now();
    
    // Reduce update frequency from 3000ms to 5000ms
    if (now - lastAccuracyUpdate < 5000) {
        return;
    }
    
    lastAccuracyUpdate = now;
    
    // Get current position accuracy
    let accuracy = 0;
    let signalText = '';
    let signalClass = '';
    
    if (lastPosition && typeof lastPosition.accuracy === 'number') {
        accuracy = lastPosition.accuracy;
        
        // Update confidence score history
        confidenceScoreHistory.push(calculateGpsConfidenceScore(accuracy));
        
        // Keep history at reasonable size
        while (confidenceScoreHistory.length > 5) {
            confidenceScoreHistory.shift();
        }
        
        // Calculate average confidence score
        gpsConfidenceScore = confidenceScoreHistory.reduce((sum, score) => sum + score, 0) / 
                            confidenceScoreHistory.length;
        
        // Determine signal quality
        if (accuracy <= GPS_CONFIDENCE_THRESHOLD_HIGH) {
            signalText = '';
            signalClass = 'accuracy-high';
        } else if (accuracy <= GPS_CONFIDENCE_THRESHOLD_MEDIUM) {
            signalText = '';
            signalClass = 'accuracy-medium';
        } else {
            signalText = '';
            signalClass = 'accuracy-low';
        }
    </script>
</body>
</html>
