<!DOCTYPE html>
<html lang="en">
<head> 
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Minnesota Then | Museum Without Walls</title>
    <link rel="shortcut icon" type="image/x-icon" href="https://www.mnthen.com/images/mnthenfav.ico">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css">
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css" />
    <link rel="stylesheet" href="https://www.mnthen.com/css/mainmap.css">
    <style>
        .user-marker-icon {
            width: 20px;
            height: 20px;
            background-color: #ff0000; /* Red user icon */
            border: 3px solid white;
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            position: relative;
            transition: transform 0.3s cubic-bezier(0.25, 0.1, 0.25, 1);
            will-change: transform;
        }
        
        .user-marker-icon::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 30px;
            height: 30px;
            background-color: rgba(255, 0, 0, 0.2); /* Red with opacity */
            border-radius: 50%;
            transform: translate(-50%, -50%);
            animation: pulse 2s infinite;
            will-change: transform, opacity;
        }
        
        @keyframes pulse {
            0% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
            100% {
                transform: translate(-50%, -50%) scale(2);
                opacity: 0;
            }
        }
        
        .stabilizing-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            z-index: 2000;
            text-align: center;
            max-width: 80%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .stabilizing-modal h3 {
            margin-bottom: 15px;
            color: #ff0000; /* Red */
        }
        
        .stabilizing-modal p {
            margin-bottom: 20px;
        }
        
        .stabilizing-modal .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255, 0, 0, 0.2); /* Red with opacity */
            border-top: 4px solid #ff0000; /* Red */
            border-radius: 50%;
            margin-bottom: 20px;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Preloader styles */
        #preloader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }

        #preloader .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(255, 0, 0, 0.2);
            border-top: 5px solid #ff0000;
            border-radius: 50%;
            margin-bottom: 20px;
            animation: spin 1s linear infinite;
        }

        #preloader p {
            font-size: 18px;
            color: #333;
            margin-top: 15px;
        }

        #preloader .progress-container {
            width: 80%;
            max-width: 300px;
            height: 10px;
            background-color: #f0f0f0;
            border-radius: 5px;
            margin-top: 15px;
            overflow: hidden;
        }

        #preloader .progress-bar {
            height: 100%;
            background-color: #ff0000;
            width: 0%;
            transition: width 0.3s ease;
        }

        /* Dark blue color for summary elements */
        .summary-heading {
            color: #0f2bab !important;
        }

        .summary-button {
            background-color: #0f2bab !important;
        }

        .summary-button:hover {
            background-color: #0a1f80 !important;
        }
        
        /* Optimize for hardware acceleration */
        #map, .user-marker-icon, .lochunt-container, .additional-info-container {
            transform: translateZ(0);
            backface-visibility: hidden;
            perspective: 1000px;
        }
        
        /* Stationary indicator - removed green glow and modified for consistent appearance */
        .user-marker-stationary .user-marker-icon {
            /* Keep the same red color and white border */
            border-color: white;
        }
        
        .user-marker-stationary .user-marker-icon::after {
            /* Keep the same red pulse effect */
            background-color: rgba(255, 0, 0, 0.2);
            animation: pulse 2s infinite;
        }
        
        /* Center the "Did you know?" modal */
        .additional-info-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            z-index: 2000;
            text-align: center;
            max-width: 80%;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            display: none;
        }
        
/* Green route button and dark blue summary button */
.button.route-button {
    background-color: #1b5e20 !important; /* Dark green color */
    color: white !important;
    border: none !important;
    padding: 8px 15px !important;
    border-radius: 0px !important;
    cursor: pointer !important;
    font-weight: 500 !important;
    transition: background-color 0.3s ease !important;
}

.button.summary-button {
    background-color: #0f2bab !important; /* Dark blue color */
    color: white !important;
    border: none !important;
    padding: 8px 15px !important;
    border-radius: 0px !important;
    cursor: pointer !important;
    font-weight: 500 !important;
    transition: background-color 0.3s ease !important;
}

.button.route-button:hover {
    background-color: #0d3c12 !important; /* Darker green on hover */
}

.button.summary-button:hover {
    background-color: #0a1f80 !important; /* Darker blue on hover */
}
        
        .custom-popup .popup-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
        }

        /* Error message styles */
        .error-message {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(255, 59, 48, 0.9);
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 2500;
            max-width: 90%;
            text-align: center;
            font-weight: 500;
            animation: fadeInOut 5s forwards;
            pointer-events: none;
        }

        @keyframes fadeInOut {
            0% { opacity: 0; transform: translate(-50%, -20px); }
            10% { opacity: 1; transform: translate(-50%, 0); }
            90% { opacity: 1; transform: translate(-50%, 0); }
            100% { opacity: 0; transform: translate(-50%, -20px); }
        }

        /* Location transition styles */
        .location-transition {
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .location-transition.visible {
            opacity: 1;
        }

/* Confidence indicator styles */
#accuracyIndicator {
    position: fixed;
    top: 10px;
    left: 10px;
    background-color: rgba(255, 255, 255, 0.8);
    padding: 5px 10px;
    border-radius: 15px;
    font-size: 12px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    z-index: 1000;
    display: flex;
    align-items: center;
    pointer-events: none;
}
.accuracy-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    margin-right: 5px;
}
.accuracy-high {
    background-color: #4CD964; /* Green */
}
.accuracy-medium {
    background-color: #FFCC00; /* Yellow */
}
.accuracy-low {
    background-color: #FF3B30; /* Red */
}
    </style>
</head>
<body>
    <!-- Preloader -->
    <div id="preloader">
        <div class="spinner"></div>
        <p>Loading Minnesota Then...</p>
        <div class="progress-container">
            <div class="progress-bar" id="preloaderProgress"></div>
        </div>
    </div>

    <div id="map"></div>
    <div id="distanceBox">Initializing...</div>
    <div id="networkStatus" title="Network Status"></div>
    <div id="accuracyIndicator"><span class="accuracy-dot accuracy-medium"></span><span id="accuracyText">GPS Signal</span></div>

    <div class="lochunt-container location-transition">
        <img id="locationImage" src="" alt="Location Image">
        <div class="lochunt-content">
            <div class="lochunt-info">
                <h2 id="locationTitle" class="mb-2 text-primary"></h2>
                <p id="locationCity" class="text-muted mb-1"></p>
                <p id="locationCreator" class="text-muted mb-3"></p>
            </div>
            <div class="audio-player">
                <div class="audio-progress">
                    <div class="progress">
                        <div id="progressBar" class="progress-bar" role="progressbar" style="width: 0%"></div>
                    </div>
                </div>
                <div class="audio-time">
                    <span id="currentTime">0:00</span>
                    <span id="duration">0:00</span>
                </div>
                <div class="audio-controls">
                    <button id="rewindBtn" class="audio-button"><i class="fas fa-backward"></i></button>
                    <button id="playPauseBtn" class="audio-button"><i class="fas fa-play"></i></button>
                    <button id="forwardBtn" class="audio-button"><i class="fas fa-forward"></i></button>
                </div>
                <audio id="locationAudio" src=""></audio>
            </div>
        </div>
    </div>
    
    <div class="additional-info-container location-transition">
       <h3 class="mb-3 text-primary text-center">Did You Know?</h3>
       <p id="additionalInfo" class="mb-3 fs-6"></p>
       <div class="d-flex justify-content-center">
           <button id="continueButton" class="btn btn-primary">Continue</button>
       </div>
    </div>
    
    <div class="map-buttons">
        <button id="recenterButton" class="map-button"><i class="fas fa-crosshairs"></i></button>
        <button id="returnButton" class="map-button"><i class="fas fa-sign-out-alt"></i></button>
        <button id="tipsButton" class="map-button"><i class="fas fa-question-circle"></i></button>
    </div>

    <div class="navigation-tips">
        <button class="close-button">&times;</button>
        <h3>Navigation Tips</h3>
        <ul>
            <li>Use the map to navigate to the marked locations.</li>
            <li>The distance box shows how far you are from the current location.</li>
            <li>Tap the recenter button to focus on your current position.</li>
            <li>When you're within 20 feet of a location, you'll be able to interact with it.</li>
            <li>Listen to the audio information for each location.</li>
            <li>After the audio, you'll see additional information about the location.</li>
        </ul>
    </div>

    <div id="summaryModal" class="modal" style="display: none;">
        <div class="modal-content">
            <p id="summaryContent"></p>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"></script>
    <script src="/locations_test.js?v=1.0.4"></script>
 
    <script>
// Global variables
let map, userMarker, markerClusterGroup
let currentLocationIndex = 0
const visitedLocations = []
let gameLocations = []
let inactivityTimer
let isLocationHuntVisible = false
let lastPosition = null
let positionBuffer = []
const MAX_BUFFER_SIZE = 20 // Increased buffer size for smoother tracking
const DISTANCE_THRESHOLD = 20 // 20 feet threshold for opening location page

const PROXIMITY_THRESHOLD = 40 // 40 feet threshold for zoom changes
let velocity = { lat: 0, lng: 0 }
let isMapInteracting = false
let followUser = true
let locationCooldowns = {}
let userIsInteracting = false
const preloadedImages = new Map() // Map to store preloaded images
const preloadedAudio = new Map() // Map to store preloaded audio
let currentSpeed = 0 // Current speed in meters per second
let lastZoomLevel = 18 // Default zoom level
let stationaryPositionHistory = [] // Array to store stationary positions for averaging
let deviceOrientation = null // Store device orientation data
let deviceMotion = null // Store device motion data
let orientationPermissionGranted = false
let geolocationSensor = null // Store GeolocationSensor instance
let isNearLocation = false // Flag to track if user is near a location
let lastProximityCheck = 0 // Last time proximity was checked
let isReturningFromExhibit = false // Flag to track if returning from exhibit

// Enhanced constants for better stabilization
const MICRO_MOVEMENT_THRESHOLD = 0.5 // Meters - threshold for detecting micro-movements (increased for better stability)
const STATIONARY_ACCURACY_MULTIPLIER = 1.5 // Looser accuracy bounds to prevent false movement detection
const MAX_ACCEPTABLE_ACCURACY = 30 // meters - more lenient accuracy requirement
const STATIONARY_THRESHOLD = 3 // Number of consecutive stationary positions to consider user as stationary (reduced for faster stabilization)
const STATIONARY_TIME_THRESHOLD = 5000 // ms - time to consider user stationary (increased)
const STATIONARY_CHECK_INTERVAL = 2000 // ms - interval to check if still stationary (increased)
const VELOCITY_DECAY = 0.95 // Higher value for smoother velocity transitions
const MIN_DISTANCE_THRESHOLD = 1.5 // meters - minimum distance to consider movement (increased)
const EXTENDED_DISTANCE_THRESHOLD = 80 // meters - distance to consider a significant position change
const UPDATE_INTERVAL = 100 // ms - less frequent updates for more stability
const STATIONARY_POSITION_HISTORY_SIZE = 10 // Number of positions to keep for stationary averaging (reduced)
const STATIONARY_POSITION_WEIGHT_DECAY = 0.95 // Weight decay for older positions in stationary average (increased)
const SUDDEN_MOVEMENT_THRESHOLD = 1.0 // meters - threshold for detecting sudden movements (increased)
const POSITION_JUMP_THRESHOLD = 3.0 // meters - threshold for detecting position jumps (increased)
const ZOOM_CHANGE_COOLDOWN = 2000 // ms - cooldown between zoom changes

// Background handling constants
const BACKGROUND_THRESHOLD = 20000 // ms - time to consider app was in background
const INACTIVITY_TIMEOUT = 39000 // ms - time to consider user inactive (changed to 39 seconds)

// Kalman filter parameters - optimized for better stationary stability
const KALMAN_PROCESS_NOISE = 0.001 // Lower value for smoother tracking
const KALMAN_MEASUREMENT_NOISE_BASE = 2.0 // Higher base measurement noise to reduce jitter
const KALMAN_STATIONARY_NOISE = 0.0005 // Lower noise when stationary (reduced to minimize jitter)

// Animation parameters
const ANIMATION_DURATION = 300 // ms - increased duration of position animation for smoother transitions
const HEADING_SMOOTHING = 0.95 // Increased heading smoothing factor

// Zoom level parameters
const MAX_ZOOM_LEVEL = 18 // Maximum zoom level (stationary)
const MIN_ZOOM_LEVEL = 14 // Minimum zoom level (high speed)
const WALKING_ZOOM_LEVEL = 18 // Zoom level for walking speed
const WALKING_SPEED_THRESHOLD = 1.5 // m/s - threshold for walking speed
const RUNNING_SPEED_THRESHOLD = 4.0 // m/s - threshold for running speed
const DRIVING_SPEED_THRESHOLD = 10.0 // m/s - threshold for driving speed
const ZOOM_TRANSITION_DURATION = 0.8 // seconds - increased duration of zoom transition

// Motion detection parameters
const MOTION_THRESHOLD = 1.0 // Increased threshold for detecting significant motion
const MOTION_SAMPLE_SIZE = 10 // Increased number of motion samples to keep
const MOTION_CHECK_INTERVAL = 300 // ms - increased interval to check motion

// Edge recenter parameters - optimized for better edge recentering
const EDGE_THRESHOLD_PERCENTAGE = 0.15 // Percentage of viewport to trigger recenter (15%)
const CRITICAL_EDGE_THRESHOLD = 0.15 // Critical threshold for emergency recenter (15%)
const RECENTER_COOLDOWN = 500 // ms - reduced minimum time between recenters for more responsive recentering

// Error handling constants
const MAX_LOCATION_RETRIES = 5 // Maximum number of retries for location
const LOCATION_RETRY_DELAY = 2000 // Delay between location retries in ms
const NETWORK_CHECK_INTERVAL = 5000 // Interval to check network status in ms
const GPS_CONFIDENCE_THRESHOLD_HIGH = 10 // meters - high confidence threshold
const GPS_CONFIDENCE_THRESHOLD_MEDIUM = 25 // meters - medium confidence threshold
const GPS_SIGNAL_CHECK_INTERVAL = 3000 // Interval to check GPS signal quality in ms
const PERMISSION_DENIED_ERROR = 1 // Error code for permission denied
const POSITION_UNAVAILABLE_ERROR = 2 // Error code for position unavailable
const TIMEOUT_ERROR = 3 // Error code for timeout
const UNKNOWN_ERROR = 4 // Error code for unknown error

// State variables
let lastUpdateTime = null
let lastVelocity = { lat: 0, lng: 0 }
let isStationary = false
let stationaryStartTime = null
let stationaryCheckTimeout = null
let lastUpdateTimestamp = null
let lastHiddenTime = 0
let lastKnownPosition = null
const isTransitioning = false
let lastVisitedLocationId = null
let stationaryCount = 0
let lastSmoothedPosition = null
const lastRecenterTime = Date.now()
let retryCount = 0
const stationaryBuffer = []
const stationaryPosition = null
let isStabilizing = true // Flag to track initial stabilization
let lastStationaryPosition = null // Last stable position when stationary
const motionSamples = [] // Array to store motion samples
const lastMotionTimestamp = 0 // Last time motion was detected
let deviceStationaryTime = 0 // Time device has been stationary based on motion sensors
let animationFrameId = null // Store requestAnimationFrame ID
let renderTimestamp = null // Last render timestamp
const positionUpdateQueue = [] // Queue for position updates to be processed
let lastHeadingValue = null // Last heading value
const headingBuffer = [] // Buffer for heading values
let isFirstPositionUpdate = true // Flag for first position update
let lastRenderPosition = null // Last rendered position
let positionInterpolator = null // Position interpolator for smooth transitions
let mapViewportWidth = 0 // Store map viewport width
let mapViewportHeight = 0 // Store map viewport height
let lastMapCenter = null // Last map center position
let lastMapZoom = null // Last map zoom level
let edgeRecenterInProgress = false // Flag to track edge recentering
const domUpdateScheduled = false // Flag to track scheduled DOM updates
const pendingDomUpdates = new Map() // Map to store pending DOM updates
let usingGeolocationSensorAPI = false // Flag to track which geolocation API is being used
const lockStationaryPosition = false // Flag to lock stationary position and prevent jitter
let positionHistory = [] // Array to store recent position history for jump detection
const lastPositionTimestamp = 0 // Last time a position was processed
let suddenMovementCount = 0 // Counter for consecutive sudden movements
let isJumpDetected = false // Flag to track if a position jump is detected
let stationaryPositionLocked = false // Flag to indicate if stationary position is locked
let stationaryPositionLockTime = 0 // Time when stationary position was locked
let lastValidPosition = null // Last valid position before a jump
let stationaryLockTimeout = null // Timeout for locking stationary position
const positionStabilityCounter = 0 // Counter for position stability
let lastZoomChangeTime = 0 // Last time zoom was changed due to proximity
let lastProximityDistance = Number.POSITIVE_INFINITY // Last distance to nearest location
let isOnline = navigator.onLine // Track online status
const lastGpsSignalCheck = 0 // Last time GPS signal was checked
let gpsConfidenceScore = 0.5 // GPS confidence score (0-1)
let permissionDenied = false // Flag to track if location permission was denied
let locationErrorCount = 0 // Counter for location errors
let networkErrorCount = 0 // Counter for network errors
let lastNetworkErrorTime = 0 // Last time a network error occurred
let isLocationAvailable = true // Flag to track if location is available
const confidenceScoreHistory = [] // Array to store confidence scores for averaging
const stationaryConfidenceScore = 0 // Confidence score for stationary state (0-1)
const movingConfidenceScore = 0 // Confidence score for moving state (0-1)
const stationaryTransitionState = 0 // Transition state between stationary and moving (0-1)
let lastAccuracyUpdate = 0 // Last time accuracy indicator was updated
let locationWatchId = null // ID for geolocation watch
let permissionRequestInProgress = false // Flag to track if permission request is in progress
let lastPermissionRequest = 0 // Last time permission was requested

// Edge recenter variables
let lastEdgeCheck = 0
const edgeCheckInterval = 500

// Map update throttling variables
let lastMapUpdate = 0
const mapUpdateThrottleInterval = 100

// Dummy locations variable for testing
const myLocations = []

// Dummy onMapRecentered variable for testing
const onMapRecentered = () => {}

// Dummy L variable for testing
const L = window.L

// Dummy GeolocationSensor variable for testing
const GeolocationSensor = window.GeolocationSensor

// Enhanced Kalman Filter implementation
class KalmanFilter {
  constructor() {
    // State variables
    this.x = 0 // Longitude estimate
    this.y = 0 // Latitude estimate
    this.vx = 0 // Longitude velocity
    this.vy = 0 // Latitude velocity

    // Error covariance matrix
    this.P = [
      [100, 0, 0, 0], // Initial high uncertainty
      [0, 100, 0, 0],
      [0, 0, 10, 0],
      [0, 0, 0, 10],
    ]

    // Process noise
    this.Q = KALMAN_PROCESS_NOISE

    // Measurement noise (will be adjusted based on GPS accuracy)
    this.R = KALMAN_MEASUREMENT_NOISE_BASE

    // Time delta
    this.dt = 1.0

    // Initialized flag
    this.initialized = false

    // Heading and accuracy tracking
    this.lastHeading = null
    this.headingConfidence = 0

    // Stationary mode flag
    this.stationaryMode = false

    // Last timestamp
    this.lastTimestamp = null

    // Adaptive noise parameters
    this.adaptiveNoiseMin = 0.0005 // Reduced for better stability
    this.adaptiveNoiseMax = 0.005 // Reduced for better stability
    this.adaptiveNoiseFactor = 1.0

    // Position history for jitter detection
    this.positionHistory = []
    this.maxPositionHistory = 5
    this.jitterThreshold = 0.5 // meters - increased to be more tolerant
    this.jitterCount = 0

    // Stationary lock
    this.stationaryLocked = false
    this.stationaryPosition = null

    // New: Enhanced jitter detection with hysteresis
    this.jitterHysteresis = 0
    this.maxJitterHysteresis = 5
    this.jitterConfidence = 0
  }

  // Initialize the filter with first position
  reset(position) {
    if (!position || typeof position.lat !== "number" || typeof position.lng !== "number") {
      console.error("Invalid position for Kalman filter reset")
      return
    }

    this.x = position.lng
    this.y = position.lat
    this.vx = 0
    this.vy = 0

    // Reset covariance matrix with high initial uncertainty
    this.P = [
      [100, 0, 0, 0],
      [0, 100, 0, 0],
      [0, 0, 10, 0],
      [0, 0, 0, 10],
    ]

    this.initialized = true
    this.lastHeading = position.heading || null
    this.headingConfidence = 0
    this.stationaryMode = false
    this.lastTimestamp = position.timestamp || Date.now()
    this.adaptiveNoiseFactor = 1.0
    this.positionHistory = []
    this.jitterCount = 0
    this.stationaryLocked = false
    this.stationaryPosition = null
    this.jitterHysteresis = 0
    this.jitterConfidence = 0
  }

  // Set stationary mode
  setStationaryMode(isStationary) {
    this.stationaryMode = isStationary

    // When entering stationary mode, reduce velocity to zero
    if (isStationary) {
      this.vx = 0
      this.vy = 0

      // Reduce process noise for stationary mode
      this.Q = KALMAN_STATIONARY_NOISE
      this.adaptiveNoiseFactor = 0.03 // Further reduced for even less jitter in stationary mode
    } else {
      // Reset to normal process noise when moving
      this.Q = KALMAN_PROCESS_NOISE
      this.adaptiveNoiseFactor = 1.0 // Normal noise when moving
      this.stationaryLocked = false
      this.stationaryPosition = null
      this.jitterHysteresis = 0
    }
  }

  // Lock stationary position
  lockStationaryPosition(position) {
    if (!this.stationaryMode) return

    this.stationaryLocked = true
    this.stationaryPosition = position
    console.log("Kalman filter: Stationary position locked")
  }

  // Enhanced jitter detection with hysteresis and confidence scoring
  detectJitter(newPosition) {
    if (this.positionHistory.length === 0) {
      this.positionHistory.push(newPosition)
      return false
    }

    const lastPos = this.positionHistory[this.positionHistory.length - 1]
    const distance = calculateDistance(lastPos, newPosition)

    // Add to history
    this.positionHistory.push(newPosition)
    if (this.positionHistory.length > this.maxPositionHistory) {
      this.positionHistory.shift()
    }

    // Check for rapid back-and-forth movement (jitter)
    if (this.positionHistory.length >= 3 && this.stationaryMode) {
      const pos1 = this.positionHistory[this.positionHistory.length - 3]
      const pos2 = this.positionHistory[this.positionHistory.length - 2]
      const pos3 = this.positionHistory[this.positionHistory.length - 1]

      const dist1 = calculateDistance(pos1, pos2)
      const dist2 = calculateDistance(pos2, pos3)

      // If moving back and forth in small distances
      if (dist1 < this.jitterThreshold && dist2 < this.jitterThreshold) {
        // Check for direction change (sign change in lat/lng differences)
        const latDiff1 = pos2.lat - pos1.lat
        const latDiff2 = pos3.lat - pos2.lat
        const lngDiff1 = pos2.lng - pos1.lng
        const lngDiff2 = pos3.lng - pos2.lng

        // If direction changed in either lat or lng
        if (
          (Math.sign(latDiff1) !== Math.sign(latDiff2) &&
            Math.abs(latDiff1) > 0.00001 &&
            Math.abs(latDiff2) > 0.00001) ||
          (Math.sign(lngDiff1) !== Math.sign(lngDiff2) && Math.abs(lngDiff1) > 0.00001 && Math.abs(lngDiff2) > 0.00001)
        ) {
          // Increase jitter hysteresis
          this.jitterHysteresis = Math.min(this.maxJitterHysteresis, this.jitterHysteresis + 1)

          // Increase jitter confidence
          this.jitterConfidence = Math.min(1.0, this.jitterConfidence + 0.2)

          return this.jitterHysteresis > 2 && this.jitterConfidence > 0.5
        }
      }
    }

    // Gradually decrease jitter hysteresis and confidence if no jitter detected
    if (distance > this.jitterThreshold * 1.5) {
      this.jitterHysteresis = Math.max(0, this.jitterHysteresis - 0.5)
      this.jitterConfidence = Math.max(0, this.jitterConfidence - 0.1)
    }

    return false
  }

  // Adjust process noise based on accuracy, motion, and jitter confidence
  adjustProcessNoise(accuracy, motionDetected) {
    // Base noise level depends on GPS accuracy
    let noiseLevel =
      this.adaptiveNoiseMin + (this.adaptiveNoiseMax - this.adaptiveNoiseMin) * Math.min(1.0, accuracy / 40.0)

    // Reduce noise when stationary
    if (this.stationaryMode) {
      noiseLevel *= 0.03 // Further reduced for even less jitter
    }

    // Increase noise when motion is detected
    if (motionDetected && !this.stationaryMode) {
      noiseLevel *= 1.5
    }

    // Reduce noise when jitter is detected (counter-intuitive but effective)
    if (this.jitterConfidence > 0.3) {
      noiseLevel *= 0.01 // Drastically reduce noise to stabilize position
    }

    // Apply adaptive factor
    noiseLevel *= this.adaptiveNoiseFactor

    // Set process noise
    this.Q = noiseLevel
  }

  // Update the filter with new measurement
  update(position, motionDetected = false) {
    if (!this.initialized) {
      this.reset(position)
      return position
    }

    if (!position || typeof position.lat !== "number" || typeof position.lng !== "number") {
      console.warn("Invalid position input to Kalman filter")
      return {
        lat: this.y,
        lng: this.x,
        accuracy: position?.accuracy || 20,
        heading: this.lastHeading,
        timestamp: position?.timestamp || Date.now(),
      }
    }

    // If we're in stationary mode and have a locked position, return the locked position
    if (this.stationaryMode && this.stationaryLocked && this.stationaryPosition) {
      return {
        lat: this.stationaryPosition.lat,
        lng: this.stationaryPosition.lng,
        accuracy: position.accuracy,
        heading: position.heading,
        timestamp: position.timestamp,
        speedMPS: 0,
      }
    }

    // Calculate time delta
    const timestamp = position.timestamp || Date.now()
    if (this.lastTimestamp) {
      this.dt = Math.min(Math.max((timestamp - this.lastTimestamp) / 1000, 0.01), 2.0)
    }
    this.lastTimestamp = timestamp

    // Check for jitter
    const isJittering = this.detectJitter(position)

    // Adjust measurement noise based on GPS accuracy and jitter
    const accuracy = position.accuracy || 20
    this.R = Math.max(KALMAN_MEASUREMENT_NOISE_BASE, accuracy / 5)

    // If in stationary mode, increase measurement noise to reduce jitter
    if (this.stationaryMode) {
      this.R *= 15.0 // Increased to further reduce jitter
    }

    // If jittering is detected, increase measurement noise significantly
    if (isJittering) {
      this.R *= 30.0 // Increased to further reduce jitter
    }

    // Adjust process noise based on accuracy and motion
    this.adjustProcessNoise(accuracy, motionDetected)

    // State transition matrix
    const F = [
      [1, 0, this.dt, 0],
      [0, 1, 0, this.dt],
      [0, 0, 1, 0],
      [0, 0, 0, 1],
    ]

    // Process noise matrix
    const G = [
      [0.5 * this.dt * this.dt, 0],
      [0, 0.5 * this.dt * this.dt],
      [this.dt, 0],
      [0, this.dt],
    ]

    // Measurement matrix
    const H = [
      [1, 0, 0, 0],
      [0, 1, 0, 0],
    ]

    // Predict step
    // x = F * x
    const predictedX = this.x + this.dt * this.vx
    const predictedY = this.y + this.dt * this.vy
    const predictedVx = this.stationaryMode ? 0 : this.vx
    const predictedVy = this.stationaryMode ? 0 : this.vy

    // P = F * P * F' + Q
    const Q = [
      [(this.Q * this.dt * this.dt * this.dt * this.dt) / 4, 0, (this.Q * this.dt * this.dt * this.dt) / 2, 0],
      [0, (this.Q * this.dt * this.dt * this.dt * this.dt) / 4, 0, (this.Q * this.dt * this.dt * this.dt) / 2],
      [(this.Q * this.dt * this.dt * this.dt) / 2, 0, this.Q * this.dt * this.dt, 0],
      [0, (this.Q * this.dt * this.dt * this.dt) / 2, 0, this.Q * this.dt * this.dt],
    ]

    // Matrix multiplication F * P
    const FP = [
      [
        this.P[0][0] + this.dt * this.P[2][0],
        this.P[0][1] + this.dt * this.P[2][1],
        this.P[0][2] + this.dt * this.P[2][2],
        this.P[0][3] + this.dt * this.P[2][3],
      ],
      [
        this.P[1][0] + this.dt * this.P[3][0],
        this.P[1][1] + this.dt * this.P[3][1],
        this.P[1][2] + this.dt * this.P[3][2],
        this.P[1][3] + this.dt * this.P[3][3],
      ],
      [this.P[2][0], this.P[2][1], this.P[2][2], this.P[2][3]],
      [this.P[3][0], this.P[3][1], this.P[3][2], this.P[3][3]],
    ]

    // Matrix multiplication FP * F'
    const predictedP = [
      [
        FP[0][0] + this.dt * FP[0][2] + Q[0][0],
        FP[0][1] + this.dt * FP[0][3] + Q[0][1],
        FP[0][2] + Q[0][2],
        FP[0][3] + Q[0][3],
      ],
      [
        FP[1][0] + this.dt * FP[1][2] + Q[1][0],
        FP[1][1] + this.dt * FP[1][3] + Q[1][1],
        FP[1][2] + Q[1][2],
        FP[1][3] + Q[1][3],
      ],
      [FP[2][0] + Q[2][0], FP[2][1] + Q[2][1], FP[2][2] + Q[2][2], FP[2][3] + Q[2][3]],
      [FP[3][0] + Q[3][0], FP[3][1] + Q[3][1], FP[3][2] + Q[3][2], FP[3][3] + Q[3][3]],
    ]

    // Update step
    // y = z - H * x
    const measurementResidualX = position.lng - predictedX
    const measurementResidualY = position.lat - predictedY

    // S = H * P * H' + R
    const S = [
      [predictedP[0][0] + this.R, predictedP[0][1]],
      [predictedP[1][0], predictedP[1][1] + this.R],
    ]

    // Calculate determinant of S
    const detS = S[0][0] * S[1][1] - S[0][1] * S[1][0]

    // Calculate inverse of S
    const invS = [
      [S[1][1] / detS, -S[0][1] / detS],
      [-S[1][0] / detS, S[0][0] / detS],
    ]

    // K = P * H' * inv(S)
    const K = [
      [
        predictedP[0][0] * invS[0][0] + predictedP[0][1] * invS[1][0],
        predictedP[0][0] * invS[0][1] + predictedP[0][1] * invS[1][1],
      ],
      [
        predictedP[1][0] * invS[0][0] + predictedP[1][1] * invS[1][0],
        predictedP[1][0] * invS[0][1] + predictedP[1][1] * invS[1][1],
      ],
      [
        predictedP[2][0] * invS[0][0] + predictedP[2][1] * invS[1][0],
        predictedP[2][0] * invS[0][1] + predictedP[2][1] * invS[1][1],
      ],
      [
        predictedP[3][0] * invS[0][0] + predictedP[3][1] * invS[1][0],
        predictedP[3][0] * invS[0][1] + predictedP[3][1] * invS[1][1],
      ],
    ]

    // x = x + K * y
    this.x = predictedX + K[0][0] * measurementResidualX + K[0][1] * measurementResidualY
    this.y = predictedY + K[1][0] * measurementResidualX + K[1][1] * measurementResidualY

    // In stationary mode, keep velocity at zero
    if (this.stationaryMode) {
      this.vx = 0
      this.vy = 0
    } else {
      this.vx = predictedVx + K[2][0] * measurementResidualX + K[2][1] * measurementResidualY
      this.vy = predictedVy + K[3][0] * measurementResidualX + K[3][1] * measurementResidualY
    }

    // P = (I - K * H) * P
this.P = [ 
  [predictedP[0][0] - (K[0][0] * predictedP[0][0] + K[0][1] * predictedP[1][0]), predictedP[0][1] - (K[0][0] * predictedP[0][1] + K[0][1] * predictedP[1][1]), predictedP[0][2] - (K[0][0] * predictedP[0][2] + K[0][1] * predictedP[1][2]), predictedP[0][3] - (K[0][0] * predictedP[0][3] + K[0][1] * predictedP[1][3])], 
  [predictedP[1][0] - (K[1][0] * predictedP[0][0] + K[1][1] * predictedP[1][0]), predictedP[1][1] - (K[1][0] * predictedP[0][1] + K[1][1] * predictedP[1][1]), predictedP[1][2] - (K[1][0] * predictedP[0][2] + K[1][1] * predictedP[1][2]), predictedP[1][3] - (K[1][0] * predictedP[0][3] + K[1][1] * predictedP[1][3])], 
  [predictedP[2][0] - (K[2][0] * predictedP[0][0] + K[2][1] * predictedP[1][0]), predictedP[2][1] - (K[2][0] * predictedP[0][1] + K[2][1] * predictedP[1][1]), predictedP[2][2] - (K[2][0] * predictedP[0][2] + K[2][1] * predictedP[1][2]), predictedP[2][3] - (K[2][0] * predictedP[0][3] + K[2][1] * predictedP[1][3])], 
  [predictedP[3][0] - (K[3][0] * predictedP[0][0] + K[3][1] * predictedP[1][0]), predictedP[3][1] - (K[3][0] * predictedP[0][1] + K[3][1] * predictedP[1][1]), predictedP[3][2] - (K[3][0] * predictedP[0][2] + K[3][1] * predictedP[1][2]), predictedP[3][3] - (K[3][0] * predictedP[0][3] + K[3][1] * predictedP[1][3])]
];
        
        // Process heading data with enhanced smoothing
        let smoothedHeading = position.heading;
        if (position.heading !== null && position.heading !== undefined) {
            if (this.lastHeading !== null) {
                // Normalize headings to 0-360
                const normalizedCurrent = ((position.heading % 360) + 360) % 360;
                const normalizedLast = ((this.lastHeading % 360) + 360) % 360;
                
                // Calculate the smallest angle between the two headings
                let diff = normalizedCurrent - normalizedLast;
                if (diff > 180) diff -= 360;
                if (diff < -180) diff += 360;
                
                // Apply stronger smoothing when stationary, more responsive when moving
                // This is a key improvement for icon movement
                const headingWeight = this.stationaryMode ? 
                    0.005 : // Extremely stable when stationary
                    (motionDetected ? 
                        (Math.abs(diff) > 30 ? 0.4 : 0.2) : // More responsive to large changes when in motion
                        0.1); // Default smoothing
                
                smoothedHeading = normalizedLast + diff * headingWeight;
                
                // Normalize back to 0-360
                smoothedHeading = ((smoothedHeading % 360) + 360) % 360;
                
                // Increase confidence with consistent headings
                if (Math.abs(diff) < 12) {
                    this.headingConfidence = Math.min(1.0, this.headingConfidence + 0.1);
                } else {
                    this.headingConfidence = Math.max(0.1, this.headingConfidence - 0.2);
                }
            }
            this.lastHeading = smoothedHeading;
        }
        
        // Calculate speed from velocity components
        const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
        
        // Create filtered position
        const filteredPosition = {
            lat: this.y,
            lng: this.x,
            accuracy: position.accuracy,
            heading: smoothedHeading,
            timestamp: position.timestamp,
            speedMPS: this.stationaryMode ? 0 : speed * 111000 // Convert from degrees/second to meters/second (approximate)
        };
        
        // If we're in stationary mode and don't have a locked position yet,
        // check if we should lock the position
        if (this.stationaryMode && !this.stationaryLocked) {
            // If we've been stationary for a while, lock the position
            if (Date.now() - stationaryStartTime > 3000) {
                this.lockStationaryPosition(filteredPosition);
            }
        }
        
        return filteredPosition;
    }
}

// Position interpolator for smooth transitions
class PositionInterpolator {
    constructor() {
        this.startPosition = null;
        this.targetPosition = null;
        this.startTime = null;
        this.duration = 0;
        this.isActive = false;
        this.lastInterpolatedPosition = null; // Track last interpolated position
    }
    
    start(startPos, targetPos, duration) {
        if (!startPos || !targetPos) return;
        
        // If already interpolating, use current interpolated position as start
        if (this.isActive && this.lastInterpolatedPosition) {
            startPos = this.lastInterpolatedPosition;
        }
        
        this.startPosition = { ...startPos };
        this.targetPosition = { ...targetPos };
        this.startTime = performance.now();
        this.duration = duration;
        this.isActive = true;
    }
    
    update() {
        if (!this.isActive) return null;
        
        const now = performance.now();
        const elapsed = now - this.startTime;
        
        if (elapsed >= this.duration) {
            this.isActive = false;
            this.lastInterpolatedPosition = this.targetPosition;
            return this.targetPosition;
        }
        
        // Calculate progress with improved easing
        const t = elapsed / this.duration;
        const easedT = this.easeOutCubic(t);
        
        // Interpolate position
        const interpolatedPosition = {
            lat: this.startPosition.lat + (this.targetPosition.lat - this.startPosition.lat) * easedT,
            lng: this.startPosition.lng + (this.targetPosition.lng - this.startPosition.lng) * easedT,
            accuracy: this.targetPosition.accuracy,
            heading: this.interpolateHeading(this.startPosition.heading, this.targetPosition.heading, easedT),
            timestamp: now,
            speedMPS: this.targetPosition.speedMPS
        };
        
        this.lastInterpolatedPosition = interpolatedPosition;
        return interpolatedPosition;
    }
    
    // Improved heading interpolation that handles the 0/360 boundary
    interpolateHeading(start, end, t) {
        if (start === undefined || end === undefined || start === null || end === null) {
            return end;
        }
        
        // Normalize headings to 0-360
        start = ((start % 360) + 360) % 360;
        end = ((end % 360) + 360) % 360;
        
        // Find the shortest path
        let diff = end - start;
        if (diff > 180) diff -= 360;
        if (diff < -180) diff += 360;
        
        // Calculate interpolated heading
        let result = start + diff * t;
        
        // Normalize result
        return ((result % 360) + 360) % 360;
    }
    
    // Improved cubic easing function for smoother motion
    easeOutCubic(t) {
        return 1 - Math.pow(1 - t, 3);
    }
    
    isInterpolating() {
        return this.isActive;
    }
    
    cancel() {
        this.isActive = false;
    }
}

// Create Kalman filter instance
const kalmanFilter = new KalmanFilter();

// Create position interpolator
positionInterpolator = new PositionInterpolator();

const domUpdateManager = {
    updates: new Map(),
    scheduled: false,
    maxUpdates: 100, // Limit the number of updates to prevent memory bloat

    // Schedule a DOM update with optional priority
    schedule(id, updateFn, priority = 0) {
        // Enforce size limit
        if (this.updates.size >= this.maxUpdates) {
            console.warn("DOM update limit reached, skipping update for:", id);
            return;
        }

        // Store the update with its priority
        this.updates.set(id, { updateFn, priority }
    )

    // Schedule a flush if not already scheduled
    if (!this.scheduled) {
      this.scheduled = true
      requestAnimationFrame(() => this.flush())
    }
  }
  ,

  // Flush all scheduled DOM updates
  flush() {
    try {
      // Convert updates to an array and sort by priority (higher priority first)
      const sortedUpdates = Array.from(this.updates.values()).sort((a, b) => b.priority - a.priority)

      // Execute updates
      sortedUpdates.forEach(({ updateFn }) => {
        try {
          updateFn()
        } catch (error) {
          console.error("Error executing DOM update:", error)
        }
      })
    } catch (error) {
      console.error("Error during DOM update flush:", error)
    } finally {
      // Clear updates and reset state
      this.updates.clear()
      this.scheduled = false
    }
  }
  ,

  // Cancel a scheduled update by ID
  cancel(id) {
    this.updates.delete(id)
  }
  ,

  // Clear all pending updates
  clear() {
    this.updates.clear()
    this.scheduled = false
  }
}

// Calculate appropriate zoom level based on speed
function calculateZoomLevel(speedMPS) {
  // Update current speed for global access
  currentSpeed = speedMPS

  // Determine zoom level based on speed
  let zoomLevel
  if (isStationary || speedMPS < 0.5) {
    // Stationary or very slow movement
    zoomLevel = MAX_ZOOM_LEVEL // 18
  } else if (speedMPS < WALKING_SPEED_THRESHOLD) {
    // Walking speed
    zoomLevel = WALKING_ZOOM_LEVEL // 18
  } else if (speedMPS < RUNNING_SPEED_THRESHOLD) {
    // Running speed - linear interpolation between walking and running zoom levels
    const t = (speedMPS - WALKING_SPEED_THRESHOLD) / (RUNNING_SPEED_THRESHOLD - WALKING_SPEED_THRESHOLD)
    zoomLevel = WALKING_ZOOM_LEVEL - t * 2 // More aggressive zoom out for running
  } else if (speedMPS < DRIVING_SPEED_THRESHOLD) {
    // Driving speed - linear interpolation between running and driving zoom levels
    const t = (speedMPS - RUNNING_SPEED_THRESHOLD) / (DRIVING_SPEED_THRESHOLD - RUNNING_SPEED_THRESHOLD)
    zoomLevel = WALKING_ZOOM_LEVEL - 2 - t * 2 // More aggressive zoom out for driving
  } else {
    // High speed
    zoomLevel = MIN_ZOOM_LEVEL // 14
  }

  // Smooth zoom level changes
  if (lastZoomLevel !== null) {
    // Apply smoothing to avoid abrupt zoom changes
    zoomLevel = lastZoomLevel * 0.85 + zoomLevel * 0.15 // Increased responsiveness
  }

  // Round to one decimal place for smoother transitions
  zoomLevel = Math.round(zoomLevel * 10) / 10

  // Clamp to valid zoom range
  zoomLevel = Math.max(MIN_ZOOM_LEVEL, Math.min(MAX_ZOOM_LEVEL, zoomLevel))

  // Update last zoom level
  lastZoomLevel = zoomLevel

  return zoomLevel
}

// Enhanced stationary position calculation
function calculateStationaryPosition(buffer) {
  if (!buffer || buffer.length === 0) {
    return null
  }

  // Sort by accuracy (best first)
  const sortedBuffer = [...buffer].sort((a, b) => a.accuracy - b.accuracy)

  // Take weighted average of best positions
  const topPositions = sortedBuffer.slice(0, Math.ceil(buffer.length / 2))

  const weights = topPositions.map((pos) => 1 / Math.max(1, pos.accuracy))
  const totalWeight = weights.reduce((sum, w) => sum + w, 0)

  if (totalWeight === 0) {
    return sortedBuffer[0]
  }

  // Calculate weighted average
  const avgPosition = {
    lat: topPositions.reduce((sum, pos, i) => sum + pos.lat * weights[i], 0) / totalWeight,
    lng: topPositions.reduce((sum, pos, i) => sum + pos.lng * weights[i], 0) / totalWeight,
    accuracy: topPositions[0].accuracy,
    heading: topPositions[0].heading,
    timestamp: Date.now(),
    speedMPS: 0,
  }

  // If we have a previous stationary position, blend with it for stability
  if (lastStationaryPosition) {
    // Increased to 99% previous, 1% new for extreme stability when stationary
    const blendFactor = 0.99
    return {
      lat: lastStationaryPosition.lat * blendFactor + avgPosition.lat * (1 - blendFactor),
      lng: lastStationaryPosition.lng * blendFactor + avgPosition.lng * (1 - blendFactor),
      accuracy: avgPosition.accuracy,
      heading: avgPosition.heading,
      timestamp: avgPosition.timestamp,
      speedMPS: 0,
    }
  }

  return avgPosition
}

// Update stationary position history
function updateStationaryHistory(position) {
  // Add new position to history
  stationaryPositionHistory.push(position)

  // Keep history at maximum size
  while (stationaryPositionHistory.length > STATIONARY_POSITION_HISTORY_SIZE) {
    stationaryPositionHistory.shift()
  }

  // Calculate weighted average of positions
  let totalWeight = 0
  let weightedLat = 0
  let weightedLng = 0

  // Newer positions have higher weight
  for (let i = 0; i < stationaryPositionHistory.length; i++) {
    const pos = stationaryPositionHistory[i]
    const weight = Math.pow(STATIONARY_POSITION_WEIGHT_DECAY, stationaryPositionHistory.length - i - 1)
    totalWeight += weight
    weightedLat += pos.lat * weight
    weightedLng += pos.lng * weight
  }

  return {
    lat: weightedLat / totalWeight,
    lng: weightedLng / totalWeight,
    accuracy: position.accuracy,
    heading: position.heading,
    timestamp: position.timestamp,
    speedMPS: 0,
  }
}

// Check if device is in motion based on motion sensors
function isDeviceInMotion() {
  if (!motionSamples || motionSamples.length < 3) {
    return false
  }

  // Calculate average motion magnitude
  const avgMotion =
    motionSamples.reduce((sum, sample) => {
      return sum + Math.sqrt(sample.x * sample.x + sample.y * sample.y + sample.z * sample.z)
    }, 0) / motionSamples.length

  return avgMotion > MOTION_THRESHOLD
}

// Process device motion data
function handleDeviceMotion(event) {
  if (!event || !event.acceleration) return

  const motion = {
    x: event.acceleration.x || 0,
    y: event.acceleration.y || 0,
    z: event.acceleration.z || 0,
    timestamp: Date.now(),
  }

  // Add to motion samples
  motionSamples.push(motion)

  // Keep only recent samples
  while (motionSamples.length > MOTION_SAMPLE_SIZE) {
    motionSamples.shift()
  }

  // Update device motion state
  deviceMotion = motion

  // Check if device is stationary based on motion
  const inMotion = isDeviceInMotion()

  if (!inMotion) {
    deviceStationaryTime += MOTION_CHECK_INTERVAL
  } else {
    deviceStationaryTime = 0
  }
}

// Process device orientation data
function handleDeviceOrientation(event) {
  if (!event || event.alpha === null) return

  deviceOrientation = {
    alpha: event.alpha, // z-axis rotation [0,360)
    beta: event.beta, // x-axis rotation [-180,180)
    gamma: event.gamma, // y-axis rotation [-90,90)
    timestamp: Date.now(),
  }

  // Update heading buffer if we have a compass heading
  if (event.webkitCompassHeading !== undefined) {
    const heading = event.webkitCompassHeading

    // Add to heading buffer
    headingBuffer.push(heading)

    // Keep only recent headings
    while (headingBuffer.length > 5) {
      headingBuffer.shift()
    }

    // Calculate median heading to filter outliers
    if (headingBuffer.length >= 3) {
      const sortedHeadings = [...headingBuffer].sort((a, b) => a - b)
      lastHeadingValue = sortedHeadings[Math.floor(sortedHeadings.length / 2)]
    }
  }
}

// Request device motion and orientation permissions
function requestMotionPermission() {
  if (typeof DeviceMotionEvent !== "undefined" && typeof DeviceMotionEvent.requestPermission === "function") {
    DeviceMotionEvent.requestPermission()
      .then((response) => {
        if (response === "granted") {
          window.addEventListener("devicemotion", handleDeviceMotion, true)
        }
      })
      .catch(console.error)
  } else {
    window.addEventListener("devicemotion", handleDeviceMotion, true)
  }

  if (typeof DeviceOrientationEvent !== "undefined" && typeof DeviceOrientationEvent.requestPermission === "function") {
    DeviceOrientationEvent.requestPermission()
      .then((response) => {
        if (response === "granted") {
          orientationPermissionGranted = true
          window.addEventListener("deviceorientation", handleDeviceOrientation, true)
        }
      })
      .catch(console.error)
  } else {
    window.addEventListener("deviceorientation", handleDeviceOrientation, true)
    orientationPermissionGranted = true
  }
}

// Image preloading function with improved batching
function preloadImages(locationsData) {
  return new Promise((resolve) => {
    if (!locationsData || locationsData.length === 0) {
      resolve()
      return
    }

    const totalImages = locationsData.length
    let loadedImages = 0
    const progressBar = document.getElementById("preloaderProgress")

    // Create preload queue
    const imagePreloadQueue = locationsData
      .filter((location) => location.image && !preloadedImages.has(location.image))
      .map((location) => location.image)

    // Also queue audio files
    const audioPreloadQueue = locationsData
      .filter((location) => location.audio && !preloadedAudio.has(location.audio))
      .map((location) => location.audio)

    // Start preloading
    const preloadStartTime = Date.now()
    let isPreloading = true
    const preloadBatchSize = 5

    // Process next batch
    function processNextBatch() {
      if (imagePreloadQueue.length === 0 && audioPreloadQueue.length === 0) {
        isPreloading = false
        resolve()
        return
      }

      // Process image batch
      const imageBatch = imagePreloadQueue.splice(0, preloadBatchSize)

      // Load images in batch
      Promise.all(
        imageBatch.map((imageUrl) => {
          return new Promise((resolveImage) => {
            const img = new Image()
            img.crossOrigin = "anonymous" // Set crossOrigin for canvas operations

            img.onload = () => {
              preloadedImages.set(imageUrl, img)
              loadedImages++
              updateProgress()
              resolveImage()
            }

            img.onerror = () => {
              console.warn(`Failed to load image: ${imageUrl}`)
              loadedImages++
              updateProgress()
              resolveImage()
            }

            img.src = imageUrl
          })
        }),
      )
        .then(() => {
          // Process audio batch
          const audioBatch = audioPreloadQueue.splice(0, preloadBatchSize)

          // Load audio in batch
          return Promise.all(
            audioBatch.map((audioUrl) => {
              return new Promise((resolveAudio) => {
                const audio = new Audio()
                audio.preload = "auto"

                audio.oncanplaythrough = () => {
                  preloadedAudio.set(audioUrl, audio)
                  resolveAudio()
                }

                audio.onerror = () => {
                  console.warn(`Failed to load audio: ${audioUrl}`)
                  resolveAudio()
                }

                audio.src = audioUrl
              })
            }),
          )
        })
        .then(() => {
          // Continue with next batch after a small delay to prevent UI blocking
          setTimeout(processNextBatch, 10)
        })
        .catch((error) => {
          console.error("Error preloading batch:", error)
          setTimeout(processNextBatch, 10)
        })
    }

    function updateProgress() {
      const percent = (loadedImages / totalImages) * 100
      domUpdateManager.schedule("preloaderProgress", () => {
        progressBar.style.width = `${percent}%`
      })
    }

    // Start processing batches
    processNextBatch()
  })
}

// Detect sudden movements or position jumps
function detectSuddenMovement(newPosition, lastPosition) {
  if (!lastPosition || !newPosition) return false

  const distance = calculateDistance(lastPosition, newPosition)
  const timeDelta = (newPosition.timestamp - lastPosition.timestamp) / 1000 // seconds

  // If time delta is too small, consider it a valid update
  if (timeDelta < 0.05) return false

  // Calculate speed in meters per second
  const speed = distance / timeDelta

  // Check for unrealistic speeds (teleportation)
  if (speed > 50) {
    // 50 m/s is about 112 mph
    console.log(`Position jump detected: ${distance.toFixed(2)}m in ${timeDelta.toFixed(2)}s (${speed.toFixed(2)} m/s)`)
    return true
  }

  // Check for sudden movements when stationary
  if (isStationary && distance > POSITION_JUMP_THRESHOLD) {
    console.log(`Sudden movement detected while stationary: ${distance.toFixed(2)}m`)
    return true
  }

  // Check for small sudden movements (jitter)
  if (isStationary && distance > SUDDEN_MOVEMENT_THRESHOLD) {
    suddenMovementCount++
    if (suddenMovementCount >= 2) {
      console.log(`Multiple sudden movements detected: ${distance.toFixed(2)}m`)
      return true
    }
  } else {
    suddenMovementCount = 0
  }

  return false
}

// Check proximity to locations and adjust zoom accordingly
function checkLocationProximity() {
  const now = Date.now()

  // Don't check too frequently
  if (now - lastProximityCheck < 1000) return
  lastProximityCheck = now

  // Don't check if zoom was recently changed
  if (now - lastZoomChangeTime < ZOOM_CHANGE_COOLDOWN) return

  if (!userMarker || !gameLocations || gameLocations.length === 0) return

  const userLatLng = userMarker.getLatLng()
  const userPos = { lat: userLatLng.lat, lng: userLatLng.lng }

  // Find closest location
  let closestDistance = Number.POSITIVE_INFINITY
  let closestLocation = null

  for (const location of gameLocations) {
    if (!location || typeof location.lat !== "number" || typeof location.lng !== "number") continue

    const locationPos = { lat: location.lat, lng: location.lng }
    const distance = calculateDistance(userPos, locationPos)

    if (isFinite(distance) && distance < closestDistance) {
      closestDistance = distance
      closestLocation = location
    }
  }

  // Convert to feet for threshold comparison
  const distanceFeet = Math.round(closestDistance * 3.28084)

  // Constants for hysteresis and thresholds
  const HYSTERESIS_FACTOR = 1.1 // 10% buffer to prevent rapid toggling
  const ZOOM_IN_THRESHOLD = PROXIMITY_THRESHOLD * 0.9 // 90% of PROXIMITY_THRESHOLD
  const ZOOM_OUT_THRESHOLD = PROXIMITY_THRESHOLD * 1.1 // 110% of PROXIMITY_THRESHOLD

  // Check if we need to adjust zoom based on proximity
  if (distanceFeet <= ZOOM_IN_THRESHOLD) {
    // If we weren't near a location before, zoom in
    if (!isNearLocation && Math.abs(lastProximityDistance - closestDistance) > 1) {
      console.log(`User is now within ${ZOOM_IN_THRESHOLD.toFixed(1)} feet of a location, zooming in`)
      isNearLocation = true
      lastZoomChangeTime = now

      // Calculate new zoom level (clamped to MAX_ZOOM_LEVEL)
      const currentZoom = map.getZoom()
      const newZoom = Math.min(currentZoom + 1, MAX_ZOOM_LEVEL)

      // Apply zoom change with smooth animation
      map.setZoom(newZoom, {
        animate: true,
        duration: ZOOM_TRANSITION_DURATION,
      })
    }
  } else if (distanceFeet >= ZOOM_OUT_THRESHOLD && isNearLocation) {
    // If we were near a location but now we're not, zoom out
    console.log(`User is now outside ${ZOOM_OUT_THRESHOLD.toFixed(1)} feet of a location, zooming out`)
    isNearLocation = false
    lastZoomChangeTime = now

    // Calculate new zoom level (clamped to MIN_ZOOM_LEVEL)
    const currentZoom = map.getZoom()
    const newZoom = Math.max(currentZoom - 1, MIN_ZOOM_LEVEL)

    // Apply zoom change with smooth animation
    map.setZoom(newZoom, {
      animate: true,
      duration: ZOOM_TRANSITION_DURATION,
    })
  }

  // Update last proximity distance
  lastProximityDistance = closestDistance
}

function initMap() {
  map = L.map("map", {
    zoomControl: false,
    attributionControl: false,
    zoomSnap: 0.1,
    zoomDelta: 0.5,
    wheelDebounceTime: 100,
    tapTolerance: 15,
    bounceAtZoomLimits: false,
    preferCanvas: true, // Use canvas renderer for better performance
    renderer: L.canvas({ padding: 0.5 }),
  }).fitWorld()

  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    maxZoom: 18,
    attribution: "© OpenStreetMap contributors",
    updateWhenIdle: true,
    updateWhenZooming: false,
    keepBuffer: 2,
  }).addTo(map)

  markerClusterGroup = L.markerClusterGroup({
    showCoverageOnHover: false,
    zoomToBoundsOnClick: true,
    spiderfyOnMaxZoom: true,
    animate: true,
    animateAddingMarkers: true,
    disableClusteringAtZoom: 18,
    maxClusterRadius: 60,
    iconCreateFunction: (cluster) =>
      L.divIcon({
        html: "<div><span>" + cluster.getChildCount() + "</span></div>",
        className: "marker-cluster-custom",
        iconSize: L.point(40, 40),
      }),
  })
  map.addLayer(markerClusterGroup)

  // Create user icon with custom styling (red)
  const userIcon = L.divIcon({
    className: "user-marker",
    html: '<div class="user-marker-icon"></div>',
    iconSize: [20, 20],
    iconAnchor: [10, 10],
  })
  userMarker = L.marker([0, 0], {
    icon: userIcon,
    zIndexOffset: 1000, // Ensure user marker is on top
    interactive: false, // Prevent marker from being clickable
  }).addTo(map)

  // Store map viewport dimensions
  updateMapViewportDimensions()

  showLoadingMessage()

  // Request motion and orientation permissions
  requestMotionPermission()

  // Try to use Geolocation Sensor API first, then fall back to standard Geolocation API
  initGeolocation()

  document.addEventListener("visibilitychange", handleVisibilityChange)

  map.on("movestart zoomstart dragstart", () => {
    followUser = false
    isMapInteracting = true
  })

  map.on("moveend zoomend", () => {
    isMapInteracting = false
    resetInactivityTimer()
    updateMapViewportDimensions()
  })

  // Listen for resize events to update viewport dimensions
  window.addEventListener("resize", updateMapViewportDimensions)

  // Start animation loop for smooth rendering
  startAnimationLoop()

  // Enable touch interactions
  map.touchZoom.enable()
  map.doubleClickZoom.enable()

  // Initialize network status monitoring
  initNetworkMonitoring()
}

// Initialize network status monitoring
function initNetworkMonitoring() {
  const networkStatus = document.getElementById("networkStatus")

  // Update network status indicator
  function updateNetworkStatus() {
    if (navigator.onLine) {
      networkStatus.classList.remove("offline")
      networkStatus.title = "Online"
      isOnline = true
    } else {
      networkStatus.classList.add("offline")
      networkStatus.title = "Offline"
      isOnline = false
      showErrorMessage("No internet connection. Some features may not work properly.")
    }
  }

  // Initial status check
  updateNetworkStatus()

  // Listen for network status changes
  window.addEventListener("online", () => {
    updateNetworkStatus()
    showErrorMessage("Internet connection restored.")

    // Retry any failed operations
    if (gameLocations.length === 0) {
      startHunt()
    }
  })

  window.addEventListener("offline", () => {
    updateNetworkStatus()
    showErrorMessage("No internet connection. Some features may not work properly.")
  })

  // Periodically check network status
  setInterval(() => {
    // Check if we can fetch a small resource to verify actual connectivity
    if (navigator.onLine) {
      fetch("https://www.mnthen.com/favicon.ico", {
        method: "HEAD",
        cache: "no-store",
        mode: "no-cors",
        timeout: 3000,
      })
        .then(() => {
          if (!isOnline) {
            isOnline = true
            networkStatus.classList.remove("offline")
            networkStatus.title = "Online"
          }
        })
        .catch((error) => {
          networkErrorCount++
          const now = Date.now()

          // Only show error message if it's been a while since the last one
          if (now - lastNetworkErrorTime > 30000 && networkErrorCount > 2) {
            showErrorMessage("Network connection is unstable.")
            lastNetworkErrorTime = now
          }

          if (networkErrorCount > 5) {
            isOnline = false
            networkStatus.classList.add("offline")
            networkStatus.title = "Connection unstable"
          }
        })
    }
  }, NETWORK_CHECK_INTERVAL)
}

// Update map viewport dimensions
function updateMapViewportDimensions() {
  if (map && map._container) {
    mapViewportWidth = map._container.clientWidth
    mapViewportHeight = map._container.clientHeight

    // Store current map center and zoom
    if (map.getCenter()) {
      lastMapCenter = map.getCenter()
      lastMapZoom = map.getZoom()
    }
  }
}

// Initialize geolocation with priority for Geolocation Sensor API
function initGeolocation() {
  if ("GeolocationSensor" in window) {
    try {
      console.log("Trying GeolocationSensor API")
      geolocationSensor = new GeolocationSensor({ frequency: 1 })

      geolocationSensor.addEventListener("reading", () => {
        const position = {
          coords: {
            latitude: geolocationSensor.latitude,
            longitude: geolocationSensor.longitude,
            accuracy: geolocationSensor.accuracy,
            altitude: geolocationSensor.altitude,
            altitudeAccuracy: geolocationSensor.altitude,
            heading: geolocationSensor.heading,
            speed: geolocationSensor.speed,
          },
          timestamp: geolocationSensor.timestamp,
        }

        if (!lastPosition) {
          initializeUserLocation(position)
        } else {
          handlePositionUpdate(position)
        }
      })

      geolocationSensor.addEventListener("error", (error) => {
        console.warn("GeolocationSensor error:", error)
        // Fall back to standard Geolocation API
        useStandardGeolocation()
      })

      geolocationSensor.start()
      usingGeolocationSensorAPI = true
      console.log("Using GeolocationSensor API")
    } catch (error) {
      console.warn("GeolocationSensor error:", error)
      // Fall back to standard Geolocation API
      useStandardGeolocation()
    }
  } else {
    // Fall back to standard Geolocation API
    useStandardGeolocation()
  }
}

// Standard Geolocation API fallback
function useStandardGeolocation() {
  console.log("Using standard Geolocation API")
  usingGeolocationSensorAPI = false

  if ("geolocation" in navigator) {
    const options = {
      enableHighAccuracy: true,
      timeout: 45000,
      maximumAge: 0,
    }

    // Try first time
    navigator.geolocation.getCurrentPosition(
      initializeUserLocation,
      (error) => {
        // Handle error based on error code
        if (error.code === PERMISSION_DENIED_ERROR) {
          permissionDenied = true
          handleLocationPermissionDenied()
        } else {
          // On other errors, try one more time before falling back
          navigator.geolocation.getCurrentPosition(initializeUserLocation, handleLocationError, options)
        }
      },
      options,
    )
  } else {
    showErrorMessage("Geolocation is not supported by your browser")
    map.setView([44.9778, -93.265], 18)
    hideLoadingMessage()
  }
}

// Handle location permission denied
function handleLocationPermissionDenied() {
  permissionDenied = true
  hideLoadingMessage()

  // Show error message
  showErrorMessage("Location access denied. Please enable location services to use this app.")

  // Show popup with instructions
  showPopup(
    "Location Access Required",
    "This app needs access to your location to guide you to historical sites. " +
      "Please enable location services in your browser settings and reload the page.",
    "error",
    () => {
      // Try to request permission again after a delay
      setTimeout(() => {
        if (!permissionRequestInProgress && Date.now() - lastPermissionRequest > 60000) {
          requestLocationPermission()
        }
      }, 5000)
    },
  )

  // Set default view
  map.setView([44.9778, -93.265], 18)
}

// Request location permission
function requestLocationPermission() {
  if (permissionRequestInProgress) return

  permissionRequestInProgress = true
  lastPermissionRequest = Date.now()

  if ("geolocation" in navigator) {
    const options = {
      enableHighAccuracy: true,
      timeout: 10000,
      maximumAge: 0,
    }

    navigator.geolocation.getCurrentPosition(
      (position) => {
        permissionDenied = false
        permissionRequestInProgress = false
        initializeUserLocation(position)
      },
      (error) => {
        permissionRequestInProgress = false
        if (error.code === PERMISSION_DENIED_ERROR) {
          permissionDenied = true
          showErrorMessage("Location access still denied. Please enable location in your browser settings.")
        } else {
          handleLocationError(error)
        }
      },
      options,
    )
  }
}

// Animation loop for smooth rendering
function startAnimationLoop() {
  function animate(timestamp) {
    // Calculate delta time
    const deltaTime = renderTimestamp ? (timestamp - renderTimestamp) / 1000 : 0
    renderTimestamp = timestamp

    // Process position updates
    processPositionUpdateQueue()

    // Update interpolated position
    if (positionInterpolator && positionInterpolator.isInterpolating()) {
      const interpolatedPosition = positionInterpolator.update()
      if (interpolatedPosition) {
        // Update marker position
        updateMarkerPosition(interpolatedPosition)

        lastRenderPosition = interpolatedPosition
      }
    }

    // Check if marker is near edge and recenter if needed
    if (followUser && !isMapInteracting && !edgeRecenterInProgress) {
      const now = Date.now()
      // Only check edge proximity at regular intervals to improve performance
      if (now - lastEdgeCheck > edgeCheckInterval) {
        lastEdgeCheck = now
        const recenterInfo = shouldRecenter(map, userMarker)
        if (recenterInfo.needsRecenter) {
          performEdgeRecenter(recenterInfo)
        }
      }
    }

    // Check proximity to locations for zoom adjustments
    checkLocationProximity()

    // Update GPS signal indicator
    updateGpsSignalIndicator()

    // Request next frame
    animationFrameId = requestAnimationFrame(animate)
  }

  // Start animation loop
  animationFrameId = requestAnimationFrame(animate)
}

// Update marker position with throttling
function updateMarkerPosition(position) {
  const now = Date.now()

  // Throttle updates to improve performance
  if (now - lastMapUpdate < mapUpdateThrottleInterval) {
    return
  }

  lastMapUpdate = now
  userMarker.setLatLng([position.lat, position.lng])
}

// Update GPS signal indicator
function updateGpsSignalIndicator() {
  const now = Date.now()

  // Don't update too frequently
  if (now - lastAccuracyUpdate < GPS_SIGNAL_CHECK_INTERVAL) {
    return
  }

  lastAccuracyUpdate = now

  // Get current position accuracy
  let accuracy = 0
  let signalText = ""
  let signalClass = ""

  if (lastPosition && typeof lastPosition.accuracy === "number") {
    accuracy = lastPosition.accuracy

    // Update confidence score history
    confidenceScoreHistory.push(calculateGpsConfidenceScore(accuracy))

    // Keep history at reasonable size
    while (confidenceScoreHistory.length > 5) {
      confidenceScoreHistory.shift()
    }

    // Calculate average confidence score
    gpsConfidenceScore = confidenceScoreHistory.reduce((sum, score) => sum + score, 0) / confidenceScoreHistory.length

    // Determine signal quality
    if (accuracy <= GPS_CONFIDENCE_THRESHOLD_HIGH) {
      signalText = ""
      signalClass = "accuracy-high"
    } else if (accuracy <= GPS_CONFIDENCE_THRESHOLD_MEDIUM) {
      signalText = ""
      signalClass = "accuracy-medium"
    } else {
      signalText = ""
      signalClass = "accuracy-low"
    }
  } else {
    signalText = "GPS: No Signal"
    signalClass = "accuracy-low"
  }

  // Update indicator
  domUpdateManager.schedule("accuracyIndicator", () => {
    const indicator = document.getElementById("accuracyIndicator")
    const dot = indicator.querySelector(".accuracy-dot")
    const text = document.getElementById("accuracyText")

    // Remove all classes
    dot.classList.remove("accuracy-high", "accuracy-medium", "accuracy-low")

    // Add appropriate class
    dot.classList.add(signalClass)

    // Update text
    text.textContent = signalText
  })
}

// Calculate GPS confidence score (0-1)
function calculateGpsConfidenceScore(accuracy) {
  if (!accuracy || accuracy <= 0) return 0

  // Higher accuracy (lower value) means higher confidence
  if (accuracy <= GPS_CONFIDENCE_THRESHOLD_HIGH) {
    return 1.0
  } else if (accuracy <= GPS_CONFIDENCE_THRESHOLD_MEDIUM) {
    // Linear interpolation between high and medium thresholds
    return (
      0.5 +
      (0.5 * (GPS_CONFIDENCE_THRESHOLD_MEDIUM - accuracy)) /
        (GPS_CONFIDENCE_THRESHOLD_MEDIUM - GPS_CONFIDENCE_THRESHOLD_HIGH)
    )
  } else {
    // Linear interpolation between medium threshold and max acceptable
    return Math.max(
      0.1,
      (0.5 * (MAX_ACCEPTABLE_ACCURACY - accuracy)) / (MAX_ACCEPTABLE_ACCURACY - GPS_CONFIDENCE_THRESHOLD_MEDIUM),
    )
  }
}

// Process position update queue
function processPositionUpdateQueue() {
  if (positionUpdateQueue.length === 0) return

  // Process all updates in queue
  while (positionUpdateQueue.length > 0) {
    const update = positionUpdateQueue.shift()
    processPositionUpdate(update)
  }
}

// Process position update
function processPositionUpdate(position) {
  // Skip if invalid position
  if (!position || typeof position.lat !== "number" || typeof position.lng !== "number") {
    return
  }

  // Update last position
  lastPosition = position

  // Start interpolation to new position
  if (lastRenderPosition && !isFirstPositionUpdate) {
    positionInterpolator.start(lastRenderPosition, position, isStationary ? 500 : ANIMATION_DURATION)
  } else {
    // First update, just set position directly
    userMarker.setLatLng([position.lat, position.lng])
    lastRenderPosition = position
    isFirstPositionUpdate = false
  }

  // Auto-recenter map if following user
  if (followUser && !isMapInteracting) {
    const recenterInfo = shouldRecenter(map, userMarker)
    if (recenterInfo.needsRecenter) {
      performEdgeRecenter(recenterInfo)
    } else if (Math.abs(map.getZoom() - calculateZoomLevel(position.speedMPS)) > 0.5) {
      // If zoom level should change significantly but no recenter needed
      const newZoom = calculateZoomLevel(position.speedMPS)
      map.setZoom(newZoom, {
        animate: true,
        duration: ZOOM_TRANSITION_DURATION,
      })
    }
  }
}

// Perform edge recentering
function performEdgeRecenter(recenterInfo) {
  edgeRecenterInProgress = true

  // Get current position
  const position = userMarker.getLatLng()

  // Calculate appropriate zoom level based on speed
  const dynamicZoom = calculateZoomLevel(lastPosition?.speedMPS || 0)

  // Calculate optimal center point that keeps the user icon away from edges
  const optimalCenter = calculateOptimalCenter(map, position, recenterInfo.edgeInfo)

  // Set view with animation
  map.setView([optimalCenter.lat, optimalCenter.lng], dynamicZoom, {
    animate: true,
    duration: recenterInfo.isEmergency ? 0.2 : ZOOM_TRANSITION_DURATION,
    noMoveStart: true,
    easeLinearity: 0.5,
  })

  // Reset edge recenter flag after animation completes
  setTimeout(
    () => {
      edgeRecenterInProgress = false
    },
    recenterInfo.isEmergency ? 300 : ZOOM_TRANSITION_DURATION * 1000,
  )
}

function showLoadingMessage() {
  const loadingMessage = document.createElement("div")
  loadingMessage.id = "loadingMessage"
  loadingMessage.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: rgba(255, 255, 255, 0.9);
        padding: 20px;
        border-radius: 10px;
        z-index: 1000;
        text-align: center;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    `
  loadingMessage.innerHTML = `
        <div style="margin-bottom: 15px;">
            <div style="width: 40px; height: 40px; border: 4px solid rgba(255, 0, 0, 0.2); border-top: 4px solid #ff0000; border-radius: 50%; margin: 0 auto 15px; animation: spin 1s linear infinite;"></div>
        </div>
        <p style="font-weight: 500; color: #333;">Searching for your location...</p>
    `
  document.body.appendChild(loadingMessage)
}

function hideLoadingMessage() {
  const loadingMessage = document.getElementById("loadingMessage")
  if (loadingMessage) {
    document.body.removeChild(loadingMessage)
  }
}

function showStabilizingModal() {
  const modal = document.createElement("div")
  modal.id = "stabilizingModal"
  modal.className = "stabilizing-modal"
  modal.innerHTML = `
        <div class="spinner"></div>
        <h3>Stabilizing Your Location</h3>
        <p>Please wait while we fine-tune your position.</p>
    `
  document.body.appendChild(modal)

  // Auto-dismiss after 5 seconds
  setTimeout(() => {
    const stabilizingModal = document.getElementById("stabilizingModal")
    if (stabilizingModal) {
      stabilizingModal.style.opacity = "0"
      stabilizingModal.style.transition = "opacity 0.5s ease"
      setTimeout(() => {
        if (stabilizingModal && stabilizingModal.parentNode) {
          stabilizingModal.parentNode.removeChild(stabilizingModal)
        }
        isStabilizing = false
      }, 500)
    }
  }, 5000)
}

function initializeUserLocation(position) {
  console.log("Initial position data:", JSON.stringify(position))

  if (!position || !position.coords) {
    console.error("Invalid initial position object")
    handleLocationError(new Error("Invalid initial position"))
    return
  }

  const { latitude: userLat, longitude: userLng, accuracy } = position.coords

  if (isNaN(userLat) || isNaN(userLng)) {
    console.error("Invalid initial coordinates:", { userLat, userLng })
    handleLocationError(new Error("Invalid initial coordinates"))
    return
  }

  console.log("Valid initial position:", { userLat, userLng, accuracy })

  try {
    userMarker.setLatLng([userLat, userLng])
    map.setView([userLat, userLng], 18)

    // Initialize Kalman filter with first position
    kalmanFilter.reset({
      lat: userLat,
      lng: userLng,
      accuracy: accuracy,
      heading: position.coords.heading,
      timestamp: Date.now(),
    })

    // Initialize stationary position
    lastStationaryPosition = {
      lat: userLat,
      lng: userLng,
      accuracy: accuracy,
      heading: position.coords.heading,
      timestamp: Date.now(),
      speedMPS: 0,
    }

    // Initialize last render position
    lastRenderPosition = {
      lat: userLat,
      lng: userLng,
      accuracy: accuracy,
      heading: position.coords.heading,
      timestamp: Date.now(),
      speedMPS: 0,
    }

    // Initialize last valid position
    lastValidPosition = {
      lat: userLat,
      lng: userLng,
      accuracy: accuracy,
      heading: position.coords.heading,
      timestamp: Date.now(),
      speedMPS: 0,
    }

    // Show stabilizing modal
    hideLoadingMessage()
    showStabilizingModal()

    // Start position updates
    startPositionUpdates()
    startHunt()

    // Reset location error count
    locationErrorCount = 0
    isLocationAvailable = true
  } catch (error) {
    console.error("Error setting initial user location:", error)
    handleLocationError(error)
  }
}

function startPositionUpdates() {
  // If already using GeolocationSensor API, don't start again
  if (usingGeolocationSensorAPI) {
    console.log("Position updates already using GeolocationSensor API")
    return
  }

  // Use standard Geolocation API
  locationWatchId = navigator.geolocation.watchPosition(handlePositionUpdate, handleLocationError, {
    enableHighAccuracy: true,
    maximumAge: 1000,
    timeout: 10000,
  })
  console.log("Position updates using standard Geolocation API")
}

function handlePositionUpdate(position) {
  if (!position?.coords?.latitude || !position?.coords?.longitude) {
    console.warn("Invalid position data received")
    return
  }

  // Reset error counters on successful update
  locationErrorCount = 0
  isLocationAvailable = true

  // Update GPS confidence score
  if (position.coords.accuracy) {
    const newScore = calculateGpsConfidenceScore(position.coords.accuracy)
    confidenceScoreHistory.push(newScore)

    // Keep history at reasonable size
    while (confidenceScoreHistory.length > 5) {
      confidenceScoreHistory.shift()
    }

    // Calculate average confidence score
    gpsConfidenceScore = confidenceScoreHistory.reduce((sum, score) => sum + score, 0) / confidenceScoreHistory.length
  }

  updateUserLocation(position)
}

function handleVisibilityChange() {
  if (document.hidden) {
    lastHiddenTime = Date.now()
    lastKnownPosition = userMarker ? userMarker.getLatLng() : null

    // Cancel any active interpolation
    if (positionInterpolator) {
      positionInterpolator.cancel()
    }

    // Cancel animation frame
    if (animationFrameId) {
      cancelAnimationFrame(animationFrameId)
      animationFrameId = null
    }

    // Stop GeolocationSensor if using it
    if (usingGeolocationSensorAPI && geolocationSensor) {
      geolocationSensor.stop()
    }
  } else {
    const hiddenDuration = Date.now() - lastHiddenTime
    if (hiddenDuration > BACKGROUND_THRESHOLD) {
      updateLocationAfterBackground()
    } else {
      map.invalidateSize()

      // Restart animation loop
      if (!animationFrameId) {
        startAnimationLoop()
      }

      // Restart GeolocationSensor if using it
      if (usingGeolocationSensorAPI && geolocationSensor) {
        geolocationSensor.start()
      }

      // If returning from exhibit, ensure movement resumes properly
      if (isReturningFromExhibit) {
        isReturningFromExhibit = false
        // Force a position update to resume tracking
        if (lastValidPosition) {
          updateUserLocation(
            {
              coords: {
                latitude: lastValidPosition.lat,
                longitude: lastValidPosition.lng,
                accuracy: lastValidPosition.accuracy,
                heading: lastValidPosition.heading,
                speed: lastValidPosition.speedMPS,
              },
              timestamp: Date.now(),
            },
            true,
          )
        }
      }
    }
  }
  resetInactivityTimer()
}

function updateLocationAfterBackground() {
  if ("geolocation" in navigator) {
    navigator.geolocation.getCurrentPosition(
      (position) => {
        console.log("Background update raw position:", JSON.stringify(position))
        if (!position || !position.coords) {
          console.warn("Invalid position object in background update")
          return
        }
        const { latitude, longitude, accuracy } = position.coords
        if (isNaN(latitude) || isNaN(longitude)) {
          console.warn("Invalid coordinates in background update:", { latitude, longitude })
          return
        }

        console.log("Valid background position update:", { lat: latitude, lng: longitude })
        try {
          updateUserLocation(position, true)
        } catch (error) {
          console.error("Error in updateUserLocation during background update:", error)
        }

        // Reset tracking variables
        lastPosition = null
        positionBuffer = []
        velocity = { lat: 0, lng: 0 }
        lastVelocity = { lat: 0, lng: 0 }
        isStationary = false
        stationaryStartTime = null
        stationaryCount = 0
        stationaryPositionHistory = []
        lastStationaryPosition = null
        stationaryPositionLocked = false
        positionHistory = []
        suddenMovementCount = 0
        isJumpDetected = false

        // Reset Kalman filter
        kalmanFilter.reset({
          lat: latitude,
          lng: longitude,
          accuracy: accuracy,
          heading: position.coords.heading,
          timestamp: Date.now(),
        })

        // Restart animation loop
        if (!animationFrameId) {
          startAnimationLoop()
        }

        // Restart GeolocationSensor if using it
        if (usingGeolocationSensorAPI && geolocationSensor) {
          geolocationSensor.start()
        }

        updateDistanceBox()
        followUser = true
        map.invalidateSize()
      },
      (error) => {
        console.error("Error getting location after background:", error)
        handleLocationError(error)
      },
      {
        enableHighAccuracy: true,
        timeout: 10000,
        maximumAge: 0,
      },
    )
  } else {
    console.warn("Geolocation is not available")
    showErrorMessage("Unable to update your location after background. Please reload the app.")
  }
}

// Helper function to validate position data
function isValidPosition(pos) {
  return (
    pos &&
    typeof pos.lat === "number" &&
    !isNaN(pos.lat) &&
    typeof pos.lng === "number" &&
    !isNaN(pos.lng) &&
    typeof pos.accuracy === "number" &&
    !isNaN(pos.accuracy)
  )
}

// Calculate distance between two points using Haversine formula
function calculateDistance(pos1, pos2) {
  if (
    !pos1 ||
    !pos2 ||
    typeof pos1.lat !== "number" ||
    typeof pos1.lng !== "number" ||
    typeof pos2.lat !== "number" ||
    typeof pos2.lng !== "number"
  ) {
    return Number.POSITIVE_INFINITY
  }

  const R = 6371000 // Earth's radius in meters
  const lat1 = (pos1.lat * Math.PI) / 180
  const lat2 = (pos2.lat * Math.PI) / 180
  const deltaLat = ((pos2.lat - pos1.lat) * Math.PI) / 180
  const deltaLng = ((pos2.lng - pos1.lng) * Math.PI) / 180

  const a =
    Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) +
    Math.cos(lat1) * Math.cos(lat2) * Math.sin(deltaLng / 2) * Math.sin(deltaLng / 2)
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))

  return R * c
}

// Linear interpolation helper
function lerp(a, b, t) {
  if (typeof a !== "number" || typeof b !== "number" || typeof t !== "number") {
    return a
  }

  return a + (b - a) * Math.max(0, Math.min(1, t))
}

// Update position buffer with new position
function updatePositionBuffer(position) {
  if (!isValidPosition(position)) {
    return
  }

  // Add new position to buffer
  positionBuffer.push({
    lat: position.lat,
    lng: position.lng,
    accuracy: position.accuracy,
    heading: position.heading,
    timestamp: position.timestamp,
    speedMPS: position.speedMPS,
  })

  // Remove old positions if buffer exceeds maxSize
  while (positionBuffer.length > MAX_BUFFER_SIZE) {
    positionBuffer.shift()
  }
}

// Update position history for jump detection
function updatePositionHistory(position) {
  if (!isValidPosition(position)) {
    return
  }

  // Add new position to history
  positionHistory.push({
    lat: position.lat,
    lng: position.lng,
    accuracy: position.accuracy,
    heading: position.heading,
    timestamp: position.timestamp,
    speedMPS: position.speedMPS,
  })

  // Keep only recent positions
  while (positionHistory.length > 10) {
    positionHistory.shift()
  }
}

function initializeFirstPosition(newPosition) {
  lastPosition = newPosition
  lastValidPosition = newPosition
  userMarker.setLatLng([newPosition.lat, newPosition.lng])
  kalmanFilter.reset(newPosition)
  lastUpdateTime = newPosition.timestamp
  stationaryStartTime = newPosition.timestamp
  positionBuffer = [newPosition]
  positionHistory = [newPosition]
  lastStationaryPosition = newPosition
  lastRenderPosition = newPosition

  // Set initial zoom based on stationary state
  const initialZoom = calculateZoomLevel(0)
  map.setView([newPosition.lat, newPosition.lng], initialZoom, { animate: false })
  updateDistanceBox()
}

function handlePositionJump(newPosition) {
  if (isStationary && stationaryPositionLocked) {
    console.log("Position jump detected while stationary, ignoring update")
    isJumpDetected = true
    return
  }
}

function handleLargePositionChange(newPosition) {
  resetStationaryState()
  userMarker.setLatLng([newPosition.lat, newPosition.lng])
  lastPosition = newPosition
  lastValidPosition = newPosition
  lastRenderPosition = newPosition
  positionBuffer = [newPosition]
  positionHistory = [newPosition]
  kalmanFilter.reset(newPosition)
  kalmanFilter.setStationaryMode(false)
  lastVelocity = { lat: 0, lng: 0 }
  lastSmoothedPosition = null

  if (positionInterpolator) {
    positionInterpolator.cancel()
  }

  const zoomLevel = calculateZoomLevel(newPosition.speedMPS)
  map.setView([newPosition.lat, newPosition.lng], zoomLevel, {
    animate: true,
    duration: 0.3,
    noMoveStart: true,
  })

  lastUpdateTime = newPosition.timestamp
  lastUpdateTimestamp = newPosition.timestamp
  updateDistanceBox()

  if (map._container) {
    map._onResize()
  }
}

function resetStationaryState() {
  if (stationaryCheckTimeout) {
    clearTimeout(stationaryCheckTimeout)
    stationaryCheckTimeout = null
  }

  if (stationaryLockTimeout) {
    clearTimeout(stationaryLockTimeout)
    stationaryLockTimeout = null
  }

  isStationary = false
  stationaryStartTime = null
  stationaryCount = 0
  stationaryPositionHistory = []
  lastStationaryPosition = null

  stationaryPositionLocked = false
  isJumpDetected = false
}

function updateStationaryState(newPosition, motionDetected) {
    // Validate input
    if (!newPosition || !lastPosition) return;
    
    // Calculate distance from last position
    const distance = calculateDistance(lastPosition, newPosition);
    
    // Calculate confidence score for stationary state
    const accuracyScore = Math.max(0, 1 - newPosition.accuracy / MAX_ACCEPTABLE_ACCURACY); // Higher accuracy = higher score
    const motionScore = motionDetected ? 0 : 1; // No motion = higher score
    const historyScore = stationaryPositionHistory.length > 5 ? 1 : 0.5; // More history = higher score
    
    // Combine scores to get overall confidence
    const stationaryConfidence = (accuracyScore + motionScore + historyScore) / 3;
    
    // Check if the user is likely stationary
    if (distance < MICRO_MOVEMENT_THRESHOLD && stationaryConfidence > 0.8) {
        stationaryCount++;
        
        // Transition to stationary state if confidence is high and threshold is met
        if (!isStationary && stationaryCount >= STATIONARY_THRESHOLD) {
            setStationary(newPosition);
        }
    } else {
        // Decrease stationary count if movement is detected
        stationaryCount = Math.max(0, stationaryCount - 1);
        
        // Transition to moving state if confidence drops below a threshold
        if (isStationary && stationaryCount < STATIONARY_THRESHOLD / 2) {
            setMoving();
        }
    }
    
    // Update stationary position history for averaging
    if (isStationary) {
        stationaryPositionHistory.push(newPosition);
        if (stationaryPositionHistory.length > STATIONARY_POSITION_HISTORY_SIZE) {
            stationaryPositionHistory.shift();
        }
    }
}

function setStationary(newPosition) {
  isStationary = true
  console.log("User is now stationary")

  // Enable stationary mode in Kalman filter
  kalmanFilter.setStationaryMode(true)
  stationaryStartTime = newPosition.timestamp

  // Add new position to stationary history
  updateStationaryPositionHistory(newPosition)

  // Calculate stable position using weighted average
  const stablePosition = calculateStationaryWeightedAverage() || newPosition

  if (stablePosition) {
    // Update position queue and state
    positionUpdateQueue.push(stablePosition)
    lastPosition = stablePosition
    lastValidPosition = stablePosition
    lastStationaryPosition = stablePosition

    // Lock the stationary position after a short delay
    stationaryLockTimeout = setTimeout(() => {
      stationaryPositionLocked = true
      stationaryPositionLockTime = Date.now()
      console.log("Stationary position locked after delay")

      // Lock the position in the Kalman filter
      kalmanFilter.lockStationaryPosition(lastStationaryPosition)
    }, 3000) // 3-second delay before locking
  }

  // Schedule the next stationary check
  stationaryCheckTimeout = setTimeout(() => checkStationaryState(newPosition), STATIONARY_CHECK_INTERVAL)

  // Adjust map zoom if following the user
  if (followUser && !isMapInteracting) {
    const stationaryZoom = calculateZoomLevel(0)
    map.setZoom(stationaryZoom, {
      animate: true,
      duration: ZOOM_TRANSITION_DURATION,
    })
  }

  // Update the distance box
  updateDistanceBox()
}

function updateStationaryPositionHistory(newPosition) {
  stationaryPositionHistory.push(newPosition)
  if (stationaryPositionHistory.length > STATIONARY_POSITION_HISTORY_SIZE) {
    stationaryPositionHistory.shift()
  }
}

function calculateStationaryWeightedAverage() {
  if (stationaryPositionHistory.length === 0) return null

  let totalWeight = 0
  let weightedLat = 0
  let weightedLng = 0

  // Calculate weighted average
  stationaryPositionHistory.forEach((pos, index) => {
    const weight = Math.pow(0.8, stationaryPositionHistory.length - index) // Exponential decay
    totalWeight += weight
    weightedLat += pos.lat * weight
    weightedLng += pos.lng * weight
  })

  return {
    lat: weightedLat / totalWeight,
    lng: weightedLng / totalWeight,
    accuracy: stationaryPositionHistory[stationaryPositionHistory.length - 1].accuracy, // Use latest accuracy
    timestamp: Date.now(),
  }
}

function setMoving() {
  isStationary = false
  stationaryPositionLocked = false
  kalmanFilter.setStationaryMode(false)

  if (stationaryLockTimeout) {
    clearTimeout(stationaryLockTimeout)
    stationaryLockTimeout = null
  }

  console.log("User is moving again")
}

function checkStationaryState(newPosition) {
  if (!lastPosition) return

  // Calculate distance between current and last position
  const distance = calculateDistance(lastPosition, newPosition)

  // Check if device motion sensors indicate movement
  const motionDetected = isDeviceInMotion()

  // If significant movement is detected or motion sensors indicate activity
  if (distance >= MICRO_MOVEMENT_THRESHOLD || motionDetected) {
    if (isStationary) {
      console.debug("Movement detected, transitioning to moving state")
      setMoving()
    }

    // Clear the stationary check timeout
    if (stationaryCheckTimeout) {
      clearTimeout(stationaryCheckTimeout)
      stationaryCheckTimeout = null
    }
  } else {
    // If no significant movement, increment stationary count
    stationaryCount++

    // If stationary count exceeds threshold, transition to stationary state
    if (!isStationary && stationaryCount >= STATIONARY_THRESHOLD) {
      setStationary(newPosition)
    }

    // Schedule the next stationary check
    if (isStationary && !stationaryCheckTimeout) {
      stationaryCheckTimeout = setTimeout(() => {
        stationaryCheckTimeout = null
        checkStationaryState(newPosition)
      }, STATIONARY_CHECK_INTERVAL)
    }
  }
}

// Predict position based on heading and speed
function predictPositionFromHeading(position, heading, distance) {
  // Input validation
  if (
    !position ||
    typeof heading !== "number" ||
    typeof distance !== "number" ||
    !position.lat ||
    !position.lng ||
    isNaN(heading) ||
    isNaN(distance)
  ) {
    return position
  }

  // Normalize heading to 0-360 range
  heading = ((heading % 360) + 360) % 360

  // Earth's radius in meters
  const R = 6371e3

  // Convert to radians
  const d = distance / R
  const θ = (heading * Math.PI) / 180
  const φ1 = (position.lat * Math.PI) / 180
  const λ1 = (position.lng * Math.PI) / 180

  // Calculate predicted position with error handling
  try {
    const sinφ1 = Math.sin(φ1)
    const cosφ1 = Math.cos(φ1)
    const cosd = Math.cos(d)
    const sind = Math.sin(d)
    const cosθ = Math.cos(θ)

    const φ2 = Math.asin(sinφ1 * cosd + cosφ1 * sind * cosθ)

    const λ2 = λ1 + Math.atan2(Math.sin(θ) * sind * cosφ1, cosd - sinφ1 * Math.sin(φ2))

    // Convert back to degrees with bounds checking
    const newLat = Math.max(-90, Math.min(90, (φ2 * 180) / Math.PI))
    const newLng = (((λ2 * 180) / Math.PI + 540) % 360) - 180

    return {
      lat: newLat,
      lng: newLng,
    }
  } catch (error) {
    // Fallback to original position if calculation fails
    return position
  }
}

// Determine if map should recenter
function shouldRecenter(map, marker) {
    const now = Date.now();
    if (now - lastRecenterTime < RECENTER_COOLDOWN) {
        return { needsRecenter: false };
    }
    
    if (!map || !marker) return { needsRecenter: false };
    
    const edgeInfo = isMarkerNearEdge(map, marker);
    const proximities = edgeInfo.proximities;
    
    // Check for critical edge proximity (very close to edge)
    const isCritical = Object.values(proximities).some(
        proximity => proximity < CRITICAL_EDGE_THRESHOLD
    );
    
    if (isCritical) {
        lastRecenterTime = now;
        return {
            needsRecenter: true,
            isEmergency: true,
            edgeInfo: edgeInfo
        };
    }
    
    // Check for normal edge proximity
    if (edgeInfo.isNearEdge) {
        lastRecenterTime = now;
        return {
            needsRecenter: true,
            isEmergency: false,
            edgeInfo: edgeInfo
        };
    }
    
    return {
        needsRecenter: false,
        isEmergency: false,
        edgeInfo: edgeInfo
    };
}

// Calculate optimal center point
function calculateOptimalCenter(map, markerPosition, edgeInfo) {
    const bounds = map.getBounds();
    
    // Calculate offsets based on which edges are being approached
    let latOffset = 0;
    let lngOffset = 0;
    
    // Apply stronger offset for the closest edge
    const proximities = edgeInfo.proximities;
    const edges = edgeInfo.edges;
    
    // Get viewport dimensions
    const viewportWidth = mapViewportWidth || map._container.clientWidth;
    const viewportHeight = mapViewportHeight || map._container.clientHeight;
    
    // Calculate aspect ratio to adjust offsets
    const aspectRatio = viewportWidth / viewportHeight;
    
    // Adjust offsets based on viewport dimensions
    const latSpan = bounds.getNorth() - bounds.getSouth();
    const lngSpan = bounds.getEast() - bounds.getWest();
    
    // Calculate offsets with consideration for viewport aspect ratio
    if (edges.north) {
        latOffset = -1 * latSpan * 0.25 * (1 / aspectRatio);
    }
    if (edges.south) {
        latOffset = latSpan * 0.25 * (1 / aspectRatio);
    }
    if (edges.east) {
        lngOffset = -1 * lngSpan * 0.25 * aspectRatio;
    }
    if (edges.west) {
        lngOffset = lngSpan * 0.25 * aspectRatio;
    }
    
    // Find the closest edge and apply extra offset
    const minProximity = Math.min(
        edges.north ? proximities.north : 1,
        edges.south ? proximities.south : 1,
        edges.east ? proximities.east : 1,
        edges.west ? proximities.west : 1
    );
    
    if (minProximity === proximities.north && edges.north) {
        latOffset *= 1.5;
    } else if (minProximity === proximities.south && edges.south) {
        latOffset *= 1.5;
    } else if (minProximity === proximities.east && edges.east) {
        lngOffset *= 1.5;
    } else if (minProximity === proximities.west && edges.west) {
        lngOffset *= 1.5;
    }
    
    return {
        lat: markerPosition.lat + latOffset,
        lng: markerPosition.lng + lngOffset
    };
}

function updateDistanceBox() {
  // Initial validation
  if (!userMarker || !gameLocations || gameLocations.length === 0) {
    document.getElementById("distanceBox").innerText = "Initializing..."
    return
  }

  // Get user coordinates
  const userLatLng = userMarker.getLatLng()
  let userLat = userLatLng.lat
  let userLng = userLatLng.lng

  // Coordinate validation
  if (!isFinite(userLat) || !isFinite(userLng)) {
    console.warn("Invalid user coordinates:", userLat, userLng)
    document.getElementById("distanceBox").innerText = "Initializing..."
    return
  }

  // Use map center if at origin
  if (userLat === 0 && userLng === 0) {
    const center = map.getCenter()
    userLat = center.lat
    userLng = center.lng
  }

  // Find closest location
  let closestDistance = Number.POSITIVE_INFINITY
  let closestLocation = null
  const userPos = { lat: userLat, lng: userLng }

  for (const location of gameLocations) {
    if (!location || typeof location.lat !== "number" || typeof location.lng !== "number") {
      console.warn("Invalid location data:", location)
      continue
    }

    const locationPos = { lat: location.lat, lng: location.lng }
    const distance = calculateDistance(userPos, locationPos)

    if (isFinite(distance) && distance < closestDistance) {
      closestDistance = distance
      closestLocation = location
    }
  }

  // Validate final distance calculation
  if (!isFinite(closestDistance) || closestDistance === Number.POSITIVE_INFINITY) {
    console.warn("Invalid distance calculation:", closestDistance)
    document.getElementById("distanceBox").innerText = "Initializing..."
    return
  }

  // Calculate and display distance
  const distanceFeet = Math.round(closestDistance * 3.28084)
  const distanceText =
    distanceFeet < 5280 ? `${distanceFeet.toLocaleString()} feet` : `${(distanceFeet / 5280).toFixed(2)} miles`

  document.getElementById("distanceBox").innerText = `Closest Stop: ${distanceText}`

  // Check if we should show location hunt
  if (distanceFeet <= DISTANCE_THRESHOLD && !isLocationHuntVisible && closestLocation) {
    console.log(`User is within threshold distance (${distanceFeet} feet). Opening location page.`)
    showLocationHunt(closestLocation)
  }
}

// Show error message
function showErrorMessage(message) {
  // Remove any existing error messages
  const existingErrors = document.querySelectorAll(".error-message")
  existingErrors.forEach((error) => {
    if (error.parentNode) {
      error.parentNode.removeChild(error)
    }
  })

  // Create new error message
  const errorMessage = document.createElement("div")
  errorMessage.className = "error-message"
  errorMessage.textContent = message
  document.body.appendChild(errorMessage)

  // Auto-remove after animation completes
  setTimeout(() => {
    if (errorMessage.parentNode) {
      errorMessage.parentNode.removeChild(errorMessage)
    }
  }, 5000)
}

const MAX_RETRIES = 3
const RETRY_DELAY = 1000

function getGeolocationOptions(retryNumber) {
  return {
    enableHighAccuracy: retryNumber < 2,
    timeout: 10000 + retryNumber * 5000,
    maximumAge: retryNumber * 5000,
  }
}

function handleLocationError(error) {
  console.warn("Error getting user location:", error)
  locationErrorCount++

  // Check if we've reached the maximum number of retries
  if (retryCount < MAX_RETRIES) {
    retryCount++
    console.log(`Retrying to get location (Attempt ${retryCount} of ${MAX_RETRIES})`)

    setTimeout(() => {
      navigator.geolocation.getCurrentPosition(
        (position) => {
          console.log("Location retrieved successfully after retry")
          hideLoadingMessage()
          updateUserLocation(position, true)
          retryCount = 0
          locationErrorCount = 0
        },
        handleLocationError,
        getGeolocationOptions(retryCount),
      )
    }, RETRY_DELAY)
    return
  }

  retryCount = 0
  hideLoadingMessage()

  // If we've had multiple errors, mark location as unavailable
  if (locationErrorCount > 3) {
    isLocationAvailable = false
  }

  let errorMessage = "An error occurred while getting your location."
  if (error && error.code) {
    switch (error.code) {
      case PERMISSION_DENIED_ERROR:
        errorMessage = "Please allow access to your location to use this feature."
        permissionDenied = true
        handleLocationPermissionDenied()
        break
      case POSITION_UNAVAILABLE_ERROR:
        errorMessage = "Your location is currently unavailable. Please check your GPS signal and try again."
        showErrorMessage(errorMessage)

        // Update GPS signal indicator
        domUpdateManager.schedule("accuracyIndicator", () => {
          const indicator = document.getElementById("accuracyIndicator")
          const dot = indicator.querySelector(".accuracy-dot")
          const text = document.getElementById("accuracyText")

          dot.classList.remove("accuracy-high", "accuracy-medium")
          dot.classList.add("accuracy-low")
          text.textContent = "GPS: Signal Lost"
        })
        break
      case TIMEOUT_ERROR:
        errorMessage = "Getting your location took too long. Please check your GPS signal and try again."
        showErrorMessage(errorMessage)
        break
      default:
        showErrorMessage(errorMessage)
        break
    }
  } else {
    showErrorMessage(errorMessage)
  }

  // Try to continue with last known position if available
  if (lastValidPosition) {
    console.log("Using last valid position due to location error")
    userMarker.setLatLng([lastValidPosition.lat, lastValidPosition.lng])
    updateDistanceBox()
  }
}

function showPopup(title, message, type = "info", callback = null) {
  const popup = document.createElement("div")
  popup.classList.add("popup")
  popup.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: white;
        padding: 20px;
        border-radius: 10px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        z-index: 2000;
        text-align: center;
        max-width: 80%;
    `

  const titleElement = document.createElement("h3")
  titleElement.textContent = title
  titleElement.style.cssText = `
        margin-bottom: 10px;
        font-size: 18px;
        font-weight: bold;
    `

  const messageElement = document.createElement("p")
  messageElement.textContent = message
  messageElement.style.cssText = `
        margin-bottom: 20px;
        font-size: 16px;
    `

  const buttonContainer = document.createElement("div")
  buttonContainer.style.cssText = `
        display: flex;
        justify-content: center;
        gap: 10px;
    `

  const okButton = document.createElement("button")
  okButton.textContent = "OK"
  okButton.style.cssText = `
        padding: 10px 20px;
        background-color: #0f2bab;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
    `

  okButton.addEventListener("click", () => {
    document.body.removeChild(popup)
    if (callback) callback()
  })

  buttonContainer.appendChild(okButton)

  if (type === "info") {
    const cancelButton = document.createElement("button")
    cancelButton.textContent = "Cancel"
    cancelButton.style.cssText = `
            padding: 10px 20px;
            background-color: #ccc;
            color: black;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        `

    cancelButton.addEventListener("click", () => {
      document.body.removeChild(popup)
    })

    buttonContainer.appendChild(cancelButton)
  }

  popup.appendChild(titleElement)
  popup.appendChild(messageElement)
  popup.appendChild(buttonContainer)
  document.body.appendChild(popup)
}

function recenterMap() {
  const recenterButton = document.getElementById("recenterButton")
  recenterButton.style.backgroundColor = "#0f2bab"
  recenterButton.style.color = "white"

  // Force map to center on user marker immediately
  if (userMarker && userMarker.getLatLng()) {
    map.closePopup()

    // Get dynamic zoom level based on current speed
    const dynamicZoom = calculateZoomLevel(currentSpeed)

    // Use flyTo instead of setView for smoother animation
    map.flyTo(userMarker.getLatLng(), dynamicZoom, {
      duration: 0.5,
    })

    followUser = true

    // Make sure any other code knows the map has been recentered
    if (typeof onMapRecentered === "function") {
      onMapRecentered()
    }
  }

  setTimeout(() => {
    recenterButton.style.backgroundColor = "white"
    recenterButton.style.color = "#0f2bab"
  }, 500)
}

function addUIEventListeners() {
  document.getElementById("recenterButton").addEventListener("click", () => {
    recenterMap()
    resetInactivityTimer()
  })
  document.getElementById("returnButton").addEventListener("click", () => {
    returnToIndex()
    resetInactivityTimer()
  })
  document.getElementById("tipsButton").addEventListener("click", () => {
    toggleNavigationTips()
    resetInactivityTimer()
  })
  document.querySelector(".navigation-tips .close-button").addEventListener("click", () => {
    closeNavigationTips()
    resetInactivityTimer()
  })
}

function addMapEventListeners() {
  const startInteraction = () => {
    isMapInteracting = true
    userIsInteracting = true
    followUser = false
    resetInactivityTimer()
  }

  map.on("movestart zoomstart dragstart", startInteraction)
}

function resetInactivityTimer() {
  clearTimeout(window.inactivityTimer)
  window.inactivityTimer = setTimeout(checkInactivity, INACTIVITY_TIMEOUT)
}

function checkInactivity() {
  console.log("Inactivity timer triggered")
  isMapInteracting = false
  userIsInteracting = false

  // Close any open popups
  map.closePopup()
  map.eachLayer((layer) => {
    if (layer.getPopup && layer.getPopup()?.isOpen()) {
      layer.closePopup()
    }
  })

  if (!isMapInteracting && !userIsInteracting) {
    recenterMap()
  }
}

function closeAllPopups() {
  if (map) {
    map.closePopup()
  }
}

let lastVisitTime = 0
const cooldownPeriod = 3 * 60 * 1000

function showLocationHunt(location) {
  const now = performance.now()
  if (location.id === lastVisitedLocationId && now - lastVisitTime < cooldownPeriod) {
    console.log(`Location ${location.id} is on cooldown. Skipping.`)
    return
  }

  lastVisitedLocationId = location.id
  lastVisitTime = now
  isLocationHuntVisible = true

  // Use DOM batch updates for better performance
  domUpdateManager.schedule("locationHunt", () => {
    const lochuntContainer = document.querySelector(".lochunt-container")
    lochuntContainer.innerHTML = ""
    lochuntContainer.style.cssText = `
            display: flex;
            flex-direction: column;
            height: 100%;
            overflow: hidden;
            background-color: #fff;
            max-width: 1200px;
            margin: 0 auto;
            box-shadow: 0 2px 20px rgba(0,0,0,0.025);
            will-change: transform;
        `

    // Add transition class
    lochuntContainer.classList.add("location-transition")

    // Trigger reflow to ensure transition works
    void lochuntContainer.offsetWidth

    // Make visible with transition
    lochuntContainer.classList.add("visible")

    const scrollableContent = document.createElement("div")
    scrollableContent.style.cssText = `
            flex: 1;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            scroll-behavior: smooth;
            will-change: scroll-position;
        `

    // Use preloaded image if available
    const locationImage = document.createElement("img")
    if (preloadedImages.has(location.image)) {
      locationImage.src = location.image
    } else {
      locationImage.src = location.image
      // Preload for next time
      const img = new Image()
      img.crossOrigin = "anonymous" // Set crossOrigin for canvas operations
      img.src = location.image
      preloadedImages.set(location.image, img)
    }
    locationImage.alt = location.name
    locationImage.style.cssText = `
            width: 100%;
            height: 45vh;
            object-fit: cover;
            object-position: center;
        `

    scrollableContent.appendChild(locationImage)

    const contentContainer = document.createElement("div")
    contentContainer.classList.add("lochunt-content")
    contentContainer.style.cssText = `
            padding: 24px;
            display: flex;
            flex-direction: column;
            align-items: center;
            max-width: 800px;
            margin: 0 auto;
        `
    const locationInfo = document.createElement("div")
    locationInfo.classList.add("lochunt-info")
    locationInfo.style.cssText = `
            text-align: center;
            width: 100%;
            margin-bottom: 15px;
        `
    const locationName = document.createElement("h1")
    locationName.textContent = location.name
    locationName.style.cssText = `
            font-size: clamp(1.8rem, 4vw, 2.5rem);
            font-weight: 700;
            color: #1a1a1a;
            margin-bottom: 8px;
            line-height: 1.2;
        `
    const locationCity = document.createElement("p")
    locationCity.textContent = `${location.city}`
    locationCity.style.cssText = `
           font-size: clamp(1.1rem, 2vw, 1.3rem);
            color: #ff0000;
            font-weight: 600;
            margin-bottom: 4px;
        `
    const locationCreator = document.createElement("p")
    locationCreator.textContent = `Created by: ${location.creator}`
    locationCreator.style.cssText = `
            font-size: calc(0.9rem + 0.4vw);
            color: #666666;
            font-weight: 500;
        `
    locationInfo.appendChild(locationName)
    locationInfo.appendChild(locationCity)
    locationInfo.appendChild(locationCreator)
    contentContainer.appendChild(locationInfo)
    const audioPlayerContainer = createAudioPlayer(location.audio)
    contentContainer.appendChild(audioPlayerContainer)
    scrollableContent.appendChild(contentContainer)
    lochuntContainer.appendChild(scrollableContent)
    const blueBar = createBlueBar(location)
    blueBar.style.cssText += `
            position: sticky;
            bottom: 0;
            width: 100%;
        `
    lochuntContainer.appendChild(blueBar)

    // Initialize audio player after DOM is updated
    requestAnimationFrame(initAudioPlayer)
  })
}

function createAudioPlayer(audioSrc) {
  const audioPlayerContainer = document.createElement("div")
  audioPlayerContainer.classList.add("audio-player")
  audioPlayerContainer.style.cssText = `
        width: 100%;
        max-width: 400px;
        margin-bottom: 15px;
    `

  const audio = document.createElement("audio")
  audio.id = "locationAudio"

  // Use preloaded audio if available
  if (preloadedAudio.has(audioSrc)) {
    audio.src = audioSrc
  } else {
    audio.src = audioSrc
    // Preload for next time
    const audioPreload = new Audio()
    audioPreload.preload = "auto"
    audioPreload.src = audioSrc
    preloadedAudio.set(audioSrc, audioPreload)
  }

  const audioProgress = document.createElement("div")
  audioProgress.classList.add("audio-progress")
  audioProgress.style.cssText = `
        width: 100%;
        margin-bottom: 15px;
    `

  const progressContainer = document.createElement("div")
  progressContainer.classList.add("progress")
  progressContainer.style.cssText = `
        height: 8px;
        background-color: #e2e8f0;
        border-radius: 4px;
        cursor: pointer;
        margin-bottom: 12px;
        overflow: hidden;
    `

  const progressBar = document.createElement("div")
  progressBar.id = "progressBar"
  progressBar.classList.add("progress-bar")
  progressBar.style.cssText = `
        height: 100%;
        background-color: #ff0000;
        width: 0%;
        transition: width 0.1s linear;
    `

  progressContainer.appendChild(progressBar)
  audioProgress.appendChild(progressContainer)

  const timeInfo = document.createElement("div")
  timeInfo.classList.add("audio-time")
  timeInfo.style.cssText = `
        display: flex;
        justify-content: space-between;
        color: #4a5568;
        font-size: 0.875rem;
        margin-bottom: 16px;
        font-weight: 500;
    `

  const currentTimeSpan = document.createElement("span")
  currentTimeSpan.id = "currentTime"
  currentTimeSpan.textContent = "0:00"

  const durationSpan = document.createElement("span")
  durationSpan.id = "duration"
  durationSpan.textContent = "0:00"

  timeInfo.appendChild(currentTimeSpan)
  timeInfo.appendChild(durationSpan)

  const audioControls = document.createElement("div")
  audioControls.classList.add("audio-controls")
  audioControls.style.cssText = `
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 24px;
    `

  const rewindBtn = createAudioButton("skip-backward", "rewindBtn")
  const playPauseBtn = createAudioButton("play", "playPauseBtn")
  const forwardBtn = createAudioButton("skip-forward", "forwardBtn")

  audioControls.appendChild(rewindBtn)
  audioControls.appendChild(playPauseBtn)
  audioControls.appendChild(forwardBtn)

  audioPlayerContainer.appendChild(audio)
  audioPlayerContainer.appendChild(audioProgress)
  audioPlayerContainer.appendChild(timeInfo)
  audioPlayerContainer.appendChild(audioControls)

  return audioPlayerContainer
}

function createAudioButton(iconName, id) {
  const button = document.createElement("button")
  button.id = id
  button.classList.add("audio-button")
  button.innerHTML = `<i class="bi bi-${iconName}"></i>`
  button.style.cssText = `
background-color: white;
color: #0000ff;
border: 2px solid #0000ff;
border-radius: 50%;
width: 55px;
height: 55px;
display: flex;
align-items: center;
justify-content: center;
cursor: pointer;
transition: all 0.3s ease;
    `

  button.addEventListener("mouseover", () => {
    button.style.backgroundColor = "rgba(0, 0, 255, 0.1)"
  })

  button.addEventListener("mouseout", () => {
    button.style.backgroundColor = "white"
  })

  button.addEventListener("click", () => {
    button.style.backgroundColor = "#0000ff"
    button.style.color = "white"
    button.style.transform = "scale(0.95)"

    setTimeout(() => {
      button.style.backgroundColor = "white"
      button.style.color = "#0000ff"
      button.style.transform = "scale(1)"
    }, 200)
  })

  return button
}

function createBlueBar(location) {
  const blueBar = document.createElement("div")
  blueBar.style.cssText = `
        width: 100%;
        height: 60px;
        background: linear-gradient(to right, #0a1f80, #0f2bab);
        margin-top: auto;
        box-shadow: 0 -2px 10px rgba(0,0,0,0.025);
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0 24px;
        position: sticky;
        bottom: 0;
    `

  const infoButton = document.createElement("button")
  infoButton.innerHTML = '<i class="bi bi-info-circle-fill text-white" style="font-size: 1.5rem; z-index: 2500;"></i>'
  infoButton.classList.add("btn", "btn-sm", "me-2")
  infoButton.onclick = () => {
    if (location && location.imageSource) {
      showPopup("Image Source", location.imageSource)
    } else {
      showPopup("Image Source", "Image source information is not available")
    }
  }

  const feedbackButton = document.createElement("a")
  feedbackButton.href = "mailto:mattreicher@protonmail.com?subject=Feedback"
  feedbackButton.target = "_blank"
  feedbackButton.rel = "noopener noreferrer"
  feedbackButton.innerHTML = '<i class="bi bi-envelope-fill text-white" style="font-size: 1.5rem;"></i>'
  feedbackButton.classList.add("btn", "btn-sm")

  blueBar.appendChild(infoButton)
  blueBar.appendChild(feedbackButton)
  return blueBar
}

function initAudioPlayer() {
  const audio = document.getElementById("locationAudio")
  const playPauseBtn = document.getElementById("playPauseBtn")
  const rewindBtn = document.getElementById("rewindBtn")
  const forwardBtn = document.getElementById("forwardBtn")
  const progressBar = document.getElementById("progressBar")
  const progressContainer = document.querySelector(".progress")
  const currentTimeSpan = document.getElementById("currentTime")
  const durationSpan = document.getElementById("duration")

  if (
    !audio ||
    !playPauseBtn ||
    !rewindBtn ||
    !forwardBtn ||
    !progressBar ||
    !progressContainer ||
    !currentTimeSpan ||
    !durationSpan
  ) {
    console.warn("Audio player elements not found, retrying...")
    requestAnimationFrame(initAudioPlayer)

    return
  }

  // Debounce progress updates to reduce DOM operations
  let lastProgressUpdate = 0
  const PROGRESS_UPDATE_INTERVAL = 250 // ms

  playPauseBtn.addEventListener("click", togglePlay)
  rewindBtn.addEventListener("click", () => seek(-10))
  forwardBtn.addEventListener("click", () => seek(10))

  // Use throttled event listener for time  () => seek(10));

  // Use throttled event listener for timeupdate
  audio.addEventListener("timeupdate", () => {
    const now = Date.now()
    if (now - lastProgressUpdate > PROGRESS_UPDATE_INTERVAL) {
      lastProgressUpdate = now
      updateProgress()
    }
  })

  audio.addEventListener("loadedmetadata", setDuration)
  audio.addEventListener("ended", () => {
    domUpdateManager.schedule("playPauseBtn", () => {
      playPauseBtn.innerHTML = '<i class="bi bi-play"></i>'
    })
    showAdditionalInfo()
  })

  // Handle audio loading errors
  audio.addEventListener("error", (e) => {
    console.error("Audio loading error:", e)
    showErrorMessage("Error loading audio. Please check your connection and try again.")
  })

  // Use event delegation for progress container clicks
  progressContainer.addEventListener("click", setProgress)

  function togglePlay() {
    if (audio.paused) {
      const playPromise = audio.play()
      if (playPromise !== undefined) {
        playPromise
          .then(() => {
            domUpdateManager.schedule("playPauseBtn", () => {
              playPauseBtn.innerHTML = '<i class="bi bi-pause"></i>'
            })
          })
          .catch((error) => {
            console.error("Audio playback failed:", error)
            showErrorMessage("Audio playback failed. Please try again.")
          })
      }
    } else {
      audio.pause()
      domUpdateManager.schedule("playPauseBtn", () => {
        playPauseBtn.innerHTML = '<i class="bi bi-play"></i>'
      })
    }
  }

  function seek(seconds) {
    audio.currentTime = Math.max(0, Math.min(audio.currentTime + seconds, audio.duration))
  }

  function updateProgress() {
    const percent = (audio.currentTime / audio.duration) * 100
    domUpdateManager.schedule("audioProgress", () => {
      progressBar.style.width = `${percent}%`
      currentTimeSpan.textContent = formatTime(audio.currentTime)
    })
  }

  function setProgress(e) {
    const width = this.clientWidth
    const clickX = e.offsetX
    const duration = audio.duration
    audio.currentTime = (clickX / width) * duration
  }

  function setDuration() {
    domUpdateManager.schedule("audioDuration", () => {
      durationSpan.textContent = formatTime(audio.duration)
    })
  }

  function formatTime(time) {
    const minutes = Math.floor(time / 60)
    const seconds = Math.floor(time % 60)
    return `${minutes}:${seconds.toString().padStart(2, "0")}`
  }
}

function showAdditionalInfo() {
  // Find the location using lastVisitedLocationId
  const location = gameLocations.find((loc) => loc.id === lastVisitedLocationId)
  console.log("Current location:", location)

  // Set flag to indicate we're returning from exhibit
  isReturningFromExhibit = true

  domUpdateManager.schedule("additionalInfo", () => {
    const additionalInfoContainer = document.querySelector(".additional-info-container")
    additionalInfoContainer.style.display = "block"

    // Add transition class
    additionalInfoContainer.classList.add("location-transition")

    // Trigger reflow to ensure transition works
    void additionalInfoContainer.offsetWidth

    // Make visible with transition
    additionalInfoContainer.classList.add("visible")

    document.getElementById("additionalInfo").textContent = location.additionalInfo

    const continueButton = document.getElementById("continueButton")
    continueButton.onclick = () => {
      // Fade out with transition
      additionalInfoContainer.classList.remove("visible")

      // Hide after transition completes
      setTimeout(() => {
        additionalInfoContainer.style.display = "none"

        // Also hide location hunt container with transition
        const lochuntContainer = document.querySelector(".lochunt-container")
        lochuntContainer.classList.remove("visible")

        setTimeout(() => {
          lochuntContainer.style.display = "none"
          isLocationHuntVisible = false
          updateDistanceBox()
        }, 500)
      }, 500)
    }
  })
}

function showDirectionsModal(lat, lng) {
  const modal = document.getElementById("directionsModal")
  modal.style.display = "block"

  const mapBtn = document.getElementById("mapButton")
  const cancelBtn = document.getElementById("cancelButton")

  mapBtn.onclick = () => {
    window.open(`https://www.google.com/maps/dir/?api=1&destination=${lat},${lng}`, "_blank")
    modal.style.display = "none"
  }

  cancelBtn.onclick = () => {
    modal.style.display = "none"
  }

  window.onclick = (event) => {
    if (event.target == modal) {
      modal.style.display = "none"
    }
  }
}

function showLocationSummary(locationId) {
  console.log("Showing summary for location ID:", locationId)
  console.log("All locations:", gameLocations)
  console.log(
    "Location IDs:",
    gameLocations.map((loc) => loc.id),
  )
  console.log("Location ID type:", typeof locationId)
  console.log("Location ID type:", typeof gameLocations[0].id)
  const location = gameLocations.find((loc) => loc.id === locationId)
  console.log("Found location:", location)
  if (location && location.summary) {
    domUpdateManager.schedule("summaryModal", () => {
      const modal = document.getElementById("summaryModal")
      const summaryContent = document.getElementById("summaryContent")
      modal.style.backgroundColor = "rgba(0, 0, 0, 0.5)"
      modal.style.display = "flex"
      modal.style.justifyContent = "center"
      modal.style.alignItems = "center"
      const modalContent = modal.querySelector(".modal-content")
      modalContent.style.cssText = `
                background-color: white;
                padding: 30px;
                border-radius: 10px;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.025);
                max-width: 500px;
                width: 90%;
                max-height: 80vh;
                overflow-y: auto;
            `
      const closeBtn = modal.querySelector(".close")
      if (closeBtn) {
        closeBtn.remove()
      }
      summaryContent.style.textAlign = "left"
      summaryContent.innerHTML = `
               <h3 class="summary-heading" style="font-size: 22px; margin-bottom: 15px; text-align: center;">${location.name}</h3>
                <p style="line-height: 1.6; margin-bottom: 15px;">
                    ${location.summary}
                </p>
                <p style="line-height: 1.6; margin-bottom: 15px;">
                    <strong>Location:</strong> ${location.today}
                </p>
            `

      const continueButton = document.createElement("button")
      continueButton.textContent = "Continue"
      continueButton.className = "summary-button"
      continueButton.style.cssText = `
                display: block;
                width: auto;
                padding: 12px 20px;
                color: white;
                border: none;
                border-radius: 10px;
                cursor: pointer;
                font-size: 18px;
                font-weight: bold;
                transition: background-color 0.3s ease;
                margin: 10px auto -15px;
            `
      continueButton.onclick = () => {
        modal.style.display = "none"
      }
      summaryContent.appendChild(continueButton)
      modal.style.display = "flex"
      window.onclick = (event) => {
        if (event.target === modal) {
          modal.style.display = "none"
        }
      }
    })
  } else {
    console.log("Location or summary not found. Location ID:", locationId)
    console.log(
      "Available IDs:",
      gameLocations.map((loc) => loc.id),
    )
    showPopup("Error", "Summary not available for this location.")
  }
}

function startHunt() {
  // Check network status before starting
  if (!navigator.onLine) {
    showErrorMessage("No internet connection. Please connect to the internet and try again.")

    // Set a timeout to retry
    setTimeout(() => {
      if (navigator.onLine) {
        startHunt()
      }
    }, 5000)

    return
  }

  try {
    gameLocations = locations.sort((a, b) => a.id - b.id)
    currentLocationIndex = 0
    locationCooldowns = {}
    lastVisitedLocationId = null

    // Preload all location images before starting
    preloadImages(gameLocations)
      .then(() => {
        // Hide preloader when images are loaded
        const preloader = document.getElementById("preloader")
        if (preloader) {
          preloader.style.opacity = "0"
          preloader.style.transition = "opacity 0.5s ease"
          setTimeout(() => {
            if (preloader && preloader.parentNode) {
              preloader.parentNode.removeChild(preloader)
            }
          }, 500)
        }

        loadAllLocations()
      })
      .catch((error) => {
        console.error("Error preloading images:", error)
        showErrorMessage("Error loading resources. Please check your connection and try again.")

        // Try to continue anyway after a delay
        setTimeout(() => {
          loadAllLocations()
        }, 3000)
      })
  } catch (error) {
    console.error("Error starting hunt:", error)
    showErrorMessage("Error starting the experience. Please reload the page.")
  }
}

function getMarkerColor(tours) {
  switch (tours.toLowerCase()) {
    case "person":
      return "#FFA500"
    case "gangster":
      return "#3f9b0b"
    case "event":
      return "#8B0000"
    case "place":
      return "#0f2bab"
    default:
      return "#0f2bab"
  }
}

const showAlert = (message) => {
  const alertEl = document.createElement("div")
  alertEl.className = "modal"
  alertEl.innerHTML = `
       <div class="modal-content">
           <p>${message}</p>
           <button class="modal-button">OK</button>
       </div>
   `
  document.body.appendChild(alertEl)
  alertEl.querySelector("button").onclick = () => {
    alertEl.remove()
    // Show directions modal again
    routeButton.click()
  }
}

function loadAllLocations() {
  try {
    gameLocations.forEach((location, index) => {
      const markerColor = getMarkerColor(location.tours)

      const locationMarker = L.marker([location.lat, location.lng], {
        icon: L.divIcon({
          className: "custom-pin-icon",
          html: `<div class="pin-head" style="background-color: ${markerColor};">
                           </div>`,
          iconSize: [30, 30],
          iconAnchor: [15, 30],
        }),
      })

      const popupContent = `
                <div class="popup-content">
                    <img src="${location.image}" alt="${location.name}" class="location-image">
                    <h4 class="location-name">
                        <a href="${location.link}" target="_blank" rel="noopener noreferrer" style="text-decoration: none; color: inherit;">${location.name}</a>
                    </h4>
                    <div class="popup-buttons">
                        <button class="button route-button" data-lat="${location.lat}" data-lng="${location.lng}">Directions</button>
                        <button class="button summary-button" data-location-id="${location.id}">Summary</button>
                    </div>
                </div>
            `
      locationMarker.bindPopup(popupContent, {
        offset: L.point(0, -25),
        className: "custom-popup",
      })

      locationMarker.on("popupopen", (e) => {
        const popup = e.popup._contentNode
        const routeButton = popup.querySelector(".route-button")
        const summaryButton = popup.querySelector(".summary-button")

        if (routeButton) {
          routeButton.addEventListener("click", function (event) {
            event.preventDefault()
            const lat = this.getAttribute("data-lat")
            const lng = this.getAttribute("data-lng")

            // Create and show the modal
            const modal = document.createElement("div")
            modal.className = "modal"
            modal.innerHTML = `
                            <div class="modal-content">
                                <h3>Choose your preferred navigation app:</h3>
                                <div class="navigation-options">
                                    <button id="googleMapsBtn" class="nav-button">
                                        <i class="bi bi-map"></i> Google Maps
                                    </button>
                                    <button id="appleMapsBtn" class="nav-button">
                                        <i class="bi bi-map-fill"></i> Apple Maps
                                    </button>
                                    <button id="wazeBtn" class="nav-button">
                                        <i class="bi bi-signpost-2"></i> Waze
                                    </button>
                                    <button id="cancelNavBtn" class="nav-button cancel">
                                        <i class="bi bi-x-circle"></i> Cancel
                                    </button>
                                </div>
                            </div>
                        `
            modal.style.cssText = `
                            position: fixed;
                            top: 0;
                            left: 0;
                            width: 100%;
                            height: 100%;
                            background-color: rgba(0, 0, 0, 0.5);
                            display: flex;
                            justify-content: center;
                            align-items: center;
                            z-index: 2000;
                        `
            document.body.appendChild(modal)

            const modalContent = modal.querySelector(".modal-content")
            modalContent.style.cssText = `
                            background-color: white;
                            padding: 20px;
                            border-radius: 10px;
                            max-width: 90%;
                            width: 350px;
                            text-align: center;
                        `

            const navigationOptions = modal.querySelector(".navigation-options")
            navigationOptions.style.cssText = `
                            display: flex;
                            flex-direction: column;
                            gap: 10px;
                            margin-top: 15px;
                        `

            const navButtons = modal.querySelectorAll(".nav-button")
            navButtons.forEach((button) => {
              button.style.cssText = `
                                padding: 12px;
                                border: none;
                                border-radius: 8px;
                                background-color: #0f2bab;
                                color: white;
                                font-size: 16px;
                                cursor: pointer;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                gap: 10px;
                            `
            })

            const cancelBtn = modal.querySelector(".cancel")
            cancelBtn.style.backgroundColor = "#ccc"
            cancelBtn.style.color = "#333"

            // Add event listeners
            modal.querySelector("#googleMapsBtn").addEventListener("click", () => {
              window.open(`https://www.google.com/maps/dir/?api=1&destination=${lat},${lng}`, "_blank")
              document.body.removeChild(modal)
            })

            modal.querySelector("#appleMapsBtn").addEventListener("click", () => {
              window.open(`https://maps.apple.com/?daddr=${lat},${lng}`, "_blank")
              document.body.removeChild(modal)
            })

            modal.querySelector("#wazeBtn").addEventListener("click", () => {
              window.open(`https://waze.com/ul?ll=${lat},${lng}&navigate=yes`, "_blank")
              document.body.removeChild(modal)
            })

            modal.querySelector("#cancelNavBtn").addEventListener("click", () => {
              document.body.removeChild(modal)
            })

            // Close modal when clicking outside
            modal.addEventListener("click", (e) => {
              if (e.target === modal) {
                document.body.removeChild(modal)
              }
            })
          })
        }

        if (summaryButton) {
          summaryButton.addEventListener("click", function (event) {
            event.preventDefault()
            const locationId = this.getAttribute("data-location-id")
            showLocationSummary(locationId)
          })
        }
      })

      markerClusterGroup.addLayer(locationMarker)
    })

    // Add UI event listeners
    addUIEventListeners()
    addMapEventListeners()

    // Start inactivity timer
    resetInactivityTimer()

    // Update distance box
    updateDistanceBox()
  } catch (error) {
    console.error("Error loading locations:", error)
    showErrorMessage("Error loading locations. Please try again later.")
  }
}

function toggleNavigationTips() {
  const tips = document.querySelector(".navigation-tips")
  tips.style.display = tips.style.display === "block" ? "none" : "block"
}

function closeNavigationTips() {
  document.querySelector(".navigation-tips").style.display = "none"
}

function returnToIndex() {
  showPopup("Confirm", "Are you ready to exit?", "info", () => {
    window.location.href = "/index.html"
  })
  document.getElementById("returnButton").classList.remove("active")
}

// Initialize the map when the page loads
window.addEventListener("load", () => {
  try {
    initMap()

    // Check if the browser supports the required features
    if (!navigator.geolocation) {
      showErrorMessage("Your browser doesn't support geolocation. Please use a modern browser.")
    }

    // Check network status
    if (!navigator.onLine) {
      showErrorMessage("No internet connection. Some features may not work properly.")
    }
  } catch (error) {
    console.error("Error initializing app:", error)
    showErrorMessage("Error initializing the app. Please reload the page.")
  }
})

// Save map state before unloading
window.addEventListener("beforeunload", () => {
  try {
    // Save current map state
    if (map && map.getCenter()) {
      const center = map.getCenter()
      const zoom = map.getZoom()

      // Save to session storage
      sessionStorage.setItem(
        "mapCenter",
        JSON.stringify({
          lat: center.lat,
          lng: center.lng,
        }),
      )
      sessionStorage.setItem("mapZoom", zoom)
    }
  } catch (error) {
    console.error("Error saving map state:", error)
  }
})

// Handle orientation changes
window.addEventListener("orientationchange", () => {
  // Delay to allow the browser to complete the orientation change
  setTimeout(() => {
    if (map) {
      map.invalidateSize()

      // Recenter map if following user
      if (followUser && userMarker) {
        map.setView(userMarker.getLatLng(), map.getZoom())
      }
    }
  }, 200)
})

// Handle resize events
window.addEventListener("resize", () => {
  // Throttle resize events
  if (!window.resizeThrottled) {
    window.resizeThrottled = true

    setTimeout(() => {
      if (map) {
        map.invalidateSize()
      }
      window.resizeThrottled = false
    }, 200)
  }
})

// Handle online/offline events
window.addEventListener("online", () => {
  const networkStatus = document.getElementById("networkStatus")
  networkStatus.classList.remove("offline")
  networkStatus.title = "Online"
  showErrorMessage("Internet connection restored")

  // Retry loading resources if needed
  if (gameLocations.length === 0) {
    startHunt()
  }
})

window.addEventListener("offline", () => {
  const networkStatus = document.getElementById("networkStatus")
  networkStatus.classList.add("offline")
  networkStatus.title = "Offline"
  showErrorMessage("No internet connection. Some features may not work properly.")
})
    </script>
</body>
</html>
