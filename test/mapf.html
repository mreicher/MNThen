<!DOCTYPE html>
<html lang="en">
<head> 
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Minnesota Then | Museum Without Walls</title>
    <link rel="shortcut icon" type="image/x-icon" href="https://www.mnthen.com/images/mnthenfav.ico">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css">
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css" />
    <link rel="stylesheet" href="https://www.mnthen.com/css/mainmap.css">
    <style>
        .user-marker-icon {
            width: 20px;
            height: 20px;
            background-color: #ff0000; /* Red user icon */
            border: 3px solid white;
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            position: relative;
            transition: transform 0.3s cubic-bezier(0.25, 0.1, 0.25, 1);
            will-change: transform;
        }
        
        .user-marker-icon::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 30px;
            height: 30px;
            background-color: rgba(255, 0, 0, 0.2); /* Red with opacity */
            border-radius: 50%;
            transform: translate(-50%, -50%);
            animation: pulse 2s infinite;
            will-change: transform, opacity;
        }
        
        @keyframes pulse {
            0% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
            100% {
                transform: translate(-50%, -50%) scale(2);
                opacity: 0;
            }
        }
        
        .stabilizing-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            z-index: 2000;
            text-align: center;
            max-width: 80%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .stabilizing-modal h3 {
            margin-bottom: 15px;
            color: #ff0000; /* Red */
        }
        
        .stabilizing-modal p {
            margin-bottom: 20px;
        }
        
        .stabilizing-modal .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255, 0, 0, 0.2); /* Red with opacity */
            border-top: 4px solid #ff0000; /* Red */
            border-radius: 50%;
            margin-bottom: 20px;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Preloader styles */
        #preloader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }

        #preloader .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(255, 0, 0, 0.2);
            border-top: 5px solid #ff0000;
            border-radius: 50%;
            margin-bottom: 20px;
            animation: spin 1s linear infinite;
        }

        #preloader p {
            font-size: 18px;
            color: #333;
            margin-top: 15px;
        }

        #preloader .progress-container {
            width: 80%;
            max-width: 300px;
            height: 10px;
            background-color: #f0f0f0;
            border-radius: 5px;
            margin-top: 15px;
            overflow: hidden;
        }

        #preloader .progress-bar {
            height: 100%;
            background-color: #ff0000;
            width: 0%;
            transition: width 0.3s ease;
        }

        /* Dark blue color for summary elements */
        .summary-heading {
            color: #0f2bab !important;
        }

        .summary-button {
            background-color: #0f2bab !important;
        }

        .summary-button:hover {
            background-color: #0a1f80 !important;
        }
        
        /* Optimize for hardware acceleration */
        #map, .user-marker-icon, .lochunt-container, .additional-info-container {
            transform: translateZ(0);
            backface-visibility: hidden;
            perspective: 1000px;
        }
        
        /* Stationary indicator - removed green glow and modified for consistent appearance */
        .user-marker-stationary .user-marker-icon {
            /* Keep the same red color and white border */
            border-color: white;
        }
        
        .user-marker-stationary .user-marker-icon::after {
            /* Keep the same red pulse effect */
            background-color: rgba(255, 0, 0, 0.2);
            animation: pulse 2s infinite;
        }
        
        /* Center the "Did you know?" modal */
        .additional-info-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            z-index: 2000;
            text-align: center;
            max-width: 80%;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            display: none;
        }
        
/* Green route button and dark blue summary button */
.button.route-button {
    background-color: #1b5e20 !important; /* Dark green color */
    color: white !important;
    border: none !important;
    padding: 8px 15px !important;
    border-radius: 0px !important;
    cursor: pointer !important;
    font-weight: 500 !important;
    transition: background-color 0.3s ease !important;
}

.button.summary-button {
    background-color: #0f2bab !important; /* Dark blue color */
    color: white !important;
    border: none !important;
    padding: 8px 15px !important;
    border-radius: 0px !important;
    cursor: pointer !important;
    font-weight: 500 !important;
    transition: background-color 0.3s ease !important;
}

.button.route-button:hover {
    background-color: #0d3c12 !important; /* Darker green on hover */
}

.button.summary-button:hover {
    background-color: #0a1f80 !important; /* Darker blue on hover */
}
        
        .custom-popup .popup-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
        }

        /* Error message styles */
        .error-message {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(255, 59, 48, 0.9);
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 2500;
            max-width: 90%;
            text-align: center;
            font-weight: 500;
            animation: fadeInOut 5s forwards;
            pointer-events: none;
        }

        @keyframes fadeInOut {
            0% { opacity: 0; transform: translate(-50%, -20px); }
            10% { opacity: 1; transform: translate(-50%, 0); }
            90% { opacity: 1; transform: translate(-50%, 0); }
            100% { opacity: 0; transform: translate(-50%, -20px); }
        }

        /* Location transition styles */
        .location-transition {
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .location-transition.visible {
            opacity: 1;
        }

/* Confidence indicator styles */
#accuracyIndicator {
    position: fixed;
    top: 10px;
    left: 10px;
    background-color: rgba(255, 255, 255, 0.8);
    padding: 5px 10px;
    border-radius: 15px;
    font-size: 12px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    z-index: 1000;
    display: flex;
    align-items: center;
    pointer-events: none;
}
.accuracy-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    margin-right: 5px;
}
.accuracy-high {
    background-color: #4CD964; /* Green */
}
.accuracy-medium {
    background-color: #FFCC00; /* Yellow */
}
.accuracy-low {
    background-color: #FF3B30; /* Red */
}

/* Remove ALL motion for reduced-motion users */
@media (prefers-reduced-motion: reduce) {
  /* Disable smooth user icon movement */
  .user-marker {
    transition: none !important;
  }
  
  /* Disable auto-recenter animation */
  .map-recenter {
    scroll-behavior: auto !important;
  }
  
  /* Replace spinner with static text */
  .spinner {
    animation: none !important;
    border: 3px solid rgba(255,0,0,0.3); /* Static red circle */
  }
  .spinner::after {
    content: "Loading...";
    display: block;
    margin-top: 10px;
  }
}
    </style>
</head>
<body>
    <!-- Preloader -->
    <div id="preloader">
        <div class="spinner"></div>
        <p>Loading Minnesota Then...</p>
        <div class="progress-container">
            <div class="progress-bar" id="preloaderProgress"></div>
        </div>
    </div>

    <div id="map"></div>
    <div id="distanceBox">Initializing...</div>
    <div id="networkStatus" title="Network Status"></div>
    <div id="accuracyIndicator"><span class="accuracy-dot accuracy-medium"></span><span id="accuracyText">GPS Signal</span></div>

    <div class="lochunt-container location-transition">
        <img id="locationImage" src="" alt="Location Image">
        <div class="lochunt-content">
            <div class="lochunt-info">
                <h2 id="locationTitle" class="mb-2 text-primary"></h2>
                <p id="locationCity" class="text-muted mb-1"></p>
                <p id="locationCreator" class="text-muted mb-3"></p>
            </div>
            <div class="audio-player">
                <div class="audio-progress">
                    <div class="progress">
                        <div id="progressBar" class="progress-bar" role="progressbar" style="width: 0%"></div>
                    </div>
                </div>
                <div class="audio-time">
                    <span id="currentTime">0:00</span>
                    <span id="duration">0:00</span>
                </div>
                <div class="audio-controls">
                    <button id="rewindBtn" class="audio-button"><i class="fas fa-backward"></i></button>
                    <button id="playPauseBtn" class="audio-button"><i class="fas fa-play"></i></button>
                    <button id="forwardBtn" class="audio-button"><i class="fas fa-forward"></i></button>
                </div>
                <audio id="locationAudio" src=""></audio>
            </div>
        </div>
    </div>
    
    <div class="additional-info-container location-transition">
       <h3 class="mb-3 text-primary text-center">Did You Know?</h3>
       <p id="additionalInfo" class="mb-3 fs-6"></p>
       <div class="d-flex justify-content-center">
           <button id="continueButton" class="btn btn-primary">Continue</button>
       </div>
    </div>
    
    <div class="map-buttons">
        <button id="recenterButton" class="map-button"><i class="fas fa-crosshairs"></i></button>
        <button id="returnButton" class="map-button"><i class="fas fa-sign-out-alt"></i></button>
        <button id="tipsButton" class="map-button"><i class="fas fa-question-circle"></i></button>
    </div>

    <div class="navigation-tips">
        <button class="close-button">&times;</button>
        <h3>Navigation Tips</h3>
        <ul>
            <li>Use the map to navigate to the marked locations.</li>
            <li>The distance box shows how far you are from the current location.</li>
            <li>Tap the recenter button to focus on your current position.</li>
            <li>When you're within 20 feet of a location, you'll be able to interact with it.</li>
            <li>Listen to the audio information for each location.</li>
            <li>After the audio, you'll see additional information about the location.</li>
        </ul>
    </div>

    <div id="summaryModal" class="modal" style="display: none;">
        <div class="modal-content">
            <p id="summaryContent"></p>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"></script>
    <script src="/locations_test.js?v=1.0.4"></script>
 
    <script>
// Global variables
let map, userMarker, markerClusterGroup;
let currentLocationIndex = 0;
let visitedLocations = [];
let gameLocations = [];
let inactivityTimer;
let isLocationHuntVisible = false;
let lastPosition = null;
let positionBuffer = [];
const MAX_BUFFER_SIZE = 20; // Increased buffer size for smoother tracking
const DISTANCE_THRESHOLD = 35000; // 20 feet threshold for opening location page
  
// Initial location notification constants      
const GEOFENCE_RADIUS_FEET = 0; // 90 feet
const FEET_TO_METERS = 0.3048; // 1 foot = 0.3048 meters
const GEOFENCE_RADIUS_METERS = GEOFENCE_RADIUS_FEET * FEET_TO_METERS; // ~27.432 meters

const PROXIMITY_THRESHOLD = 40; // 40 feet threshold for zoom changes
let velocity = { lat: 0, lng: 0 };
let isMapInteracting = false;
let followUser = true;
let locationCooldowns = {};
let userIsInteracting = false;
let preloadedImages = new Map(); // Map to store preloaded images
let preloadedAudio = new Map(); // Map to store preloaded audio
let currentSpeed = 0; // Current speed in meters per second
let lastZoomLevel = 18; // Default zoom level
let stationaryPositionHistory = []; // Array to store stationary positions for averaging
let deviceOrientation = null; // Store device orientation data
let deviceMotion = null; // Store device motion data
let orientationPermissionGranted = false;
let geolocationSensor = null; // Store GeolocationSensor instance
let isNearLocation = false; // Flag to track if user is near a location
let lastProximityCheck = 0; // Last time proximity was checked
let isReturningFromExhibit = false; // Flag to track if returning from exhibit

// Enhanced constants for better stabilization
const MICRO_MOVEMENT_THRESHOLD = 0.5; // Meters - threshold for detecting micro-movements
const STATIONARY_ACCURACY_MULTIPLIER = 1.5; // Looser accuracy bounds to prevent false movement detection
const MAX_ACCEPTABLE_ACCURACY = 30; // meters - more lenient accuracy requirement
const STATIONARY_THRESHOLD = 3; // Number of consecutive stationary positions to consider user as stationary
const STATIONARY_TIME_THRESHOLD = 5000; // ms - time to consider user stationary
const STATIONARY_CHECK_INTERVAL = 2000; // ms - interval to check if still stationary
const VELOCITY_DECAY = 0.95; // Higher value for smoother velocity transitions
const MIN_DISTANCE_THRESHOLD = 1.5; // meters - minimum distance to consider movement
const EXTENDED_DISTANCE_THRESHOLD = 80; // meters - distance to consider a significant position change
const UPDATE_INTERVAL = 100; // ms - less frequent updates for more stability
const STATIONARY_POSITION_HISTORY_SIZE = 10; // Number of positions to keep for stationary averaging
const STATIONARY_POSITION_WEIGHT_DECAY = 0.95; // Weight decay for older positions in stationary average
const SUDDEN_MOVEMENT_THRESHOLD = 1.0; // meters - threshold for detecting sudden movements
const POSITION_JUMP_THRESHOLD = 3.0; // meters - threshold for detecting position jumps
const ZOOM_CHANGE_COOLDOWN = 2000; // ms - cooldown between zoom changes

// Background handling constants
const BACKGROUND_THRESHOLD = 20000; // ms - time to consider app was in background
const INACTIVITY_TIMEOUT = 30000; // ms - time to consider user inactive (30 seconds)

// Kalman filter parameters - optimized for better stationary stability
const KALMAN_PROCESS_NOISE = 0.001; // Lower value for smoother tracking
const KALMAN_MEASUREMENT_NOISE_BASE = 2.0; // Higher base measurement noise to reduce jitter
const KALMAN_STATIONARY_NOISE = 0.0005; // Lower noise when stationary

// Animation parameters
const ANIMATION_DURATION = 300; // ms - duration of position animation for smoother transitions
const HEADING_SMOOTHING = 0.95; // Heading smoothing factor

// Zoom level parameters
const MAX_ZOOM_LEVEL = 18; // Maximum zoom level (stationary)
const MIN_ZOOM_LEVEL = 14; // Minimum zoom level (high speed)
const WALKING_ZOOM_LEVEL = 18; // Zoom level for walking speed
const WALKING_SPEED_THRESHOLD = 1.5; // m/s - threshold for walking speed
const RUNNING_SPEED_THRESHOLD = 4.0; // m/s - threshold for running speed
const DRIVING_SPEED_THRESHOLD = 10.0; // m/s - threshold for driving speed
const ZOOM_TRANSITION_DURATION = 0.8; // seconds - duration of zoom transition

// Motion detection parameters
const MOTION_THRESHOLD = 1.0; // Threshold for detecting significant motion
const MOTION_SAMPLE_SIZE = 10; // Number of motion samples to keep
const MOTION_CHECK_INTERVAL = 300; // ms - interval to check motion

// Edge recenter parameters - optimized for better edge recentering
const EDGE_THRESHOLD_PERCENTAGE = 0.20; // Percentage of viewport to trigger recenter (20%)
const CRITICAL_EDGE_THRESHOLD = 0.10; // Critical threshold for emergency recenter (10%)
const RECENTER_COOLDOWN = 500; // ms - minimum time between recenters

// Error handling constants
const MAX_LOCATION_RETRIES = 5; // Maximum number of retries for location
const LOCATION_RETRY_DELAY = 2000; // Delay between location retries in ms
const NETWORK_CHECK_INTERVAL = 5000; // Interval to check network status in ms
const GPS_CONFIDENCE_THRESHOLD_HIGH = 10; // meters - high confidence threshold
const GPS_CONFIDENCE_THRESHOLD_MEDIUM = 25; // meters - medium confidence threshold
const GPS_SIGNAL_CHECK_INTERVAL = 3000; // Interval to check GPS signal quality in ms
const PERMISSION_DENIED_ERROR = 1; // Error code for permission denied
const POSITION_UNAVAILABLE_ERROR = 2; // Error code for position unavailable
const TIMEOUT_ERROR = 3; // Error code for timeout
const UNKNOWN_ERROR = 4; // Error code for unknown error

// State variables
let lastUpdateTime = null;
let lastVelocity = { lat: 0, lng: 0 };
let isStationary = false;
let stationaryStartTime = null;
let stationaryCheckTimeout = null;
let lastUpdateTimestamp = null;
let lastHiddenTime = 0;
let lastKnownPosition = null;
let isTransitioning = false;
let lastVisitedLocationId = null;
let stationaryCount = 0;
let lastSmoothedPosition = null;
let lastRecenterTime = Date.now();
let retryCount = 0;
let stationaryBuffer = [];
let stationaryPosition = null;
let isStabilizing = true; // Flag to track initial stabilization
let lastStationaryPosition = null; // Last stable position when stationary
let motionSamples = []; // Array to store motion samples
let lastMotionTimestamp = 0; // Last time motion was detected
let deviceStationaryTime = 0; // Time device has been stationary based on motion sensors
let animationFrameId = null; // Store requestAnimationFrame ID
let renderTimestamp = null; // Last render timestamp
let positionUpdateQueue = []; // Queue for position updates to be processed
let lastHeadingValue = null; // Last heading value
let headingBuffer = []; // Buffer for heading values
let isFirstPositionUpdate = true; // Flag for first position update
let lastRenderPosition = null; // Last rendered position
let positionInterpolator = null; // Position interpolator for smooth transitions
let mapViewportWidth = 0; // Store map viewport width
let mapViewportHeight = 0; // Store map viewport height
let lastMapCenter = null; // Last map center position
let lastMapZoom = null; // Last map zoom level
let edgeRecenterInProgress = false; // Flag to track edge recentering
let domUpdateScheduled = false; // Flag to track scheduled DOM updates
let pendingDomUpdates = new Map(); // Map to store pending DOM updates
let usingGeolocationSensorAPI = false; // Flag to track which geolocation API is being used
let lockStationaryPosition = false; // Flag to lock stationary position and prevent jitter
let positionHistory = []; // Array to store recent position history for jump detection
let lastPositionTimestamp = 0; // Last time a position was processed
let suddenMovementCount = 0; // Counter for consecutive sudden movements
let isJumpDetected = false; // Flag to track if a position jump is detected
let stationaryPositionLocked = false; // Flag to indicate if stationary position is locked
let stationaryPositionLockTime = 0; // Time when stationary position was locked
let lastValidPosition = null; // Last valid position before a jump
let stationaryLockTimeout = null; // Timeout for locking stationary position
let positionStabilityCounter = 0; // Counter for position stability
let lastZoomChangeTime = 0; // Last time zoom was changed due to proximity
let lastProximityDistance = Infinity; // Last distance to nearest location
let isOnline = navigator.onLine; // Track online status
let lastGpsSignalCheck = 0; // Last time GPS signal was checked
let gpsConfidenceScore = 0.5; // GPS confidence score (0-1)
let permissionDenied = false; // Flag to track if location permission was denied
let locationErrorCount = 0; // Counter for location errors
let networkErrorCount = 0; // Counter for network errors
let lastNetworkErrorTime = 0; // Last time a network error occurred
let isLocationAvailable = true; // Flag to track if location is available
let confidenceScoreHistory = []; // Array to store confidence scores for averaging
let stationaryConfidenceScore = 0; // Confidence score for stationary state (0-1)
let movingConfidenceScore = 0; // Confidence score for moving state (0-1)
let stationaryTransitionState = 0; // Transition state between stationary and moving (0-1)
let lastAccuracyUpdate = 0; // Last time accuracy indicator was updated
let locationWatchId = null; // ID for geolocation watch
let permissionRequestInProgress = false; // Flag to track if permission request is in progress
let lastPermissionRequest = 0; // Last time permission was requested
let lastUserInteractionTime = Date.now(); // Track last user interaction time
let touchMoveCount = 0; // Counter for touch move events
let lastTouchTime = 0; // Last time a touch event was detected

// Edge recenter variables
let lastEdgeCheck = 0;
const edgeCheckInterval = 500;

// Map update throttling variables
let lastMapUpdate = 0;
const mapUpdateThrottleInterval = 100;

// Dummy variables for testing
const myLocations = [];
const onMapRecentered = () => {};
const L = window.L;
const GeolocationSensor = window.GeolocationSensor;

// Enhanced Kalman Filter implementation
class KalmanFilter {
    constructor() {
        // State variables
        this.x = 0; // Longitude estimate
        this.y = 0; // Latitude estimate
        this.vx = 0; // Longitude velocity
        this.vy = 0; // Latitude velocity
        
        // Error covariance matrix
        this.P = [
            [100, 0, 0, 0],  // Initial high uncertainty
            [0, 100, 0, 0],
            [0, 0, 10, 0],
            [0, 0, 0, 10]
        ];
        
        // Process noise
        this.Q = KALMAN_PROCESS_NOISE;
        
        // Measurement noise (will be adjusted based on GPS accuracy)
        this.R = KALMAN_MEASUREMENT_NOISE_BASE;
        
        // Time delta
        this.dt = 1.0;
        
        // Initialized flag
        this.initialized = false;
        
        // Heading and accuracy tracking
        this.lastHeading = null;
        this.headingConfidence = 0;
        
        // Stationary mode flag
        this.stationaryMode = false;
        
        // Last timestamp
        this.lastTimestamp = null;
        
        // Adaptive noise parameters
        this.adaptiveNoiseMin = 0.0005;
        this.adaptiveNoiseMax = 0.005;
        this.adaptiveNoiseFactor = 1.0;
        
        // Position history for jitter detection
        this.positionHistory = [];
        this.maxPositionHistory = 5;
        this.jitterThreshold = 0.5; // meters
        this.jitterCount = 0;
        
        // Stationary lock
        this.stationaryLocked = false;
        this.stationaryPosition = null;
        
        // Enhanced jitter detection with hysteresis
        this.jitterHysteresis = 0;
        this.maxJitterHysteresis = 5;
        this.jitterConfidence = 0;
    }
    
    // Initialize the filter with first position
    reset(position) {
        if (!position || typeof position.lat !== 'number' || typeof position.lng !== 'number') {
            console.error("Invalid position for Kalman filter reset");
            return;
        }
        
        this.x = position.lng;
        this.y = position.lat;
        this.vx = 0;
        this.vy = 0;
        
        // Reset covariance matrix with high initial uncertainty
        this.P = [
            [100, 0, 0, 0],
            [0, 100, 0, 0],
            [0, 0, 10, 0],
            [0, 0, 0, 10]
        ];
        
        this.initialized = true;
        this.lastHeading = position.heading || null;
        this.headingConfidence = 0;
        this.stationaryMode = false;
        this.lastTimestamp = position.timestamp || Date.now();
        this.adaptiveNoiseFactor = 1.0;
        this.positionHistory = [];
        this.jitterCount = 0;
        this.stationaryLocked = false;
        this.stationaryPosition = null;
        this.jitterHysteresis = 0;
        this.jitterConfidence = 0;
    }
    
    // Set stationary mode
    setStationaryMode(isStationary) {
        this.stationaryMode = isStationary;
        
        // When entering stationary mode, reduce velocity to zero
        if (isStationary) {
            this.vx = 0;
            this.vy = 0;
            
            // Reduce process noise for stationary mode
            this.Q = KALMAN_STATIONARY_NOISE;
            this.adaptiveNoiseFactor = 0.03; // Further reduced for even less jitter in stationary mode
        } else {
            // Reset to normal process noise when moving
            this.Q = KALMAN_PROCESS_NOISE;
            this.adaptiveNoiseFactor = 1.0; // Normal noise when moving
            this.stationaryLocked = false;
            this.stationaryPosition = null;
            this.jitterHysteresis = 0;
        }
    }
    
    // Lock stationary position
    lockStationaryPosition(position) {
        if (!this.stationaryMode) return;
        
        this.stationaryLocked = true;
        this.stationaryPosition = position;
        console.log("Kalman filter: Stationary position locked");
    }
    
    // Enhanced jitter detection with hysteresis and confidence scoring
    detectJitter(newPosition) {
        if (this.positionHistory.length === 0) {
            this.positionHistory.push(newPosition);
            return false;
        }
        
        const lastPos = this.positionHistory[this.positionHistory.length - 1];
        const distance = calculateDistance(lastPos, newPosition);
        
        // Add to history
        this.positionHistory.push(newPosition);
        if (this.positionHistory.length > this.maxPositionHistory) {
            this.positionHistory.shift();
        }
        
        // Check for rapid back-and-forth movement (jitter)
        if (this.positionHistory.length >= 3 && this.stationaryMode) {
            const pos1 = this.positionHistory[this.positionHistory.length - 3];
            const pos2 = this.positionHistory[this.positionHistory.length - 2];
            const pos3 = this.positionHistory[this.positionHistory.length - 1];
            
            const dist1 = calculateDistance(pos1, pos2);
            const dist2 = calculateDistance(pos2, pos3);
            
            // If moving back and forth in small distances
            if (dist1 < this.jitterThreshold && dist2 < this.jitterThreshold) {
                // Check for direction change (sign change in lat/lng differences)
                const latDiff1 = pos2.lat - pos1.lat;
                const latDiff2 = pos3.lat - pos2.lat;
                const lngDiff1 = pos2.lng - pos1.lng;
                const lngDiff2 = pos3.lng - pos2.lng;
                
                // If direction changed in either lat or lng
                if ((Math.sign(latDiff1) !== Math.sign(latDiff2) && Math.abs(latDiff1) > 0.00001 && Math.abs(latDiff2) > 0.00001) || 
                    (Math.sign(lngDiff1) !== Math.sign(lngDiff2) && Math.abs(lngDiff1) > 0.00001 && Math.abs(lngDiff2) > 0.00001)) {
                    
                    // Increase jitter hysteresis
                    this.jitterHysteresis = Math.min(this.maxJitterHysteresis, this.jitterHysteresis + 1);
                    
                    // Increase jitter confidence
                    this.jitterConfidence = Math.min(1.0, this.jitterConfidence + 0.2);
                    
                    return this.jitterHysteresis > 2 && this.jitterConfidence > 0.5;
                }
            }
        }
        
        // Gradually decrease jitter hysteresis and confidence if no jitter detected
        if (distance > this.jitterThreshold * 1.5) {
            this.jitterHysteresis = Math.max(0, this.jitterHysteresis - 0.5);
            this.jitterConfidence = Math.max(0, this.jitterConfidence - 0.1);
        }
        
        return false;
    }
    
    // Adjust process noise based on accuracy, motion, and jitter confidence
    adjustProcessNoise(accuracy, motionDetected) {
        // Base noise level depends on GPS accuracy
        let noiseLevel = this.adaptiveNoiseMin + 
            (this.adaptiveNoiseMax - this.adaptiveNoiseMin) * 
            Math.min(1.0, accuracy / 40.0);
        
        // Reduce noise when stationary
        if (this.stationaryMode) {
            noiseLevel *= 0.03; // Further reduced for even less jitter
        }
        
        // Increase noise when motion is detected
        if (motionDetected && !this.stationaryMode) {
            noiseLevel *= 1.5;
        }
        
        // Reduce noise when jitter is detected (counter-intuitive but effective)
        if (this.jitterConfidence > 0.3) {
            noiseLevel *= 0.01; // Drastically reduce noise to stabilize position
        }
        
        // Apply adaptive factor
        noiseLevel *= this.adaptiveNoiseFactor;
        
        // Set process noise
        this.Q = noiseLevel;
    }
    
    // Update the filter with new measurement
    update(position, motionDetected = false) {
        if (!this.initialized) {
            this.reset(position);
            return position;
        }
        
        if (!position || typeof position.lat !== 'number' || typeof position.lng !== 'number') {
            console.warn("Invalid position input to Kalman filter");
            return {
                lat: this.y,
                lng: this.x,
                accuracy: position?.accuracy || 20,
                heading: this.lastHeading,
                timestamp: position?.timestamp || Date.now()
            };
        }
        
        // If we're in stationary mode and have a locked position, return the locked position
        if (this.stationaryMode && this.stationaryLocked && this.stationaryPosition) {
            return {
                lat: this.stationaryPosition.lat,
                lng: this.stationaryPosition.lng,
                accuracy: position.accuracy,
                heading: position.heading,
                timestamp: position.timestamp,
                speedMPS: 0
            };
        }
        
        // Calculate time delta
        const timestamp = position.timestamp || Date.now();
        if (this.lastTimestamp) {
            this.dt = Math.min(Math.max((timestamp - this.lastTimestamp) / 1000, 0.01), 2.0);
        }
        this.lastTimestamp = timestamp;
        
        // Check for jitter
        const isJittering = this.detectJitter(position);
        
        // Adjust measurement noise based on GPS accuracy and jitter
        const accuracy = position.accuracy || 20;
        this.R = Math.max(KALMAN_MEASUREMENT_NOISE_BASE, accuracy / 5);
        
        // If in stationary mode, increase measurement noise to reduce jitter
        if (this.stationaryMode) {
            this.R *= 15.0; // Increased to further reduce jitter
        }
        
        // If jittering is detected, increase measurement noise significantly
        if (isJittering) {
            this.R *= 30.0; // Increased to further reduce jitter
        }
        
        // Adjust process noise based on accuracy and motion
        this.adjustProcessNoise(accuracy, motionDetected);
        
        // Predict step
        // x = F * x
        const predictedX = this.x + this.dt * this.vx;
        const predictedY = this.y + this.dt * this.vy;
        const predictedVx = this.stationaryMode ? 0 : this.vx;
        const predictedVy = this.stationaryMode ? 0 : this.vy;
        
        // P = F * P * F' + Q
        const Q = [
            [this.Q * this.dt * this.dt * this.dt * this.dt / 4, 0, this.Q * this.dt * this.dt * this.dt / 2, 0],
            [0, this.Q * this.dt * this.dt * this.dt * this.dt / 4, 0, this.Q * this.dt * this.dt * this.dt / 2],
            [this.Q * this.dt * this.dt * this.dt / 2, 0, this.Q * this.dt * this.dt, 0],
            [0, this.Q * this.dt * this.dt * this.dt / 2, 0, this.Q * this.dt * this.dt]
        ];
        
        // Matrix multiplication F * P
        const FP = [
            [this.P[0][0] + this.dt * this.P[2][0], this.P[0][1] + this.dt * this.P[2][1], this.P[0][2] + this.dt * this.P[2][2], this.P[0][3] + this.dt * this.P[2][3]],
            [this.P[1][0] + this.dt * this.P[3][0], this.P[1][1] + this.dt * this.P[3][1], this.P[1][2] + this.dt * this.P[3][2], this.P[1][3] + this.dt * this.P[3][3]],
            [this.P[2][0], this.P[2][1], this.P[2][2], this.P[2][3]],
            [this.P[3][0], this.P[3][1], this.P[3][2], this.P[3][3]]
        ];
        
        // Matrix multiplication FP * F'
        const predictedP = [
            [FP[0][0] + this.dt * FP[0][2] + Q[0][0], FP[0][1] + this.dt * FP[0][3] + Q[0][1], FP[0][2] + Q[0][2], FP[0][3] + Q[0][3]],
            [FP[1][0] + this.dt * FP[1][2] + Q[1][0], FP[1][1] + this.dt * FP[1][3] + Q[1][1], FP[1][2] + Q[1][2], FP[1][3] + Q[1][3]],
            [FP[2][0] + Q[2][0], FP[2][1] + Q[2][1], FP[2][2] + Q[2][2], FP[2][3] + Q[2][3]],
            [FP[3][0] + Q[3][0], FP[3][1] + Q[3][1], FP[3][2] + Q[3][2], FP[3][3] + Q[3][3]]
        ];
                
        // Update step
        // y = z - H * x
        const measurementResidualX = position.lng - predictedX;
        const measurementResidualY = position.lat - predictedY;
        
        // S = H * P * H' + R
        const S = [
            [predictedP[0][0] + this.R, predictedP[0][1]],
            [predictedP[1][0], predictedP[1][1] + this.R]
        ];
        
        // Calculate determinant of S
        const detS = S[0][0] * S[1][1] - S[0][1] * S[1][0];
        
        // Check for numerical stability
        if (Math.abs(detS) < 1e-10) {
            // If determinant is too small, use previous state
            return {
                lat: this.y,
                lng: this.x,
                accuracy: position.accuracy,
                heading: position.heading,
                timestamp: position.timestamp,
                speedMPS: this.stationaryMode ? 0 : Math.sqrt(this.vx * this.vx + this.vy * this.vy) * 111000
            };
        }
        
        // Calculate inverse of S
        const invS = [
            [S[1][1] / detS, -S[0][1] / detS],
            [-S[1][0] / detS, S[0][0] / detS]
        ];
        
        // K = P * H' * inv(S)
        const K = [
            [predictedP[0][0] * invS[0][0] + predictedP[0][1] * invS[1][0], predictedP[0][0] * invS[0][1] + predictedP[0][1] * invS[1][1]],
            [predictedP[1][0] * invS[0][0] + predictedP[1][1] * invS[1][0], predictedP[1][0] * invS[0][1] + predictedP[1][1] * invS[1][1]],
            [predictedP[2][0] * invS[0][0] + predictedP[2][1] * invS[1][0], predictedP[2][0] * invS[0][1] + predictedP[2][1] * invS[1][1]],
            [predictedP[3][0] * invS[0][0] + predictedP[3][1] * invS[1][0], predictedP[3][0] * invS[0][1] + predictedP[3][1] * invS[1][1]]
        ];
        
        // x = x + K * y
        this.x = predictedX + K[0][0] * measurementResidualX + K[0][1] * measurementResidualY;
        this.y = predictedY + K[1][0] * measurementResidualX + K[1][1] * measurementResidualY;
        
        // In stationary mode, keep velocity at zero
        if (this.stationaryMode) {
            this.vx = 0;
            this.vy = 0;
        } else {
            this.vx = predictedVx + K[2][0] * measurementResidualX + K[2][1] * measurementResidualY;
            this.vy = predictedVy + K[3][0] * measurementResidualX + K[3][1] * measurementResidualY;
        }
        
        // P = (I - K * H) * P
        // Fixed matrix multiplication for P update
        const KH = [
            [K[0][0], K[0][1]],
            [K[1][0], K[1][1]],
            [K[2][0], K[2][1]],
            [K[3][0], K[3][1]]
        ];
        
        const IKH = [
            [1 - KH[0][0], -KH[0][1]],
            [-KH[1][0], 1 - KH[1][1]],
            [-KH[2][0], -KH[2][1]],
            [-KH[3][0], -KH[3][1]]
        ];
        
        // Compute (I - K*H) * P
        this.P = [
            [
                IKH[0][0] * predictedP[0][0] + IKH[0][1] * predictedP[1][0],
                IKH[0][0] * predictedP[0][1] + IKH[0][1] * predictedP[1][1],
                IKH[0][0] * predictedP[0][2] + IKH[0][1] * predictedP[1][2],
                IKH[0][0] * predictedP[0][3] + IKH[0][1] * predictedP[1][3]
            ],
            [
                IKH[1][0] * predictedP[0][0] + IKH[1][1] * predictedP[1][0],
                IKH[1][0] * predictedP[0][1] + IKH[1][1] * predictedP[1][1],
                IKH[1][0] * predictedP[0][2] + IKH[1][1] * predictedP[1][2],
                IKH[1][0] * predictedP[0][3] + IKH[1][1] * predictedP[1][3]
            ],
            [
                IKH[2][0]  + IKH[1][1] * predictedP[1][3]
            ],
            [
                IKH[2][0] * predictedP[0][0] + IKH[2][1] * predictedP[1][0],
                IKH[2][0] * predictedP[0][1] + IKH[2][1] * predictedP[1][1],
                IKH[2][0] * predictedP[0][2] + IKH[2][1] * predictedP[1][2],
                IKH[2][0] * predictedP[0][3] + IKH[2][1] * predictedP[1][3]
            ],
            [
                IKH[3][0] * predictedP[0][0] + IKH[3][1] * predictedP[1][0],
                IKH[3][0] * predictedP[0][1] + IKH[3][1] * predictedP[1][1],
                IKH[3][0] * predictedP[0][2] + IKH[3][1] * predictedP[1][2],
                IKH[3][0] * predictedP[0][3] + IKH[3][1] * predictedP[1][3]
            ]
        ];
        
        // Process heading data with enhanced smoothing
        let smoothedHeading = position.heading;
        if (position.heading !== null && position.heading !== undefined) {
            if (this.lastHeading !== null) {
                // Normalize headings to 0-360
                const normalizedCurrent = ((position.heading % 360) + 360) % 360;
                const normalizedLast = ((this.lastHeading % 360) + 360) % 360;
                
                // Calculate the smallest angle between the two headings
                let diff = normalizedCurrent - normalizedLast;
                if (diff > 180) diff -= 360;
                if (diff < -180) diff += 360;
                
                // Apply stronger smoothing when stationary, more responsive when moving
                const headingWeight = this.stationaryMode ? 
                    0.005 : // Extremely stable when stationary
                    (motionDetected ? 
                        (Math.abs(diff) > 30 ? 0.4 : 0.2) : // More responsive to large changes when in motion
                        0.1); // Default smoothing
                
                smoothedHeading = normalizedLast + diff * headingWeight;
                
                // Normalize back to 0-360
                smoothedHeading = ((smoothedHeading % 360) + 360) % 360;
                
                // Increase confidence with consistent headings
                if (Math.abs(diff) < 12) {
                    this.headingConfidence = Math.min(1.0, this.headingConfidence + 0.1);
                } else {
                    this.headingConfidence = Math.max(0.1, this.headingConfidence - 0.2);
                }
            }
            this.lastHeading = smoothedHeading;
        }
        
        // Calculate speed from velocity components
        const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
        
        // Create filtered position
        const filteredPosition = {
            lat: this.y,
            lng: this.x,
            accuracy: position.accuracy,
            heading: smoothedHeading,
            timestamp: position.timestamp,
            speedMPS: this.stationaryMode ? 0 : speed * 111000 // Convert from degrees/second to meters/second (approximate)
        };
        
        // If we're in stationary mode and don't have a locked position yet,
        // check if we should lock the position
        if (this.stationaryMode && !this.stationaryLocked && stationaryStartTime) {
            // If we've been stationary for a while, lock the position
            if (Date.now() - stationaryStartTime > 3000) {
                this.lockStationaryPosition(filteredPosition);
            }
        }
        
        return filteredPosition;
    }
}

// Position interpolator for smooth transitions
class PositionInterpolator {
    constructor() {
        this.startPosition = null;
        this.targetPosition = null;
        this.startTime = null;
        this.duration = 0;
        this.isActive = false;
        this.lastInterpolatedPosition = null; // Track last interpolated position
    }
    
    start(startPos, targetPos, duration) {
        if (!startPos || !targetPos) return;
        
        // If already interpolating, use current interpolated position as start
        if (this.isActive && this.lastInterpolatedPosition) {
            startPos = this.lastInterpolatedPosition;
        }
        
        this.startPosition = { ...startPos };
        this.targetPosition = { ...targetPos };
        this.startTime = performance.now();
        this.duration = duration;
        this.isActive = true;
    }
    
    update() {
        if (!this.isActive) return null;
        
        const now = performance.now();
        const elapsed = now - this.startTime;
        
        if (elapsed >= this.duration) {
            this.isActive = false;
            this.lastInterpolatedPosition = this.targetPosition;
            return this.targetPosition;
        }
        
        // Calculate progress with improved easing
        const t = elapsed / this.duration;
        const easedT = this.easeOutCubic(t);
        
        // Interpolate position
        const interpolatedPosition = {
            lat: this.startPosition.lat + (this.targetPosition.lat - this.startPosition.lat) * easedT,
            lng: this.startPosition.lng + (this.targetPosition.lng - this.startPosition.lng) * easedT,
            accuracy: this.targetPosition.accuracy,
            heading: this.interpolateHeading(this.startPosition.heading, this.targetPosition.heading, easedT),
            timestamp: now,
            speedMPS: this.targetPosition.speedMPS
        };
        
        this.lastInterpolatedPosition = interpolatedPosition;
        return interpolatedPosition;
    }
    
    // Improved heading interpolation that handles the 0/360 boundary
    interpolateHeading(start, end, t) {
        if (start === undefined || end === undefined || start === null || end === null) {
            return end;
        }
        
        // Normalize headings to 0-360
        start = ((start % 360) + 360) % 360;
        end = ((end % 360) + 360) % 360;
        
        // Find the shortest path
        let diff = end - start;
        if (diff > 180) diff -= 360;
        if (diff < -180) diff += 360;
        
        // Calculate interpolated heading
        let result = start + diff * t;
        
        // Normalize result
        return ((result % 360) + 360) % 360;
    }
    
    // Improved cubic easing function for smoother motion
    easeOutCubic(t) {
        return 1 - Math.pow(1 - t, 3);
    }
    
    isInterpolating() {
        return this.isActive;
    }
    
    cancel() {
        this.isActive = false;
    }
}

// Create Kalman filter instance
const kalmanFilter = new KalmanFilter();

// Create position interpolator
positionInterpolator = new PositionInterpolator();

// DOM update manager for batching UI updates
const domUpdateManager = {
    updates: new Map(),
    scheduled: false,
    maxUpdates: 100, // Limit the number of updates to prevent memory bloat

    // Schedule a DOM update with optional priority
    schedule(id, updateFn, priority = 0) {
        // Enforce size limit
        if (this.updates.size >= this.maxUpdates) {
            console.warn("DOM update limit reached, skipping update for:", id);
            return;
        }

        // Store the update with its priority
        this.updates.set(id, { updateFn, priority });

        // Schedule a flush if not already scheduled
        if (!this.scheduled) {
            this.scheduled = true;
            requestAnimationFrame(() => this.flush());
        }
    },

    // Flush all scheduled DOM updates
    flush() {
        try {
            // Convert updates to an array and sort by priority (higher priority first)
            const sortedUpdates = Array.from(this.updates.values())
                .sort((a, b) => b.priority - a.priority);

            // Execute updates
            sortedUpdates.forEach(({ updateFn }) => {
                try {
                    updateFn();
                } catch (error) {
                    console.error("Error executing DOM update:", error);
                }
            });
        } catch (error) {
            console.error("Error during DOM update flush:", error);
        } finally {
            // Clear updates and reset state
            this.updates.clear();
            this.scheduled = false;
        }
    },

    // Cancel a scheduled update by ID
    cancel(id) {
        this.updates.delete(id);
    },

    // Clear all pending updates
    clear() {
        this.updates.clear();
        this.scheduled = false;
    }
};
        
// Enhanced dynamic zoom functionality to keep user icon visible at all speeds
function calculateZoomLevel(speedMPS) {
    // Update current speed for global access
    currentSpeed = speedMPS;
    
    // Speed thresholds in meters per second
    const STATIONARY_SPEED = 0.5;       // Below this is considered stationary
    const WALKING_SPEED = 1.5;          // ~5.4 km/h
    const RUNNING_SPEED = 4.0;          // ~14.4 km/h
    const BIKING_SPEED = 8.0;           // ~28.8 km/h
    const DRIVING_SPEED = 15.0;         // ~54 km/h
    const HIGH_SPEED_DRIVING = 25.0;    // ~90 km/h
    
    // Determine zoom level based on speed with more granular steps
    let zoomLevel;
    
    if (isStationary || speedMPS < STATIONARY_SPEED) {
        // Stationary or very slow movement
        zoomLevel = MAX_ZOOM_LEVEL; // 18
    } else if (speedMPS < WALKING_SPEED) {
        // Walking speed
        zoomLevel = 18; // Full zoom for walking
    } else if (speedMPS < RUNNING_SPEED) {
        // Between walking and running - linear interpolation
        const t = (speedMPS - WALKING_SPEED) / (RUNNING_SPEED - WALKING_SPEED);
        zoomLevel = 18 - t * 1; // From 18 to 17
    } else if (speedMPS < BIKING_SPEED) {
        // Between running and biking - linear interpolation
        const t = (speedMPS - RUNNING_SPEED) / (BIKING_SPEED - RUNNING_SPEED);
        zoomLevel = 17 - t * 1; // From 17 to 16
    } else if (speedMPS < DRIVING_SPEED) {
        // Between biking and driving - linear interpolation
        const t = (speedMPS - BIKING_SPEED) / (DRIVING_SPEED - BIKING_SPEED);
        zoomLevel = 16 - t * 1; // From 16 to 15
    } else if (speedMPS < HIGH_SPEED_DRIVING) {
        // Between normal driving and high-speed driving
        const t = (speedMPS - DRIVING_SPEED) / (HIGH_SPEED_DRIVING - DRIVING_SPEED);
        zoomLevel = 15 - t * 1; // From 15 to 14
    } else {
        // High speed
        zoomLevel = MIN_ZOOM_LEVEL; // 14
    }
    
    // Apply hysteresis to prevent zoom oscillation
    // More aggressive smoothing at higher speeds, less at lower speeds
    if (lastZoomLevel !== null) {
        const smoothingFactor = speedMPS > DRIVING_SPEED ? 0.8 : 
                               (speedMPS > BIKING_SPEED ? 0.85 : 0.9);
        zoomLevel = lastZoomLevel * smoothingFactor + zoomLevel * (1 - smoothingFactor);
    }
    
    // Round to one decimal place for smoother transitions
    zoomLevel = Math.round(zoomLevel * 10) / 10;
    
    // Clamp to valid zoom range
    zoomLevel = Math.max(MIN_ZOOM_LEVEL, Math.min(MAX_ZOOM_LEVEL, zoomLevel));
    
    // Update last zoom level
    lastZoomLevel = zoomLevel;
    
    return zoomLevel;
}

// Enhanced stationary position calculation
function calculateStationaryPosition(buffer) {
    if (!buffer || buffer.length === 0) {
        return null;
    }
    
    // Sort by accuracy (best first)
    const sortedBuffer = [...buffer].sort((a, b) => a.accuracy - b.accuracy);
    
    // Take weighted average of best positions
    const topPositions = sortedBuffer.slice(0, Math.ceil(buffer.length / 2));
    
    const weights = topPositions.map(pos => 1 / Math.max(1, pos.accuracy));
    const totalWeight = weights.reduce((sum, w) => sum + w, 0);
    
    if (totalWeight === 0) {
        return sortedBuffer[0];
    }
    
    // Calculate weighted average
    const avgPosition = {
        lat: topPositions.reduce((sum, pos, i) => sum + pos.lat * weights[i], 0) / totalWeight,
        lng: topPositions.reduce((sum, pos, i) => sum + pos.lng * weights[i], 0) / totalWeight,
        accuracy: topPositions[0].accuracy,
        heading: topPositions[0].heading,
        timestamp: Date.now(),
        speedMPS: 0
    };
    
    // If we have a previous stationary position, blend with it for stability
    if (lastStationaryPosition) {
        // Increased to 99% previous, 1% new for extreme stability when stationary
        const blendFactor = 0.99; 
        return {
            lat: lastStationaryPosition.lat * blendFactor + avgPosition.lat * (1 - blendFactor),
            lng: lastStationaryPosition.lng * blendFactor + avgPosition.lng * (1 - blendFactor),
            accuracy: avgPosition.accuracy,
            heading: avgPosition.heading,
            timestamp: avgPosition.timestamp,
            speedMPS: 0
        };
    }
    
    return avgPosition;
}

// Update stationary position history
function updateStationaryHistory(position) {
    // Add new position to history
    stationaryPositionHistory.push(position);
    
    // Keep history at maximum size
    while (stationaryPositionHistory.length > STATIONARY_POSITION_HISTORY_SIZE) {
        stationaryPositionHistory.shift();
    }
    
    // Calculate weighted average of positions
    let totalWeight = 0;
    let weightedLat = 0;
    let weightedLng = 0;
    
    // Newer positions have higher weight
    for (let i = 0; i < stationaryPositionHistory.length; i++) {
        const pos = stationaryPositionHistory[i];
        const weight = Math.pow(STATIONARY_POSITION_WEIGHT_DECAY, stationaryPositionHistory.length - i - 1);
        totalWeight += weight;
        weightedLat += pos.lat * weight;
        weightedLng += pos.lng * weight;
    }
    
    return {
        lat: weightedLat / totalWeight,
        lng: weightedLng / totalWeight,
        accuracy: position.accuracy,
        heading: position.heading,
        timestamp: position.timestamp,
        speedMPS: 0
    };
}

// Check if device is in motion based on motion sensors
function isDeviceInMotion() {
    if (!motionSamples || motionSamples.length < 3) {
        return false;
    }
    
    // Calculate average motion magnitude
    const avgMotion = motionSamples.reduce((sum, sample) => {
        return sum + Math.sqrt(
            sample.x * sample.x + 
            sample.y * sample.y + 
            sample.z * sample.z
        );
    }, 0) / motionSamples.length;
    
    return avgMotion > MOTION_THRESHOLD;
}

// Process device motion data
function handleDeviceMotion(event) {
    if (!event || !event.acceleration) return;
    
    const motion = {
        x: event.acceleration.x || 0,
        y: event.acceleration.y || 0,
        z: event.acceleration.z || 0,
        timestamp: Date.now()
    };
    
    // Add to motion samples
    motionSamples.push(motion);
    
    // Keep only recent samples
    while (motionSamples.length > MOTION_SAMPLE_SIZE) {
        motionSamples.shift();
    }
    
    // Update device motion state
    deviceMotion = motion;
    
    // Check if device is stationary based on motion
    const inMotion = isDeviceInMotion();
    
    if (!inMotion) {
        deviceStationaryTime += MOTION_CHECK_INTERVAL;
    } else {
        deviceStationaryTime = 0;
    }
}

// Process device orientation data
function handleDeviceOrientation(event) {
    if (!event || event.alpha === null) return;
    
    deviceOrientation = {
        alpha: event.alpha, // z-axis rotation [0,360)
        beta: event.beta,   // x-axis rotation [-180,180)
        gamma: event.gamma, // y-axis rotation [-90,90)
        timestamp: Date.now()
    };
    
    // Update heading buffer if we have a compass heading
    if (event.webkitCompassHeading !== undefined) {
        const heading = event.webkitCompassHeading;
        
        // Add to heading buffer
        headingBuffer.push(heading);
        
        // Keep only recent headings
        while (headingBuffer.length > 5) {
            headingBuffer.shift();
        }
        
        // Calculate median heading to filter outliers
        if (headingBuffer.length >= 3) {
            const sortedHeadings = [...headingBuffer].sort((a, b) => a - b);
            lastHeadingValue = sortedHeadings[Math.floor(sortedHeadings.length / 2)];
        }
    }
}

// Request device motion and orientation permissions
function requestMotionPermission() {
    if (typeof DeviceMotionEvent !== 'undefined' && 
        typeof DeviceMotionEvent.requestPermission === 'function') {
        
        DeviceMotionEvent.requestPermission()
            .then(response => {
                if (response === 'granted') {
                    window.addEventListener('devicemotion', handleDeviceMotion, true);
                }
            })
            .catch(console.error);
    } else {
        window.addEventListener('devicemotion', handleDeviceMotion, true);
    }
    
    if (typeof DeviceOrientationEvent !== 'undefined' && 
        typeof DeviceOrientationEvent.requestPermission === 'function') {
        
        DeviceOrientationEvent.requestPermission()
            .then(response => {
                if (response === 'granted') {
                    orientationPermissionGranted = true;
                    window.addEventListener('deviceorientation', handleDeviceOrientation, true);
                }
            })
            .catch(console.error);
    } else {
        window.addEventListener('deviceorientation', handleDeviceOrientation, true);
        orientationPermissionGranted = true;
    }
}

// Image preloading function with improved batching
function preloadImages(locationsData) {
    return new Promise((resolve) => {
        if (!locationsData || locationsData.length === 0) {
            resolve();
            return;
        }
        
        const totalImages = locationsData.length;
        let loadedImages = 0;
        const progressBar = document.getElementById('preloaderProgress');
        
        // Create preload queue
        let imagePreloadQueue = locationsData.filter(location => location.image && !preloadedImages.has(location.image))
            .map(location => location.image);
        
        // Also queue audio files
        let audioPreloadQueue = locationsData.filter(location => location.audio && !preloadedAudio.has(location.audio))
            .map(location => location.audio);
        
        // Start preloading
        let preloadStartTime = Date.now();
        let isPreloading = true;
        let preloadBatchSize = 5;
        
        // Process next batch
        function processNextBatch() {
            if (imagePreloadQueue.length === 0 && audioPreloadQueue.length === 0) {
                isPreloading = false;
                resolve();
                return;
            }
            
            // Process image batch
            const imageBatch = imagePreloadQueue.splice(0, preloadBatchSize);
            
            // Load images in batch
            Promise.all(imageBatch.map(imageUrl => {
                return new Promise((resolveImage) => {
                    const img = new Image();
                    img.crossOrigin = "anonymous"; // Set crossOrigin for canvas operations
                    
                    img.onload = function() {
                        preloadedImages.set(imageUrl, img);
                        loadedImages++;
                        updateProgress();
                        resolveImage();
                    };
                    
                    img.onerror = function() {
                        console.warn(`Failed to load image: ${imageUrl}`);
                        loadedImages++;
                        updateProgress();
                        resolveImage();
                    };
                    
                    img.src = imageUrl;
                });
            })).then(() => {
                // Process audio batch
                const audioBatch = audioPreloadQueue.splice(0, preloadBatchSize);
                
                // Load audio in batch
                return Promise.all(audioBatch.map(audioUrl => {
                    return new Promise((resolveAudio) => {
                        const audio = new Audio();
                        audio.preload = 'auto';
                        
                        audio.oncanplaythrough = () => {
                            preloadedAudio.set(audioUrl, audio);
                            resolveAudio();
                        };
                        
                        audio.onerror = () => {
                            console.warn(`Failed to load audio: ${audioUrl}`);
                            resolveAudio();
                        };
                        
                        audio.src = audioUrl;
                    });
                }));
            }).then(() => {
                // Continue with next batch after a small delay to prevent UI blocking
                setTimeout(processNextBatch, 10);
            }).catch(error => {
                console.error("Error preloading batch:", error);
                setTimeout(processNextBatch, 10);
            });
        }
        
        function updateProgress() {
            const percent = (loadedImages / totalImages) * 100;
            domUpdateManager.schedule('preloaderProgress', () => {
                if (progressBar) {
                    progressBar.style.width = `${percent}%`;
                }
            });
        }
        
        // Start processing batches
        processNextBatch();
    });
}

// Detect sudden movements or position jumps
function detectSuddenMovement(newPosition, lastPosition) {
    if (!lastPosition || !newPosition) return false;
    
    const distance = calculateDistance(lastPosition, newPosition);
    const timeDelta = (newPosition.timestamp - lastPosition.timestamp) / 1000; // seconds
    
    // If time delta is too small, consider it a valid update
    if (timeDelta < 0.05) return false;
    
    // Calculate speed in meters per second
    const speed = distance / timeDelta;
    
    // Check for unrealistic speeds (teleportation)
    if (speed > 50) { // 50 m/s is about 112 mph
        console.log(`Position jump detected: ${distance.toFixed(2)}m in ${timeDelta.toFixed(2)}s (${speed.toFixed(2)} m/s)`);
        return true;
    }
    
    // Check for sudden movements when stationary
    if (isStationary && distance > POSITION_JUMP_THRESHOLD) {
        console.log(`Sudden movement detected while stationary: ${distance.toFixed(2)}m`);
        return true;
    }
    
    // Check for small sudden movements (jitter)
    if (isStationary && distance > SUDDEN_MOVEMENT_THRESHOLD) {
        suddenMovementCount++;
        if (suddenMovementCount >= 2) {
            console.log(`Multiple sudden movements detected: ${distance.toFixed(2)}m`);
            return true;
        }
    } else {
        suddenMovementCount = 0;
    }
    
    return false;
}

// Check proximity to locations and adjust zoom accordingly
function checkLocationProximity() {
    const now = Date.now();
    
    // Don't check too frequently
    if (now - lastProximityCheck < 1000) return;
    lastProximityCheck = now;
    
    // Don't check if zoom was recently changed
    if (now - lastZoomChangeTime < ZOOM_CHANGE_COOLDOWN) return;
    
    if (!userMarker || !gameLocations || gameLocations.length === 0) return;
    
    const userLatLng = userMarker.getLatLng();
    
    // Validate user coordinates
    if (!userLatLng || typeof userLatLng.lat !== 'number' || typeof userLatLng.lng !== 'number' || 
        isNaN(userLatLng.lat) || isNaN(userLatLng.lng)) {
        console.warn("Invalid user coordinates for proximity check");
        return;
    }
    
    const userPos = { lat: userLatLng.lat, lng: userLatLng.lng };
    
    // Find closest location
    let closestDistance = Infinity;
    let closestLocation = null;
    
    for (const location of gameLocations) {
        if (!location || typeof location.lat !== 'number' || typeof location.lng !== 'number' || 
            isNaN(location.lat) || isNaN(location.lng)) {
            continue;
        }
        
        const locationPos = { lat: location.lat, lng: location.lng };
        const distance = calculateDistance(userPos, locationPos);
        
        if (isFinite(distance) && distance < closestDistance) {
            closestDistance = distance;
            closestLocation = location;
        }
    }
    
    // If no valid locations found, exit
    if (!closestLocation || !isFinite(closestDistance)) {
        return;
    }
    
    // Convert to feet for threshold comparison
    const distanceFeet = Math.round(closestDistance * 3.28084);

    // Constants for hysteresis and thresholds
    const HYSTERESIS_FACTOR = 1.1; // 10% buffer to prevent rapid toggling
    const ZOOM_IN_THRESHOLD = PROXIMITY_THRESHOLD * 0.9; // 90% of PROXIMITY_THRESHOLD
    const ZOOM_OUT_THRESHOLD = PROXIMITY_THRESHOLD * 1.1; // 110% of PROXIMITY_THRESHOLD

    // Check if we need to adjust zoom based on proximity
    if (distanceFeet <= ZOOM_IN_THRESHOLD) {
        // If we weren't near a location before, zoom in
        if (!isNearLocation && Math.abs(lastProximityDistance - closestDistance) > 1) {
            console.log(`User is now within ${ZOOM_IN_THRESHOLD.toFixed(1)} feet of a location, zooming in`);
            isNearLocation = true;
            lastZoomChangeTime = now;

            // Calculate new zoom level (clamped to MAX_ZOOM_LEVEL)
            const currentZoom = map.getZoom();
            const newZoom = Math.min(currentZoom + 1, MAX_ZOOM_LEVEL);

            // Apply zoom change with smooth animation
            map.setZoom(newZoom, {
                animate: true,
                duration: ZOOM_TRANSITION_DURATION
            });
        }
    } else if (distanceFeet >= ZOOM_OUT_THRESHOLD && isNearLocation) {
        // If we were near a location but now we're not, zoom out
        console.log(`User is now outside ${ZOOM_OUT_THRESHOLD.toFixed(1)} feet of a location, zooming out`);
        isNearLocation = false;
        lastZoomChangeTime = now;

        // Calculate new zoom level (clamped to MIN_ZOOM_LEVEL)
        const currentZoom = map.getZoom();
        const newZoom = Math.max(currentZoom - 1, MIN_ZOOM_LEVEL);

        // Apply zoom change with smooth animation
        map.setZoom(newZoom, {
            animate: true,
            duration: ZOOM_TRANSITION_DURATION
        });
    }
    
    // Update last proximity distance
    lastProximityDistance = closestDistance;
}

function initMap() {
    map = L.map('map', {
        zoomControl: false,
        attributionControl: false,
        zoomSnap: 0.1,
        zoomDelta: 0.5,
        wheelDebounceTime: 100,
        tapTolerance: 15,
        bounceAtZoomLimits: false,
        preferCanvas: true, // Use canvas renderer for better performance
        renderer: L.canvas({ padding: 0.5 })
    }).fitWorld();

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 18,
        attribution: ' OpenStreetMap contributors',
        updateWhenIdle: true,
        updateWhenZooming: false,
        keepBuffer: 2
    }).addTo(map);

    markerClusterGroup = L.markerClusterGroup({
        showCoverageOnHover: false,
        zoomToBoundsOnClick: true,
        spiderfyOnMaxZoom: true,
        animate: true,
        animateAddingMarkers: true,
        disableClusteringAtZoom: 18,
        maxClusterRadius: 60,
        iconCreateFunction: function(cluster) {
            return L.divIcon({
                html: '<div><span>' + cluster.getChildCount() + '</span></div>',
                className: 'marker-cluster-custom',
                iconSize: L.point(40, 40)
            });
        }
    });
    map.addLayer(markerClusterGroup);

    // Create user icon with custom styling (red)
    const userIcon = L.divIcon({
        className: 'user-marker',
        html: '<div class="user-marker-icon"></div>',
        iconSize: [20, 20],
        iconAnchor: [10, 10]
    });
    userMarker = L.marker([0, 0], { 
        icon: userIcon,
        zIndexOffset: 1000, // Ensure user marker is on top
        interactive: false // Prevent marker from being clickable
    }).addTo(map);
    
    // Store map viewport dimensions
    updateMapViewportDimensions();
    
    showLoadingMessage();

    // Request motion and orientation permissions
    requestMotionPermission();

    // Try to use Geolocation Sensor API first, then fall back to standard Geolocation API
    initGeolocation();
    
    // Add visibility change handler
    document.addEventListener('visibilitychange', handleVisibilityChange);

    // Add map interaction handlers
    map.on('movestart zoomstart dragstart', () => {
        followUser = false;
        isMapInteracting = true;
        updateUserInteractionTime();
    });

    map.on('moveend zoomend dragend', () => {
        isMapInteracting = false;
        updateUserInteractionTime();
        updateMapViewportDimensions();
    });
    
    // Add touch event listeners for mobile
    document.addEventListener('touchstart', updateUserInteractionTime);
    document.addEventListener('touchmove', handleTouchMove);
    document.addEventListener('touchend', updateUserInteractionTime);
    
    // Add mouse event listeners for desktop
    document.addEventListener('mousedown', updateUserInteractionTime);
    document.addEventListener('mousemove', updateUserInteractionTime);
    document.addEventListener('mouseup', updateUserInteractionTime);
    document.addEventListener('click', updateUserInteractionTime);
    
    // Listen for resize events to update viewport dimensions
    window.addEventListener('resize', () => {
        updateMapViewportDimensions();
        updateUserInteractionTime();
    });

    // Start animation loop for smooth rendering
    startAnimationLoop();
    
    // Enable touch interactions
    map.touchZoom.enable();
    map.doubleClickZoom.enable();
    
    // Initialize network status monitoring
    initNetworkMonitoring();
    
    // Start inactivity timer
    resetInactivityTimer();
}

// Handle touch move events
function handleTouchMove(e) {
    updateUserInteractionTime();
    
    // Count touch move events to detect scrolling/panning
    const now = Date.now();
    if (now - lastTouchTime < 300) {
        touchMoveCount++;
        
        // If user is actively panning/scrolling, consider it as interaction
        if (touchMoveCount > 3) {
            followUser = false;
        }
    } else {
        // Reset touch move count if time between touches is too long
        touchMoveCount = 1;
    }
    
    lastTouchTime = now;
}

// Update user interaction time
function updateUserInteractionTime() {
    lastUserInteractionTime = Date.now();
    userIsInteracting = true;
    
    // Reset inactivity timer whenever user interacts
    resetInactivityTimer();
}

// Initialize network status monitoring
function initNetworkMonitoring() {
    const networkStatus = document.getElementById('networkStatus');
    
    // Update network status indicator
    function updateNetworkStatus() {
        if (navigator.onLine) {
            if (networkStatus) {
                networkStatus.classList.remove('offline');
                networkStatus.title = 'Online';
                isOnline = true;
            }
        } else {
            if (networkStatus) {
                networkStatus.classList.add('offline');
                networkStatus.title = 'Offline';
                isOnline = false;
                showErrorMessage('No internet connection. Some features may not work properly.');
            }
        }
    }
    
    // Initial status check
    updateNetworkStatus();
    
    // Listen for network status changes
    window.addEventListener('online', () => {
        updateNetworkStatus();
        showErrorMessage('Internet connection restored.');
        
        // Retry any failed operations
        if (gameLocations.length === 0) {
            startHunt();
        }
    });
    
    window.addEventListener('offline', () => {
        updateNetworkStatus();
        showErrorMessage('No internet connection. Some features may not work properly.');
    });
    
    // Periodically check network status
    setInterval(() => {
        // Check if we can fetch a small resource to verify actual connectivity
        if (navigator.onLine) {
            fetch('https://www.mnthen.com/favicon.ico', { 
                method: 'HEAD',
                cache: 'no-store',
                mode: 'no-cors',
                timeout: 3000
            })
            .then(() => {
                if (!isOnline) {
                    isOnline = true;
                    if (networkStatus) {
                        networkStatus.classList.remove('offline');
                        networkStatus.title = 'Online';
                    }
                }
            })
            .catch(error => {
                networkErrorCount++;
                const now = Date.now();
                
                // Only show error message if it's been a while since the last one
                if (now - lastNetworkErrorTime > 30000 && networkErrorCount > 2) {
                    showErrorMessage('Network connection is unstable.');
                    lastNetworkErrorTime = now;
                }
                
                if (networkErrorCount > 5) {
                    isOnline = false;
                    if (networkStatus) {
                        networkStatus.classList.add('offline');
                        networkStatus.title = 'Connection unstable';
                    }
                }
            });
        }
    }, NETWORK_CHECK_INTERVAL);
}

// Update map viewport dimensions
function updateMapViewportDimensions() {
    if (map && map._container) {
        mapViewportWidth = map._container.clientWidth;
        mapViewportHeight = map._container.clientHeight;
        
        // Store current map center and zoom
        if (map.getCenter()) {
            lastMapCenter = map.getCenter();
            lastMapZoom = map.getZoom();
        }
    }
}

// Initialize geolocation with priority for Geolocation Sensor API
function initGeolocation() {
    if ('GeolocationSensor' in window) {
        try {
            console.log('Trying GeolocationSensor API');
            geolocationSensor = new GeolocationSensor({ frequency: 1 });
            
            geolocationSensor.addEventListener('reading', () => {
                const position = {
                    coords: {
                        latitude: geolocationSensor.latitude,
                        longitude: geolocationSensor.longitude,
                        accuracy: geolocationSensor.accuracy,
                        altitude: geolocationSensor.altitude,
                        altitudeAccuracy: geolocationSensor.altitudeAccuracy,
                        heading: geolocationSensor.heading,
                        speed: geolocationSensor.speed
                    },
                    timestamp: geolocationSensor.timestamp
                };
                
                if (!lastPosition) {
                    initializeUserLocation(position);
                } else {
                    handlePositionUpdate(position);
                }
            });
            
            geolocationSensor.addEventListener('error', (error) => {
                console.warn('GeolocationSensor error:', error);
                // Fall back to standard Geolocation API
                useStandardGeolocation();
            });
            
            geolocationSensor.start();
            usingGeolocationSensorAPI = true;
            console.log('Using GeolocationSensor API');
        } catch (error) {
            console.warn('GeolocationSensor error:', error);
            // Fall back to standard Geolocation API
            useStandardGeolocation();
        }
    } else {
        // Fall back to standard Geolocation API
        useStandardGeolocation();
    }
}

// Standard Geolocation API fallback
function useStandardGeolocation() {
    console.log('Using standard Geolocation API');
    usingGeolocationSensorAPI = false;
    
    if ("geolocation" in navigator) {
        const options = {
            enableHighAccuracy: true,
            timeout: 45000,
            maximumAge: 0
        };

        // Try first time
        navigator.geolocation.getCurrentPosition(
            initializeUserLocation,
            (error) => {
                // Handle error based on error code
                if (error.code === PERMISSION_DENIED_ERROR) {
                    permissionDenied = true;
                    handleLocationPermissionDenied();
                } else {
                    // On other errors, try one more time before falling back
                    navigator.geolocation.getCurrentPosition(
                        initializeUserLocation,
                        handleLocationError,
                        options
                    );
                }
            },
            options
        );
    } else {
        showErrorMessage("Geolocation is not supported by your browser");
        map.setView([44.9778, -93.2650], 18);
        hideLoadingMessage();
    }
}

// Handle location permission denied
function handleLocationPermissionDenied() {
    permissionDenied = true;
    hideLoadingMessage();
    
    // Show error message
    showErrorMessage("Location access denied. Please enable location services to use this app.");
    
    // Show popup with instructions
    showPopup("Location Access Required", 
        "This app needs access to your location to guide you to historical sites. " +
        "Please enable location services in your browser settings and reload the page.", 
        'error', 
        () => {
            // Try to request permission again after a delay
            setTimeout(() => {
                if (!permissionRequestInProgress && Date.now() - lastPermissionRequest > 60000) {
                    requestLocationPermission();
                }
            }, 5000);
        }
    );
    
    // Set default view
    map.setView([44.9778, -93.2650], 18);
}

function requestLocationPermission() {
    if (permissionRequestInProgress) return;
    
    permissionRequestInProgress = true;
    lastPermissionRequest = Date.now();
    
    if ("geolocation" in navigator) {
        const options = {
            enableHighAccuracy: true,
            timeout: 10000,
            maximumAge: 0
        };
        
        navigator.geolocation.getCurrentPosition(
            (position) => {
                try {
                    // Extensive logging
                    console.log('Full position object:', JSON.stringify(position, null, 2));
                    console.log('Coordinates:', {
                        latitude: position.coords.latitude,
                        longitude: position.coords.longitude,
                        accuracy: position.coords.accuracy,
                        timestamp: position.timestamp
                    });

                    // Comprehensive coordinate validation
                    const latitude = position.coords.latitude;
                    const longitude = position.coords.longitude;
                    const accuracy = position.coords.accuracy;

                    if (
                        position &&
                        position.coords &&
                        Number.isFinite(latitude) &&
                        Number.isFinite(longitude) &&
                        latitude !== null &&
                        longitude !== null &&
                        latitude !== undefined &&
                        longitude !== undefined
                    ) {
                        permissionDenied = false;
                        permissionRequestInProgress = false;
                        
                        // Create location object with additional safety checks
                        const locationData = {
                            lat: Number(latitude.toFixed(6)),
                            lng: Number(longitude.toFixed(6)),
                            accuracy: Number(accuracy.toFixed(2)) || null,
                            timestamp: position.timestamp
                        };

                        console.log('Processed location data:', locationData);
                        
                        // Call initialization with processed data
                        initializeUserLocation(position);
                    } else {
                        throw new Error('Invalid or unexpected coordinate values');
                    }
                } catch (processingError) {
                    console.error('Location processing error:', processingError);
                    showErrorMessage("Failed to process location coordinates.");
                    handleLocationError(processingError);
                }
            },
            (error) => {
                permissionRequestInProgress = false;
                console.error('Geolocation Error Details:', {
                    code: error.code,
                    message: error.message,
                    fullError: JSON.stringify(error, null, 2)
                });

                switch(error.code) {
                    case PERMISSION_DENIED_ERROR:
                        permissionDenied = true;
                        showErrorMessage("Location access denied. Please enable location in your browser settings.");
                        break;
                    case POSITION_UNAVAILABLE_ERROR:
                        showErrorMessage("Location information is unavailable. Check your device's location services.");
                        break;
                    case TIMEOUT_ERROR:
                        showErrorMessage("Location request timed out. Please check your network connection.");
                        break;
                    default:
                        showErrorMessage("An unexpected error occurred while retrieving location.");
                }

                handleLocationError(error);
            },
            options
        );
    } else {
        console.error('Geolocation not supported');
        showErrorMessage("Geolocation is not supported by this browser.");
        
        // Optional: Trigger fallback mechanism
        handleLocationError(new Error('Geolocation not supported'));
    }
}
        
// Enhanced animation loop with proactive zoom adjustments
function startAnimationLoop() {
    function animate(timestamp) {
        // Calculate delta time
        const deltaTime = renderTimestamp ? (timestamp - renderTimestamp) / 1000 : 0;
        renderTimestamp = timestamp;
        
        // Process position updates
        processPositionUpdateQueue();
        
        // Update interpolated position
        if (positionInterpolator && positionInterpolator.isInterpolating()) {
            const interpolatedPosition = positionInterpolator.update();
            if (interpolatedPosition) {
                // Update marker position
                updateMarkerPosition(interpolatedPosition);
                lastRenderPosition = interpolatedPosition;
            }
        }
        
        // Check if we need to adjust zoom based on speed, even if not near edge
        const now = Date.now();
        if (followUser && !isMapInteracting && !edgeRecenterInProgress) {
            // Only check at regular intervals to improve performance
            if (now - lastEdgeCheck > edgeCheckInterval) {
                lastEdgeCheck = now;
                
                // Get current zoom and ideal zoom based on speed
                const currentZoom = map.getZoom();
                const idealZoom = calculateZoomLevel(currentSpeed);
                
                // If zoom difference is significant and we haven't recentered recently
                if (Math.abs(currentZoom - idealZoom) > 0.5 && 
                    now - lastRecenterTime > RECENTER_COOLDOWN) {
                    
                    // Check if marker is near edge
                    const recenterInfo = shouldRecenter(map, userMarker);
                    
                    if (recenterInfo.needsRecenter) {
                        // Perform full recenter if needed
                        performEdgeRecenter(recenterInfo);
                    } else if (!edgeRecenterInProgress) {
                        // Just adjust zoom if not near edge but zoom needs adjustment
                        map.setZoom(idealZoom, {
                            animate: true,
                            duration: ZOOM_TRANSITION_DURATION
                        });
                        lastRecenterTime = now; // Update to prevent too frequent adjustments
                    }
                } else {
                    // Regular edge check
                    const recenterInfo = shouldRecenter(map, userMarker);
                    if (recenterInfo.needsRecenter) {
                        performEdgeRecenter(recenterInfo);
                    }
                }
            }
        }
        
        // Check proximity to locations for zoom adjustments
        checkLocationProximity();
        
        // Update GPS signal indicator
        updateGpsSignalIndicator();
        
        // Request next frame
        animationFrameId = requestAnimationFrame(animate);
    }
    
    // Start animation loop
    animationFrameId = requestAnimationFrame(animate);
}

function updateMarkerPosition(position) {
    // Comprehensive validation
    if (!position) {
        console.error('Position is undefined or null');
        return;
    }

    // Check if lat and lng exist and are valid numbers
    const lat = Number(position.lat);
    const lng = Number(position.lng);

    // Validate coordinates
    if (
        !Number.isFinite(lat) || 
        !Number.isFinite(lng) || 
        Math.abs(lat) > 90 || 
        Math.abs(lng) > 180
    ) {
        console.error('Invalid coordinates:', {
            lat: position.lat, 
            lng: position.lng,
            rawPosition: position
        });
        return;
    }

    const now = Date.now();
    
    // Throttle updates to improve performance
    if (now - lastMapUpdate < mapUpdateThrottleInterval) {
        return;
    }
    
    lastMapUpdate = now;

    try {
        // Set marker with validated coordinates
        userMarker.setLatLng([lat, lng]);
    } catch (error) {
        console.error('Error setting marker position:', error, {
            lat, 
            lng, 
            originalPosition: position
        });
    }
}

// Update GPS signal indicator
function updateGpsSignalIndicator() {
    const now = Date.now();
    
    // Don't update too frequently
    if (now - lastAccuracyUpdate < GPS_SIGNAL_CHECK_INTERVAL) {
        return;
    }
    
    lastAccuracyUpdate = now;
    
    // Get current position accuracy
    let accuracy = 0;
    let signalText = '';
    let signalClass = '';
    
    if (lastPosition && typeof lastPosition.accuracy === 'number') {
        accuracy = lastPosition.accuracy;
        
        // Update confidence score history
        confidenceScoreHistory.push(calculateGpsConfidenceScore(accuracy));
        
        // Keep history at reasonable size
        while (confidenceScoreHistory.length > 5) {
            confidenceScoreHistory.shift();
        }
        
        // Calculate average confidence score
        gpsConfidenceScore = confidenceScoreHistory.reduce((sum, score) => sum + score, 0) / 
                            confidenceScoreHistory.length;
        
        // Determine signal quality
        if (accuracy <= GPS_CONFIDENCE_THRESHOLD_HIGH) {
            signalText = '';
            signalClass = 'accuracy-high';
        } else if (accuracy <= GPS_CONFIDENCE_THRESHOLD_MEDIUM) {
            signalText = '';
            signalClass = 'accuracy-medium';
        } else {
            signalText = '';
            signalClass = 'accuracy-low';
        }
    } else {
        signalText = '';
        signalClass = 'accuracy-low';
    }
    
    // Update indicator
    domUpdateManager.schedule('accuracyIndicator', () => {
        const indicator = document.getElementById('accuracyIndicator');
        if (indicator) {
            const dot = indicator.querySelector('.accuracy-dot');
            const text = document.getElementById('accuracyText');
            
            if (dot) {
                // Remove all classes
                dot.classList.remove('accuracy-high', 'accuracy-medium', 'accuracy-low');
                
                // Add appropriate class
                dot.classList.add(signalClass);
            }
            
            // Update text
            if (text) {
                text.textContent = signalText;
            }
        }
    });
}

// Calculate GPS confidence score (0-1)
function calculateGpsConfidenceScore(accuracy) {
    if (!accuracy || accuracy <= 0) return 0;
    
    // Higher accuracy (lower value) means higher confidence
    if (accuracy <= GPS_CONFIDENCE_THRESHOLD_HIGH) {
        return 1.0;
    } else if (accuracy <= GPS_CONFIDENCE_THRESHOLD_MEDIUM) {
        // Linear interpolation between high and medium thresholds
        return 0.5 + 0.5 * (GPS_CONFIDENCE_THRESHOLD_MEDIUM - accuracy) / 
               (GPS_CONFIDENCE_THRESHOLD_MEDIUM - GPS_CONFIDENCE_THRESHOLD_HIGH);
    } else {
        // Linear interpolation between medium threshold and max acceptable
        return Math.max(0.1, 0.5 * (MAX_ACCEPTABLE_ACCURACY - accuracy) / 
               (MAX_ACCEPTABLE_ACCURACY - GPS_CONFIDENCE_THRESHOLD_MEDIUM));
    }
}

// Process position update queue
function processPositionUpdateQueue() {
    if (positionUpdateQueue.length === 0) return;
    
    // Process all updates in queue
    while (positionUpdateQueue.length > 0) {
        const update = positionUpdateQueue.shift();
        processPositionUpdate(update);
    }
}

// Process position update
function processPositionUpdate(position) {
    // Skip if invalid position
    if (!position || typeof position.lat !== 'number' || typeof position.lng !== 'number' || 
        isNaN(position.lat) || isNaN(position.lng)) {
        return;
    }
    
    // Update last position
    lastPosition = position;
    
    // Start interpolation to new position
    if (lastRenderPosition && !isFirstPositionUpdate) {
        positionInterpolator.start(
            lastRenderPosition,
            position,
            isStationary ? 500 : ANIMATION_DURATION
        );
    } else {
        // First update, just set position directly
        userMarker.setLatLng([position.lat, position.lng]);
        lastRenderPosition = position;
        isFirstPositionUpdate = false;
    }
    
    // Auto-recenter map if following user
    if (followUser && !isMapInteracting) {
        const recenterInfo = shouldRecenter(map, userMarker);
        if (recenterInfo.needsRecenter) {
            performEdgeRecenter(recenterInfo);
        } else if (Math.abs(map.getZoom() - calculateZoomLevel(position.speedMPS)) > 0.5) {
            // If zoom level should change significantly but no recenter needed
            const newZoom = calculateZoomLevel(position.speedMPS);
            map.setZoom(newZoom, {
                animate: true,
                duration: ZOOM_TRANSITION_DURATION
            });
        }
    }
}

// Enhanced edge recenter function with better zoom handling
function performEdgeRecenter(recenterInfo) {
    edgeRecenterInProgress = true;
    
    // Get current position
    const position = userMarker.getLatLng();
    
    // Determine appropriate zoom level
    let targetZoom;
    if (recenterInfo.needsZoomAdjustment && recenterInfo.targetZoom) {
        // Use the recommended zoom from recenter info
        targetZoom = recenterInfo.targetZoom;
    } else {
        // Calculate based on current speed
        targetZoom = calculateZoomLevel(currentSpeed);
    }
    
    // Calculate optimal center point
    let optimalCenter;
    if (recenterInfo.edgeInfo) {
        // If we have edge info, use it to calculate optimal center
        optimalCenter = calculateOptimalCenter(map, position, recenterInfo.edgeInfo);
    } else {
        // Otherwise just use the marker position
        optimalCenter = position;
    }
    
    // Add a buffer to ensure the marker stays visible
    // This creates a slight offset in the direction of travel if we have heading information
    if (lastPosition && lastPosition.heading !== undefined && lastPosition.speedMPS > 1.0) {
        // Add a small offset in the direction of travel
        const heading = lastPosition.heading;
        const offsetDistance = Math.min(50, lastPosition.speedMPS * 5); // Meters, capped at 50m
        
        const headingRad = heading * Math.PI / 180;
        const latOffset = Math.cos(headingRad) * offsetDistance / 111000; // Approx meters to degrees
        const lngOffset = Math.sin(headingRad) * offsetDistance / (111000 * Math.cos(position.lat * Math.PI / 180));
        
        optimalCenter = {
            lat: optimalCenter.lat + latOffset,
            lng: optimalCenter.lng + lngOffset
        };
    }
    
    // Set view with animation
    // Use flyTo for smoother animation with better path prediction
    map.flyTo([optimalCenter.lat, optimalCenter.lng], targetZoom, {
        duration: recenterInfo.isEmergency ? 0.2 : ZOOM_TRANSITION_DURATION,
        easeLinearity: 0.5
    });
    
    // Reset edge recenter flag after animation completes
    setTimeout(() => {
        edgeRecenterInProgress = false;
    }, recenterInfo.isEmergency ? 300 : ZOOM_TRANSITION_DURATION * 1000);
}

function showLoadingMessage() {
    const loadingMessage = document.createElement('div');
    loadingMessage.id = 'loadingMessage';
    loadingMessage.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: rgba(255, 255, 255, 0.9);
        padding: 20px;
        border-radius: 10px;
        z-index: 1000;
        text-align: center;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    `;
    loadingMessage.innerHTML = `
        <div style="margin-bottom: 15px;">
            <div style="width: 40px; height: 40px; border: 4px solid rgba(255, 0, 0, 0.2); border-top: 4px solid #ff0000; border-radius: 50%; margin: 0 auto 15px; animation: spin 1s linear infinite;"></div>
        </div>
        <p style="font-weight: 500; color: #333;">Searching for your location...</p>
    `;
    document.body.appendChild(loadingMessage);
}

function hideLoadingMessage() {
    const loadingMessage = document.getElementById('loadingMessage');
    if (loadingMessage) {
        document.body.removeChild(loadingMessage);
    }
}

function showStabilizingModal() {
    const modal = document.createElement('div');
    modal.id = 'stabilizingModal';
    modal.className = 'stabilizing-modal';
    modal.innerHTML = `
        <div class="spinner"></div>
        <h3>Stabilizing Your Location</h3>
        <p>Please wait while we fine-tune your position.</p>
    `;
    document.body.appendChild(modal);
    
    // Auto-dismiss after 5 seconds
    setTimeout(() => {
        const stabilizingModal = document.getElementById('stabilizingModal');
        if (stabilizingModal) {
            stabilizingModal.style.opacity = '0';
            stabilizingModal.style.transition = 'opacity 0.5s ease';
            setTimeout(() => {
                if (stabilizingModal && stabilizingModal.parentNode) {
                    stabilizingModal.parentNode.removeChild(stabilizingModal);
                }
                isStabilizing = false;
            }, 500);
        }
    }, 5000);
}

function initializeUserLocation(position) {
    console.log("Initial position data:", JSON.stringify(position));

    if (!position || !position.coords) {
        console.error("Invalid initial position object");
        handleLocationError(new Error("Invalid initial position"));
        return;
    }

    const { latitude: userLat, longitude: userLng, accuracy } = position.coords;

    if (isNaN(userLat) || isNaN(userLng)) {
        console.error("Invalid initial coordinates:", { userLat, userLng });
        handleLocationError(new Error("Invalid initial coordinates"));
        return;
    }

    console.log("Valid initial position:", { userLat, userLng, accuracy });

    try {
        userMarker.setLatLng([userLat, userLng]);
        map.setView([userLat, userLng], 18);
        
        // Initialize Kalman filter with first position
        kalmanFilter.reset({
            lat: userLat,
            lng: userLng,
            accuracy: accuracy,
            heading: position.coords.heading,
            timestamp: Date.now()
        });
        
        // Initialize stationary position
        lastStationaryPosition = {
            lat: userLat,
            lng: userLng,
            accuracy: accuracy,
            heading: position.coords.heading,
            timestamp: Date.now(),
            speedMPS: 0
        };
        
        // Initialize last render position
        lastRenderPosition = {
            lat: userLat,
            lng: userLng,
            accuracy: accuracy,
            heading: position.coords.heading,
            timestamp: Date.now(),
            speedMPS: 0
        };
        
        // Initialize last valid position
        lastValidPosition = {
            lat: userLat,
            lng: userLng,
            accuracy: accuracy,
            heading: position.coords.heading,
            timestamp: Date.now(),
            speedMPS: 0
        };
        
        // Show stabilizing modal
        hideLoadingMessage();
        showStabilizingModal();
        
        // Start position updates
        startPositionUpdates();
        startHunt();
        
        // Reset location error count
        locationErrorCount = 0;
        isLocationAvailable = true;
    } catch (error) {
        console.error("Error setting initial user location:", error);
        handleLocationError(error);
    }
}

function startPositionUpdates() {
    // If already using GeolocationSensor API, don't start again
    if (usingGeolocationSensorAPI) {
        console.log('Position updates already using GeolocationSensor API');
        return;
    }
    
    // Use standard Geolocation API
    locationWatchId = navigator.geolocation.watchPosition(
        handlePositionUpdate,
        handleLocationError,
        {
            enableHighAccuracy: true,
            maximumAge: 1000,
            timeout: 10000
        }
    );
    console.log('Position updates using standard Geolocation API');
}

function handlePositionUpdate(position) {
    if (!position?.coords?.latitude || !position?.coords?.longitude) {
        console.warn("Invalid position data received");
        return;
    }
    
    // Reset error counters on successful update
    locationErrorCount = 0;
    isLocationAvailable = true;
    
    // Update GPS confidence score
    if (position.coords.accuracy) {
        const newScore = calculateGpsConfidenceScore(position.coords.accuracy);
        confidenceScoreHistory.push(newScore);
        
        // Keep history at reasonable size
        while (confidenceScoreHistory.length > 5) {
            confidenceScoreHistory.shift();
        }
        
        // Calculate average confidence score
        gpsConfidenceScore = confidenceScoreHistory.reduce((sum, score) => sum + score, 0) / 
                            confidenceScoreHistory.length;
    }
    
    updateUserLocation(position);
}

function handleVisibilityChange() {
    if (document.hidden) {
        lastHiddenTime = Date.now();
        lastKnownPosition = userMarker ? userMarker.getLatLng() : null;
        
        // Cancel any active interpolation
        if (positionInterpolator) {
            positionInterpolator.cancel();
        }
        
        // Cancel animation frame
        if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
        }
        
        // Stop GeolocationSensor if using it
        if (usingGeolocationSensorAPI && geolocationSensor) {
            geolocationSensor.stop();
        }
    } else {
        const hiddenDuration = Date.now() - lastHiddenTime;
        if (hiddenDuration > BACKGROUND_THRESHOLD) {
            updateLocationAfterBackground();
        } else {
            map.invalidateSize();
            
            // Restart animation loop
            if (!animationFrameId) {
                startAnimationLoop();
            }
            
            // Restart GeolocationSensor if using it
            if (usingGeolocationSensorAPI && geolocationSensor) {
                geolocationSensor.start();
            }
            
            // If returning from exhibit, ensure movement resumes properly
            if (isReturningFromExhibit) {
                isReturningFromExhibit = false;
                // Force a position update to resume tracking
                if (lastValidPosition) {
                    updateUserLocation({
                        coords: {
                            latitude: lastValidPosition.lat,
                            longitude: lastValidPosition.lng,
                            accuracy: lastValidPosition.accuracy,
                            heading: lastValidPosition.heading,
                            speed: lastValidPosition.speedMPS
                        },
                        timestamp: Date.now()
                    }, true);
                }
            }
        }
    }
    resetInactivityTimer();
}

function updateLocationAfterBackground() {
    if ("geolocation" in navigator) {
        navigator.geolocation.getCurrentPosition(
            (position) => {
                console.log("Background update raw position:", JSON.stringify(position));
                if (!position || !position.coords) {
                    console.warn("Invalid position object in background update");
                    return;
                }
                const { latitude, longitude, accuracy } = position.coords;
                if (isNaN(latitude) || isNaN(longitude)) {
                    console.warn("Invalid coordinates in background update:", { latitude, longitude });
                    return;
                }
                
                console.log("Valid background position update:", { lat: latitude, lng: longitude });
                try {
                    updateUserLocation(position, true);
                } catch (error) {
                    console.error("Error in updateUserLocation during background update:", error);
                }
                
                // Reset tracking variables
                lastPosition = null;
                positionBuffer = [];
                velocity = { lat: 0, lng: 0 };
                lastVelocity = { lat: 0, lng: 0 };
                isStationary = false;
                stationaryStartTime = null;
                stationaryCount = 0;
                stationaryPositionHistory = [];
                lastStationaryPosition = null;
                stationaryPositionLocked = false;
                positionHistory = [];
                suddenMovementCount = 0;
                isJumpDetected = false;
                
                // Reset Kalman filter
                kalmanFilter.reset({
                    lat: latitude,
                    lng: longitude,
                    accuracy: accuracy,
                    heading: position.coords.heading,
                    timestamp: Date.now()
                });
                
                // Restart animation loop
                if (!animationFrameId) {
                    startAnimationLoop();
                }
                
                // Restart GeolocationSensor if using it
                if (usingGeolocationSensorAPI && geolocationSensor) {
                    geolocationSensor.start();
                }
                
                updateDistanceBox();
                followUser = true;
                map.invalidateSize();
            },
            (error) => {
                console.error("Error getting location after background:", error);
                handleLocationError(error);
            },
            {
                enableHighAccuracy: true,
                timeout: 10000,
                maximumAge: 0
            }
        );
    } else {
        console.warn("Geolocation is not available");
        showErrorMessage("Unable to update your location after background. Please reload the app.");
    }
}

// Helper function to validate position data
function isValidPosition(pos) {
    return pos && 
           typeof pos.lat === 'number' && !isNaN(pos.lat) &&
           typeof pos.lng === 'number' && !isNaN(pos.lng) &&
           typeof pos.accuracy === 'number' && !isNaN(pos.accuracy);
}

// Fix for Haversine distance calculation
function calculateDistance(pos1, pos2) {
    if (!pos1 || !pos2 || 
        typeof pos1.lat !== 'number' || typeof pos1.lng !== 'number' || 
        typeof pos2.lat !== 'number' || typeof pos2.lng !== 'number' ||
        isNaN(pos1.lat) || isNaN(pos1.lng) || isNaN(pos2.lat) || isNaN(pos2.lng)) {
        return Infinity;
    }
    
    const R = 6371000; // Earth's radius in meters
    const lat1 = pos1.lat * Math.PI / 180;
    const lat2 = pos2.lat * Math.PI / 180;
    const deltaLat = (pos2.lat - pos1.lat) * Math.PI / 180;
    const deltaLng = (pos2.lng - pos1.lng) * Math.PI / 180;

    const a = Math.sin(deltaLat/2) * Math.sin(deltaLat/2) +
            Math.cos(lat1) * Math.cos(lat2) *
            Math.sin(deltaLng/2) * Math.sin(deltaLng/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

    return R * c; // Distance in meters
}

// Linear interpolation helper
function lerp(a, b, t) {
    if (typeof a !== 'number' || typeof b !== 'number' || typeof t !== 'number' ||
        isNaN(a) || isNaN(b) || isNaN(t)) {
        return a;
    }
    
    return a + (b - a) * Math.max(0, Math.min(1, t));
}

// Update position buffer with new position
function updatePositionBuffer(position) {
    if (!isValidPosition(position)) {
        return;
    }
    
    // Add new position to buffer
    positionBuffer.push({
        lat: position.lat,
        lng: position.lng,
        accuracy: position.accuracy,
        heading: position.heading,
        timestamp: position.timestamp,
        speedMPS: position.speedMPS
    });

    // Remove old positions if buffer exceeds maxSize
    while (positionBuffer.length > MAX_BUFFER_SIZE) {
        positionBuffer.shift();
    }
}

// Update position history for jump detection
function updatePositionHistory(position) {
    if (!isValidPosition(position)) {
        return;
    }
    
    // Add new position to history
    positionHistory.push({
        lat: position.lat,
        lng: position.lng,
        accuracy: position.accuracy,
        heading: position.heading,
        timestamp: position.timestamp,
        speedMPS: position.speedMPS
    });
    
    // Keep only recent positions
    while (positionHistory.length > 10) {
        positionHistory.shift();
    }
}

function initializeFirstPosition(newPosition) {
    lastPosition = newPosition;
    lastValidPosition = newPosition;
    userMarker.setLatLng([newPosition.lat, newPosition.lng]);
    kalmanFilter.reset(newPosition);
    lastUpdateTime = newPosition.timestamp;
    stationaryStartTime = newPosition.timestamp;
    positionBuffer = [newPosition];
    positionHistory = [newPosition];
    lastStationaryPosition = newPosition;
    lastRenderPosition = newPosition;

    // Set initial zoom based on stationary state
    const initialZoom = calculateZoomLevel(0);
    map.setView([newPosition.lat, newPosition.lng], initialZoom, { animate: false });
    updateDistanceBox();
}

function handlePositionJump(newPosition) {
    if (isStationary && stationaryPositionLocked) {
        console.log("Position jump detected while stationary, ignoring update");
        isJumpDetected = true;
        return;
    }
}

function handleLargePositionChange(newPosition) {
    resetStationaryState();
    userMarker.setLatLng([newPosition.lat, newPosition.lng]);
    lastPosition = newPosition;
    lastValidPosition = newPosition;
    lastRenderPosition = newPosition;
    positionBuffer = [newPosition];
    positionHistory = [newPosition];
    kalmanFilter.reset(newPosition);
    kalmanFilter.setStationaryMode(false);
    lastVelocity = { lat: 0, lng: 0 };
    lastSmoothedPosition = null;

    if (positionInterpolator) {
        positionInterpolator.cancel();
    }

    const zoomLevel = calculateZoomLevel(newPosition.speedMPS);
    map.setView([newPosition.lat, newPosition.lng], zoomLevel, {
        animate: true,
        duration: 0.3,
        noMoveStart: true
    });

    lastUpdateTime = newPosition.timestamp;
    lastUpdateTimestamp = newPosition.timestamp;
    updateDistanceBox();

    if (map._container) {
        map._onResize();
    }
}

function resetStationaryState() {
    if (stationaryCheckTimeout) {
        clearTimeout(stationaryCheckTimeout);
        stationaryCheckTimeout = null;
    }
    
    if (stationaryLockTimeout) {
        clearTimeout(stationaryLockTimeout);
        stationaryLockTimeout = null;
    }
    
    isStationary = false;
    stationaryStartTime = null;
    stationaryCount = 0;
    stationaryPositionHistory = [];
    lastStationaryPosition = null;

    stationaryPositionLocked = false;
    isJumpDetected = false;
}

function updateStationaryState(newPosition, motionDetected) {
    // Validate input 
    if (!newPosition || !lastPosition) return;

    // Calculate distance from last position 
    const distance = calculateDistance(lastPosition, newPosition);

    // Calculate confidence score for stationary state 
    const accuracyScore = Math.max(0, 1 - (newPosition.accuracy / MAX_ACCEPTABLE_ACCURACY)); // Higher accuracy = higher score 
    const motionScore = motionDetected ? 0 : 1; // No motion = higher score 
    const historyScore = stationaryPositionHistory.length > 5 ? 1 : 0.5; // More history = higher score

    // Combine scores to get overall confidence 
    const stationaryConfidence = (accuracyScore + motionScore + historyScore) / 3;

    // Check if the user is likely stationary 
    if (distance < MICRO_MOVEMENT_THRESHOLD && stationaryConfidence > 0.8) { 
        stationaryCount++;

        // Transition to stationary state if confidence is high and threshold is met 
        if (!isStationary && stationaryCount >= STATIONARY_THRESHOLD) { 
            setStationary(newPosition); 
        } 
    } else { 
        // Decrease stationary count if movement is detected 
        stationaryCount = Math.max(0, stationaryCount - 1);

        // Transition to moving state if confidence drops below a threshold 
        if (isStationary && stationaryCount < STATIONARY_THRESHOLD / 2) { 
            setMoving(); 
        } 
    }

    // Update stationary position history for averaging 
    if (isStationary) { 
        stationaryPositionHistory.push(newPosition); 
        if (stationaryPositionHistory.length > STATIONARY_POSITION_HISTORY_SIZE) { 
            stationaryPositionHistory.shift(); 
        } 
    }
}

function setStationary(newPosition) {
    isStationary = true;
    console.log("User is now stationary");

    // Enable stationary mode in Kalman filter
    kalmanFilter.setStationaryMode(true);
    stationaryStartTime = newPosition.timestamp;

    // Add new position to stationary history
    updateStationaryPositionHistory(newPosition);

    // Calculate stable position using weighted average
    const stablePosition = calculateStationaryWeightedAverage() || newPosition;

    if (stablePosition) {
        // Update position queue and state
        positionUpdateQueue.push(stablePosition);
        lastPosition = stablePosition;
        lastValidPosition = stablePosition;
        lastStationaryPosition = stablePosition;

        // Lock the stationary position after a short delay
        stationaryLockTimeout = setTimeout(() => {
            stationaryPositionLocked = true;
            stationaryPositionLockTime = Date.now();
            console.log("Stationary position locked after delay");

            // Lock the position in the Kalman filter
            kalmanFilter.lockStationaryPosition(lastStationaryPosition);
        }, 3000); // 3-second delay before locking
    }

    // Schedule the next stationary check
    stationaryCheckTimeout = setTimeout(() => checkStationaryState(newPosition), STATIONARY_CHECK_INTERVAL);

    // Adjust map zoom if following the user
    if (followUser && !isMapInteracting) {
        const stationaryZoom = calculateZoomLevel(0);
        map.setZoom(stationaryZoom, {
            animate: true,
            duration: ZOOM_TRANSITION_DURATION
        });
    }

    // Update the distance box
    updateDistanceBox();
}

function updateStationaryPositionHistory(newPosition) {
    stationaryPositionHistory.push(newPosition);
    if (stationaryPositionHistory.length > STATIONARY_POSITION_HISTORY_SIZE) {
        stationaryPositionHistory.shift();
    }
}

function calculateStationaryWeightedAverage() {
    if (stationaryPositionHistory.length === 0) return null;

    let totalWeight = 0;
    let weightedLat = 0;
    let weightedLng = 0;

    // Calculate weighted average
    stationaryPositionHistory.forEach((pos, index) => {
        const weight = Math.pow(0.8, stationaryPositionHistory.length - index); // Exponential decay
        totalWeight += weight;
        weightedLat += pos.lat * weight;
        weightedLng += pos.lng * weight;
    });

    return {
        lat: weightedLat / totalWeight,
        lng: weightedLng / totalWeight,
        accuracy: stationaryPositionHistory[stationaryPositionHistory.length - 1].accuracy, // Use latest accuracy
        timestamp: Date.now(),
        speedMPS: 0
    };
}
        
function setMoving() {
    isStationary = false;
    stationaryPositionLocked = false;
    kalmanFilter.setStationaryMode(false);

    if (stationaryLockTimeout) {
        clearTimeout(stationaryLockTimeout);
        stationaryLockTimeout = null;
    }

    console.log("User is moving again");
}

function checkStationaryState(newPosition) {
  if (!lastPosition) return;
  
  // Calculate distance between current and last position
  const distance = calculateDistance(lastPosition, newPosition);
  
  // Check if device motion sensors indicate movement
  const motionDetected = isDeviceInMotion();
  
  // If significant movement is detected or motion sensors indicate activity
  if (distance >= MICRO_MOVEMENT_THRESHOLD || motionDetected) {
    if (isStationary) {
      console.debug("Movement detected, transitioning to moving state");
      setMoving();
    }
    
    // Clear the stationary check timeout
    if (stationaryCheckTimeout) {
      clearTimeout(stationaryCheckTimeout);
      stationaryCheckTimeout = null;
    }
  } else {
    // If no significant movement, increment stationary count
    stationaryCount++;
    
    // If stationary count exceeds threshold, transition to stationary state
    if (!isStationary && stationaryCount >= STATIONARY_THRESHOLD) {
      setStationary(newPosition);
    }
    
    // Schedule the next stationary check
    if (isStationary && !stationaryCheckTimeout) {
      stationaryCheckTimeout = setTimeout(() => {
        stationaryCheckTimeout = null;
        checkStationaryState(newPosition);
      }, STATIONARY_CHECK_INTERVAL);
    }
  }
}
        
// Predict position based on heading and speed
function predictPositionFromHeading(position, heading, distance) {
    // Input validation
    if (!position || typeof heading !== 'number' || typeof distance !== 'number' ||
        !position.lat || !position.lng || isNaN(heading) || isNaN(distance)) {
        return position;
    }

    // Normalize heading to 0-360 range
    heading = ((heading % 360) + 360) % 360;

    // Earth's radius in meters
    const R = 6371e3;

    // Convert to radians
    const d = distance / R;
    const  = heading * Math.PI / 180;
    const 1 = position.lat * Math.PI / 180;
    const 1 = position.lng * Math.PI / 180;

    // Calculate predicted position with error handling
    try {
        const sin1 = Math.sin(1);
        const cos1 = Math.cos(1);
        const cosd = Math.cos(d);
        const sind = Math.sin(d);
        const cos = Math.cos();

        const 2 = Math.asin(
            sin1 * cosd +
            cos1 * sind * cos
        );

        const 2 = 1 + Math.atan2(
            Math.sin() * sind * cos1,
            cosd - sin1 * Math.sin(2)
        );

        // Convert back to degrees with bounds checking
        const newLat = Math.max(-90, Math.min(90, 2 * 180 / Math.PI));
        const newLng = ((2 * 180 / Math.PI + 540) % 360) - 180;

        return {
            lat: newLat,
            lng: newLng
        };
    } catch (error) {
        // Fallback to original position if calculation fails
        return position;
    }
}

function checkGeofence(locationPos, locationName) {
    const userLatLng = userMarker.getLatLng();
    
    // Validate coordinates
    if (!userLatLng || !locationPos || 
        typeof userLatLng.lat !== 'number' || typeof userLatLng.lng !== 'number' ||
        typeof locationPos.lat !== 'number' || typeof locationPos.lng !== 'number' ||
        isNaN(userLatLng.lat) || isNaN(userLatLng.lng) ||
        isNaN(locationPos.lat) || isNaN(locationPos.lng)) {
        return;
    }
    
    const distance = calculateDistance(userLatLng, locationPos); // Distance in meters
    const notification = document.getElementById('approachNotification');

    if (distance <= GEOFENCE_RADIUS_METERS) { // Compare in meters
        if (!notification) {
            showApproachNotification(locationName);
        }
    } else if (notification) {
        // Remove notification if user moves out of the radius
        document.body.removeChild(notification);
    }
}

function showApproachNotification(locationName) {
    // Check if a notification is already shown
    if (document.getElementById('approachNotification')) return;

    // Create notification element
    const notification = document.createElement('div');
    notification.id = 'approachNotification';
    notification.style.cssText = `
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background-color: white;
        padding: 15px;
        border-radius: 10px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        display: flex;
        align-items: center;
        gap: 10px;
        z-index: 1000;
    `;

    // Add message
    const message = document.createElement('span');
    message.textContent = `You are approaching "${locationName}".`;
    notification.appendChild(message);

    // Add "Continue" button
    const continueButton = document.createElement('button');
    continueButton.textContent = 'Continue';
    continueButton.style.cssText = `
        padding: 5px 10px;
        background-color: #0f2bab;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
    `;
    continueButton.onclick = () => {
        document.body.removeChild(notification);
    };
    notification.appendChild(continueButton);

    // Add notification to the DOM
    document.body.appendChild(notification);
}

function updateUserLocation(position, forceUpdate = false) {
    // Validate input position
    if (!position?.coords?.latitude || !position?.coords?.longitude) {
        console.warn("Invalid position data received");
        return;
    }

    const currentTime = Date.now();
    const timeDelta = lastUpdateTime ? (currentTime - lastUpdateTime) / 1000 : 0;

    // Create position object
    const newPosition = {
        lat: position.coords.latitude,
        lng: position.coords.longitude,
        accuracy: position.coords.accuracy || 20,
        heading: position.coords.heading !== null ? position.coords.heading : (lastHeadingValue || undefined),
        timestamp: currentTime,
        speedMPS: position.coords.speed !== null ? position.coords.speed : 0
    };

    // First position initialization
    if (!lastPosition) {
        initializeFirstPosition(newPosition);
        return;
    }

    // Calculate distance from last position
    const distance = calculateDistance(lastPosition, newPosition);

    // Check for sudden movements or position jumps
    if (!forceUpdate && detectSuddenMovement(newPosition, lastPosition)) {
        handlePositionJump(newPosition);
        return;
    }

    // Handle large position changes or forced updates
    if (distance > EXTENDED_DISTANCE_THRESHOLD || forceUpdate) {
        handleLargePositionChange(newPosition);
        return;
    }

    // Skip updates with poor accuracy or unrealistic movement
    if (!forceUpdate && (newPosition.accuracy > MAX_ACCEPTABLE_ACCURACY || (timeDelta > 0 && distance / timeDelta > 50))) {
        console.log("Skipping update due to poor accuracy or unrealistic movement");
        return;
    }

    try {
        // Check if device is in motion based on motion sensors
        const motionDetected = deviceMotion && isDeviceInMotion();

        // Update stationary state
        updateStationaryState(newPosition, motionDetected);

        // If stationary and position is locked, skip updates
        if (isStationary && stationaryPositionLocked && lastStationaryPosition) {
            updateDistanceBox();
            return;
        }

        // Apply Kalman filter with motion detection
        const filteredPosition = kalmanFilter.update(newPosition, motionDetected);

        // Update position buffer and history
        updatePositionBuffer(filteredPosition);
        updateStationaryPositionHistory(filteredPosition); // Use stationary-specific history

        // Determine final position based on movement state
        let finalPosition;

        if (isStationary) {
            // When stationary, use the stable position with minimal updates
            if (lastStationaryPosition) {
                // Only update if accuracy significantly improves
                if (newPosition.accuracy < lastStationaryPosition.accuracy * 0.8) {
                    // Calculate new stable position using weighted average
                    const stablePosition = calculateStationaryWeightedAverage();
                    if (stablePosition) {
                        // Smooth transition to new stable position
                        finalPosition = {
                            lat: lerp(lastStationaryPosition.lat, stablePosition.lat, 0.01), // Reduced to minimize jitter
                            lng: lerp(lastStationaryPosition.lng, stablePosition.lng, 0.01), // Reduced to minimize jitter
                            accuracy: stablePosition.accuracy,
                            heading: stablePosition.heading,
                            timestamp: currentTime,
                            speedMPS: 0
                        };

                        // Add to position update queue
                        positionUpdateQueue.push(finalPosition);
                        lastPosition = finalPosition;
                        lastValidPosition = finalPosition;
                        lastStationaryPosition = finalPosition;
                    } else {
                        finalPosition = lastStationaryPosition;
                    }
                } else {
                    // Use existing stable position
                    finalPosition = lastStationaryPosition;
                }
            } else {
                // If no stable position yet, calculate one using weighted average
                const stablePosition = calculateStationaryWeightedAverage();
                if (stablePosition) {
                    finalPosition = stablePosition;
                    lastStationaryPosition = stablePosition;
                    lastValidPosition = stablePosition;

                    // Add to position update queue
                    positionUpdateQueue.push(finalPosition);
                } else {
                    finalPosition = filteredPosition;
                    lastValidPosition = filteredPosition;

                    // Add to position update queue
                    positionUpdateQueue.push(finalPosition);
                }
                lastPosition = finalPosition;
            }
        } else {
            // Smooth movement when active
            finalPosition = filteredPosition;
            lastValidPosition = filteredPosition;

            // Apply heading-based prediction for smoother movement
            if (finalPosition.heading !== undefined && finalPosition.speedMPS > 0.5) {
                const predictedPosition = predictPositionFromHeading(
                    finalPosition,
                    finalPosition.heading,
                    finalPosition.speedMPS * 0.3 // Predict slightly ahead
                );

                // Blend predicted and filtered positions
                finalPosition = {
                    lat: lerp(finalPosition.lat, predictedPosition.lat, 0.2),
                    lng: lerp(finalPosition.lng, predictedPosition.lng, 0.2),
                    accuracy: finalPosition.accuracy,
                    heading: finalPosition.heading,
                    timestamp: currentTime,
                    speedMPS: finalPosition.speedMPS
                };
            }

            // Add to position update queue
            positionUpdateQueue.push(finalPosition);
            lastPosition = finalPosition;
        }

        lastUpdateTime = currentTime;
        lastUpdateTimestamp = currentTime;

        // Update distance box (existing functionality)
        updateDistanceBox();

        // Check geofence for all locations
        gameLocations.forEach(location => {
            if (location && typeof location.lat === 'number' && typeof location.lng === 'number' &&
                !isNaN(location.lat) && !isNaN(location.lng)) {
                const locationPos = { lat: location.lat, lng: location.lng };
                checkGeofence(locationPos, location.name);
            }
        });

    } catch (error) {
        console.error("Location update error:", error);
        // Fallback with basic filtering
        userMarker.setLatLng([newPosition.lat, newPosition.lng]);
        lastPosition = newPosition;
        lastValidPosition = newPosition;
        lastRenderPosition = newPosition;
        updateDistanceBox();
    }
}
        
// Enhanced edge detection with dynamic thresholds based on speed
function isMarkerNearEdge(map, marker, isStrict = false) {
    if (!map || !marker) return { isNearEdge: false };
    
    const bounds = map.getBounds();
    const point = marker.getLatLng();
    
    // Validate coordinates
    if (!bounds || !point || typeof point.lat !== 'number' || typeof point.lng !== 'number' ||
        isNaN(point.lat) || isNaN(point.lng)) {
        return { isNearEdge: false };
    }
    
    const proximities = calculateEdgeProximity(map, point);
    
    // Adjust threshold based on speed - faster movement needs earlier detection
    let thresholdPercentage;
    if (isStrict) {
        thresholdPercentage = 0.12; // Strict threshold for critical recentering
    } else {
        // Dynamic threshold based on speed
        // Higher speeds get larger thresholds to recenter earlier
        if (currentSpeed < 1.0) {
            thresholdPercentage = EDGE_THRESHOLD_PERCENTAGE; // Base threshold for slow movement
        } else if (currentSpeed < 5.0) {
            thresholdPercentage = EDGE_THRESHOLD_PERCENTAGE * 1.1; // 10% larger for moderate speed
        } else if (currentSpeed < 10.0) {
            thresholdPercentage = EDGE_THRESHOLD_PERCENTAGE * 1.2; // 20% larger for higher speed
        } else {
            thresholdPercentage = EDGE_THRESHOLD_PERCENTAGE * 1.3; // 30% larger for very high speed
        }
    }
    
    const edges = {
        north: proximities.north < thresholdPercentage,
        south: proximities.south < thresholdPercentage,
        east: proximities.east < thresholdPercentage,
        west: proximities.west < thresholdPercentage
    };
    
    return {
        isNearEdge: Object.values(edges).some(edge => edge),
        edges: edges,
        proximities: proximities
    };
}

// Calculate proximity to map edges
function calculateEdgeProximity(map, point) {
    const bounds = map.getBounds();
    
    // Validate bounds and point
    if (!bounds || !point || typeof point.lat !== 'number' || typeof point.lng !== 'number' ||
        isNaN(point.lat) || isNaN(point.lng)) {
        return { north: 1, south: 1, east: 1, west: 1 };
    }
    
    const latSpan = bounds.getNorth() - bounds.getSouth();
    const lngSpan = bounds.getEast() - bounds.getWest();
    
    // Avoid division by zero
    if (latSpan === 0 || lngSpan === 0) {
        return { north: 1, south: 1, east: 1, west: 1 };
    }
    
    return {
        north: Math.abs(point.lat - bounds.getNorth()) / latSpan,
        south: Math.abs(point.lat - bounds.getSouth()) / latSpan,
        east: Math.abs(point.lng - bounds.getEast()) / lngSpan,
        west: Math.abs(point.lng - bounds.getWest()) / lngSpan
    };
}

// Improved recenter decision logic with speed consideration
function shouldRecenter(map, marker) {
    const now = Date.now();
    
    // Respect cooldown period to prevent too frequent recenters
    if (now - lastRecenterTime < RECENTER_COOLDOWN) {
        return { needsRecenter: false };
    }
    
    if (!map || !marker) return { needsRecenter: false };
    
    // Get current zoom and calculate ideal zoom based on speed
    const currentZoom = map.getZoom();
    const idealZoom = calculateZoomLevel(currentSpeed);
    
    // Check if we need a zoom adjustment (more than 0.5 zoom level difference)
    const needsZoomAdjustment = Math.abs(currentZoom - idealZoom) > 0.5;
    
    // Get edge proximity information
    const edgeInfo = isMarkerNearEdge(map, marker);
    
    // Validate edge info
    if (!edgeInfo || !edgeInfo.proximities) {
        // If we only need zoom adjustment, still trigger a recenter
        if (needsZoomAdjustment) {
            lastRecenterTime = now;
            return {
                needsRecenter: true,
                isEmergency: false,
                needsZoomAdjustment: true,
                targetZoom: idealZoom
            };
        }
        return { needsRecenter: false };
    }
    
    const proximities = edgeInfo.proximities;
    
    // Check for critical edge proximity (very close to edge)
    const isCritical = Object.values(proximities).some(
        proximity => proximity < CRITICAL_EDGE_THRESHOLD
    );
    
    if (isCritical) {
        lastRecenterTime = now;
        return {
            needsRecenter: true,
            isEmergency: true,
            edgeInfo: edgeInfo,
            needsZoomAdjustment: needsZoomAdjustment,
            targetZoom: idealZoom
        };
    }
    
    // Check for normal edge proximity
    if (edgeInfo.isNearEdge) {
        lastRecenterTime = now;
        return {
            needsRecenter: true,
            isEmergency: false,
            edgeInfo: edgeInfo,
            needsZoomAdjustment: needsZoomAdjustment,
            targetZoom: idealZoom
        };
    }
    
    // If we're not near an edge but need zoom adjustment
    if (needsZoomAdjustment) {
        lastRecenterTime = now;
        return {
            needsRecenter: true,
            isEmergency: false,
            needsZoomAdjustment: true,
            targetZoom: idealZoom
        };
    }
    
    return {
        needsRecenter: false,
        isEmergency: false,
        edgeInfo: edgeInfo
    };
}

// Calculate optimal center point with improved positioning
function calculateOptimalCenter(map, markerPosition, edgeInfo) {
    if (!map || !markerPosition || !edgeInfo) {
        return markerPosition;
    }
    
    const bounds = map.getBounds();
    
    // Validate bounds and marker position
    if (!bounds || typeof markerPosition.lat !== 'number' || typeof markerPosition.lng !== 'number' ||
        isNaN(markerPosition.lat) || isNaN(markerPosition.lng)) {
        return markerPosition;
    }
    
    // Calculate offsets based on which edges are being approached
    let latOffset = 0;
    let lngOffset = 0;
    
    // Apply stronger offset for the closest edge
    const proximities = edgeInfo.proximities;
    const edges = edgeInfo.edges;
    
    // Get viewport dimensions
    const viewportWidth = mapViewportWidth || map._container.clientWidth;
    const viewportHeight = mapViewportHeight || map._container.clientHeight;
    
    // Calculate aspect ratio to adjust offsets
    const aspectRatio = viewportWidth / viewportHeight;
    
    // Adjust offsets based on viewport dimensions
    const latSpan = bounds.getNorth() - bounds.getSouth();
    const lngSpan = bounds.getEast() - bounds.getWest();
    
    // Scale offset based on speed - faster movement needs more space
    const speedFactor = Math.min(2.0, Math.max(1.0, currentSpeed / 5.0));
    
    // Calculate offsets with consideration for viewport aspect ratio and speed
    if (edges.north) {
        latOffset = -1 * latSpan * 0.25 * (1 / aspectRatio) * speedFactor;
    }
    if (edges.south) {
        latOffset = latSpan * 0.25 * (1 / aspectRatio) * speedFactor;
    }
    if (edges.east) {
        lngOffset = -1 * lngSpan * 0.25 * aspectRatio * speedFactor;
    }
    if (edges.west) {
        lngOffset = lngSpan * 0.25 * aspectRatio * speedFactor;
    }
    
    // If we have heading information, add a slight bias in the direction of travel
    if (lastPosition && lastPosition.heading !== undefined && lastPosition.speedMPS > 1.0) {
        const heading = lastPosition.heading;
        const headingRad = heading * Math.PI / 180;
        
        // Calculate directional bias (stronger at higher speeds)
        const directionBias = Math.min(0.1, lastPosition.speedMPS * 0.01);
        
        // Add slight bias in direction of travel
        latOffset += Math.cos(headingRad) * latSpan * directionBias;
        lngOffset += Math.sin(headingRad) * lngSpan * directionBias;
    }
    
    return {
        lat: markerPosition.lat + latOffset,
        lng: markerPosition.lng + lngOffset
    };
}

function updateDistanceBox() {
    // Initial validation
    if (!userMarker || !gameLocations || gameLocations.length === 0) {
        const distanceBox = document.getElementById("distanceBox");
        if (distanceBox) {
            distanceBox.innerText = "Initializing...";
        }
        return;
    }

    // Get user coordinates
    const userLatLng = userMarker.getLatLng();
    
    // Validate user coordinates
    if (!userLatLng || typeof userLatLng.lat !== 'number' || typeof userLatLng.lng !== 'number' ||
        isNaN(userLatLng.lat) || isNaN(userLatLng.lng)) {
        console.warn("Invalid user coordinates:", userLatLng);
        const distanceBox = document.getElementById("distanceBox");
        if (distanceBox) {
            distanceBox.innerText = "Initializing...";
        }
        return;
    }
    
    let userLat = userLatLng.lat;
    let userLng = userLatLng.lng;

    // Use map center if at origin
    if (userLat === 0 && userLng === 0) {
        const center = map.getCenter();
        if (center && typeof center.lat === 'number' && typeof center.lng === 'number') {
            userLat = center.lat;
            userLng = center.lng;
        } else {
            console.warn("Invalid map center:", center);
            return;
        }
    }

    // Find closest location
    let closestDistance = Infinity;
    let closestLocation = null;
    const userPos = { lat: userLat, lng: userLng };

    for (const location of gameLocations) {
        if (!location || typeof location.lat !== "number" || typeof location.lng !== "number" ||
            isNaN(location.lat) || isNaN(location.lng)) {
            console.warn("Invalid location data:", location);
            continue;
        }

        const locationPos = { lat: location.lat, lng: location.lng };
        const distance = calculateDistance(userPos, locationPos);

        if (isFinite(distance) && distance < closestDistance) {
            closestDistance = distance;
            closestLocation = location;
        }
    }

    // Validate final distance calculation
    if (!isFinite(closestDistance) || closestDistance === Infinity) {
        console.warn("Invalid distance calculation:", closestDistance);
        const distanceBox = document.getElementById("distanceBox");
        if (distanceBox) {
            distanceBox.innerText = "Initializing...";
        }
        return;
    }

    // Calculate and display distance
    const distanceFeet = Math.round(closestDistance * 3.28084);
    const distanceText = distanceFeet < 5280 
        ? `${distanceFeet.toLocaleString()} feet` 
        : `${(distanceFeet / 5280).toFixed(2)} miles`;
    
    const distanceBox = document.getElementById("distanceBox");
    if (distanceBox) {
        distanceBox.innerText = `Closest Stop: ${distanceText}`;
    }

    // Check if we should show location hunt - THIS IS THE CRITICAL PART
    if (distanceFeet <= DISTANCE_THRESHOLD && !isLocationHuntVisible && closestLocation) {
        console.log(`User is within threshold distance (${distanceFeet} feet). Opening location page.`);
        showLocationHunt(closestLocation);
    }
}

// Show error message
function showErrorMessage(message) {
    // Remove any existing error messages
    const existingErrors = document.querySelectorAll('.error-message');
    existingErrors.forEach(error => {
        if (error.parentNode) {
            error.parentNode.removeChild(error);
        }
    });
    
    // Create new error message
    const errorMessage = document.createElement('div');
    errorMessage.className = 'error-message';
    errorMessage.textContent = message;
    document.body.appendChild(errorMessage);
    
    // Auto-remove after animation completes
    setTimeout(() => {
        if (errorMessage.parentNode) {
            errorMessage.parentNode.removeChild(errorMessage);
        }
    }, 5000);
}

const MAX_RETRIES = 3;
const RETRY_DELAY = 1000;

function getGeolocationOptions(retryNumber) {
    return {
        enableHighAccuracy: retryNumber < 2,
        timeout: 10000 + (retryNumber * 5000),
        maximumAge: retryNumber * 5000
    };
}

function handleLocationError(error) {
    console.warn("Error getting user location:", error);
    locationErrorCount++;
    
    // Check if we've reached the maximum number of retries
    if (retryCount < MAX_RETRIES) {
        retryCount++;
        console.log(`Retrying to get location (Attempt ${retryCount} of ${MAX_RETRIES})`);
        
        setTimeout(() => {
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    console.log("Location retrieved successfully after retry");
                    hideLoadingMessage();
                    updateUserLocation(position, true);
                    retryCount = 0;
                    locationErrorCount = 0;
                },
                handleLocationError,
                getGeolocationOptions(retryCount)
            );
        }, RETRY_DELAY);
        return;
    }
    
    retryCount = 0;
    hideLoadingMessage();
    
    // If we've had multiple errors, mark location as unavailable
    if (locationErrorCount > 3) {
        isLocationAvailable = false;
    }
    
    let errorMessage = "An error occurred while getting your location.";
    if (error && error.code) {
        switch(error.code) {
            case PERMISSION_DENIED_ERROR:
                errorMessage = "Please allow access to your location to use this feature.";
                permissionDenied = true;
                handleLocationPermissionDenied();
                break;
            case POSITION_UNAVAILABLE_ERROR:
                errorMessage = "Your location is currently unavailable. Please check your GPS signal and try again.";
                showErrorMessage(errorMessage);
                
                // Update GPS signal indicator
                domUpdateManager.schedule('accuracyIndicator', () => {
                    const indicator = document.getElementById('accuracyIndicator');
                    if (indicator) {
                        const dot = indicator.querySelector('.accuracy-dot');
                        const text = document.getElementById('accuracyText');
                        
                        if (dot) {
                            dot.classList.remove('accuracy-high', 'accuracy-medium');
                            dot.classList.add('accuracy-low');
                        }
                        
                        if (text) {
                            text.textContent = 'GPS: Signal Lost';
                        }
                    }
                });
                break;
            case TIMEOUT_ERROR:
                errorMessage = "Getting your location took too long. Please check your GPS signal and try again.";
                showErrorMessage(errorMessage);
                break;
            default:
                showErrorMessage(errorMessage);
                break;
        }
    } else {
        showErrorMessage(errorMessage);
    }
    
    // Try to continue with last known position if available
    if (lastValidPosition) {
        console.log("Using last valid position due to location error");
        userMarker.setLatLng([lastValidPosition.lat, lastValidPosition.lng]);
        updateDistanceBox();
    }
}   

function showPopup(title, message, type = 'info', callback = null) {
    const popup = document.createElement('div');
    popup.classList.add('popup');
    popup.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: white;
        padding: 20px;
        border-radius: 10px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        z-index: 2000;
        text-align: center;
        max-width: 80%;
    `;

    const titleElement = document.createElement('h3');
    titleElement.textContent = title;
    titleElement.style.cssText = `
        margin-bottom: 10px;
        font-size: 18px;
        font-weight: bold;
    `;

    const messageElement = document.createElement('p');
    messageElement.textContent = message;
    messageElement.style.cssText = `
        margin-bottom: 20px;
        font-size: 16px;
    `;

    const buttonContainer = document.createElement('div');
    buttonContainer.style.cssText = `
        display: flex;
        justify-content: center;
        gap: 10px;
    `;

    const okButton = document.createElement('button');
    okButton.textContent = 'OK';
    okButton.style.cssText = `
        padding: 10px 20px;
        background-color: #0f2bab;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
    `;

    okButton.addEventListener('click', () => {
        document.body.removeChild(popup);
        if (callback) callback();
    });

    buttonContainer.appendChild(okButton);

    if (type === 'info') {
        const cancelButton = document.createElement('button');
        cancelButton.textContent = 'Cancel';
        cancelButton.style.cssText = `
            padding: 10px 20px;
            background-color: #ccc;
            color: black;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        `;

        cancelButton.addEventListener('click', () => {
            document.body.removeChild(popup);
        });

        buttonContainer.appendChild(cancelButton);
    }

    popup.appendChild(titleElement);
    popup.appendChild(messageElement);
    popup.appendChild(buttonContainer);
    document.body.appendChild(popup);
}

// Enhanced recenter map function with better zoom handling
function recenterMap() {
    const recenterButton = document.getElementById('recenterButton');
    if (recenterButton) {
        recenterButton.style.backgroundColor = '#0f2bab';
        recenterButton.style.color = 'white';
    }
    
    // Force map to center on user marker immediately
    if (userMarker && userMarker.getLatLng()) {
        map.closePopup();
        
        // Get dynamic zoom level based on current speed
        const dynamicZoom = calculateZoomLevel(currentSpeed);
        
        // Get current position
        const position = userMarker.getLatLng();
        
        // Calculate optimal center with heading bias if available
        let optimalCenter = { lat: position.lat, lng: position.lng };
        
        if (lastPosition && lastPosition.heading !== undefined && lastPosition.speedMPS > 1.0) {
            // Add a small offset in the direction of travel
            const heading = lastPosition.heading;
            const offsetDistance = Math.min(30, lastPosition.speedMPS * 3); // Meters, capped at 30m
            
            const headingRad = heading * Math.PI / 180;
            const latOffset = Math.cos(headingRad) * offsetDistance / 111000; // Approx meters to degrees
            const lngOffset = Math.sin(headingRad) * offsetDistance / (111000 * Math.cos(position.lat * Math.PI / 180));
            
            optimalCenter = {
                lat: position.lat + latOffset,
                lng: position.lng + lngOffset
            };
        }
        
        // Use flyTo for smoother animation with better path prediction
        map.flyTo([optimalCenter.lat, optimalCenter.lng], dynamicZoom, {
            duration: 0.5,
            easeLinearity: 0.5
        });
        
        followUser = true;
        
        // Make sure any other code knows the map has been recentered
        if (typeof onMapRecentered === 'function') {
            onMapRecentered();
        }
    }
    
    setTimeout(() => {
        if (recenterButton) {
            recenterButton.style.backgroundColor = 'white';
            recenterButton.style.color = '#0f2bab';
        }
    }, 500);
}

function addUIEventListeners() {
    const recenterButton = document.getElementById('recenterButton');
    if (recenterButton) {
        recenterButton.addEventListener('click', () => {
            recenterMap();
            updateUserInteractionTime();
        });
    }
    
    const returnButton = document.getElementById('returnButton');
    if (returnButton) {
        returnButton.addEventListener('click', () => {
            returnToIndex();
            updateUserInteractionTime();
        });
    }
    
    const tipsButton = document.getElementById('tipsButton');
    if (tipsButton) {
        tipsButton.addEventListener('click', () => {
            toggleNavigationTips();
            updateUserInteractionTime();
        });
    }
    
    const closeButton = document.querySelector('.navigation-tips .close-button');
    if (closeButton) {
        closeButton.addEventListener('click', () => {
            closeNavigationTips();
            updateUserInteractionTime();
        });
    }
}

function resetInactivityTimer() {
    clearTimeout(inactivityTimer);
    inactivityTimer = setTimeout(checkInactivity, INACTIVITY_TIMEOUT);
}

function checkInactivity() {
    console.log('Inactivity timer triggered');
    
    // Only recenter if user hasn't interacted recently
    const now = Date.now();
    const timeSinceLastInteraction = now - lastUserInteractionTime;
    
    if (timeSinceLastInteraction >= INACTIVITY_TIMEOUT) {
        isMapInteracting = false;
        userIsInteracting = false;
        
        // Close any open popups
        map.closePopup();
        map.eachLayer((layer) => {
            if (layer.getPopup && layer.getPopup()?.isOpen()) {
                layer.closePopup();
            }
        });
        
        // Force recenter after inactivity
        followUser = true;
        recenterMap();
        
        console.log('Map recentered due to inactivity');
    }
    
    // Always reset the timer
    resetInactivityTimer();
}

function closeAllPopups() {
    if (map) {
        map.closePopup();
    }
}

let lastVisitTime = 0;
const cooldownPeriod = 3 * 60 * 1000;
        
function showLocationHunt(location) {
    if (!location) {
        console.error("Invalid location data for showLocationHunt");
        return;
    }
    
    const now = performance.now();
    if (location.id === lastVisitedLocationId && now - lastVisitTime < cooldownPeriod) {
        console.log(`Location ${location.id} is on cooldown. Skipping.`);
        return;
    }
    
    lastVisitedLocationId = location.id;
    lastVisitTime = now;
    isLocationHuntVisible = true;

    // Use DOM batch updates for better performance
    domUpdateManager.schedule('locationHunt', () => {
        const lochuntContainer = document.querySelector('.lochunt-container');
        if (!lochuntContainer) {
            console.error("Location hunt container not found");
            return;
        }
        
        lochuntContainer.innerHTML = '';
        lochuntContainer.style.cssText = `
            display: flex;
            flex-direction: column;
            height: 100%;
            overflow: hidden;
            background-color: #fff;
            max-width: 1200px;
            margin: 0 auto;
            box-shadow: 0 2px 20px rgba(0,0,0,0.025);
            will-change: transform;
        `;
        
        // Add transition class
        lochuntContainer.classList.add('location-transition');
        
        // Trigger reflow to ensure transition works
        void lochuntContainer.offsetWidth;
        
        // Make visible with transition
        lochuntContainer.classList.add('visible');

        const scrollableContent = document.createElement('div');
        scrollableContent.style.cssText = `
            flex: 1;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            scroll-behavior: smooth;
            will-change: scroll-position;
        `;

        // Use preloaded image if available
        const locationImage = document.createElement('img');
        if (preloadedImages.has(location.image)) {
            locationImage.src = location.image;
        } else {
            locationImage.src = location.image;
            // Preload for next time
            const img = new Image();
            img.crossOrigin = "anonymous"; // Set crossOrigin for canvas operations
            img.src = location.image;
            preloadedImages.set(location.image, img);
        }
        locationImage.alt = location.name;
        locationImage.style.cssText = `
            width: 100%;
            height: 45vh;
            object-fit: cover;
            object-position: center;
        `;

        scrollableContent.appendChild(locationImage);
     
        const contentContainer = document.createElement('div');
        contentContainer.classList.add('lochunt-content');
        contentContainer.style.cssText = `
            padding: 24px;
            display: flex;
            flex-direction: column;
            align-items: center;
            max-width: 800px;
            margin: 0 auto;
        `;
        const locationInfo = document.createElement('div');
        locationInfo.classList.add('lochunt-info');
        locationInfo.style.cssText = `
            text-align: center;
            width: 100%;
            margin-bottom: 15px;
        `;
        const locationName = document.createElement('h1');
        locationName.textContent = location.name;
        locationName.style.cssText = `
            font-size: clamp(1.8rem, 4vw, 2.5rem);
            font-weight: 700;
            color: #1a1a1a;
            margin-bottom: 8px;
            line-height: 1.2;
        `;
        const locationCity = document.createElement('p');
        locationCity.textContent = `${location.city}`;
        locationCity.style.cssText = `
           font-size: clamp(1.1rem, 2vw, 1.3rem);
            color: #ff0000;
            font-weight: 600;
            margin-bottom: 4px;
        `;
        const locationCreator = document.createElement('p');
        locationCreator.textContent = `Created by: ${location.creator}`;
        locationCreator.style.cssText = `
            font-size: calc(0.9rem + 0.4vw);
            color: #666666;
            font-weight: 500;
        `;
        locationInfo.appendChild(locationName);
        locationInfo.appendChild(locationCity);
        locationInfo.appendChild(locationCreator);
        contentContainer.appendChild(locationInfo);
        const audioPlayerContainer = createAudioPlayer(location.audio);
        contentContainer.appendChild(audioPlayerContainer);
        scrollableContent.appendChild(contentContainer);
        lochuntContainer.appendChild(scrollableContent);
        const blueBar = createBlueBar(location);
        blueBar.style.cssText += `
            position: sticky;
            bottom: 0;
            width: 100%;
        `;
        lochuntContainer.appendChild(blueBar);
        
        // Initialize audio player after DOM is updated
        requestAnimationFrame(initAudioPlayer);
    });
}

function createAudioPlayer(audioSrc) {
    const audioPlayerContainer = document.createElement('div');
    audioPlayerContainer.classList.add('audio-player');
    audioPlayerContainer.style.cssText = `
        width: 100%;
        max-width: 400px;
        margin-bottom: 15px;
    `;

    const audio = document.createElement('audio');
    audio.id = 'locationAudio';
    
    // Use preloaded audio if available
    if (preloadedAudio.has(audioSrc)) {
        audio.src = audioSrc;
    } else {
        audio.src = audioSrc;
        // Preload for next time
        const audioPreload = new Audio();
        audioPreload.preload = 'auto';
        audioPreload.src = audioSrc;
        preloadedAudio.set(audioSrc, audioPreload);
    }

    const audioProgress = document.createElement('div');
    audioProgress.classList.add('audio-progress');
    audioProgress.style.cssText = `
        width: 100%;
        margin-bottom: 15px;
    `;

    const progressContainer = document.createElement('div');
    progressContainer.classList.add('progress');
    progressContainer.style.cssText = `
        height: 8px;
        background-color: #e2e8f0;
        border-radius: 4px;
        cursor: pointer;
        margin-bottom: 12px;
        overflow: hidden;
    `;

    const progressBar = document.createElement('div');
    progressBar.id = 'progressBar';
    progressBar.classList.add('progress-bar');
    progressBar.style.cssText = `
        height: 100%;
        background-color: #ff0000;
        width: 0%;
        transition: width 0.1s linear;
    `;

    progressContainer.appendChild(progressBar);
    audioProgress.appendChild(progressContainer);

    const timeInfo = document.createElement('div');
    timeInfo.classList.add('audio-time');
    timeInfo.style.cssText = `
        display: flex;
        justify-content: space-between;
        color: #4a5568;
        font-size: 0.875rem;
        margin-bottom: 16px;
        font-weight: 500;
    `;

    const currentTimeSpan = document.createElement('span');
    currentTimeSpan.id = 'currentTime';
    currentTimeSpan.textContent = '0:00';

    const durationSpan = document.createElement('span');
    durationSpan.id = 'duration';
    durationSpan.textContent = '0:00';

    timeInfo.appendChild(currentTimeSpan);
    timeInfo.appendChild(durationSpan);

    const audioControls = document.createElement('div');
    audioControls.classList.add('audio-controls');
    audioControls.style.cssText = `
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 24px;
    `;

    const rewindBtn = createAudioButton('skip-backward', 'rewindBtn');
    const playPauseBtn = createAudioButton('play', 'playPauseBtn');
    const forwardBtn = createAudioButton('skip-forward', 'forwardBtn');

    audioControls.appendChild(rewindBtn);
    audioControls.appendChild(playPauseBtn);
    audioControls.appendChild(forwardBtn);

    audioPlayerContainer.appendChild(audio);
    audioPlayerContainer.appendChild(audioProgress);
    audioPlayerContainer.appendChild(timeInfo);
    audioPlayerContainer.appendChild(audioControls);

    return audioPlayerContainer;
}

function createAudioButton(iconName, id) {
    const button = document.createElement('button');
    button.id = id;
    button.classList.add('audio-button');
    button.innerHTML = `<i class="bi bi-${iconName}"></i>`;
    button.style.cssText = `
background-color: white;
color: #0000ff;
border: 2px solid #0000ff;
border-radius: 50%;
width: 55px;
height: 55px;
display: flex;
align-items: center;
justify-content: center;
cursor: pointer;
transition: all 0.3s ease;
    `;

    button.addEventListener('mouseover', () => {
        button.style.backgroundColor = 'rgba(0, 0, 255, 0.1)';
    });

    button.addEventListener('mouseout', () => {
        button.style.backgroundColor = 'white';
    });

    button.addEventListener('click', () => {
        button.style.backgroundColor = '#0000ff';
        button.style.color = 'white';
        button.style.transform = 'scale(0.95)';
        
        setTimeout(() => {
            button.style.backgroundColor = 'white';
            button.style.color = '#0000ff';
            button.style.transform = 'scale(1)';
        }, 200);
    });

    return button;
}

function createBlueBar(location) {
    const blueBar = document.createElement('div');
    blueBar.style.cssText = `
        width: 100%;
        height: 60px;
        background: linear-gradient(to right, #0a1f80, #0f2bab);
        margin-top: auto;
        box-shadow: 0 -2px 10px rgba(0,0,0,0.025);
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0 24px;
        position: sticky;
        bottom: 0;
    `;
    
    const infoButton = document.createElement('button');
    infoButton.innerHTML = '<i class="bi bi-info-circle-fill text-white" style="font-size: 1.5rem; z-index: 2500;"></i>';
    infoButton.classList.add('btn', 'btn-sm', 'me-2');
    infoButton.onclick = () => {
        if (location && location.imageSource) {
            showPopup('Image Source', location.imageSource);
        } else {
            showPopup('Image Source', 'Image source information is not available');
        }
    };

    const feedbackButton = document.createElement('a');
    feedbackButton.href = 'mailto:mattreicher@protonmail.com?subject=Feedback';
    feedbackButton.target = '_blank';
    feedbackButton.rel = 'noopener noreferrer';
    feedbackButton.innerHTML = '<i class="bi bi-envelope-fill text-white" style="font-size: 1.5rem;"></i>';
    feedbackButton.classList.add('btn', 'btn-sm');

    blueBar.appendChild(infoButton);
    blueBar.appendChild(feedbackButton);
    return blueBar;
}        

function initAudioPlayer() {
    const audio = document.getElementById('locationAudio');
    const playPauseBtn = document.getElementById('playPauseBtn');
    const rewindBtn = document.getElementById('rewindBtn');
    const forwardBtn = document.getElementById('forwardBtn');
    const progressBar = document.getElementById('progressBar');
    const progressContainer = document.querySelector('.progress');
    const currentTimeSpan = document.getElementById('currentTime');
    const durationSpan = document.getElementById('duration');

    if (!audio || !playPauseBtn || !rewindBtn || !forwardBtn || !progressBar || !progressContainer || !currentTimeSpan || !durationSpan) {
        console.warn('Audio player elements not found, retrying...');
        requestAnimationFrame(initAudioPlayer);
        
        return;
    }

    // Debounce progress updates to reduce DOM operations
    let lastProgressUpdate = 0;
    const PROGRESS_UPDATE_INTERVAL = 250; // ms

    playPauseBtn.addEventListener('click', togglePlay);
    rewindBtn.addEventListener('click', () => seek(-10));
    forwardBtn.addEventListener('click', () => seek(10));
    
    // Use throttled event listener for timeupdate
    audio.addEventListener('timeupdate', () => {
        const now = Date.now();
        if (now - lastProgressUpdate > PROGRESS_UPDATE_INTERVAL) {
            lastProgressUpdate = now;
            updateProgress();
        }
    });
    
    audio.addEventListener('loadedmetadata', setDuration);
    audio.addEventListener('ended', () => {
        domUpdateManager.schedule('playPauseBtn', () => {
            playPauseBtn.innerHTML = '<i class="bi bi-play"></i>';
        });
        showAdditionalInfo();
    });
    
    // Handle audio loading errors
    audio.addEventListener('error', (e) => {
        console.error('Audio loading error:', e);
        showErrorMessage('Error loading audio. Please check your connection and try again.');
    });
    
    // Use event delegation for progress container clicks
    progressContainer.addEventListener('click', setProgress);

    function togglePlay() {
        if (audio.paused) {
            const playPromise = audio.play();
            if (playPromise !== undefined) {
                playPromise.then(() => {
                    domUpdateManager.schedule('playPauseBtn', () => {
                        playPauseBtn.innerHTML = '<i class="bi bi-pause"></i>';
                    });
                }).catch(error => {
                    console.error('Audio playback failed:', error);
                    showErrorMessage('Audio playback failed. Please try again.');
                });
            }
        } else {
            audio.pause();
            domUpdateManager.schedule('playPauseBtn', () => {
                playPauseBtn.innerHTML = '<i class="bi bi-play"></i>';
            });
        }
    }

    function seek(seconds) {
        audio.currentTime = Math.max(0, Math.min(audio.currentTime + seconds, audio.duration));
    }

    function updateProgress() {
        const percent = (audio.currentTime / audio.duration) * 100;
        domUpdateManager.schedule('audioProgress', () => {
            progressBar.style.width = `${percent}%`;
            currentTimeSpan.textContent = formatTime(audio.currentTime);
        });
    }

    function setProgress(e) {
        const width = this.clientWidth;
        const clickX = e.offsetX;
        const duration = audio.duration;
        audio.currentTime = (clickX / width) * duration;
    }

    function setDuration() {
        domUpdateManager.schedule('audioDuration', () => {
            durationSpan.textContent = formatTime(audio.duration);
        });
    }

    function formatTime(time) {
        const minutes = Math.floor(time / 60);
        const seconds = Math.floor(time % 60);
        return `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }
}

function showAdditionalInfo() {
    // Find the location using lastVisitedLocationId
    const location = gameLocations.find(loc => loc.id === lastVisitedLocationId);
    console.log('Current location:', location);
    
    // Set flag to indicate we're returning from exhibit
    isReturningFromExhibit = true;
    
    domUpdateManager.schedule('additionalInfo', () => {
        const additionalInfoContainer = document.querySelector('.additional-info-container');
        if (!additionalInfoContainer) {
            console.error("Additional info container not found");
            return;
        }
        
        additionalInfoContainer.style.display = 'block';
        
        // Add transition class
        additionalInfoContainer.classList.add('location-transition');
        
        // Trigger reflow to ensure transition works
        void additionalInfoContainer.offsetWidth;
        
        // Make visible with transition
        additionalInfoContainer.classList.add('visible');
        
        const additionalInfoElement = document.getElementById('additionalInfo');
        if (additionalInfoElement && location) {
            additionalInfoElement.textContent = location.additionalInfo;
        }

        const continueButton = document.getElementById('continueButton');
        if (continueButton) {
            continueButton.onclick = () => {
                // Fade out with transition
                additionalInfoContainer.classList.remove('visible');
                
                // Hide after transition completes
                setTimeout(() => {
                    additionalInfoContainer.style.display = 'none';
                    
                    // Also hide location hunt container with transition
                    const lochuntContainer = document.querySelector('.lochunt-container');
                    if (lochuntContainer) {
                        lochuntContainer.classList.remove('visible');
                        
                        setTimeout(() => {
                            lochuntContainer.style.display = 'none';
                            isLocationHuntVisible = false;
                            updateDistanceBox();
                        }, 500);
                    }
                }, 500);
            };
        }
    });
}

function showDirectionsModal(lat, lng) {
    const modal = document.getElementById('directionsModal');
    if (!modal) {
        console.error("Directions modal not found");
        return;
    }
    
    modal.style.display = 'block';

    const mapBtn = document.getElementById('mapButton');
    const cancelBtn = document.getElementById('cancelButton');

    if (mapBtn) {
        mapBtn.onclick = () => {
            window.open(`https://www.google.com/maps/dir/?api=1&destination=${lat},${lng}`, '_blank');
            modal.style.display = 'none';
        };
    }

    if (cancelBtn) {
        cancelBtn.onclick = () => {
            modal.style.display = 'none';
        };
    }

    window.onclick = (event) => {
        if (event.target == modal) {
            modal.style.display = 'none';
        }
    };
}

function showLocationSummary(locationId) {
    console.log("Showing summary for location ID:", locationId);
    console.log("All locations:", gameLocations);
    console.log("Location IDs:", gameLocations.map(loc => loc.id));
    console.log("Location ID type:", typeof locationId);
    
    if (gameLocations.length > 0) {
        console.log("Location ID type:", typeof gameLocations[0].id);
    }
    
    const location = gameLocations.find(loc => loc.id === locationId);
    console.log("Found location:", location);
    
    if (location && location.summary) {
        domUpdateManager.schedule('summaryModal', () => {
            const modal = document.getElementById('summaryModal');
            const summaryContent = document.getElementById('summaryContent');
            
            if (!modal || !summaryContent) {
                console.error("Summary modal elements not found");
                return;
            }
            
            modal.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
            modal.style.display = 'flex';
            modal.style.justifyContent = 'center';
            modal.style.alignItems = 'center';
            
            const modalContent = modal.querySelector('.modal-content');
            if (modalContent) {
                modalContent.style.cssText = `
                    background-color: white;
                    padding: 30px;
                    border-radius: 10px;
                    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.025);
                    max-width: 500px;
                    width: 90%;
                    max-height: 80vh;
                    overflow-y: auto;
                `;
            }
            
            const closeBtn = modal.querySelector('.close');
            if (closeBtn) {
                closeBtn.remove();
            }
            
            summaryContent.style.textAlign = 'left';
            summaryContent.innerHTML = `
               <h3 class="summary-heading" style="font-size: 22px; margin-bottom: 15px; text-align: center;">${location.name}</h3>
                <p style="line-height: 1.6; margin-bottom: 15px;">
                    ${location.summary}
                </p>
                <p style="line-height: 1.6; margin-bottom: 15px;">
                    <strong>Location:</strong> ${location.today}
                </p>
            `;
            
            const continueButton = document.createElement('button');
            continueButton.textContent = 'Continue';
            continueButton.className = 'summary-button';
            continueButton.style.cssText = `
                display: block;
                width: auto;
                padding: 12px 20px;
                color: white;
                border: none;
                border-radius: 10px;
                cursor: pointer;
                font-size: 18px;
                font-weight: bold;
                transition: background-color 0.3s ease;
                margin: 10px auto -15px;
            `;
            continueButton.onclick = function() {
                modal.style.display = 'none';
            };
            summaryContent.appendChild(continueButton);
            modal.style.display = 'flex';
            window.onclick = function(event) {
                if (event.target === modal) {
                    modal.style.display = 'none';
                }
            };
        });
    } else {
        console.log("Location or summary not found. Location ID:", locationId);
        console.log("Available IDs:", gameLocations.map(loc => loc.id));
        showPopup("Error", "Summary not available for this location.");
    }
}
        
function startHunt() {
    // Check network status before starting
    if (!navigator.onLine) {
        showErrorMessage("No internet connection. Please connect to the internet and try again.");
        
        // Set a timeout to retry
        setTimeout(() => {
            if (navigator.onLine) {
                startHunt();
            }
        }, 5000);
        
        return;
    }
    
    try {
        // Ensure locations is defined before using it
        if (typeof locations !== 'undefined' && Array.isArray(locations)) {
            gameLocations = locations.sort((a, b) => a.id - b.id);
        } else {
            console.warn("Locations data is not available");
            gameLocations = [];
        }
        
        currentLocationIndex = 0;
        locationCooldowns = {};
        lastVisitedLocationId = null;
        
        // Preload all location images before starting
        preloadImages(gameLocations).then(() => {
            // Hide preloader when images are loaded
            const preloader = document.getElementById('preloader');
            if (preloader) {
                preloader.style.opacity = '0';
                preloader.style.transition = 'opacity 0.5s ease';
                setTimeout(() => {
                    if (preloader && preloader.parentNode) {
                        preloader.parentNode.removeChild(preloader);
                    }
                }, 500);
            }
            
            loadAllLocations();
        }).catch(error => {
            console.error("Error preloading images:", error);
            showErrorMessage("Error loading resources. Please check your connection and try again.");
            
            // Try to continue anyway after a delay
            setTimeout(() => {
                loadAllLocations();
            }, 3000);
        });
    } catch (error) {
        console.error("Error starting hunt:", error);
        showErrorMessage("Error starting the experience. Please reload the page.");
    }
}

function getMarkerColor(tours) {
    if (!tours) return '#0f2bab'; // Default color
    
    switch (tours.toLowerCase()) {
        case 'person':
            return '#FFA500';
        case 'gangster':
            return '#3f9b0b';
        case 'event':
            return '#8B0000';
        case 'place':
            return '#0f2bab';
        default:
            return '#0f2bab';
    }
}

const showAlert = (message) => {
   const alertEl = document.createElement('div');
   alertEl.className = 'modal';
   alertEl.innerHTML = `
       <div class="modal-content">
           <p>${message}</p>
           <button class="modal-button">OK</button>
       </div>
   `;
   document.body.appendChild(alertEl);
   
   const button = alertEl.querySelector('button');
   if (button) {
       button.onclick = () => {
           alertEl.remove();
           // Show directions modal again
           const routeButton = document.querySelector('.route-button');
           if (routeButton) {
               routeButton.click();
           }
       };
   }
};
        
function loadAllLocations() {
    try {
        if (!gameLocations || !Array.isArray(gameLocations)) {
            console.error("Game locations not available");
            return;
        }
        
        gameLocations.forEach((location, index) => {
            if (!location || typeof location.lat !== 'number' || typeof location.lng !== 'number' ||
                isNaN(location.lat) || isNaN(location.lng)) {
                console.warn("Invalid location data:", location);
                return;
            }
            
            const markerColor = getMarkerColor(location.tours);
            
            const locationMarker = L.marker([location.lat, location.lng], {
                icon: L.divIcon({
                    className: 'custom-pin-icon',
                    html: `<div class="pin-head" style="background-color: ${markerColor};">
                           </div>`,
                    iconSize: [30, 30],
                    iconAnchor: [15, 30],
                })
            });
                    
            const popupContent = `
                <div class="popup-content">
                    <img src="${location.image}" alt="${location.name}" class="location-image">
                    <h4 class="location-name">
                        <a href="${location.link}" target="_blank" rel="noopener noreferrer" style="text-decoration: none; color: inherit;">${location.name}</a>
                    </h4>
                    <div class="popup-buttons">
                        <button class="button route-button" data-lat="${location.lat}" data-lng="${location.lng}">Directions</button>
                        <button class="button summary-button" data-location-id="${location.id}">Summary</button>
                    </div>
                </div>
            `;
            locationMarker.bindPopup(popupContent, {
                offset: L.point(0, -25),
                className: 'custom-popup'
            });
            
            locationMarker.on('popupopen', function(e) {
                const popup = e.popup._contentNode;
                const routeButton = popup.querySelector('.route-button');
                const summaryButton = popup.querySelector('.summary-button');
                
                if (routeButton) {
                    routeButton.addEventListener('click', function(event) {
                        event.preventDefault();
                        const lat = this.getAttribute('data-lat');
                        const lng = this.getAttribute('data-lng');
                        
                        // Create and show the modal
                        const modal = document.createElement('div');
                        modal.className = 'modal';
                        modal.innerHTML = `
                            <div class="modal-content">
                                <h3>Choose your preferred navigation app:</h3>
                                <div class="navigation-options">
                                    <button id="googleMapsBtn" class="nav-button" style="background-color: #4285F4; color: white;">
                                        <i class="bi bi-map"></i> Google Maps
                                    </button>
                                    <button id="appleMapsBtn" class="nav-button" style="background-color: #007AFF; color: white;">
                                        <i class="bi bi-map-fill"></i> Apple Maps
                                    </button>
                                    <button id="wazeBtn" class="nav-button" style="background-color: #66BD47; color: white;">
                                        <i class="bi bi-signpost-2"></i> Waze
                                    </button>
                                    <button id="cancelNavBtn" class="nav-button cancel">
                                        <i class="bi bi-x-circle"></i> Cancel
                                    </button>
                                </div>
                            </div>
                        `;
                        modal.style.cssText = `
                            position: fixed;
                            top: 0;
                            left: 0;
                            width: 100%;
                            height: 100%;
                            background-color: rgba(0, 0, 0, 0.5);
                            display: flex;
                            justify-content: center;
                            align-items: center;
                            z-index: 2000;
                        `;
                        document.body.appendChild(modal);
                        
                        const modalContent = modal.querySelector('.modal-content');
                        modalContent.style.cssText = `
                            background-color: white;
                            padding: 20px;
                            border-radius: 10px;
                            max-width: 90%;
                            width: 350px;
                            text-align: center;
                        `;
                        
                        const navigationOptions = modal.querySelector('.navigation-options');
                        navigationOptions.style.cssText = `
                            display: flex;
                            flex-direction: column;
                            gap: 10px;
                            margin-top: 15px;
                        `;
                        
                        const navButtons = modal.querySelectorAll('.nav-button');
                        navButtons.forEach(button => {
                            button.style.cssText = `
                                padding: 12px;
                                border: none;
                                border-radius: 8px;
                                background-color: #0f2bab;
                                color: white;
                                font-size: 16px;
                                cursor: pointer;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                gap: 10px;
                            `;
                        });
                        
                        const cancelBtn = modal.querySelector('.cancel');
                        if (cancelBtn) {
                            cancelBtn.style.backgroundColor = '#ccc';
                            cancelBtn.style.color = '#333';
                        }
                        
                        // Add event listeners
                        const googleMapsBtn = modal.querySelector('#googleMapsBtn');
                        if (googleMapsBtn) {
                            googleMapsBtn.addEventListener('click', () => {
                                window.open(`https://www.google.com/maps/dir/?api=1&destination=${lat},${lng}`, '_blank');
                                document.body.removeChild(modal);
                            });
                        }
                        
                        const appleMapsBtn = modal.querySelector('#appleMapsBtn');
                        if (appleMapsBtn) {
                            appleMapsBtn.addEventListener('click', () => {
                                window.open(`https://maps.apple.com/?daddr=${lat},${lng}`, '_blank');
                                document.body.removeChild(modal);
                            });
                        }
                        
                        const wazeBtn = modal.querySelector('#wazeBtn');
                        if (wazeBtn) {
                            wazeBtn.addEventListener('click', () => {
                                window.open(`https://waze.com/ul?ll=${lat},${lng}&navigate=yes`, '_blank');
                                document.body.removeChild(modal);
                            });
                        }
                        
                        const cancelNavBtn = modal.querySelector('#cancelNavBtn');
                        if (cancelNavBtn) {
                            cancelNavBtn.addEventListener('click', () => {
                                document.body.removeChild(modal);
                            });
                        }
                        
                        // Close modal when clicking outside
                        modal.addEventListener('click', (e) => {
                            if (e.target === modal) {
                                document.body.removeChild(modal);
                            }
                        });
                    });
                }
                
                if (summaryButton) {
                    summaryButton.addEventListener('click', function(event) {
                        event.preventDefault();
                        const locationId = this.getAttribute('data-location-id');
                        showLocationSummary(locationId);
                    });
                }
            });
            
            markerClusterGroup.addLayer(locationMarker);
        });
        
        // Add UI event listeners
        addUIEventListeners();
        
        // Start inactivity timer
        resetInactivityTimer();
        
        // Update distance box
        updateDistanceBox();
        
    } catch (error) {
        console.error("Error loading locations:", error);
        showErrorMessage("Error loading locations. Please try again later.");
    }
}

function toggleNavigationTips() {
    const tips = document.querySelector('.navigation-tips');
    if (tips) {
        tips.style.display = tips.style.display === 'block' ? 'none' : 'block';
    }
}

function closeNavigationTips() {
    const tips = document.querySelector('.navigation-tips');
    if (tips) {
        tips.style.display = 'none';
    }
}

function returnToIndex() {
    showPopup("Confirm", "Are you ready to exit?", 'info', () => {
        window.location = "index.html";
    });
}

// Initialize the map
document.addEventListener('DOMContentLoaded', initMap);

// Export for testing
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        calculateDistance,
        isValidPosition,
        updateMarkerPosition,
        updateDistanceBox
    };
}

console.log("Map script loaded successfully");
    </script>
</body>
</html>
