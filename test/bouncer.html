<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Bouncer: Extreme Edition</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #111;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            user-select: none;
        }

        #game-container {
            position: relative;
            max-width: 95vw; 
            max-height: 95vh;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
            border: 2px solid #333;
            background: #000;
        }

        canvas {
            display: block;
            background-color: #000;
            max-width: 100%;
            max-height: 100%;
        }

        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.85);
            z-index: 10;
            text-align: center;
        }

        .hidden {
            display: none !important;
        }

        h1 {
            font-size: 2.5rem;
            margin: 0 0 10px 0;
            color: #fff;
            text-shadow: 0 0 10px #0ff;
        }

        p {
            font-size: 1.2rem;
            color: #ccc;
            margin-bottom: 20px;
        }

        button {
            padding: 15px 40px;
            font-size: 1.5rem;
            background: #0ff;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            color: #000;
            font-weight: bold;
            box-shadow: 0 0 15px #0ff;
            transition: transform 0.1s;
        }

        button:hover {
            transform: scale(1.05);
        }

        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            font-size: 1.2rem;
            font-weight: bold;
            z-index: 5;
            text-shadow: 1px 1px 0 #000;
        }

        .stat-box {
            background: rgba(255, 255, 255, 0.1);
            padding: 5px 15px;
            border-radius: 10px;
        }

        #difficulty-warning {
            position: absolute;
            top: 25%;
            width: 100%;
            text-align: center;
            color: #ff0055;
            font-size: 2.5rem;
            font-weight: bold;
            text-shadow: 0 0 15px #ff0055;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        
        <div id="hud" class="hidden">
            <div class="stat-box">Score: <span id="scoreDisplay" style="color:#0ff">0</span></div>
            <div class="stat-box">Lives: <span id="livesDisplay" style="color:#ff0055">3</span></div>
        </div>
        
        <div id="difficulty-warning">OPE! LIFE LOST!</div>

        <div id="startScreen" class="overlay">
            <h1>NEON BOUNCER</h1>
            <p>Catch balls for points. Avoid the red spikes!<br>Don't let balls hit the floor!</p>
            <button id="startBtn">PLAY</button>
        </div>

        <div id="gameOverScreen" class="overlay hidden">
            <h1 style="color: #ff0055; text-shadow: 0 0 10px #ff0055;">GAME OVER</h1>
            <p>You did real good! Final Score: <span id="finalScore">0</span></p>
            <button id="restartBtn">TRY AGAIN</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const hud = document.getElementById('hud');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const livesDisplay = document.getElementById('livesDisplay');
        const finalScoreDisplay = document.getElementById('finalScore');
        const warningMsg = document.getElementById('difficulty-warning');

        const GAME_WIDTH = 600;
        const GAME_HEIGHT = 600;
        canvas.width = GAME_WIDTH;
        canvas.height = GAME_HEIGHT;

        let animationId;
        let score = 0;
        let lives = 3;
        let isGameRunning = false;
        let lastTime = 0;
        let spawnTimer = 0;
        let difficultyLevel = 1;

        const GRAVITY = 0.25;
        const PADDLE_WIDTH = 110;
        const PADDLE_HEIGHT = 15;

        let paddle = {
            x: GAME_WIDTH / 2 - PADDLE_WIDTH / 2,
            y: GAME_HEIGHT - 40,
            width: PADDLE_WIDTH,
            height: PADDLE_HEIGHT,
            color: '#ffffff'
        };

        let entities = [];

        function handleInput(clientX) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            let relativeX = (clientX - rect.left) * scaleX;
            paddle.x = relativeX - paddle.width / 2;
            if (paddle.x < 0) paddle.x = 0;
            if (paddle.x + paddle.width > GAME_WIDTH) paddle.x = GAME_WIDTH - paddle.width;
        }

        document.addEventListener('mousemove', (e) => handleInput(e.clientX));
        document.addEventListener('touchmove', (e) => {
            handleInput(e.touches[0].clientX);
            e.preventDefault();
        }, { passive: false });

        class Entity {
            constructor(type) {
                this.type = type; // 'ball' or 'spike'
                this.radius = type === 'ball' ? 12 : 15;
                this.x = Math.random() * (GAME_WIDTH - this.radius * 2) + this.radius;
                this.y = -20;
                this.dx = (Math.random() - 0.5) * 5;
                this.dy = Math.random() * 2 + 1;
                
                if (this.type === 'ball') {
                    // 20% chance for a gold high-value ball
                    this.isGold = Math.random() > 0.8;
                    this.color = this.isGold ? '#ffdd00' : '#00ffcc';
                    this.points = this.isGold ? 50 : 10;
                } else {
                    this.color = '#ff0055'; // Spikes are red
                }
            }

            draw() {
                ctx.beginPath();
                if (this.type === 'ball') {
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    // Add glow for gold balls
                    if(this.isGold) {
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = "gold";
                    }
                } else {
                    // Draw a triangle (Spike)
                    ctx.moveTo(this.x, this.y - this.radius);
                    ctx.lineTo(this.x - this.radius, this.y + this.radius);
                    ctx.lineTo(this.x + this.radius, this.y + this.radius);
                    ctx.closePath();
                }
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.shadowBlur = 0;
            }

            update() {
                this.dy += GRAVITY;
                this.x += this.dx;
                this.y += this.dy;

                // Wall bounce
                if (this.x + this.radius > GAME_WIDTH || this.x - this.radius < 0) {
                    this.dx *= -1;
                }

                // Paddle Collision
                if (this.y + this.radius >= paddle.y && 
                    this.y - this.radius <= paddle.y + paddle.height &&
                    this.x >= paddle.x &&
                    this.x <= paddle.x + paddle.width) {
                    
                    if (this.type === 'ball') {
                        this.dy *= -0.9; // Bounce up
                        this.y = paddle.y - this.radius; // Reset position to top of paddle
                        score += this.points;
                        scoreDisplay.textContent = score;
                        flashPaddle('#0ff');
                    } else {
                        // Hit a spike!
                        loseLife("OUCH! SPIKE!");
                        return false; // Remove entity
                    }
                }

                // Floor Collision
                if (this.y - this.radius > GAME_HEIGHT) {
                    if (this.type === 'ball') {
                        loseLife("MISSED ONE!");
                    }
                    return false; // Remove entity
                }
                return true;
            }
        }

        function flashPaddle(color) {
            paddle.color = color;
            setTimeout(() => paddle.color = '#ffffff', 150);
        }

        function loseLife(msg) {
            lives--;
            livesDisplay.textContent = lives;
            showWarning(msg);
            flashPaddle('#ff0055');
            if (lives <= 0) endGame();
        }

        function showWarning(text) {
            warningMsg.textContent = text;
            warningMsg.style.opacity = 1;
            setTimeout(() => warningMsg.style.opacity = 0, 1000);
        }

        function initGame() {
            entities = [new Entity('ball')];
            score = 0;
            lives = 3;
            spawnTimer = 0;
            scoreDisplay.textContent = score;
            livesDisplay.textContent = lives;
            isGameRunning = true;
            lastTime = performance.now();
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            hud.classList.remove('hidden');
            animate();
        }

        function endGame() {
            isGameRunning = false;
            cancelAnimationFrame(animationId);
            finalScoreDisplay.textContent = score;
            hud.classList.add('hidden');
            gameOverScreen.classList.remove('hidden');
        }

        function animate(currentTime) {
            if (!isGameRunning) return;
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;

            ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

            // Draw Paddle
            ctx.fillStyle = paddle.color;
            ctx.shadowBlur = 10;
            ctx.shadowColor = paddle.color;
            ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);
            ctx.shadowBlur = 0;

            // Spawn logic
            spawnTimer += deltaTime;
            let spawnRate = Math.max(0.5, 2.0 - (score / 1000)); // Gets faster as score goes up
            if (spawnTimer >= spawnRate) {
                // Randomly choose ball or spike
                const type = Math.random() > 0.2 ? 'ball' : 'spike';
                entities.push(new Entity(type));
                spawnTimer = 0;
            }

            // Update and draw entities
            entities = entities.filter(ent => {
                ent.draw();
                return ent.update();
            });

            animationId = requestAnimationFrame(animate);
        }

        document.getElementById('startBtn').addEventListener('click', initGame);
        document.getElementById('restartBtn').addEventListener('click', initGame);
    </script>
</body>
</html>
