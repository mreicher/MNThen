<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<title>Orbit Bounce</title>
<style>
:root {
--primary: #3b82f6;
--primary-glow: rgba(59, 130, 246, 0.5);
--gold: #fbbf24;
--gold-glow: rgba(251, 191, 36, 0.6);
--danger: #ef4444;
--text-main: #ffffff;
--text-muted: #94a3b8;
--bg-dark: rgba(2, 6, 23, 0.92);
--font-stack: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
}
* {
margin: 0;
padding: 0;
box-sizing: border-box;
user-select: none;
-webkit-user-select: none;
-webkit-touch-callout: none;
-webkit-tap-highlight-color: transparent;
}
html, body {
width: 100%;
height: 100%;
overflow: hidden;
position: fixed;
touch-action: none;
}
body {
background-image: url('https://images.unsplash.com/photo-1419242902214-272b3f66ee7a?q=80&w=2000');
background-size: cover;
background-position: center;
background-repeat: no-repeat;
background-attachment: fixed;
background-color: #0f172a;
color: var(--text-main);
font-family: var(--font-stack);
}
body::before {
content: '';
position: fixed;
top: 0;
left: 0;
right: 0;
bottom: 0;
background: rgba(0, 0, 0, 0.5);
z-index: 0;
pointer-events: none;
}
#game-container {
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
width: 90vw;
height: 85vh;
max-width: 600px;
max-height: 900px;
display: flex;
flex-direction: column;
border-radius: 20px;
overflow: hidden;
box-shadow: 0 30px 80px rgba(0, 0, 0, 0.6);
background: rgba(15, 23, 42, 0.4);
backdrop-filter: blur(10px);
-webkit-backdrop-filter: blur(10px);
border: 1px solid rgba(255, 255, 255, 0.1);
z-index: 10;
}
@media (max-width: 768px) {
#game-container {
position: fixed;
top: 0;
left: 0;
transform: none;
width: 100vw;
height: 100vh;
max-width: none;
max-height: none;
border-radius: 0;
background: transparent;
backdrop-filter: none;
-webkit-backdrop-filter: none;
border: none;
box-shadow: none;
}
body::before {
background: rgba(0, 0, 0, 0.3);
}
}
canvas {
display: block;
width: 100%;
height: 100%;
touch-action: none;
}
.screen {
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
background: rgba(15, 23, 42, 0.97);
backdrop-filter: blur(25px);
-webkit-backdrop-filter: blur(25px);
display: flex;
flex-direction: column;
justify-content: center;
align-items: center;
z-index: 100;
padding: 5vh 5vw;
transition: opacity 0.4s ease, visibility 0.4s ease;
border-radius: 20px;
}
@media (max-width: 768px) {
.screen {
border-radius: 0;
}
}
.screen.hidden {
opacity: 0;
visibility: hidden;
pointer-events: none;
}
#startScreen {
background: rgba(15, 23, 42, 0.97);
}
@media (max-width: 768px) {
#startScreen {
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
width: 90vw;
max-width: 500px;
height: auto;
min-height: 400px;
border-radius: 20px;
padding: 8vh 8vw;
box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
border: 1px solid rgba(255, 255, 255, 0.15);
}
#startScreen.hidden {
transform: translate(-50%, -50%) scale(0.9);
}
}
#gameOverScreen {
justify-content: flex-start;
padding-top: 6vh;
}
#gameOverScreen .button-group {
display: flex;
gap: clamp(12px, 3vw, 20px);
flex-wrap: wrap;
justify-content: center;
margin-top: 1vh;
}
@media (max-width: 768px) {
#gameOverScreen .button-group {
flex-direction: column;
align-items: center;
}
#gameOverScreen .button-group button {
width: 80%;
}
}
h1 {
font-size: clamp(3rem, 12vw, 5rem);
font-weight: 900;
letter-spacing: -0.05em;
background: linear-gradient(135deg, #fff 0%, #94a3b8 100%);
-webkit-background-clip: text;
-webkit-text-fill-color: transparent;
background-clip: text;
margin-bottom: 2vh;
text-align: center;
line-height: 1;
}
h2 {
font-size: clamp(1.8rem, 6vw, 2.5rem);
color: var(--text-main);
font-weight: 700;
text-align: center;
margin-bottom: 1vh;
}
.subtitle {
font-size: clamp(0.9rem, 3vw, 1.15rem);
color: var(--text-muted);
margin-bottom: 4vh;
font-weight: 500;
max-width: 500px;
text-align: center;
line-height: 1.6;
}
button {
padding: clamp(14px, 3vh, 20px) clamp(40px, 10vw, 60px);
font-size: clamp(1rem, 3.5vw, 1.2rem);
font-weight: 700;
background: var(--primary);
color: white;
border: none;
border-radius: 16px;
cursor: pointer;
box-shadow: 0 8px 24px var(--primary-glow);
transition: all 0.2s ease;
text-transform: uppercase;
letter-spacing: 0.08em;
touch-action: manipulation;
min-width: 200px;
}
button:active {
transform: scale(0.95);
box-shadow: 0 4px 12px var(--primary-glow);
}
.share-btn {
background: #10b981;
box-shadow: 0 8px 24px rgba(16, 185, 129, 0.5);
}
#hud {
position: absolute;
top: 0;
left: 0;
right: 0;
padding: clamp(12px, 2vh, 20px) clamp(12px, 3vw, 24px);
display: flex;
justify-content: space-between;
align-items: flex-start;
pointer-events: none;
z-index: 50;
transition: opacity 0.3s;
}
.hud-pill {
background: rgba(15, 23, 42, 0.85);
border: 1px solid rgba(255,255,255,0.15);
backdrop-filter: blur(12px);
-webkit-backdrop-filter: blur(12px);
padding: clamp(8px, 1.5vh, 12px) clamp(12px, 2.5vw, 16px);
border-radius: 20px;
display: flex;
align-items: center;
gap: clamp(6px, 1.5vw, 10px);
box-shadow: 0 4px 16px rgba(0,0,0,0.3);
}
.hud-label {
font-size: clamp(0.65rem, 2vw, 0.8rem);
text-transform: uppercase;
letter-spacing: 0.05em;
color: var(--text-muted);
font-weight: 700;
}
.hud-value {
font-size: clamp(1rem, 3vw, 1.4rem);
font-weight: 800;
color: var(--text-main);
min-width: clamp(30px, 6vw, 45px);
text-align: right;
}
#lives-container {
display: flex;
gap: clamp(5px, 1.5vw, 8px);
}
.heart {
width: clamp(10px, 2.5vw, 14px);
height: clamp(10px, 2.5vw, 14px);
border-radius: 50%;
background-color: var(--primary);
box-shadow: 0 0 12px var(--primary-glow);
transition: all 0.3s ease;
}
.heart.lost {
background-color: #334155;
box-shadow: none;
opacity: 0.4;
}
.notification-text {
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%) scale(0.8);
font-size: clamp(1.5rem, 5vw, 2.5rem);
font-weight: 900;
color: #fff;
text-shadow: 0 4px 20px rgba(0,0,0,0.8);
opacity: 0;
pointer-events: none;
transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
z-index: 80;
text-align: center;
white-space: nowrap;
}
.notification-text.gold {
color: var(--gold);
text-shadow: 0 0 30px var(--gold-glow), 0 4px 20px rgba(0,0,0,0.8);
}
.notification-text.purple {
color: #c084fc;
text-shadow: 0 0 30px rgba(192, 132, 252, 0.6), 0 4px 20px rgba(0,0,0,0.8);
}
.notification-text.active {
opacity: 1;
transform: translate(-50%, -50%) scale(1);
}

/* Countdown Modal */
#countdownModal {
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
display: flex;
flex-direction: column;
justify-content: center;
align-items: center;
z-index: 200;
color: white;
font-size: 8rem;
font-weight: 900;
opacity: 0;
pointer-events: none;
transition: opacity 0.3s;
background: rgba(15, 23, 42, 0.95);
}
#countdownModal::before {
content: '';
position: absolute;
top: 0;
left: 0;
right: 0;
bottom: 0;
background-image: url('https://images.unsplash.com/photo-1419242902214-272b3f66ee7a?q=80&w=2000');
background-size: cover;
background-position: center;
opacity: 0.3;
z-index: -1;
}
#countdownModal.active {
opacity: 1;
pointer-events: all;
}
.countdown-sponsor {
font-size: clamp(1rem, 3vw, 1.4rem);
margin-bottom: 2vh;
color: var(--text-muted);
text-align: center;
}
.ad-placeholder {
width: 90%;
max-width: 300px;
height: 80px;
background: rgba(0, 0, 0, 0.3);
border: 1px dashed rgba(255, 255, 255, 0.2);
border-radius: 12px;
display: flex;
justify-content: center;
align-items: center;
color: rgba(255, 255, 255, 0.4);
font-size: 0.9rem;
margin-top: 1vh;
}

/* Shake fix: apply only to container */
.shake {
animation: shake 0.5s cubic-bezier(.36,.07,.19,.97);
}
@keyframes shake {
0%, 100% { transform: translateX(0); }
10%, 30%, 50%, 70%, 90% { transform: translateX(-8px); }
20%, 40%, 60%, 80% { transform: translateX(8px); }
}

.total-label {
font-size: clamp(0.9rem, 2.5vw, 1.1rem);
color: var(--text-muted);
text-transform: uppercase;
letter-spacing: 0.1em;
margin-bottom: 1vh;
font-weight: 600;
}
.final-score-display {
font-size: clamp(2.5rem, 11vw, 4rem);
font-weight: 900;
margin-bottom: 3vh;
background: linear-gradient(135deg, var(--primary) 0%, var(--gold) 100%);
-webkit-background-clip: text;
-webkit-text-fill-color: transparent;
background-clip: text;
line-height: 1;
}
.game-over-stats {
display: grid;
grid-template-columns: 1fr 1fr;
gap: clamp(12px, 3vw, 20px);
width: 100%;
max-width: 400px;
margin-bottom: 2vh;
}
.stat-box {
background: rgba(255,255,255,0.05);
border: 1px solid rgba(255, 255, 255, 0.1);
padding: clamp(12px, 2.5vh, 18px);
border-radius: 12px;
text-align: center;
}
.stat-label {
font-size: clamp(0.7rem, 2vw, 0.85rem);
color: var(--text-muted);
text-transform: uppercase;
margin-bottom: 0.5vh;
font-weight: 600;
}
.stat-number {
font-size: clamp(1.5rem, 5vw, 2rem);
font-weight: 900;
color: var(--text-main);
}
@supports(padding: max(0px)) {
#hud {
padding-top: max(clamp(12px, 2vh, 20px), env(safe-area-inset-top));
padding-left: max(clamp(12px, 3vw, 24px), env(safe-area-inset-left));
padding-right: max(clamp(12px, 3vw, 24px), env(safe-area-inset-right));
}
}
</style>
</head>
<body>
<div id="game-container">
<canvas id="gameCanvas"></canvas>
<div id="hud" class="hidden">
<div class="hud-pill">
<span class="hud-label">Score</span>
<span id="scoreDisplay" class="hud-value">0</span>
</div>
<div class="hud-pill">
<span class="hud-label">Orbs</span>
<span id="ballCount" class="hud-value">1</span>
</div>
<div class="hud-pill">
<div id="lives-container">
<div class="heart"></div>
<div class="heart"></div>
<div class="heart"></div>
</div>
</div>
</div>
<div id="notification" class="notification-text">New Orb</div>

<!-- Countdown Modal -->
<div id="countdownModal">
<div class="countdown-sponsor">This game is sponsored by:</div>
<div class="ad-placeholder">Advertisement Space</div>
<div id="countdownNumber">5</div>
</div>

<div id="startScreen" class="screen">
<h1>ORBIT</h1>
<p class="subtitle">Drag to move the paddle. Catch orbs and avoid spikes. Golden orbs grant extra lives!</p>
<button id="startBtn">Start Game</button>
</div>
<div id="gameOverScreen" class="screen hidden">
<h2 style="color: var(--danger);">Game Over</h2>
<div class="total-label">Total Points</div>
<div class="final-score-display" id="finalScore">0</div>
<div class="game-over-stats">
<div class="stat-box">
<div class="stat-number" id="maxBalls">0</div>
<div class="stat-label">Max Orbs</div>
</div>
<div class="stat-box">
<div class="stat-number" id="survivalTime">0s</div>
<div class="stat-label">Survived</div>
</div>
</div>
<div class="button-group">
<button id="shareBtn" class="share-btn">Share Score</button>
<button id="restartBtn">Play Again</button>
</div>
</div>
</div>
<script>
// ═══════════════════════════════════════════════════════════
// CORE SETUP
// ═══════════════════════════════════════════════════════════
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false });
const container = document.getElementById('game-container');
const ui = {
start: document.getElementById('startScreen'),
over: document.getElementById('gameOverScreen'),
hud: document.getElementById('hud'),
score: document.getElementById('scoreDisplay'),
balls: document.getElementById('ballCount'),
finalScore: document.getElementById('finalScore'),
maxBalls: document.getElementById('maxBalls'),
time: document.getElementById('survivalTime'),
lives: document.querySelectorAll('.heart'),
notify: document.getElementById('notification'),
countdown: document.getElementById('countdownModal'),
countdownNum: document.getElementById('countdownNumber'),
shareBtn: document.getElementById('shareBtn')
};
let animationId;
let isPlaying = false;
let lastTime = 0;
let gameTime = 0;
let score = 0;
let lives = 3;
const MAX_LIVES = 5;
let maxBallsActive = 0;
let entities = [];
let particles = [];
let nextBallTime = 0;
let nextSpikeTime = 0;
let nextGoldTime = 0;
let nextPowerUpTime = 0;
let gameWidth = 0;
let gameHeight = 0;
let minBounceY = 0;
let maxBounceY = 0;
let slowMoEndTime = 0;

const paddle = {
width: 0,
height: 0,
x: 0,
y: 0,
targetX: 0,
color: '#3b82f6',
glowColor: 'rgba(59, 130, 246, 0.6)',
startWidthRatio: 0.35,
minWidthRatio: 0.18,
shrinkDuration: 150,
shrinkDelay: 15
};

// ═══════════════════════════════════════════════════════════
// RESPONSIVE CANVAS SETUP
// ═══════════════════════════════════════════════════════════
function resize() {
const rect = container.getBoundingClientRect();
const dpr = Math.min(window.devicePixelRatio || 1, 2);
gameWidth = rect.width;
gameHeight = rect.height;
minBounceY = gameHeight * 0.5;
maxBounceY = gameHeight * 0.1;
canvas.width = gameWidth * dpr;
canvas.height = gameHeight * dpr;
canvas.style.width = gameWidth + 'px';
canvas.style.height = gameHeight + 'px';
ctx.scale(dpr, dpr);
paddle.height = Math.max(12, gameHeight * 0.015);
paddle.width = gameWidth * paddle.startWidthRatio;
paddle.x = (gameWidth - paddle.width) / 2;
paddle.targetX = paddle.x;
paddle.y = gameHeight * 0.82;
}
window.addEventListener('resize', resize);
resize();

// ═══════════════════════════════════════════════════════════
// INPUT HANDLING
// ═══════════════════════════════════════════════════════════
let touchId = null;
function handlePointerMove(clientX) {
if (!isPlaying) return;
const rect = canvas.getBoundingClientRect();
const x = clientX - rect.left;
paddle.targetX = x - (paddle.width / 2);
paddle.targetX = Math.max(0, Math.min(gameWidth - paddle.width, paddle.targetX));
}
canvas.addEventListener('mousemove', (e) => handlePointerMove(e.clientX));
canvas.addEventListener('touchstart', (e) => {
if (!isPlaying) return;
e.preventDefault();
const touch = e.changedTouches[0];
touchId = touch.identifier;
handlePointerMove(touch.clientX);
}, { passive: false });
canvas.addEventListener('touchmove', (e) => {
if (!isPlaying) return;
e.preventDefault();
for (let touch of e.changedTouches) {
if (touch.identifier === touchId) {
handlePointerMove(touch.clientX);
break;
}
}
}, { passive: false });
canvas.addEventListener('touchend', (e) => {
for (let touch of e.changedTouches) {
if (touch.identifier === touchId) {
touchId = null;
break;
}
}
});

// Prevent browser swipe-back/navigation
document.body.addEventListener('touchstart', (e) => {
if (isPlaying) e.preventDefault();
}, { passive: false });

// ═══════════════════════════════════════════════════════════
// GAME ENTITIES (Ball, GoldBall, Spike, SlowMoPowerUp)
// ═══════════════════════════════════════════════════════════
class Ball {
constructor() {
this.type = 'ball';
this.radius = Math.max(8, gameWidth * 0.015);
this.x = gameWidth * (0.15 + Math.random() * 0.7);
this.y = paddle.y - 30;
const targetY = minBounceY - Math.random() * (minBounceY - maxBounceY);
const targetHeight = paddle.y - targetY;
const gravity = 0.4;
const requiredVelocity = Math.sqrt(2 * gravity * targetHeight);
this.dy = -requiredVelocity;
this.dx = (Math.random() - 0.5) * 4;
this.color = `hsl(${200 + Math.random()*60}, 85%, 60%)`;
this.trail = [];
}
update(dt) {
const slowdown = slowMoEndTime > gameTime ? 0.3 : 1;
const gravity = 0.4 * slowdown;
this.dy += gravity;
this.x += this.dx * slowdown;
this.y += this.dy * slowdown;
this.trail.push({x: this.x, y: this.y});
if (this.trail.length > 6) this.trail.shift();
if (this.x < this.radius) {
this.x = this.radius;
this.dx *= -0.85;
}
if (this.x > gameWidth - this.radius) {
this.x = gameWidth - this.radius;
this.dx *= -0.85;
}
if (
this.dy > 0 &&
this.y + this.radius >= paddle.y &&
this.y - this.radius <= paddle.y + paddle.height &&
this.x >= paddle.x - this.radius &&
this.x <= paddle.x + paddle.width + this.radius
) {
const targetY = minBounceY - Math.random() * (minBounceY - maxBounceY);
const targetHeight = paddle.y - targetY;
const requiredVelocity = Math.sqrt(2 * gravity * targetHeight);
this.dy = -requiredVelocity * (0.95 + Math.random() * 0.1);
const hitPos = (this.x - (paddle.x + paddle.width/2)) / (paddle.width/2);
this.dx = hitPos * 6;
score += 10;
ui.score.textContent = score;
spawnParticles(this.x, paddle.y, this.color, 8);
updateHUD();
return 'hit';
}
if (this.y > gameHeight + this.radius * 2) return 'dead';
return 'alive';
}
draw() {
ctx.globalAlpha = 0.4;
this.trail.forEach((pos, i) => {
const size = this.radius * (i / this.trail.length);
ctx.fillStyle = this.color;
ctx.beginPath();
ctx.arc(pos.x, pos.y, size, 0, Math.PI * 2);
ctx.fill();
});
ctx.globalAlpha = 1;
ctx.shadowBlur = 20;
ctx.shadowColor = this.color;
ctx.fillStyle = this.color;
ctx.beginPath();
ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
ctx.fill();
ctx.fillStyle = 'rgba(255,255,255,0.9)';
ctx.beginPath();
ctx.arc(this.x - this.radius * 0.3, this.y - this.radius * 0.3, this.radius * 0.25, 0, Math.PI * 2);
ctx.fill();
ctx.shadowBlur = 0;
}
}

class GoldBall {
constructor() {
this.type = 'gold';
this.radius = Math.max(12, gameWidth * 0.022);
this.x = gameWidth * (0.2 + Math.random() * 0.6);
this.y = paddle.y - 30;
const targetY = minBounceY - Math.random() * (minBounceY - maxBounceY);
const targetHeight = paddle.y - targetY;
const gravity = 0.4;
const requiredVelocity = Math.sqrt(2 * gravity * targetHeight);
this.dy = -requiredVelocity;
this.dx = (Math.random() - 0.5) * 3;
this.pulse = 0;
this.color = '#fbbf24';
this.trail = [];
}
update(dt) {
const slowdown = slowMoEndTime > gameTime ? 0.3 : 1;
const gravity = 0.4 * slowdown;
this.dy += gravity;
this.x += this.dx * slowdown;
this.y += this.dy * slowdown;
this.pulse += dt * 6;
this.trail.push({x: this.x, y: this.y});
if (this.trail.length > 8) this.trail.shift();
if (this.x < this.radius) {
this.x = this.radius;
this.dx *= -0.9;
}
if (this.x > gameWidth - this.radius) {
this.x = gameWidth - this.radius;
this.dx *= -0.9;
}
if (
this.y + this.radius >= paddle.y &&
this.y - this.radius <= paddle.y + paddle.height &&
this.x >= paddle.x - this.radius &&
this.x <= paddle.x + paddle.width + this.radius
) {
return 'hit';
}
if (this.y > gameHeight + this.radius * 2) return 'dead';
return 'alive';
}
draw() {
const r = this.radius + Math.sin(this.pulse) * 2;
ctx.globalAlpha = 0.5;
this.trail.forEach((pos, i) => {
const size = r * (i / this.trail.length);
ctx.fillStyle = this.color;
ctx.beginPath();
ctx.arc(pos.x, pos.y, size, 0, Math.PI * 2);
ctx.fill();
});
ctx.globalAlpha = 1;
ctx.shadowBlur = 30;
ctx.shadowColor = this.color;
ctx.fillStyle = this.color;
ctx.beginPath();
ctx.arc(this.x, this.y, r, 0, Math.PI * 2);
ctx.fill();
ctx.fillStyle = '#fff';
ctx.shadowBlur = 15;
ctx.beginPath();
ctx.arc(this.x - r * 0.25, this.y - r * 0.25, r * 0.3, 0, Math.PI * 2);
ctx.fill();
ctx.shadowBlur = 0;
}
}

class Spike {
constructor() {
this.type = 'spike';
this.size = Math.max(12, gameWidth * 0.02);
this.x = gameWidth * (0.1 + Math.random() * 0.8);
this.y = -this.size * 2;
const speed = 3 + (gameTime * 0.025);
this.dx = (Math.random() - 0.5) * 1.5;
this.dy = speed;
this.color = '#ef4444';
this.rot = Math.random() * Math.PI * 2;
this.rotSpeed = (Math.random() - 0.5) * 0.12;
}
update(dt) {
const slowdown = slowMoEndTime > gameTime ? 0.3 : 1;
this.dy += 0.08 * slowdown;
this.x += this.dx * slowdown;
this.y += this.dy * slowdown;
this.rot += this.rotSpeed * slowdown;
if (this.x < 0) this.x = gameWidth;
if (this.x > gameWidth) this.x = 0;
const expandedHitbox = this.size * 0.7;
if (
this.y + expandedHitbox >= paddle.y &&
this.y - expandedHitbox <= paddle.y + paddle.height &&
this.x >= paddle.x - expandedHitbox &&
this.x <= paddle.x + paddle.width + expandedHitbox
) {
return 'hit';
}
if (this.y > gameHeight + this.size * 2) return 'dead';
return 'alive';
}
draw() {
ctx.save();
ctx.translate(this.x, this.y);
ctx.rotate(this.rot);
ctx.shadowBlur = 15;
ctx.shadowColor = this.color;
ctx.fillStyle = this.color;
ctx.beginPath();
ctx.moveTo(0, -this.size);
ctx.lineTo(this.size * 0.9, this.size * 0.9);
ctx.lineTo(-this.size * 0.9, this.size * 0.9);
ctx.closePath();
ctx.fill();
ctx.restore();
ctx.shadowBlur = 0;
}
}

class SlowMoPowerUp {
constructor() {
this.type = 'slowmo';
this.radius = Math.max(10, gameWidth * 0.018);
this.x = gameWidth * (0.2 + Math.random() * 0.6);
this.y = paddle.y - 30;
const targetY = minBounceY - Math.random() * (minBounceY - maxBounceY);
const targetHeight = paddle.y - targetY;
const gravity = 0.4;
const requiredVelocity = Math.sqrt(2 * gravity * targetHeight);
this.dy = -requiredVelocity;
this.dx = (Math.random() - 0.5) * 2.5;
this.color = '#c084fc';
this.trail = [];
}
update(dt) {
const slowdown = slowMoEndTime > gameTime ? 0.3 : 1;
const gravity = 0.4 * slowdown;
this.dy += gravity;
this.x += this.dx * slowdown;
this.y += this.dy * slowdown;
this.trail.push({x: this.x, y: this.y});
if (this.trail.length > 7) this.trail.shift();
if (this.x < this.radius) {
this.x = this.radius;
this.dx *= -0.85;
}
if (this.x > gameWidth - this.radius) {
this.x = gameWidth - this.radius;
this.dx *= -0.85;
}
if (
this.y + this.radius >= paddle.y &&
this.y - this.radius <= paddle.y + paddle.height &&
this.x >= paddle.x - this.radius &&
this.x <= paddle.x + paddle.width + this.radius
) {
return 'hit';
}
if (this.y > gameHeight + this.radius * 2) return 'dead';
return 'alive';
}
draw() {
ctx.globalAlpha = 0.5;
this.trail.forEach((pos, i) => {
const size = this.radius * (i / this.trail.length);
ctx.fillStyle = this.color;
ctx.beginPath();
ctx.arc(pos.x, pos.y, size, 0, Math.PI * 2);
ctx.fill();
});
ctx.globalAlpha = 1;
ctx.shadowBlur = 25;
ctx.shadowColor = this.color;
ctx.fillStyle = this.color;
ctx.beginPath();
ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
ctx.fill();
ctx.fillStyle = 'rgba(255,255,255,0.9)';
ctx.beginPath();
ctx.arc(this.x - this.radius * 0.3, this.y - this.radius * 0.3, this.radius * 0.2, 0, Math.PI * 2);
ctx.fill();
ctx.shadowBlur = 0;
}
}

// ═══════════════════════════════════════════════════════════
// EFFECTS & NOTIFICATIONS
// ═══════════════════════════════════════════════════════════
function spawnParticles(x, y, color, count = 10) {
const maxParts = window.devicePixelRatio > 1 ? 100 : 50;
if (particles.length > maxParts) return;
for (let i = 0; i < count; i++) {
const angle = Math.random() * Math.PI * 2;
const speed = 2 + Math.random() * 4;
particles.push({
x, y,
dx: Math.cos(angle) * speed,
dy: Math.sin(angle) * speed,
life: 1.0,
size: 2 + Math.random() * 3,
color
});
}
}
function updateParticles() {
const slowdown = slowMoEndTime > gameTime ? 0.3 : 1;
for (let i = particles.length - 1; i >= 0; i--) {
const p = particles[i];
p.x += p.dx * slowdown;
p.y += p.dy * slowdown;
p.dy += 0.15 * slowdown;
p.life -= 0.02;
if (p.life <= 0) {
particles.splice(i, 1);
} else {
ctx.globalAlpha = p.life;
ctx.fillStyle = p.color;
ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
}
}
ctx.globalAlpha = 1;
}
function showNotification(text, type = '') {
ui.notify.textContent = text;
ui.notify.className = 'notification-text active';
if (type === 'gold') ui.notify.classList.add('gold');
else if (type === 'purple') ui.notify.classList.add('purple');
if (ui.notifyTimeout) clearTimeout(ui.notifyTimeout);
ui.notifyTimeout = setTimeout(() => {
ui.notify.classList.remove('active');
}, 1800);
}

// ═══════════════════════════════════════════════════════════
// GAME LOGIC
// ═══════════════════════════════════════════════════════════
function updateHUD() {
const balls = entities.filter(e => e.type === 'ball').length;
ui.balls.textContent = balls;
maxBallsActive = Math.max(maxBallsActive, balls);
ui.lives.forEach((dot, i) => {
dot.classList.toggle('lost', i >= lives);
});
}
function takeDamage() {
lives--;
updateHUD();
container.classList.add('shake');
setTimeout(() => container.classList.remove('shake'), 500);
if (lives <= 0) {
gameOver();
}
}
function addLife() {
if (lives < MAX_LIVES) {
lives++;
updateHUD();
container.classList.add('pulse');
setTimeout(() => container.classList.remove('pulse'), 300);
}
}
function activateSlowMo() {
slowMoEndTime = gameTime + 5;
showNotification('SLOW TIME!', 'purple');
}
function startCountdown() {
ui.start.classList.add('hidden');
ui.countdown.classList.add('active');
let count = 5;
ui.countdownNum.textContent = count;
const interval = setInterval(() => {
count--;
if (count > 0) {
ui.countdownNum.textContent = count;
} else {
clearInterval(interval);
ui.countdown.classList.remove('active');
initGame();
}
}, 1000);
}
function initGame() {
resize();
entities = [new Ball()];
particles = [];
score = 0;
lives = 3;
gameTime = 0;
maxBallsActive = 1;
paddle.width = gameWidth * paddle.startWidthRatio;
paddle.x = (gameWidth - paddle.width) / 2;
paddle.targetX = paddle.x;
nextBallTime = 8;
nextSpikeTime = 25;
nextGoldTime = 30;
nextPowerUpTime = 45;
updateHUD();
ui.score.textContent = '0';
isPlaying = true;
ui.hud.classList.remove('hidden');
lastTime = performance.now();
animate(lastTime);
}
function gameOver() {
isPlaying = false;
cancelAnimationFrame(animationId);
ui.finalScore.textContent = score;
ui.maxBalls.textContent = maxBallsActive;
ui.time.textContent = Math.floor(gameTime) + 's';
ui.hud.classList.add('hidden');
ui.over.classList.remove('hidden');
}

// ═══════════════════════════════════════════════════════════
// SOCIAL SHARE
// ═══════════════════════════════════════════════════════════
function shareScore() {
if (navigator.share) {
navigator.share({
title: 'Orbit Bounce Score',
text: `I scored ${score} points in Orbit Bounce! Can you beat it?`,
url: window.location.href
}).catch(console.error);
} else {
alert('Your score: ' + score + '\nShare it with friends!');
}
}
ui.shareBtn.addEventListener('click', shareScore);

// ═══════════════════════════════════════════════════════════
// MAIN GAME LOOP — FIXED TIME STEP
// ═══════════════════════════════════════════════════════════
let accumulator = 0;
const fixedDeltaTime = 1 / 60;

function animate(timestamp) {
if (!isPlaying) return;

	const frameTime = (timestamp - lastTime) / 1000;
	lastTime = timestamp;
	const clampedFrameTime = Math.min(frameTime, 0.25);
	accumulator += clampedFrameTime;
	gameTime += clampedFrameTime;

	const gradient = ctx.createLinearGradient(0, 0, 0, gameHeight);
	gradient.addColorStop(0, '#0f172a');
	gradient.addColorStop(1, '#1e293b');
	ctx.fillStyle = gradient;
	ctx.fillRect(0, 0, gameWidth, gameHeight);

	while (accumulator >= fixedDeltaTime) {
		updateGameLogic(fixedDeltaTime);
		accumulator -= fixedDeltaTime;
	}

	drawEntities();

	animationId = requestAnimationFrame(animate);
}

function updateGameLogic(dt) {
	if (gameTime > nextBallTime) {
		const ballCount = entities.filter(e => e.type === 'ball').length;
		if (ballCount < 5) {
			entities.push(new Ball());
			nextBallTime = gameTime + (8 + Math.random() * 6);
			showNotification('New Orb');
		}
	}
	if (gameTime > nextSpikeTime) {
		entities.push(new Spike());
		nextSpikeTime = gameTime + (12 + Math.random() * 8);
		showNotification('⚠ Spike');
	}
	if (gameTime > nextGoldTime) {
		entities.push(new GoldBall());
		nextGoldTime = gameTime + 30;
		showNotification('GOLDEN ORB!', 'gold');
	}
	if (gameTime > nextPowerUpTime) {
		entities.push(new SlowMoPowerUp());
		nextPowerUpTime = gameTime + 60;
	}

	const lerpSpeed = 0.25;
	paddle.x += (paddle.targetX - paddle.x) * lerpSpeed;

	if (gameTime > paddle.shrinkDelay) {
		const shrinkProgress = Math.min(
			(gameTime - paddle.shrinkDelay) / paddle.shrinkDuration,
			1
		);
		const easeProgress = 1 - Math.pow(1 - shrinkProgress, 3);
		const startWidth = gameWidth * paddle.startWidthRatio;
		const endWidth = gameWidth * paddle.minWidthRatio;
		const newWidth = startWidth - (startWidth - endWidth) * easeProgress;
		const widthDiff = paddle.width - newWidth;
		const relativePos = (paddle.targetX - paddle.x) / paddle.width;
		paddle.x += widthDiff * (0.5 + relativePos * 0.5);
		paddle.width = newWidth;
		paddle.x = Math.max(0, Math.min(gameWidth - paddle.width, paddle.x));
	}

	for (let i = entities.length - 1; i >= 0; i--) {
		const entity = entities[i];
		const status = entity.update(dt);
		if (status === 'dead') {
			if (entity.type === 'ball') {
				takeDamage();
			}
			entities.splice(i, 1);
			updateHUD();
		} else if (status === 'hit') {
			if (entity.type === 'gold') {
				spawnParticles(entity.x, entity.y, '#fbbf24', 20);
				addLife();
				score += 100;
				ui.score.textContent = score;
				showNotification('+1 LIFE', 'gold');
				entities.splice(i, 1);
			} else if (entity.type === 'spike') {
				spawnParticles(entity.x, entity.y, '#ef4444', 15);
				takeDamage();
				entities.splice(i, 1);
			} else if (entity.type === 'slowmo') {
				spawnParticles(entity.x, entity.y, '#c084fc', 15);
				activateSlowMo();
				entities.splice(i, 1);
			}
		}
	}

	const ballCount = entities.filter(e => e.type === 'ball').length;
	if (isPlaying && ballCount === 0 && lives > 0) {
		entities.push(new Ball());
		updateHUD();
	}

	for (let i = particles.length - 1; i >= 0; i--) {
		const p = particles[i];
		const slowdown = slowMoEndTime > gameTime ? 0.3 : 1;
		p.x += p.dx * slowdown;
		p.y += p.dy * slowdown;
		p.dy += 0.15 * slowdown;
		p.life -= 0.02;
		if (p.life <= 0) {
			particles.splice(i, 1);
		}
	}
}

function drawEntities() {
	const paddleGradient = ctx.createLinearGradient(
		paddle.x, paddle.y,
		paddle.x, paddle.y + paddle.height
	);
	paddleGradient.addColorStop(0, 'rgba(255,255,255,0.2)');
	paddleGradient.addColorStop(1, paddle.color);
	ctx.shadowBlur = 20;
	ctx.shadowColor = paddle.glowColor;
	ctx.fillStyle = paddleGradient;
	ctx.beginPath();
	if (ctx.roundRect) {
		ctx.roundRect(paddle.x, paddle.y, paddle.width, paddle.height, 8);
	} else {
		ctx.rect(paddle.x, paddle.y, paddle.width, paddle.height);
	}
	ctx.fill();

	ctx.shadowBlur = 0;
	ctx.fillStyle = 'rgba(255,255,255,0.3)';
	ctx.beginPath();
	if (ctx.roundRect) {
		ctx.roundRect(paddle.x, paddle.y, paddle.width, paddle.height * 0.4, [8, 8, 0, 0]);
	} else {
		ctx.rect(paddle.x, paddle.y, paddle.width, paddle.height * 0.4);
	}
	ctx.fill();

	for (const entity of entities) {
		entity.draw();
	}

	for (let i = particles.length - 1; i >= 0; i--) {
		const p = particles[i];
		ctx.globalAlpha = p.life;
		ctx.fillStyle = p.color;
		ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
	}
	ctx.globalAlpha = 1;
}

// ═══════════════════════════════════════════════════════════
// EVENT LISTENERS
// ═══════════════════════════════════════════════════════════
document.getElementById('startBtn').addEventListener('click', startCountdown);
document.getElementById('restartBtn').addEventListener('click', () => {
ui.over.classList.add('hidden');
startCountdown();
});
canvas.addEventListener('contextmenu', (e) => e.preventDefault());
document.addEventListener('visibilitychange', () => {
if (document.hidden && isPlaying) {
lastTime = performance.now();
}
});
</script>
</body>
</html>
