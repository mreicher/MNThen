<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<title>Orbit Bounce</title>
<style>
:root {
--primary: #6366f1;
--primary-glow: rgba(99, 102, 241, 0.6);
--gold: #fbbf24;
--gold-glow: rgba(251, 191, 36, 0.7);
--danger: #f43f5e;
--danger-glow: rgba(244, 63, 94, 0.6);
--purple: #a855f7;
--purple-glow: rgba(168, 85, 247, 0.6);
--text-main: #ffffff;
--text-muted: #cbd5e1;
--bg-overlay: rgba(15, 23, 42, 0.85);
--font-stack: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
}

* {
margin: 0;
padding: 0;
box-sizing: border-box;
user-select: none;
-webkit-user-select: none;
-webkit-touch-callout: none;
-webkit-tap-highlight-color: transparent;
}

html, body {
width: 100%;
height: 100%;
overflow: hidden;
position: fixed;
touch-action: none;
}

body {
background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
color: var(--text-main);
font-family: var(--font-stack);
}

.bg-wrapper {
position: fixed;
top: 0;
left: 0;
right: 0;
bottom: 0;
z-index: 0;
overflow: hidden;
}

.bg-image {
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
min-width: 100%;
min-height: 100%;
width: auto;
height: auto;
object-fit: cover;
filter: brightness(0.7) saturate(1.2);
}

.bg-overlay {
position: absolute;
top: 0;
left: 0;
right: 0;
bottom: 0;
background: radial-gradient(circle at 50% 50%, rgba(99, 102, 241, 0.15), rgba(15, 23, 42, 0.8));
}

.animated-bg {
position: absolute;
top: 0;
left: 0;
right: 0;
bottom: 0;
background: 
linear-gradient(45deg, transparent 30%, rgba(99, 102, 241, 0.1) 50%, transparent 70%),
linear-gradient(-45deg, transparent 30%, rgba(168, 85, 247, 0.1) 50%, transparent 70%);
background-size: 200% 200%;
animation: gradientShift 15s ease infinite;
pointer-events: none;
}

@keyframes gradientShift {
0% { background-position: 0% 50%; }
50% { background-position: 100% 50%; }
100% { background-position: 0% 50%; }
}

#game-container {
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
width: 90vw;
height: 85vh;
max-width: 600px;
max-height: 900px;
display: flex;
flex-direction: column;
border-radius: 24px;
overflow: hidden;
box-shadow: 
0 0 80px rgba(99, 102, 241, 0.4),
0 30px 90px rgba(0, 0, 0, 0.6);
background: linear-gradient(180deg, rgba(30, 41, 59, 0.4) 0%, rgba(15, 23, 42, 0.6) 100%);
backdrop-filter: blur(20px);
-webkit-backdrop-filter: blur(20px);
border: 2px solid rgba(255, 255, 255, 0.1);
z-index: 10;
}

@media (max-width: 768px) {
#game-container {
position: fixed;
top: 0;
left: 0;
transform: none;
width: 100vw;
height: 100vh;
max-width: none;
max-height: none;
border-radius: 0;
background: linear-gradient(180deg, rgba(30, 41, 59, 0.3) 0%, rgba(15, 23, 42, 0.5) 100%);
border: none;
box-shadow: none;
}
}

canvas {
display: block;
width: 100%;
height: 100%;
touch-action: none;
}

.screen {
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
display: flex;
flex-direction: column;
justify-content: center;
align-items: center;
z-index: 100;
padding: 6vh 8vw;
transition: opacity 0.4s ease, visibility 0.4s ease, transform 0.4s ease;
}

.screen.hidden {
opacity: 0;
visibility: hidden;
pointer-events: none;
transform: scale(0.95);
}

#startScreen {
background: transparent;
}

.screen-content {
position: relative;
z-index: 2;
max-width: 500px;
width: 100%;
display: flex;
flex-direction: column;
align-items: center;
}

.logo-container {
margin-bottom: 3vh;
text-align: center;
}

.logo-icon {
width: clamp(60px, 15vw, 100px);
height: clamp(60px, 15vw, 100px);
margin: 0 auto 2vh;
background: linear-gradient(135deg, var(--primary), var(--purple));
border-radius: 50%;
display: flex;
align-items: center;
justify-content: center;
box-shadow: 
0 0 60px var(--primary-glow),
0 20px 40px rgba(0, 0, 0, 0.4);
animation: float 3s ease-in-out infinite;
}

@keyframes float {
0%, 100% { transform: translateY(0px); }
50% { transform: translateY(-10px); }
}

.logo-icon::before {
content: '⚡';
font-size: clamp(2rem, 8vw, 3.5rem);
filter: drop-shadow(0 0 10px rgba(255, 255, 255, 0.8));
}

h1 {
font-size: clamp(3rem, 12vw, 5.5rem);
font-weight: 900;
letter-spacing: -0.03em;
background: linear-gradient(135deg, #fff 0%, #a5b4fc 100%);
-webkit-background-clip: text;
-webkit-text-fill-color: transparent;
background-clip: text;
margin-bottom: 2vh;
text-align: center;
line-height: 1;
text-shadow: 0 0 80px rgba(255, 255, 255, 0.3);
}

h2 {
font-size: clamp(2rem, 7vw, 3rem);
color: var(--text-main);
font-weight: 800;
text-align: center;
margin-bottom: 1.5vh;
text-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
}

.subtitle {
font-size: clamp(0.95rem, 3.2vw, 1.2rem);
color: var(--text-muted);
margin-bottom: 4vh;
font-weight: 500;
max-width: 450px;
text-align: center;
line-height: 1.7;
text-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
}

button {
padding: clamp(16px, 3.5vh, 22px) clamp(48px, 12vw, 70px);
font-size: clamp(1.05rem, 3.8vw, 1.3rem);
font-weight: 700;
background: linear-gradient(135deg, var(--primary), var(--purple));
color: white;
border: none;
border-radius: 16px;
cursor: pointer;
box-shadow: 
0 0 40px var(--primary-glow),
0 10px 30px rgba(0, 0, 0, 0.4);
transition: all 0.3s ease;
text-transform: uppercase;
letter-spacing: 0.1em;
touch-action: manipulation;
min-width: 220px;
position: relative;
overflow: hidden;
}

button::before {
content: '';
position: absolute;
top: 0;
left: -100%;
width: 100%;
height: 100%;
background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
transition: left 0.5s;
}

button:hover::before {
left: 100%;
}

button:active {
transform: scale(0.97);
box-shadow: 
0 0 30px var(--primary-glow),
0 6px 20px rgba(0, 0, 0, 0.4);
}

.share-btn {
background: linear-gradient(135deg, #10b981, #059669);
box-shadow: 
0 0 40px rgba(16, 185, 129, 0.6),
0 10px 30px rgba(0, 0, 0, 0.4);
}

#hud {
position: absolute;
top: 0;
left: 0;
right: 0;
padding: clamp(14px, 2.5vh, 24px) clamp(16px, 3.5vw, 28px);
display: flex;
justify-content: space-between;
align-items: flex-start;
pointer-events: none;
z-index: 50;
transition: opacity 0.3s;
}

.hud-pill {
background: rgba(15, 23, 42, 0.9);
border: 2px solid rgba(99, 102, 241, 0.3);
backdrop-filter: blur(16px);
-webkit-backdrop-filter: blur(16px);
padding: clamp(10px, 2vh, 14px) clamp(14px, 3vw, 18px);
border-radius: 24px;
display: flex;
align-items: center;
gap: clamp(8px, 2vw, 12px);
box-shadow: 
0 0 30px rgba(99, 102, 241, 0.3),
0 8px 24px rgba(0, 0, 0, 0.4);
}

.hud-label {
font-size: clamp(0.7rem, 2.2vw, 0.85rem);
text-transform: uppercase;
letter-spacing: 0.08em;
color: var(--text-muted);
font-weight: 700;
}

.hud-value {
font-size: clamp(1.1rem, 3.5vw, 1.5rem);
font-weight: 900;
color: var(--text-main);
min-width: clamp(35px, 7vw, 50px);
text-align: right;
text-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
}

#lives-container {
display: flex;
gap: clamp(6px, 1.8vw, 10px);
}

.heart {
width: clamp(12px, 3vw, 16px);
height: clamp(12px, 3vw, 16px);
border-radius: 50%;
background: linear-gradient(135deg, var(--primary), var(--purple));
box-shadow: 
0 0 16px var(--primary-glow),
0 4px 8px rgba(0, 0, 0, 0.3);
transition: all 0.3s ease;
}

.heart.lost {
background: rgba(51, 65, 85, 0.5);
box-shadow: none;
opacity: 0.3;
}

.notification-text {
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%) scale(0.8);
font-size: clamp(1.8rem, 6vw, 3rem);
font-weight: 900;
color: #fff;
text-shadow: 
0 0 40px rgba(99, 102, 241, 0.8),
0 4px 30px rgba(0, 0, 0, 0.9);
opacity: 0;
pointer-events: none;
transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
z-index: 80;
text-align: center;
white-space: nowrap;
}

.notification-text.gold {
color: var(--gold);
text-shadow: 
0 0 50px var(--gold-glow),
0 4px 30px rgba(0, 0, 0, 0.9);
}

.notification-text.purple {
color: var(--purple);
text-shadow: 
0 0 50px var(--purple-glow),
0 4px 30px rgba(0, 0, 0, 0.9);
}

.notification-text.active {
opacity: 1;
transform: translate(-50%, -50%) scale(1);
}

#countdownModal {
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
display: flex;
flex-direction: column;
justify-content: center;
align-items: center;
z-index: 200;
color: white;
opacity: 0;
pointer-events: none;
transition: opacity 0.3s;
background: transparent;
}

#countdownModal.active {
opacity: 1;
pointer-events: all;
}

.countdown-content {
position: relative;
z-index: 2;
text-align: center;
}

.countdown-sponsor {
font-size: clamp(1rem, 3.2vw, 1.4rem);
margin-bottom: 2vh;
color: var(--text-muted);
text-align: center;
font-weight: 600;
text-shadow: 0 2px 10px rgba(0, 0, 0, 0.6);
}

.ad-placeholder {
width: 90%;
max-width: 320px;
height: 90px;
background: rgba(15, 23, 42, 0.7);
border: 2px dashed rgba(99, 102, 241, 0.4);
border-radius: 16px;
display: flex;
justify-content: center;
align-items: center;
color: rgba(255, 255, 255, 0.5);
font-size: 0.95rem;
margin: 0 auto 3vh;
backdrop-filter: blur(10px);
-webkit-backdrop-filter: blur(10px);
box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
}

#countdownNumber {
font-size: clamp(6rem, 20vw, 10rem);
font-weight: 900;
background: linear-gradient(135deg, #fff, var(--primary));
-webkit-background-clip: text;
-webkit-text-fill-color: transparent;
background-clip: text;
text-shadow: 0 0 80px rgba(255, 255, 255, 0.5);
animation: pulse 1s ease-in-out;
}

@keyframes pulse {
0%, 100% { transform: scale(1); }
50% { transform: scale(1.1); }
}

.shake {
animation: shake 0.5s cubic-bezier(.36,.07,.19,.97);
}

@keyframes shake {
0%, 100% { transform: translateX(0); }
10%, 30%, 50%, 70%, 90% { transform: translateX(-10px); }
20%, 40%, 60%, 80% { transform: translateX(10px); }
}

#gameOverScreen {
background: transparent;
justify-content: flex-start;
padding-top: 8vh;
}

.game-over-modal {
background: var(--bg-overlay);
backdrop-filter: blur(30px);
-webkit-backdrop-filter: blur(30px);
border-radius: 24px;
padding: clamp(32px, 6vh, 48px) clamp(24px, 5vw, 40px);
box-shadow: 
0 0 80px rgba(99, 102, 241, 0.4),
0 30px 90px rgba(0, 0, 0, 0.7);
border: 2px solid rgba(255, 255, 255, 0.15);
max-width: 500px;
width: 90%;
}

.total-label {
font-size: clamp(0.95rem, 2.8vw, 1.15rem);
color: var(--text-muted);
text-transform: uppercase;
letter-spacing: 0.12em;
margin-bottom: 1vh;
font-weight: 700;
}

.final-score-display {
font-size: clamp(3rem, 12vw, 5rem);
font-weight: 900;
margin-bottom: 3vh;
background: linear-gradient(135deg, var(--primary) 0%, var(--gold) 100%);
-webkit-background-clip: text;
-webkit-text-fill-color: transparent;
background-clip: text;
line-height: 1;
text-shadow: 0 0 60px rgba(99, 102, 241, 0.5);
filter: drop-shadow(0 4px 20px rgba(0, 0, 0, 0.5));
}

.game-over-stats {
display: grid;
grid-template-columns: 1fr 1fr;
gap: clamp(14px, 3.5vw, 24px);
width: 100%;
margin-bottom: 3vh;
}

.stat-box {
background: rgba(99, 102, 241, 0.1);
border: 2px solid rgba(99, 102, 241, 0.3);
padding: clamp(16px, 3vh, 22px);
border-radius: 16px;
text-align: center;
backdrop-filter: blur(10px);
-webkit-backdrop-filter: blur(10px);
box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
}

.stat-label {
font-size: clamp(0.75rem, 2.2vw, 0.9rem);
color: var(--text-muted);
text-transform: uppercase;
margin-bottom: 0.5vh;
font-weight: 700;
letter-spacing: 0.08em;
}

.stat-number {
font-size: clamp(1.8rem, 6vw, 2.5rem);
font-weight: 900;
color: var(--text-main);
text-shadow: 0 2px 12px rgba(0, 0, 0, 0.4);
}

.button-group {
display: flex;
gap: clamp(12px, 3vw, 20px);
flex-wrap: wrap;
justify-content: center;
margin-top: 2vh;
}

@media (max-width: 768px) {
.button-group {
flex-direction: column;
align-items: stretch;
}
.button-group button {
width: 100%;
}
}

@supports(padding: max(0px)) {
#hud {
padding-top: max(clamp(14px, 2.5vh, 24px), env(safe-area-inset-top));
padding-left: max(clamp(16px, 3.5vw, 28px), env(safe-area-inset-left));
padding-right: max(clamp(16px, 3.5vw, 28px), env(safe-area-inset-right));
}
}

.stars {
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
pointer-events: none;
z-index: 1;
}

.star {
position: absolute;
background: white;
border-radius: 50%;
animation: twinkle 3s ease-in-out infinite;
}

@keyframes twinkle {
0%, 100% { opacity: 0.3; transform: scale(1); }
50% { opacity: 1; transform: scale(1.2); }
}
</style>
</head>
<body>
<div class="bg-wrapper">
<img src="https://images.unsplash.com/photo-1506318137071-a8e063b4bec0?q=80&w=2000&auto=format" alt="" class="bg-image">
<div class="bg-overlay"></div>
<div class="animated-bg"></div>
<div class="stars" id="stars"></div>
</div>

<div id="game-container">
<canvas id="gameCanvas"></canvas>
<div id="hud" class="hidden">
<div class="hud-pill">
<span class="hud-label">Score</span>
<span id="scoreDisplay" class="hud-value">0</span>
</div>
<div class="hud-pill">
<span class="hud-label">Orbs</span>
<span id="ballCount" class="hud-value">1</span>
</div>
<div class="hud-pill">
<div id="lives-container">
<div class="heart"></div>
<div class="heart"></div>
<div class="heart"></div>
</div>
</div>
</div>
<div id="notification" class="notification-text">New Orb</div>

<div id="countdownModal">
<div class="countdown-content">
<div class="countdown-sponsor">Get Ready!</div>
<div class="ad-placeholder">Advertisement Space</div>
<div id="countdownNumber">3</div>
</div>
</div>

<div id="startScreen" class="screen">
<div class="screen-content">
<div class="logo-container">
<div class="logo-icon"></div>
<h1>ORBIT</h1>
</div>
<p class="subtitle">Drag to move the paddle. Catch orbs and avoid spikes. Golden orbs grant extra lives!</p>
<button id="startBtn">Start Game</button>
</div>
</div>

<div id="gameOverScreen" class="screen hidden">
<div class="game-over-modal">
<h2 style="color: var(--danger);">Game Over</h2>
<div class="total-label">Total Points</div>
<div class="final-score-display" id="finalScore">0</div>
<div class="game-over-stats">
<div class="stat-box">
<div class="stat-number" id="maxBalls">0</div>
<div class="stat-label">Max Orbs</div>
</div>
<div class="stat-box">
<div class="stat-number" id="survivalTime">0s</div>
<div class="stat-label">Survived</div>
</div>
</div>
<div class="button-group">
<button id="exitBtn">Exit</button>
<button id="restartBtn">Play Again</button>
</div>
</div>
</div>
</div>

<script>
// Create animated stars
function createStars() {
const starsContainer = document.getElementById('stars');
const starCount = 50;
for (let i = 0; i < starCount; i++) {
const star = document.createElement('div');
star.className = 'star';
star.style.left = Math.random() * 100 + '%';
star.style.top = Math.random() * 100 + '%';
star.style.width = (Math.random() * 2 + 1) + 'px';
star.style.height = star.style.width;
star.style.animationDelay = Math.random() * 3 + 's';
star.style.animationDuration = (Math.random() * 3 + 2) + 's';
starsContainer.appendChild(star);
}
}
createStars();

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false });
const container = document.getElementById('game-container');
const ui = {
start: document.getElementById('startScreen'),
over: document.getElementById('gameOverScreen'),
hud: document.getElementById('hud'),
score: document.getElementById('scoreDisplay'),
balls: document.getElementById('ballCount'),
finalScore: document.getElementById('finalScore'),
maxBalls: document.getElementById('maxBalls'),
time: document.getElementById('survivalTime'),
lives: document.querySelectorAll('.heart'),
notify: document.getElementById('notification'),
countdown: document.getElementById('countdownModal'),
countdownNum: document.getElementById('countdownNumber'),
exitBtn: document.getElementById('exitBtn'),
restartBtn: document.getElementById('restartBtn')
};

let animationId;
let isPlaying = false;
let lastTime = 0;
let gameTime = 0;
let score = 0;
let lives = 3;
const MAX_LIVES = 5;
let maxBallsActive = 0;
let entities = [];
let particles = [];
let nextBallTime = 0;
let nextSpikeTime = 0;
let nextGoldTime = 0;
let nextPowerUpTime = 0;
let gameWidth = 0;
let gameHeight = 0;
let minBounceY = 0;
let maxBounceY = 0;
let slowMoEndTime = 0;

const paddle = {
width: 0,
height: 0,
x: 0,
y: 0,
targetX: 0,
color: '#6366f1',
glowColor: 'rgba(99, 102, 241, 0.8)',
startWidthRatio: 0.35,
minWidthRatio: 0.18,
shrinkDuration: 150,
shrinkDelay: 15
};

const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
let shareBtn = null;

function resize() {
const rect = container.getBoundingClientRect();
const dpr = Math.min(window.devicePixelRatio || 1, 2);
gameWidth = rect.width;
gameHeight = rect.height;
minBounceY = gameHeight * 0.5;
maxBounceY = gameHeight * 0.1;
canvas.width = gameWidth * dpr;
canvas.height = gameHeight * dpr;
canvas.style.width = gameWidth + 'px';
canvas.style.height = gameHeight + 'px';
ctx.scale(dpr, dpr);
paddle.height = Math.max(12, gameHeight * 0.015);
paddle.width = gameWidth * paddle.startWidthRatio;
paddle.x = (gameWidth - paddle.width) / 2;
paddle.targetX = paddle.x;
paddle.y = gameHeight * 0.82;
}
window.addEventListener('resize', resize);
resize();

let touchId = null;
function handlePointerMove(clientX) {
if (!isPlaying) return;
const rect = canvas.getBoundingClientRect();
const x = clientX - rect.left;
paddle.targetX = x - (paddle.width / 2);
paddle.targetX = Math.max(0, Math.min(gameWidth - paddle.width, paddle.targetX));
}

canvas.addEventListener('mousemove', (e) => handlePointerMove(e.clientX));
canvas.addEventListener('touchstart', (e) => {
if (!isPlaying) return;
e.preventDefault();
const touch = e.changedTouches[0];
touchId = touch.identifier;
handlePointerMove(touch.clientX);
}, { passive: false });

canvas.addEventListener('touchmove', (e) => {
if (!isPlaying) return;
e.preventDefault();
for (let touch of e.changedTouches) {
if (touch.identifier === touchId) {
handlePointerMove(touch.clientX);
break;
}
}
}, { passive: false });

canvas.addEventListener('touchend', (e) => {
for (let touch of e.changedTouches) {
if (touch.identifier === touchId) {
touchId = null;
break;
}
}
});

document.body.addEventListener('touchstart', (e) => {
if (isPlaying) e.preventDefault();
}, { passive: false });

class Ball {
constructor() {
this.type = 'ball';
this.radius = Math.max(8, gameWidth * 0.015);
this.x = gameWidth * (0.15 + Math.random() * 0.7);
this.y = paddle.y - 30;
const targetY = minBounceY - Math.random() * (minBounceY - maxBounceY);
const targetHeight = paddle.y - targetY;
const gravity = 0.4;
const requiredVelocity = Math.sqrt(2 * gravity * targetHeight);
this.dy = -requiredVelocity;
this.dx = (Math.random() - 0.5) * 4;
this.hue = 200 + Math.random() * 60;
this.trail = [];
}
update(dt) {
const slowdown = slowMoEndTime > gameTime ? 0.3 : 1;
const gravity = 0.4 * slowdown;
this.dy += gravity;
this.x += this.dx * slowdown;
this.y += this.dy * slowdown;
this.trail.push({x: this.x, y: this.y});
if (this.trail.length > 6) this.trail.shift();
if (this.x < this.radius) {
this.x = this.radius;
this.dx *= -0.85;
}
if (this.x > gameWidth - this.radius) {
this.x = gameWidth - this.radius;
this.dx *= -0.85;
}
if (
this.dy > 0 &&
this.y + this.radius >= paddle.y &&
this.y - this.radius <= paddle.y + paddle.height &&
this.x >= paddle.x - this.radius &&
this.x <= paddle.x + paddle.width + this.radius
) {
const targetY = minBounceY - Math.random() * (minBounceY - maxBounceY);
const targetHeight = paddle.y - targetY;
const requiredVelocity = Math.sqrt(2 * gravity * targetHeight);
this.dy = -requiredVelocity * (0.95 + Math.random() * 0.1);
const hitPos = (this.x - (paddle.x + paddle.width/2)) / (paddle.width/2);
this.dx = hitPos * 6;
score += 10;
ui.score.textContent = score;
spawnParticles(this.x, paddle.y, `hsl(${this.hue}, 85%, 60%)`, 8);
updateHUD();
return 'hit';
}
if (this.y > gameHeight + this.radius * 2) return 'dead';
return 'alive';
}
draw() {
const color = `hsl(${this.hue}, 85%, 60%)`;
ctx.globalAlpha = 0.4;
this.trail.forEach((pos, i) => {
const size = this.radius * (i / this.trail.length);
ctx.fillStyle = color;
ctx.beginPath();
ctx.arc(pos.x, pos.y, size, 0, Math.PI * 2);
ctx.fill();
});
ctx.globalAlpha = 1;
ctx.shadowBlur = 25;
ctx.shadowColor = color;
ctx.fillStyle = color;
ctx.beginPath();
ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
ctx.fill();
ctx.fillStyle = 'rgba(255,255,255,0.9)';
ctx.beginPath();
ctx.arc(this.x - this.radius * 0.3, this.y - this.radius * 0.3, this.radius * 0.25, 0, Math.PI * 2);
ctx.fill();
ctx.shadowBlur = 0;
}
}

class GoldBall {
constructor() {
this.type = 'gold';
this.radius = Math.max(12, gameWidth * 0.022);
this.x = gameWidth * (0.2 + Math.random() * 0.6);
this.y = paddle.y - 30;
const targetY = minBounceY - Math.random() * (minBounceY - maxBounceY);
const targetHeight = paddle.y - targetY;
const gravity = 0.4;
const requiredVelocity = Math.sqrt(2 * gravity * targetHeight);
this.dy = -requiredVelocity;
this.dx = (Math.random() - 0.5) * 3;
this.pulse = 0;
this.color = '#fbbf24';
this.trail = [];
}
update(dt) {
const slowdown = slowMoEndTime > gameTime ? 0.3 : 1;
const gravity = 0.4 * slowdown;
this.dy += gravity;
this.x += this.dx * slowdown;
this.y += this.dy * slowdown;
this.pulse += dt * 6;
this.trail.push({x: this.x, y: this.y});
if (this.trail.length > 8) this.trail.shift();
if (this.x < this.radius) {
this.x = this.radius;
this.dx *= -0.9;
}
if (this.x > gameWidth - this.radius) {
this.x = gameWidth - this.radius;
this.dx *= -0.9;
}
if (
this.y + this.radius >= paddle.y &&
this.y - this.radius <= paddle.y + paddle.height &&
this.x >= paddle.x - this.radius &&
this.x <= paddle.x + paddle.width + this.radius
) {
return 'hit';
}
if (this.y > gameHeight + this.radius * 2) return 'dead';
return 'alive';
}
draw() {
const r = this.radius + Math.sin(this.pulse) * 2;
ctx.globalAlpha = 0.5;
this.trail.forEach((pos, i) => {
const size = r * (i / this.trail.length);
ctx.fillStyle = this.color;
ctx.beginPath();
ctx.arc(pos.x, pos.y, size, 0, Math.PI * 2);
ctx.fill();
});
ctx.globalAlpha = 1;
ctx.shadowBlur = 35;
ctx.shadowColor = this.color;
ctx.fillStyle = this.color;
ctx.beginPath();
ctx.arc(this.x, this.y, r, 0, Math.PI * 2);
ctx.fill();
ctx.fillStyle = '#fff';
ctx.shadowBlur = 20;
ctx.beginPath();
ctx.arc(this.x - r * 0.25, this.y - r * 0.25, r * 0.3, 0, Math.PI * 2);
ctx.fill();
ctx.shadowBlur = 0;
}
}

class Spike {
constructor() {
this.type = 'spike';
this.size = Math.max(12, gameWidth * 0.02);
this.x = gameWidth * (0.1 + Math.random() * 0.8);
this.y = -this.size * 2;
const speed = 3 + (gameTime * 0.025);
this.dx = (Math.random() - 0.5) * 1.5;
this.dy = speed;
this.color = '#f43f5e';
this.rot = Math.random() * Math.PI * 2;
this.rotSpeed = (Math.random() - 0.5) * 0.12;
}
update(dt) {
const slowdown = slowMoEndTime > gameTime ? 0.3 : 1;
this.dy += 0.08 * slowdown;
this.x += this.dx * slowdown;
this.y += this.dy * slowdown;
this.rot += this.rotSpeed * slowdown;
if (this.x < 0) this.x = gameWidth;
if (this.x > gameWidth) this.x = 0;
const expandedHitbox = this.size * 0.7;
if (
this.y + expandedHitbox >= paddle.y &&
this.y - expandedHitbox <= paddle.y + paddle.height &&
this.x >= paddle.x - expandedHitbox &&
this.x <= paddle.x + paddle.width + expandedHitbox
) {
return 'hit';
}
if (this.y > gameHeight + this.size * 2) return 'dead';
return 'alive';
}
draw() {
ctx.save();
ctx.translate(this.x, this.y);
ctx.rotate(this.rot);
ctx.shadowBlur = 20;
ctx.shadowColor = this.color;
ctx.fillStyle = this.color;
ctx.beginPath();
ctx.moveTo(0, -this.size);
ctx.lineTo(this.size * 0.9, this.size * 0.9);
ctx.lineTo(-this.size * 0.9, this.size * 0.9);
ctx.closePath();
ctx.fill();
ctx.restore();
ctx.shadowBlur = 0;
}
}

class SlowMoPowerUp {
constructor() {
this.type = 'slowmo';
this.radius = Math.max(10, gameWidth * 0.018);
this.x = gameWidth * (0.2 + Math.random() * 0.6);
this.y = paddle.y - 30;
const targetY = minBounceY - Math.random() * (minBounceY - maxBounceY);
const targetHeight = paddle.y - targetY;
const gravity = 0.4;
const requiredVelocity = Math.sqrt(2 * gravity * targetHeight);
this.dy = -requiredVelocity;
this.dx = (Math.random() - 0.5) * 2.5;
this.color = '#a855f7';
this.trail = [];
}
update(dt) {
const slowdown = slowMoEndTime > gameTime ? 0.3 : 1;
const gravity = 0.4 * slowdown;
this.dy += gravity;
this.x += this.dx * slowdown;
this.y += this.dy * slowdown;
this.trail.push({x: this.x, y: this.y});
if (this.trail.length > 7) this.trail.shift();
if (this.x < this.radius) {
this.x = this.radius;
this.dx *= -0.85;
}
if (this.x > gameWidth - this.radius) {
this.x = gameWidth - this.radius;
this.dx *= -0.85;
}
if (
this.y + this.radius >= paddle.y &&
this.y - this.radius <= paddle.y + paddle.height &&
this.x >= paddle.x - this.radius &&
this.x <= paddle.x + paddle.width + this.radius
) {
return 'hit';
}
if (this.y > gameHeight + this.radius * 2) return 'dead';
return 'alive';
}
draw() {
ctx.globalAlpha = 0.5;
this.trail.forEach((pos, i) => {
const size = this.radius * (i / this.trail.length);
ctx.fillStyle = this.color;
ctx.beginPath();
ctx.arc(pos.x, pos.y, size, 0, Math.PI * 2);
ctx.fill();
});
ctx.globalAlpha = 1;
ctx.shadowBlur = 30;
ctx.shadowColor = this.color;
ctx.fillStyle = this.color;
ctx.beginPath();
ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
ctx.fill();
ctx.fillStyle = 'rgba(255,255,255,0.9)';
ctx.beginPath();
ctx.arc(this.x - this.radius * 0.3, this.y - this.radius * 0.3, this.radius * 0.2, 0, Math.PI * 2);
ctx.fill();
ctx.shadowBlur = 0;
}
}

function spawnParticles(x, y, color, count = 10) {
const maxParts = window.devicePixelRatio > 1 ? 100 : 50;
if (particles.length > maxParts) return;
for (let i = 0; i < count; i++) {
const angle = Math.random() * Math.PI * 2;
const speed = 2 + Math.random() * 4;
particles.push({
x, y,
dx: Math.cos(angle) * speed,
dy: Math.sin(angle) * speed,
life: 1.0,
size: 2 + Math.random() * 3,
color
});
}
}

function updateParticles() {
const slowdown = slowMoEndTime > gameTime ? 0.3 : 1;
for (let i = particles.length - 1; i >= 0; i--) {
const p = particles[i];
p.x += p.dx * slowdown;
p.y += p.dy * slowdown;
p.dy += 0.15 * slowdown;
p.life -= 0.02;
if (p.life <= 0) {
particles.splice(i, 1);
} else {
ctx.globalAlpha = p.life;
ctx.fillStyle = p.color;
ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
}
}
ctx.globalAlpha = 1;
}

function showNotification(text, type = '') {
ui.notify.textContent = text;
ui.notify.className = 'notification-text active';
if (type === 'gold') ui.notify.classList.add('gold');
else if (type === 'purple') ui.notify.classList.add('purple');
if (ui.notifyTimeout) clearTimeout(ui.notifyTimeout);
ui.notifyTimeout = setTimeout(() => {
ui.notify.classList.remove('active');
}, 1800);
}

function updateHUD() {
const balls = entities.filter(e => e.type === 'ball').length;
ui.balls.textContent = balls;
maxBallsActive = Math.max(maxBallsActive, balls);
ui.lives.forEach((dot, i) => {
dot.classList.toggle('lost', i >= lives);
});
}

function takeDamage() {
lives--;
updateHUD();
container.classList.add('shake');
setTimeout(() => container.classList.remove('shake'), 500);
if (lives <= 0) {
gameOver();
}
}

function addLife() {
if (lives < MAX_LIVES) {
lives++;
updateHUD();
}
}

function activateSlowMo() {
slowMoEndTime = gameTime + 5;
showNotification('SLOW TIME!', 'purple');
}

function startCountdown() {
ui.start.classList.add('hidden');
ui.countdown.classList.add('active');
let count = 3;
ui.countdownNum.textContent = count;
const interval = setInterval(() => {
count--;
if (count > 0) {
ui.countdownNum.textContent = count;
ui.countdownNum.style.animation = 'none';
setTimeout(() => {
ui.countdownNum.style.animation = 'pulse 1s ease-in-out';
}, 10);
} else {
clearInterval(interval);
ui.countdown.classList.remove('active');
initGame();
}
}, 1000);
}

function initGame() {
resize();
entities = [new Ball()];
particles = [];
score = 0;
lives = 3;
gameTime = 0;
maxBallsActive = 1;
slowMoEndTime = 0;
paddle.width = gameWidth * paddle.startWidthRatio;
paddle.x = (gameWidth - paddle.width) / 2;
paddle.targetX = paddle.x;
nextBallTime = 8;
nextSpikeTime = 25;
nextGoldTime = 30;
nextPowerUpTime = 45;
updateHUD();
ui.score.textContent = '0';
isPlaying = true;
ui.hud.classList.remove('hidden');
lastTime = performance.now();
animate(lastTime);
}

function gameOver() {
isPlaying = false;
cancelAnimationFrame(animationId);
slowMoEndTime = 0;
ui.finalScore.textContent = score;
ui.maxBalls.textContent = maxBallsActive;
ui.time.textContent = Math.floor(gameTime) + 's';
ui.hud.classList.add('hidden');
ui.over.classList.remove('hidden');
}

function setupShareButton() {
if (isTouchDevice && navigator.share) {
shareBtn = document.createElement('button');
shareBtn.className = 'share-btn';
shareBtn.textContent = 'Share Score';
shareBtn.addEventListener('click', () => {
navigator.share({
title: 'Orbit Bounce Score',
text: `I scored ${score} points in Orbit Bounce! Can you beat it?`,
url: window.location.href
}).catch(console.error);
});
const buttonGroup = document.querySelector('#gameOverScreen .button-group');
buttonGroup.insertBefore(shareBtn, buttonGroup.firstChild);
}
}
setupShareButton();

let accumulator = 0;
const fixedDeltaTime = 1 / 60;

function animate(timestamp) {
if (!isPlaying) return;
const frameTime = (timestamp - lastTime) / 1000;
lastTime = timestamp;
const clampedFrameTime = Math.min(frameTime, 0.25);
accumulator += clampedFrameTime;
gameTime += clampedFrameTime;

const gradient = ctx.createLinearGradient(0, 0, 0, gameHeight);
gradient.addColorStop(0, 'rgba(30, 41, 59, 0.5)');
gradient.addColorStop(1, 'rgba(15, 23, 42, 0.7)');
ctx.fillStyle = gradient;
ctx.fillRect(0, 0, gameWidth, gameHeight);

while (accumulator >= fixedDeltaTime) {
updateGameLogic(fixedDeltaTime);
accumulator -= fixedDeltaTime;
}

drawEntities();
animationId = requestAnimationFrame(animate);
}

function updateGameLogic(dt) {
if (gameTime > nextBallTime) {
const ballCount = entities.filter(e => e.type === 'ball').length;
if (ballCount < 5) {
entities.push(new Ball());
nextBallTime = gameTime + (8 + Math.random() * 6);
showNotification('New Orb');
}
}
if (gameTime > nextSpikeTime) {
entities.push(new Spike());
nextSpikeTime = gameTime + (12 + Math.random() * 8);
showNotification('⚠ Spike');
}
if (gameTime > nextGoldTime) {
entities.push(new GoldBall());
nextGoldTime = gameTime + 30;
showNotification('GOLDEN ORB!', 'gold');
}
if (gameTime > nextPowerUpTime) {
entities.push(new SlowMoPowerUp());
nextPowerUpTime = gameTime + 60;
}

const lerpSpeed = 0.25;
paddle.x += (paddle.targetX - paddle.x) * lerpSpeed;

if (gameTime > paddle.shrinkDelay) {
const shrinkProgress = Math.min(
(gameTime - paddle.shrinkDelay) / paddle.shrinkDuration,
1
);
const easeProgress = 1 - Math.pow(1 - shrinkProgress, 3);
const startWidth = gameWidth * paddle.startWidthRatio;
const endWidth = gameWidth * paddle.minWidthRatio;
const newWidth = startWidth - (startWidth - endWidth) * easeProgress;
const widthDiff = paddle.width - newWidth;
const relativePos = (paddle.targetX - paddle.x) / paddle.width;
paddle.x += widthDiff * (0.5 + relativePos * 0.5);
paddle.width = newWidth;
paddle.x = Math.max(0, Math.min(gameWidth - paddle.width, paddle.x));
}

for (let i = entities.length - 1; i >= 0; i--) {
const entity = entities[i];
const status = entity.update(dt);
if (status === 'dead') {
if (entity.type === 'ball') {
takeDamage();
}
entities.splice(i, 1);
updateHUD();
} else if (status === 'hit') {
if (entity.type === 'gold') {
spawnParticles(entity.x, entity.y, '#fbbf24', 20);
addLife();
score += 100;
ui.score.textContent = score;
showNotification('+1 LIFE', 'gold');
entities.splice(i, 1);
} else if (entity.type === 'spike') {
spawnParticles(entity.x, entity.y, '#f43f5e', 15);
takeDamage();
entities.splice(i, 1);
} else if (entity.type === 'slowmo') {
spawnParticles(entity.x, entity.y, '#a855f7', 15);
activateSlowMo();
entities.splice(i, 1);
}
}
}

const ballCount = entities.filter(e => e.type === 'ball').length;
if (isPlaying && ballCount === 0 && lives > 0) {
entities.push(new Ball());
updateHUD();
}

for (let i = particles.length - 1; i >= 0; i--) {
const p = particles[i];
const slowdown = slowMoEndTime > gameTime ? 0.3 : 1;
p.x += p.dx * slowdown;
p.y += p.dy * slowdown;
p.dy += 0.15 * slowdown;
p.life -= 0.02;
if (p.life <= 0) {
particles.splice(i, 1);
}
}
}

function drawEntities() {
const paddleGradient = ctx.createLinearGradient(
paddle.x, paddle.y,
paddle.x, paddle.y + paddle.height
);
paddleGradient.addColorStop(0, 'rgba(255,255,255,0.3)');
paddleGradient.addColorStop(1, paddle.color);
ctx.shadowBlur = 25;
ctx.shadowColor = paddle.glowColor;
ctx.fillStyle = paddleGradient;
ctx.beginPath();
if (ctx.roundRect) {
ctx.roundRect(paddle.x, paddle.y, paddle.width, paddle.height, 8);
} else {
ctx.rect(paddle.x, paddle.y, paddle.width, paddle.height);
}
ctx.fill();

ctx.shadowBlur = 0;
ctx.fillStyle = 'rgba(255,255,255,0.4)';
ctx.beginPath();
if (ctx.roundRect) {
ctx.roundRect(paddle.x, paddle.y, paddle.width, paddle.height * 0.4, [8, 8, 0, 0]);
} else {
ctx.rect(paddle.x, paddle.y, paddle.width, paddle.height * 0.4);
}
ctx.fill();

for (const entity of entities) {
entity.draw();
}

for (let i = particles.length - 1; i >= 0; i--) {
const p = particles[i];
ctx.globalAlpha = p.life;
ctx.fillStyle = p.color;
ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
}
ctx.globalAlpha = 1;
}

document.getElementById('startBtn').addEventListener('click', startCountdown);
document.getElementById('restartBtn').addEventListener('click', () => {
ui.over.classList.add('hidden');
startCountdown();
});
document.getElementById('exitBtn').addEventListener('click', () => {
ui.over.classList.add('hidden');
ui.start.classList.remove('hidden');
});
canvas.addEventListener('contextmenu', (e) => e.preventDefault());
document.addEventListener('visibilitychange', () => {
if (document.hidden && isPlaying) {
lastTime = performance.now();
}
});
</script>
</body>
</html>
