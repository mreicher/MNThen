<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Bouncer: Progressive Chaos</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #111;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            user-select: none;
        }

        #game-container {
            position: relative;
            max-width: 95vw; 
            max-height: 95vh;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.4);
            border: 2px solid #444;
            background: #000;
        }

        canvas {
            display: block;
            background-color: #000;
            max-width: 100%;
            max-height: 100%;
        }

        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.9);
            z-index: 10;
            text-align: center;
        }

        .hidden { display: none !important; }

        h1 {
            font-size: 2.5rem;
            margin: 0 0 10px 0;
            color: #fff;
            text-shadow: 0 0 15px #0ff;
        }

        button {
            padding: 15px 40px;
            font-size: 1.5rem;
            background: #0ff;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            color: #000;
            font-weight: bold;
            box-shadow: 0 0 15px #0ff;
        }

        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            font-size: 1.1rem;
            z-index: 5;
        }

        .stat-box {
            background: rgba(255, 255, 255, 0.1);
            padding: 5px 12px;
            border-radius: 8px;
            border: 1px solid #333;
        }

        #alert-msg {
            position: absolute;
            top: 30%;
            width: 100%;
            text-align: center;
            color: #ffdd00;
            font-size: 2rem;
            font-weight: bold;
            text-shadow: 0 0 10px #000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        
        <div id="hud" class="hidden">
            <div class="stat-box">Score: <span id="scoreDisplay" style="color:#0ff">0</span></div>
            <div class="stat-box">Lives: <span id="livesDisplay" style="color:#ff0055">3</span></div>
        </div>
        
        <div id="alert-msg">NEW BALL!</div>

        <div id="startScreen" class="overlay">
            <h1>NEON BOUNCER</h1>
            <p>New ball every 10 seconds!<br>Avoid the red spikes!</p>
            <button id="startBtn">START</button>
        </div>

        <div id="gameOverScreen" class="overlay hidden">
            <h1 style="color: #ff0055;">GAME OVER</h1>
            <p>Final Score: <span id="finalScore">0</span></p>
            <button id="restartBtn">TRY AGAIN</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const livesDisplay = document.getElementById('livesDisplay');
        const alertMsg = document.getElementById('alert-msg');

        const GAME_WIDTH = 600;
        const GAME_HEIGHT = 600;
        canvas.width = GAME_WIDTH;
        canvas.height = GAME_HEIGHT;

        let animationId;
        let score = 0;
        let lives = 3;
        let isGameRunning = false;
        let lastTime = 0;
        let multiBallTimer = 0;
        let spikeTimer = 0;
        let currentGravity = 0.15; // Starts slow

        const PADDLE_WIDTH = 110;
        const PADDLE_HEIGHT = 15;
        let paddle = { x: 245, y: 560, width: PADDLE_WIDTH, height: PADDLE_HEIGHT, color: '#fff' };

        let entities = [];

        function handleInput(clientX) {
            const rect = canvas.getBoundingClientRect();
            paddle.x = (clientX - rect.left) * (GAME_WIDTH / rect.width) - paddle.width / 2;
            if (paddle.x < 0) paddle.x = 0;
            if (paddle.x + paddle.width > GAME_WIDTH) paddle.x = GAME_WIDTH - paddle.width;
        }

        document.addEventListener('mousemove', (e) => handleInput(e.clientX));
        document.addEventListener('touchmove', (e) => {
            handleInput(e.touches[0].clientX);
            e.preventDefault();
        }, { passive: false });

        class Entity {
            constructor(type, isInitial = false) {
                this.type = type;
                this.radius = type === 'ball' ? 12 : 15;
                this.x = Math.random() * (GAME_WIDTH - 40) + 20;
                this.y = isInitial ? 100 : -20;
                this.dx = (Math.random() - 0.5) * 4;
                this.dy = 2;
                
                if (this.type === 'ball') {
                    this.isGold = Math.random() > 0.85;
                    this.color = this.isGold ? '#ffdd00' : '#00ffcc';
                    this.points = this.isGold ? 50 : 10;
                } else {
                    this.color = '#ff0055'; // Spikes
                }
            }

            draw() {
                ctx.beginPath();
                if (this.type === 'ball') {
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    if(this.isGold) { ctx.shadowBlur = 10; ctx.shadowColor = "gold"; }
                } else {
                    ctx.moveTo(this.x, this.y - this.radius);
                    ctx.lineTo(this.x - this.radius, this.y + this.radius);
                    ctx.lineTo(this.x + this.radius, this.y + this.radius);
                    ctx.closePath();
                }
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.shadowBlur = 0;
            }

            update() {
                this.dy += currentGravity;
                this.x += this.dx;
                this.y += this.dy;

                if (this.x + this.radius > GAME_WIDTH || this.x - this.radius < 0) this.dx *= -1;

                // Paddle Collision
                if (this.y + this.radius >= paddle.y && this.y - this.radius <= paddle.y + paddle.height &&
                    this.x >= paddle.x && this.x <= paddle.x + paddle.width) {
                    
                    if (this.type === 'ball') {
                        // Math logic: Ensure it bounces to at least Y=300 (middle)
                        // v^2 = u^2 + 2as. We solve for 'u' to reach middle height.
                        let distanceToMiddle = paddle.y - 300;
                        let requiredVelocity = Math.sqrt(2 * currentGravity * distanceToMiddle);
                        this.dy = -requiredVelocity - (Math.random() * 2); // Guaranteed height + randomness
                        
                        score += this.points;
                        scoreDisplay.textContent = score;
                        flashPaddle('#0ff');
                    } else {
                        loseLife("OPE! WATCH THE SPIKES!");
                        return false; 
                    }
                }

                if (this.y - this.radius > GAME_HEIGHT) {
                    if (this.type === 'ball') loseLife("MISSED ONE!");
                    return false;
                }
                return true;
            }
        }

        function flashPaddle(color) {
            paddle.color = color;
            setTimeout(() => paddle.color = '#ffffff', 150);
        }

        function loseLife(msg) {
            lives--;
            livesDisplay.textContent = lives;
            showAlert(msg, "#ff0055");
            if (lives <= 0) endGame();
        }

        function showAlert(text, color) {
            alertMsg.textContent = text;
            alertMsg.style.color = color;
            alertMsg.style.opacity = 1;
            setTimeout(() => alertMsg.style.opacity = 0, 1000);
        }

        function initGame() {
            entities = [new Entity('ball', true)];
            score = 0; lives = 3; multiBallTimer = 0; spikeTimer = 0; currentGravity = 0.15;
            scoreDisplay.textContent = score;
            livesDisplay.textContent = lives;
            isGameRunning = true;
            lastTime = performance.now();
            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('gameOverScreen').classList.add('hidden');
            document.getElementById('hud').classList.remove('hidden');
            animate();
        }

        function endGame() {
            isGameRunning = false;
            cancelAnimationFrame(animationId);
            document.getElementById('finalScore').textContent = score;
            document.getElementById('hud').classList.add('hidden');
            document.getElementById('gameOverScreen').classList.remove('hidden');
        }

        function animate(currentTime) {
            if (!isGameRunning) return;
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;

            ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

            // Draw Middle Line (Visual Guide)
            ctx.strokeStyle = "rgba(255,255,255,0.05)";
            ctx.beginPath(); ctx.moveTo(0, 300); ctx.lineTo(600, 300); ctx.stroke();

            // Progress Timers
            multiBallTimer += deltaTime;
            spikeTimer += deltaTime;
            currentGravity += 0.00005; // Very slow speed increase over time

            if (multiBallTimer >= 10) {
                entities.push(new Entity('ball'));
                showAlert("NEW BALL ADDED!", "#0ff");
                multiBallTimer = 0;
            }

            if (spikeTimer >= 4) { // Spikes drop every 4 seconds
                entities.push(new Entity('spike'));
                spikeTimer = 0;
            }

            ctx.fillStyle = paddle.color;
            ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);

            entities = entities.filter(ent => {
                ent.draw();
                return ent.update();
            });

            animationId = requestAnimationFrame(animate);
        }

        document.getElementById('startBtn').addEventListener('click', initGame);
        document.getElementById('restartBtn').addEventListener('click', initGame);
    </script>
</body>
</html>
