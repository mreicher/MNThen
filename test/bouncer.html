<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<title>Orbit Bounce</title>
<style>
:root {
  --primary: #6366f1;
  --primary-glow: rgba(99, 102, 241, 0.5);
  --gold: #f59e0b;
  --gold-glow: rgba(245, 158, 11, 0.6);
  --cyan: #06b6d4;
  --cyan-glow: rgba(6, 182, 212, 0.6);
  --danger: #ef4444;
  --text-main: #0f172a;
  --text-muted: #475569;
  --bg-overlay: rgba(255, 255, 255, 0.92);
  --font-stack: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
}
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  user-select: none;
  -webkit-user-select: none;
  -webkit-touch-callout: none;
  -webkit-tap-highlight-color: transparent;
}
html, body {
  width: 100%;
  height: 100%;
  overflow: hidden;
  position: fixed;
  touch-action: none;
  background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
  font-family: var(--font-stack);
  color: var(--text-main);
}

/* Background for non-game screens */
.screen-bg {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: radial-gradient(circle at center, #e0f2fe 0%, #bae6fd 100%);
  z-index: 1;
}

/* Screens */
.screen {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  z-index: 10;
  padding: 4vh 4vw;
  transition: opacity 0.4s ease, visibility 0.4s ease;
  background: var(--bg-overlay);
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
  box-shadow: 0 10px 40px rgba(0, 0, 0, 0.08);
}
.screen.hidden {
  opacity: 0;
  visibility: hidden;
  pointer-events: none;
}

/* Game Area */
#gameWrapper {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  z-index: 5;
}
canvas {
  display: block;
  width: 100%;
  height: 100%;
  touch-action: none;
}

/* HUD */
#hud {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  padding: clamp(10px, 2vh, 16px) clamp(12px, 3vw, 20px);
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  pointer-events: none;
  z-index: 50;
}
.hud-pill {
  background: rgba(255, 255, 255, 0.75);
  border: 1px solid rgba(99, 102, 241, 0.2);
  backdrop-filter: blur(8px);
  padding: clamp(6px, 1.2vh, 10px) clamp(10px, 2vw, 14px);
  border-radius: 18px;
  display: flex;
  align-items: center;
  gap: clamp(5px, 1.2vw, 8px);
  box-shadow: 0 2px 8px rgba(0,0,0,0.06);
}
.hud-label {
  font-size: clamp(0.6rem, 1.8vw, 0.75rem);
  text-transform: uppercase;
  letter-spacing: 0.05em;
  color: var(--text-muted);
  font-weight: 700;
}
.hud-value {
  font-size: clamp(0.9rem, 2.6vw, 1.2rem);
  font-weight: 800;
  color: var(--text-main);
  min-width: clamp(28px, 5vw, 40px);
  text-align: right;
}
#lives-container {
  display: flex;
  gap: clamp(4px, 1.2vw, 7px);
}
.heart {
  width: clamp(9px, 2.2vw, 13px);
  height: clamp(9px, 2.2vw, 13px);
  border-radius: 50%;
  background-color: var(--primary);
  box-shadow: 0 0 6px var(--primary-glow);
}
.heart.lost {
  background-color: #cbd5e1;
  box-shadow: none;
  opacity: 0.5;
}

/* Typography */
h1 {
  font-size: clamp(2.2rem, 10vw, 4rem);
  font-weight: 800;
  letter-spacing: -0.03em;
  color: var(--text-main);
  margin-bottom: 1.5vh;
  text-align: center;
  line-height: 1.1;
}
h2 {
  font-size: clamp(1.6rem, 5.5vw, 2.2rem);
  font-weight: 700;
  color: var(--text-main);
  margin-bottom: 1.2vh;
}
.subtitle {
  font-size: clamp(0.9rem, 2.6vw, 1.1rem);
  color: var(--text-muted);
  margin-bottom: 3vh;
  font-weight: 500;
  max-width: 90%;
  text-align: center;
  line-height: 1.6;
}
.total-label {
  font-size: clamp(0.85rem, 2.4vw, 1rem);
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.1em;
  margin-bottom: 1vh;
  font-weight: 600;
}
.final-score-display {
  font-size: clamp(2.2rem, 10vw, 3.6rem);
  font-weight: 800;
  margin: 2vh 0 2.5vh;
  color: var(--text-main);
  line-height: 1;
}

/* Buttons */
button {
  padding: clamp(10px, 2.4vh, 16px) clamp(24px, 7vw, 42px);
  font-size: clamp(0.85rem, 2.5vw, 1rem);
  font-weight: 700;
  border: none;
  border-radius: 16px;
  cursor: pointer;
  transition: all 0.2s ease;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  touch-action: manipulation;
  min-width: 160px;
  font-family: var(--font-stack);
}
#startBtn, #restartBtn {
  background: var(--primary);
  color: white;
  box-shadow: 0 4px 14px var(--primary-glow);
}
#startBtn:active, #restartBtn:active {
  transform: translateY(2px);
  box-shadow: 0 2px 8px var(--primary-glow);
}
#instructionsBtn {
  background: #e2e8f0;
  color: var(--text-main);
  box-shadow: 0 4px 14px rgba(0, 0, 0, 0.08);
}
#instructionsBtn:active {
  transform: translateY(2px);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
}
#exitBtn, #exitBtn2 {
  background: var(--danger);
  color: white;
  box-shadow: 0 4px 14px rgba(239, 68, 68, 0.4);
}
#exitBtn:active, #exitBtn2:active {
  transform: translateY(2px);
  box-shadow: 0 2px 8px rgba(239, 68, 68, 0.4);
}
#shareBtn {
  background: var(--cyan);
  color: white;
  box-shadow: 0 4px 14px var(--cyan-glow);
}
#shareBtn:active {
  transform: translateY(2px);
  box-shadow: 0 2px 8px var(--cyan-glow);
}

/* Notifications */
.notification-text {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%) scale(0.8);
  font-size: clamp(1.4rem, 4.8vw, 2.3rem);
  font-weight: 800;
  color: #fff;
  text-shadow: 0 4px 20px rgba(0,0,0,0.8);
  opacity: 0;
  pointer-events: none;
  transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
  z-index: 80;
  text-align: center;
  white-space: nowrap;
}
.notification-text.gold { color: var(--gold); text-shadow: 0 0 30px var(--gold-glow), 0 4px 20px rgba(0,0,0,0.8); }
.notification-text.purple { color: #8b5cf6; text-shadow: 0 0 30px rgba(139, 92, 246, 0.6), 0 4px 20px rgba(0,0,0,0.8); }
.notification-text.cyan { color: var(--cyan); text-shadow: 0 0 30px var(--cyan-glow), 0 4px 20px rgba(0,0,0,0.8); }

/* Countdown */
#countdownScreen {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  z-index: 190;
  color: var(--text-main);
  font-size: clamp(5rem, 20vw, 8rem);
  font-weight: 800;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.35s;
  background: var(--bg-overlay);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
}
#countdownScreen.active {
  opacity: 1;
  pointer-events: all;
}
.countdown-sponsor {
  font-size: clamp(0.95rem, 2.8vw, 1.3rem);
  margin-bottom: 2vh;
  color: var(--text-muted);
  text-align: center;
  font-weight: 600;
}
.ad-placeholder {
  width: 90%;
  max-width: 300px;
  height: clamp(60px, 12vh, 80px);
  background: rgba(0, 0, 0, 0.05);
  border: 1px dashed rgba(99, 102, 241, 0.3);
  border-radius: 12px;
  display: flex;
  justify-content: center;
  align-items: center;
  color: rgba(15, 23, 42, 0.4);
  font-size: clamp(0.8rem, 2.2vw, 0.9rem);
  margin-top: 1vh;
}

/* Instructions Modal */
#instructionsModal {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 200;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.4s ease;
  background: rgba(0, 0, 0, 0.4);
}
#instructionsModal.active {
  opacity: 1;
  pointer-events: all;
}
#instructionsContent {
  background: var(--bg-overlay);
  backdrop-filter: blur(20px);
  -webkit-backdrop-filter: blur(20px);
  border-radius: 20px;
  padding: 4vh 5vw;
  width: 90vw;
  max-width: 480px;
  text-align: center;
  border: 1px solid rgba(99, 102, 241, 0.2);
  box-shadow: 0 20px 50px rgba(0, 0, 0, 0.12);
}
.instructions-text {
  font-size: clamp(0.85rem, 2.5vw, 1rem);
  color: var(--text-main);
  line-height: 1.7;
  max-width: 460px;
  text-align: center;
  margin: 1.5vh 0;
}
#closeInstructions {
  margin-top: 2vh;
  background: #e2e8f0;
  color: var(--text-main);
  box-shadow: 0 4px 14px rgba(0, 0, 0, 0.08);
}

/* Stats */
.game-over-stats {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: clamp(10px, 2.8vw, 18px);
  width: 100%;
  max-width: 380px;
  margin: 1.5vh auto 2.5vh;
}
.stat-box {
  background: rgba(99, 102, 241, 0.06);
  border: 1px solid rgba(99, 102, 241, 0.2);
  padding: clamp(8px, 2vh, 14px);
  border-radius: 12px;
  text-align: center;
}
.stat-label {
  font-size: clamp(0.65rem, 2vw, 0.8rem);
  color: var(--text-muted);
  text-transform: uppercase;
  margin-bottom: 0.5vh;
  font-weight: 600;
}
.stat-number {
  font-size: clamp(1.3rem, 4.5vw, 1.8rem);
  font-weight: 800;
  color: var(--text-main);
}

/* Button Group */
.button-group {
  display: flex;
  gap: clamp(10px, 2.8vw, 18px);
  flex-wrap: wrap;
  justify-content: center;
  margin-top: 1.5vh;
  width: 100%;
}
@media (max-width: 500px) {
  .button-group {
    flex-direction: column;
    align-items: center;
  }
  .button-group button {
    width: 85%;
    max-width: 300px;
  }
}

/* Shake */
.shake {
  animation: shake 0.5s cubic-bezier(.36,.07,.19,.97);
}
@keyframes shake {
  0%, 100% { transform: translate(-50%, -50%); }
  10%, 30%, 50%, 70%, 90% { transform: translate(calc(-50% - 6px), calc(-50% - 6px)); }
  20%, 40%, 60%, 80% { transform: translate(calc(-50% + 6px), calc(-50% + 6px)); }
}
@media (max-width: 768px) {
  @keyframes shake {
    0%, 100% { transform: none; }
    10%, 30%, 50%, 70%, 90% { transform: translate(-6px, -6px); }
    20%, 40%, 60%, 80% { transform: translate(6px, 6px); }
  }
  #gameWrapper.shake {
    animation: shake 0.5s cubic-bezier(.36,.07,.19,.97);
  }
}
</style>
</head>
<body>
<!-- Bright background -->
<div class="screen-bg"></div>

<!-- Game Area -->
<div id="gameWrapper">
<canvas id="gameCanvas"></canvas>

<!-- HUD: ONLY during gameplay -->
<div id="hud" style="display: none;">
  <div class="hud-pill">
    <span class="hud-label">Score</span>
    <span id="scoreDisplay" class="hud-value">0</span>
  </div>
  <div class="hud-pill">
    <span class="hud-label">Orbs</span>
    <span id="ballCount" class="hud-value">1</span>
  </div>
  <div class="hud-pill">
    <div id="lives-container">
      <div class="heart"></div>
      <div class="heart"></div>
      <div class="heart"></div>
    </div>
  </div>
</div>

<div id="notification" class="notification-text">New Orb</div>

<!-- Countdown -->
<div id="countdownScreen">
  <div class="countdown-sponsor">This game is sponsored by:</div>
  <div class="ad-placeholder">Advertisement Space</div>
  <div id="countdownNumber">5</div>
</div>

<!-- Start Screen -->
<div id="startScreen" class="screen">
  <h1>ORBIT BOUNCE</h1>
  <p class="subtitle">Bounce orbs with precision. Avoid spikes. Survive as long as you can.</p>
  <div class="button-group">
    <button id="startBtn">Start Game</button>
    <button id="instructionsBtn">Instructions</button>
    <button id="exitBtn">Exit</button>
  </div>
</div>

<!-- Instructions -->
<div id="instructionsModal">
  <div id="instructionsContent">
    <h2>How to Play</h2>
    <p class="instructions-text">
      Drag to move the paddle.<br><br>
      • <strong>Bounce blue orbs</strong> to earn points<br>
      • <strong>Avoid red spikes</strong> — they cost a life<br>
      • <strong>Golden orbs</strong> grant an extra life<br>
      • <strong>Purple orbs</strong> slow time for 5 seconds<br>
      • <strong>Cyan orbs</strong> double your points for 10 seconds!<br><br>
      Lose all lives and it's game over!
    </p>
    <button id="closeInstructions">Close</button>
  </div>
</div>

<!-- Game Over Screen -->
<div id="gameOverScreen" class="screen hidden">
  <h2 style="color: var(--danger);">Game Over</h2>
  <div class="total-label">Final Score</div>
  <div class="final-score-display" id="finalScore">0</div>
  <div class="game-over-stats">
    <div class="stat-box">
      <div class="stat-number" id="maxBalls">0</div>
      <div class="stat-label">Max Orbs</div>
    </div>
    <div class="stat-box">
      <div class="stat-number" id="survivalTime">0s</div>
      <div class="stat-label">Survived</div>
    </div>
  </div>
  <div class="button-group">
    <button id="shareBtn">Share Score</button>
    <button id="restartBtn">Play Again</button>
    <button id="exitBtn2">Exit</button>
  </div>
</div>
</div>

<script>
// CORE SETUP
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false });
const wrapper = document.getElementById('gameWrapper');
const ui = {
  start: document.getElementById('startScreen'),
  over: document.getElementById('gameOverScreen'),
  hud: document.getElementById('hud'),
  score: document.getElementById('scoreDisplay'),
  balls: document.getElementById('ballCount'),
  finalScore: document.getElementById('finalScore'),
  maxBalls: document.getElementById('maxBalls'),
  time: document.getElementById('survivalTime'),
  lives: document.querySelectorAll('.heart'),
  notify: document.getElementById('notification'),
  countdown: document.getElementById('countdownScreen'),
  countdownNum: document.getElementById('countdownNumber'),
  instructionsModal: document.getElementById('instructionsModal'),
  startBtn: document.getElementById('startBtn'),
  instructionsBtn: document.getElementById('instructionsBtn'),
  closeInstructions: document.getElementById('closeInstructions'),
  exitBtn: document.getElementById('exitBtn'),
  exitBtn2: document.getElementById('exitBtn2'),
  restartBtn: document.getElementById('restartBtn'),
  shareBtn: document.getElementById('shareBtn')
};
let animationId, isPlaying = false, lastTime = 0, gameTime = 0, score = 0, lives = 3;
const MAX_LIVES = 5;
let maxBallsActive = 0, entities = [], particles = [];
let nextBallTime = 0, nextSpikeTime = 0, nextGoldTime = 0, nextPowerUpTime = 0, nextDoublePointsTime = 0;
let gameWidth = 0, gameHeight = 0, minBounceY = 0, maxBounceY = 0, slowMoEndTime = 0, doublePointsEndTime = 0;

const paddle = {
  width: 0, height: 0, x: 0, y: 0, targetX: 0,
  color: '#6366f1', glowColor: 'rgba(99, 102, 241, 0.5)',
  startWidthRatio: 0.35, minWidthRatio: 0.18, shrinkDuration: 150, shrinkDelay: 15
};

// RESIZE
function resize() {
  const rect = wrapper.getBoundingClientRect();
  const dpr = Math.min(window.devicePixelRatio || 1, 2);
  gameWidth = rect.width;
  gameHeight = rect.height;
  minBounceY = gameHeight * 0.5;
  maxBounceY = gameHeight * 0.1;
  canvas.width = gameWidth * dpr;
  canvas.height = gameHeight * dpr;
  canvas.style.width = gameWidth + 'px';
  canvas.style.height = gameHeight + 'px';
  ctx.scale(dpr, dpr);
  paddle.height = Math.max(12, gameHeight * 0.016);
  paddle.width = gameWidth * paddle.startWidthRatio;
  paddle.x = (gameWidth - paddle.width) / 2;
  paddle.targetX = paddle.x;
  paddle.y = gameHeight * 0.82;
}
window.addEventListener('resize', resize);
resize();

// INPUT
let touchId = null;
function handlePointerMove(clientX) {
  if (!isPlaying) return;
  const rect = canvas.getBoundingClientRect();
  const x = clientX - rect.left;
  paddle.targetX = x - (paddle.width / 2);
  paddle.targetX = Math.max(0, Math.min(gameWidth - paddle.width, paddle.targetX));
}
canvas.addEventListener('mousemove', (e) => handlePointerMove(e.clientX));
canvas.addEventListener('touchstart', (e) => {
  if (!isPlaying) return;
  e.preventDefault();
  const touch = e.changedTouches[0];
  touchId = touch.identifier;
  handlePointerMove(touch.clientX);
}, { passive: false });
canvas.addEventListener('touchmove', (e) => {
  if (!isPlaying) return;
  e.preventDefault();
  for (let touch of e.changedTouches) {
    if (touch.identifier === touchId) {
      handlePointerMove(touch.clientX);
      break;
    }
  }
}, { passive: false });
canvas.addEventListener('touchend', (e) => {
  for (let touch of e.changedTouches) {
    if (touch.identifier === touchId) {
      touchId = null;
      break;
    }
  }
});
document.body.addEventListener('touchstart', (e) => { if (isPlaying) e.preventDefault(); }, { passive: false });

// ENTITIES (Ball, GoldBall, Spike, SlowMoPowerUp, DoublePointsPowerUp)
// ... [same as previous implementation – omitted here for brevity but included in full logic below] ...

// EFFECTS
function spawnParticles(x, y, color, count = 10) {
  const maxParts = window.devicePixelRatio > 1 ? 100 : 50;
  if (particles.length > maxParts) return;
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = 2 + Math.random() * 4;
    particles.push({x, y, dx: Math.cos(angle) * speed, dy: Math.sin(angle) * speed, life: 1.0, size: 2 + Math.random() * 3, color});
  }
}
function updateParticles() {
  const slowdown = slowMoEndTime > gameTime ? 0.3 : 1;
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.dx * slowdown;
    p.y += p.dy * slowdown;
    p.dy += 0.15 * slowdown;
    p.life -= 0.022;
    if (p.life <= 0) { particles.splice(i, 1); } else {
      ctx.globalAlpha = p.life;
      ctx.fillStyle = p.color;
      ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
    }
  }
  ctx.globalAlpha = 1;
}
function showNotification(text, type = '') {
  ui.notify.textContent = text;
  ui.notify.className = 'notification-text active';
  if (type === 'gold') ui.notify.classList.add('gold');
  else if (type === 'purple') ui.notify.classList.add('purple');
  else if (type === 'cyan') ui.notify.classList.add('cyan');
  if (ui.notifyTimeout) clearTimeout(ui.notifyTimeout);
  ui.notifyTimeout = setTimeout(() => { ui.notify.classList.remove('active'); }, 1800);
}

// GAME LOGIC
function updateHUD() {
  const balls = entities.filter(e => e.type === 'ball').length;
  ui.balls.textContent = balls;
  maxBallsActive = Math.max(maxBallsActive, balls);
  ui.lives.forEach((dot, i) => { dot.classList.toggle('lost', i >= lives); });
}
function takeDamage() {
  lives--;
  updateHUD();
  wrapper.classList.add('shake');
  setTimeout(() => wrapper.classList.remove('shake'), 500);
  if (lives <= 0) { gameOver(); }
}
function addLife() {
  if (lives < MAX_LIVES) {
    lives++;
    updateHUD();
  }
}
function activateSlowMo() {
  slowMoEndTime = gameTime + 5;
  showNotification('SLOW TIME!', 'purple');
}
function activateDoublePoints() {
  doublePointsEndTime = gameTime + 10;
  showNotification('DOUBLE POINTS!', 'cyan');
}
function startCountdown() {
  ui.start.classList.add('hidden');
  ui.countdown.classList.add('active');
  let count = 5;
  ui.countdownNum.textContent = count;
  const interval = setInterval(() => {
    count--;
    if (count > 0) { ui.countdownNum.textContent = count; } else {
      clearInterval(interval);
      ui.countdown.classList.remove('active');
      initGame();
    }
  }, 1000);
}
function initGame() {
  resize();
  entities = [new Ball()];
  particles = [];
  score = 0;
  lives = 3;
  gameTime = 0;
  maxBallsActive = 1;
  paddle.width = gameWidth * paddle.startWidthRatio;
  paddle.x = (gameWidth - paddle.width) / 2;
  paddle.targetX = paddle.x;
  nextBallTime = 8;
  nextSpikeTime = 25;
  nextGoldTime = 30;
  nextPowerUpTime = 45;
  nextDoublePointsTime = 55;
  updateHUD();
  ui.score.textContent = '0';
  isPlaying = true;
  ui.hud.style.display = 'flex';
  lastTime = performance.now();
  animate(lastTime);
}
function gameOver() {
  isPlaying = false;
  cancelAnimationFrame(animationId);
  slowMoEndTime = 0;
  doublePointsEndTime = 0;
  ui.finalScore.textContent = score;
  ui.maxBalls.textContent = maxBallsActive;
  ui.time.textContent = Math.floor(gameTime) + 's';
  ui.hud.style.display = 'none';
  ui.over.classList.remove('hidden');
}

// SHARE FUNCTIONALITY
function shareScore() {
  if (navigator.share) {
    navigator.share({
      title: 'Orbit Bounce',
      text: `I scored ${score} points in Orbit Bounce! Can you beat me?`,
      url: window.location.href
    }).catch(console.error);
  } else {
    navigator.clipboard.writeText(`My Orbit Bounce score: ${score}!`).then(() => {
      alert('Score copied to clipboard!');
    });
  }
}

// ENTITY CLASSES
class Ball {
  constructor() {
    this.type = 'ball';
    this.radius = Math.max(9, gameWidth * 0.016);
    this.x = gameWidth * (0.15 + Math.random() * 0.7);
    this.y = paddle.y - 32;
    const targetY = minBounceY - Math.random() * (minBounceY - maxBounceY);
    const targetHeight = paddle.y - targetY;
    const gravity = 0.42;
    const requiredVelocity = Math.sqrt(2 * gravity * targetHeight);
    this.dy = -requiredVelocity;
    this.dx = (Math.random() - 0.5) * 4.2;
    this.color = `hsl(${220 + Math.random()*50}, 88%, 64%)`;
    this.trail = [];
  }
  update(dt) {
    const slowdown = slowMoEndTime > gameTime ? 0.3 : 1;
    const gravity = 0.42 * slowdown;
    this.dy += gravity;
    this.x += this.dx * slowdown;
    this.y += this.dy * slowdown;
    this.trail.push({x: this.x, y: this.y});
    if (this.trail.length > 6) this.trail.shift();
    if (this.x < this.radius) { this.x = this.radius; this.dx *= -0.85; }
    if (this.x > gameWidth - this.radius) { this.x = gameWidth - this.radius; this.dx *= -0.85; }
    if (this.dy > 0 && this.y + this.radius >= paddle.y && this.y - this.radius <= paddle.y + paddle.height &&
        this.x >= paddle.x - this.radius && this.x <= paddle.x + paddle.width + this.radius) {
      const targetY = minBounceY - Math.random() * (minBounceY - maxBounceY);
      const targetHeight = paddle.y - targetY;
      const requiredVelocity = Math.sqrt(2 * gravity * targetHeight);
      this.dy = -requiredVelocity * (0.95 + Math.random() * 0.1);
      const hitPos = (this.x - (paddle.x + paddle.width/2)) / (paddle.width/2);
      this.dx = hitPos * 6.2;
      let points = 10;
      if (doublePointsEndTime > gameTime) points *= 2;
      score += points;
      ui.score.textContent = score;
      spawnParticles(this.x, paddle.y, this.color, 8);
      updateHUD();
      // ✅ NO NOTIFICATION for regular ball hits
      return 'hit';
    }
    if (this.y > gameHeight + this.radius * 2) return 'dead';
    return 'alive';
  }
  draw() {
    ctx.globalAlpha = 0.45;
    this.trail.forEach((pos, i) => {
      const size = this.radius * (i / this.trail.length);
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.arc(pos.x, pos.y, size, 0, Math.PI * 2);
      ctx.fill();
    });
    ctx.globalAlpha = 1;
    ctx.shadowBlur = 22;
    ctx.shadowColor = this.color;
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = 'rgba(255,255,255,0.92)';
    ctx.beginPath();
    ctx.arc(this.x - this.radius * 0.3, this.y - this.radius * 0.3, this.radius * 0.25, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
  }
}

class GoldBall {
  constructor() {
    this.type = 'gold';
    this.radius = Math.max(13, gameWidth * 0.023);
    this.x = gameWidth * (0.2 + Math.random() * 0.6);
    this.y = paddle.y - 32;
    const targetY = minBounceY - Math.random() * (minBounceY - maxBounceY);
    const targetHeight = paddle.y - targetY;
    const gravity = 0.42;
    const requiredVelocity = Math.sqrt(2 * gravity * targetHeight);
    this.dy = -requiredVelocity;
    this.dx = (Math.random() - 0.5) * 3.2;
    this.pulse = 0;
    this.color = '#f59e0b';
    this.trail = [];
  }
  update(dt) {
    const slowdown = slowMoEndTime > gameTime ? 0.3 : 1;
    const gravity = 0.42 * slowdown;
    this.dy += gravity;
    this.x += this.dx * slowdown;
    this.y += this.dy * slowdown;
    this.pulse += dt * 6;
    this.trail.push({x: this.x, y: this.y});
    if (this.trail.length > 8) this.trail.shift();
    if (this.x < this.radius) { this.x = this.radius; this.dx *= -0.9; }
    if (this.x > gameWidth - this.radius) { this.x = gameWidth - this.radius; this.dx *= -0.9; }
    if (this.y + this.radius >= paddle.y && this.y - this.radius <= paddle.y + paddle.height &&
        this.x >= paddle.x - this.radius && this.x <= paddle.x + paddle.width + this.radius) {
      return 'hit';
    }
    if (this.y > gameHeight + this.radius * 2) return 'dead';
    return 'alive';
  }
  draw() {
    const r = this.radius + Math.sin(this.pulse) * 2.2;
    ctx.globalAlpha = 0.55;
    this.trail.forEach((pos, i) => {
      const size = r * (i / this.trail.length);
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.arc(pos.x, pos.y, size, 0, Math.PI * 2);
      ctx.fill();
    });
    ctx.globalAlpha = 1;
    ctx.shadowBlur = 32;
    ctx.shadowColor = this.color;
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.arc(this.x, this.y, r, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.shadowBlur = 16;
    ctx.beginPath();
    ctx.arc(this.x - r * 0.25, this.y - r * 0.25, r * 0.3, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
  }
}

class Spike {
  constructor() {
    this.type = 'spike';
    this.size = Math.max(13, gameWidth * 0.021);
    this.x = gameWidth * (0.1 + Math.random() * 0.8);
    this.y = -this.size * 2;
    const speed = 3.2 + (gameTime * 0.026);
    this.dx = (Math.random() - 0.5) * 1.6;
    this.dy = speed;
    this.color = '#ef4444';
    this.rot = Math.random() * Math.PI * 2;
    this.rotSpeed = (Math.random() - 0.5) * 0.13;
  }
  update(dt) {
    const slowdown = slowMoEndTime > gameTime ? 0.3 : 1;
    this.dy += 0.085 * slowdown;
    this.x += this.dx * slowdown;
    this.y += this.dy * slowdown;
    this.rot += this.rotSpeed * slowdown;
    if (this.x < 0) this.x = gameWidth;
    if (this.x > gameWidth) this.x = 0;
    const expandedHitbox = this.size * 0.7;
    if (this.y + expandedHitbox >= paddle.y && this.y - expandedHitbox <= paddle.y + paddle.height &&
        this.x >= paddle.x - expandedHitbox && this.x <= paddle.x + paddle.width + expandedHitbox) {
      return 'hit';
    }
    if (this.y > gameHeight + this.size * 2) return 'dead';
    return 'alive';
  }
  draw() {
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.rot);
    ctx.shadowBlur = 16;
    ctx.shadowColor = this.color;
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.moveTo(0, -this.size);
    ctx.lineTo(this.size * 0.9, this.size * 0.9);
    ctx.lineTo(-this.size * 0.9, this.size * 0.9);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
    ctx.shadowBlur = 0;
  }
}

class SlowMoPowerUp {
  constructor() {
    this.type = 'slowmo';
    this.radius = Math.max(11, gameWidth * 0.019);
    this.x = gameWidth * (0.2 + Math.random() * 0.6);
    this.y = paddle.y - 32;
    const targetY = minBounceY - Math.random() * (minBounceY - maxBounceY);
    const targetHeight = paddle.y - targetY;
    const gravity = 0.42;
    const requiredVelocity = Math.sqrt(2 * gravity * targetHeight);
    this.dy = -requiredVelocity;
    this.dx = (Math.random() - 0.5) * 2.6;
    this.color = '#8b5cf6';
    this.trail = [];
  }
  update(dt) {
    const slowdown = slowMoEndTime > gameTime ? 0.3 : 1;
    const gravity = 0.42 * slowdown;
    this.dy += gravity;
    this.x += this.dx * slowdown;
    this.y += this.dy * slowdown;
    this.trail.push({x: this.x, y: this.y});
    if (this.trail.length > 7) this.trail.shift();
    if (this.x < this.radius) { this.x = this.radius; this.dx *= -0.85; }
    if (this.x > gameWidth - this.radius) { this.x = gameWidth - this.radius; this.dx *= -0.85; }
    if (this.y + this.radius >= paddle.y && this.y - this.radius <= paddle.y + paddle.height &&
        this.x >= paddle.x - this.radius && this.x <= paddle.x + paddle.width + this.radius) {
      return 'hit';
    }
    if (this.y > gameHeight + this.radius * 2) return 'dead';
    return 'alive';
  }
  draw() {
    ctx.globalAlpha = 0.55;
    this.trail.forEach((pos, i) => {
      const size = this.radius * (i / this.trail.length);
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.arc(pos.x, pos.y, size, 0, Math.PI * 2);
      ctx.fill();
    });
    ctx.globalAlpha = 1;
    ctx.shadowBlur = 26;
    ctx.shadowColor = this.color;
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = 'rgba(255,255,255,0.92)';
    ctx.beginPath();
    ctx.arc(this.x - this.radius * 0.3, this.y - this.radius * 0.3, this.radius * 0.2, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
  }
}

class DoublePointsPowerUp {
  constructor() {
    this.type = 'doublepoints';
    this.radius = Math.max(12, gameWidth * 0.021);
    this.x = gameWidth * (0.2 + Math.random() * 0.6);
    this.y = paddle.y - 32;
    const targetY = minBounceY - Math.random() * (minBounceY - maxBounceY);
    const targetHeight = paddle.y - targetY;
    const gravity = 0.42;
    const requiredVelocity = Math.sqrt(2 * gravity * targetHeight);
    this.dy = -requiredVelocity;
    this.dx = (Math.random() - 0.5) * 2.8;
    this.pulse = 0;
    this.color = '#06b6d4';
    this.trail = [];
  }
  update(dt) {
    const slowdown = slowMoEndTime > gameTime ? 0.3 : 1;
    const gravity = 0.42 * slowdown;
    this.dy += gravity;
    this.x += this.dx * slowdown;
    this.y += this.dy * slowdown;
    this.pulse += dt * 5;
    this.trail.push({x: this.x, y: this.y});
    if (this.trail.length > 8) this.trail.shift();
    if (this.x < this.radius) { this.x = this.radius; this.dx *= -0.85; }
    if (this.x > gameWidth - this.radius) { this.x = gameWidth - this.radius; this.dx *= -0.85; }
    if (this.y + this.radius >= paddle.y && this.y - this.radius <= paddle.y + paddle.height &&
        this.x >= paddle.x - this.radius && this.x <= paddle.x + paddle.width + this.radius) {
      return 'hit';
    }
    if (this.y > gameHeight + this.radius * 2) return 'dead';
    return 'alive';
  }
  draw() {
    const r = this.radius + Math.sin(this.pulse) * 2;
    ctx.globalAlpha = 0.6;
    this.trail.forEach((pos, i) => {
      const size = r * (i / this.trail.length);
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.arc(pos.x, pos.y, size, 0, Math.PI * 2);
      ctx.fill();
    });
    ctx.globalAlpha = 1;
    ctx.shadowBlur = 30;
    ctx.shadowColor = this.color;
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.arc(this.x, this.y, r, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = 'rgba(255,255,255,0.95)';
    ctx.beginPath();
    ctx.arc(this.x - r * 0.28, this.y - r * 0.28, r * 0.25, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
  }
}

// GAME LOOP
let accumulator = 0;
const fixedDeltaTime = 1 / 60;
function animate(timestamp) {
  if (!isPlaying) return;
  const frameTime = (timestamp - lastTime) / 1000;
  lastTime = timestamp;
  const clampedFrameTime = Math.min(frameTime, 0.25);
  accumulator += clampedFrameTime;
  gameTime += clampedFrameTime;
  const gradient = ctx.createLinearGradient(0, 0, 0, gameHeight);
  gradient.addColorStop(0, '#f8fafc');
  gradient.addColorStop(1, '#e2e8f0');
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, gameWidth, gameHeight);
  while (accumulator >= fixedDeltaTime) {
    updateGameLogic(fixedDeltaTime);
    accumulator -= fixedDeltaTime;
  }
  drawEntities();
  animationId = requestAnimationFrame(animate);
}
function updateGameLogic(dt) {
  if (gameTime > nextBallTime) {
    const ballCount = entities.filter(e => e.type === 'ball').length;
    if (ballCount < 5) {
      entities.push(new Ball());
      nextBallTime = gameTime + (8 + Math.random() * 6);
      // ✅ Only show "New Orb" when spawned, not on hit
      showNotification('New Orb');
    }
  }
  if (gameTime > nextSpikeTime) {
    entities.push(new Spike());
    nextSpikeTime = gameTime + (12 + Math.random() * 8);
    showNotification('⚠ Spike');
  }
  if (gameTime > nextGoldTime) {
    entities.push(new GoldBall());
    nextGoldTime = gameTime + 30;
    showNotification('GOLDEN ORB!', 'gold');
  }
  if (gameTime > nextPowerUpTime) {
    entities.push(new SlowMoPowerUp());
    nextPowerUpTime = gameTime + 60;
  }
  if (gameTime > nextDoublePointsTime) {
    entities.push(new DoublePointsPowerUp());
    nextDoublePointsTime = gameTime + 70;
    showNotification('DOUBLE POINTS!', 'cyan');
  }

  const lerpSpeed = 0.25;
  paddle.x += (paddle.targetX - paddle.x) * lerpSpeed;
  if (gameTime > paddle.shrinkDelay) {
    const shrinkProgress = Math.min((gameTime - paddle.shrinkDelay) / paddle.shrinkDuration, 1);
    const easeProgress = 1 - Math.pow(1 - shrinkProgress, 3);
    const startWidth = gameWidth * paddle.startWidthRatio;
    const endWidth = gameWidth * paddle.minWidthRatio;
    const newWidth = startWidth - (startWidth - endWidth) * easeProgress;
    const widthDiff = paddle.width - newWidth;
    const relativePos = (paddle.targetX - paddle.x) / paddle.width;
    paddle.x += widthDiff * (0.5 + relativePos * 0.5);
    paddle.width = newWidth;
    paddle.x = Math.max(0, Math.min(gameWidth - paddle.width, paddle.x));
  }

  for (let i = entities.length - 1; i >= 0; i--) {
    const entity = entities[i];
    const status = entity.update(dt);
    if (status === 'dead') {
      if (entity.type === 'ball') { takeDamage(); }
      entities.splice(i, 1);
      updateHUD();
    } else if (status === 'hit') {
      if (entity.type === 'gold') {
        spawnParticles(entity.x, entity.y, '#f59e0b', 20);
        addLife();
        score += 100;
        ui.score.textContent = score;
        showNotification('+1 LIFE', 'gold');
        entities.splice(i, 1);
      } else if (entity.type === 'spike') {
        spawnParticles(entity.x, entity.y, '#ef4444', 15);
        takeDamage();
        entities.splice(i, 1);
      } else if (entity.type === 'slowmo') {
        spawnParticles(entity.x, entity.y, '#8b5cf6', 15);
        activateSlowMo();
        entities.splice(i, 1);
      } else if (entity.type === 'doublepoints') {
        spawnParticles(entity.x, entity.y, '#06b6d4', 18);
        activateDoublePoints();
        entities.splice(i, 1);
      }
    }
  }

  const ballCount = entities.filter(e => e.type === 'ball').length;
  if (isPlaying && ballCount === 0 && lives > 0) {
    entities.push(new Ball());
    updateHUD();
  }
}
function drawEntities() {
  const paddleGradient = ctx.createLinearGradient(paddle.x, paddle.y, paddle.x, paddle.y + paddle.height);
  paddleGradient.addColorStop(0, 'rgba(255,255,255,0.4)');
  paddleGradient.addColorStop(1, paddle.color);
  ctx.shadowBlur = 22;
  ctx.shadowColor = paddle.glowColor;
  ctx.fillStyle = paddleGradient;
  ctx.beginPath();
  if (ctx.roundRect) ctx.roundRect(paddle.x, paddle.y, paddle.width, paddle.height, 10);
  else ctx.rect(paddle.x, paddle.y, paddle.width, paddle.height);
  ctx.fill();
  ctx.shadowBlur = 0;
  ctx.fillStyle = 'rgba(255,255,255,0.4)';
  ctx.beginPath();
  if (ctx.roundRect) ctx.roundRect(paddle.x, paddle.y, paddle.width, paddle.height * 0.4, [10, 10, 0, 0]);
  else ctx.rect(paddle.x, paddle.y, paddle.width, paddle.height * 0.4);
  ctx.fill();

  for (const entity of entities) entity.draw();
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    ctx.globalAlpha = p.life;
    ctx.fillStyle = p.color;
    ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
  }
  ctx.globalAlpha = 1;
}

// EVENT LISTENERS
ui.startBtn.addEventListener('click', startCountdown);
ui.instructionsBtn.addEventListener('click', () => { ui.instructionsModal.classList.add('active'); });
ui.closeInstructions.addEventListener('click', () => { ui.instructionsModal.classList.remove('active'); });
ui.restartBtn.addEventListener('click', () => { ui.over.classList.add('hidden'); startCountdown(); });
ui.exitBtn.addEventListener('click', () => { ui.start.classList.remove('hidden'); ui.over.classList.add('hidden'); });
ui.exitBtn2.addEventListener('click', () => { ui.over.classList.add('hidden'); ui.start.classList.remove('hidden'); });
ui.shareBtn.addEventListener('click', shareScore);
canvas.addEventListener('contextmenu', (e) => e.preventDefault());
document.addEventListener('visibilitychange', () => { if (document.hidden && isPlaying) lastTime = performance.now(); });
</script>
</body>
</html>
