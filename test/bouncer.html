<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<title>Orbit Bounce</title>
<style>
:root {
--primary: #4f46e5;
--primary-glow: rgba(79, 70, 229, 0.6);
--gold: #f59e0b;
--gold-glow: rgba(245, 158, 11, 0.7);
--danger: #dc2626;
--text-main: #ffffff;
--text-muted: #cbd5e1;
--bg-overlay: rgba(15, 23, 42, 0.88);
--font-stack: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
}
* {
margin: 0;
padding: 0;
box-sizing: border-box;
user-select: none;
-webkit-user-select: none;
-webkit-touch-callout: none;
-webkit-tap-highlight-color: transparent;
}
html, body {
width: 100%;
height: 100%;
overflow: hidden;
position: fixed;
touch-action: none;
background: #0f172a;
}
body {
color: var(--text-main);
font-family: var(--font-stack);
}

/* Background for non-game screens */
.screen-bg {
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
background-image: url('https://images.unsplash.com/photo-1506260408121-e353d10b87c7?ixlib=rb-4.0.3&auto=format&fit=crop&w=2000&q=80');
background-size: cover;
background-position: center;
z-index: 1;
}
.screen-overlay {
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
background: rgba(0, 0, 0, 0.5);
z-index: 2;
}

/* Screens: Start, Game Over */
.screen {
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
display: flex;
flex-direction: column;
justify-content: center;
align-items: center;
z-index: 10;
padding: 6vh 6vw;
transition: opacity 0.4s ease, visibility 0.4s ease;
border-radius: 24px;
background: var(--bg-overlay);
backdrop-filter: blur(20px);
-webkit-backdrop-filter: blur(20px);
}
.screen.hidden {
opacity: 0;
visibility: hidden;
pointer-events: none;
}
@media (max-width: 768px) {
.screen {
border-radius: 0;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
width: 92vw;
max-width: 520px;
min-height: 420px;
box-shadow: 0 25px 60px rgba(0, 0, 0, 0.8);
}
}

/* Game Wrapper - No background */
#gameWrapper {
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
width: 92vw;
height: 86vh;
max-width: 620px;
max-height: 920px;
display: flex;
flex-direction: column;
border-radius: 24px;
overflow: hidden;
box-shadow: 0 35px 90px rgba(0, 0, 0, 0.7);
background: #0f172a;
z-index: 5;
}
@media (max-width: 768px) {
#gameWrapper {
position: fixed;
top: 0;
left: 0;
transform: none;
width: 100vw;
height: 100vh;
max-width: none;
max-height: none;
border-radius: 0;
box-shadow: none;
background: #0f172a;
}
}

canvas {
display: block;
width: 100%;
height: 100%;
touch-action: none;
}

/* HUD - ONLY during gameplay */
#hud {
position: absolute;
top: 0;
left: 0;
right: 0;
padding: clamp(14px, 2.2vh, 22px) clamp(14px, 3.2vw, 26px);
display: flex;
justify-content: space-between;
align-items: flex-start;
pointer-events: none;
z-index: 50;
}
.hud-pill {
background: rgba(20, 25, 50, 0.75);
border: 1px solid rgba(255,255,255,0.18);
backdrop-filter: blur(14px);
-webkit-backdrop-filter: blur(14px);
padding: clamp(9px, 1.7vh, 13px) clamp(14px, 2.7vw, 18px);
border-radius: 22px;
display: flex;
align-items: center;
gap: clamp(7px, 1.7vw, 11px);
box-shadow: 0 5px 18px rgba(0,0,0,0.35);
}
.hud-label {
font-size: clamp(0.7rem, 2.2vw, 0.85rem);
text-transform: uppercase;
letter-spacing: 0.06em;
color: var(--text-muted);
font-weight: 800;
}
.hud-value {
font-size: clamp(1.1rem, 3.3vw, 1.5rem);
font-weight: 900;
color: var(--text-main);
min-width: clamp(34px, 6.5vw, 50px);
text-align: right;
}
#lives-container {
display: flex;
gap: clamp(6px, 1.7vw, 9px);
}
.heart {
width: clamp(11px, 2.7vw, 15px);
height: clamp(11px, 2.7vw, 15px);
border-radius: 50%;
background-color: var(--primary);
box-shadow: 0 0 14px var(--primary-glow);
}
.heart.lost {
background-color: #475569;
box-shadow: none;
opacity: 0.45;
}

/* Typography */
h1 {
font-size: clamp(3.2rem, 13vw, 5.4rem);
font-weight: 900;
letter-spacing: -0.04em;
background: linear-gradient(135deg, #e2e8f0 0%, #94a3b8 100%);
-webkit-background-clip: text;
-webkit-text-fill-color: transparent;
background-clip: text;
margin-bottom: 2vh;
text-align: center;
line-height: 1;
}
h2 {
font-size: clamp(2rem, 7vw, 2.8rem);
color: var(--text-main);
font-weight: 800;
margin-bottom: 1.5vh;
}
.subtitle {
font-size: clamp(1rem, 3.2vw, 1.25rem);
color: var(--text-muted);
margin-bottom: 4vh;
font-weight: 500;
max-width: 520px;
text-align: center;
line-height: 1.6;
}
.instructions-text {
font-size: clamp(0.95rem, 3vw, 1.15rem);
color: var(--text-main);
line-height: 1.7;
max-width: 480px;
text-align: center;
margin: 2vh 0;
}
.total-label {
font-size: clamp(1rem, 2.8vw, 1.2rem);
color: var(--text-muted);
text-transform: uppercase;
letter-spacing: 0.12em;
margin-bottom: 1.2vh;
font-weight: 700;
}
.final-score-display {
font-size: clamp(2.8rem, 12vw, 4.4rem);
font-weight: 900;
margin: 2vh 0 3vh;
background: linear-gradient(135deg, var(--primary) 0%, var(--gold) 100%);
-webkit-background-clip: text;
-webkit-text-fill-color: transparent;
background-clip: text;
line-height: 1;
}

/* Buttons */
button {
padding: clamp(15px, 3.2vh, 22px) clamp(42px, 11vw, 64px);
font-size: clamp(1.05rem, 3.7vw, 1.25rem);
font-weight: 800;
background: var(--primary);
color: white;
border: none;
border-radius: 18px;
cursor: pointer;
box-shadow: 0 10px 28px var(--primary-glow);
transition: all 0.22s ease;
text-transform: uppercase;
letter-spacing: 0.09em;
touch-action: manipulation;
min-width: 210px;
}
button:active {
transform: scale(0.96);
box-shadow: 0 6px 18px var(--primary-glow);
}
.exit-btn {
background: var(--danger);
box-shadow: 0 10px 28px rgba(220, 38, 38, 0.6);
}
.exit-btn:active {
box-shadow: 0 6px 18px rgba(220, 38, 38, 0.6);
}

/* Notifications */
.notification-text {
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%) scale(0.8);
font-size: clamp(1.6rem, 5.5vw, 2.7rem);
font-weight: 900;
color: #fff;
text-shadow: 0 5px 22px rgba(0,0,0,0.85);
opacity: 0;
pointer-events: none;
transition: all 0.42s cubic-bezier(0.34, 1.56, 0.64, 1);
z-index: 80;
text-align: center;
white-space: nowrap;
}
.notification-text.gold { color: var(--gold); text-shadow: 0 0 34px var(--gold-glow), 0 5px 22px rgba(0,0,0,0.85); }
.notification-text.purple { color: #c084fc; text-shadow: 0 0 34px rgba(192, 132, 252, 0.7), 0 5px 22px rgba(0,0,0,0.85); }

/* Countdown */
#countdownScreen {
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
display: flex;
flex-direction: column;
justify-content: center;
align-items: center;
z-index: 190;
color: white;
font-size: 8.2rem;
font-weight: 900;
opacity: 0;
pointer-events: none;
transition: opacity 0.35s;
background: var(--bg-overlay);
backdrop-filter: blur(10px);
-webkit-backdrop-filter: blur(10px);
}
#countdownScreen.active {
opacity: 1;
pointer-events: all;
}
.countdown-sponsor {
font-size: clamp(1.1rem, 3.3vw, 1.5rem);
margin-bottom: 2.2vh;
color: var(--text-muted);
text-align: center;
font-weight: 600;
}
.ad-placeholder {
width: 92%;
max-width: 310px;
height: 84px;
background: rgba(0, 0, 0, 0.35);
border: 1px dashed rgba(255, 255, 255, 0.25);
border-radius: 14px;
display: flex;
justify-content: center;
align-items: center;
color: rgba(255, 255, 255, 0.45);
font-size: 0.95rem;
margin-top: 1.2vh;
}

/* Instructions Modal */
#instructionsModal {
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
display: flex;
justify-content: center;
align-items: center;
z-index: 200;
opacity: 0;
pointer-events: none;
transition: opacity 0.4s ease;
background: rgba(0, 0, 0, 0.6);
}
#instructionsModal.active {
opacity: 1;
pointer-events: all;
}
#instructionsContent {
background: var(--bg-overlay);
backdrop-filter: blur(22px);
-webkit-backdrop-filter: blur(22px);
border-radius: 24px;
padding: 5vh 6vw;
width: 90vw;
max-width: 500px;
text-align: center;
border: 1px solid rgba(255, 255, 255, 0.15);
box-shadow: 0 30px 70px rgba(0, 0, 0, 0.7);
}
#closeInstructions {
margin-top: 2vh;
background: #64748b;
}

/* Shake */
.shake {
animation: shake 0.52s cubic-bezier(.36,.07,.19,.97);
}
@keyframes shake {
0%, 100% { transform: translate(-50%, -50%); }
10%, 30%, 50%, 70%, 90% { transform: translate(calc(-50% - 10px), calc(-50% - 10px)); }
20%, 40%, 60%, 80% { transform: translate(calc(-50% + 10px), calc(-50% + 10px)); }
}
@media (max-width: 768px) {
@keyframes shake {
0%, 100% { transform: none; }
10%, 30%, 50%, 70%, 90% { transform: translate(-10px, -10px); }
20%, 40%, 60%, 80% { transform: translate(10px, 10px); }
}
#gameWrapper.shake {
animation: shake 0.52s cubic-bezier(.36,.07,.19,.97);
}
}

/* Stats */
.game-over-stats {
display: grid;
grid-template-columns: 1fr 1fr;
gap: clamp(14px, 3.3vw, 22px);
width: 100%;
max-width: 420px;
margin: 2vh auto 3vh;
}
.stat-box {
background: rgba(255,255,255,0.06);
border: 1px solid rgba(255, 255, 255, 0.12);
padding: clamp(13px, 2.7vh, 19px);
border-radius: 14px;
text-align: center;
}
.stat-label {
font-size: clamp(0.75rem, 2.2vw, 0.9rem);
color: var(--text-muted);
text-transform: uppercase;
margin-bottom: 0.6vh;
font-weight: 700;
letter-spacing: 0.05em;
}
.stat-number {
font-size: clamp(1.6rem, 5.2vw, 2.1rem);
font-weight: 900;
color: var(--text-main);
}

/* Button Group */
.button-group {
display: flex;
gap: clamp(14px, 3.3vw, 22px);
flex-wrap: wrap;
justify-content: center;
margin-top: 1.5vh;
}
@media (max-width: 768px) {
.button-group {
flex-direction: column;
align-items: center;
}
.button-group button {
width: 84%;
}
}
</style>
</head>
<body>
<!-- Background for Start and Game Over -->
<div class="screen-bg"></div>
<div class="screen-overlay"></div>

<!-- Game Area - No background -->
<div id="gameWrapper">
<canvas id="gameCanvas"></canvas>

<!-- HUD: ONLY shown during gameplay -->
<div id="hud" style="display: none;">
<div class="hud-pill">
<span class="hud-label">Score</span>
<span id="scoreDisplay" class="hud-value">0</span>
</div>
<div class="hud-pill">
<span class="hud-label">Orbs</span>
<span id="ballCount" class="hud-value">1</span>
</div>
<div class="hud-pill">
<div id="lives-container">
<div class="heart"></div>
<div class="heart"></div>
<div class="heart"></div>
</div>
</div>
</div>

<div id="notification" class="notification-text">New Orb</div>

<!-- Countdown -->
<div id="countdownScreen">
<div class="countdown-sponsor">This game is sponsored by:</div>
<div class="ad-placeholder">Advertisement Space</div>
<div id="countdownNumber">5</div>
</div>

<!-- Start Screen -->
<div id="startScreen" class="screen">
<h1>ORBIT</h1>
<p class="subtitle">Bounce orbs with your paddle. Avoid spikes!</p>
<div class="button-group">
<button id="startBtn">Start Game</button>
<button id="instructionsBtn">Instructions</button>
<button id="exitBtn" class="exit-btn">Exit</button>
</div>
</div>

<!-- Instructions -->
<div id="instructionsModal">
<div id="instructionsContent">
<h2>How to Play</h2>
<p class="instructions-text">Drag to move the paddle.<br><br>
• <strong>Bounce orbs</strong> to earn points<br>
• <strong>Avoid red spikes</strong> — they cost a life<br>
• <strong>Golden orbs</strong> grant an extra life<br>
• <strong>Purple orbs</strong> slow time for 5 seconds<br><br>
Lose all lives and it's game over!</p>
<button id="closeInstructions">Got It</button>
</div>
</div>

<!-- Game Over -->
<div id="gameOverScreen" class="screen hidden">
<h2 style="color: var(--danger);">Game Over</h2>
<div class="total-label">Total Points</div>
<div class="final-score-display" id="finalScore">0</div>
<div class="game-over-stats">
<div class="stat-box">
<div class="stat-number" id="maxBalls">0</div>
<div class="stat-label">Max Orbs</div>
</div>
<div class="stat-box">
<div class="stat-number" id="survivalTime">0s</div>
<div class="stat-label">Survived</div>
</div>
</div>
<div class="button-group">
<button id="restartBtn">Play Again</button>
<button id="exitBtn2" class="exit-btn">Exit</button>
</div>
</div>
</div>

<script>
// CORE SETUP
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false });
const wrapper = document.getElementById('gameWrapper');
const ui = {
start: document.getElementById('startScreen'),
over: document.getElementById('gameOverScreen'),
hud: document.getElementById('hud'),
score: document.getElementById('scoreDisplay'),
balls: document.getElementById('ballCount'),
finalScore: document.getElementById('finalScore'),
maxBalls: document.getElementById('maxBalls'),
time: document.getElementById('survivalTime'),
lives: document.querySelectorAll('.heart'),
notify: document.getElementById('notification'),
countdown: document.getElementById('countdownScreen'),
countdownNum: document.getElementById('countdownNumber'),
instructionsModal: document.getElementById('instructionsModal'),
startBtn: document.getElementById('startBtn'),
instructionsBtn: document.getElementById('instructionsBtn'),
closeInstructions: document.getElementById('closeInstructions'),
exitBtn: document.getElementById('exitBtn'),
exitBtn2: document.getElementById('exitBtn2'),
restartBtn: document.getElementById('restartBtn')
};
let animationId, isPlaying = false, lastTime = 0, gameTime = 0, score = 0, lives = 3;
const MAX_LIVES = 5;
let maxBallsActive = 0, entities = [], particles = [];
let nextBallTime = 0, nextSpikeTime = 0, nextGoldTime = 0, nextPowerUpTime = 0;
let gameWidth = 0, gameHeight = 0, minBounceY = 0, maxBounceY = 0, slowMoEndTime = 0;

const paddle = {
width: 0, height: 0, x: 0, y: 0, targetX: 0,
color: '#4f46e5', glowColor: 'rgba(79, 70, 229, 0.6)',
startWidthRatio: 0.35, minWidthRatio: 0.18, shrinkDuration: 150, shrinkDelay: 15
};

// RESIZE
function resize() {
const rect = wrapper.getBoundingClientRect();
const dpr = Math.min(window.devicePixelRatio || 1, 2);
gameWidth = rect.width;
gameHeight = rect.height;
minBounceY = gameHeight * 0.5;
maxBounceY = gameHeight * 0.1;
canvas.width = gameWidth * dpr;
canvas.height = gameHeight * dpr;
canvas.style.width = gameWidth + 'px';
canvas.style.height = gameHeight + 'px';
ctx.scale(dpr, dpr);
paddle.height = Math.max(14, gameHeight * 0.016);
paddle.width = gameWidth * paddle.startWidthRatio;
paddle.x = (gameWidth - paddle.width) / 2;
paddle.targetX = paddle.x;
paddle.y = gameHeight * 0.82;
}
window.addEventListener('resize', resize);
resize();

// INPUT
let touchId = null;
function handlePointerMove(clientX) {
if (!isPlaying) return;
const rect = canvas.getBoundingClientRect();
const x = clientX - rect.left;
paddle.targetX = x - (paddle.width / 2);
paddle.targetX = Math.max(0, Math.min(gameWidth - paddle.width, paddle.targetX));
}
canvas.addEventListener('mousemove', (e) => handlePointerMove(e.clientX));
canvas.addEventListener('touchstart', (e) => {
if (!isPlaying) return;
e.preventDefault();
const touch = e.changedTouches[0];
touchId = touch.identifier;
handlePointerMove(touch.clientX);
}, { passive: false });
canvas.addEventListener('touchmove', (e) => {
if (!isPlaying) return;
e.preventDefault();
for (let touch of e.changedTouches) {
if (touch.identifier === touchId) {
handlePointerMove(touch.clientX);
break;
}
}
}, { passive: false });
canvas.addEventListener('touchend', (e) => {
for (let touch of e.changedTouches) {
if (touch.identifier === touchId) {
touchId = null;
break;
}
}
});
document.body.addEventListener('touchstart', (e) => { if (isPlaying) e.preventDefault(); }, { passive: false });

// ENTITIES (Ball, GoldBall, Spike, SlowMoPowerUp)
class Ball {
constructor() {
this.type = 'ball';
this.radius = Math.max(9, gameWidth * 0.016);
this.x = gameWidth * (0.15 + Math.random() * 0.7);
this.y = paddle.y - 32;
const targetY = minBounceY - Math.random() * (minBounceY - maxBounceY);
const targetHeight = paddle.y - targetY;
const gravity = 0.42;
const requiredVelocity = Math.sqrt(2 * gravity * targetHeight);
this.dy = -requiredVelocity;
this.dx = (Math.random() - 0.5) * 4.2;
this.color = `hsl(${220 + Math.random()*50}, 88%, 64%)`;
this.trail = [];
}
update(dt) {
const slowdown = slowMoEndTime > gameTime ? 0.3 : 1;
const gravity = 0.42 * slowdown;
this.dy += gravity;
this.x += this.dx * slowdown;
this.y += this.dy * slowdown;
this.trail.push({x: this.x, y: this.y});
if (this.trail.length > 6) this.trail.shift();
if (this.x < this.radius) { this.x = this.radius; this.dx *= -0.85; }
if (this.x > gameWidth - this.radius) { this.x = gameWidth - this.radius; this.dx *= -0.85; }
if (this.dy > 0 && this.y + this.radius >= paddle.y && this.y - this.radius <= paddle.y + paddle.height &&
    this.x >= paddle.x - this.radius && this.x <= paddle.x + paddle.width + this.radius) {
const targetY = minBounceY - Math.random() * (minBounceY - maxBounceY);
const targetHeight = paddle.y - targetY;
const requiredVelocity = Math.sqrt(2 * gravity * targetHeight);
this.dy = -requiredVelocity * (0.95 + Math.random() * 0.1);
const hitPos = (this.x - (paddle.x + paddle.width/2)) / (paddle.width/2);
this.dx = hitPos * 6.2;
score += 10;
ui.score.textContent = score;
spawnParticles(this.x, paddle.y, this.color, 8);
updateHUD();
return 'hit';
}
if (this.y > gameHeight + this.radius * 2) return 'dead';
return 'alive';
}
draw() {
ctx.globalAlpha = 0.45;
this.trail.forEach((pos, i) => {
const size = this.radius * (i / this.trail.length);
ctx.fillStyle = this.color;
ctx.beginPath();
ctx.arc(pos.x, pos.y, size, 0, Math.PI * 2);
ctx.fill();
});
ctx.globalAlpha = 1;
ctx.shadowBlur = 22;
ctx.shadowColor = this.color;
ctx.fillStyle = this.color;
ctx.beginPath();
ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
ctx.fill();
ctx.fillStyle = 'rgba(255,255,255,0.92)';
ctx.beginPath();
ctx.arc(this.x - this.radius * 0.3, this.y - this.radius * 0.3, this.radius * 0.25, 0, Math.PI * 2);
ctx.fill();
ctx.shadowBlur = 0;
}
}

class GoldBall {
constructor() {
this.type = 'gold';
this.radius = Math.max(13, gameWidth * 0.023);
this.x = gameWidth * (0.2 + Math.random() * 0.6);
this.y = paddle.y - 32;
const targetY = minBounceY - Math.random() * (minBounceY - maxBounceY);
const targetHeight = paddle.y - targetY;
const gravity = 0.42;
const requiredVelocity = Math.sqrt(2 * gravity * targetHeight);
this.dy = -requiredVelocity;
this.dx = (Math.random() - 0.5) * 3.2;
this.pulse = 0;
this.color = '#f59e0b';
this.trail = [];
}
update(dt) {
const slowdown = slowMoEndTime > gameTime ? 0.3 : 1;
const gravity = 0.42 * slowdown;
this.dy += gravity;
this.x += this.dx * slowdown;
this.y += this.dy * slowdown;
this.pulse += dt * 6;
this.trail.push({x: this.x, y: this.y});
if (this.trail.length > 8) this.trail.shift();
if (this.x < this.radius) { this.x = this.radius; this.dx *= -0.9; }
if (this.x > gameWidth - this.radius) { this.x = gameWidth - this.radius; this.dx *= -0.9; }
if (this.y + this.radius >= paddle.y && this.y - this.radius <= paddle.y + paddle.height &&
    this.x >= paddle.x - this.radius && this.x <= paddle.x + paddle.width + this.radius) {
return 'hit';
}
if (this.y > gameHeight + this.radius * 2) return 'dead';
return 'alive';
}
draw() {
const r = this.radius + Math.sin(this.pulse) * 2.2;
ctx.globalAlpha = 0.55;
this.trail.forEach((pos, i) => {
const size = r * (i / this.trail.length);
ctx.fillStyle = this.color;
ctx.beginPath();
ctx.arc(pos.x, pos.y, size, 0, Math.PI * 2);
ctx.fill();
});
ctx.globalAlpha = 1;
ctx.shadowBlur = 32;
ctx.shadowColor = this.color;
ctx.fillStyle = this.color;
ctx.beginPath();
ctx.arc(this.x, this.y, r, 0, Math.PI * 2);
ctx.fill();
ctx.fillStyle = '#fff';
ctx.shadowBlur = 16;
ctx.beginPath();
ctx.arc(this.x - r * 0.25, this.y - r * 0.25, r * 0.3, 0, Math.PI * 2);
ctx.fill();
ctx.shadowBlur = 0;
}
}

class Spike {
constructor() {
this.type = 'spike';
this.size = Math.max(13, gameWidth * 0.021);
this.x = gameWidth * (0.1 + Math.random() * 0.8);
this.y = -this.size * 2;
const speed = 3.2 + (gameTime * 0.026);
this.dx = (Math.random() - 0.5) * 1.6;
this.dy = speed;
this.color = '#dc2626';
this.rot = Math.random() * Math.PI * 2;
this.rotSpeed = (Math.random() - 0.5) * 0.13;
}
update(dt) {
const slowdown = slowMoEndTime > gameTime ? 0.3 : 1;
this.dy += 0.085 * slowdown;
this.x += this.dx * slowdown;
this.y += this.dy * slowdown;
this.rot += this.rotSpeed * slowdown;
if (this.x < 0) this.x = gameWidth;
if (this.x > gameWidth) this.x = 0;
const expandedHitbox = this.size * 0.7;
if (this.y + expandedHitbox >= paddle.y && this.y - expandedHitbox <= paddle.y + paddle.height &&
    this.x >= paddle.x - expandedHitbox && this.x <= paddle.x + paddle.width + expandedHitbox) {
return 'hit';
}
if (this.y > gameHeight + this.size * 2) return 'dead';
return 'alive';
}
draw() {
ctx.save();
ctx.translate(this.x, this.y);
ctx.rotate(this.rot);
ctx.shadowBlur = 16;
ctx.shadowColor = this.color;
ctx.fillStyle = this.color;
ctx.beginPath();
ctx.moveTo(0, -this.size);
ctx.lineTo(this.size * 0.9, this.size * 0.9);
ctx.lineTo(-this.size * 0.9, this.size * 0.9);
ctx.closePath();
ctx.fill();
ctx.restore();
ctx.shadowBlur = 0;
}
}

class SlowMoPowerUp {
constructor() {
this.type = 'slowmo';
this.radius = Math.max(11, gameWidth * 0.019);
this.x = gameWidth * (0.2 + Math.random() * 0.6);
this.y = paddle.y - 32;
const targetY = minBounceY - Math.random() * (minBounceY - maxBounceY);
const targetHeight = paddle.y - targetY;
const gravity = 0.42;
const requiredVelocity = Math.sqrt(2 * gravity * targetHeight);
this.dy = -requiredVelocity;
this.dx = (Math.random() - 0.5) * 2.6;
this.color = '#c084fc';
this.trail = [];
}
update(dt) {
const slowdown = slowMoEndTime > gameTime ? 0.3 : 1;
const gravity = 0.42 * slowdown;
this.dy += gravity;
this.x += this.dx * slowdown;
this.y += this.dy * slowdown;
this.trail.push({x: this.x, y: this.y});
if (this.trail.length > 7) this.trail.shift();
if (this.x < this.radius) { this.x = this.radius; this.dx *= -0.85; }
if (this.x > gameWidth - this.radius) { this.x = gameWidth - this.radius; this.dx *= -0.85; }
if (this.y + this.radius >= paddle.y && this.y - this.radius <= paddle.y + paddle.height &&
    this.x >= paddle.x - this.radius && this.x <= paddle.x + paddle.width + this.radius) {
return 'hit';
}
if (this.y > gameHeight + this.radius * 2) return 'dead';
return 'alive';
}
draw() {
ctx.globalAlpha = 0.55;
this.trail.forEach((pos, i) => {
const size = this.radius * (i / this.trail.length);
ctx.fillStyle = this.color;
ctx.beginPath();
ctx.arc(pos.x, pos.y, size, 0, Math.PI * 2);
ctx.fill();
});
ctx.globalAlpha = 1;
ctx.shadowBlur = 26;
ctx.shadowColor = this.color;
ctx.fillStyle = this.color;
ctx.beginPath();
ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
ctx.fill();
ctx.fillStyle = 'rgba(255,255,255,0.92)';
ctx.beginPath();
ctx.arc(this.x - this.radius * 0.3, this.y - this.radius * 0.3, this.radius * 0.2, 0, Math.PI * 2);
ctx.fill();
ctx.shadowBlur = 0;
}
}

// EFFECTS
function spawnParticles(x, y, color, count = 10) {
const maxParts = window.devicePixelRatio > 1 ? 100 : 50;
if (particles.length > maxParts) return;
for (let i = 0; i < count; i++) {
const angle = Math.random() * Math.PI * 2;
const speed = 2.2 + Math.random() * 4.2;
particles.push({x, y, dx: Math.cos(angle) * speed, dy: Math.sin(angle) * speed, life: 1.0, size: 2.2 + Math.random() * 3.2, color});
}
}
function updateParticles() {
const slowdown = slowMoEndTime > gameTime ? 0.3 : 1;
for (let i = particles.length - 1; i >= 0; i--) {
const p = particles[i];
p.x += p.dx * slowdown;
p.y += p.dy * slowdown;
p.dy += 0.16 * slowdown;
p.life -= 0.02;
if (p.life <= 0) { particles.splice(i, 1); } else {
ctx.globalAlpha = p.life;
ctx.fillStyle = p.color;
ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
}
}
ctx.globalAlpha = 1;
}
function showNotification(text, type = '') {
ui.notify.textContent = text;
ui.notify.className = 'notification-text active';
if (type === 'gold') ui.notify.classList.add('gold');
else if (type === 'purple') ui.notify.classList.add('purple');
if (ui.notifyTimeout) clearTimeout(ui.notifyTimeout);
ui.notifyTimeout = setTimeout(() => { ui.notify.classList.remove('active'); }, 1800);
}

// GAME LOGIC
function updateHUD() {
const balls = entities.filter(e => e.type === 'ball').length;
ui.balls.textContent = balls;
maxBallsActive = Math.max(maxBallsActive, balls);
ui.lives.forEach((dot, i) => { dot.classList.toggle('lost', i >= lives); });
}
function takeDamage() {
lives--;
updateHUD();
wrapper.classList.add('shake');
setTimeout(() => wrapper.classList.remove('shake'), 520);
nextBallTime = gameTime + (8 + Math.random() * 6);
if (lives <= 0) { gameOver(); }
}
function addLife() {
if (lives < MAX_LIVES) {
lives++;
updateHUD();
wrapper.classList.add('pulse');
setTimeout(() => wrapper.classList.remove('pulse'), 300);
}
}
function activateSlowMo() {
slowMoEndTime = gameTime + 5;
showNotification('SLOW TIME!', 'purple');
}
function startCountdown() {
ui.start.classList.add('hidden');
ui.countdown.classList.add('active');
let count = 5;
ui.countdownNum.textContent = count;
const interval = setInterval(() => {
count--;
if (count > 0) { ui.countdownNum.textContent = count; } else {
clearInterval(interval);
ui.countdown.classList.remove('active');
initGame();
}
}, 1000);
}
function initGame() {
resize();
entities = [new Ball()];
particles = [];
score = 0;
lives = 3;
gameTime = 0;
maxBallsActive = 1;
paddle.width = gameWidth * paddle.startWidthRatio;
paddle.x = (gameWidth - paddle.width) / 2;
paddle.targetX = paddle.x;
nextBallTime = 8;
nextSpikeTime = 25;
nextGoldTime = 30;
nextPowerUpTime = 45;
updateHUD();
ui.score.textContent = '0';
isPlaying = true;
ui.hud.style.display = 'flex'; // ✅ SHOW HUD ONLY DURING GAMEPLAY
lastTime = performance.now();
animate(lastTime);
}
function gameOver() {
isPlaying = false;
cancelAnimationFrame(animationId);
slowMoEndTime = 0;
ui.finalScore.textContent = score;
ui.maxBalls.textContent = maxBallsActive;
ui.time.textContent = Math.floor(gameTime) + 's';
ui.hud.style.display = 'none'; // ✅ HIDE HUD ON GAME OVER
ui.over.classList.remove('hidden');
}

// GAME LOOP
let accumulator = 0;
const fixedDeltaTime = 1 / 60;
function animate(timestamp) {
if (!isPlaying) return;
const frameTime = (timestamp - lastTime) / 1000;
lastTime = timestamp;
const clampedFrameTime = Math.min(frameTime, 0.25);
accumulator += clampedFrameTime;
gameTime += clampedFrameTime;
const gradient = ctx.createLinearGradient(0, 0, 0, gameHeight);
gradient.addColorStop(0, '#0f172a');
gradient.addColorStop(1, '#1e293b');
ctx.fillStyle = gradient;
ctx.fillRect(0, 0, gameWidth, gameHeight);
while (accumulator >= fixedDeltaTime) {
updateGameLogic(fixedDeltaTime);
accumulator -= fixedDeltaTime;
}
drawEntities();
animationId = requestAnimationFrame(animate);
}
function updateGameLogic(dt) {
if (gameTime > nextBallTime) {
const ballCount = entities.filter(e => e.type === 'ball').length;
if (ballCount < 5) {
entities.push(new Ball());
nextBallTime = gameTime + (8 + Math.random() * 6);
showNotification('New Orb');
}
}
if (gameTime > nextSpikeTime) {
entities.push(new Spike());
nextSpikeTime = gameTime + (12 + Math.random() * 8);
showNotification('⚠ Spike');
}
if (gameTime > nextGoldTime) {
entities.push(new GoldBall());
nextGoldTime = gameTime + 30;
showNotification('GOLDEN ORB!', 'gold');
}
if (gameTime > nextPowerUpTime) {
entities.push(new SlowMoPowerUp());
nextPowerUpTime = gameTime + 60;
}
const lerpSpeed = 0.25;
paddle.x += (paddle.targetX - paddle.x) * lerpSpeed;
if (gameTime > paddle.shrinkDelay) {
const shrinkProgress = Math.min((gameTime - paddle.shrinkDelay) / paddle.shrinkDuration, 1);
const easeProgress = 1 - Math.pow(1 - shrinkProgress, 3);
const startWidth = gameWidth * paddle.startWidthRatio;
const endWidth = gameWidth * paddle.minWidthRatio;
const newWidth = startWidth - (startWidth - endWidth) * easeProgress;
const widthDiff = paddle.width - newWidth;
const relativePos = (paddle.targetX - paddle.x) / paddle.width;
paddle.x += widthDiff * (0.5 + relativePos * 0.5);
paddle.width = newWidth;
paddle.x = Math.max(0, Math.min(gameWidth - paddle.width, paddle.x));
}
for (let i = entities.length - 1; i >= 0; i--) {
const entity = entities[i];
const status = entity.update(dt);
if (status === 'dead') {
if (entity.type === 'ball') { takeDamage(); }
entities.splice(i, 1);
updateHUD();
} else if (status === 'hit') {
if (entity.type === 'gold') {
spawnParticles(entity.x, entity.y, '#f59e0b', 20);
addLife();
score += 100;
ui.score.textContent = score;
showNotification('+1 LIFE', 'gold');
entities.splice(i, 1);
} else if (entity.type === 'spike') {
spawnParticles(entity.x, entity.y, '#dc2626', 15);
takeDamage();
entities.splice(i, 1);
} else if (entity.type === 'slowmo') {
spawnParticles(entity.x, entity.y, '#c084fc', 15);
activateSlowMo();
entities.splice(i, 1);
}
}
}
const ballCount = entities.filter(e => e.type === 'ball').length;
if (isPlaying && ballCount === 0 && lives > 0) {
entities.push(new Ball());
updateHUD();
}
for (let i = particles.length - 1; i >= 0; i--) {
const p = particles[i];
const slowdown = slowMoEndTime > gameTime ? 0.3 : 1;
p.x += p.dx * slowdown;
p.y += p.dy * slowdown;
p.dy += 0.16 * slowdown;
p.life -= 0.02;
if (p.life <= 0) { particles.splice(i, 1); }
}
}
function drawEntities() {
const paddleGradient = ctx.createLinearGradient(paddle.x, paddle.y, paddle.x, paddle.y + paddle.height);
paddleGradient.addColorStop(0, 'rgba(255,255,255,0.25)');
paddleGradient.addColorStop(1, paddle.color);
ctx.shadowBlur = 22;
ctx.shadowColor = paddle.glowColor;
ctx.fillStyle = paddleGradient;
ctx.beginPath();
if (ctx.roundRect) ctx.roundRect(paddle.x, paddle.y, paddle.width, paddle.height, 10);
else ctx.rect(paddle.x, paddle.y, paddle.width, paddle.height);
ctx.fill();
ctx.shadowBlur = 0;
ctx.fillStyle = 'rgba(255,255,255,0.35)';
ctx.beginPath();
if (ctx.roundRect) ctx.roundRect(paddle.x, paddle.y, paddle.width, paddle.height * 0.4, [10, 10, 0, 0]);
else ctx.rect(paddle.x, paddle.y, paddle.width, paddle.height * 0.4);
ctx.fill();
for (const entity of entities) entity.draw();
for (let i = particles.length - 1; i >= 0; i--) {
const p = particles[i];
ctx.globalAlpha = p.life;
ctx.fillStyle = p.color;
ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
}
ctx.globalAlpha = 1;
}

// EVENT LISTENERS
ui.startBtn.addEventListener('click', startCountdown);
ui.instructionsBtn.addEventListener('click', () => { ui.instructionsModal.classList.add('active'); });
ui.closeInstructions.addEventListener('click', () => { ui.instructionsModal.classList.remove('active'); });
ui.restartBtn.addEventListener('click', () => { ui.over.classList.add('hidden'); startCountdown(); });
ui.exitBtn.addEventListener('click', () => { ui.start.classList.remove('hidden'); ui.over.classList.add('hidden'); });
ui.exitBtn2.addEventListener('click', () => { ui.over.classList.add('hidden'); ui.start.classList.remove('hidden'); });
canvas.addEventListener('contextmenu', (e) => e.preventDefault());
document.addEventListener('visibilitychange', () => { if (document.hidden && isPlaying) lastTime = performance.now(); });
</script>
</body>
</html>
