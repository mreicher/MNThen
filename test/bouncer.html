<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Bouncer: Multi-Ball Mayhem</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #0a0a0a;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            user-select: none;
        }

        #game-container {
            position: relative;
            max-width: 95vw; 
            max-height: 95vh;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
            border: 3px solid #333;
            background: #000;
        }

        canvas {
            display: block;
            background-color: #000;
        }

        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.9);
            z-index: 10;
            text-align: center;
        }

        .hidden { display: none !important; }

        h1 {
            font-size: 3rem;
            margin: 0;
            color: #fff;
            text-shadow: 0 0 20px #0ff;
        }

        button {
            margin-top: 20px;
            padding: 15px 45px;
            font-size: 1.5rem;
            background: #0ff;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            color: #000;
            font-weight: bold;
            box-shadow: 0 0 15px #0ff;
        }

        #hud {
            position: absolute;
            top: 15px;
            left: 15px;
            right: 15px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            font-size: 1.2rem;
            z-index: 5;
        }

        .stat-box {
            background: rgba(255, 255, 255, 0.1);
            padding: 8px 15px;
            border-radius: 12px;
            border: 1px solid #444;
            backdrop-filter: blur(5px);
        }

        #alert-msg {
            position: absolute;
            top: 35%;
            width: 100%;
            text-align: center;
            font-size: 2.5rem;
            font-weight: bold;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s, transform 0.3s;
            z-index: 8;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        
        <div id="hud" class="hidden">
            <div class="stat-box">Score: <span id="scoreDisplay" style="color:#0ff">0</span></div>
            <div class="stat-box">Lives: <span id="livesDisplay" style="color:#ff0055">3</span></div>
        </div>
        
        <div id="alert-msg">OPE! NEW BALL!</div>

        <div id="startScreen" class="overlay">
            <h1>NEON BOUNCER</h1>
            <p>A new ball drops every 10 seconds!<br>Don't touch the red spikes.</p>
            <button id="startBtn">PLAY NOW</button>
        </div>

        <div id="gameOverScreen" class="overlay hidden">
            <h1 style="color: #ff0055;">GAME OVER</h1>
            <p>You did a real fine job! Final Score: <span id="finalScore">0</span></p>
            <button id="restartBtn">RETRY</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const livesDisplay = document.getElementById('livesDisplay');
        const alertMsg = document.getElementById('alert-msg');

        const GAME_WIDTH = 600;
        const GAME_HEIGHT = 600;
        canvas.width = GAME_WIDTH;
        canvas.height = GAME_HEIGHT;

        let animationId;
        let score = 0;
        let lives = 3;
        let isGameRunning = false;
        let lastTime = 0;
        let ballTimer = 0;
        let spikeTimer = 0;
        let currentGravity = 0.15;

        const PADDLE_WIDTH = 110;
        const PADDLE_HEIGHT = 15;
        let paddle = { x: 245, y: 560, width: PADDLE_WIDTH, height: PADDLE_HEIGHT, color: '#fff' };

        let entities = [];
        const BALL_COLORS = ['#00ffcc', '#ffdd00', '#ff00ff', '#0077ff', '#ffffff', '#00ff00'];

        function handleInput(clientX) {
            const rect = canvas.getBoundingClientRect();
            paddle.x = (clientX - rect.left) * (GAME_WIDTH / rect.width) - paddle.width / 2;
            if (paddle.x < 0) paddle.x = 0;
            if (paddle.x + paddle.width > GAME_WIDTH) paddle.x = GAME_WIDTH - paddle.width;
        }

        document.addEventListener('mousemove', (e) => handleInput(e.clientX));
        document.addEventListener('touchmove', (e) => {
            handleInput(e.touches[0].clientX);
            e.preventDefault();
        }, { passive: false });

        class Entity {
            constructor(type, isInitial = false) {
                this.type = type;
                this.radius = type === 'ball' ? 12 : 15;
                this.x = Math.random() * (GAME_WIDTH - 40) + 20;
                this.y = isInitial ? 100 : -20;
                this.dx = (Math.random() - 0.5) * 6;
                this.dy = 1;
                
                if (this.type === 'ball') {
                    // Pick a random color from the tray
                    this.color = BALL_COLORS[Math.floor(Math.random() * BALL_COLORS.length)];
                    this.points = (this.color === '#ffdd00') ? 50 : 10;
                } else {
                    this.color = '#ff0055'; // Spikes are always red/pink
                }
            }

            draw() {
                ctx.beginPath();
                if (this.type === 'ball') {
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fillStyle = this.color;
                    ctx.fill();
                    // Fancy glow
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = this.color;
                } else {
                    // Spike (Triangle)
                    ctx.moveTo(this.x, this.y - this.radius);
                    ctx.lineTo(this.x - this.radius, this.y + this.radius);
                    ctx.lineTo(this.x + this.radius, this.y + this.radius);
                    ctx.closePath();
                    ctx.fillStyle = this.color;
                    ctx.fill();
                }
                ctx.shadowBlur = 0;
            }

            update() {
                this.dy += currentGravity;
                this.x += this.dx;
                this.y += this.dy;

                // Wall bounce
                if (this.x + this.radius > GAME_WIDTH || this.x - this.radius < 0) this.dx *= -1;

                // Paddle Collision
                if (this.y + this.radius >= paddle.y && this.y - this.radius <= paddle.y + paddle.height &&
                    this.x >= paddle.x && this.x <= paddle.x + paddle.width) {
                    
                    if (this.type === 'ball' && this.dy > 0) {
                        // Math for guaranteed middle-screen bounce
                        let bounceHeight = 350; // Pixels from bottom
                        let requiredVelocity = Math.sqrt(2 * currentGravity * bounceHeight);
                        this.dy = -requiredVelocity;
                        
                        score += this.points;
                        scoreDisplay.textContent = score;
                        flashPaddle('#0ff');
                    } else if (this.type === 'spike') {
                        loseLife("OUCH! SPIKE HIT!");
                        return false; 
                    }
                }

                // Floor check
                if (this.y - this.radius > GAME_HEIGHT) {
                    if (this.type === 'ball') loseLife("OPE! DROPPED ONE!");
                    return false;
                }
                return true;
            }
        }

        function flashPaddle(color) {
            paddle.color = color;
            setTimeout(() => paddle.color = '#ffffff', 150);
        }

        function loseLife(msg) {
            lives--;
            livesDisplay.textContent = lives;
            showAlert(msg, "#ff0055");
            flashPaddle('#ff0055');
            if (lives <= 0) endGame();
        }

        function showAlert(text, color) {
            alertMsg.textContent = text;
            alertMsg.style.color = color;
            alertMsg.style.opacity = 1;
            alertMsg.style.transform = "translateY(-20px)";
            setTimeout(() => {
                alertMsg.style.opacity = 0;
                alertMsg.style.transform = "translateY(0px)";
            }, 1000);
        }

        function initGame() {
            entities = [new Entity('ball', true)];
            score = 0; lives = 3; ballTimer = 0; spikeTimer = 0; currentGravity = 0.15;
            scoreDisplay.textContent = score;
            livesDisplay.textContent = lives;
            isGameRunning = true;
            lastTime = performance.now();
            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('gameOverScreen').classList.add('hidden');
            document.getElementById('hud').classList.remove('hidden');
            animate();
        }

        function endGame() {
            isGameRunning = false;
            cancelAnimationFrame(animationId);
            document.getElementById('finalScore').textContent = score;
            document.getElementById('hud').classList.add('hidden');
            document.getElementById('gameOverScreen').classList.remove('hidden');
        }

        function animate(currentTime) {
            if (!isGameRunning) return;
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;

            ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

            // Time-based progression
            ballTimer += deltaTime;
            spikeTimer += deltaTime;
            currentGravity += 0.00007; // Slowly getting faster

            // Spawn a new colorful ball every 10 seconds
            if (ballTimer >= 10) {
                entities.push(new Entity('ball'));
                showAlert("NEW BALL ADDED!", "#0ff");
                ballTimer = 0;
            }

            // Random spikes dropping
            if (spikeTimer >= 3.5) {
                entities.push(new Entity('spike'));
                spikeTimer = 0;
            }

            // Draw Paddle
            ctx.fillStyle = paddle.color;
            ctx.shadowBlur = 10;
            ctx.shadowColor = paddle.color;
            ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);
            ctx.shadowBlur = 0;

            // Process all entities
            entities = entities.filter(ent => {
                ent.draw();
                return ent.update();
            });

            animationId = requestAnimationFrame(animate);
        }

        document.getElementById('startBtn').addEventListener('click', initGame);
        document.getElementById('restartBtn').addEventListener('click', initGame);
    </script>
</body>
</html>
