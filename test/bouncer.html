<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<title>Orbit Bounce</title>
<style>
:root {
  --primary: #6366f1;
  --primary-glow: rgba(99, 102, 241, 0.5);
  --gold: #f59e0b;
  --gold-glow: rgba(245, 158, 11, 0.6);
  --cyan: #06b6d4;
  --cyan-glow: rgba(6, 182, 212, 0.6);
  --purple: #a855f7;
  --purple-glow: rgba(168, 85, 247, 0.5);
  --danger: #ef4444;
  --text-main: #f1f5f9;
  --text-muted: #cbd5e1;
  --surface: rgba(15, 23, 42, 0.88);
  --border: rgba(255, 255, 255, 0.1);
  --shadow-lg: 0 20px 50px rgba(0, 0, 0, 0.6);
  --radius-lg: 20px;
  --font-sans: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
}
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  user-select: none;
  -webkit-user-select: none;
  -webkit-touch-callout: none;
  -webkit-tap-highlight-color: transparent;
}
html, body {
  width: 100%;
  height: 100%;
  overflow: hidden;
  position: fixed;
  touch-action: none;
  background: #0c0e1d;
  font-family: var(--font-sans);
  color: var(--text-main);
  -webkit-font-smoothing: antialiased;
}

/* Cosmic background */
.screen-bg {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: radial-gradient(ellipse at bottom, #1a1f36 0%, #0c0e1d 100%),
              url('https://images.unsplash.com/photo-1446776653993-8e92d358a4f0?ixlib=rb-4.0.3&auto=format&fit=crop&w=1920&q=80');
  background-size: cover;
  background-position: center;
  z-index: 1;
}

/* Modal container for all screens */
.screen {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 10;
  padding: 0;
}
.screen-content {
  background: var(--surface);
  backdrop-filter: blur(16px);
  -webkit-backdrop-filter: blur(16px);
  border-radius: var(--radius-lg);
  padding: 5vh 5vw;
  width: 92vw;
  max-width: 600px;
  height: 88vh;
  max-height: 800px;
  display: flex;
  flex-direction: column;
  border: 1px solid var(--border);
  box-shadow: var(--shadow-lg);
  z-index: 11;
  overflow: hidden;
}
.screen.hidden {
  display: none;
}

/* Game-specific styles */
#gameCanvas {
  display: block;
  width: 100%;
  height: 100%;
  touch-action: none;
}

/* HUD */
#hud {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  padding: clamp(12px, 2vh, 18px) clamp(16px, 3vw, 24px);
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  pointer-events: none;
  z-index: 50;
}
.hud-pill {
  background: rgba(20, 25, 50, 0.7);
  border: 1px solid var(--border);
  backdrop-filter: blur(10px);
  padding: clamp(8px, 1.5vh, 12px) clamp(12px, 2.5vw, 16px);
  border-radius: 18px;
  display: flex;
  align-items: center;
  gap: clamp(6px, 1.5vw, 10px);
  box-shadow: 0 4px 12px rgba(0,0,0,0.3);
}
.hud-label {
  font-size: clamp(0.65rem, 2vw, 0.8rem);
  text-transform: uppercase;
  letter-spacing: 0.05em;
  color: var(--text-muted);
  font-weight: 700;
}
.hud-value {
  font-size: clamp(1rem, 3vw, 1.4rem);
  font-weight: 800;
  color: var(--text-main);
  min-width: clamp(30px, 6vw, 45px);
  text-align: right;
}
#lives-container {
  display: flex;
  gap: clamp(5px, 1.5vw, 8px);
}
.heart {
  width: clamp(10px, 2.5vw, 14px);
  height: clamp(10px, 2.5vw, 14px);
  border-radius: 50%;
  background-color: var(--primary);
  box-shadow: 0 0 12px var(--primary-glow);
}
.heart.lost {
  background-color: #334155;
  box-shadow: none;
  opacity: 0.4;
}

/* Notifications */
.notification-text {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%) scale(0.8);
  font-size: clamp(1.5rem, 5vw, 2.5rem);
  font-weight: 800;
  color: #fff;
  text-shadow: 0 4px 20px rgba(0,0,0,0.8);
  opacity: 0;
  pointer-events: none;
  transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
  z-index: 80;
  text-align: center;
  white-space: nowrap;
}
.notification-text.gold { color: var(--gold); text-shadow: 0 0 30px var(--gold-glow), 0 4px 20px rgba(0,0,0,0.8); }
.notification-text.purple { color: var(--purple); text-shadow: 0 0 30px var(--purple-glow), 0 4px 20px rgba(0,0,0,0.8); }
.notification-text.cyan { color: var(--cyan); text-shadow: 0 0 30px var(--cyan-glow), 0 4px 20px rgba(0,0,0,0.8); }

/* Countdown */
#countdownScreen {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: none;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  z-index: 190;
  background: var(--surface);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
}
#countdownScreen.active {
  display: flex;
}
.countdown-sponsor {
  font-size: clamp(1rem, 3vw, 1.4rem);
  margin-bottom: 2vh;
  color: var(--text-muted);
  text-align: center;
  font-weight: 600;
}
.ad-placeholder {
  width: 90%;
  max-width: 300px;
  height: clamp(60px, 12vh, 80px);
  background: rgba(0, 0, 0, 0.3);
  border: 1px dashed rgba(255, 255, 255, 0.2);
  border-radius: 12px;
  display: flex;
  justify-content: center;
  align-items: center;
  color: rgba(255, 255, 255, 0.4);
  font-size: clamp(0.8rem, 2.2vw, 0.9rem);
  margin-top: 1vh;
}
#countdownNumber {
  font-size: clamp(5rem, 20vw, 8rem);
  font-weight: 800;
  color: white;
  margin-top: 1vh;
}

/* Typography */
h1 {
  font-size: clamp(2.8rem, 12vw, 4.8rem);
  font-weight: 800;
  letter-spacing: -0.03em;
  color: var(--text-main);
  margin-bottom: 1.8vh;
  text-align: center;
  line-height: 1.1;
}
h2 {
  font-size: clamp(1.8rem, 6vw, 2.4rem);
  font-weight: 700;
  color: var(--text-main);
  margin-bottom: 1.5vh;
  text-align: center;
}
.subtitle {
  font-size: clamp(0.95rem, 2.8vw, 1.15rem);
  color: var(--text-muted);
  margin-bottom: 3.5vh;
  font-weight: 500;
  max-width: 500px;
  text-align: center;
  line-height: 1.6;
}
.total-label {
  font-size: clamp(0.9rem, 2.5vw, 1.1rem);
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.1em;
  margin-bottom: 1vh;
  font-weight: 600;
  text-align: center;
}
.final-score-display {
  font-size: clamp(2.5rem, 11vw, 4rem);
  font-weight: 800;
  margin: 2vh 0 2.5vh;
  color: var(--text-main);
  line-height: 1;
  text-align: center;
}

/* Buttons */
button {
  padding: clamp(12px, 2.8vh, 18px) clamp(28px, 8vw, 48px);
  font-size: clamp(0.9rem, 2.8vw, 1.05rem);
  font-weight: 700;
  border: none;
  border-radius: 16px;
  cursor: pointer;
  transition: all 0.2s ease;
  text-transform: uppercase;
  letter-spacing: 0.06em;
  touch-action: manipulation;
  min-width: 180px;
  font-family: var(--font-sans);
}
#startBtn, #restartBtn {
  background: var(--primary);
  color: white;
  box-shadow: 0 6px 20px var(--primary-glow);
}
#startBtn:active, #restartBtn:active {
  transform: translateY(2px);
  box-shadow: 0 3px 12px var(--primary-glow);
}
#instructionsBtn {
  background: #475569;
  color: white;
  box-shadow: 0 6px 20px rgba(71, 85, 105, 0.5);
}
#instructionsBtn:active {
  transform: translateY(2px);
  box-shadow: 0 3px 12px rgba(71, 85, 105, 0.5);
}
#exitBtn, #exitBtn2 {
  background: var(--danger);
  color: white;
  box-shadow: 0 6px 20px rgba(239, 68, 68, 0.5);
}
#exitBtn:active, #exitBtn2:active {
  transform: translateY(2px);
  box-shadow: 0 3px 12px rgba(239, 68, 68, 0.5);
}
#shareBtn {
  background: var(--cyan);
  color: white;
  box-shadow: 0 6px 20px var(--cyan-glow);
}
#shareBtn:active {
  transform: translateY(2px);
  box-shadow: 0 3px 12px var(--cyan-glow);
}

/* Stats */
.game-over-stats {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: clamp(12px, 3vw, 20px);
  width: 100%;
  max-width: 400px;
  margin: 1.5vh auto 2.5vh;
}
.stat-box {
  background: rgba(255,255,255,0.05);
  border: 1px solid var(--border);
  padding: clamp(10px, 2.2vh, 16px);
  border-radius: 12px;
  text-align: center;
}
.stat-label {
  font-size: clamp(0.7rem, 2vw, 0.85rem);
  color: var(--text-muted);
  text-transform: uppercase;
  margin-bottom: 0.5vh;
  font-weight: 600;
}
.stat-number {
  font-size: clamp(1.4rem, 4.8vw, 1.9rem);
  font-weight: 800;
  color: var(--text-main);
}

/* Button Group */
.button-group {
  display: flex;
  gap: clamp(12px, 3vw, 20px);
  flex-wrap: wrap;
  justify-content: center;
  margin-top: 1.5vh;
  width: 100%;
}
@media (max-width: 520px) {
  .button-group {
    flex-direction: column;
    align-items: center;
  }
  .button-group button {
    width: 85%;
    max-width: 300px;
  }
}

/* Shake Animation */
.shake {
  animation: shake 0.5s cubic-bezier(.36,.07,.19,.97);
}
@keyframes shake {
  0%, 100% { transform: translateX(0); }
  10%, 30%, 50%, 70%, 90% { transform: translateX(-8px); }
  20%, 40%, 60%, 80% { transform: translateX(8px); }
}
</style>
</head>
<body>
<!-- Cosmic background -->
<div class="screen-bg"></div>

<!-- Start Screen -->
<div id="startScreen" class="screen">
  <div class="screen-content">
    <h1>ORBIT BOUNCE</h1>
    <p class="subtitle">Bounce orbs with precision. Avoid spikes. Survive as long as you can.</p>
    <div class="button-group">
      <button id="startBtn">Start Game</button>
      <button id="instructionsBtn">Instructions</button>
      <button id="exitBtn">Exit</button>
    </div>
  </div>
</div>

<!-- Game Screen (now in modal!) -->
<div id="gameScreen" class="screen hidden">
  <div class="screen-content" id="gameModal">
    <canvas id="gameCanvas"></canvas>
    <div id="hud" style="display: none;">
      <div class="hud-pill">
        <span class="hud-label">Score</span>
        <span id="scoreDisplay" class="hud-value">0</span>
      </div>
      <div class="hud-pill">
        <span class="hud-label">Orbs</span>
        <span id="ballCount" class="hud-value">1</span>
      </div>
      <div class="hud-pill">
        <div id="lives-container">
          <div class="heart"></div>
          <div class="heart"></div>
          <div class="heart"></div>
        </div>
      </div>
    </div>
    <div id="notification" class="notification-text">New Orb</div>
  </div>
</div>

<!-- Countdown -->
<div id="countdownScreen">
  <div class="countdown-sponsor">This game is sponsored by:</div>
  <div class="ad-placeholder">Advertisement Space</div>
  <div id="countdownNumber">5</div>
</div>

<!-- Instructions -->
<div id="instructionsModal" class="screen hidden">
  <div class="screen-content" style="max-width: 500px; height: auto; padding: 4vh 5vw;">
    <h2>How to Play</h2>
    <p class="instructions-text" style="font-size: clamp(0.9rem, 2.8vw, 1.05rem); line-height: 1.7; margin: 1.8vh 0; color: var(--text-main);">
      Drag to move the paddle.<br><br>
      • <strong>Bounce blue orbs</strong> to earn points<br>
      • <strong>Avoid red spikes</strong> — they cost a life<br>
      • <strong>Golden orbs</strong> grant an extra life<br>
      • <strong>Purple orbs</strong> double your paddle size for 5 seconds!<br>
      • <strong>Cyan orbs</strong> double your points for 10 seconds!<br><br>
      Lose all lives and it's game over!
    </p>
    <button id="closeInstructions" style="margin-top: 2vh;">Close</button>
  </div>
</div>

<!-- Game Over Screen (full overlay) -->
<div id="gameOverScreen" class="screen hidden">
  <div class="screen-content" style="max-width: 520px; height: auto; padding: 5vh 5vw;">
    <h2 style="color: var(--danger);">Game Over</h2>
    <div class="total-label">Final Score</div>
    <div class="final-score-display" id="finalScore">0</div>
    <div class="game-over-stats">
      <div class="stat-box">
        <div class="stat-number" id="maxBalls">0</div>
        <div class="stat-label">Max Orbs</div>
      </div>
      <div class="stat-box">
        <div class="stat-number" id="survivalTime">0s</div>
        <div class="stat-label">Survived</div>
      </div>
    </div>
    <div class="button-group">
      <button id="shareBtn">Share Score</button>
      <button id="restartBtn">Play Again</button>
      <button id="exitBtn2">Exit</button>
    </div>
  </div>
</div>

<script>
// CORE SETUP
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false });
const ui = {
  start: document.getElementById('startScreen'),
  game: document.getElementById('gameScreen'),
  over: document.getElementById('gameOverScreen'),
  hud: document.getElementById('hud'),
  score: document.getElementById('scoreDisplay'),
  balls: document.getElementById('ballCount'),
  finalScore: document.getElementById('finalScore'),
  maxBalls: document.getElementById('maxBalls'),
  time: document.getElementById('survivalTime'),
  lives: document.querySelectorAll('.heart'),
  notify: document.getElementById('notification'),
  countdown: document.getElementById('countdownScreen'),
  countdownNum: document.getElementById('countdownNumber'),
  instructionsModal: document.getElementById('instructionsModal'),
  startBtn: document.getElementById('startBtn'),
  instructionsBtn: document.getElementById('instructionsBtn'),
  closeInstructions: document.getElementById('closeInstructions'),
  exitBtn: document.getElementById('exitBtn'),
  exitBtn2: document.getElementById('exitBtn2'),
  restartBtn: document.getElementById('restartBtn'),
  shareBtn: document.getElementById('shareBtn')
};
let animationId, isPlaying = false, lastTime = 0, gameTime = 0, score = 0, lives = 3;
const MAX_LIVES = 5;
let maxBallsActive = 0, entities = [], particles = [];
let nextBallTime = 0, nextSpikeTime = 0, nextGoldTime = 0, nextPowerUpTime = 0, nextDoublePointsTime = 0;
let gameWidth = 0, gameHeight = 0, minBounceY = 0, maxBounceY = 0, doublePointsEndTime = 0;
let paddleDoubled = false, originalPaddleWidth = 0, paddleDoubleEndTime = 0;

const paddle = {
  width: 0, height: 0, x: 0, y: 0, targetX: 0,
  color: '#6366f1', glowColor: 'rgba(99, 102, 241, 0.5)',
  startWidthRatio: 0.35, minWidthRatio: 0.18, shrinkDuration: 150, shrinkDelay: 15
};

// RESIZE (based on modal content)
function resize() {
  const rect = document.getElementById('gameModal').getBoundingClientRect();
  const dpr = Math.min(window.devicePixelRatio || 1, 2);
  gameWidth = rect.width;
  gameHeight = rect.height;
  minBounceY = gameHeight * 0.5;
  maxBounceY = gameHeight * 0.1;
  canvas.width = gameWidth * dpr;
  canvas.height = gameHeight * dpr;
  canvas.style.width = gameWidth + 'px';
  canvas.style.height = gameHeight + 'px';
  ctx.scale(dpr, dpr);
  paddle.height = Math.max(14, gameHeight * 0.016);
  paddle.width = gameWidth * (paddleDoubled ? 0.7 : paddle.startWidthRatio);
  paddle.x = (gameWidth - paddle.width) / 2;
  paddle.targetX = paddle.x;
  paddle.y = gameHeight * 0.82;
}
window.addEventListener('resize', resize);

// INPUT
let touchId = null;
function handlePointerMove(clientX) {
  if (!isPlaying) return;
  const rect = canvas.getBoundingClientRect();
  const x = clientX - rect.left;
  paddle.targetX = x - (paddle.width / 2);
  paddle.targetX = Math.max(0, Math.min(gameWidth - paddle.width, paddle.targetX));
}
canvas.addEventListener('mousemove', (e) => handlePointerMove(e.clientX));
canvas.addEventListener('touchstart', (e) => {
  if (!isPlaying) return;
  e.preventDefault();
  const touch = e.changedTouches[0];
  touchId = touch.identifier;
  handlePointerMove(touch.clientX);
}, { passive: false });
canvas.addEventListener('touchmove', (e) => {
  if (!isPlaying) return;
  e.preventDefault();
  for (let touch of e.changedTouches) {
    if (touch.identifier === touchId) {
      handlePointerMove(touch.clientX);
      break;
    }
  }
}, { passive: false });
canvas.addEventListener('touchend', (e) => {
  for (let touch of e.changedTouches) {
    if (touch.identifier === touchId) {
      touchId = null;
      break;
    }
  }
});
document.body.addEventListener('touchstart', (e) => { if (isPlaying) e.preventDefault(); }, { passive: false });

// EFFECTS
function spawnParticles(x, y, color, count = 10) {
  const maxParts = window.devicePixelRatio > 1 ? 100 : 50;
  if (particles.length > maxParts) return;
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = 2.2 + Math.random() * 4.2;
    particles.push({x, y, dx: Math.cos(angle) * speed, dy: Math.sin(angle) * speed, life: 1.0, size: 2.2 + Math.random() * 3.2, color});
  }
}
function updateParticles() {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.dx;
    p.y += p.dy;
    p.dy += 0.16;
    p.life -= 0.02;
    if (p.life <= 0) { particles.splice(i, 1); } else {
      ctx.globalAlpha = p.life;
      ctx.fillStyle = p.color;
      ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
    }
  }
  ctx.globalAlpha = 1;
}
function showNotification(text, type = '') {
  ui.notify.textContent = text;
  ui.notify.className = 'notification-text active';
  if (type === 'gold') ui.notify.classList.add('gold');
  else if (type === 'purple') ui.notify.classList.add('purple');
  else if (type === 'cyan') ui.notify.classList.add('cyan');
  if (ui.notifyTimeout) clearTimeout(ui.notifyTimeout);
  ui.notifyTimeout = setTimeout(() => { ui.notify.classList.remove('active'); }, 1800);
}

// GAME LOGIC
function updateHUD() {
  const balls = entities.filter(e => e.type === 'ball').length;
  ui.balls.textContent = balls;
  maxBallsActive = Math.max(maxBallsActive, balls);
  ui.lives.forEach((dot, i) => { dot.classList.toggle('lost', i >= lives); });
}
function takeDamage() {
  lives--;
  updateHUD();
  document.getElementById('gameModal').classList.add('shake');
  setTimeout(() => document.getElementById('gameModal').classList.remove('shake'), 500);
  if (lives <= 0) { gameOver(); }
}
function addLife() {
  if (lives < MAX_LIVES) {
    lives++;
    updateHUD();
  }
}
function activatePaddleDouble() {
  paddleDoubled = true;
  paddleDoubleEndTime = gameTime + 5;
  originalPaddleWidth = paddle.width;
  paddle.width = gameWidth * 0.7;
  // Re-center paddle
  const oldCenter = paddle.x + originalPaddleWidth / 2;
  paddle.x = oldCenter - paddle.width / 2;
  paddle.x = Math.max(0, Math.min(gameWidth - paddle.width, paddle.x));
  paddle.targetX = paddle.x;
  showNotification('PADDLE DOUBLED!', 'purple');
}
function activateDoublePoints() {
  doublePointsEndTime = gameTime + 10;
  showNotification('DOUBLE POINTS!', 'cyan');
}
function startCountdown() {
  ui.start.classList.add('hidden');
  ui.countdown.classList.add('active');
  let count = 5;
  ui.countdownNum.textContent = count;
  const interval = setInterval(() => {
    count--;
    if (count > 0) { ui.countdownNum.textContent = count; } else {
      clearInterval(interval);
      ui.countdown.classList.remove('active');
      ui.game.classList.remove('hidden');
      initGame();
    }
  }, 1000);
}
function initGame() {
  resize();
  entities = [new Ball()];
  particles = [];
  score = 0;
  lives = 3;
  gameTime = 0;
  maxBallsActive = 1;
  paddleDoubled = false;
  paddleDoubleEndTime = 0;
  paddle.width = gameWidth * paddle.startWidthRatio;
  paddle.x = (gameWidth - paddle.width) / 2;
  paddle.targetX = paddle.x;
  nextBallTime = 8;
  nextSpikeTime = 25;
  nextGoldTime = 30;
  nextPowerUpTime = 45;
  nextDoublePointsTime = 55;
  updateHUD();
  ui.score.textContent = '0';
  isPlaying = true;
  ui.hud.style.display = 'flex';
  lastTime = performance.now();
  animate(lastTime);
}
function gameOver() {
  isPlaying = false;
  cancelAnimationFrame(animationId);
  doublePointsEndTime = 0;
  paddleDoubled = false;
  ui.finalScore.textContent = score;
  ui.maxBalls.textContent = maxBallsActive;
  ui.time.textContent = Math.floor(gameTime) + 's';
  ui.hud.style.display = 'none';
  ui.game.classList.add('hidden');
  ui.over.classList.remove('hidden');
}

// SHARE
function shareScore() {
  if (navigator.share) {
    navigator.share({
      title: 'Orbit Bounce',
      text: `I scored ${score} points in Orbit Bounce! Can you beat me?`,
      url: window.location.href
    }).catch(console.error);
  } else {
    navigator.clipboard.writeText(`My Orbit Bounce score: ${score}!`).then(() => {
      alert('Score copied to clipboard!');
    });
  }
}

// ENTITIES
class Ball {
  constructor() {
    this.type = 'ball';
    this.radius = Math.max(9, gameWidth * 0.016);
    this.x = gameWidth * (0.15 + Math.random() * 0.7);
    this.y = paddle.y - 32;
    const targetY = minBounceY - Math.random() * (minBounceY - maxBounceY);
    const targetHeight = paddle.y - targetY;
    const gravity = 0.42;
    const requiredVelocity = Math.sqrt(2 * gravity * targetHeight);
    this.dy = -requiredVelocity;
    this.dx = (Math.random() - 0.5) * 4.2;
    this.color = `hsl(${220 + Math.random()*50}, 88%, 64%)`;
    this.trail = [];
  }
  update(dt) {
    const gravity = 0.42;
    this.dy += gravity;
    this.x += this.dx;
    this.y += this.dy;
    this.trail.push({x: this.x, y: this.y});
    if (this.trail.length > 6) this.trail.shift();
    if (this.x < this.radius) { this.x = this.radius; this.dx *= -0.85; }
    if (this.x > gameWidth - this.radius) { this.x = gameWidth - this.radius; this.dx *= -0.85; }
    if (this.dy > 0 && this.y + this.radius >= paddle.y && this.y - this.radius <= paddle.y + paddle.height &&
        this.x >= paddle.x - this.radius && this.x <= paddle.x + paddle.width + this.radius) {
      const targetY = minBounceY - Math.random() * (minBounceY - maxBounceY);
      const targetHeight = paddle.y - targetY;
      const requiredVelocity = Math.sqrt(2 * gravity * targetHeight);
      this.dy = -requiredVelocity * (0.95 + Math.random() * 0.1);
      const hitPos = (this.x - (paddle.x + paddle.width/2)) / (paddle.width/2);
      this.dx = hitPos * 6.2;
      let points = 10;
      if (doublePointsEndTime > gameTime) points *= 2;
      score += points;
      ui.score.textContent = score;
      updateHUD();
      // ✅ NO PARTICLES, NO NOTIFICATION
      return 'hit';
    }
    if (this.y > gameHeight + this.radius * 2) return 'dead';
    return 'alive';
  }
  draw() {
    ctx.globalAlpha = 0.45;
    this.trail.forEach((pos, i) => {
      const size = this.radius * (i / this.trail.length);
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.arc(pos.x, pos.y, size, 0, Math.PI * 2);
      ctx.fill();
    });
    ctx.globalAlpha = 1;
    ctx.shadowBlur = 22;
    ctx.shadowColor = this.color;
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = 'rgba(255,255,255,0.92)';
    ctx.beginPath();
    ctx.arc(this.x - this.radius * 0.3, this.y - this.radius * 0.3, this.radius * 0.25, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
  }
}

class GoldBall {
  constructor() {
    this.type = 'gold';
    this.radius = Math.max(13, gameWidth * 0.023);
    this.x = gameWidth * (0.2 + Math.random() * 0.6);
    this.y = paddle.y - 32;
    const targetY = minBounceY - Math.random() * (minBounceY - maxBounceY);
    const targetHeight = paddle.y - targetY;
    const gravity = 0.42;
    const requiredVelocity = Math.sqrt(2 * gravity * targetHeight);
    this.dy = -requiredVelocity;
    this.dx = (Math.random() - 0.5) * 3.2;
    this.pulse = 0;
    this.color = '#f59e0b';
    this.trail = [];
  }
  update(dt) {
    const gravity = 0.42;
    this.dy += gravity;
    this.x += this.dx;
    this.y += this.dy;
    this.pulse += dt * 6;
    this.trail.push({x: this.x, y: this.y});
    if (this.trail.length > 8) this.trail.shift();
    if (this.x < this.radius) { this.x = this.radius; this.dx *= -0.9; }
    if (this.x > gameWidth - this.radius) { this.x = gameWidth - this.radius; this.dx *= -0.9; }
    if (this.y + this.radius >= paddle.y && this.y - this.radius <= paddle.y + paddle.height &&
        this.x >= paddle.x - this.radius && this.x <= paddle.x + paddle.width + this.radius) {
      return 'hit';
    }
    if (this.y > gameHeight + this.radius * 2) return 'dead';
    return 'alive';
  }
  draw() {
    const r = this.radius + Math.sin(this.pulse) * 2.2;
    ctx.globalAlpha = 0.55;
    this.trail.forEach((pos, i) => {
      const size = r * (i / this.trail.length);
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.arc(pos.x, pos.y, size, 0, Math.PI * 2);
      ctx.fill();
    });
    ctx.globalAlpha = 1;
    ctx.shadowBlur = 32;
    ctx.shadowColor = this.color;
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.arc(this.x, this.y, r, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.shadowBlur = 16;
    ctx.beginPath();
    ctx.arc(this.x - r * 0.25, this.y - r * 0.25, r * 0.3, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
  }
}

class Spike {
  constructor() {
    this.type = 'spike';
    this.size = Math.max(13, gameWidth * 0.021);
    this.x = gameWidth * (0.1 + Math.random() * 0.8);
    this.y = -this.size * 2;
    const speed = 3.2 + (gameTime * 0.026);
    this.dx = (Math.random() - 0.5) * 1.6;
    this.dy = speed;
    this.color = '#ef4444';
    this.rot = Math.random() * Math.PI * 2;
    this.rotSpeed = (Math.random() - 0.5) * 0.13;
  }
  update(dt) {
    this.dy += 0.085;
    this.x += this.dx;
    this.y += this.dy;
    this.rot += this.rotSpeed;
    if (this.x < 0) this.x = gameWidth;
    if (this.x > gameWidth) this.x = 0;
    const expandedHitbox = this.size * 0.7;
    if (this.y + expandedHitbox >= paddle.y && this.y - expandedHitbox <= paddle.y + paddle.height &&
        this.x >= paddle.x - expandedHitbox && this.x <= paddle.x + paddle.width + expandedHitbox) {
      return 'hit';
    }
    if (this.y > gameHeight + this.size * 2) return 'dead';
    return 'alive';
  }
  draw() {
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.rot);
    ctx.shadowBlur = 16;
    ctx.shadowColor = this.color;
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.moveTo(0, -this.size);
    ctx.lineTo(this.size * 0.9, this.size * 0.9);
    ctx.lineTo(-this.size * 0.9, this.size * 0.9);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
    ctx.shadowBlur = 0;
  }
}

// PADDLE DOUBLER (replaces slow-mo)
class PaddleDoubler {
  constructor() {
    this.type = 'paddledoubler';
    this.radius = Math.max(11, gameWidth * 0.019);
    this.x = gameWidth * (0.2 + Math.random() * 0.6);
    this.y = paddle.y - 32;
    const targetY = minBounceY - Math.random() * (minBounceY - maxBounceY);
    const targetHeight = paddle.y - targetY;
    const gravity = 0.42;
    const requiredVelocity = Math.sqrt(2 * gravity * targetHeight);
    this.dy = -requiredVelocity;
    this.dx = (Math.random() - 0.5) * 2.6;
    this.color = '#a855f7';
    this.trail = [];
  }
  update(dt) {
    const gravity = 0.42;
    this.dy += gravity;
    this.x += this.dx;
    this.y += this.dy;
    this.trail.push({x: this.x, y: this.y});
    if (this.trail.length > 7) this.trail.shift();
    if (this.x < this.radius) { this.x = this.radius; this.dx *= -0.85; }
    if (this.x > gameWidth - this.radius) { this.x = gameWidth - this.radius; this.dx *= -0.85; }
    if (this.y + this.radius >= paddle.y && this.y - this.radius <= paddle.y + paddle.height &&
        this.x >= paddle.x - this.radius && this.x <= paddle.x + paddle.width + this.radius) {
      return 'hit';
    }
    if (this.y > gameHeight + this.radius * 2) return 'dead';
    return 'alive';
  }
  draw() {
    ctx.globalAlpha = 0.55;
    this.trail.forEach((pos, i) => {
      const size = this.radius * (i / this.trail.length);
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.arc(pos.x, pos.y, size, 0, Math.PI * 2);
      ctx.fill();
    });
    ctx.globalAlpha = 1;
    ctx.shadowBlur = 26;
    ctx.shadowColor = this.color;
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = 'rgba(255,255,255,0.92)';
    ctx.beginPath();
    ctx.arc(this.x - this.radius * 0.3, this.y - this.radius * 0.3, this.radius * 0.2, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
  }
}

class DoublePointsPowerUp {
  constructor() {
    this.type = 'doublepoints';
    this.radius = Math.max(12, gameWidth * 0.021);
    this.x = gameWidth * (0.2 + Math.random() * 0.6);
    this.y = paddle.y - 32;
    const targetY = minBounceY - Math.random() * (minBounceY - maxBounceY);
    const targetHeight = paddle.y - targetY;
    const gravity = 0.42;
    const requiredVelocity = Math.sqrt(2 * gravity * targetHeight);
    this.dy = -requiredVelocity;
    this.dx = (Math.random() - 0.5) * 2.8;
    this.pulse = 0;
    this.color = '#06b6d4';
    this.trail = [];
  }
  update(dt) {
    const gravity = 0.42;
    this.dy += gravity;
    this.x += this.dx;
    this.y += this.dy;
    this.pulse += dt * 5;
    this.trail.push({x: this.x, y: this.y});
    if (this.trail.length > 8) this.trail.shift();
    if (this.x < this.radius) { this.x = this.radius; this.dx *= -0.85; }
    if (this.x > gameWidth - this.radius) { this.x = gameWidth - this.radius; this.dx *= -0.85; }
    if (this.y + this.radius >= paddle.y && this.y - this.radius <= paddle.y + paddle.height &&
        this.x >= paddle.x - this.radius && this.x <= paddle.x + paddle.width + this.radius) {
      return 'hit';
    }
    if (this.y > gameHeight + this.radius * 2) return 'dead';
    return 'alive';
  }
  draw() {
    const r = this.radius + Math.sin(this.pulse) * 2;
    ctx.globalAlpha = 0.6;
    this.trail.forEach((pos, i) => {
      const size = r * (i / this.trail.length);
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.arc(pos.x, pos.y, size, 0, Math.PI * 2);
      ctx.fill();
    });
    ctx.globalAlpha = 1;
    ctx.shadowBlur = 30;
    ctx.shadowColor = this.color;
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.arc(this.x, this.y, r, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = 'rgba(255,255,255,0.95)';
    ctx.beginPath();
    ctx.arc(this.x - r * 0.28, this.y - r * 0.28, r * 0.25, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
  }
}

// GAME LOOP
let accumulator = 0;
const fixedDeltaTime = 1 / 60;
function animate(timestamp) {
  if (!isPlaying) return;
  const frameTime = (timestamp - lastTime) / 1000;
  lastTime = timestamp;
  const clampedFrameTime = Math.min(frameTime, 0.25);
  accumulator += clampedFrameTime;
  gameTime += clampedFrameTime;
  const gradient = ctx.createLinearGradient(0, 0, 0, gameHeight);
  gradient.addColorStop(0, '#0f172a');
  gradient.addColorStop(1, '#1e293b');
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, gameWidth, gameHeight);
  while (accumulator >= fixedDeltaTime) {
    updateGameLogic(fixedDeltaTime);
    accumulator -= fixedDeltaTime;
  }
  drawEntities();
  animationId = requestAnimationFrame(animate);
}
function updateGameLogic(dt) {
  // Handle paddle doubling expiration
  if (paddleDoubled && gameTime > paddleDoubleEndTime) {
    paddleDoubled = false;
    const oldCenter = paddle.x + paddle.width / 2;
    paddle.width = gameWidth * paddle.startWidthRatio;
    paddle.x = oldCenter - paddle.width / 2;
    paddle.x = Math.max(0, Math.min(gameWidth - paddle.width, paddle.x));
    paddle.targetX = paddle.x;
  }

  if (gameTime > nextBallTime) {
    const ballCount = entities.filter(e => e.type === 'ball').length;
    if (ballCount < 5) {
      entities.push(new Ball());
      nextBallTime = gameTime + (8 + Math.random() * 6);
      showNotification('New Orb');
    }
  }
  if (gameTime > nextSpikeTime) {
    entities.push(new Spike());
    nextSpikeTime = gameTime + (12 + Math.random() * 8);
    showNotification('⚠ Spike');
  }
  if (gameTime > nextGoldTime) {
    entities.push(new GoldBall());
    nextGoldTime = gameTime + 30;
    showNotification('GOLDEN ORB!', 'gold');
  }
  if (gameTime > nextPowerUpTime) {
    entities.push(new PaddleDoubler());
    nextPowerUpTime = gameTime + 60;
  }
  if (gameTime > nextDoublePointsTime) {
    entities.push(new DoublePointsPowerUp());
    nextDoublePointsTime = gameTime + 70;
    showNotification('DOUBLE POINTS!', 'cyan');
  }

  const lerpSpeed = 0.25;
  paddle.x += (paddle.targetX - paddle.x) * lerpSpeed;

  // Apply paddle shrinking only if not doubled
  if (!paddleDoubled && gameTime > paddle.shrinkDelay) {
    const shrinkProgress = Math.min((gameTime - paddle.shrinkDelay) / paddle.shrinkDuration, 1);
    const easeProgress = 1 - Math.pow(1 - shrinkProgress, 3);
    const startWidth = gameWidth * paddle.startWidthRatio;
    const endWidth = gameWidth * paddle.minWidthRatio;
    const newWidth = startWidth - (startWidth - endWidth) * easeProgress;
    const widthDiff = paddle.width - newWidth;
    const relativePos = (paddle.targetX - paddle.x) / paddle.width;
    paddle.x += widthDiff * (0.5 + relativePos * 0.5);
    paddle.width = newWidth;
    paddle.x = Math.max(0, Math.min(gameWidth - paddle.width, paddle.x));
  }

  for (let i = entities.length - 1; i >= 0; i--) {
    const entity = entities[i];
    const status = entity.update(dt);
    if (status === 'dead') {
      if (entity.type === 'ball') { takeDamage(); }
      entities.splice(i, 1);
      updateHUD();
    } else if (status === 'hit') {
      if (entity.type === 'gold') {
        spawnParticles(entity.x, entity.y, '#f59e0b', 20);
        addLife();
        score += 100;
        ui.score.textContent = score;
        showNotification('+1 LIFE', 'gold');
        entities.splice(i, 1);
      } else if (entity.type === 'spike') {
        spawnParticles(entity.x, entity.y, '#ef4444', 15);
        takeDamage();
        entities.splice(i, 1);
      } else if (entity.type === 'paddledoubler') {
        spawnParticles(entity.x, entity.y, '#a855f7', 15);
        activatePaddleDouble();
        entities.splice(i, 1);
      } else if (entity.type === 'doublepoints') {
        spawnParticles(entity.x, entity.y, '#06b6d4', 18);
        activateDoublePoints();
        entities.splice(i, 1);
      }
    }
  }

  const ballCount = entities.filter(e => e.type === 'ball').length;
  if (isPlaying && ballCount === 0 && lives > 0) {
    entities.push(new Ball());
    updateHUD();
  }
}
function drawEntities() {
  const paddleGradient = ctx.createLinearGradient(paddle.x, paddle.y, paddle.x, paddle.y + paddle.height);
  paddleGradient.addColorStop(0, 'rgba(255,255,255,0.25)');
  paddleGradient.addColorStop(1, paddle.color);
  ctx.shadowBlur = 22;
  ctx.shadowColor = paddle.glowColor;
  ctx.fillStyle = paddleGradient;
  ctx.beginPath();
  if (ctx.roundRect) ctx.roundRect(paddle.x, paddle.y, paddle.width, paddle.height, 10);
  else ctx.rect(paddle.x, paddle.y, paddle.width, paddle.height);
  ctx.fill();
  ctx.shadowBlur = 0;
  ctx.fillStyle = 'rgba(255,255,255,0.35)';
  ctx.beginPath();
  if (ctx.roundRect) ctx.roundRect(paddle.x, paddle.y, paddle.width, paddle.height * 0.4, [10, 10, 0, 0]);
  else ctx.rect(paddle.x, paddle.y, paddle.width, paddle.height * 0.4);
  ctx.fill();

  for (const entity of entities) entity.draw();
  updateParticles();
}

// EVENT LISTENERS
ui.startBtn.addEventListener('click', startCountdown);
ui.instructionsBtn.addEventListener('click', () => { ui.instructionsModal.classList.remove('hidden'); });
ui.closeInstructions.addEventListener('click', () => { ui.instructionsModal.classList.add('hidden'); });
ui.restartBtn.addEventListener('click', () => { ui.over.classList.add('hidden'); startCountdown(); });
ui.exitBtn.addEventListener('click', () => { ui.start.classList.remove('hidden'); ui.over.classList.add('hidden'); });
ui.exitBtn2.addEventListener('click', () => { ui.over.classList.add('hidden'); ui.start.classList.remove('hidden'); });
ui.shareBtn.addEventListener('click', shareScore);
canvas.addEventListener('contextmenu', (e) => e.preventDefault());
document.addEventListener('visibilitychange', () => { if (document.hidden && isPlaying) lastTime = performance.now(); });
</script>
</body>
</html>
