<!DOCTYPE html>
<html lang="en">
<head> 
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Minnesota Then | Museum Without Walls</title>
    <link rel="shortcut icon" type="image/x-icon" href="https://www.mnthen.com/images/mnthenfav.ico">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css">
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css" />
    
    <style>
        :root {
            --primary-color: #005f9e;
            --secondary-color: #004b7d;
            --hover-color: #e6f2fa;
            --text-color: #333333;
            --light-text: #ffffff;
            --background-color: #f8f9fa;
            --border-color: #dee2e6;
            --success-color: #28a745;
            --warning-color: #ffc107;
            --danger-color: #dc3545;
            --shadow-color: rgba(0, 0, 0, 0.1);
            --safe-bottom: env(safe-area-inset-bottom, 0px);
            --safe-top: env(safe-area-inset-top, 0px);
            --modal-width: 90%;
            --modal-max-width: 400px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            overflow: hidden;
            position: relative;
            height: 100vh;
            width: 100vw;
            background-color: var(--background-color);
            color: var(--text-color);
        }

        #map {
            height: 100vh;
            width: 100vw;
            z-index: 1;
        }

        /* User marker styling - Removed blue circle as requested */
        .user-marker-icon {
            width: 24px;
            height: 24px;
            background-color: #ff3b30; /* Red user icon */
            border: 3px solid white;
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            transition: all 0.3s ease;
            position: relative;
            will-change: transform;
        }

        .user-marker-icon::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 36px;
            height: 36px;
            background-color: rgba(255, 59, 48, 0.2);
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        /* Accuracy circle for user location */
        .accuracy-circle {
            border-radius: 50%;
            border: 1px solid rgba(255, 59, 48, 0.5);
            background-color: rgba(255, 59, 48, 0.1);
            will-change: transform, opacity;
            transition: all 0.3s ease;
        }

        /* Custom marker cluster styling - DARK GREEN as requested */
        .marker-cluster-custom {
            background-color: rgba(0, 100, 0, 0.6); /* Dark green background */
            border-radius: 50%;
            width: 40px !important;
            height: 40px !important;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid white;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
        }

        .marker-cluster-custom div {
            width: 34px;
            height: 34px;
            border-radius: 50%;
            background-color: rgba(0, 100, 0, 0.8); /* Darker green inner circle */
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .marker-cluster-custom span {
            color: white;
            font-weight: bold;
            font-size: 14px;
        }

        /* Custom pin icon */
        .custom-pin-icon {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .pin-head {
            width: 30px;
            height: 30px;
            border-radius: 50% 50% 50% 0;
            background-color: #0f2bab;
            transform: rotate(-45deg);
            position: relative;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            border: 2px solid white;
        }

        .pin-head::after {
            content: '';
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: white;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        /* Distance box styling */
        #distanceBox {
            position: fixed;
            top: max(20px, calc(var(--safe-top) + 10px));
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(255, 255, 255, 0.95);
            padding: 12px 24px;
            border-radius: 30px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            font-weight: 600;
            font-size: 18px;
            color: var(--primary-color);
            text-align: center;
            transition: all 0.3s cubic-bezier(0.25, 0.1, 0.25, 1);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.7);
            will-change: transform, opacity;
            max-width: 90%;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Map buttons container */
        .map-buttons-container {
            position: fixed;
            bottom: max(20px, calc(var(--safe-bottom) + 20px));
            left: 0;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            padding: 0 10px;
        }

        .map-buttons {
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: center;
            gap: 24px;
            background-color: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border-radius: 50px;
            padding: 12px 24px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
            will-change: transform;
        }

        .map-button {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-color: white;
            color: var(--primary-color);
            border: none;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.25, 0.1, 0.25, 1);
            font-size: 24px;
            -webkit-tap-highlight-color: transparent;
        }

        .map-button:hover {
            background-color: var(--hover-color);
            transform: translateY(-2px);
        }

        .map-button:active {
            transform: scale(0.95);
        }

        .map-button.active {
            background-color: var(--primary-color);
            color: white;
        }

        /* Navigation tips */
        .navigation-tips {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1500;
            background-color: rgba(0, 0, 0, 0.5);
        }

        .navigation-tips-content {
            background-color: white;
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.2);
            width: var(--modal-width);
            max-width: var(--modal-max-width);
            will-change: transform, opacity;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .navigation-tips h3 {
            font-size: 26px;
            font-weight: 600;
            margin-bottom: 20px;
            color: var(--primary-color);
            text-align: center;
        }

        .navigation-tips ul {
            padding-left: 24px;
            margin-bottom: 0;
        }

        .navigation-tips li {
            margin-bottom: 16px;
            font-size: 20px;
            line-height: 1.5;
        }

        .navigation-tips .close-button {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: var(--dark-gray);
            -webkit-tap-highlight-color: transparent;
            padding: 8px;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Location hunt container */
        .lochunt-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: white;
            z-index: 2000;
            display: none;
            flex-direction: column;
            overflow: hidden;
        }

        .lochunt-content {
            padding: 25px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .lochunt-info {
            text-align: center;
            margin-bottom: 25px;
        }

        /* Audio player */
        .audio-player {
            width: 100%;
            max-width: 400px;
            margin-bottom: 25px;
        }

        .audio-progress {
            width: 100%;
            margin-bottom: 15px;
        }

        .progress {
            height: 10px;
            background-color: #e2e8f0;
            border-radius: 5px;
            overflow: hidden;
            cursor: pointer;
        }

        .progress-bar {
            height: 100%;
            background-color: var(--primary-color);
            width: 0%;
            transition: width 0.1s linear;
        }

        .audio-time {
            display: flex;
            justify-content: space-between;
            color: #666;
            font-size: 16px;
            margin-bottom: 15px;
        }

        .audio-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .audio-button {
            background-color: white;
            color: var(--primary-color);
            border: 2px solid var(--primary-color);
            border-radius: 50%;
            width: 55px;
            height: 55px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 20px;
        }

        .audio-button:hover {
            background-color: var(--hover-color);
        }

        .audio-button:active {
            transform: scale(0.95);
        }

        /* Additional info container */
        .additional-info-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: white;
            z-index: 2500;
            display: none;
            padding: 30px 20px;
            text-align: center;
            overflow-y: auto;
        }

        .additional-info-container h3 {
            color: var(--primary-color);
            margin-bottom: 25px;
            font-size: 26px;
            font-weight: 600;
        }

        .additional-info-container p {
            margin-bottom: 30px;
            line-height: 1.6;
            font-size: 18px;
        }

        /* Custom popup */
        .custom-popup {
            margin-bottom: 10px;
        }

        .custom-popup .leaflet-popup-content-wrapper {
            border-radius: 15px;
            padding: 0;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .custom-popup .leaflet-popup-content {
            margin: 0;
            width: 280px !important;
        }

        .popup-content {
            display: flex;
            flex-direction: column;
        }

        .location-image {
            width: 100%;
            height: 180px;
            object-fit: cover;
        }

        .location-name {
            padding: 15px;
            margin: 0;
            font-size: 18px;
            font-weight: 600;
            color: var(--text-color);
            text-align: center;
        }

        .popup-buttons {
            display: flex;
            border-top: 1px solid var(--border-color);
        }

        .popup-buttons .button {
            flex: 1;
            padding: 12px;
            background: none;
            border: none;
            font-size: 16px;
            font-weight: 500;
            color: var(--primary-color);
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .popup-buttons .button:first-child {
            border-right: 1px solid var(--border-color);
        }

        .popup-buttons .button:hover {
            background-color: var(--hover-color);
        }

        /* Summary Modal */
        #summaryModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.75);
            z-index: 3000;
            padding: 16px;
            backdrop-filter: blur(4px);
            will-change: opacity;
        }

        #summaryModal .modal-content {
            background-color: white;
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.2);
            max-width: var(--modal-max-width);
            width: var(--modal-width);
            max-height: 80vh;
            overflow-y: auto;
            text-align: left;
            font-size: 20px;
            line-height: 1.6;
            will-change: transform;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        /* Loading animation */
        .loading-spinner {
            display: inline-block;
            width: 30px;
            height: 30px;
            border: 3px solid rgba(0, 95, 158, 0.3);
            border-radius: 50%;
            border-top-color: var(--primary-color);
            animation: spin 1s ease-in-out infinite;
            margin-right: 10px;
            vertical-align: middle;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Pulse animation for distance indicator */
        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(2); opacity: 0; }
        }

        .pulse {
            animation: pulse-box 2s infinite;
        }

        @keyframes pulse-box {
            0% { box-shadow: 0 0 0 0 rgba(0, 95, 158, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(0, 95, 158, 0); }
            100% { box-shadow: 0 0 0 0 rgba(0, 95, 158, 0); }
        }

        /* Transition animations */
        .fade-in {
            animation: fadeIn 0.3s forwards;
        }

        .fade-out {
            animation: fadeOut 0.3s forwards;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes fadeOut {
            from { opacity: 1; transform: translateY(0); }
            to { opacity: 0; transform: translateY(10px); }
        }

        /* Modal animations */
        .modal-fade-in {
            animation: modalFadeIn 0.3s forwards;
        }

        .modal-fade-out {
            animation: modalFadeOut 0.3s forwards;
        }

        @keyframes modalFadeIn {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }

        @keyframes modalFadeOut {
            from { opacity: 1; transform: scale(1); }
            to { opacity: 0; transform: scale(0.95); }
        }

        /* Accessibility improvements */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }

        /* Focus styles for better keyboard navigation */
        button:focus-visible, a:focus-visible {
            outline: 3px solid rgba(0, 95, 158, 0.5);
            outline-offset: 2px;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            #distanceBox {
                top: max(15px, calc(var(--safe-top) + 10px));
                padding: 10px 20px;
                font-size: 22px;
            }

            .map-buttons {
                bottom: max(15px, calc(var(--safe-bottom) + 15px));
                gap: 12px;
            }

            .map-button {
                width: 50px;
                height: 50px;
                font-size: 20px;
            }

            .audio-button {
                width: 50px;
                height: 50px;
                font-size: 18px;
            }
        }

        @media (max-width: 480px) {
            #summaryModal .modal-content {
                max-width: 95%;
                max-height: 95vh;
                padding: 20px;
            }
            
            .navigation-tips-content {
                width: 95%;
                max-width: 95%;
                padding: 20px;
            }
            
            .navigation-tips li {
                font-size: 18px;
                margin-bottom: 10px;
            }
        }

        /* Location error modal - CENTERED as requested */
        .location-error-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 3000;
            background-color: rgba(0, 0, 0, 0.5);
        }

        .location-error-content {
            background-color: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.2);
            width: 90%;
            max-width: 400px;
            text-align: center;
        }

        .modal-title {
            font-size: 22px;
            margin-bottom: 15px;
            color: var(--primary-color);
        }

        .modal-message {
            font-size: 16px;
            margin-bottom: 25px;
            line-height: 1.5;
        }

        .modal-button {
            padding: 12px 25px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            transition: background-color 0.2s;
        }

        .modal-button:hover {
            background-color: var(--secondary-color);
        }

        /* Modal container - CENTERED as requested */
        .modal-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.75);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 3000;
            padding: 16px;
            backdrop-filter: blur(4px);
        }
        
        .modal-box {
            background-color: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.2);
            width: 90%;
            max-width: 400px;
            text-align: center;
        }

        .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
        }

        .modal-button.secondary {
            background-color: #f2f2f2;
            color: #333;
        }

        .modal-button.secondary:hover {
            background-color: #e0e0e0;
        }

        /* Loading message */
        #loadingMessage {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 15px;
            z-index: 3000;
            display: flex;
            align-items: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }
        
        /* Auto-recenter indicator */
        #autoRecenterIndicator {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 3500;
        }
        
        #autoRecenterIndicator.visible {
            opacity: 1;
        }

        /* Enhanced visual feedback */
        .haptic-feedback {
            animation: haptic 0.15s ease-in-out;
        }

        @keyframes haptic {
            0% { transform: scale(1); }
            50% { transform: scale(0.97); }
            100% { transform: scale(1); }
        }

        /* Improved accessibility for interactive elements */
        .interactive {
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .interactive:active {
            transform: scale(0.98);
        }

        /* Improved visual hierarchy */
        .primary-heading {
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--primary-color);
            margin-bottom: 1rem;
        }

        .secondary-heading {
            font-size: 1.4rem;
            font-weight: 600;
            color: var(--secondary-color);
            margin-bottom: 0.8rem;
        }

        /* Improved touch targets for mobile */
        @media (max-width: 480px) {
            .touch-target {
                min-height: 44px;
                min-width: 44px;
            }
        }

        /* Debug overlay - for development only */
        #debugOverlay {
            position: fixed;
            bottom: 100px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 5000;
            max-width: 300px;
            display: none;
        }

        /* Motion path visualization - for development only */
        #motionPath {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 900;
            pointer-events: none;
        }

        .motion-path-point {
            position: absolute;
            width: 4px;
            height: 4px;
            background-color: rgba(255, 0, 0, 0.6);
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        .predicted-path-point {
            position: absolute;
            width: 4px;
            height: 4px;
            background-color: rgba(0, 255, 0, 0.6);
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <div id="distanceBox">Initializing...</div>
    <div id="autoRecenterIndicator">Auto-recentering in <span id="recenterCountdown">5</span>s</div>

    <div class="lochunt-container">
        <img id="locationImage" src="/placeholder.svg" alt="Location Image">
        <div class="lochunt-content">
            <div class="lochunt-info">
                <h2 id="locationTitle" class="mb-2 text-primary"></h2>
                <p id="locationCity" class="text-muted mb-1"></p>
                <p id="locationCreator" class="text-muted mb-3"></p>
            </div>
            <div class="audio-player">
                <div class="audio-progress">
                    <div class="progress">
                        <div id="progressBar" class="progress-bar" role="progressbar" style="width: 0%"></div>
                    </div>
                </div>
                <div class="audio-time">
                    <span id="currentTime">0:00</span>
                    <span id="duration">0:00</span>
                </div>
                <div class="audio-controls">
                    <button id="rewindBtn" class="audio-button touch-target" aria-label="Rewind 10 seconds"><i class="fas fa-backward"></i></button>
                    <button id="playPauseBtn" class="audio-button touch-target" aria-label="Play"><i class="fas fa-play"></i></button>
                    <button id="forwardBtn" class="audio-button touch-target" aria-label="Forward 10 seconds"><i class="fas fa-forward"></i></button>
                </div>
                <audio id="locationAudio" src="/placeholder.svg" preload="auto"></audio>
            </div>
        </div>
    </div>

    <div class="additional-info-container">
        <h3 class="mb-3 text-primary text-center">Did You Know?</h3>
        <p id="additionalInfo" class="mb-3 fs-6"></p>
        <div class="d-flex justify-content-center">
            <button id="continueButton" class="btn btn-primary touch-target">Continue</button>
        </div>
    </div>

    <div class="map-buttons-container">
        <div class="map-buttons">
            <button id="recenterButton" class="map-button touch-target" aria-label="Recenter map"><i class="fas fa-crosshairs"></i></button>
            <button id="returnButton" class="map-button touch-target" aria-label="Return to home"><i class="fas fa-sign-out-alt"></i></button>
            <button id="tipsButton" class="map-button touch-target" aria-label="Navigation tips"><i class="fas fa-question-circle"></i></button>
        </div>
    </div>

    <!-- Navigation tips -->
    <div class="navigation-tips">
        <div class="navigation-tips-content">
            <button class="close-button touch-target" aria-label="Close tips">&times;</button>
            <h3>Navigation Tips</h3>
            <ul>
                <li>Use the map to navigate to the marked locations.</li>
                <li>The distance box shows how far you are from the current location.</li>
                <li>Tap the recenter button to focus on your current position.</li>
                <li>When you're within 20 feet of a location, you'll be able to interact with it.</li>
                <li>Listen to the audio information for each location.</li>
                <li>After the audio, you'll see additional information about the location.</li>
            </ul>
        </div>
    </div>

    <div id="summaryModal" class="modal">
        <div class="modal-content">
            <p id="summaryContent"></p>
        </div>
    </div>

    <!-- Debug overlay - hidden by default -->
    <div id="debugOverlay">
        <div id="debugInfo">Debug information will appear here</div>
    </div>

    <!-- Motion path visualization - for development only -->
    <div id="motionPath"></div>

    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"></script>
    <script src="/locations_test.js?v=1.0.4"></script>

    <script>
    // *******************************************************
    // * CORE APPLICATION VARIABLES AND CONSTANTS
    // *******************************************************
    
    // Core application variables
    let map, userMarker, userAccuracyCircle, markerClusterGroup;
    let currentLocationIndex = 0;
    let visitedLocations = [];
    let gameLocations = [];
    let isLocationHuntVisible = false;
    let followUser = true;
    let locationCooldowns = {};
    let lastVisitedLocationId = null;
    let isMapInteracting = false;
    let lastRecenterTime = 0;
    let autoRecenterCountdown = 5;
    let autoRecenterInterval = null;
    let lastZoomLevel = null;
    let userInteractionTime = Date.now();
    let isSummaryModalOpen = false;
    let activeModals = [];
    let imageCache = {};
    let locationImagePreloaded = false;
    let pendingLocationImages = new Set();
    let imagePreloadQueue = [];
    let isPreloadingImages = false;

    // Animation and physics variables
    let animationFrameId = null;
    let lastAnimationTimestamp = 0;
    let physicsUpdateAccumulator = 0;
    let pendingVisualUpdate = null;

    // Motion tracking variables
    let lastPosition = null;
    let lastRawPosition = null;
    let lastUpdateTime = null;
    let positionBuffer = [];
    let filteredPosition = null;
    let lastVelocity = { lat: 0, lng: 0 };
    let lastAcceleration = { lat: 0, lng: 0 };
    let lastHeading = null;
    let headingBuffer = [];
    let lastPredictedPosition = null;
    let stationaryCount = 0;
    let lastSmoothedPosition = null;
    let rejectedPositions = [];
    let isFirstFewUpdates = true;
    let updateCount = 0;
    let pendingPosition = null;
    let retryCount = 0;
    let inactivityTimer = null;
    let recenterTimer = null;
    let stationaryStartTime = null;
    let isStationary = false;
    let stationaryBuffer = [];
    let stationaryPosition = null;
    let stationaryCheckTimeout = null;
    let lastHiddenTime = 0;
    let lastKnownPosition = null;

    // Configuration constants
    const DISTANCE_THRESHOLD = 20; // should be 20 feet (6.096 meters)
    const MAX_BUFFER_SIZE = 8; // Increased buffer size for better smoothing
    const MAX_HEADING_BUFFER_SIZE = 5;
    const MAX_ACCEPTABLE_ACCURACY = 45; // meters
    const MAX_REJECTED_POSITIONS = 10;
    const BACKGROUND_THRESHOLD = 25000; // ms
    const INACTIVITY_TIMEOUT = 30000; // ms
    const PHYSICS_UPDATE_INTERVAL = 1000 / 60; // 60 Hz physics updates
    const RENDER_UPDATE_INTERVAL = 1000 / 60; // 60 Hz render updates
    const MIN_UPDATE_INTERVAL = 0.05; // seconds between updates
    const MICRO_MOVEMENT_THRESHOLD = 0.3; // meters
    const MIN_STATIONARY_THRESHOLD = 0.2; // meters
    const STATIONARY_ACCURACY_MULTIPLIER = 1.1;
    const MAX_SPEED = 50; // m/s
    const MIN_DISTANCE_THRESHOLD = 1.5; // meters
    const VELOCITY_DECAY = 0.85;
    const ACCELERATION_DECAY = 0.7;
    const BEARING_WEIGHT = 0.35;
    const SMOOTHING_FACTOR = 0.25;
    const EXTENDED_DISTANCE_THRESHOLD = 100; // meters
    const STATIONARY_THRESHOLD = 3;
    const STATIONARY_TIME_THRESHOLD = 5000; // ms
    const STATIONARY_CHECK_INTERVAL = 2500; // ms
    const STATIONARY_SMOOTHING = 0.95;
    const STATIONARY_BUFFER_SIZE = 12;
    const STATIONARY_ACCURACY_WEIGHT = 0.7;
    const STATIONARY_THRESHOLD_B = 3;
    const MAX_ALPHA = 0.25;
    const MIN_ALPHA = 0.02;
    const MIN_EXPECTED_ACCURACY = 5; // meters
    const MAX_RETRIES = 3;
    const RETRY_DELAY = 1000; // ms
    const EDGE_THRESHOLD_PERCENTAGE = 0.10; // 10% from edge of screen
    const STRICT_EDGE_THRESHOLD_PERCENTAGE = 0.07; // 7% from edge for strict recenter
    const CRITICAL_EDGE_THRESHOLD_PERCENTAGE = 0.05; // 5% from edge for critical recenter
    const MAX_ACCURACY_THRESHOLD = 2500;
    const TARGET_ACCURACY_THRESHOLD = 100;
    const MIN_RECENTER_INTERVAL = 2000; // ms
    const AUTO_RECENTER_INTERVAL = 30000; // 30 seconds for auto-recenter
    const AUTO_RECENTER_COUNTDOWN_START = 5; // seconds before auto-recenter to show countdown
    const FIRST_LOCATION_TIMEOUT = 10000; // 10 seconds for first location attempt
    const SECOND_LOCATION_TIMEOUT = 5000; // 5 seconds for second location attempt
    const SPEED_ZOOM_THRESHOLDS = [
        { speed: 35, zoom: 14 },  // Highway speeds
        { speed: 25, zoom: 15 },  // Major roads
        { speed: 15, zoom: 16 },  // Urban driving
        { speed: 8, zoom: 17 },   // Slow driving - bicycling
    ];
    const IMAGE_PRELOAD_BATCH_SIZE = 3; // Number of images to preload at once
    const IMAGE_PRELOAD_DELAY = 200; // ms between batches
    const IMAGE_PRELOAD_TIMEOUT = 5000; // ms timeout for image preloading
    const HAPTIC_FEEDBACK_DURATION = 10; // ms
    const PREDICTION_THRESHOLD = 150; // ms - time threshold to apply motion prediction
    const VISUAL_UPDATE_DURATION = 50; // ms - time for visual transition
    const CONFIDENCE_DECAY_RATE = 0.85; // Decay rate for confidence in predictions
    const PATH_VISUALIZATION_MAX_POINTS = 50; // Maximum number of points for path visualization
    const DEBUG_MODE = false; // Set to true to enable debug overlay

    // *******************************************************
    // * INITIALIZATION FUNCTIONS
    // *******************************************************

    // Initialize map and core functionality
    function initMap() {
        try {
            // Create map with optimized settings
            map = L.map('map', {
                zoomControl: false,
                attributionControl: false,
                zoomSnap: 0.1,
                zoomDelta: 0.5,
                wheelDebounceTime: 100,
                tapTolerance: 15,
                bounceAtZoomLimits: false,
                preferCanvas: true, // Better performance for many markers
                renderer: L.canvas({ padding: 0.5 })
            }).fitWorld();

            // Add tile layer with performance optimizations
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 19,
                attribution: '© OpenStreetMap contributors',
                updateWhenIdle: true,
                updateWhenZooming: false,
                keepBuffer: 2
            }).addTo(map);

            // Initialize marker cluster group with custom styling
            markerClusterGroup = L.markerClusterGroup({
                showCoverageOnHover: false,
                zoomToBoundsOnClick: true,
                spiderfyOnMaxZoom: true,
                animate: true,
                animateAddingMarkers: true,
                chunkedLoading: true,
                chunkProgress: updateLoadingStatus,
                maxClusterRadius: function(zoom) {
                    return zoom > 16 ? 40 : 80; // Adaptive clustering based on zoom
                },
                iconCreateFunction: function(cluster) {
                    return L.divIcon({
                        html: '<div><span>' + cluster.getChildCount() + '</span></div>',
                        className: 'marker-cluster-custom',
                        iconSize: L.point(40, 40)
                    });
                }
            });
            map.addLayer(markerClusterGroup);

            // Create user location marker with RED color
            const userIcon = L.divIcon({
                className: 'user-marker',
                html: '<div class="user-marker-icon"></div>',
                iconSize: [20, 20],
                iconAnchor: [10, 10]
            });
            
            userMarker = L.marker([0, 0], { 
                icon: userIcon, 
                zIndexOffset: 1000,
                interactive: false // Prevent clicks on user marker
            }).addTo(map);
            
            // Add accuracy circle
            userAccuracyCircle = L.circle([0, 0], {
                radius: 10,
                className: 'accuracy-circle',
                interactive: false, // Prevent clicks on accuracy circle
                pane: 'overlayPane' // Place in overlay pane to be above tile layer but below markers
            }).addTo(map);
            
            showLoadingMessage();

            // Initialize geolocation with fallback
            if ("geolocation" in navigator) {
                const options = {
                    enableHighAccuracy: true,
                    timeout: FIRST_LOCATION_TIMEOUT,
                    maximumAge: 0
                };

                // Try to get initial position with retry
                navigator.geolocation.getCurrentPosition(
                    initializeUserLocation,
                    (error) => {
                        // On error, try one more time with shorter timeout
                        console.log("First location attempt failed, trying again with shorter timeout");
                        navigator.geolocation.getCurrentPosition(
                            initializeUserLocation,
                            handleLocationError,
                            {
                                enableHighAccuracy: true,
                                timeout: SECOND_LOCATION_TIMEOUT,
                                maximumAge: 0
                            }
                        );
                    },
                    options
                );
            } else {
                showPopup("Geolocation Error", "Geolocation is not supported by your browser");
                map.setView([44.9778, -93.2650], 19); // Default to Minneapolis
                hideLoadingMessage();
            }
            
            // Set up event listeners
            document.addEventListener('visibilitychange', handleVisibilityChange);

            map.on('movestart zoomstart', () => {
                followUser = false;
                isMapInteracting = true;
                userInteractionTime = Date.now();
                stopAutoRecenterCountdown();
                
                // Store current zoom level
                lastZoomLevel = map.getZoom();
            });

            map.on('moveend zoomend', () => {
                isMapInteracting = false;
                resetInactivityTimer();
                startAutoRecenterTimer();
            });

            // Enable touch interactions
            map.touchZoom.enable();
            map.doubleClickZoom.enable();
            
            // Add debug overlay if debug mode is enabled
            if (DEBUG_MODE) {
                document.getElementById('debugOverlay').style.display = 'block';
            }
            
            // Start auto-recenter timer
            startAutoRecenterTimer();
            
            // Setup UI event listeners
            addUIEventListeners();
            addMapEventListeners();
        } catch (error) {
            console.error("Error initializing map:", error);
            showPopup("Application Error", "There was a problem initializing the map. Please refresh the page and try again.");
        }
    }

    // Improved image preloading system
    function preloadLocationImages() {
        if (locationImagePreloaded || !gameLocations || !gameLocations.length) return;
        
        console.log("Starting to preload location images...");
        
        // Create a queue of locations to preload
        imagePreloadQueue = gameLocations
            .filter(location => location && location.image && typeof location.image === 'string')
            .map(location => ({
                id: location.id,
                image: location.image,
                priority: 0 // Default priority
            }));
        
        // Sort by priority (can be adjusted based on distance later)
        imagePreloadQueue.sort((a, b) => b.priority - a.priority);
        
        // Start preloading process
        processImagePreloadQueue();
        
        // Mark as started
        locationImagePreloaded = true;
    }
    
    // Process the image preload queue
    function processImagePreloadQueue() {
        if (isPreloadingImages || imagePreloadQueue.length === 0) return;
        
        isPreloadingImages = true;
        
        // Take the next batch of locations
        const batch = imagePreloadQueue.splice(0, IMAGE_PRELOAD_BATCH_SIZE);
        
        // Track successful loads in this batch
        let loadedCount = 0;
        let totalCount = batch.length;
        
        // Function to check if batch is complete
        const checkBatchComplete = () => {
            loadedCount++;
            if (loadedCount >= totalCount) {
                isPreloadingImages = false;
                
                // Schedule next batch with delay
                if (imagePreloadQueue.length > 0) {
                    setTimeout(processImagePreloadQueue, IMAGE_PRELOAD_DELAY);
                } else {
                    console.log("All location images preloaded successfully");
                }
            }
        };
        
        // Preload each image in the batch
        batch.forEach(item => {
            if (imageCache[item.id]) {
                // Already cached
                checkBatchComplete();
                return;
            }
            
            pendingLocationImages.add(item.id);
            
            const img = new Image();
            img.crossOrigin = "anonymous";
            
            // Set up load timeout
            const timeoutId = setTimeout(() => {
                console.warn(`Image load timeout for location ${item.id}`);
                pendingLocationImages.delete(item.id);
                checkBatchComplete();
            }, IMAGE_PRELOAD_TIMEOUT);
            
            img.onload = () => {
                clearTimeout(timeoutId);
                imageCache[item.id] = img;
                pendingLocationImages.delete(item.id);
                console.log(`Preloaded image for location ${item.id}`);
                checkBatchComplete();
            };
            
            img.onerror = (error) => {
                clearTimeout(timeoutId);
                pendingLocationImages.delete(item.id);
                console.error(`Failed to preload image for location ${item.id}:`, error);
                checkBatchComplete();
            };
            
            img.src = item.image;
        });
    }

    // Provide haptic feedback if available
    function provideHapticFeedback() {
        try {
            if ('vibrate' in navigator && HAPTIC_FEEDBACK_DURATION > 0) {
                navigator.vibrate(HAPTIC_FEEDBACK_DURATION);
            }
        } catch (error) {
            console.warn("Haptic feedback error:", error);
            // Silently fail - haptic feedback is non-critical
        }
    }

    function initializeUserLocation(position) {
        try {
            console.log("Initial position data:", position.coords);

            if (!position || !position.coords) {
                console.error("Invalid initial position object");
                handleLocationError(new Error("Invalid initial position"));
                return;
            }

            const { latitude: userLat, longitude: userLng, accuracy } = position.coords;

            if (isNaN(userLat) || isNaN(userLng)) {
                console.error("Invalid initial coordinates:", { userLat, userLng });
                handleLocationError(new Error("Invalid initial coordinates"));
                return;
            }

            console.log("Valid initial position:", { userLat, userLng, accuracy });

            // Set initial user location
            userMarker.setLatLng([userLat, userLng]);
            userAccuracyCircle.setLatLng([userLat, userLng]);
            userAccuracyCircle.setRadius(accuracy);
            
            map.setView([userLat, userLng], 19);
            lastZoomLevel = 19; // Store initial zoom level
            
            // Initialize tracking variables
            lastPosition = {
                lat: userLat,
                lng: userLng,
                accuracy: accuracy || 20,
                heading: position.coords.heading,
                speedMPS: position.coords.speed || 0,
                timestamp: Date.now(),
                altitude: position.coords.altitude,
                altitudeAccuracy: position.coords.altitudeAccuracy
            };
            
            lastRawPosition = {...lastPosition};
            lastUpdateTime = Date.now();
            positionBuffer = [lastPosition];
            headingBuffer = position.coords.heading ? [position.coords.heading] : [];
            
            // Initialize Kalman filter
            kalmanFilter.reset(lastPosition);
            
            hideLoadingMessage();
            startPositionUpdates();
            startHunt();
            startSmoothAnimationLoop();
            
            // Pulse the distance box to draw attention
            const distanceBox = document.getElementById('distanceBox');
            distanceBox.classList.add('pulse');
            setTimeout(() => distanceBox.classList.remove('pulse'), 3000);
            
            // For first few updates, be more responsive
            isFirstFewUpdates = true;
            setTimeout(() => {
                isFirstFewUpdates = false;
            }, 15000); // 15 seconds of more responsive initial updates
        } catch (error) {
            console.error("Error setting initial user location:", error);
            handleLocationError(error);
        }
    }

    function startPositionUpdates() {
        try {
            // Use high accuracy watchPosition with optimized settings
            navigator.geolocation.watchPosition(
                handlePositionUpdate,
                handleLocationError,
                {
                    enableHighAccuracy: true,
                    maximumAge: 0,
                    timeout: 15000
                }
            );
        } catch (error) {
            console.error("Error starting position updates:", error);
            showPopup("Location Error", "Unable to track your location. Please check your device settings and refresh the page.");
        }
    }

    // *******************************************************
    // * PHYSICS AND ANIMATION CORE
    // *******************************************************

    // Start the smooth animation loop with physics separation
    function startSmoothAnimationLoop() {
        try {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            
            // Last time for physics update
            let lastPhysicsTime = performance.now();
            
            // Main animation loop function
            function animationLoop(timestamp) {
                // Calculate time delta in seconds
                const deltaTime = (timestamp - lastPhysicsTime) / 1000;
                
                // Accumulate time for physics updates
                physicsUpdateAccumulator += deltaTime;
                
                // Run physics updates at fixed time step
                while (physicsUpdateAccumulator >= MIN_UPDATE_INTERVAL) {
                    updatePhysics(MIN_UPDATE_INTERVAL);
                    physicsUpdateAccumulator -= MIN_UPDATE_INTERVAL;
                }
                
                // Render at animation frame rate
                updateRendering(timestamp);
                
                // Store time for next frame
                lastPhysicsTime = timestamp;
                
                // Continue animation loop
                animationFrameId = requestAnimationFrame(animationLoop);
            }
            
            // Start the animation loop
            animationFrameId = requestAnimationFrame(animationLoop);
        } catch (error) {
            console.error("Error starting animation loop:", error);
            // Try to restart the animation loop after a delay
            setTimeout(() => {
                if (!animationFrameId) {
                    startSmoothAnimationLoop();
                }
            }, 1000);
        }
    }

    // Physics update function - runs at fixed timestep
    function updatePhysics(deltaTime) {
        try {
            // Process any pending position updates
            if (pendingPosition) {
                processPendingPosition();
            }
            
            // Only run physics if we have a last position
            if (!lastPosition || !lastVelocity) return;
            
            // Check if we need to update predictions
            const timeSinceLastUpdate = (Date.now() - lastUpdateTime);
            
            if (timeSinceLastUpdate > PREDICTION_THRESHOLD && !isStationary) {
                // Calculate predicted position based on current velocity and acceleration
                const predictionFactor = Math.min(1, timeSinceLastUpdate / 1000);
                
                // Apply motion equations: position = initial_position + velocity*time + 0.5*acceleration*time²
                lastPredictedPosition = {
                    lat: lastPosition.lat + (lastVelocity.lat * predictionFactor) + 
                         (0.5 * lastAcceleration.lat * predictionFactor * predictionFactor),
                    lng: lastPosition.lng + (lastVelocity.lng * predictionFactor) + 
                         (0.5 * lastAcceleration.lng * predictionFactor * predictionFactor),
                    accuracy: lastPosition.accuracy,
                    heading: lastPosition.heading,
                    timestamp: Date.now(),
                    speedMPS: lastPosition.speedMPS,
                    predicted: true
                };
                
                // Add points to motion path if debug is enabled
                if (DEBUG_MODE) {
                    addPredictedPathPoint(lastPredictedPosition);
                }
            }
        } catch (error) {
            console.error("Physics update error:", error);
            // Non-critical error, continue execution
        }
    }

    // Rendering update function - runs at animation frame rate
    function updateRendering(timestamp) {
        try {
            // If we're stationary, just use the stable position
            if (isStationary && stationaryPosition) {
                updateVisuals(stationaryPosition);
                return;
            }
            
            // Use prediction if we haven't had an update for a while and we're not stationary
            if (lastPredictedPosition && (Date.now() - lastUpdateTime) > PREDICTION_THRESHOLD && !isStationary) {
                updateVisuals(lastPredictedPosition);
                return;
            }
            
            // Otherwise use the most recent position
            if (lastPosition) {
                updateVisuals(lastPosition);
            }
            
            // Update debug overlay if enabled
            if (DEBUG_MODE) {
                updateDebugOverlay();
            }
        } catch (error) {
            console.error("Rendering update error:", error);
            // Non-critical error, continue execution
        }
    }

    // Update visual elements on the map
    function updateVisuals(position) {
        try {
            if (!position || typeof position.lat !== 'number' || typeof position.lng !== 'number') {
                return;
            }
            
            // Update marker position
            userMarker.setLatLng([position.lat, position.lng]);
            
            // Update accuracy circle
            userAccuracyCircle.setLatLng([position.lat, position.lng]);
            
            // Only update accuracy radius if it changed significantly
            if (Math.abs(userAccuracyCircle.getRadius() - position.accuracy) > 1) {
                userAccuracyCircle.setRadius(position.accuracy);
            }
            
            // Recenter map if needed
            if (followUser && !isMapInteracting) {
                const recenterInfo = shouldRecenter(map, position);
                
                if (recenterInfo.needsRecenter) {
                    const newCenter = recenterInfo.isEmergency ? 
                        [position.lat, position.lng] : 
                        calculateOptimalCenter(map, position, recenterInfo.edgeInfo);
                        
                    map.panTo(newCenter, {
                        animate: true,
                        duration: recenterInfo.isEmergency ? 0.1 : 0.5,
                        easeLinearity: 0.5
                    });
                }
                
                // Adjust zoom based on speed if needed
                if (position.speedMPS !== undefined) {
                    const zoomLevel = getSpeedBasedZoom(position.speedMPS);
                    if (zoomLevel !== -1 && Math.abs(map.getZoom() - zoomLevel) > 0.5) {
                        map.setZoom(zoomLevel, { animate: true, duration: 1 });
                        lastZoomLevel = zoomLevel; // Store the new zoom level
                    }
                }
            }
            
            // Update distance box
            updateDistanceBox();
        } catch (error) {
            console.error("Visual update error:", error);
            // Non-critical error, continue execution
        }
    }
    
    // Process pending position updates
    function processPendingPosition() {
        try {
            if (pendingPosition) {
                updateUserLocation(pendingPosition);
                pendingPosition = null;
            }
        } catch (error) {
            console.error("Error processing pending position:", error);
            pendingPosition = null;
        }
    }

    // *******************************************************
    // * MOTION PREDICTION AND FILTERING
    // *******************************************************

    // Enhanced Kalman filter implementation
    const kalmanFilter = {
        x: { estimate: 0, error: 1 },
        y: { estimate: 0, error: 1 },
        q: 0.015, // Process noise
        r: 1,     // Measurement noise
        
        update: function(measurement, dynamicNoise = null) {
            try {
                // Validate input
                if (!measurement || typeof measurement.lat !== 'number' || typeof measurement.lng !== 'number') {
                    return measurement;
                }
                
                // Update measurement noise if provided
                if (dynamicNoise !== null) {
                    this.r = dynamicNoise;
                }
                
                // Initialize if first measurement
                if (this.x.estimate === 0 && this.y.estimate === 0) {
                    this.x.estimate = measurement.lng;
                    this.y.estimate = measurement.lat;
                    return measurement;
                }
                
                // X coordinate (longitude)
                const predX = this.x.estimate;
                const predErrX = this.x.error + this.q;
                const gainX = predErrX / (predErrX + this.r);
                this.x.estimate = predX + gainX * (measurement.lng - predX);
                this.x.error = (1 - gainX) * predErrX;
                
                // Y coordinate (latitude)
                const predY = this.y.estimate;
                const predErrY = this.y.error + this.q;
                const gainY = predErrY / (predErrY + this.r);
                this.y.estimate = predY + gainY * (measurement.lat - predY);
                this.y.error = (1 - gainY) * predErrY;
                
                return {
                    lat: this.y.estimate,
                    lng: this.x.estimate,
                    accuracy: measurement.accuracy,
                    timestamp: measurement.timestamp,
                    heading: measurement.heading,
                    speedMPS: measurement.speedMPS,
                    altitude: measurement.altitude,
                    altitudeAccuracy: measurement.altitudeAccuracy
                };
            } catch (error) {
                console.error("Kalman filter error:", error);
                return measurement; // Return original measurement on error
            }
        },
        
        reset: function(measurement) {
            if (!measurement) return;
            
            this.x.estimate = measurement.lng;
            this.y.estimate = measurement.lat;
            this.x.error = 1;
            this.y.error = 1;
        }
    };

    // Apply enhanced Kalman filter with dynamic noise adjustment
    function applyEnhancedKalmanFilter(newPosition, lastPosition, timeDelta) {
        try {
            // Calculate dynamic Kalman noise based on movement state and accuracy
            const dynamicKalmanNoise = calculateDynamicKalmanNoise(newPosition, lastPosition, isStationary);
            
            // Apply Kalman filter with dynamic noise
            return kalmanFilter.update(newPosition, dynamicKalmanNoise);
        } catch (error) {
            console.error("Enhanced Kalman filter error:", error);
            return newPosition; // Return original position on error
        }
    }
    
    // Calculate dynamic Kalman filter noise parameter based on movement state
    function calculateDynamicKalmanNoise(newPosition, lastPosition, isStationary) {
        try {
            if (!newPosition || !lastPosition) return 1;
            
            if (isStationary) {
                return newPosition.accuracy / 400; // Tighter filtering when stationary
            }
            
            // Adjust noise based on accuracy, speed and consistency
            const speedFactor = Math.min(1, newPosition.speedMPS / 5); // 0-1 factor based on speed
            const accuracyRatio = newPosition.accuracy / (lastPosition?.accuracy || 20);
            
            // Lower values = more filtering/smoothing
            let dynamicR = newPosition.accuracy / (75 + 50 * speedFactor); 
            
            // Adjust for sudden accuracy changes
            if (accuracyRatio > 2) { // Accuracy suddenly worse
                dynamicR *= 0.7; // More filtering
            } else if (accuracyRatio < 0.5) { // Accuracy suddenly better
                dynamicR *= 1.2; // Less filtering, trust the measurement more
            }
            
            return Math.max(newPosition.accuracy / 400, Math.min(dynamicR, newPosition.accuracy / 25));
        } catch (error) {
            console.error("Dynamic Kalman noise calculation error:", error);
            return 1; // Return default value on error
        }
    }

    // Update position buffer with new position data
    function updatePositionBuffer(position, confidenceFactor = 1.0) {
        try {
            if (!position || typeof position.lat !== 'number' || typeof position.lng !== 'number') {
                return;
            }
            
            // Add new position to buffer with confidence weighting
            positionBuffer.push({
                lat: position.lat,
                lng: position.lng,
                accuracy: position.accuracy,
                timestamp: position.timestamp,
                heading: position.heading,
                speedMPS: position.speedMPS,
                confidence: confidenceFactor,
                altitude: position.altitude,
                altitudeAccuracy: position.altitudeAccuracy
            });

            // Remove old positions if buffer exceeds maxSize
            while (positionBuffer.length > MAX_BUFFER_SIZE) {
                positionBuffer.shift();
            }
            
            // Update heading buffer if we have heading data
            if (position.heading !== undefined && position.heading !== null) {
                headingBuffer.push(position.heading);
                while (headingBuffer.length > MAX_HEADING_BUFFER_SIZE) {
                    headingBuffer.shift();
                }
            }
        } catch (error) {
            console.error("Position buffer update error:", error);
        }
    }

    // Calculate weighted position from buffer
    function calculateWeightedFinalPosition() {
        try {
            if (!Array.isArray(positionBuffer) || positionBuffer.length === 0) {
                return null;
            }

            // Filter out invalid positions
            const validPositions = positionBuffer.filter(pos => 
                pos && typeof pos.lat === 'number' && typeof pos.lng === 'number' && 
                !isNaN(pos.lat) && !isNaN(pos.lng)
            );

            if (validPositions.length === 0) {
                return null;
            }

            let sumLat = 0, sumLng = 0, totalWeight = 0;
            let sumConfidence = 0;
            let bestAccuracy = Infinity;
            let latestTimestamp = 0;
            let latestHeading = null;
            let latestSpeed = 0;
            let latestAltitude = null;
            let latestAltitudeAccuracy = null;

            // Use recency and confidence for weighting
            for (let i = 0; i < validPositions.length; i++) {
                const position = validPositions[i];
                const recencyWeight = Math.pow(0.8, validPositions.length - i - 1);
                const confidenceWeight = position.confidence || 1.0;
                const weight = recencyWeight * confidenceWeight;
                
                sumLat += position.lat * weight;
                sumLng += position.lng * weight;
                totalWeight += weight;
                sumConfidence += confidenceWeight;
                
                // Track best accuracy and latest values
                if (position.accuracy < bestAccuracy) {
                    bestAccuracy = position.accuracy;
                }
                
                if (position.timestamp > latestTimestamp) {
                    latestTimestamp = position.timestamp;
                    latestHeading = position.heading;
                    latestSpeed = position.speedMPS;
                    latestAltitude = position.altitude;
                    latestAltitudeAccuracy = position.altitudeAccuracy;
                }
            }

            // Calculate average confidence
            const avgConfidence = sumConfidence / validPositions.length;

            const result = {
                lat: sumLat / totalWeight,
                lng: sumLng / totalWeight,
                accuracy: bestAccuracy,
                timestamp: latestTimestamp,
                heading: latestHeading,
                speedMPS: latestSpeed,
                altitude: latestAltitude,
                altitudeAccuracy: latestAltitudeAccuracy,
                confidence: avgConfidence
            };

            return result;
        } catch (error) {
            console.error("Weighted position calculation error:", error);
            // Return the most recent valid position as fallback
            return positionBuffer.length > 0 ? positionBuffer[positionBuffer.length - 1] : null;
        }
    }

    // Apply adaptive smoothing based on confidence and accuracy
    function applyAdaptiveSmoothing(newPosition, lastPosition, smoothingFactor = 0.75) {
        try {
            // Validate inputs
            if (!newPosition || !lastPosition) {
                return newPosition;
            }

            // Initialize lastSmoothedPosition if it doesn't exist
            if (!lastSmoothedPosition) {
                lastSmoothedPosition = lastPosition;
            }

            // Calculate adaptive alpha - higher values = less smoothing
            const alpha = calculateAdaptiveSmoothingFactor(newPosition, lastPosition);
            
            // Apply exponential smoothing
            const smoothedPosition = {
                lat: lastSmoothedPosition.lat + alpha * (newPosition.lat - lastSmoothedPosition.lat),
                lng: lastSmoothedPosition.lng + alpha * (newPosition.lng - lastSmoothedPosition.lng),
                accuracy: Math.min(newPosition.accuracy, lastSmoothedPosition.accuracy),
                heading: newPosition.heading,
                timestamp: newPosition.timestamp,
                speedMPS: newPosition.speedMPS ? 
                          lastSmoothedPosition.speedMPS * 0.7 + newPosition.speedMPS * 0.3 : // Smooth speed changes
                          newPosition.speedMPS,
                altitude: newPosition.altitude,
                altitudeAccuracy: newPosition.altitudeAccuracy
            };

            // Smooth heading when available
            if (smoothedPosition.heading !== undefined && lastSmoothedPosition.heading !== undefined) {
                // Calculate shortest angular distance for proper heading interpolation
                const headingDiff = ((((newPosition.heading - lastSmoothedPosition.heading) % 360) + 540) % 360) - 180;
                smoothedPosition.heading = (lastSmoothedPosition.heading + alpha * headingDiff) % 360;
                if (smoothedPosition.heading < 0) smoothedPosition.heading += 360;
            }

            // Update last smoothed position
            lastSmoothedPosition = smoothedPosition;

            return smoothedPosition;
        } catch (error) {
            console.error("Adaptive smoothing error:", error);
            return newPosition; // Return original position on error
        }
    }

    // Calculate adaptive smoothing factor based on movement context
    function calculateAdaptiveSmoothingFactor(newPosition, lastPosition) {
        try {
            if (!newPosition || !lastPosition) return MAX_ALPHA;
            
            // Base smoothing factor - higher values = less smoothing
            let alpha = MAX_ALPHA;
            
            // Adjust for speed (less smoothing at higher speeds for responsiveness)
            if (newPosition.speedMPS !== undefined) {
                alpha = Math.min(MAX_ALPHA, MAX_ALPHA - 0.05 + (newPosition.speedMPS / 30));
            }
            
            // Adjust for accuracy (more smoothing for lower accuracy)
            alpha -= Math.min(0.15, (newPosition.accuracy - MIN_EXPECTED_ACCURACY) / 150);
            
            // Adjust for heading changes (less smoothing during turns)
            if (lastPosition?.heading != null && newPosition.heading != null) {
                const headingDiff = Math.abs(lastPosition.heading - newPosition.heading);
                if (headingDiff > 15 && headingDiff < 180) {
                    alpha += Math.min(0.1, headingDiff / 360);
                }
            }
            
            // Adjust for first few updates
            if (isFirstFewUpdates) {
                alpha = Math.min(0.9, alpha * 1.5);
            }
            
            // Ensure alpha is within bounds
            return Math.max(MIN_ALPHA, Math.min(alpha, MAX_ALPHA));
        } catch (error) {
            console.error("Smoothing factor calculation error:", error);
            return MAX_ALPHA; // Return default value on error
        }
    }

    // Calculate advanced prediction with acceleration
    function calculateAdvancedPrediction(currentPosition, lastPosition, timeDelta) {
        try {
            if (!lastVelocity || !lastAcceleration || timeDelta <= 0 || !currentPosition || !lastPosition) {
                return currentPosition;
            }
            
            // Apply physics equations with limits
            const predictionFactor = Math.min(1, Math.max(0.1, timeDelta));
            
            // Limit prediction strength based on confidence
            const confidenceFactor = Math.min(1, (currentPosition.confidence || 0.5) * 1.5);
            
            // Position = initial_position + velocity*time + 0.5*acceleration*time²
            return {
                lat: currentPosition.lat + 
                     (lastVelocity.lat * predictionFactor * confidenceFactor) + 
                     (0.5 * lastAcceleration.lat * predictionFactor * predictionFactor * confidenceFactor),
                lng: currentPosition.lng + 
                     (lastVelocity.lng * predictionFactor * confidenceFactor) + 
                     (0.5 * lastAcceleration.lng * predictionFactor * predictionFactor * confidenceFactor),
                accuracy: currentPosition.accuracy,
                heading: currentPosition.heading,
                timestamp: currentPosition.timestamp,
                speedMPS: currentPosition.speedMPS,
                altitude: currentPosition.altitude,
                altitudeAccuracy: currentPosition.altitudeAccuracy
            };
        } catch (error) {
            console.error("Advanced prediction error:", error);
            return currentPosition; // Return original position on error
        }
    }

    // Update velocity and acceleration vectors for prediction
    function updateMotionVectors(newPosition, oldPosition, timeDelta) {
        try {
            if (!newPosition || !oldPosition || timeDelta <= 0) return;
            
            // Calculate new velocity
            const currentVelocity = {
                lat: (newPosition.lat - oldPosition.lat) / timeDelta,
                lng: (newPosition.lng - oldPosition.lng) / timeDelta
            };
            
            // Calculate new acceleration
            const currentAcceleration = {
                lat: lastVelocity ? (currentVelocity.lat - lastVelocity.lat) / timeDelta : 0,
                lng: lastVelocity ? (currentVelocity.lng - lastVelocity.lng) / timeDelta : 0
            };
            
            // Apply smoothing to velocity and acceleration
            lastVelocity = {
                lat: lastVelocity ? lastVelocity.lat * VELOCITY_DECAY + currentVelocity.lat * (1 - VELOCITY_DECAY) : currentVelocity.lat,
                lng: lastVelocity ? lastVelocity.lng * VELOCITY_DECAY + currentVelocity.lng * (1 - VELOCITY_DECAY) : currentVelocity.lng
            };
            
            lastAcceleration = {
                lat: lastAcceleration ? lastAcceleration.lat * ACCELERATION_DECAY + currentAcceleration.lat * (1 - ACCELERATION_DECAY) : currentAcceleration.lat,
                lng: lastAcceleration ? lastAcceleration.lng * ACCELERATION_DECAY + currentAcceleration.lng * (1 - ACCELERATION_DECAY) : currentAcceleration.lng
            };
            
            // Add magnitude limits
            const velocityMagnitude = Math.sqrt(lastVelocity.lat * lastVelocity.lat + lastVelocity.lng * lastVelocity.lng);
            const maxVelocity = MAX_SPEED / 111000; // convert m/s to degrees/s (approx)
            
            if (velocityMagnitude > maxVelocity) {
                const scaleFactor = maxVelocity / velocityMagnitude;
                lastVelocity.lat *= scaleFactor;
                lastVelocity.lng *= scaleFactor;
            }
            
            // Limit acceleration as well
            const accelMagnitude = Math.sqrt(lastAcceleration.lat * lastAcceleration.lat + lastAcceleration.lng * lastAcceleration.lng);
            const maxAccel = maxVelocity / 2; // limit acceleration to half of max velocity change per second
            
            if (accelMagnitude > maxAccel) {
                const scaleFactorAccel = maxAccel / accelMagnitude;
                lastAcceleration.lat *= scaleFactorAccel;
                lastAcceleration.lng *= scaleFactorAccel;
            }
        } catch (error) {
            console.error("Motion vector update error:", error);
            // Non-critical error, continue execution
        }
    }

    // Update position state with the latest position
    function updatePositionState(position, speedMPS) {
        try {
            if (!position) return;
            
            lastPosition = position;
            lastUpdateTime = position.timestamp;
            
            // Add point to motion path if debug is enabled
            if (DEBUG_MODE) {
                addMotionPathPoint(position);
            }
        } catch (error) {
            console.error("Position state update error:", error);
        }
    }

    // Apply fallback update when filtering fails
    function applyFallbackUpdate(newPosition) {
        try {
            // Use a weighted combination of new position and last position
            if (!lastPosition) {
                lastPosition = newPosition;
                return;
            }
            
            const fallbackPosition = {
                lat: lastPosition.lat * 0.3 + newPosition.lat * 0.7,
                lng: lastPosition.lng * 0.3 + newPosition.lng * 0.7,
                accuracy: newPosition.accuracy,
                heading: newPosition.heading,
                timestamp: newPosition.timestamp,
                speedMPS: newPosition.speedMPS,
                altitude: newPosition.altitude,
                altitudeAccuracy: newPosition.altitudeAccuracy
            };
            
            lastPosition = fallbackPosition;
            lastUpdateTime = newPosition.timestamp;
            
            // Add point to motion path if debug is enabled
            if (DEBUG_MODE) {
                addMotionPathPoint(fallbackPosition);
            }
        } catch (error) {
            console.error("Fallback update error:", error);
            lastPosition = newPosition; // Use original position as last resort
        }
    }

    // Handle stationary state more efficiently
    function handleStationaryState(newPosition, currentTime) {
        try {
            if (!newPosition || !currentTime) return false;
            
            if (!stationaryStartTime) {
                stationaryStartTime = currentTime;
            }
            
            if (currentTime - stationaryStartTime > STATIONARY_TIME_THRESHOLD) {
                if (!isStationary) {
                    console.log("Device is stationary, optimizing updates");
                    isStationary = true;
                }
                
                // Add position to stationary buffer for improved stability
                stationaryBuffer.push(newPosition);
                if (stationaryBuffer.length > STATIONARY_BUFFER_SIZE) {
                    stationaryBuffer.shift();
                }
                
                // Only update the stationary position occasionally for stability
                if (!stationaryPosition || currentTime % 5000 < 100) {
                    calculateStationaryPosition();
                }
                
                // Still check for actual movement periodically
                if (!stationaryCheckTimeout) {
                    stationaryCheckTimeout = setTimeout(() => {
                        checkStationaryState(newPosition);
                        stationaryCheckTimeout = null;
                    }, STATIONARY_CHECK_INTERVAL);
                }
                
                return true;
            }
            
            return false;
        } catch (error) {
            console.error("Stationary state handling error:", error);
            return false;
        }
    }

    // Calculate stabilized position for stationary device
    function calculateStationaryPosition() {
        try {
            if (!stationaryBuffer || stationaryBuffer.length === 0) return;
            
            // Use weighted average with higher weights for higher accuracy points
            let sumLat = 0, sumLng = 0, sumWeights = 0;
            let bestAccuracy = Infinity;
            let latestHeading = null;
            let latestTimestamp = 0;
            
            stationaryBuffer.forEach(pos => {
                if (!pos || typeof pos.lat !== 'number' || typeof pos.lng !== 'number') return;
                
                // Invert accuracy for weighting (lower accuracy = lower weight)
                const weight = 1 / Math.max(5, pos.accuracy);
                sumLat += pos.lat * weight;
                sumLng += pos.lng * weight;
                sumWeights += weight;
                
                if (pos.accuracy < bestAccuracy) {
                    bestAccuracy = pos.accuracy;
                }
                
                if (pos.timestamp > latestTimestamp) {
                    latestTimestamp = pos.timestamp;
                    latestHeading = pos.heading;
                }
            });
            
            if (sumWeights === 0) return;
            
            stationaryPosition = {
                lat: sumLat / sumWeights,
                lng: sumLng / sumWeights,
                accuracy: bestAccuracy,
                heading: latestHeading,
                timestamp: latestTimestamp,
                speedMPS: 0
            };
        } catch (error) {
            console.error("Stationary position calculation error:", error);
        }
    }

    // Check if device is still stationary
    function checkStationaryState(newPosition) {
        try {
            if (!lastPosition || !newPosition) return;
            
            const distance = calculateDistance(lastPosition, newPosition);
            
            if (distance >= MICRO_MOVEMENT_THRESHOLD) {
                isStationary = false;
                stationaryStartTime = null;
                console.debug("Movement detected, resuming normal updates");
            }
            
            if (stationaryCheckTimeout) {
                clearTimeout(stationaryCheckTimeout);
                stationaryCheckTimeout = null;
            }
            
            if (isStationary) {
                stationaryCheckTimeout = setTimeout(() => checkStationaryState(newPosition), STATIONARY_CHECK_INTERVAL);
            }
        } catch (error) {
            console.error("Stationary state check error:", error);
        }
    }

    // Calculate confidence factor for position updates
    function calculateConfidenceFactor(newPosition, lastPosition) {
        try {
            if (!lastPosition || !newPosition) return 1.0;
            
            let confidence = 1.0;
            
            // Reduce confidence for low accuracy
            if (newPosition.accuracy > 20) {
                confidence *= Math.max(0.5, 1 - (newPosition.accuracy - 20) / 100);
            }
            
            // Reduce confidence for implausible movement
            const distance = calculateDistance(lastPosition, newPosition);
            const timeDelta = (newPosition.timestamp - lastPosition.timestamp) / 1000;
            
            if (timeDelta > 0) {
                const speed = distance / timeDelta;
                if (speed > MAX_SPEED) {
                    confidence *= Math.max(0.3, MAX_SPEED / speed);
                }
            }
            
            return Math.max(0.3, Math.min(1.0, confidence));
        } catch (error) {
            console.error("Confidence factor calculation error:", error);
            return 0.5; // Return moderate confidence on error
        }
    }

    // Calculate threshold for minimum detectable movement based on accuracy
    function calculateDynamicMinDistance(timeDelta, accuracy) {
        try {
            if (typeof accuracy !== 'number' || isNaN(accuracy)) {
                return MIN_DISTANCE_THRESHOLD;
            }
            
            // Minimum threshold scaled by accuracy and time
            return Math.max(
                MIN_DISTANCE_THRESHOLD,
                Math.min(accuracy * 0.05, MIN_DISTANCE_THRESHOLD * 2)
            );
        } catch (error) {
            console.error("Dynamic min distance calculation error:", error);
            return MIN_DISTANCE_THRESHOLD;
        }
    }

    // Calculate dynamic threshold for maximum acceptable accuracy
    function calculateDynamicAccuracyThreshold(speedMPS) {
        try {
            // Allow less accurate positions when moving faster
            const speedFactor = speedMPS ? Math.min(1, speedMPS / 10) : 0;
            return MAX_ACCEPTABLE_ACCURACY + (speedFactor * 20);
        } catch (error) {
            console.error("Dynamic accuracy threshold calculation error:", error);
            return MAX_ACCEPTABLE_ACCURACY;
        }
    }

    // Calculate dynamic maximum speed threshold
    function calculateDynamicSpeedThreshold(lastSpeed) {
        try {
            // Base threshold that adapts to previous speed
            const baseThreshold = lastSpeed ? Math.max(MAX_SPEED, lastSpeed * 1.5) : MAX_SPEED;
            return baseThreshold;
        } catch (error) {
            console.error("Dynamic speed threshold calculation error:", error);
            return MAX_SPEED;
        }
    }

    // *******************************************************
    // * GEOLOCATION AND POSITION HANDLING
    // *******************************************************

    function handlePositionUpdate(position) {
        try {
            if (!position || !position.coords || 
                isNaN(position.coords.latitude) || 
                isNaN(position.coords.longitude)) {
                console.warn("Invalid position data received");
                return;
            }
            
            // Process valid position update
            updateUserLocation(position);
        } catch (error) {
            console.error("Position update handling error:", error);
        }
    }

    function handleVisibilityChange() {
        try {
            if (document.hidden) {
                lastHiddenTime = Date.now();
                lastKnownPosition = userMarker ? userMarker.getLatLng() : null;
                stopAutoRecenterCountdown();
            } else {
                const hiddenDuration = Date.now() - lastHiddenTime;
                if (hiddenDuration > BACKGROUND_THRESHOLD) {
                    updateLocationAfterBackground();
                } else {
                    // Just refresh the map size
                    map.invalidateSize();
                }
            }
            resetInactivityTimer();
            
            // Reset auto-recenter timer when app becomes visible again
            if (!document.hidden) {
                startAutoRecenterTimer();
            }
        } catch (error) {
            console.error("Visibility change handling error:", error);
        }
    }

    function updateLocationAfterBackground() {
        try {
            if ("geolocation" in navigator) {
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        if (!position || !position.coords) {
                            console.warn("Invalid position object in background update");
                            return;
                        }
                        
                        const { latitude, longitude, accuracy } = position.coords;
                        if (isNaN(latitude) || isNaN(longitude)) {
                            console.warn("Invalid coordinates in background update");
                            return;
                        }
                        
                        try {
                            // Force update with new position
                            updateUserLocation(position, true);
                            
                            // Reset all position tracking variables
                            lastPosition = null;
                            positionBuffer = [];
                            filteredPosition = null;
                            lastVelocity = { lat: 0, lng: 0 };
                            lastAcceleration = { lat: 0, lng: 0 };
                            headingBuffer = [];
                            
                            updateDistanceBox();
                            followUser = true;
                            map.invalidateSize();
                        } catch (error) {
                            console.error("Error updating location after background:", error);
                        }
                    },
                    (error) => {
                        console.error("Error getting location after background:", error);
                        if (error.code === 3) { // If timeout, retry with lower accuracy
                            navigator.geolocation.getCurrentPosition(
                                position => {
                                    updateUserLocation(position, true);
                                },
                                error => console.error("Error on retry:", error),
                                {
                                    enableHighAccuracy: false,
                                    timeout: 20000,
                                    maximumAge: 30000
                                }
                            );
                        }
                    },
                    {
                        enableHighAccuracy: true,
                        timeout: 10000,
                        maximumAge: 0
                    }
                );
            } else {
                console.warn("Geolocation is not available");
            }
        } catch (error) {
            console.error("Background location update error:", error);
        }
    }

    function updateUserLocation(position, forceUpdate = false) {
        try {
            // Validate input position
            if (!position?.coords?.latitude || !position?.coords?.longitude) {
                console.warn("Invalid position data received");
                return;
            }

            const currentTime = Date.now();
            const timeDelta = lastUpdateTime ? (currentTime - lastUpdateTime) / 1000 : 0;

            // Enhanced position object with additional properties
            const newPosition = {
                lat: position.coords.latitude,
                lng: position.coords.longitude,
                accuracy: position.coords.accuracy || 20,
                heading: position.coords.heading ?? null,
                timestamp: currentTime,
                speedMPS: position.coords.speed || calculateSpeedFromLastPosition(position, lastPosition, timeDelta),
                altitude: position.coords.altitude || null,
                altitudeAccuracy: position.coords.altitudeAccuracy || null
            };

            // Store the raw position for analysis
            lastRawPosition = { ...newPosition };

            // First position initialization
            if (!lastPosition) {
                lastPosition = newPosition;
                userMarker.setLatLng([newPosition.lat, newPosition.lng]);
                userAccuracyCircle.setLatLng([newPosition.lat, newPosition.lng]);
                userAccuracyCircle.setRadius(newPosition.accuracy);
                
                kalmanFilter.reset(newPosition);
                lastUpdateTime = currentTime;
                stationaryStartTime = currentTime;
                positionBuffer = [newPosition];
                lastVelocity = { lat: 0, lng: 0 };
                lastAcceleration = { lat: 0, lng: 0 };
                
                if (newPosition.heading) {
                    headingBuffer = [newPosition.heading];
                }
                
                const zoomLevel = getSpeedBasedZoom(newPosition.speedMPS);
                if (zoomLevel !== -1) {
                    map.setZoom(zoomLevel, { animate: false });
                    lastZoomLevel = zoomLevel;
                }
                
                map.setView([newPosition.lat, newPosition.lng], map.getZoom(), { animate: false });
                updateDistanceBox();
                return;
            }

            // Debounce rapid updates for performance
            if (!forceUpdate && timeDelta < MIN_UPDATE_INTERVAL && !isFirstFewUpdates) {
                pendingPosition = newPosition;
                return;
            }

            const distance = calculateDistance(lastPosition, newPosition);
            updateCount++;

            // Calculate confidence factor based on accuracy and consistency
            const confidenceFactor = calculateConfidenceFactor(newPosition, lastPosition);
            
            // Extended distance handling with immediate response
            if (distance > EXTENDED_DISTANCE_THRESHOLD || forceUpdate) {
                if (stationaryCheckTimeout) {
                    clearTimeout(stationaryCheckTimeout);
                    stationaryCheckTimeout = null;
                }
                isStationary = false;
                stationaryStartTime = null;

                // Only reset completely if confidence is high or it's a forced update
                if (confidenceFactor > 0.7 || forceUpdate) {
                    userMarker.setLatLng([newPosition.lat, newPosition.lng]);
                    userAccuracyCircle.setLatLng([newPosition.lat, newPosition.lng]);
                    userAccuracyCircle.setRadius(newPosition.accuracy);
                    
                    lastPosition = newPosition;
                    positionBuffer = [newPosition];
                    kalmanFilter.reset(newPosition);
                    lastVelocity = { lat: 0, lng: 0 };
                    lastAcceleration = { lat: 0, lng: 0 };
                    
                    if (newPosition.heading !== null) {
                        headingBuffer = [newPosition.heading];
                    }
                } else {
                    // For lower confidence jumps, apply a weighted transition
                    const transitionPosition = {
                        lat: lastPosition.lat * 0.3 + newPosition.lat * 0.7,
                        lng: lastPosition.lng * 0.3 + newPosition.lng * 0.7,
                        accuracy: newPosition.accuracy,
                        heading: newPosition.heading,
                        timestamp: currentTime,
                        speedMPS: newPosition.speedMPS,
                        altitude: newPosition.altitude,
                        altitudeAccuracy: newPosition.altitudeAccuracy
                    };
                    
                    userMarker.setLatLng([transitionPosition.lat, transitionPosition.lng]);
                    userAccuracyCircle.setLatLng([transitionPosition.lat, transitionPosition.lng]);
                    userAccuracyCircle.setRadius(transitionPosition.accuracy);
                    
                    lastPosition = transitionPosition;
                    positionBuffer = [transitionPosition];
                    kalmanFilter.reset(transitionPosition);
                    
                    if (transitionPosition.heading !== null) {
                        headingBuffer = [transitionPosition.heading];
                    }
                }

                const zoomLevel = getSpeedBasedZoom(newPosition.speedMPS);
                if (zoomLevel !== -1 && Math.abs(lastZoomLevel - zoomLevel) > 1) {
                    map.setZoom(zoomLevel, { animate: true, duration: 0.5 });
                    lastZoomLevel = zoomLevel;
                }
                
                map.setView([lastPosition.lat, lastPosition.lng], map.getZoom(), { 
                    animate: true, 
                    duration: 0.5,
                    noMoveStart: true
                });
                
                lastUpdateTime = currentTime;
                updateDistanceBox();
                
                return;
            }

            // Enhanced stationary detection with adaptive thresholds
            const stationaryThreshold = Math.min(
                MICRO_MOVEMENT_THRESHOLD,
                Math.max(newPosition.accuracy * 0.08, MIN_STATIONARY_THRESHOLD)
            );

            if (distance < stationaryThreshold && !forceUpdate) {
                if (handleStationaryState(newPosition, currentTime)) {
                    return;
                }
            } else {
                isStationary = false;
                stationaryStartTime = null;
                if (stationaryCheckTimeout) {
                    clearTimeout(stationaryCheckTimeout);
                    stationaryCheckTimeout = null;
                }
            }

            // Enhanced movement quality check with adaptive thresholds
            const maxAcceptableAccuracy = calculateDynamicAccuracyThreshold(newPosition.speedMPS);
            const maxSpeedThreshold = calculateDynamicSpeedThreshold(lastPosition.speedMPS);
            const minDistanceThreshold = calculateDynamicMinDistance(timeDelta, newPosition.accuracy);
            
            if (!forceUpdate && (
                newPosition.accuracy > maxAcceptableAccuracy ||
                (distance < minDistanceThreshold && !isFirstFewUpdates) ||
                (timeDelta > 0 && distance / timeDelta > maxSpeedThreshold)
            )) {
                // Store rejected position for analysis
                rejectedPositions.push({
                    position: newPosition, 
                    reason: 'quality_check_failed',
                    timestamp: currentTime,
                    distance: distance,
                    speed: timeDelta > 0 ? distance / timeDelta : 0
                });
                
                if (rejectedPositions.length > MAX_REJECTED_POSITIONS) {
                    rejectedPositions.shift();
                }
                return;
            }

            try {
                // Apply Enhanced Kalman filter with predictive components
                const filteredPosition = applyEnhancedKalmanFilter(newPosition, lastPosition, timeDelta);
                
                // Update position buffer with intelligent weighting
                updatePositionBuffer(filteredPosition, confidenceFactor);

                // Calculate final position using weighted buffer algorithm
                const finalPosition = calculateWeightedFinalPosition();
                if (!finalPosition) throw new Error("Final position calculation failed");

                // Apply velocity and acceleration based prediction
                const predictedPosition = calculateAdvancedPrediction(finalPosition, lastPosition, timeDelta);

                // Apply adaptive smoothing based on speed and accuracy
                const smoothingFactor = calculateAdaptiveSmoothingFactor(newPosition, lastPosition);
                const smoothedPosition = applyAdaptiveSmoothing(predictedPosition, lastPosition, smoothingFactor);

                // Update motion vectors for future predictions
                updateMotionVectors(smoothedPosition, lastPosition, timeDelta);
                
                // Update position state
                updatePositionState(smoothedPosition, newPosition.speedMPS);

            } catch (error) {
                console.error("Location update error:", error);
                // Improved fallback with weighted combination
                applyFallbackUpdate(newPosition);
            }
        } catch (error) {
            console.error("User location update error:", error);
            // Critical error handling - try to recover
            if (position && position.coords) {
                try {
                    userMarker.setLatLng([position.coords.latitude, position.coords.longitude]);
                    lastPosition = {
                        lat: position.coords.latitude,
                        lng: position.coords.longitude,
                        accuracy: position.coords.accuracy || 20,
                        timestamp: Date.now()
                    };
                } catch (innerError) {
                    console.error("Recovery attempt failed:", innerError);
                }
            }
        }
    }

    // Calculate speed when not provided by GPS
    function calculateSpeedFromLastPosition(position, lastPosition, timeDelta) {
        try {
            if (!lastPosition || timeDelta <= 0 || !position || !position.coords) return 0;
            
            const distance = calculateDistance(
                {lat: lastPosition.lat, lng: lastPosition.lng}, 
                {lat: position.coords.latitude, lng: position.coords.longitude}
            );
            
            return distance / timeDelta; // meters per second
        } catch (error) {
            console.error("Speed calculation error:", error);
            return 0;
        }
    }

    // *******************************************************
    // * MAP INTERACTIONS AND UI
    // *******************************************************

    function startAutoRecenterTimer() {
        try {
            // Clear any existing timer
            if (recenterTimer) {
                clearTimeout(recenterTimer);
                recenterTimer = null;
            }
            
            // Set up new timer to recenter after 30 seconds of inactivity
            recenterTimer = setTimeout(() => {
                if (userMarker && lastPosition) {
                    // If summary modal is open, show countdown
                    if (isSummaryModalOpen) {
                        startAutoRecenterCountdown();
                    } else {
                        // Otherwise, just recenter immediately
                        performAutoRecenter();
                    }
                }
            }, AUTO_RECENTER_INTERVAL);
        } catch (error) {
            console.error("Auto-recenter timer error:", error);
        }
    }
    
    function startAutoRecenterCountdown() {
        try {
            // Only show countdown for summary modals
            if (!isSummaryModalOpen) return;
            
            const indicator = document.getElementById('autoRecenterIndicator');
            const countdownEl = document.getElementById('recenterCountdown');
            
            if (!indicator || !countdownEl) return;
            
            // Reset countdown
            autoRecenterCountdown = AUTO_RECENTER_COUNTDOWN_START;
            countdownEl.textContent = autoRecenterCountdown;
            
            // Show indicator
            indicator.classList.add('visible');
            
            // Clear any existing countdown
            if (autoRecenterInterval) {
                clearInterval(autoRecenterInterval);
            }
            
            // Start countdown
            autoRecenterInterval = setInterval(() => {
                autoRecenterCountdown--;
                countdownEl.textContent = autoRecenterCountdown;
                
                if (autoRecenterCountdown <= 0) {
                    // Time to recenter
                    clearInterval(autoRecenterInterval);
                    indicator.classList.remove('visible');
                    
                    // Perform auto-recenter with the same zoom level
                    performAutoRecenter();
                }
            }, 1000);
        } catch (error) {
            console.error("Auto-recenter countdown error:", error);
            // Try to clean up on error
            if (autoRecenterInterval) {
                clearInterval(autoRecenterInterval);
                autoRecenterInterval = null;
            }
        }
    }
    
    function stopAutoRecenterCountdown() {
        try {
            if (autoRecenterInterval) {
                clearInterval(autoRecenterInterval);
                autoRecenterInterval = null;
            }
            
            const indicator = document.getElementById('autoRecenterIndicator');
            if (indicator) {
                indicator.classList.remove('visible');
            }
        } catch (error) {
            console.error("Stop auto-recenter countdown error:", error);
        }
    }
    
    function performAutoRecenter() {
        try {
            if (userMarker && lastPosition) {
                console.log("Auto-recentering map after 30 seconds");
                
                // Close any open popups and modals
                closeAllModals();
                map.closePopup();
                
                // Use the stored zoom level or current zoom level
                const zoomToUse = lastZoomLevel || map.getZoom();
                
                // Recenter with smooth animation
                map.setView([lastPosition.lat, lastPosition.lng], zoomToUse, {
                    animate: true,
                    duration: 0.8,
                    easeLinearity: 0.5
                });
                
                followUser = true;
                lastRecenterTime = Date.now();
                
                // Restart the auto-recenter timer
                startAutoRecenterTimer();
            }
        } catch (error) {
            console.error("Auto-recenter error:", error);
        }
    }
    
    function closeAllModals() {
        try {
            // Close summary modal if open
            const summaryModal = document.getElementById('summaryModal');
            if (summaryModal && window.getComputedStyle(summaryModal).display !== 'none') {
                summaryModal.style.display = 'none';
                isSummaryModalOpen = false;
            }
            
            // Close navigation tips if open
            const navTips = document.querySelector('.navigation-tips');
            if (navTips && window.getComputedStyle(navTips).display !== 'none') {
                navTips.style.display = 'none';
            }
            
            // Close any other modals in the activeModals array
            activeModals.forEach(modal => {
                if (document.body.contains(modal)) {
                    document.body.removeChild(modal);
                }
            });
            activeModals = [];
        } catch (error) {
            console.error("Close modals error:", error);
        }
    }

    function calculateEdgeProximity(map, point) {
        try {
            if (!map || !point) return { north: 1, south: 1, east: 1, west: 1 };
            
            const bounds = map.getBounds();
            const latSpan = bounds.getNorth() - bounds.getSouth();
            const lngSpan = bounds.getEast() - bounds.getWest();
            
            return {
                north: Math.abs(point.lat - bounds.getNorth()) / latSpan,
                south: Math.abs(point.lat - bounds.getSouth()) / latSpan,
                east: Math.abs(point.lng - bounds.getEast()) / lngSpan,
                west: Math.abs(point.lng - bounds.getWest()) / lngSpan
            };
        } catch (error) {
            console.error("Edge proximity calculation error:", error);
            return { north: 1, south: 1, east: 1, west: 1 };
        }
    }

    function shouldRecenter(map, position) {
        try {
            const now = Date.now();
            if (now - lastRecenterTime < MIN_RECENTER_INTERVAL) {
                return { needsRecenter: false };
            }
            
            // Convert position to point if it's not a Leaflet LatLng
            const point = position instanceof L.LatLng ? position : L.latLng(position.lat, position.lng);
            
            const proximities = calculateEdgeProximity(map, point);
            
            // Check for critical proximity to edge (very close to edge)
            const isCritical = Object.values(proximities).some(
                proximity => proximity < CRITICAL_EDGE_THRESHOLD_PERCENTAGE
            );
            
            if (isCritical) {
                lastRecenterTime = now;
                return {
                    needsRecenter: true,
                    isEmergency: true,
                    edgeInfo: {
                        isNearEdge: true,
                        edges: {
                            north: proximities.north < CRITICAL_EDGE_THRESHOLD_PERCENTAGE,
                            south: proximities.south < CRITICAL_EDGE_THRESHOLD_PERCENTAGE,
                            east: proximities.east < CRITICAL_EDGE_THRESHOLD_PERCENTAGE,
                            west: proximities.west < CRITICAL_EDGE_THRESHOLD_PERCENTAGE
                        },
                        proximities: proximities
                    }
                };
            }
            
            // Check for regular edge proximity
            const isNearEdge = Object.values(proximities).some(
                proximity => proximity < EDGE_THRESHOLD_PERCENTAGE
            );
            
            if (isNearEdge) {
                lastRecenterTime = now;
                return {
                    needsRecenter: true,
                    isEmergency: false,
                    edgeInfo: {
                        isNearEdge: true,
                        edges: {
                            north: proximities.north < EDGE_THRESHOLD_PERCENTAGE,
                            south: proximities.south < EDGE_THRESHOLD_PERCENTAGE,
                            east: proximities.east < EDGE_THRESHOLD_PERCENTAGE,
                            west: proximities.west < EDGE_THRESHOLD_PERCENTAGE
                        },
                        proximities: proximities
                    }
                };
            }
            
            return {
                needsRecenter: false,
                isEmergency: false,
                edgeInfo: {
                    isNearEdge: false,
                    edges: {
                        north: false,
                        south: false,
                        east: false,
                        west: false
                    },
                    proximities: proximities
                }
            };
        } catch (error) {
            console.error("Recenter check error:", error);
            return { needsRecenter: false };
        }
    }

    function calculateOptimalCenter(map, position, edgeInfo) {
        try {
            if (!map || !position || !edgeInfo) return position;
            
            const bounds = map.getBounds();
            
            let latOffset = 0;
            let lngOffset = 0;
            
            // Position can be either a Leaflet LatLng or our custom position object
            const lat = position instanceof L.LatLng ? position.lat : position.lat;
            const lng = position instanceof L.LatLng ? position.lng : position.lng;
            
            if (edgeInfo.edges.north) latOffset = -1 * (bounds.getNorth() - bounds.getSouth()) * 0.2;
            if (edgeInfo.edges.south) latOffset = (bounds.getNorth() - bounds.getSouth()) * 0.2;
            if (edgeInfo.edges.east) lngOffset = -1 * (bounds.getEast() - bounds.getWest()) * 0.2;
            if (edgeInfo.edges.west) lngOffset = (bounds.getEast() - bounds.getWest()) * 0.2;
            
            return {
                lat: lat + latOffset,
                lng: lng + lngOffset
            };
        } catch (error) {
            console.error("Optimal center calculation error:", error);
            return position;
        }
    }

    function recenterMap() {
        try {
            const recenterButton = document.getElementById('recenterButton');
            if (!recenterButton) return;
            
            recenterButton.style.backgroundColor = 'var(--primary-color)';
            recenterButton.style.color = 'white';
            recenterButton.classList.add('haptic-feedback');
            provideHapticFeedback();
            
            if (userMarker && lastPosition) {
                map.closePopup();
                
                // Determine optimal zoom level based on user speed and current zoom
                let targetZoom;
                const currentSpeed = lastPosition?.speedMPS || 0;
                
                if (currentSpeed > 20) {
                    // Higher speeds (driving/biking) - zoom out for better context
                    targetZoom = 15;
                } else if (currentSpeed > 5) {
                    // Medium speeds (jogging/slow biking)
                    targetZoom = 16;
                } else if (currentSpeed > 1) {
                    // Walking speeds
                    targetZoom = 17;
                } else {
                    // Standing still or very slow - zoom in closer
                    targetZoom = 18;
                }
                
                // If current zoom is significantly higher (more zoomed in) than target zoom,
                // preserve some of that user preference but still adjust
                if (map.getZoom() > targetZoom + 2) {
                    targetZoom = map.getZoom() - 1;
                }
                
                // Set view with appropriate zoom level
                map.setView([lastPosition.lat, lastPosition.lng], targetZoom, {
                    animate: true,
                    duration: 0.5
                });
                
                // Store this zoom level for future reference
                lastZoomLevel = targetZoom;
                
                followUser = true;
                
                // Reset auto-recenter timer
                stopAutoRecenterCountdown();
                startAutoRecenterTimer();
            }
            
            setTimeout(() => {
                recenterButton.style.backgroundColor = 'white';
                recenterButton.style.color = 'var(--primary-color)';
                recenterButton.classList.remove('haptic-feedback');
            }, 500);
        } catch (error) {
            console.error("Recenter map error:", error);
            // Try to recover
            if (userMarker && lastPosition) {
                try {
                    map.setView([lastPosition.lat, lastPosition.lng], map.getZoom());
                    followUser = true;
                } catch (innerError) {
                    console.error("Recenter recovery failed:", innerError);
                }
            }
        }
    }

    function updateDistanceBox() {
        try {
            const distanceBox = document.getElementById('distanceBox');
            if (!distanceBox) return;
            
            // Initial validation
            if (!userMarker || !gameLocations || gameLocations.length === 0) {
                distanceBox.innerText = 'Initializing...';
                return;
            }

            // Get user coordinates
            const userLatLng = userMarker.getLatLng();
            let userLat = userLatLng.lat;
            let userLng = userLatLng.lng;

            // Coordinate validation
            if (!isFinite(userLat) || !isFinite(userLng)) {
                console.warn('Invalid user coordinates:', userLat, userLng);
                distanceBox.innerText = 'Initializing...';
                return;
            }

            // Use map center if at origin
            if (userLat === 0 && userLng === 0) {
                const center = map.getCenter();
                userLat = center.lat;
                userLng = center.lng;
            }

            // Find closest location
            let closestDistance = Infinity;
            let closestLocation = null;
            const userPos = { lat: userLat, lng: userLng };

            for (const location of gameLocations) {
                if (!location || typeof location.lat !== 'number' || typeof location.lng !== 'number') {
                    console.warn('Invalid location data:', location);
                    continue;
                }

                const locationPos = { lat: location.lat, lng: location.lng };
                const distance = calculateDistance(userPos, locationPos);

                if (isFinite(distance) && distance < closestDistance) {
                    closestDistance = distance;
                    closestLocation = location;
                }
            }

            // Validate final distance calculation
            if (!isFinite(closestDistance) || closestDistance === Infinity) {
                console.warn('Invalid distance calculation:', closestDistance);
                distanceBox.innerText = 'Initializing...';
                return;
            }

            // Calculate and display distance
            const distanceFeet = Math.round(closestDistance * 3.28084);
            const distanceText = distanceFeet < 5280 
                ? `${distanceFeet.toLocaleString()} feet` 
                : `${(distanceFeet / 5280).toFixed(2)} miles`;
            
            distanceBox.innerText = `Closest Stop: ${distanceText}`;

            // Check if we should show location hunt
            if (distanceFeet <= DISTANCE_THRESHOLD && !isLocationHuntVisible && closestLocation) {
                showLocationHunt(closestLocation);
            }
        } catch (error) {
            console.error("Distance box update error:", error);
            const distanceBox = document.getElementById('distanceBox');
            if (distanceBox) {
                distanceBox.innerText = 'Distance unavailable';
            }
        }
    }

    // Calculate distance between two points using Haversine formula
    function calculateDistance(pos1, pos2) {
        try {
            if (!pos1 || !pos2 || 
                typeof pos1.lat !== 'number' || typeof pos1.lng !== 'number' || 
                typeof pos2.lat !== 'number' || typeof pos2.lng !== 'number') {
                return Infinity;
            }
            
            // Haversine formula implementation
            const R = 6371000; // Earth's radius in meters
            const lat1 = pos1.lat * Math.PI / 180;
            const lat2 = pos2.lat * Math.PI / 180;
            const deltaLat = (pos2.lat - pos1.lat) * Math.PI / 180;
            const deltaLng = (pos2.lng - pos1.lng) * Math.PI / 180;

            const a = Math.sin(deltaLat/2) * Math.sin(deltaLat/2) +
                    Math.cos(lat1) * Math.cos(lat2) *
                    Math.sin(deltaLng/2) * Math.sin(deltaLng/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

            return R * c;
        } catch (error) {
            console.error("Distance calculation error:", error);
            return Infinity;
        }
    }

    function getSpeedBasedZoom(speedMPS) {
        try {
            if (speedMPS === undefined || speedMPS === null) {
                return -1;
            }
            
            // Convert m/s to mph
            const speedMPH = speedMPS * 2.23694;

            for (const threshold of SPEED_ZOOM_THRESHOLDS) {
                if (speedMPH >= threshold.speed) {
                    return threshold.zoom;
                }
            }

            // If speed is below the lowest threshold, return -1 to indicate user control
            return -1;
        } catch (error) {
            console.error("Speed-based zoom calculation error:", error);
            return -1;
        }
    }

    function updateLoadingStatus(processed, total, elapsed) {
        try {
            if (processed === total) {
                // All markers loaded
                console.log(`Loaded ${processed} markers in ${elapsed.toFixed(2)}ms`);
                
                // Start preloading images after markers are loaded
                setTimeout(preloadLocationImages, 500);
            }
        } catch (error) {
            console.error("Loading status update error:", error);
        }
    }

    function showLoadingMessage() {
        try {
            const existingMessage = document.getElementById('loadingMessage');
            if (existingMessage) return;

            const loadingMessage = document.createElement('div');
            loadingMessage.id = 'loadingMessage';
            loadingMessage.setAttribute('aria-live', 'polite');
            loadingMessage.setAttribute('role', 'status');
            loadingMessage.innerHTML = '<div class="loading-spinner" aria-hidden="true"></div><p style="margin: 0;">Finding your location...</p>';
            document.body.appendChild(loadingMessage);
        } catch (error) {
            console.error("Show loading message error:", error);
        }
    }

    function hideLoadingMessage() {
        try {
            const loadingMessage = document.getElementById('loadingMessage');
            if (loadingMessage) {
                loadingMessage.classList.add('fade-out');
                setTimeout(() => {
                    if (loadingMessage.parentNode) {
                        document.body.removeChild(loadingMessage);
                    }
                }, 300);
            }
        } catch (error) {
            console.error("Hide loading message error:", error);
            // Try direct removal if animation fails
            const loadingMessage = document.getElementById('loadingMessage');
            if (loadingMessage && loadingMessage.parentNode) {
                document.body.removeChild(loadingMessage);
            }
        }
    }

    function getGeolocationOptions(retryNumber) {
        return {
            enableHighAccuracy: retryNumber < 2,
            timeout: retryNumber === 0 ? FIRST_LOCATION_TIMEOUT : SECOND_LOCATION_TIMEOUT,
            maximumAge: retryNumber * 5000
        };
    }

    function handleLocationError(error) {
        try {
            console.warn("Error getting user location:", error);
            
            if (retryCount < MAX_RETRIES) {
                retryCount++;
                console.log(`Retrying to get location (Attempt ${retryCount} of ${MAX_RETRIES})`);
                
                setTimeout(() => {
                    navigator.geolocation.getCurrentPosition(
                        (position) => {
                            console.log("Location retrieved successfully after retry");
                            hideLoadingMessage();
                            updateUserLocation(position, true);
                            retryCount = 0;
                        },
                        handleLocationError,
                        getGeolocationOptions(retryCount)
                    );
                }, RETRY_DELAY);
                return;
            }
            
            retryCount = 0;
            hideLoadingMessage();
            
            let errorMessage = "An error occurred while getting your location.";
            let errorTitle = "Location Error";
            
            if (error && error.code) {
                switch(error.code) {
                    case 1:
                        errorTitle = "Location Permission Denied";
                        errorMessage = "Please allow access to your location to use this feature. You can change this in your browser or device settings.";
                        break;
                    case 2:
                        errorTitle = "Location Unavailable";
                        errorMessage = "Your location is currently unavailable. Please check your device's location services and try again.";
                        break;
                    case 3:
                        errorTitle = "Location Timeout";
                        errorMessage = "Getting your location took too long. Please check your connection and try again.";
                        break;
                }
            }
            showPopup(errorTitle, errorMessage);
        } catch (innerError) {
            console.error("Location error handling failed:", innerError);
            showPopup("Location Error", "Unable to access your location. Please refresh the page and try again.");
        }
    }

    function showPopup(title, message, type = 'info', callback = null) {
        try {
            // Remove any existing popups
            const existingPopups = document.querySelectorAll('.popup');
            existingPopups.forEach(popup => {
                if (document.body.contains(popup)) {
                    document.body.removeChild(popup);
                }
            });
            
            const popup = document.createElement('div');
            popup.classList.add('popup', 'fade-in');
            popup.setAttribute('role', 'dialog');
            popup.setAttribute('aria-modal', 'true');
            popup.setAttribute('aria-labelledby', 'popup-title');
            popup.setAttribute('aria-describedby', 'popup-message');
            
            popup.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0, 0, 0, 0.5);
                z-index: 3000;
                display: flex;
                justify-content: center;
                align-items: center;
            `;

            const popupContent = document.createElement('div');
            popupContent.style.cssText = `
                background-color: white;
                padding: 25px;
                border-radius: 12px;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
                max-width: 85%;
                width: 350px;
                text-align: center;
            `;

            const titleElement = document.createElement('h3');
            titleElement.id = 'popup-title';
            titleElement.textContent = title;
            titleElement.style.cssText = `
                margin-bottom: 15px;
                font-size: 20px;
                font-weight: 600;
                color: var(--primary-color);
            `;

            const messageElement = document.createElement('p');
            messageElement.id = 'popup-message';
            messageElement.textContent = message;
            messageElement.style.cssText = `
                margin-bottom: 25px;
                font-size: 16px;
                line-height: 1.5;
                color: #333;
            `;

            const buttonContainer = document.createElement('div');
            buttonContainer.style.cssText = `
                display: flex;
                justify-content: center;
                gap: 15px;
            `;

            const okButton = document.createElement('button');
            okButton.textContent = 'OK';
            okButton.classList.add('touch-target');
            okButton.setAttribute('aria-label', 'Close this dialog');
            okButton.style.cssText = `
                padding: 10px 25px;
                background-color: var(--primary-color);
                color: white;
                border: none;
                border-radius: 8px;
                cursor: pointer;
                font-size: 16px;
                font-weight: 500;
                transition: background-color 0.2s;
            `;
            okButton.onmouseover = () => { okButton.style.backgroundColor = '#004b7d'; };
            okButton.onmouseout = () => { okButton.style.backgroundColor = 'var(--primary-color)'; };

            okButton.addEventListener('click', () => {
                provideHapticFeedback();
                popup.classList.add('fade-out');
                setTimeout(() => {
                    if (document.body.contains(popup)) {
                        document.body.removeChild(popup);
                    }
                    if (callback) callback();
                }, 300);
            });

            buttonContainer.appendChild(okButton);

            if (type === 'info') {
                const cancelButton = document.createElement('button');
                cancelButton.textContent = 'Cancel';
                cancelButton.classList.add('touch-target');
                cancelButton.setAttribute('aria-label', 'Cancel and close this dialog');
                cancelButton.style.cssText = `
                    padding: 10px 25px;
                    background-color: #f2f2f2;
                    color: #333;
                    border: none;
                    border-radius: 8px;
                    cursor: pointer;
                    font-size: 16px;
                    font-weight: 500;
                    transition: background-color 0.2s;
                `;
                cancelButton.onmouseover = () => { cancelButton.style.backgroundColor = '#e0e0e0'; };
                cancelButton.onmouseout = () => { cancelButton.style.backgroundColor = '#f2f2f2'; };

                cancelButton.addEventListener('click', () => {
                    provideHapticFeedback();
                    popup.classList.add('fade-out');
                    setTimeout(() => {
                        if (document.body.contains(popup)) {
                            document.body.removeChild(popup);
                        }
                    }, 300);
                });

                buttonContainer.appendChild(cancelButton);
            }

            popupContent.appendChild(titleElement);
            popupContent.appendChild(messageElement);
            popupContent.appendChild(buttonContainer);
            popup.appendChild(popupContent);
            document.body.appendChild(popup);
            
            // Set focus to the OK button for keyboard accessibility
            setTimeout(() => {
                okButton.focus();
            }, 100);
            
            // Add to active modals
            activeModals.push(popup);
            
            // Reset auto-recenter timer when showing a popup
            startAutoRecenterTimer();
        } catch (error) {
            console.error("Show popup error:", error);
            // Fallback to alert in case of critical error
            alert(`${title}: ${message}`);
        }
    }

    // *******************************************************
    // * LOCATION HUNT FUNCTIONALITY
    // *******************************************************

    let lastVisitTime = 0;
    const cooldownPeriod = 3 * 60 * 1000; // 3 minutes

    function showLocationHunt(location) {
        try {
            if (!location || !location.id) {
                console.error("Invalid location data for location hunt");
                return;
            }
            
            const now = performance.now();
            if (location.id === lastVisitedLocationId && now - lastVisitTime < cooldownPeriod) {
                console.log(`Location ${location.id} is on cooldown. Skipping.`);
                return;
            }
            
            lastVisitedLocationId = location.id;
            lastVisitTime = now;
            isLocationHuntVisible = true;
            
            // Stop auto-recenter countdown when showing location hunt
            stopAutoRecenterCountdown();

            const lochuntContainer = document.querySelector('.lochunt-container');
            if (!lochuntContainer) {
                console.error("Location hunt container not found");
                return;
            }
            
            lochuntContainer.innerHTML = '';
            lochuntContainer.style.display = 'flex';
            lochuntContainer.classList.add('fade-in');
            lochuntContainer.setAttribute('role', 'dialog');
            lochuntContainer.setAttribute('aria-modal', 'true');
            lochuntContainer.setAttribute('aria-labelledby', 'locationTitle');

            const scrollableContent = document.createElement('div');
            scrollableContent.style.cssText = `
                flex: 1;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
                scroll-behavior: smooth;
                will-change: scroll-position;
            `;

            // Use cached image if available
            let locationImage;
            if (imageCache[location.id]) {
                console.log(`Using cached image for location ${location.id}`);
                locationImage = imageCache[location.id].cloneNode(false);
            } else {
                locationImage = new Image();
                locationImage.crossOrigin = "anonymous";
                locationImage.src = location.image;
                
                // Cache the image for future use
                locationImage.onload = () => {
                    if (!imageCache[location.id]) {
                        imageCache[location.id] = locationImage.cloneNode(false);
                    }
                };
            }
            
            locationImage.alt = location.name || "Location image";
            locationImage.style.cssText = `
                width: 100%;
                height: 45vh;
                object-fit: cover;
                object-position: center;
            `;
            locationImage.loading = "eager"; // Prioritize image loading

            scrollableContent.appendChild(locationImage);
     
            const contentContainer = document.createElement('div');
            contentContainer.classList.add('lochunt-content');
            contentContainer.style.cssText = `
                padding: 24px;
                display: flex;
                flex-direction: column;
                align-items: center;
                max-width: 800px;
                margin: 0 auto;
            `;
            
            const locationInfo = document.createElement('div');
            locationInfo.classList.add('lochunt-info');
            locationInfo.style.cssText = `
                text-align: center;
                width: 100%;
                margin-bottom: 15px;
            `;
            
            const locationName = document.createElement('h1');
            locationName.id = 'locationTitle';
            locationName.textContent = location.name || "Unknown Location";
            locationName.style.cssText = `
                font-size: clamp(1.8rem, 4vw, 2.5rem);
                font-weight: 700;
                color: #1a1a1a;
                margin-bottom: 8px;
                line-height: 1.2;
            `;
            
            const locationCity = document.createElement('p');
            locationCity.textContent = location.city || "";
            locationCity.style.cssText = `
                font-size: clamp(1.1rem, 2vw, 1.3rem);
                color: #2c5282;
                font-weight: 600;
                margin-bottom: 4px;
            `;
            
            const locationCreator = document.createElement('p');
            locationCreator.textContent = location.creator ? `Created by: ${location.creator}` : "";
            locationCreator.style.cssText = `
                font-size: calc(0.9rem + 0.4vw);
                color: #666666;
                font-weight: 500;
            `;
            
            locationInfo.appendChild(locationName);
            locationInfo.appendChild(locationCity);
            locationInfo.appendChild(locationCreator);
            contentContainer.appendChild(locationInfo);
            
            const audioPlayerContainer = createAudioPlayer(location.audio);
            contentContainer.appendChild(audioPlayerContainer);
            scrollableContent.appendChild(contentContainer);
            lochuntContainer.appendChild(scrollableContent);
            
            const blueBar = createBlueBar(location);
            blueBar.style.cssText += `
                position: sticky;
                bottom: 0;
                width: 100%;
            `;
            lochuntContainer.appendChild(blueBar);
            
            // Initialize audio player after DOM is updated
            setTimeout(() => {
                initAudioPlayer();
            }, 100);
        } catch (error) {
            console.error("Show location hunt error:", error);
            isLocationHuntVisible = false;
            
            // Try to recover
            const lochuntContainer = document.querySelector('.lochunt-container');
            if (lochuntContainer) {
                lochuntContainer.style.display = 'none';
            }
            
            showPopup("Location Error", "There was a problem displaying this location. Please try again later.");
        }
    }

    function createAudioPlayer(audioSrc) {
        try {
            if (!audioSrc) {
                console.warn("No audio source provided for audio player");
                return document.createElement('div');
            }
            
            const audioPlayerContainer = document.createElement('div');
            audioPlayerContainer.classList.add('audio-player');
            audioPlayerContainer.style.cssText = `
                width: 100%;
                max-width: 400px;
                margin-bottom: 15px;
            `;

            const audio = document.createElement('audio');
            audio.id = 'locationAudio';
            audio.src = audioSrc;
            audio.preload = "auto";

            const audioProgress = document.createElement('div');
            audioProgress.classList.add('audio-progress');
            audioProgress.style.cssText = `
                width: 100%;
                margin-bottom: 15px;
            `;

            const progressContainer = document.createElement('div');
            progressContainer.classList.add('progress');
            progressContainer.setAttribute('role', 'progressbar');
            progressContainer.setAttribute('aria-valuemin', '0');
            progressContainer.setAttribute('aria-valuemax', '100');
            progressContainer.setAttribute('aria-valuenow', '0');
            progressContainer.style.cssText = `
                height: 8px;
                background-color: #e2e8f0;
                border-radius: 4px;
                cursor: pointer;
                margin-bottom: 12px;
                overflow: hidden;
            `;

            const progressBar = document.createElement('div');
            progressBar.id = 'progressBar';
            progressBar.classList.add('progress-bar');
            progressBar.style.cssText = `
                height: 100%;
                background-color: #2c5282;
                width: 0%;
                transition: width 0.1s linear;
            `;

            progressContainer.appendChild(progressBar);
            audioProgress.appendChild(progressContainer);

            const timeInfo = document.createElement('div');
            timeInfo.classList.add('audio-time');
            timeInfo.style.cssText = `
                display: flex;
                justify-content: space-between;
                color: #4a5568;
                font-size: 0.875rem;
                margin-bottom: 16px;
                font-weight: 500;
            `;

            const currentTimeSpan = document.createElement('span');
            currentTimeSpan.id = 'currentTime';
            currentTimeSpan.textContent = '0:00';

            const durationSpan = document.createElement('span');
            durationSpan.id = 'duration';
            durationSpan.textContent = '0:00';

            timeInfo.appendChild(currentTimeSpan);
            timeInfo.appendChild(durationSpan);

            const audioControls = document.createElement('div');
            audioControls.classList.add('audio-controls');
            audioControls.style.cssText = `
                display: flex;
                justify-content: space-between;
                align-items: center;
                font-size: 24px;
            `;

            const rewindBtn = createAudioButton('skip-backward', 'rewindBtn', 'Rewind 10 seconds');
            const playPauseBtn = createAudioButton('play', 'playPauseBtn', 'Play');
            const forwardBtn = createAudioButton('skip-forward', 'forwardBtn', 'Forward 10 seconds');

            audioControls.appendChild(rewindBtn);
            audioControls.appendChild(playPauseBtn);
            audioControls.appendChild(forwardBtn);

            audioPlayerContainer.appendChild(audio);
            audioPlayerContainer.appendChild(audioProgress);
            audioPlayerContainer.appendChild(timeInfo);
            audioPlayerContainer.appendChild(audioControls);

            return audioPlayerContainer;
        } catch (error) {
            console.error("Audio player creation error:", error);
            return document.createElement('div');
        }
    }

    function createAudioButton(iconName, id, ariaLabel) {
        try {
            const button = document.createElement('button');
            button.id = id;
            button.classList.add('audio-button', 'touch-target', 'interactive');
            button.setAttribute('aria-label', ariaLabel);
            button.innerHTML = `<i class="bi bi-${iconName}"></i>`;
            button.style.cssText = `
                background-color: white;
                color: var(--primary-color);
                border: 2px solid var(--primary-color);
                border-radius: 50%;
                width: 55px;
                height: 55px;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                transition: all 0.3s ease;
            `;

            button.addEventListener('mouseover', () => {
                button.style.backgroundColor = 'var(--hover-color)';
            });

            button.addEventListener('mouseout', () => {
                button.style.backgroundColor = 'white';
            });

            button.addEventListener('click', () => {
                provideHapticFeedback();
                button.style.backgroundColor = 'var(--primary-color)';
                button.style.color = 'white';
                button.style.transform = 'scale(0.95)';
                
                setTimeout(() => {
                    button.style.backgroundColor = 'white';
                    button.style.color = 'var(--primary-color)';
                    button.style.transform = 'scale(1)';
                }, 200);
            });

            return button;
        } catch (error) {
            console.error("Audio button creation error:", error);
            const fallbackButton = document.createElement('button');
            fallbackButton.textContent = ariaLabel;
            return fallbackButton;
        }
    }

    function createBlueBar(location) {
        try {
            const blueBar = document.createElement('div');
            blueBar.style.cssText = `
                width: 100%;
                height: 60px;
                background: linear-gradient(to right, #2c5282, #2b6cb0);
                margin-top: auto;
                box-shadow: 0 -2px 10px rgba(0,0,0,0.025);
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 0 24px;
                position: sticky;
                bottom: 0;
            `;
            
            const infoButton = document.createElement('button');
            infoButton.innerHTML = '<i class="bi bi-info-circle-fill text-white" style="font-size: 1.5rem; z-index: 2500;"></i>';
            infoButton.classList.add('btn', 'btn-sm', 'me-2', 'touch-target', 'interactive');
            infoButton.setAttribute('aria-label', 'Image source information');
            infoButton.onclick = () => {
                provideHapticFeedback();
                if (location && location.imageSource) {
                    showPopup('Image Source', location.imageSource);
                } else {
                    showPopup('Image Source', 'Image source information is not available');
                }
            };

            const feedbackButton = document.createElement('a');
            feedbackButton.href = 'mailto:mattreicher@protonmail.com?subject=Feedback';
            feedbackButton.target = '_blank';
            feedbackButton.rel = 'noopener noreferrer';
            feedbackButton.setAttribute('aria-label', 'Send feedback email');
            feedbackButton.innerHTML = '<i class="bi bi-envelope-fill text-white" style="font-size: 1.5rem;"></i>';
            feedbackButton.classList.add('btn', 'btn-sm', 'touch-target', 'interactive');

            blueBar.appendChild(infoButton);
            blueBar.appendChild(feedbackButton);
            return blueBar;
        } catch (error) {
            console.error("Blue bar creation error:", error);
            return document.createElement('div');
        }
    }

    function initAudioPlayer() {
        try {
            const audio = document.getElementById('locationAudio');
            const playPauseBtn = document.getElementById('playPauseBtn');
            const rewindBtn = document.getElementById('rewindBtn');
            const forwardBtn = document.getElementById('forwardBtn');
            const progressBar = document.getElementById('progressBar');
            const progressContainer = document.querySelector('.progress');
            const currentTimeSpan = document.getElementById('currentTime');
            const durationSpan = document.getElementById('duration');

            if (!audio || !playPauseBtn || !progressBar) {
                console.error("Audio player elements not found");
                return;
            }

            // Set up event listeners
            playPauseBtn.addEventListener('click', togglePlay);
            rewindBtn.addEventListener('click', () => seek(-10));
            forwardBtn.addEventListener('click', () => seek(10));
            audio.addEventListener('timeupdate', updateProgress);
            audio.addEventListener('loadedmetadata', setDuration);
            audio.addEventListener('ended', () => {
                playPauseBtn.innerHTML = '<i class="bi bi-play"></i>';
                playPauseBtn.setAttribute('aria-label', 'Play');
                showAdditionalInfo();
            });
            
            if (progressContainer) {
                progressContainer.addEventListener('click', setProgress);
            }

            // Preload audio
            audio.load();

            function togglePlay() {
                if (audio.paused) {
                    const playPromise = audio.play();
                    if (playPromise !== undefined) {
                        playPromise.then(() => {
                            playPauseBtn.innerHTML = '<i class="bi bi-pause"></i>';
                            playPauseBtn.setAttribute('aria-label', 'Pause');
                        }).catch(error => {
                            console.error("Audio play error:", error);
                            showPopup("Audio Error", "There was a problem playing the audio. Please try again.");
                        });
                    }
                } else {
                    audio.pause();
                    playPauseBtn.innerHTML = '<i class="bi bi-play"></i>';
                    playPauseBtn.setAttribute('aria-label', 'Play');
                }
            }

            function seek(seconds) {
                audio.currentTime = Math.max(0, Math.min(audio.currentTime + seconds, audio.duration));
            }

            function updateProgress() {
                if (!isFinite(audio.duration)) return;
                
                const percent = (audio.currentTime / audio.duration) * 100;
                progressBar.style.width = `${percent}%`;
                progressContainer.setAttribute('aria-valuenow', percent);
                currentTimeSpan.textContent = formatTime(audio.currentTime);
            }

            function setProgress(e) {
                const width = this.clientWidth;
                const clickX = e.offsetX;
                const duration = audio.duration;
                
                if (isFinite(duration) && width > 0) {
                    audio.currentTime = (clickX / width) * duration;
                }
            }

            function setDuration() {
                if (isFinite(audio.duration)) {
                    durationSpan.textContent = formatTime(audio.duration);
                }
            }

            function formatTime(time) {
                if (!isFinite(time)) return "0:00";
                
                const minutes = Math.floor(time / 60);
                const seconds = Math.floor(time % 60);
                return `${minutes}:${seconds.toString().padStart(2, '0')}`;
            }
        } catch (error) {
            console.error("Audio player initialization error:", error);
            showPopup("Audio Error", "There was a problem initializing the audio player. Please try again later.");
        }
    }

    function showAdditionalInfo() {
        try {
            // Find the location using lastVisitedLocationId
            const location = gameLocations.find(loc => loc.id === lastVisitedLocationId);
            if (!location) {
                console.error('Location not found for ID:', lastVisitedLocationId);
                return;
            }
            
            const additionalInfoContainer = document.querySelector('.additional-info-container');
            if (!additionalInfoContainer) {
                console.error("Additional info container not found");
                return;
            }
            
            additionalInfoContainer.style.display = 'block';
            additionalInfoContainer.classList.add('fade-in');
            additionalInfoContainer.setAttribute('role', 'dialog');
            additionalInfoContainer.setAttribute('aria-modal', 'true');
            additionalInfoContainer.setAttribute('aria-labelledby', 'additionalInfoTitle');
            additionalInfoContainer.setAttribute('aria-describedby', 'additionalInfo');
            
            // Add title if it doesn't exist
            let titleElement = additionalInfoContainer.querySelector('h3');
            if (titleElement) {
                titleElement.id = 'additionalInfoTitle';
            } else {
              titleElement = document.createElement('h3');
            titleElement.id = 'additionalInfoTitle';
            titleElement.className = 'mb-3 text-primary text-center';
            titleElement.textContent = 'Did You Know?';
            additionalInfoContainer.insertBefore(titleElement, additionalInfoContainer.firstChild);
        }
        
        document.getElementById('additionalInfo').textContent = location.additionalInfo || 
            "No additional information available for this location.";

        const continueButton = document.getElementById('continueButton');
        if (continueButton) {
            continueButton.onclick = () => {
                provideHapticFeedback();
                additionalInfoContainer.classList.add('fade-out');
                setTimeout(() => {
                    additionalInfoContainer.style.display = 'none';
                    additionalInfoContainer.classList.remove('fade-out');
                    
                    document.querySelector('.lochunt-container').classList.add('fade-out');
                    setTimeout(() => {
                        document.querySelector('.lochunt-container').style.display = 'none';
                        document.querySelector('.lochunt-container').classList.remove('fade-out');
                        isLocationHuntVisible = false;
                        updateDistanceBox();
                        
                        // Restart auto-recenter timer when returning to map
                        startAutoRecenterTimer();
                    }, 300);
                }, 300);
            };
        }
    } catch (error) {
        console.error("Show additional info error:", error);
        // Try to recover
        isLocationHuntVisible = false;
        const lochuntContainer = document.querySelector('.lochunt-container');
        const additionalInfoContainer = document.querySelector('.additional-info-container');
        
        if (lochuntContainer) {
            lochuntContainer.style.display = 'none';
        }
        
        if (additionalInfoContainer) {
            additionalInfoContainer.style.display = 'none';
        }
        
        updateDistanceBox();
        startAutoRecenterTimer();
    }
}

function showLocationSummary(locationId) {
    try {
        const location = gameLocations.find(loc => String(loc.id) === String(locationId));
        
        if (location && location.summary) {
            // Preload the image if it exists
            if (location.image && !imageCache[location.id]) {
                const preloadImage = new Image();
                preloadImage.crossOrigin = "anonymous";
                preloadImage.src = location.image;
                preloadImage.onload = () => {
                    imageCache[location.id] = preloadImage;
                };
                preloadImage.onerror = (error) => {
                    console.error(`Failed to preload image for location ${location.id}:`, error);
                };
            }
            
            const modal = document.getElementById('summaryModal');
            const summaryContent = document.getElementById('summaryContent');
            
            if (!modal || !summaryContent) {
                console.error("Summary modal elements not found");
                return;
            }
            
            modal.style.display = 'flex';
            modal.classList.add('fade-in');
            modal.setAttribute('role', 'dialog');
            modal.setAttribute('aria-modal', 'true');
            modal.setAttribute('aria-labelledby', 'summary-title');
            modal.setAttribute('aria-describedby', 'summaryContent');
            
            isSummaryModalOpen = true;
            
            const modalContent = modal.querySelector('.modal-content');
            modalContent.style.cssText = `
                background-color: white;
                padding: 30px;
                border-radius: 10px;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
                max-width: 500px;
                width: 90%;
                max-height: 80vh;
                overflow-y: auto;
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
            `;
            
            // Remove existing close button if any
            const closeBtn = modal.querySelector('.close');
            if (closeBtn) {
                closeBtn.remove();
            }
            
            summaryContent.style.textAlign = 'left';

            let summaryHTML = `
                <h3 id="summary-title" style="color: var(--primary-color); font-size: 22px; margin-bottom: 15px; text-align: center;">${location.name}</h3>
                <p style="line-height: 1.6; margin-bottom: 15px;">
                    ${location.summary}
                </p>
                <p style="line-height: 1.6; margin-bottom: 15px;">
                    <strong>Location:</strong> ${location.today || "Information not available"}
                </p>
            `;
            
            summaryContent.innerHTML = summaryHTML;
            
            const continueButton = document.createElement('button');
            continueButton.textContent = 'Continue';
            continueButton.classList.add('touch-target', 'interactive');
            continueButton.setAttribute('aria-label', 'Close summary and return to map');
            continueButton.style.cssText = `
                display: block;
                width: auto;
                padding: 12px 20px;
                background-color: var(--primary-color);
                color: white;
                border: none;
                border-radius: 10px;
                cursor: pointer;
                font-size: 18px;
                font-weight: bold;
                transition: background-color 0.3s ease;
                margin: 10px auto -15px;
            `;
            continueButton.onmouseover = function() {
                this.style.backgroundColor = '#0077c2';
            };
            continueButton.onmouseout = function() {
                this.style.backgroundColor = 'var(--primary-color)';
            };
            continueButton.onclick = function() {
                provideHapticFeedback();
                modal.classList.add('fade-out');
                setTimeout(() => {
                    modal.style.display = 'none';
                    modal.classList.remove('fade-out');
                    isSummaryModalOpen = false;
                    stopAutoRecenterCountdown();
                    startAutoRecenterTimer();
                }, 300);
            };
            
            summaryContent.appendChild(continueButton);
            
            // Set focus to the continue button for keyboard accessibility
            setTimeout(() => {
                continueButton.focus();
            }, 100);
            
            // Close modal when clicking outside
            window.onclick = function(event) {
                if (event.target === modal) {
                    modal.classList.add('fade-out');
                    setTimeout(() => {
                        modal.style.display = 'none';
                        modal.classList.remove('fade-out');
                        isSummaryModalOpen = false;
                        stopAutoRecenterCountdown();
                        startAutoRecenterTimer();
                    }, 300);
                }
            };
            
            // Handle escape key for accessibility
            window.addEventListener('keydown', function(event) {
                if (event.key === 'Escape' && isSummaryModalOpen) {
                    continueButton.click();
                }
            });
            
            // Start auto-recenter timer for summary modal
            startAutoRecenterTimer();
        } else {
            console.log("Location or summary not found. Location ID:", locationId);
            showPopup("Error", "Summary not available for this location.");
        }
    } catch (error) {
        console.error("Show location summary error:", error);
        showPopup("Error", "There was a problem displaying the location summary.");
    }
}

function startHunt() {
    try {
        if (!locations || !Array.isArray(locations)) {
            console.error("Locations data not available");
            showPopup("Error", "Location data is not available. Please refresh the page.");
            return;
        }
        
        gameLocations = locations.sort((a, b) => a.id - b.id);
        currentLocationIndex = 0;
        locationCooldowns = {};
        lastVisitedLocationId = null;
        
        // Start preloading images immediately
        preloadAllLocationImages();
        
        // Load all locations on the map
        loadAllLocations();
    } catch (error) {
        console.error("Start hunt error:", error);
        showPopup("Error", "There was a problem starting the hunt. Please refresh the page.");
    }
}

// Improved image preloading function
function preloadAllLocationImages() {
    try {
        if (!gameLocations || !gameLocations.length) {
            console.warn("No locations available for image preloading");
            return;
        }
        
        console.log("Starting to preload ALL location images...");
        
        // Create a queue of valid locations to preload
        const locationsToPreload = gameLocations.filter(location => 
            location && location.image && typeof location.image === 'string' && location.image.trim() !== ''
        );
        
        if (locationsToPreload.length === 0) {
            console.log("No valid images to preload");
            return;
        }
        
        // Track preloading progress
        let loadedCount = 0;
        const totalCount = locationsToPreload.length;
        
        // Function to preload a batch of images
        function preloadNextBatch(startIndex, batchSize) {
            if (startIndex >= totalCount) {
                console.log(`All ${loadedCount} location images preloaded successfully`);
                locationImagePreloaded = true;
                return;
            }
            
            // Calculate end index for this batch
            const endIndex = Math.min(startIndex + batchSize, totalCount);
            
            // Preload each image in the batch
            for (let i = startIndex; i < endIndex; i++) {
                const location = locationsToPreload[i];
                
                // Skip if already cached
                if (imageCache[location.id]) {
                    loadedCount++;
                    continue;
                }
                
                pendingLocationImages.add(location.id);
                
                const img = new Image();
                img.crossOrigin = "anonymous";
                
                img.onload = () => {
                    imageCache[location.id] = img;
                    pendingLocationImages.delete(location.id);
                    loadedCount++;
                    console.log(`Preloaded image ${loadedCount}/${totalCount} for location ${location.id}`);
                    
                    // If all images in this batch are loaded, start the next batch
                    if (loadedCount >= endIndex) {
                        setTimeout(() => preloadNextBatch(endIndex, batchSize), 100);
                    }
                };
                
                img.onerror = (error) => {
                    pendingLocationImages.delete(location.id);
                    loadedCount++;
                    console.error(`Failed to preload image for location ${location.id}:`, error);
                    
                    // Continue to next batch even if there's an error
                    if (loadedCount >= endIndex) {
                        setTimeout(() => preloadNextBatch(endIndex, batchSize), 100);
                    }
                };
                
                // Start loading the image
                img.src = location.image;
            }
        }
        
        // Start preloading with the first batch
        preloadNextBatch(0, IMAGE_PRELOAD_BATCH_SIZE);
    } catch (error) {
        console.error("Image preloading error:", error);
        // Continue without preloaded images if there's an error
    }
}

function getMarkerColor(tours) {
    try {
        if (!tours) return '#0f2bab'; // Default color
        
        switch (tours.toLowerCase()) {
            case 'person':
                return '#FFA500'; // Orange
            case 'gangster':
                return '#3f9b0b'; // Green
            case 'event':
                return '#8B0000'; // Dark red
            case 'place':
                return '#0f2bab'; // Blue
            default:
                return '#0f2bab'; // Default blue
        }
    } catch (error) {
        console.error("Marker color error:", error);
        return '#0f2bab'; // Default blue on error
    }
}

function loadAllLocations() {
    try {
        if (!gameLocations || !Array.isArray(gameLocations) || gameLocations.length === 0) {
            console.error("No locations available to load");
            showPopup("Error", "No locations available. Please try reloading the page.");
            return;
        }

        // Clear existing markers if any
        markerClusterGroup.clearLayers();

        // Create markers for each location
        gameLocations.forEach((location) => {
            if (!location || typeof location.lat !== 'number' || typeof location.lng !== 'number') {
                console.warn("Invalid location data:", location);
                return;
            }

            const markerColor = getMarkerColor(location.tours);
            
            const locationMarker = L.marker([location.lat, location.lng], {
                icon: L.divIcon({
                    className: 'custom-pin-icon',
                    html: `<div class="pin-head" style="background-color: ${markerColor};"></div>`,
                    iconSize: [30, 30],
                    iconAnchor: [15, 30],
                })
            });
                    
            const popupContent = `
                <div class="popup-content">
                    <img src="${location.image}" alt="${location.name || 'Location image'}" class="location-image">
                    <h4 class="location-name">
                        <a href="${location.link || '#'}" target="_blank" rel="noopener noreferrer" style="text-decoration: none; color: inherit;">${location.name || 'Unknown Location'}</a>
                    </h4>
                    <div class="popup-buttons">
                        <button class="button route-button touch-target" data-lat="${location.lat}" data-lng="${location.lng}" aria-label="Get directions to ${location.name || 'this location'}">Directions</button>
                        <button class="button summary-button touch-target" data-location-id="${location.id}" aria-label="View summary of ${location.name || 'this location'}">Summary</button>
                    </div>
                </div>
            `;
            
            locationMarker.bindPopup(popupContent, {
                offset: L.point(0, -25),
                className: 'custom-popup',
                maxWidth: 300
            });
            
            locationMarker.on('popupopen', function(e) {
                const popup = e.popup._contentNode;
                const routeButton = popup.querySelector('.route-button');
                const summaryButton = popup.querySelector('.summary-button');
                
                if (routeButton) {
                    routeButton.addEventListener('click', function(event) {
                        event.preventDefault();
                        provideHapticFeedback();
                        const lat = this.getAttribute('data-lat');
                        const lng = this.getAttribute('data-lng');
                        
                        // Create and show the modal
                        const modal = document.createElement('div');
                        modal.className = 'modal';
                        modal.setAttribute('role', 'dialog');
                        modal.setAttribute('aria-modal', 'true');
                        modal.setAttribute('aria-labelledby', 'navigation-modal-title');
                        modal.style.display = 'flex';
                        modal.classList.add('fade-in');
                        modal.innerHTML = `
                            <div class="modal-content">
                                <h3 id="navigation-modal-title">Choose your preferred navigation app:</h3>
                                <div class="modal-buttons">
                                    <button class="modal-button google-maps touch-target" aria-label="Open in Google Maps">
                                        Google Maps
                                    </button>
                                    <button class="modal-button waze touch-target" aria-label="Open in Waze">
                                        Waze
                                    </button>
                                    <button class="modal-button apple-maps touch-target" aria-label="Open in Apple Maps">
                                        Apple Maps
                                    </button>
                                    <button class="modal-button cancel touch-target" aria-label="Cancel navigation">Cancel</button>
                                </div>
                            </div>
                        `;

                        // Add modal styles if not already present
                        if (!document.querySelector('#modal-styles')) {
                            const style = document.createElement('style');
                            style.id = 'modal-styles';
                            style.textContent = `
                                .modal {
                                    position: fixed;
                                    top: 0;
                                    left: 0;
                                    width: 100%;
                                    height: 100%;
                                    background: rgba(0, 0, 0, 0.75);
                                    display: flex;
                                    justify-content: center;
                                    align-items: center;
                                    z-index: 3000;
                                    padding: 16px;
                                    backdrop-filter: blur(4px);
                                }
                                .modal-content {
                                    background: white;
                                    padding: 24px 16px;
                                    border-radius: 16px;
                                    width: 100%;
                                    max-width: 320px;
                                    text-align: center;
                                    box-shadow: 0 20px 40px rgba(0,0,0,0.2);
                                }
                                .modal-buttons {
                                    margin-top: 20px;
                                    display: flex;
                                    flex-direction: column;
                                    gap: 12px;
                                    align-items: center;
                                }
                                .modal-button {
                                    padding: 16px;
                                    border-radius: 12px;
                                    width: 100%;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    font-size: 16px;
                                    font-weight: 500;
                                    border: none;
                                    cursor: pointer;
                                    transition: transform 0.15s ease;
                                }
                                .modal-button:active {
                                    transform: scale(0.98);
                                }
                                .google-maps {
                                    background: #4285F4;
                                    color: white;
                                    box-shadow: 0 2px 8px rgba(66,133,244,0.3);
                                }
                                .waze {
                                    background: #33ccff;
                                    color: white;
                                    box-shadow: 0 2px 8px rgba(51,204,255,0.3);
                                }
                                .apple-maps {
                                    background: #000000;
                                    color: white;
                                    box-shadow: 0 2px 8px rgba(0,0,0,0.2);
                                }
                                .cancel {
                                    background: #f2f2f2;
                                    color: #666;
                                }
                            `;
                            document.head.appendChild(style);
                        }

                        document.body.appendChild(modal);
                        activeModals.push(modal);
                        
                        // Set focus to first button
                        setTimeout(() => {
                            const firstButton = modal.querySelector('.google-maps');
                            if (firstButton) firstButton.focus();
                        }, 100);

                        // Handle button clicks
                        modal.querySelector('.google-maps').addEventListener('click', () => {
                            provideHapticFeedback();
                            window.location.href = `https://www.google.com/maps/dir/?api=1&destination=${lat},${lng}`;
                            modal.classList.add('fade-out');
                            setTimeout(() => modal.remove(), 300);
                        });

                        modal.querySelector('.waze').addEventListener('click', () => {
                            provideHapticFeedback();
                            window.location.href = `https://www.waze.com/ul?ll=${lat}%2C${lng}&navigate=yes`;
                            modal.classList.add('fade-out');
                            setTimeout(() => modal.remove(), 300);
                        });

                        modal.querySelector('.apple-maps').addEventListener('click', () => {
                            provideHapticFeedback();
                            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
                            if (isIOS) {
                                window.location.href = `maps://maps.apple.com/?daddr=${lat},${lng}`;
                                modal.classList.add('fade-out');
                                setTimeout(() => modal.remove(), 300);
                            } else {
                                const alertEl = document.createElement('div');
                                alertEl.className = 'modal';
                                alertEl.style.zIndex = '4000';
                                alertEl.setAttribute('role', 'alert');
                                alertEl.innerHTML = `
                                    <div class="modal-content">
                                        <p>Apple Maps is only available on iOS devices</p>
                                        <button class="modal-button touch-target" aria-label="Close alert">OK</button>
                                    </div>
                                `;
                                document.body.appendChild(alertEl);
                                activeModals.push(alertEl);
                                
                                const okButton = alertEl.querySelector('button');
                                okButton.onclick = () => {
                                    provideHapticFeedback();
                                    alertEl.remove();
                                };
                                
                                // Set focus to OK button
                                setTimeout(() => {
                                    if (okButton) okButton.focus();
                                }, 100);
                            }
                        });
                        
                        modal.querySelector('.cancel').addEventListener('click', () => {
                            provideHapticFeedback();
                            modal.classList.add('fade-out');
                            setTimeout(() => modal.remove(), 300);
                        });

                        // Close modal if clicking outside
                        modal.addEventListener('click', (e) => {
                            if (e.target === modal) {
                                modal.classList.add('fade-out');
                                setTimeout(() => modal.remove(), 300);
                            }
                        });
                        
                        // Handle escape key
                        modal.addEventListener('keydown', (e) => {
                            if (e.key === 'Escape') {
                                modal.classList.add('fade-out');
                                setTimeout(() => modal.remove(), 300);
                            }
                        });
                    });
                }
                
                if (summaryButton) {
                    summaryButton.addEventListener('click', function(event) {
                        event.preventDefault();
                        provideHapticFeedback();
                        const locationId = this.getAttribute('data-location-id');
                        showLocationSummary(locationId);
                    });
                }
            });
            
            markerClusterGroup.addLayer(locationMarker);
        });
        
        map.addLayer(markerClusterGroup);
        updateDistanceBox();
        resetInactivityTimer();
    } catch (error) {
        console.error("Load locations error:", error);
        showPopup("Error", "There was a problem loading locations. Please refresh the page.");
    }
}

function returnToIndex() {
    try {
        showPopup("Confirm", "Are you ready to exit?", 'info', () => {
            window.location.href = "/index.html";
        });
        
        const returnButton = document.getElementById('returnButton');
        if (returnButton) {
            returnButton.classList.remove('active');
        }
    } catch (error) {
        console.error("Return to index error:", error);
        // Direct navigation on error
        window.location.href = "/index.html";
    }
}

function toggleNavigationTips() {
    try {
        const tipsElement = document.querySelector('.navigation-tips');
        if (!tipsElement) return;
        
        const computedStyle = window.getComputedStyle(tipsElement);

        if (computedStyle.display === 'none') {
            tipsElement.style.display = 'block';
            tipsElement.classList.add('fade-in');
            tipsElement.setAttribute('role', 'dialog');
            tipsElement.setAttribute('aria-modal', 'true');
            tipsElement.setAttribute('aria-labelledby', 'tips-title');
            
            // Set focus to close button
            setTimeout(() => {
                const closeButton = tipsElement.querySelector('.close-button');
                if (closeButton) closeButton.focus();
            }, 100);
        } else {
            tipsElement.classList.add('fade-out');
            setTimeout(() => {
                tipsElement.style.display = 'none';
                tipsElement.classList.remove('fade-out');
            }, 300);
        }

        const tipsButton = document.getElementById('tipsButton');
        if (tipsButton) {
            tipsButton.classList.toggle('active');
        }
    } catch (error) {
        console.error("Toggle navigation tips error:", error);
    }
}

function closeNavigationTips() {
    try {
        const tipsElement = document.querySelector('.navigation-tips');
        if (!tipsElement) return;
        
        tipsElement.classList.add('fade-out');
        setTimeout(() => {
            tipsElement.style.display = 'none';
            tipsElement.classList.remove('fade-out');
        }, 300);
        
        const tipsButton = document.getElementById('tipsButton');
        if (tipsButton) {
            tipsButton.classList.remove('active');
        }
    } catch (error) {
        console.error("Close navigation tips error:", error);
    }
}

function addUIEventListeners() {
    try {
        const recenterButton = document.getElementById('recenterButton');
        if (recenterButton) {
            recenterButton.addEventListener('click', () => {
                recenterMap();
                resetInactivityTimer();
            });
        }
        
        const returnButton = document.getElementById('returnButton');
        if (returnButton) {
            returnButton.addEventListener('click', () => {
                provideHapticFeedback();
                returnToIndex();
                resetInactivityTimer();
            });
        }
        
        const tipsButton = document.getElementById('tipsButton');
        if (tipsButton) {
            tipsButton.addEventListener('click', () => {
                provideHapticFeedback();
                toggleNavigationTips();
                resetInactivityTimer();
            });
        }
        
        const closeButton = document.querySelector('.navigation-tips .close-button');
        if (closeButton) {
            closeButton.addEventListener('click', () => {
                provideHapticFeedback();
                closeNavigationTips();
                resetInactivityTimer();
            });
        }
    } catch (error) {
        console.error("UI event listeners error:", error);
    }
}

function addMapEventListeners() {
    try {
        const startInteraction = () => {
            isMapInteracting = true;
            followUser = false;
            resetInactivityTimer();
            userInteractionTime = Date.now();
            stopAutoRecenterCountdown();
        };

        map.on('movestart zoomstart dragstart', startInteraction);
        
        // Add touch event listeners for mobile
        map.getContainer().addEventListener('touchstart', () => {
            resetInactivityTimer();
            userInteractionTime = Date.now();
        });
        
        // Add keyboard navigation support
        map.getContainer().setAttribute('tabindex', '0');
        map.getContainer().setAttribute('role', 'application');
        map.getContainer().setAttribute('aria-label', 'Interactive map');
        
        map.getContainer().addEventListener('keydown', (e) => {
            // Arrow keys for panning
            if (e.key === 'ArrowUp') {
                map.panBy([0, -50]);
                startInteraction();
            } else if (e.key === 'ArrowDown') {
                map.panBy([0, 50]);
                startInteraction();
            } else if (e.key === 'ArrowLeft') {
                map.panBy([-50, 0]);
                startInteraction();
            } else if (e.key === 'ArrowRight') {
                map.panBy([50, 0]);
                startInteraction();
            }
            // + and - for zoom
            else if (e.key === '+' || e.key === '=') {
                map.zoomIn();
                startInteraction();
            } else if (e.key === '-' || e.key === '_') {
                map.zoomOut();
                startInteraction();
            }
            // r for recenter
            else if (e.key === 'r' || e.key === 'R') {
                recenterMap();
            }
        });
    } catch (error) {
        console.error("Map event listeners error:", error);
    }
}

function resetInactivityTimer() {
    try {
        clearTimeout(inactivityTimer);
        inactivityTimer = setTimeout(checkInactivity, INACTIVITY_TIMEOUT);
    } catch (error) {
        console.error("Reset inactivity timer error:", error);
    }
}

function checkInactivity() {
    try {
        console.log('Inactivity timer triggered');
        isMapInteracting = false;
        
        // Close any open popups
        map.closePopup();
        map.eachLayer((layer) => {
            if (layer.getPopup && layer.getPopup()?.isOpen()) {
                layer.closePopup();
            }
        });
        
        if (!isLocationHuntVisible) {
            recenterMap();
        }
    } catch (error) {
        console.error("Inactivity check error:", error);
    }
}

// *******************************************************
// * DEBUGGING UTILITIES
// *******************************************************

// Add motion path point to visualize actual user trajectory
function addMotionPathPoint(position) {
    try {
        if (!DEBUG_MODE) return;
        
        const motionPath = document.getElementById('motionPath');
        if (!motionPath) return;
        
        const point = document.createElement('div');
        point.className = 'motion-path-point';
        
        const pixelPoint = map.latLngToContainerPoint([position.lat, position.lng]);
        point.style.left = `${pixelPoint.x}px`;
        point.style.top = `${pixelPoint.y}px`;
        
        motionPath.appendChild(point);
        
        // Limit number of points
        const points = motionPath.getElementsByClassName('motion-path-point');
        while (points.length > PATH_VISUALIZATION_MAX_POINTS) {
            motionPath.removeChild(points[0]);
        }
    } catch (error) {
        console.error("Motion path point error:", error);
    }
}

// Add predicted path point to visualize the predicted trajectory
function addPredictedPathPoint(position) {
    try {
        if (!DEBUG_MODE) return;
        
        const motionPath = document.getElementById('motionPath');
        if (!motionPath) return;
        
        const point = document.createElement('div');
        point.className = 'predicted-path-point';
        
        const pixelPoint = map.latLngToContainerPoint([position.lat, position.lng]);
        point.style.left = `${pixelPoint.x}px`;
        point.style.top = `${pixelPoint.y}px`;
        
        motionPath.appendChild(point);
        
        // Limit number of points
        const points = motionPath.getElementsByClassName('predicted-path-point');
        while (points.length > PATH_VISUALIZATION_MAX_POINTS / 2) {
            motionPath.removeChild(points[0]);
        }
    } catch (error) {
        console.error("Predicted path point error:", error);
    }
}

// Update debug overlay with useful information
function updateDebugOverlay() {
    try {
        if (!DEBUG_MODE) return;
        
        const debugInfo = document.getElementById('debugInfo');
        if (!debugInfo) return;
        
        let info = '';
        
        // Add position info
        if (lastPosition) {
            info += `Pos: ${lastPosition.lat.toFixed(6)}, ${lastPosition.lng.toFixed(6)}<br>`;
            info += `Acc: ${lastPosition.accuracy.toFixed(1)}m<br>`;
            
            if (lastPosition.speedMPS !== undefined) {
                info += `Speed: ${(lastPosition.speedMPS * 2.23694).toFixed(1)} mph<br>`;
            }
            
            if (lastPosition.heading !== undefined) {
                info += `Heading: ${lastPosition.heading.toFixed(0)}°<br>`;
            }
        }
        
        // Add velocity/acceleration info
        if (lastVelocity) {
            const velMagnitude = Math.sqrt(
                lastVelocity.lat * lastVelocity.lat + 
                lastVelocity.lng * lastVelocity.lng
            ) * 111000 * 2.23694; // Convert to mph
            
            info += `Vel: ${velMagnitude.toFixed(2)} mph<br>`;
        }
        
        // Add stationary info
        info += `Stationary: ${isStationary ? 'Yes' : 'No'}<br>`;
        info += `Follow: ${followUser ? 'Yes' : 'No'}<br>`;
        
        // Add buffer info
        info += `Buffer: ${positionBuffer.length} pts<br>`;
        
        // Add rejected positions count
        info += `Rejected: ${rejectedPositions.length} pts<br>`;
        
        // Update the debug info
        debugInfo.innerHTML = info;
        
        // Reposition path points when map moves
        if (DEBUG_MODE) {
            repositionPathPoints();
        }
    } catch (error) {
        console.error("Debug overlay update error:", error);
    }
}

// Reposition path visualization points when map changes
function repositionPathPoints() {
    try {
        const motionPathPoints = document.getElementsByClassName('motion-path-point');
        const predictedPathPoints = document.getElementsByClassName('predicted-path-point');
        
        // Clear all points if too many to avoid performance issues
        if (motionPathPoints.length > PATH_VISUALIZATION_MAX_POINTS * 2) {
            const motionPath = document.getElementById('motionPath');
            if (motionPath) {
                motionPath.innerHTML = '';
            }
            return;
        }
        
        // Hide points when map is interacted with to avoid performance issues
        const motionPath = document.getElementById('motionPath');
        if (motionPath) {
            motionPath.style.display = isMapInteracting ? 'none' : 'block';
        }
    } catch (error) {
        console.error("Path points repositioning error:", error);
    }
}

    // Initialize the application
    initMap();
    </script>
</body>
</html>
           
