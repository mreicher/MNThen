<!DOCTYPE html>
<html lang="en">
<head> 
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Minnesota Then | Museum Without Walls</title>
    <link rel="shortcut icon" type="image/x-icon" href="https://www.mnthen.com/images/mnthenfav.ico">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css">
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css">
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css">
    <link rel="stylesheet" href="https://www.mnthen.com/css/mainmap.css">
   
<style>
    :root {
        --primary-color: #005f9e;
        --hover-color: #e6f0f7;
    }
    
    @keyframes pulse {
        0% {
            transform: scale(1);
            opacity: 1;
        }
        50% {
            transform: scale(1.15);
            opacity: 0.8;
        }
        100% {
            transform: scale(1);
            opacity: 1;
        }
    }
    
    .user-marker-icon {
        background-color: #dc2626;
        border-radius: 50%;
        width: 16px;
        height: 16px;
        margin: 2px;
        animation: pulse 2s infinite ease-in-out;
        box-shadow: 0 0 0 rgba(220, 38, 38, 0.6);
        will-change: transform, opacity;
    }
    
    .user-marker-pulse {
        position: absolute;
        width: 40px;
        height: 40px;
        margin-left: -10px;
        margin-top: -10px;
        border-radius: 50%;
        background-color: rgba(220, 38, 38, 0.3);
        animation: pulse 2s infinite ease-out;
        z-index: -1;
        will-change: transform, opacity;
    }
    
    /* Optimize modal styles */
    .modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.75);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
        padding: 16px;
        backdrop-filter: blur(4px);
    }
    
    .modal-content {
        background: white;
        padding: 24px 16px;
        border-radius: 16px;
        width: 100%;
        max-width: 320px;
        text-align: center;
        box-shadow: 0 20px 40px rgba(0,0,0,0.2);
    }
    
    .modal-buttons {
        margin-top: 20px;
        display: flex;
        flex-direction: column;
        gap: 12px;
        align-items: center;
    }
    
    .modal-button {
        padding: 16px;
        border-radius: 12px;
        width: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 16px;
        font-weight: 500;
        border: none;
        cursor: pointer;
        transition: transform 0.15s ease;
    }
    
    .modal-button:active {
        transform: scale(0.98);
    }
    
    .google-maps {
        background: #4285F4;
        color: white;
        box-shadow: 0 2px 8px rgba(66,133,244,0.3);
    }
    
    .waze {
        background: #33ccff;
        color: white;
        box-shadow: 0 2px 8px rgba(51,204,255,0.3);
    }
    
    .apple-maps {
        background: #000000;
        color: white;
        box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    }
    
    .cancel {
        background: #f2f2f2;
        color: #666;
    }
    
    /* Loading message styles */
    #loadingMessage {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: rgba(255, 255, 255, 0.9);
        padding: 30px;
        border-radius: 10px;
        z-index: 1000;
        text-align: center;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        min-width: 280px;
    }

    /* Error message styles */
    .error-message {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background-color: #f8d7da;
        color: #721c24;
        border: 1px solid #f5c6cb;
        border-radius: 8px;
        padding: 12px 20px;
        z-index: 1000;
        box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        display: flex;
        align-items: center;
        justify-content: space-between;
        max-width: 90%;
        min-width: 280px;
        animation: slideUp 0.3s ease-out forwards;
    }

    .error-message button {
        background: none;
        border: none;
        color: #721c24;
        font-weight: bold;
        cursor: pointer;
        margin-left: 10px;
        padding: 5px;
    }

    .retry-button {
        background-color: #721c24;
        color: white;
        border: none;
        border-radius: 4px;
        padding: 6px 12px;
        margin-left: 10px;
        cursor: pointer;
        font-size: 14px;
    }

    @keyframes slideUp {
        from {
            opacity: 0;
            transform: translate(-50%, 20px);
        }
        to {
            opacity: 1;
            transform: translate(-50%, 0);
        }
    }

    /* Accessibility improvements */
    .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border-width: 0;
    }

    /* Fallback content styles */
    .fallback-content {
        padding: 20px;
        text-align: center;
        background-color: #f8f9fa;
        border-radius: 8px;
        margin: 20px;
    }
</style>
</head>
<body>
    <div id="map"></div>
    <div id="distanceBox" role="status" aria-live="polite">Initializing...</div>

    <div class="lochunt-container">
        <img id="locationImage" src="/placeholder.svg" alt="Location Image">
        <div class="lochunt-content">
            <div class="lochunt-info">
                <h2 id="locationTitle" class="mb-2 text-primary"></h2>
                <p id="locationCity" class="text-muted mb-1"></p>
                <p id="locationCreator" class="text-muted mb-3"></p>
            </div>
            <div class="audio-player">
                <div class="audio-progress">
                    <div class="progress">
                        <div id="progressBar" class="progress-bar" role="progressbar" style="width: 0%" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100"></div>
                    </div>
                </div>
                <div class="audio-time">
                    <span id="currentTime">0:00</span>
                    <span id="duration">0:00</span>
                </div>
                <div class="audio-controls">
                    <button id="rewindBtn" class="audio-button" aria-label="Rewind 10 seconds"><i class="fas fa-backward" aria-hidden="true"></i></button>
                    <button id="playPauseBtn" class="audio-button" aria-label="Play"><i class="fas fa-play" aria-hidden="true"></i></button>
                    <button id="forwardBtn" class="audio-button" aria-label="Forward 10 seconds"><i class="fas fa-forward" aria-hidden="true"></i></button>
                </div>
                <audio id="locationAudio" src="/placeholder.svg" preload="metadata"></audio>
            </div>
        </div>
    </div>
<div class="additional-info-container">
   <h3 class="mb-3 text-primary text-center">Did You Know?</h3>
   <p id="additionalInfo" class="mb-3 fs-6"></p>
   <div class="d-flex justify-content-center">
       <button id="continueButton" class="btn btn-primary">Continue</button>
   </div>
</div>

    <div class="map-buttons-container">
        <div class="map-buttons">
            <button id="recenterButton" class="map-button touch-target" aria-label="Recenter map"><i class="fas fa-crosshairs" aria-hidden="true"></i></button>
            <button id="returnButton" class="map-button touch-target" aria-label="Return to home"><i class="fas fa-sign-out-alt" aria-hidden="true"></i></button>
            <button id="tipsButton" class="map-button touch-target" aria-label="Navigation tips"><i class="fas fa-question-circle" aria-hidden="true"></i></button>
        </div>
    </div>
    
    <div class="navigation-tips">
        <button class="close-button" aria-label="Close navigation tips">&times;</button>
        <h3>Navigation Tips</h3>
        <ul>
            <li>Use the map to navigate to the marked locations.</li>
            <li>The distance box shows how far you are from the current location.</li>
            <li>Tap the recenter button to focus on your current position.</li>
            <li>When you're within 20 feet of a location, you'll be able to interact with it.</li>
            <li>Listen to the audio information for each location.</li>
            <li>After the audio, you'll see additional information about the location.</li>
        </ul>
    </div>

    <div id="summaryModal" class="modal" style="display: none;" aria-modal="true" role="dialog">
        <div class="modal-content">
            <p id="summaryContent"></p>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"></script>
    <script src="/locations_test.js?v=1.0.4"></script>

    <script>
// Add these constants for better initialization stability
const INITIAL_STABILIZATION_PERIOD = 5000; // 5 seconds of extra stability on startup
const INITIAL_SMOOTHING_FACTOR = 0.02; // Very low smoothing factor during initialization
const MAX_BUFFER_SIZE = 5;
const DISTANCE_THRESHOLD = 20; // 20 feet to measure threshold distance to marker before opening location page.
const MICRO_MOVEMENT_THRESHOLD = 0.5; // Increase to be less sensitive
const STATIONARY_ACCURACY_MULTIPLIER = 1.2;
const ANIMATION_FRAME_RATE = 60; // Target frame rate for smooth animations
const PHYSICS_UPDATE_RATE = 20; // Physics updates per second (decoupled from rendering)
const MAX_BUFFER_SIZE_STATIONARY = 15; // Larger buffer for stationary positions
const ACCELERATION_DECAY = 0.85; // How quickly acceleration decays
const VELOCITY_DECAY = 0.8; // How quickly velocity decays
const POSITION_CONFIDENCE_THRESHOLD = 0.7; // Threshold for position confidence
const ADAPTIVE_SMOOTHING_MIN = 0.05; // Lower minimum smoothing factor for more stability
const ADAPTIVE_SMOOTHING_MAX = 0.9; // Maximum smoothing factor
const STATIONARY_MOVEMENT_THRESHOLD = 0.15; // Extremely low threshold for stationary movement
const STATIONARY_TRANSITION_COUNT = 5; // Reduced for more balanced transitions
const MOTION_TRANSITION_COUNT = 2; // Adjusted for better response
const STATIONARY_POSITION_FREEZE_TIME = 2000; // Reduced freeze time
const EXTENDED_DISTANCE_THRESHOLD = 100; // Preserve the extended distance threshold
const MAX_ACCEPTABLE_ACCURACY = 35; // meters 
const BACKGROUND_THRESHOLD = 25000;
const INACTIVITY_TIMEOUT = 30000; // 30 seconds inactivity timeout
const MIN_RECENTER_INTERVAL = 1500;
const MAX_RETRIES = 3;
const RETRY_DELAY = 1000;
const RECENTER_ZOOM_LEVELS = {
    STATIONARY: 19,
    WALKING: 18,
    CYCLING: 17,
    DRIVING_SLOW: 16,
    DRIVING_FAST: 15
};
const EDGE_THRESHOLD_PERCENTAGE = 0.25;
const STRICT_EDGE_THRESHOLD_PERCENTAGE = 0.15;
const CRITICAL_EDGE_THRESHOLD_PERCENTAGE = 0.07;
// Add a new constant for extended distance stabilization
const EXTENDED_DISTANCE_STABILIZATION_PERIOD = 1000; // 1 second stabilization after extended distance jump
// Add constants for sensor fusion
const GYRO_WEIGHT = 0.3; // Weight for gyroscope data in sensor fusion
const ACCEL_WEIGHT = 0.2; // Weight for accelerometer data in sensor fusion
const GPS_WEIGHT = 0.5; // Weight for GPS data in sensor fusion
// Add constants for error handling
const ERROR_DISPLAY_DURATION = 5000; // How long to show error messages
const ERROR_COOLDOWN_PERIOD = 10000; // Minimum time between similar errors

// State variables
let map, userMarker, markerClusterGroup;
let currentLocationIndex = 0;
let visitedLocations = [];
let gameLocations = [];
let inactivityTimer;
let isLocationHuntVisible = false;
let lastPosition = null;
let positionBuffer = [];
let filteredPosition = null;
let velocity = { lat: 0, lng: 0 };
let isMapInteracting = false;
let followUser = true;
let locationCooldowns = {};
let appInitTime = 0; // Track when the app was initialized
let isInitializing = true; // Flag for initialization phase
let lastHiddenTime = 0;
let lastKnownPosition = null;
let isTransitioning = false;
let lastVisitedLocationId = null;
let animationFrameId = null;
let lastAnimationTimestamp = 0;
let lastPhysicsUpdateTime = 0;
let acceleration = { lat: 0, lng: 0 };
let lastVelocity = { lat: 0, lng: 0 };
let targetPosition = null;
let isStationary = false;
let stationaryBuffer = [];
let stationaryStartTime = null;
let stationaryCheckTimeout = null;
let lastUpdateTime = null;
let lastUpdateTimestamp = null;
let stationaryCount = 0;
let lastSmoothedPosition = null;
let lastRecenterTime = 0;
let retryCount = 0;
let activeLocationData = null;
let audioPlaybackPosition = 0;
let isAudioPlaying = false;
let isAdditionalInfoShown = false;
let lastVisitTime = 0;
let debounceTimeout;
// Add new state variables for extended distance handling
let isExtendedDistanceJump = false;
let extendedDistanceStabilizationTimer = null;
// Add new state variables for inactivity tracking
let lastUserMovementTime = 0;
let lastUserInteractionTime = 0;
let lastIconPosition = null;
// Add new state variables for sensor fusion
let gyroscopeData = { alpha: 0, beta: 0, gamma: 0 };
let accelerometerData = { x: 0, y: 0, z: 0 };
let hasSensorPermission = false;
// Add new state variables for error handling
let activeErrors = {};
let errorObserver = null;
let domChangeObserver = null;

// Enhanced Kalman filter with adaptive parameters
const kalmanFilter = {
    x: { estimate: 0, error: 1 },
    y: { estimate: 0, error: 1 },
    q: 0.01, // Process noise - lower for smoother tracking
    r: 1,    // Measurement noise - will be adjusted dynamically
    
    update: function(measurement, accuracy) {
        // Initialize if first measurement
        if (this.x.estimate === 0 && this.y.estimate === 0) {
            this.x.estimate = measurement.lng;
            this.y.estimate = measurement.lat;
            this.x.error = 1;
            this.y.error = 1;
            return measurement;
        }
        
        // Adjust measurement noise based on GPS accuracy and stationary state
        this.r = isStationary 
            ? Math.max(0.5, Math.min(10, accuracy / 10)) // Higher noise rejection when stationary
            : Math.max(0.1, Math.min(5, accuracy / 20));
        
        // Adjust process noise based on stationary state
        this.q = isStationary ? 0.001 : 0.01;
        
        // X coordinate (longitude)
        let predX = this.x.estimate;
        let predErrX = this.x.error + this.q;
        let gainX = predErrX / (predErrX + this.r);
        this.x.estimate = predX + gainX * (measurement.lng - predX);
        this.x.error = (1 - gainX) * predErrX;
        
        // Y coordinate (latitude)
        let predY = this.y.estimate;
        let predErrY = this.y.error + this.q;
        let gainY = predErrY / (predErrY + this.r);
        this.y.estimate = predY + gainY * (measurement.lat - predY);
        this.y.error = (1 - gainY) * predErrY;
        
        return {
            lat: this.y.estimate,
            lng: this.x.estimate,
            accuracy: measurement.accuracy,
            timestamp: measurement.timestamp,
            heading: measurement.heading,
            speedMPS: measurement.speedMPS
        };
    },
    
    reset: function(measurement) {
        this.x.estimate = measurement.lng;
        this.y.estimate = measurement.lat;
        this.x.error = 1;
        this.y.error = 1;
    }
};

// Initialize DOM mutation observer to replace old DOM mutation events
function initDomObservers() {
    // Observer for error messages
    errorObserver = new MutationObserver(mutations => {
        mutations.forEach(mutation => {
            if (mutation.type === 'childList') {
                mutation.addedNodes.forEach(node => {
                    if (node.classList && node.classList.contains('error-message')) {
                        // Auto-remove error messages after a delay
                        setTimeout(() => {
                            if (node.parentNode) {
                                node.parentNode.removeChild(node);
                            }
                        }, ERROR_DISPLAY_DURATION);
                    }
                });
            }
        });
    });
    
    // Start observing the body for error messages
    errorObserver.observe(document.body, { 
        childList: true,
        subtree: false
    });
    
    // Observer for dynamic content changes
    domChangeObserver = new MutationObserver(mutations => {
        mutations.forEach(mutation => {
            if (mutation.type === 'childList') {
                // Check for added nodes that might need event listeners
                mutation.addedNodes.forEach(node => {
                    if (node.nodeType === 1) { // Element node
                        // Add event listeners to any new buttons or interactive elements
                        const buttons = node.querySelectorAll('button');
                        buttons.forEach(button => {
                            button.addEventListener('click', updateUserInteractionTime);
                        });
                        
                        // Check for popups and add listeners
                        if (node.classList && (node.classList.contains('popup') || 
                                              node.classList.contains('modal'))) {
                            updateUserInteractionTime();
                        }
                    }
                });
            }
        });
    });
    
    // Start observing the body for content changes
    domChangeObserver.observe(document.body, { 
        childList: true,
        subtree: true
    });
    
    console.log("DOM Mutation Observers initialized");
}

// Initialize motion sensors for improved location accuracy
function initMotionSensors() {
    if (typeof DeviceMotionEvent !== 'undefined' && 
        typeof DeviceMotionEvent.requestPermission === 'function') {
        // iOS 13+ requires permission
        DeviceMotionEvent.requestPermission()
            .then(permissionState => {
                if (permissionState === 'granted') {
                    hasSensorPermission = true;
                    window.addEventListener('devicemotion', handleMotionEvent, true);
                    console.log("Motion sensor permission granted");
                } else {
                    console.log("Motion sensor permission denied");
                }
            })
            .catch(console.error);
    } else if (window.DeviceMotionEvent) {
        // Other browsers
        hasSensorPermission = true;
        window.addEventListener('devicemotion', handleMotionEvent, true);
        console.log("Motion sensors initialized");
    } else {
        console.log("Device motion not supported");
    }
    
    if (typeof DeviceOrientationEvent !== 'undefined' && 
        typeof DeviceOrientationEvent.requestPermission === 'function') {
        // iOS 13+ requires permission
        DeviceOrientationEvent.requestPermission()
            .then(permissionState => {
                if (permissionState === 'granted') {
                    hasSensorPermission = true;
                    window.addEventListener('deviceorientation', handleOrientationEvent, true);
                    console.log("Orientation sensor permission granted");
                } else {
                    console.log("Orientation sensor permission denied");
                }
            })
            .catch(console.error);
    } else if (window.DeviceOrientationEvent) {
        // Other browsers
        hasSensorPermission = true;
        window.addEventListener('deviceorientation', handleOrientationEvent, true);
        console.log("Orientation sensors initialized");
    } else {
        console.log("Device orientation not supported");
    }
}

// Handle device motion events
function handleMotionEvent(event) {
    if (!event.accelerationIncludingGravity) return;
    
    accelerometerData = {
        x: event.accelerationIncludingGravity.x || 0,
        y: event.accelerationIncludingGravity.y || 0,
        z: event.accelerationIncludingGravity.z || 0,
        timestamp: Date.now()
    };
    
    // Use accelerometer data to improve movement detection
    const magnitude = Math.sqrt(
        accelerometerData.x * accelerometerData.x + 
        accelerometerData.y * accelerometerData.y + 
        accelerometerData.z * accelerometerData.z
    );
    
    // Detect significant movement from accelerometer
    if (magnitude > 12) { // Threshold for significant movement
        // Reset stationary state if we detect significant movement
        if (isStationary) {
            stationaryCount = Math.max(0, stationaryCount - 1);
            if (stationaryCount === 0) {
                isStationary = false;
                console.log("Exiting stationary state due to accelerometer movement");
            }
        }
        
        // Update user movement time
        lastUserMovementTime = Date.now();
    }
}

// Handle device orientation events
function handleOrientationEvent(event) {
    gyroscopeData = {
        alpha: event.alpha || 0, // Z-axis rotation
        beta: event.beta || 0,   // X-axis rotation
        gamma: event.gamma || 0, // Y-axis rotation
        timestamp: Date.now()
    };
    
    // Use gyroscope data to improve heading accuracy
    if (lastPosition && typeof lastPosition.heading !== 'undefined') {
        // Combine GPS heading with gyroscope data for smoother heading changes
        const compassHeading = event.webkitCompassHeading || 
                              (event.alpha ? 360 - event.alpha : null);
        
        if (compassHeading !== null) {
            // Weighted average between GPS heading and compass heading
            const gpsWeight = 0.7;
            const compassWeight = 0.3;
            
            // Only update if we have a valid GPS heading
            if (!isNaN(lastPosition.heading)) {
                lastPosition.heading = 
                    (lastPosition.heading * gpsWeight) + 
                    (compassHeading * compassWeight);
            }
        }
    }
}

function initMap() {
    map = L.map('map', {
        zoomControl: false,
        attributionControl: false,
        zoomSnap: 0.1,
        zoomDelta: 0.5,
        wheelDebounceTime: 100,
        tapTolerance: 15,
        bounceAtZoomLimits: false
    }).fitWorld();

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 18,
        attribution: '© OpenStreetMap contributors',
        updateWhenIdle: true,
        updateWhenZooming: false
    }).addTo(map);

    markerClusterGroup = L.markerClusterGroup({
        showCoverageOnHover: false,
        zoomToBoundsOnClick: true,
        spiderfyOnMaxZoom: true,
        animate: true,
        animateAddingMarkers: true,
        iconCreateFunction: function(cluster) {
            return L.divIcon({
                html: '<div><span>' + cluster.getChildCount() + '</span></div>',
                className: 'marker-cluster-custom',
                iconSize: L.point(40, 40)
            });
        }
    });
    map.addLayer(markerClusterGroup);

    // Create user icon and marker with pulsing effect
    const userIcon = L.divIcon({
        className: 'user-marker',
        html: '<div class="user-marker-pulse"></div><div class="user-marker-icon"></div>',
        iconSize: [20, 20],
        iconAnchor: [10, 10]
    });
    userMarker = L.marker([0, 0], { icon: userIcon }).addTo(map);
    
    showLoadingMessage();

    // Initialize DOM observers (replacing old mutation events)
    initDomObservers();
    
    // Initialize motion sensors for improved accuracy
    initMotionSensors();

    if ("geolocation" in navigator) {
        const options = {
            enableHighAccuracy: true,
            timeout: 45000,
            maximumAge: 0
        };

        // Try first time
        navigator.geolocation.getCurrentPosition(
            initializeUserLocation,
            (error) => {
                // On error, try one more time before falling back
                navigator.geolocation.getCurrentPosition(
                    initializeUserLocation,
                    handleLocationError,
                    options
                );
            },
            options
        );
    } else {
        showErrorMessage("Geolocation is not supported by your browser", "warning", showFallbackContent);
        map.setView([44.9778, -93.2650], 18);
        hideLoadingMessage();
    }
    
    document.addEventListener('visibilitychange', handleVisibilityChange);

    map.on('movestart zoomstart', () => {
        followUser = false;
        isMapInteracting = true;
        updateUserInteractionTime();
    });

    map.on('moveend zoomend', () => {
        isMapInteracting = false;
        updateUserInteractionTime();
    });

    map.touchZoom.enable();
    map.doubleClickZoom.enable();
    
    // Initialize inactivity system
    initInactivitySystem();
}

function showLoadingMessage() {
    // Remove any existing loading message first
    hideLoadingMessage();
    
    const loadingMessage = document.createElement('div');
    loadingMessage.id = 'loadingMessage';
    loadingMessage.setAttribute('role', 'status');
    loadingMessage.setAttribute('aria-live', 'polite');
    loadingMessage.innerHTML = '<p style="font-size: 18px; font-weight: 500; margin-bottom: 10px;">Searching for your location...</p>';
    document.body.appendChild(loadingMessage);
}

function hideLoadingMessage() {
    const loadingMessage = document.getElementById('loadingMessage');
    if (loadingMessage) {
        document.body.removeChild(loadingMessage);
    }
}

// New function to show error messages with retry options
function showErrorMessage(message, type = 'error', retryCallback = null) {
    // Check if we've shown this error recently to avoid spamming
    const errorKey = message.substring(0, 30); // Use first 30 chars as key
    const now = Date.now();
    
    if (activeErrors[errorKey] && now - activeErrors[errorKey] < ERROR_COOLDOWN_PERIOD) {
        console.log("Error message throttled:", message);
        return;
    }
    
    // Record this error to prevent duplicates
    activeErrors[errorKey] = now;
    
    // Create error message element
    const errorElement = document.createElement('div');
    errorElement.className = 'error-message';
    errorElement.setAttribute('role', 'alert');
    
    // Set appropriate styling based on type
    if (type === 'warning') {
        errorElement.style.backgroundColor = '#fff3cd';
        errorElement.style.color = '#856404';
        errorElement.style.borderColor = '#ffeeba';
    }
    
    // Create message content
    const messageContent = document.createElement('span');
    messageContent.textContent = message;
    errorElement.appendChild(messageContent);
    
    // Add retry button if callback provided
    if (retryCallback) {
        const retryButton = document.createElement('button');
        retryButton.className = 'retry-button';
        retryButton.textContent = 'Retry';
        retryButton.addEventListener('click', () => {
            errorElement.remove();
            retryCallback();
        });
        errorElement.appendChild(retryButton);
    }
    
    // Add close button
    const closeButton = document.createElement('button');
    closeButton.textContent = '×';
    closeButton.setAttribute('aria-label', 'Close');
    closeButton.addEventListener('click', () => {
        errorElement.remove();
    });
    errorElement.appendChild(closeButton);
    
    // Add to document
    document.body.appendChild(errorElement);
    
    // Auto-remove after timeout (handled by mutation observer)
}

// Show fallback content when location services fail
function showFallbackContent() {
    const mapContainer = document.getElementById('map');
    
    const fallbackContent = document.createElement('div');
    fallbackContent.className = 'fallback-content';
    fallbackContent.innerHTML = `
        <h2>Minnesota Then | Museum Without Walls</h2>
        <p>This interactive map experience requires location services to work properly.</p>
        <p>You can still explore historical locations by clicking on the markers on the map.</p>
        <button id="tryAgainButton" class="btn btn-primary mt-3">Try Again</button>
    `;
    
    mapContainer.appendChild(fallbackContent);
    
    document.getElementById('tryAgainButton').addEventListener('click', () => {
        fallbackContent.remove();
        initMap();
    });
}

function initializeUserLocation(position) {
    console.log("Initial position data:", JSON.stringify(position));

    if (!position || !position.coords) {
        console.error("Invalid initial position object");
        handleLocationError(new Error("Invalid initial position"));
        return;
    }

    const { latitude: userLat, longitude: userLng, accuracy } = position.coords;

    if (isNaN(userLat) || isNaN(userLng)) {
        console.error("Invalid initial coordinates:", { userLat, userLng });
        handleLocationError(new Error("Invalid coordinates"));
        return;
    }

    console.log("Valid initial position:", { userLat, userLng, accuracy });

    try {
        userMarker.setLatLng([userLat, userLng]);
        map.setView([userLat, userLng], 19); 
    } catch (error) {
        console.error("Error setting initial user location:", error);
        handleLocationError(error);
        return;
    }

    // Set initialization time and flags
    appInitTime = Date.now();
    isInitializing = true;
    
    // Initialize inactivity tracking
    lastUserMovementTime = Date.now();
    lastUserInteractionTime = Date.now();
    lastIconPosition = { lat: userLat, lng: userLng };
    
    // Update loading message to indicate stabilization
    const loadingMessage = document.getElementById('loadingMessage');
    if (loadingMessage) {
        loadingMessage.innerHTML = '<p style="font-size: 18px; font-weight: 500; margin-bottom: 10px;">Stabilizing your position...</p><p style="font-size: 16px; color: #444;">Please wait a moment</p>';
    }
    
    // Start preloading location images
    preloadLocationImages();
    
    // Set a timeout to exit initialization mode and hide loading message
    setTimeout(() => {
        isInitializing = false;
        console.log("Exiting initialization mode");
        hideLoadingMessage();
    }, INITIAL_STABILIZATION_PERIOD);

    startPositionUpdates();
    startHunt();
    
    // Start animation loop
    startAnimationLoop();
    
    // Restore any active location if it exists
    restoreLocationState();
}

function preloadLocationImages() {
    if (!locations || !Array.isArray(locations)) {
        console.warn("No locations available for preloading images");
        return;
    }
    
    console.log("Starting to preload " + locations.length + " location images");
    
    // Create a container to track preloading progress
    const preloadContainer = document.createElement('div');
    preloadContainer.style.cssText = `
        width: 100%;
        height: 4px;
        background-color: #eee;
        margin-top: 15px;
        border-radius: 2px;
        overflow: hidden;
    `;
    
    const progressBar = document.createElement('div');
    progressBar.style.cssText = `
        height: 100%;
        width: 0%;
        background-color: #005f9e;
        transition: width 0.3s ease;
    `;
    
    preloadContainer.appendChild(progressBar);
    
    // Add to loading message if it exists
    const loadingMessage = document.getElementById('loadingMessage');
    if (loadingMessage) {
        loadingMessage.appendChild(preloadContainer);
    }
    
    // Track preloading progress
    let loadedCount = 0;
    let errorCount = 0;
    const totalImages = locations.length;
    
    // Preload each image
    locations.forEach((location) => {
        if (location.image) {
            const img = new Image();
            
            img.onload = function() {
                loadedCount++;
                const progress = (loadedCount / totalImages) * 100;
                progressBar.style.width = progress + '%';
                
                console.log(`Preloaded image ${loadedCount} of ${totalImages}: ${location.image}`);
            };
            
            img.onerror = function() {
                errorCount++;
                loadedCount++;
                const progress = (loadedCount / totalImages) * 100;
                progressBar.style.width = progress + '%';
                
                console.warn(`Failed to preload image: ${location.image}`);
            };
            
            // Set crossOrigin to avoid CORS issues
            img.crossOrigin = "anonymous";
            img.src = location.image;
        }
    });
    
    // Report any errors after preloading completes
    setTimeout(() => {
        if (errorCount > 0) {
            console.warn(`${errorCount} images failed to preload`);
            // Only show error if a significant number failed
            if (errorCount > totalImages * 0.25) {
                showErrorMessage(`Some location images couldn't be loaded. You may experience missing images.`, 'warning');
            }
        }
    }, 5000);
}

// Improved inactivity system that tracks both user interaction and icon movement
function initInactivitySystem() {
    console.log("Initializing inactivity system");
    
    // Initialize tracking variables
    lastUserMovementTime = Date.now();
    lastUserInteractionTime = Date.now();
    
    // Set up the inactivity check interval
    if (window.inactivityInterval) {
        clearInterval(window.inactivityInterval);
    }
    
    // Check for inactivity every 5 seconds
    window.inactivityInterval = setInterval(checkInactivity, 5000);
    
    // Add event listeners for user interactions
    const interactionEvents = [
        'mousedown', 'mousemove', 'mouseup', 
        'touchstart', 'touchmove', 'touchend',
        'keydown', 'scroll', 'click', 'wheel'
    ];
    
    interactionEvents.forEach(eventType => {
        document.addEventListener(eventType, updateUserInteractionTime, { passive: true });
    });
    
    // Add specific listeners for map interactions
    const mapContainer = map.getContainer();
    interactionEvents.forEach(eventType => {
        mapContainer.addEventListener(eventType, updateUserInteractionTime, { passive: true });
    });
    
    // Add listeners for map-specific events
    const mapEvents = ['movestart', 'move', 'moveend', 'zoomstart', 'zoom', 'zoomend', 'dragstart', 'drag', 'dragend'];
    mapEvents.forEach(eventType => {
        map.on(eventType, updateUserInteractionTime);
    });
    
    console.log("Inactivity system initialized");
}

// Update the user interaction timestamp
function updateUserInteractionTime() {
    lastUserInteractionTime = Date.now();
    // Debug log every 10th reset to avoid flooding console
    if (Math.random() < 0.1) {
        console.log("User interaction detected, reset interaction timer");
    }
}

// Update the user movement timestamp when the icon moves
function updateUserMovementTime(newPosition) {
    if (!lastIconPosition) {
        lastIconPosition = newPosition;
        lastUserMovementTime = Date.now();
        return;
    }
    
    // Check if the icon has moved significantly
    const distance = calculateDistance(lastIconPosition, newPosition);
    if (distance > MICRO_MOVEMENT_THRESHOLD) {
        lastUserMovementTime = Date.now();
        lastIconPosition = newPosition;
        // Debug log every 10th movement to avoid flooding console
        if (Math.random() < 0.1) {
            console.log("Icon movement detected, reset movement timer");
        }
    }
}

// Check for inactivity (both user interaction and icon movement)
function checkInactivity() {
    const now = Date.now();
    const timeSinceInteraction = now - lastUserInteractionTime;
    const timeSinceMovement = now - lastUserMovementTime;
    
    // If there's been no user interaction AND no icon movement for the timeout period
    if (timeSinceMovement >= INACTIVITY_TIMEOUT && timeSinceInteraction >= INACTIVITY_TIMEOUT) {
        console.log(`INACTIVITY DETECTED: ${Math.floor(timeSinceMovement / 1000)}s since movement, ${Math.floor(timeSinceInteraction / 1000)}s since interaction`);
        performInactivityActions();
    }
}

// Actions to perform when inactivity is detected
function performInactivityActions() {
    console.log('EXECUTING INACTIVITY ACTIONS after ' + (INACTIVITY_TIMEOUT/1000) + ' seconds');
    
    try {
        // Set flags
        isMapInteracting = false;
        followUser = true;
        
        // Close any open popups
        map.closePopup();
        
        // Also close popups attached to markers
        map.eachLayer((layer) => {
            if (layer.getPopup && layer.getPopup()?.isOpen()) {
                layer.closePopup();
            }
        });
        
        // Recenter map on inactivity
        if (userMarker && userMarker.getLatLng()) {
            console.log("RECENTERING MAP due to inactivity");
            
            // Force a more aggressive recenter with animation
            const userPos = userMarker.getLatLng();
            map.setView(userPos, 18, {
                animate: true,
                duration: 0.75,
                noMoveStart: true
            });
            
            // Log success
            console.log("Recenter complete to:", userPos);
        } else {
            console.warn("Could not recenter - user marker not available");
        }
    } catch (error) {
        console.error("Error in performInactivityActions:", error);
    }
    
    // Reset the timers after performing actions
    lastUserInteractionTime = Date.now();
    lastUserMovementTime = Date.now();
}

// Legacy function for backward compatibility
function resetInactivityTimer() {
    updateUserInteractionTime();
}

function startPositionUpdates() {
    navigator.geolocation.watchPosition(
        handlePositionUpdate,
        handleLocationError,
        {
            enableHighAccuracy: true,
            maximumAge: 1000,
            timeout: 10000
        }
    );
}

function handlePositionUpdate(position) {
    // Clear any existing timeout to reset the debounce timer
    if (debounceTimeout) {
        clearTimeout(debounceTimeout);
    }

    // Calculate dynamic delay based on speed (in m/s)
    const speed = position.coords.speed || 0; // Default to 0 if speed is not available
    const delay = calculateDynamicDelay(speed); // Get the delay based on speed

    // Set a new timeout with dynamic delay
    debounceTimeout = setTimeout(() => {
        updateUserLocation(position);
    }, delay);
}

// Helper function to calculate dynamic delay based on speed
function calculateDynamicDelay(speed) {
    // Define speed thresholds and corresponding delays
    if (speed > 10) { // Very fast movement (e.g., driving)
        return 200; // Short delay for real-time updates
    } else if (speed > 5) { // Moderate movement (e.g., cycling)
        return 300; // Slightly longer delay
    } else if (speed > 1) { // Slow movement (e.g., walking)
        return 500; // Moderate delay
    } else { // Stationary or very slow movement
        return 1000; // Long delay to optimize performance
    }
}

function handleVisibilityChange() {
    if (document.hidden) {
        lastHiddenTime = Date.now();
        lastKnownPosition = userMarker ? userMarker.getLatLng() : null;
        
        // Save current location state before going to background
        saveLocationState();
        
        // Stop animation loop when page is hidden
        if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
        }
    } else {
        const hiddenDuration = Date.now() - lastHiddenTime;
        
        // Restore location state first
        restoreLocationState();
        
        if (hiddenDuration > BACKGROUND_THRESHOLD) {
            updateLocationAfterBackground();
        } else {
            map.invalidateSize();
            
            // Restart animation loop when page becomes visible again
            if (!animationFrameId) {
                startAnimationLoop();
            }
        }
    }
    resetInactivityTimer();
}

// New function to save location state when app goes to background
function saveLocationState() {
    // Only save if a location is currently visible
    if (isLocationHuntVisible) {
        const lochuntContainer = document.querySelector('.lochunt-container');
        const additionalInfoContainer = document.querySelector('.additional-info-container');
        const audio = document.getElementById('locationAudio');
        
        // Save the current location data
        activeLocationData = {
            locationId: lastVisitedLocationId,
            isVisible: isLocationHuntVisible,
            isAdditionalInfoShown: additionalInfoContainer.style.display === 'block',
            audioPosition: audio ? audio.currentTime : 0,
            isAudioPlaying: audio ? !audio.paused : false
        };
        
        console.log("Saved location state:", activeLocationData);
        
        // Store in sessionStorage for persistence
        try {
            sessionStorage.setItem('activeLocationData', JSON.stringify(activeLocationData));
        } catch (e) {
            console.error("Failed to save to sessionStorage:", e);
        }
    }
}

// New function to restore location state when app returns from background
function restoreLocationState() {
    // Try to get from sessionStorage first
    try {
        const storedData = sessionStorage.getItem('activeLocationData');
        if (storedData) {
            activeLocationData = JSON.parse(storedData);
            console.log("Restored location state from storage:", activeLocationData);
        }
    } catch (e) {
        console.error("Failed to restore from sessionStorage:", e);
    }
    
    // If we have active location data, restore it
    if (activeLocationData && activeLocationData.isVisible) {
        console.log("Restoring location state:", activeLocationData);
        
        // Find the location data
        const location = gameLocations.find(loc => loc.id === activeLocationData.locationId);
        if (location) {
            // Show the location hunt UI
            showLocationHunt(location);
            
            // Restore audio position
            const audio = document.getElementById('locationAudio');
            if (audio) {
                audio.currentTime = activeLocationData.audioPosition || 0;
                
                // Update play/pause button
                const playPauseBtn = document.getElementById('playPauseBtn');
                if (playPauseBtn) {
                    playPauseBtn.innerHTML = activeLocationData.isAudioPlaying ? 
                        '<i class="bi bi-pause"></i>' : 
                        '<i class="bi bi-play"></i>';
                }
                
                // Resume playing if it was playing
                if (activeLocationData.isAudioPlaying) {
                    audio.play().catch(e => {
                        console.error("Failed to resume audio:", e);
                        showErrorMessage("Couldn't resume audio playback", "warning");
                    });
                }
                
                // Update progress bar
                updateProgress();
            }
            
            // Show additional info if it was shown
            if (activeLocationData.isAdditionalInfoShown) {
                const additionalInfoContainer = document.querySelector('.additional-info-container');
                if (additionalInfoContainer) {
                    additionalInfoContainer.style.display = 'block';
                    document.getElementById('additionalInfo').textContent = location.additionalInfo;
                }
            }
        }
    }
}

function updateLocationAfterBackground() {
    if ("geolocation" in navigator) {
        navigator.geolocation.getCurrentPosition(
            (position) => {
                console.log("Background update raw position:", JSON.stringify(position));
                if (!position || !position.coords) {
                    console.warn("Invalid position object in background update");
                    return;
                }
                const { latitude, longitude, accuracy } = position.coords;
                if (isNaN(latitude) || isNaN(longitude)) {
                    console.warn("Invalid coordinates in background update:", { latitude, longitude });
                    return;
                }
                const newPosition = { lat: latitude, lng: longitude };
                
                console.log("Valid background position update:", newPosition);
                try {
                    updateUserLocation(position, true);
                } catch (error) {
                    console.error("Error in updateUserLocation during background update:", error);
                    showErrorMessage("Error updating location after background", "warning", () => {
                        updateLocationAfterBackground();
                    });
                }
                lastPosition = null;
                positionBuffer = [];
                filteredPosition = null;
                velocity = { lat: 0, lng: 0 };
                acceleration = { lat: 0, lng: 0 };
                
                updateDistanceBox();
                followUser = true;
                map.invalidateSize();
                
                // Restart animation loop
                if (!animationFrameId) {
                    startAnimationLoop();
                }
            },
            (error) => {
                console.error("Error getting location after background:", error);
                showErrorMessage("Couldn't update your location after returning to the app", "warning", () => {
                    updateLocationAfterBackground();
                });
                
                if (error.code === 3) { // If timeout, retry with lower accuracy
                    navigator.geolocation.getCurrentPosition(
                        position => {
                            console.log("Retry successful with lower accuracy");
                            updateUserLocation(position, true);
                            
                            // Restart animation loop
                            if (!animationFrameId) {
                                startAnimationLoop();
                            }
                        },
                        error => {
                            console.error("Error on retry:", error);
                            showErrorMessage("Location services unavailable", "error", showFallbackContent);
                        },
                        {
                            enableHighAccuracy: false,
                            timeout: 20000,
                            maximumAge: 30000
                        }
                    );
                }
            },
            {
                enableHighAccuracy: true,
                timeout: 10000,
                maximumAge: 0
            }
        );
    } else {
        console.warn("Geolocation is not available");
        showErrorMessage("Location services unavailable", "error", showFallbackContent);
    }
}

// Animation loop using requestAnimationFrame for smooth rendering
function startAnimationLoop() {
    if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
    }
    
    lastAnimationTimestamp = performance.now();
    lastPhysicsUpdateTime = lastAnimationTimestamp;
    
    function animate(timestamp) {
        const deltaTime = timestamp - lastAnimationTimestamp;
        lastAnimationTimestamp = timestamp;
        
        // Update physics at a fixed rate, independent of frame rate
        const physicsElapsed = timestamp - lastPhysicsUpdateTime;
        if (physicsElapsed >= 1000 / PHYSICS_UPDATE_RATE) {
            updatePhysics(physicsElapsed / 1000);
            lastPhysicsUpdateTime = timestamp;
        }
        
        // Render at animation frame rate
        renderFrame(deltaTime / 1000);
        
        // Continue animation loop
        animationFrameId = requestAnimationFrame(animate);
    }
    
    animationFrameId = requestAnimationFrame(animate);
}

// Physics update function (position prediction, velocity, acceleration)
function updatePhysics(deltaTime) {
    if (!lastPosition || !userMarker) return;
    
    // Skip physics updates when stationary or during extended distance stabilization
    if (isStationary || isExtendedDistanceJump) return;
    
    // Calculate current velocity based on position changes
    if (targetPosition) {
        const currentPos = userMarker.getLatLng();
        
        // Calculate new velocity with acceleration
        velocity = {
            lat: velocity.lat * VELOCITY_DECAY + acceleration.lat * deltaTime,
            lng: velocity.lng * VELOCITY_DECAY + acceleration.lng * deltaTime
        };
        
        // Apply velocity limits
        const maxVelocity = 0.0001; // Maximum velocity per physics update
        velocity.lat = Math.max(-maxVelocity, Math.min(maxVelocity, velocity.lat));
        velocity.lng = Math.max(-maxVelocity, Math.min(maxVelocity, velocity.lng));
        
        // Update acceleration based on target position
        const targetDiff = {
            lat: targetPosition.lat - currentPos.lat,
            lng: targetPosition.lng - currentPos.lng
        };
        
        // Adaptive acceleration based on distance to target
        const distToTarget = Math.sqrt(targetDiff.lat * targetDiff.lat + targetDiff.lng * targetDiff.lng);
        const accelerationFactor = Math.min(1, distToTarget / 0.0001) * 0.00001;
        
        acceleration = {
            lat: targetDiff.lat * accelerationFactor,
            lng: targetDiff.lng * accelerationFactor
        };
        
        // Decay acceleration
        acceleration.lat *= ACCELERATION_DECAY;
        acceleration.lng *= ACCELERATION_DECAY;
    }
}

// Render function for smooth marker movement
function renderFrame(deltaTime) {
    if (!lastPosition || !userMarker || !targetPosition) return;
    
    // Skip rendering when completely stationary
    if (isStationary) {
        // When stationary, just set the position directly without animation
        userMarker.setLatLng([targetPosition.lat, targetPosition.lng]);
        return;
    }
    
    // During extended distance stabilization, just use the target position directly
    if (isExtendedDistanceJump) {
        userMarker.setLatLng([targetPosition.lat, targetPosition.lng]);
        return;
    }
    
    // Get current marker position
    const currentPos = userMarker.getLatLng();
    
    // Calculate distance to target
    const distToTarget = calculateDistance(
        { lat: currentPos.lat, lng: currentPos.lng },
        { lat: targetPosition.lat, lng: targetPosition.lng }
    );
    
    // If very close to target, snap to it
    if (distToTarget < 0.1) {
        userMarker.setLatLng([targetPosition.lat, targetPosition.lng]);
        return;
    }
    
    // Calculate interpolation factor based on distance
    const lerpFactor = Math.min(1, deltaTime * 5);
    
    // Apply direct interpolation without velocity    
    const newPos = {
        lat: currentPos.lat + (targetPosition.lat - currentPos.lat) * lerpFactor,
        lng: currentPos.lng + (targetPosition.lng - currentPos.lng) * lerpFactor
    };
    
    // Update marker position
    userMarker.setLatLng([newPos.lat, newPos.lng]);
    
    // Auto-recenter map if following user
    if (followUser && !isMapInteracting) {
        const edgeInfo = isMarkerNearEdge(map, userMarker);
        if (edgeInfo.isNearEdge) {
            const optimalCenter = calculateOptimalCenter(map, newPos, edgeInfo);
            map.panTo(optimalCenter, { animate: true, duration: 0.5, noMoveStart: true });
        }
    }
}

// Enhanced recenter function with zoom adjustment based on movement speed
function recenterMap() {
    const recenterButton = document.getElementById('recenterButton');
    recenterButton.style.backgroundColor = '#005f9e';
    recenterButton.style.color = 'white';
    
    const now = Date.now();
    if (now - lastRecenterTime < MIN_RECENTER_INTERVAL) {
        return;
    }
    lastRecenterTime = now;
    
    if (userMarker && userMarker.getLatLng()) {
        map.closePopup();
        
        // Get current position and speed
        const currentPos = userMarker.getLatLng();
        const currentSpeed = lastPosition?.speedMPS || 0;
        
        // Determine appropriate zoom level based on speed
        let zoomLevel = RECENTER_ZOOM_LEVELS.STATIONARY;
        
        if (currentSpeed > 20) {
            zoomLevel = RECENTER_ZOOM_LEVELS.DRIVING_FAST;
        } else if (currentSpeed > 10) {
            zoomLevel = RECENTER_ZOOM_LEVELS.DRIVING_SLOW;
        } else if (currentSpeed > 5) {
            zoomLevel = RECENTER_ZOOM_LEVELS.CYCLING;
        } else if (currentSpeed > 1) {
            zoomLevel = RECENTER_ZOOM_LEVELS.WALKING;
        }
        
        // Animate to new view with appropriate zoom
        map.setView(currentPos, zoomLevel, {
            animate: true,
            duration: 0.5
        });
        
        followUser = true;
    }
    
    setTimeout(() => {
        recenterButton.style.backgroundColor = 'white';
        recenterButton.style.color = '#005f9e';
    }, 500);
    
    // Reset inactivity timers
    updateUserInteractionTime();
}

function calculateEdgeProximity(map, point) {
    const bounds = map.getBounds();
    const latSpan = bounds.getNorth() - bounds.getSouth();
    const lngSpan = bounds.getEast() - bounds.getWest();
    
    return {
        north: Math.abs(point.lat - bounds.getNorth()) / latSpan,
        south: Math.abs(point.lat - bounds.getSouth()) / latSpan,
        east: Math.abs(point.lng - bounds.getEast()) / lngSpan,
        west: Math.abs(point.lng - bounds.getWest()) / lngSpan
    };
}

function isMarkerNearEdge(map, marker, isStrict = false) {
    const bounds = map.getBounds();
    const point = marker.getLatLng();
    const proximities = calculateEdgeProximity(map, point);
    
    const thresholdPercentage = isStrict ? 
        STRICT_EDGE_THRESHOLD_PERCENTAGE : 
        EDGE_THRESHOLD_PERCENTAGE;
    
    const edges = {
        north: proximities.north < thresholdPercentage,
        south: proximities.south < thresholdPercentage,
        east: proximities.east < thresholdPercentage,
        west: proximities.west < thresholdPercentage
    };
    
    return {
        isNearEdge: Object.values(edges).some(edge => edge),
        edges: edges,
        proximities: proximities
    };
}

function calculateOptimalCenter(map, markerPosition, edgeInfo) {
    const bounds = map.getBounds();
    
    let latOffset = 0;
    let lngOffset = 0;
    
    if (edgeInfo.edges.north) latOffset = -1 * (bounds.getNorth() - bounds.getSouth()) * 0.2;
    if (edgeInfo.edges.south) latOffset = (bounds.getNorth() - bounds.getSouth()) * 0.2;
    if (edgeInfo.edges.east) lngOffset = -1 * (bounds.getEast() - bounds.getWest()) * 0.2;
    if (edgeInfo.edges.west) lngOffset = (bounds.getEast() - bounds.getWest()) * 0.2;
    
    return {
        lat: markerPosition.lat + latOffset,
        lng: markerPosition.lng + lngOffset
    };
}

// Improved position validation
function isValidPosition(pos) {
    return pos && 
           typeof pos.lat === 'number' && !isNaN(pos.lat) &&
           typeof pos.lng === 'number' && !isNaN(pos.lng) &&
           Math.abs(pos.lat) <= 90 && Math.abs(pos.lng) <= 180;
}

// Enhanced position buffer management with accuracy weighting
function updatePositionBuffer(position) {
    // Validate position before adding to buffer
    if (!isValidPosition(position)) {
        console.warn("Invalid position rejected from buffer:", position);
        return;
    }
    
    // Add new position to buffer with timestamp
    positionBuffer.push({
        lat: position.lat,
        lng: position.lng,
        accuracy: position.accuracy || 20,
        heading: position.heading,
        speedMPS: position.speedMPS || 0,
        timestamp: position.timestamp || Date.now()
    });

    // Use different buffer sizes based on movement state
    const maxSize = isStationary ? MAX_BUFFER_SIZE_STATIONARY : MAX_BUFFER_SIZE;
    
    // Remove old positions if buffer exceeds maxSize
    while (positionBuffer.length > maxSize) {
        positionBuffer.shift();
    }
}

// Dynamic smoothing based on accuracy and movement
function calculateDynamicSmoothingFactor(newPosition, lastPosition) {
    if (!newPosition || !lastPosition) return 0.5;
    
    // Base smoothing on accuracy
    const accuracyFactor = Math.min(1, Math.max(0, 1 - (newPosition.accuracy / MAX_ACCEPTABLE_ACCURACY)));
    
    // Calculate movement speed
    const distance = calculateDistance(newPosition, lastPosition);
    const timeDelta = (newPosition.timestamp - lastPosition.timestamp) / 1000;
    const speed = timeDelta > 0 ? distance / timeDelta : 0;
    
    // Adjust smoothing based on speed (more smoothing at higher speeds)
    const speedFactor = Math.min(1, speed / 10);
    
    // Calculate final smoothing factor
    let smoothingFactor = ADAPTIVE_SMOOTHING_MIN + 
                          (ADAPTIVE_SMOOTHING_MAX - ADAPTIVE_SMOOTHING_MIN) * 
                          (accuracyFactor * 0.7 + speedFactor * 0.3);
    
    // Ensure smoothing factor is within bounds
    return Math.max(ADAPTIVE_SMOOTHING_MIN, Math.min(ADAPTIVE_SMOOTHING_MAX, smoothingFactor));
}

// Modify the applyExponentialSmoothing function to be more stable during initialization
function applyExponentialSmoothing(newPosition, lastPosition) {
    // Validate inputs
    if (!newPosition || !lastPosition || 
        typeof newPosition.lat !== 'number' || typeof newPosition.lng !== 'number' || 
        typeof lastPosition.lat !== 'number' || typeof lastPosition.lng !== 'number') {
        console.warn("Invalid input to applyExponentialSmoothing");
        return newPosition;
    }

    // Initialize lastSmoothedPosition if it doesn't exist
    if (!lastSmoothedPosition) {
        lastSmoothedPosition = lastPosition;
    }

    const distance = calculateDistance(newPosition, lastSmoothedPosition);
    
    // Enhanced stationary detection
    if (distance < MICRO_MOVEMENT_THRESHOLD) {
        stationaryCount = Math.min(stationaryCount + 1, 5);
    } else {
        stationaryCount = Math.max(stationaryCount - 1, 0);
    }

    // Calculate adaptive alpha based on multiple factors
    let alpha = calculateDynamicSmoothingFactor(newPosition, lastPosition);
    
    // Use much lower alpha during initialization for extra stability
    if (isInitializing) {
        alpha = INITIAL_SMOOTHING_FACTOR;
    }

    // Apply smoothing with weighted factors
    const smoothedPosition = {
        lat: lastSmoothedPosition.lat + alpha * (newPosition.lat - lastSmoothedPosition.lat),
        lng: lastSmoothedPosition.lng + alpha * (newPosition.lng - lastSmoothedPosition.lng),
        accuracy: Math.min(newPosition.accuracy, lastSmoothedPosition.accuracy),
        heading: newPosition.heading,
        timestamp: newPosition.timestamp,
        speedMPS: newPosition.speedMPS ? 
                  lastSmoothedPosition.speedMPS * 0.7 + newPosition.speedMPS * 0.3 : // Smooth speed changes
                  newPosition.speedMPS
    };

    // Apply additional smoothing to heading when stationary
    if (stationaryCount >= 3 && lastSmoothedPosition.heading !== undefined && newPosition.heading !== undefined) {
        smoothedPosition.heading = alpha * newPosition.heading + (1 - alpha) * lastSmoothedPosition.heading;
    }

    // Additional stabilization for very small movements
    if (distance < MICRO_MOVEMENT_THRESHOLD * 0.5) {
        smoothedPosition.lat = lastSmoothedPosition.lat * 0.95 + smoothedPosition.lat * 0.05;
        smoothedPosition.lng = lastSmoothedPosition.lng * 0.95 + smoothedPosition.lng * 0.05;
    }

    // Update last smoothed position
    lastSmoothedPosition = smoothedPosition;

    return smoothedPosition;
}

// Enhanced stationary state detection
function checkStationaryState(newPosition) {
    if (!lastPosition) return false;
    
    const distance = calculateDistance(lastPosition, newPosition);
    
    // Use a more aggressive threshold during initialization
    const adaptiveThreshold = isInitializing ? 
        STATIONARY_MOVEMENT_THRESHOLD * 3 : // Triple the threshold during initialization
        STATIONARY_MOVEMENT_THRESHOLD * (1 + Math.min(1, newPosition.accuracy / 20));
    
    // Check for significant movement
    if (distance >= adaptiveThreshold * 2 || newPosition.speedMPS > 0.8) {
        // Quickly transition out of stationary state if significant movement
        stationaryCount = Math.max(0, stationaryCount - MOTION_TRANSITION_COUNT);
        if (stationaryCount === 0) {
            isStationary = false;
            stationaryStartTime = null;
            stationaryBuffer = [];
            console.log("Exiting stationary state due to significant movement");
            return false;
        }
    } else if (distance < adaptiveThreshold) {
        // Gradually increase stationary count
        stationaryCount = Math.min(STATIONARY_TRANSITION_COUNT, stationaryCount + 1);
        
        // If we've been stationary for a while, enter stationary state
        if (stationaryCount >= STATIONARY_TRANSITION_COUNT && !isStationary) {
            isStationary = true;
            stationaryStartTime = newPosition.timestamp;
            console.log("Entering stationary state");
            return true;
        }
    }
    
    // If we're already stationary, maintain that state
    if (isStationary) {
        // Check if we should update the stationary position
        const now = newPosition.timestamp;
        const stationaryDuration = now - stationaryStartTime;
        
        // After a certain time, only update if accuracy improves significantly
        if (stationaryDuration > STATIONARY_POSITION_FREEZE_TIME) {
            // Only update if new position has significantly better accuracy
            if (newPosition.accuracy < lastPosition.accuracy * 0.7) {
                console.log("Updating stationary position due to improved accuracy");
                return true;
            }
            return false; // Don't update position
        }
        
        return true;
    }
    
    return false;
}

// Improved sensor fusion for more accurate location tracking
function applySensorFusion(position) {
    // Skip sensor fusion if we don't have sensor data
    if (!hasSensorPermission || !position) {
        return position;
    }
    
    // Only apply sensor fusion when we have recent sensor data
    const now = Date.now();
    const gyroAge = now - (gyroscopeData.timestamp || 0);
    const accelAge = now - (accelerometerData.timestamp || 0);
    
    if (gyroAge > 1000 || accelAge > 1000) {
        return position;
    }
    
    // Calculate movement magnitude from accelerometer
    const accelMagnitude = Math.sqrt(
        accelerometerData.x * accelerometerData.x + 
        accelerometerData.y * accelerometerData.y + 
        accelerometerData.z * accelerometerData.z
    );
    
    // Determine if device is in motion based on accelerometer
    const isInMotion = accelMagnitude > 10.5; // Threshold slightly above gravity
    
    // If device is stationary according to accelerometer but GPS shows movement,
    // reduce confidence in the GPS reading
    if (!isInMotion && position.speedMPS > 0.5) {
        position.accuracy = position.accuracy * 1.5; // Reduce confidence
    }
    
    // If we have a previous position, use gyroscope to improve heading
    if (lastPosition && position.heading !== undefined && gyroscopeData.alpha !== undefined) {
        // Use gyroscope data to smooth heading changes
        const headingDiff = Math.abs(position.heading - lastPosition.heading);
        
        // If heading change is large but gyroscope shows little rotation,
        // blend the headings to avoid jumps
        if (headingDiff > 30 && Math.abs(gyroscopeData.alpha) < 15) {
            position.heading = lastPosition.heading * 0.7 + position.heading * 0.3;
        }
    }
    
    return position;
}

// Main position update function with enhanced filtering and prediction
function updateUserLocation(position, forceUpdate = false) {
    // Validate input position
    if (!position?.coords?.latitude || !position?.coords?.longitude) {
        console.warn("Invalid position data received");
        return;
    }

    const currentTime = Date.now();
    const timeDelta = lastUpdateTime ? (currentTime - lastUpdateTime) / 1000 : 0;

    const newPosition = {
        lat: position.coords.latitude,
        lng: position.coords.longitude,
        accuracy: position.coords.accuracy || 20,
        heading: position.coords.heading !== null ? position.coords.heading : undefined,
        timestamp: currentTime,
        speedMPS: position.coords.speed !== null ? position.coords.speed : 0
    };
    
    // Apply sensor fusion to improve position accuracy
    const fusedPosition = applySensorFusion(newPosition);

    // First position initialization
    if (!lastPosition) {
        lastPosition = fusedPosition;
        userMarker.setLatLng([fusedPosition.lat, fusedPosition.lng]);
        kalmanFilter.reset(fusedPosition);
        lastUpdateTime = currentTime;
        stationaryStartTime = currentTime;
        positionBuffer = [fusedPosition];
        targetPosition = fusedPosition;
        lastIconPosition = fusedPosition;
        lastUserMovementTime = currentTime;
        
        map.setView([fusedPosition.lat, fusedPosition.lng], 18, { animate: false });
        updateDistanceBox();
        return;
    }

    // Calculate distance between positions
    const distance = calculateDistance(lastPosition, fusedPosition);

    // Handle large position jumps or forced updates (preserve extended distance handling)
    if (distance > EXTENDED_DISTANCE_THRESHOLD || forceUpdate) {
        console.log("Extended distance detected:", distance, "meters or forced update");
        
        // Set extended distance jump flag
        isExtendedDistanceJump = true;
        
        // Reset all tracking variables
        isStationary = false;
        stationaryStartTime = null;
        stationaryBuffer = [];
        stationaryCount = 0;
        
        // Reset Kalman filter
        kalmanFilter.reset(fusedPosition);
        
        // Update marker position immediately
        userMarker.setLatLng([fusedPosition.lat, fusedPosition.lng]);
        
        // Reset motion variables
        lastPosition = fusedPosition;
        positionBuffer = [fusedPosition];
        velocity = { lat: 0, lng: 0 };
        acceleration = { lat: 0, lng: 0 };
        targetPosition = fusedPosition;
        
        // Update map view
        if (followUser) {
            map.setView([fusedPosition.lat, fusedPosition.lng], map.getZoom(), { animate: false });
        }
        
        lastUpdateTime = currentTime;
        updateDistanceBox();
        
        // Update movement tracking
        lastIconPosition = fusedPosition;
        lastUserMovementTime = currentTime;
        
        // Clear any existing stabilization timer
        if (extendedDistanceStabilizationTimer) {
            clearTimeout(extendedDistanceStabilizationTimer);
        }
        
        // Set a timer to exit extended distance jump mode
        extendedDistanceStabilizationTimer = setTimeout(() => {
            console.log("Extended distance stabilization complete");
            isExtendedDistanceJump = false;
            extendedDistanceStabilizationTimer = null;
        }, EXTENDED_DISTANCE_STABILIZATION_PERIOD);
        
        return;
    }

    // Skip updates with poor accuracy unless forced
    if (!forceUpdate && fusedPosition.accuracy > MAX_ACCEPTABLE_ACCURACY) {
        console.log("Skipping low accuracy update:", fusedPosition.accuracy);
        return;
    }

    // Skip updates during extended distance stabilization period
    if (isExtendedDistanceJump) {
        console.log("Skipping update during extended distance stabilization");
        return;
    }

    try {
        // Check if device is stationary
        const isNowStationary = checkStationaryState(fusedPosition);
        
        // Apply different processing based on movement state
        if (isNowStationary) {
            // Enhanced stationary position handling
            const stationaryPosition = calculateStationaryPosition(fusedPosition);
            
            // Apply minimal Kalman filtering for stationary positions
            const filteredPosition = kalmanFilter.update(stationaryPosition, stationaryPosition.accuracy);
            
            // Set as target position with minimal animation
            targetPosition = filteredPosition;
            
            // For extremely stable stationary positions, only update marker occasionally
            const stationaryDuration = currentTime - stationaryStartTime;
            if (stationaryDuration > STATIONARY_POSITION_FREEZE_TIME) {
                // After freeze time, only update if accuracy improves significantly
                if (fusedPosition.accuracy < lastPosition.accuracy * 0.7) {
                    userMarker.setLatLng([filteredPosition.lat, filteredPosition.lng]);
                    console.log("Updating stationary marker due to improved accuracy");
                }
                // Otherwise don't update the marker position at all
            } else {
                // During initial stationary period, use minimal animation
                userMarker.setLatLng([filteredPosition.lat, filteredPosition.lng], { animate: true, duration: 0.5 });
            }
            
            // Update last position
            lastPosition = filteredPosition;
        } else {
            // Dynamic Kalman filter parameters for moving state
            kalmanFilter.q = 0.01; // Standard process noise when moving
            
            // Apply Kalman filter with accuracy-based measurement noise
            const filteredPosition = kalmanFilter.update(fusedPosition, fusedPosition.accuracy);
            
            // Update position buffer with filtered position
            updatePositionBuffer(filteredPosition);
            
            // Apply exponential smoothing for additional stability
            const smoothedPosition = applyExponentialSmoothing(filteredPosition, lastPosition);
            
            // Calculate acceleration for prediction
            if (timeDelta > 0) {
                const currentVelocity = {
                    lat: (smoothedPosition.lat - lastPosition.lat) / timeDelta,
                    lng: (smoothedPosition.lng - lastPosition.lng) / timeDelta
                };
                
                acceleration = {
                    lat: (currentVelocity.lat - (lastVelocity?.lat || 0)) / timeDelta,
                    lng: (currentVelocity.lng - (lastVelocity?.lng || 0)) / timeDelta
                };
                
                lastVelocity = currentVelocity;
            }
            
            // Set as target position for animation
            targetPosition = smoothedPosition;
            
            // Update last position
            lastPosition = smoothedPosition;
            
            // Check if the icon has moved significantly and update movement time
            updateUserMovementTime(smoothedPosition);
        }
        
        // Auto-recenter map if following user and near edge
        if (followUser && !isMapInteracting) {
            const edgeInfo = isMarkerNearEdge(map, userMarker);
            if (edgeInfo.isNearEdge) {
                const optimalCenter = calculateOptimalCenter(map, targetPosition, edgeInfo);
                map.panTo(optimalCenter, { animate: true, duration: 0.5, noMoveStart: true });
            }
        }
        
        lastUpdateTime = currentTime;
        updateDistanceBox();
        
    } catch (error) {
        console.error("Error in position update:", error);
        showErrorMessage("Error updating your location", "warning", () => {
            // Retry on error
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    pos => updateUserLocation(pos, true),
                    err => console.error("Retry failed:", err),
                    { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
                );
            }
        });
        
        // Fallback to basic update in case of error
        userMarker.setLatLng([newPosition.lat, newPosition.lng]);
        lastPosition = newPosition;
        targetPosition = newPosition;
        updateDistanceBox();
        
        // Update movement tracking even on error
        lastIconPosition = newPosition;
        lastUserMovementTime = currentTime;
    }
}

// Calculate distance between two positions using Haversine formula
function calculateDistance(pos1, pos2) {
    if (!pos1 || !pos2 || typeof pos1.lat !== 'number' || typeof pos1.lng !== 'number' || 
        typeof pos2.lat !== 'number' || typeof pos2.lng !== 'number') {
        return 0;
    }
    
    // Haversine formula implementation
    const R = 6371000; // Earth's radius in meters
    const lat1 = pos1.lat * Math.PI / 180;
    const lat2 = pos2.lat * Math.PI / 180;
    const deltaLat = (pos2.lat - pos1.lat) * Math.PI / 180;
    const deltaLng = (pos2.lng - pos1.lng) * Math.PI / 180;

    const a = Math.sin(deltaLat/2) * Math.sin(deltaLat/2) +
            Math.cos(lat1) * Math.cos(lat2) *
            Math.sin(deltaLng/2) * Math.sin(deltaLng/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

    return R * c;
}

// Enhanced distance box update with better error handling
function updateDistanceBox() {
    const distanceBox = document.getElementById('distanceBox');
    
    // Initial validation
    if (!userMarker || !gameLocations || gameLocations.length === 0) {
        distanceBox.innerText = 'Initializing...';
        return;
    }
    
    // Get user coordinates
    const userLatLng = userMarker.getLatLng();
    let userLat = userLatLng.lat;
    let userLng = userLatLng.lng;
    
    // Coordinate validation
    if (!isFinite(userLat) || !isFinite(userLng)) {
        console.warn('Invalid user coordinates:', userLat, userLng);
        distanceBox.innerText = 'Initializing...';
        return;
    }
    
    // Use map center if at origin
    if (userLat === 0 && userLng === 0) {
        const center = map.getCenter();
        userLat = center.lat;
        userLng = center.lng;
    }
    
    // Find closest location
    let closestDistance = Infinity;
    let closestLocation = null;
    const userPos = { lat: userLat, lng: userLng };
    
    for (const location of gameLocations) {
        if (!location || typeof location.lat !== 'number' || typeof location.lng !== 'number') {
            console.warn('Invalid location data:', location);
            continue;
        }
        
        const locationPos = { lat: location.lat, lng: location.lng };
        const distance = calculateDistance(userPos, locationPos);
        
        if (isFinite(distance) && distance < closestDistance) {
            closestDistance = distance;
            closestLocation = location;
        }
    }
    
    // Validate final distance calculation
    if (!isFinite(closestDistance) || closestDistance === Infinity) {
        console.warn('Invalid distance calculation:', closestDistance);
        distanceBox.innerText = 'Initializing...';
        return;
    }
    
    // Calculate and display distance
    const distanceFeet = Math.round(closestDistance * 3.28084);
    const distanceText = distanceFeet < 5280 
        ? `${distanceFeet.toLocaleString()} feet` 
        : `${(distanceFeet / 5280).toFixed(2)} miles`;
    
    distanceBox.innerText = `Closest Stop: ${distanceText}`;
    
    // Check if we should show location hunt
    // Only show if not already showing a location and we're within threshold
    if (distanceFeet <= DISTANCE_THRESHOLD && !isLocationHuntVisible && closestLocation) {
        showLocationHunt(closestLocation);
    }
}

// Enhanced error handling for geolocation
function getGeolocationOptions(retryNumber) {
    return {
        enableHighAccuracy: retryNumber < 2,
        timeout: 10000 + (retryNumber * 5000),
        maximumAge: retryNumber * 5000
    };
}

//Location error logic with improved error messages and recovery options
function handleLocationError(error) {
    console.warn("Error getting user location:", error);
    
    if (retryCount < MAX_RETRIES) {
        retryCount++;
        console.log(`Retrying to get location (Attempt ${retryCount} of ${MAX_RETRIES})`);
        
        setTimeout(() => {
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    console.log("Location retrieved successfully after retry");
                    hideLoadingMessage();
                    updateUserLocation(position, true);
                    retryCount = 0;
                },
                handleLocationError,
                getGeolocationOptions(retryCount)
            );
        }, RETRY_DELAY);
        return;
    }
    
    retryCount = 0;
    hideLoadingMessage();
    
    let errorMessage = "An error occurred while getting your location.";
    let errorTitle = "Location Error";
    let retryCallback = null;
    
    if (error && error.code) {
        switch(error.code) {
            case 1:
                errorMessage = "Please allow access to your location to use this feature.";
                errorTitle = "Permission Denied";
                retryCallback = () => {
                    if (navigator.geolocation) {
                        navigator.geolocation.getCurrentPosition(
                            initializeUserLocation,
                            handleLocationError,
                            { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
                        );
                    }
                };
                break;
            case 2:
                errorMessage = "Your location is currently unavailable. Please check your device settings and try again.";
                errorTitle = "Position Unavailable";
                retryCallback = () => {
                    if (navigator.geolocation) {
                        navigator.geolocation.getCurrentPosition(
                            initializeUserLocation,
                            handleLocationError,
                            { enableHighAccuracy: false, timeout: 20000, maximumAge: 30000 }
                        );
                    }
                };
                break;
            case 3:
                errorMessage = "Getting your location took too long. Please try again or check your connection.";
                errorTitle = "Timeout";
                retryCallback = () => {
                    if (navigator.geolocation) {
                        navigator.geolocation.getCurrentPosition(
                            initializeUserLocation,
                            handleLocationError,
                            { enableHighAccuracy: false, timeout: 30000, maximumAge: 60000 }
                        );
                    }
                };
                break;
        }
    }
    
    // Show error message with retry option
    showErrorMessage(errorMessage, "error", retryCallback);
    
    // Show fallback content if we've tried multiple times
    if (retryCount >= MAX_RETRIES - 1) {
        showFallbackContent();
    }
}

function showPopup(title, message, type = 'info', callback = null) {
    const popup = document.createElement('div');
    popup.classList.add('popup');
    popup.setAttribute('role', 'dialog');
    popup.setAttribute('aria-modal', 'true');
    popup.setAttribute('aria-labelledby', 'popup-title');
    popup.setAttribute('aria-describedby', 'popup-message');
    popup.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: white;
        padding: 20px;
        border-radius: 10px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        z-index: 2000;
        text-align: center;
        max-width: 80%;
    `;

    const titleElement = document.createElement('h3');
    titleElement.id = 'popup-title';
    titleElement.textContent = title;
    titleElement.style.cssText = `
        margin-bottom: 10px;
        font-size: 18px;
        font-weight: bold;
    `;

    const messageElement = document.createElement('p');
    messageElement.id = 'popup-message';
    messageElement.textContent = message;
    messageElement.style.cssText = `
        margin-bottom: 20px;
        font-size: 16px;
    `;

    const buttonContainer = document.createElement('div');
    buttonContainer.style.cssText = `
        display: flex;
        justify-content: center;
        gap: 10px;
    `;

    const okButton = document.createElement('button');
    okButton.textContent = 'OK';
    okButton.style.cssText = `
        padding: 10px 20px;
        background-color: #005f9e;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
    `;

    okButton.addEventListener('click', () => {
        document.body.removeChild(popup);
        if (callback) callback();
    });

    buttonContainer.appendChild(okButton);

    if (type === 'info') {
        const cancelButton = document.createElement('button');
        cancelButton.textContent = 'Cancel';
        cancelButton.style.cssText = `
            padding: 10px  20px;
            background-color: #ccc;
            color: black;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        `;

        cancelButton.addEventListener('click', () => {
            document.body.removeChild(popup);
        });

        buttonContainer.appendChild(cancelButton);
    }

    popup.appendChild(titleElement);
    popup.appendChild(messageElement);
    popup.appendChild(buttonContainer);
    document.body.appendChild(popup);
}

// Add this function to calculate stationary position with better initialization handling
function calculateStationaryPosition(newPos) {
    if (!isValidPosition(newPos)) {
        return lastPosition || newPos;
    }
    
    // Add to stationary buffer
    stationaryBuffer.push(newPos);
    if (stationaryBuffer.length > MAX_BUFFER_SIZE_STATIONARY) {
        stationaryBuffer.shift();
    }

    // If buffer is too small, just return the new position
    if (stationaryBuffer.length < 3) {
        return newPos;
    }

    // Calculate weights based on accuracy and recency
    const weights = stationaryBuffer.map((pos, index) => {
        // Higher weight for more accurate readings (inverse relationship with accuracy)
        const accuracyWeight = 1 / Math.max(1, pos.accuracy);
        
        // Higher weight for more recent readings, but with diminishing returns
        // This creates more stability by not overweighting the newest readings
        const recencyWeight = Math.sqrt((index + 1) / stationaryBuffer.length);
        
        return accuracyWeight * recencyWeight;
    });

    const totalWeight = weights.reduce((sum, w) => sum + w, 0);
    
    if (totalWeight === 0) {
        return newPos;
    }

    // Calculate weighted average position
    const weightedPosition = {
        lat: stationaryBuffer.reduce((sum, pos, i) => sum + pos.lat * weights[i], 0) / totalWeight,
        lng: stationaryBuffer.reduce((sum, pos, i) => sum + pos.lng * weights[i], 0) / totalWeight,
        accuracy: Math.min(...stationaryBuffer.map(pos => pos.accuracy)),
        heading: newPos.heading,
        timestamp: newPos.timestamp,
        speedMPS: 0
    };
    
    // Apply additional stabilization for stationary positions
    if (lastPosition && isStationary) {
        // Use extremely heavy smoothing for stationary positions
        // During initialization, use even heavier smoothing
        const stationaryAlpha = isInitializing ? 0.01 : 0.05; // 99% or 95% weight to previous position
        return {
            lat: lastPosition.lat * (1 - stationaryAlpha) + weightedPosition.lat * stationaryAlpha,
            lng: lastPosition.lng * (1 - stationaryAlpha) + weightedPosition.lng * stationaryAlpha,
            accuracy: weightedPosition.accuracy,
            heading: weightedPosition.heading,
            timestamp: weightedPosition.timestamp,
            speedMPS: 0
        };
    }
    
    return weightedPosition;
}

const cooldownPeriod = 3 * 60 * 1000;

function showLocationHunt(location) {
    const now = performance.now();
    if (location.id === lastVisitedLocationId && now - lastVisitTime < cooldownPeriod) {
        console.log(`Location ${location.id} is on cooldown. Skipping.`);
        return;
    }
    
    lastVisitedLocationId = location.id;
    lastVisitTime = now;
    isLocationHuntVisible = true;

    // Save the current location data for state persistence
    activeLocationData = {
        locationId: location.id,
        isVisible: true,
        isAdditionalInfoShown: false,
        audioPosition: 0,
        isAudioPlaying: false
    };
    
    // Try to save to sessionStorage
    try {
        sessionStorage.setItem('activeLocationData', JSON.stringify(activeLocationData));
    } catch (e) {
        console.error("Failed to save to sessionStorage:", e);
    }

    const lochuntContainer = document.querySelector('.lochunt-container');
    lochuntContainer.innerHTML = '';
    lochuntContainer.style.cssText = `
        display: flex;
        flex-direction: column;
        height: 100%;
        overflow: hidden;
        background-color: #fff;
        max-width: 1200px;
        margin: 0 auto;
        box-shadow: 0 2px 20px rgba(0,0,0,0.025);
        will-change: transform;
    `;

    const scrollableContent = document.createElement('div');
    scrollableContent.style.cssText = `
        flex: 1;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
        scroll-behavior: smooth;
        will-change: scroll-position;
    `;

    const locationImage = document.createElement('img');
    locationImage.src = location.image;
    locationImage.alt = location.name;
    locationImage.style.cssText = `
        width: 100%;
        height: 45vh;
        object-fit: cover;
        object-position: center;
    `;
    // Set crossOrigin to avoid CORS issues
    locationImage.crossOrigin = "anonymous";

    scrollableContent.appendChild(locationImage);
 
    const contentContainer = document.createElement('div');
    contentContainer.classList.add('lochunt-content');
    contentContainer.style.cssText = `
        padding: 24px;
        display: flex;
        flex-direction: column;
        align-items: center;
        max-width: 800px;
        margin: 0 auto;
    `;
    const locationInfo = document.createElement('div');
    locationInfo.classList.add('lochunt-info');
    locationInfo.style.cssText = `
        text-align: center;
        width: 100%;
        margin-bottom: 15px;
    `;
    const locationName = document.createElement('h1');
    locationName.textContent = location.name;
    locationName.style.cssText = `
        font-size: clamp(1.8rem, 4vw, 2.5rem);
        font-weight: 700;
        color: #1a1a1a;
        margin-bottom: 8px;
        line-height: 1.2;
    `;
    const locationCity = document.createElement('p');
    locationCity.textContent = `${location.city}`;
    locationCity.style.cssText = `
       font-size: clamp(1.1rem, 
        2vw, 1.3rem);
        color: #2c5282;
        font-weight: 600;
        margin-bottom: 4px;
    `;
    const locationCreator = document.createElement('p');
    locationCreator.textContent = `Created by: ${location.creator}`;
    locationCreator.style.cssText = `
        font-size: calc(0.9rem + 0.4vw);
        color: #666666;
        font-weight: 500;
    `;
    locationInfo.appendChild(locationName);
    locationInfo.appendChild(locationCity);
    locationInfo.appendChild(locationCreator);
    contentContainer.appendChild(locationInfo);
    const audioPlayerContainer = createAudioPlayer(location.audio);
    contentContainer.appendChild(audioPlayerContainer);
    scrollableContent.appendChild(contentContainer);
    lochuntContainer.appendChild(scrollableContent);
    const blueBar = createBlueBar(location);
    blueBar.style.cssText += `
        position: sticky;
        bottom: 0;
        width: 100%;
    `;
    lochuntContainer.appendChild(blueBar);
    initAudioPlayer();
}

function createAudioPlayer(audioSrc) {
    const audioPlayerContainer = document.createElement('div');
    audioPlayerContainer.classList.add('audio-player');
    audioPlayerContainer.style.cssText = `
        width: 100%;
        max-width: 400px;
        margin-bottom: 15px;
    `;

    const audio = document.createElement('audio');
    audio.id = 'locationAudio';
    audio.src = audioSrc;
    audio.preload = 'metadata';

    const audioProgress = document.createElement('div');
    audioProgress.classList.add('audio-progress');
    audioProgress.style.cssText = `
        width: 100%;
        margin-bottom: 15px;
    `;

    const progressContainer = document.createElement('div');
    progressContainer.classList.add('progress');
    progressContainer.style.cssText = `
        height: 8px;
        background-color: #e2e8f0;
        border-radius: 4px;
        cursor: pointer;
        margin-bottom: 12px;
        overflow: hidden;
    `;

    const progressBar = document.createElement('div');
    progressBar.id = 'progressBar';
    progressBar.classList.add('progress-bar');
    progressBar.setAttribute('role', 'progressbar');
    progressBar.setAttribute('aria-valuenow', '0');
    progressBar.setAttribute('aria-valuemin', '0');
    progressBar.setAttribute('aria-valuemax', '100');
    progressBar.style.cssText = `
        height: 100%;
        background-color: #2c5282;
        width: 0%;
        transition: width 0.1s linear;
    `;

    progressContainer.appendChild(progressBar);
    audioProgress.appendChild(progressContainer);

    const timeInfo = document.createElement('div');
    timeInfo.classList.add('audio-time');
    timeInfo.style.cssText = `
        display: flex;
        justify-content: space-between;
        color: #4a5568;
        font-size: 0.875rem;
        margin-bottom: 16px;
        font-weight: 500;
    `;

    const currentTimeSpan = document.createElement('span');
    currentTimeSpan.id = 'currentTime';
    currentTimeSpan.textContent = '0:00';

    const durationSpan = document.createElement('span');
    durationSpan.id = 'duration';
    durationSpan.textContent = '0:00';

    timeInfo.appendChild(currentTimeSpan);
    timeInfo.appendChild(durationSpan);

    const audioControls = document.createElement('div');
    audioControls.classList.add('audio-controls');
    audioControls.style.cssText = `
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 24px;
    `;

    const rewindBtn = createAudioButton('skip-backward', 'rewindBtn');
    const playPauseBtn = createAudioButton('play', 'playPauseBtn');
    const forwardBtn = createAudioButton('skip-forward', 'forwardBtn');

    audioControls.appendChild(rewindBtn);
    audioControls.appendChild(playPauseBtn);
    audioControls.appendChild(forwardBtn);

    audioPlayerContainer.appendChild(audio);
    audioPlayerContainer.appendChild(audioProgress);
    audioPlayerContainer.appendChild(timeInfo);
    audioPlayerContainer.appendChild(audioControls);

    return audioPlayerContainer;
}

function createAudioButton(iconName, id) {
    const button = document.createElement('button');
    button.id = id;
    button.classList.add('audio-button');
    button.innerHTML = `<i class="bi bi-${iconName}"></i>`;
    button.style.cssText = `
        background-color: white;
        color: var(--primary-color);
        border: 2px solid var(--primary-color);
        border-radius: 50%;
        width: 55px;
        height: 55px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.3s ease;
    `;

    button.addEventListener('mouseover', () => {
        button.style.backgroundColor = 'var(--hover-color)';
    });

    button.addEventListener('mouseout', () => {
        button.style.backgroundColor = 'white';
    });

    button.addEventListener('click', () => {
        button.style.backgroundColor = 'var(--primary-color)';
        button.style.color = 'white';
        button.style.transform = 'scale(0.95)';
        
        setTimeout(() => {
            button.style.backgroundColor = 'white';
            button.style.color = 'var(--primary-color)';
            button.style.transform = 'scale(1)';
        }, 200);
    });

    return button;
}

function createBlueBar(location) {
    const blueBar = document.createElement('div');
    blueBar.style.cssText = `
        width: 100%;
        height: 60px;
        background: linear-gradient(to right, #2c5282, #2b6cb0);
        margin-top: auto;
        box-shadow: 0 -2px 10px rgba(0,0,0,0.025);
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0 24px;
        position: sticky;
        bottom: 0;
    `;
    
    const infoButton = document.createElement('button');
    infoButton.innerHTML = '<i class="bi bi-info-circle-fill text-white" style="font-size: 1.5rem; z-index: 2500;"></i>';
    infoButton.classList.add('btn', 'btn-sm', 'me-2');
    infoButton.setAttribute('aria-label', 'Image source information');
    infoButton.onclick = () => {
        if (location && location.imageSource) {
            showPopup('Image Source', location.imageSource);
        } else {
            showPopup('Image Source', 'Image source information is not available');
        }
    };

    const feedbackButton = document.createElement('a');
    feedbackButton.href = 'mailto:mattreicher@protonmail.com?subject=Feedback';
    feedbackButton.target = '_blank';
    feedbackButton.rel = 'noopener noreferrer';
    feedbackButton.setAttribute('aria-label', 'Send feedback email');
    feedbackButton.innerHTML = '<i class="bi bi-envelope-fill text-white" style="font-size: 1.5rem;"></i>';
    feedbackButton.classList.add('btn', 'btn-sm');

    blueBar.appendChild(infoButton);
    blueBar.appendChild(feedbackButton);
    return blueBar;
}

function initAudioPlayer() {
    const audio = document.getElementById('locationAudio');
    const playPauseBtn = document.getElementById('playPauseBtn');
    const rewindBtn = document.getElementById('rewindBtn');
    const forwardBtn = document.getElementById('forwardBtn');
    const progressBar = document.getElementById('progressBar');
    const progressContainer = document.querySelector('.progress');
    const currentTimeSpan = document.getElementById('currentTime');
    const durationSpan = document.getElementById('duration');

    playPauseBtn.addEventListener('click', togglePlay);
    rewindBtn.addEventListener('click', () => seek(-10));
    forwardBtn.addEventListener('click', () => seek(10));
    audio.addEventListener('timeupdate', updateProgress);
    audio.addEventListener('loadedmetadata', setDuration);
    audio.addEventListener('ended', () => {
        playPauseBtn.innerHTML = '<i class="bi bi-play"></i>';
        showAdditionalInfo();
    });
    
    // Add error handling for audio
    audio.addEventListener('error', (e) => {
        console.error("Audio error:", e);
        showErrorMessage("Couldn't play audio. Try again later.", "warning", () => {
            // Retry loading audio
            const src = audio.src;
            audio.src = '';
            setTimeout(() => {
                audio.src = src;
                audio.load();
            }, 1000);
        });
    });
    
    progressContainer.addEventListener('click', setProgress);

    function togglePlay() {
        if (audio.paused) {
            audio.play().catch(e => {
                console.error("Failed to play audio:", e);
                showErrorMessage("Couldn't play audio. Try again.", "warning");
            });
            playPauseBtn.innerHTML = '<i class="bi bi-pause"></i>';
            playPauseBtn.setAttribute('aria-label', 'Pause');
            
            // Update state
            if (activeLocationData) {
                activeLocationData.isAudioPlaying = true;
                try {
                    sessionStorage.setItem('activeLocationData', JSON.stringify(activeLocationData));
                } catch (e) {
                    console.error("Failed to save audio state:", e);
                }
            }
        } else {
            audio.pause();
            playPauseBtn.innerHTML = '<i class="bi bi-play"></i>';
            playPauseBtn.setAttribute('aria-label', 'Play');
            
            // Update state
            if (activeLocationData) {
                activeLocationData.isAudioPlaying = false;
                try {
                    sessionStorage.setItem('activeLocationData', JSON.stringify(activeLocationData));
                } catch (e) {
                    console.error("Failed to save audio state:", e);
                }
            }
        }
    }

    function seek(seconds) {
        audio.currentTime = Math.max(0, Math.min(audio.currentTime + seconds, audio.duration));
        
        // Update state
        if (activeLocationData) {
            activeLocationData.audioPosition = audio.currentTime;
            try {
                sessionStorage.setItem('activeLocationData', JSON.stringify(activeLocationData));
            } catch (e) {
                console.error("Failed to save audio position:", e);
            }
        }
    }

    function updateProgress() {
        const percent = (audio.currentTime / audio.duration) * 100;
        progressBar.style.width = `${percent}%`;
        progressBar.setAttribute('aria-valuenow', percent);
        currentTimeSpan.textContent = formatTime(audio.currentTime);
        
        // Update state periodically (not on every frame to avoid performance issues)
        if (activeLocationData && Math.abs(activeLocationData.audioPosition - audio.currentTime) > 1) {
            activeLocationData.audioPosition = audio.currentTime;
            try {
                sessionStorage.setItem('activeLocationData', JSON.stringify(activeLocationData));
            } catch (e) {
                // Silent fail for frequent updates
            }
        }
    }

    function setProgress(e) {
        const width = this.clientWidth;
        const clickX = e.offsetX;
        const duration = audio.duration;
        audio.currentTime = (clickX / width) * duration;
        
        // Update state
        if (activeLocationData) {
            activeLocationData.audioPosition = audio.currentTime;
            try {
                sessionStorage.setItem('activeLocationData', JSON.stringify(activeLocationData));
            } catch (e) {
                console.error("Failed to save audio position:", e);
            }
        }
    }

    function setDuration() {
        durationSpan.textContent = formatTime(audio.duration);
    }

    function formatTime(time) {
        const minutes = Math.floor(time / 60);
        const seconds = Math.floor(time % 60);
        return `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }
}

function showAdditionalInfo() {
    // Find the location using lastVisitedLocationId
    const location = gameLocations.find(loc => loc.id === lastVisitedLocationId);
    
    const additionalInfoContainer = document.querySelector('.additional-info-container');
    additionalInfoContainer.style.display = 'block';
    
    document.getElementById('additionalInfo').textContent = location.additionalInfo;

    // Update state
    if (activeLocationData) {
        activeLocationData.isAdditionalInfoShown = true;
        try {
            sessionStorage.setItem('activeLocationData', JSON.stringify(activeLocationData));
        } catch (e) {
            console.error("Failed to save additional info state:", e);
        }
    }

    const continueButton = document.getElementById('continueButton');
    continueButton.onclick = () => {
        additionalInfoContainer.style.display = 'none';
        document.querySelector('.lochunt-container').style.display = 'none';
        isLocationHuntVisible = false;
        
        // Clear active location data
        activeLocationData = null;
        try {
            sessionStorage.removeItem('activeLocationData');
        } catch (e) {
            console.error("Failed to clear location data:", e);
        }
        
        updateDistanceBox();
    };
}

function showLocationSummary(locationId) {
    const location = locations.find(loc => loc.id === locationId || loc.id === parseInt(locationId));
    if (location && location.summary) {
        const modal = document.getElementById('summaryModal');
        const summaryContent = document.getElementById('summaryContent');
        modal.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
        modal.style.display = 'flex';
        modal.style.justifyContent = 'center';
        modal.style.alignItems = 'center';
        const modalContent = modal.querySelector('.modal-content');
        modalContent.style.cssText = `
            background-color: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.025);
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        `;
        const closeBtn = modal.querySelector('.close');
        if (closeBtn) {
            closeBtn.remove();
        }
        summaryContent.style.textAlign = 'left';
        summaryContent.innerHTML = `
           <h3 style="color: #005f9e; font-size: 22px; margin-bottom: 15px; text-align: center;">${location.name}</h3>
            <p style="line-height: 1.6; margin-bottom: 15px;">
                ${location.summary}
            </p>
            <p style="line-height: 1.6; margin-bottom: 15px;">
                <strong>Location:</strong> ${location.today}
            </p>
        `;
        
        const continueButton = document.createElement('button');
        continueButton.textContent = 'Continue';
        continueButton.style.cssText = `
            display: block;
            width: auto;
            padding: 12px 20px;
            background-color: #005f9e;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            transition: background-color 0.3s ease;
            margin: 10px auto -15px;
        `;
        continueButton.onmouseover = function() {
            this.style.backgroundColor = '#0077c2';
        };
        continueButton.onmouseout = function() {
            this.style.backgroundColor = '#005f9e';
        };
        continueButton.onclick = function() {
            modal.style.display = 'none';
        };
        summaryContent.appendChild(continueButton);
        modal.style.display = 'flex';
        window.onclick = function(event) {
            if (event.target === modal) {
                modal.style.display = 'none';
            }
        };
    } else {
        showErrorMessage("Summary not available for this location.", "warning");
    }
}

function startHunt() {
    gameLocations = locations.sort((a, b) => a.id - b.id);
    currentLocationIndex = 0;
    locationCooldowns = {};
    lastVisitedLocationId = null;
    loadAllLocations();
}

function getMarkerColor(tours) {
    switch (tours.toLowerCase()) {
        case 'person':
            return '#FFA500';
        case 'gangster':
            return '#3f9b0b';
        case 'event':
            return '#8B0000';
        case 'place':
            return '#0f2bab';
        default:
            return '#0f2bab';
    }
}

const showAlert = (message) => {
   const alertEl = document.createElement('div');
   alertEl.className = 'modal';
   alertEl.setAttribute('role', 'alert');
   alertEl.innerHTML = `
       <div class="modal-content">
           <p>${message}</p>
           <button class="modal-button">OK</button>
       </div>
   `;
   document.body.appendChild(alertEl);
   alertEl.querySelector('button').onclick = () => {
       alertEl.remove();
       // Show directions modal again
       routeButton.click();
   };
};

function loadAllLocations() {
    gameLocations.forEach((location) => {
        const markerColor = getMarkerColor(location.tours);
        
        const locationMarker = L.marker([location.lat, location.lng], {
            icon: L.divIcon({
                className: 'custom-pin-icon',
                html: `<div class="pin-head" style="background-color: ${markerColor};">
                       </div>`,
                iconSize: [30, 30],
                iconAnchor: [15, 30],
            })
        });
                
        const popupContent = `
            <div class="popup-content">
                <img src="${location.image}" alt="${location.name}" class="location-image" crossorigin="anonymous">
                <h4 class="location-name">
                    <a href="${location.link}" target="_blank" rel="noopener noreferrer" style="text-decoration: none; color: inherit;">${location.name}</a>
                </h4>
                <div class="popup-buttons">
                    <button class="button route-button" data-lat="${location.lat}" data-lng="${location.lng}">Directions</button>
                    <button class="button summary-button" data-location-id="${location.id}">Summary</button>
                </div>
            </div>
        `;
        locationMarker.bindPopup(popupContent, {
            offset: L.point(0, -25),
            className: 'custom-popup'
        });
        
        locationMarker.on('popupopen', function(e) {
            // Reset inactivity timer when popup opens
            updateUserInteractionTime();
            
            const popup = e.popup._contentNode;
            const routeButton = popup.querySelector('.route-button');
            const summaryButton = popup.querySelector('.summary-button');
            
            if (routeButton) {
                routeButton.addEventListener('click', function(event) {
                    updateUserInteractionTime();
                    event.preventDefault();
                    const lat = this.getAttribute('data-lat');
                    const lng = this.getAttribute('data-lng');
                    
                    // Create and show the modal
                    const modal = document.createElement('div');
                    modal.className = 'modal';
                    modal.setAttribute('role', 'dialog');
                    modal.setAttribute('aria-modal', 'true');
                    modal.setAttribute('aria-labelledby', 'navigation-modal-title');
                    modal.innerHTML = `
                        <div class="modal-content">
                            <h3 id="navigation-modal-title">Choose your preferred navigation app:</h3>
                            <div class="modal-buttons">
                                <button class="modal-button google-maps">
                                    Google Maps
                                </button>
                                <button class="modal-button waze">
                                    Waze
                                </button>
                                <button class="modal-button apple-maps">
                                    Apple Maps
                                </button>
                                <button class="modal-button cancel">Cancel</button>
                            </div>
                        </div>
                    `;

                    document.body.appendChild(modal);

                    // Handle button clicks
                    modal.querySelector('.google-maps').addEventListener('click', () => {
                        window.location.href = `https://www.google.com/maps/dir/?api=1&destination=${lat},${lng}`;
                        modal.remove();
                    });

                    modal.querySelector('.waze').addEventListener('click', () => {
                        window.location.href = `https://www.waze.com/ul?ll=${lat}%2C${lng}&navigate=yes`;
                        modal.remove();
                    });

                    modal.querySelector('.apple-maps').addEventListener('click', () => {
                        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
                        if (isIOS) {
                            window.location.href = `maps://maps.apple.com/?daddr=${lat},${lng}`;
                            modal.remove();
                        } else {
                            showErrorMessage("Apple Maps is only available on iOS devices", "warning");
                        }
                    });
                    
                    modal.querySelector('.cancel').addEventListener('click', () => {
                        modal.remove();
                    });

                    // Close modal if clicking outside
                    modal.addEventListener('click', (e) => {
                        if (e.target === modal) {
                            modal.remove();
                        }
                    });
                });
            }
            
            if (summaryButton) {
                summaryButton.addEventListener('click', function(event) {
                    updateUserInteractionTime();
                    event.preventDefault();
                    const locationId = this.getAttribute('data-location-id');
                    showLocationSummary(locationId);
                });
            }
        });
        
        markerClusterGroup.addLayer(locationMarker);
    });
    map.addLayer(markerClusterGroup);
    updateDistanceBox();
}

function returnToIndex() {
    showPopup("Confirm", "Are you ready to exit?", 'info', () => {
        window.location.href = "/index.html";
    });
    document.getElementById('returnButton').classList.remove('active');
}

function toggleNavigationTips() {
    const tipsElement = document.querySelector('.navigation-tips');
    const computedStyle = window.getComputedStyle(tipsElement);

    if (computedStyle.display === 'none') {
        tipsElement.style.display = 'block';
    } else {
        tipsElement.style.display = 'none';
    }

    document.getElementById('tipsButton').classList.toggle('active');
    updateUserInteractionTime();
}

function closeNavigationTips() {
    document.querySelector('.navigation-tips').style.display = 'none';
    document.getElementById('tipsButton').classList.remove('active');
    updateUserInteractionTime();
}

function addUIEventListeners() {
    document.getElementById('recenterButton').addEventListener('click', () => {
        recenterMap();
        updateUserInteractionTime();
    });
    document.getElementById('returnButton').addEventListener('click', () => {
        returnToIndex();
        updateUserInteractionTime();
    });
    document.getElementById('tipsButton').addEventListener('click', () => {
        toggleNavigationTips();
        updateUserInteractionTime();
    });
    document.querySelector('.navigation-tips .close-button').addEventListener('click', () => {
        closeNavigationTips();
        updateUserInteractionTime();
    });
}

// Update the addMapEventListeners function to include touch events
function addMapEventListeners() {
    const startInteraction = () => {
        isMapInteracting = true;
        followUser = false;
        updateUserInteractionTime();
    };

    map.on('movestart zoomstart dragstart', startInteraction);
    map.on('click', updateUserInteractionTime);
    map.on('popupopen', updateUserInteractionTime);
    map.on('popupclose', updateUserInteractionTime);
    map.on('touchstart touchmove touchend', updateUserInteractionTime);
}

// Clean up resources when page is unloaded
function cleanupResources() {
    // Stop any active observers
    if (errorObserver) {
        errorObserver.disconnect();
    }
    if (domChangeObserver) {
        domChangeObserver.disconnect();
    }
    
    // Remove event listeners
    if (window.DeviceMotionEvent) {
        window.removeEventListener('devicemotion', handleMotionEvent);
    }
    if (window.DeviceOrientationEvent) {
        window.removeEventListener('deviceorientation', handleOrientationEvent);
    }
    
    // Clear intervals and timeouts
    if (window.inactivityInterval) {
        clearInterval(window.inactivityInterval);
    }
    if (stationaryCheckTimeout) {
        clearTimeout(stationaryCheckTimeout);
    }
    if (extendedDistanceStabilizationTimer) {
        clearTimeout(extendedDistanceStabilizationTimer);
    }
    if (debounceTimeout) {
        clearTimeout(debounceTimeout);
    }
    
    // Cancel animation frame
    if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
    }
}

// Initialize the application when DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
    initMap();
    addUIEventListeners();
    addMapEventListeners();
    
    // Add cleanup on page unload
    window.addEventListener('beforeunload', cleanupResources);
});
    </script>
  </body>
</html>
