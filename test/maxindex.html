<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Minnesota Then | Museum Without Walls</title>
    <link rel="shortcut icon" type="image/x-icon" href="https://www.mnthen.com/images/mnthenfav.ico">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css">
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css" />

    <link rel="stylesheet" href="https://www.mnthen.com/css/mainmap.css">
    <link rel="stylesheet" href="https://www.mnthen.com/css/mnthen_main_map2.css">
    
    <style>
        /* Enhanced touch handling styles */
        .leaflet-container {
            touch-action: none; /* Disable browser handling of all panning and zooming gestures */
        }
        
        /* Improved user marker with better visibility */
        .user-marker-icon {
            width: 20px;
            height: 20px;
            background-color: #2c5282;
            border: 3px solid white;
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            position: relative;
            transform-origin: center;
            transition: transform 0.3s ease-out;
        }
        
        /* Pulse animation for user marker */
        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.8; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        .user-marker-icon.pulse {
            animation: pulse 1.5s infinite;
        }
        
        /* Enhanced distance box with better visibility */
        #distanceBox {
            transition: background-color 0.3s, transform 0.3s;
        }
        
        #distanceBox.pulse {
            animation: pulse 1.5s;
        }
        
        /* Improved touch feedback */
        .map-button:active {
            transform: scale(0.95);
            background-color: #f0f0f0;
        }

        /* Loading message styles */
        .loading-message {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            background-image: url('https://raw.githubusercontent.com/mreicher/MNThen/refs/heads/main/images/splash_screen.webp');
            background-size: cover;
            background-position: center;
            background-color: rgba(0, 0, 0, 0.1); 
            background-blend-mode: overlay; 
            z-index: 1000;
            font-family: 'Segoe UI', 'Roboto', 'Arial', sans-serif;
            opacity: 0; 
            visibility: hidden;
            transition: opacity 0.6s ease-out, visibility: 0.6s; 
            pointer-events: none;
        }

        .loading-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: rgba(255, 255, 255, 0.98); 
            padding: clamp(25px, 5vw, 45px); 
            border-radius: 20px;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.3); 
            width: clamp(300px, 90%, 550px); 
            text-align: center;
            opacity: 0;
            transform: scale(0.95) translateY(10px);
            transition: transform 0.5s cubic-bezier(0.25, 0.8, 0.25, 1) 0.2s, opacity 0.5s ease-out 0.2s;
            pointer-events: auto;
        }

        .loading-logo {
            width: clamp(130px, 60%, 260px); 
            height: auto;
            margin-bottom: clamp(18px, 4vw, 28px); 
            border-radius: 10px; 
            object-fit: contain;
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.1)); 
        }

        .loading-title {
            margin: 0 0 clamp(10px, 2vw, 18px) 0;
            font-size: clamp(22px, 5.5vw, 28px); 
            font-weight: 600; 
            color: #002855; 
            text-align: center;
            line-height: 1.35; 
            letter-spacing: -0.02em;
            text-shadow: 0 1px 2px rgba(0, 40, 85, 0.1); 
        }

        .loading-status {
            margin: 0 0 clamp(18px, 4vw, 28px) 0; 
            font-size: clamp(15px, 4vw, 17px); 
            font-weight: 400;
            text-align: center;
            color: #0052A5; 
            line-height: 1.5;
            min-height: 1.5em; 
        }

        .progress-container {
            width: 100%;
            height: 8px; 
            background-color: rgba(0, 51, 102, 0.15); 
            border-radius: 10px; 
            overflow: hidden;
            margin-top: 8px;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1); 
        }

        .progress-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #0052A5, #007bff); 
            border-radius: 10px; 
            transition: width 0.25s cubic-bezier(0.4, 0, 0.2, 1); 
            box-shadow: 0 0 10px rgba(0, 123, 255, 0.6); 
        }

        /* Popup styles */
        .popup {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 3000;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: none;
        }

        .popup-content {
            background-color: white;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            max-width: 85%;
            width: 350px;
            text-align: center;
            position: relative;
            transform: translate(0, 0);
            margin: 0;
            pointer-events: auto;
        }

        .popup h3 {
            margin-bottom: 15px;
            font-size: 20px;
            font-weight: 600;
            color: var(--primary-color);
        }

        .popup p {
            margin-bottom: 25px;
            font-size: 16px;
            line-height: 1.5;
            color: #333;
        }

        .button-container {
            display: flex;
            justify-content: center;
            gap: 15px;
        }

        .ok-button, .cancel-button {
            padding: 10px 25px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            transition: background-color 0.2s;
        }

        .ok-button {
            background-color: var(--primary-color);
            color: white;
        }

        .cancel-button {
            background-color: #f2f2f2;
            color: #333;
        }

        .ok-button:hover {
            background-color: #004b7d;
        }

        .cancel-button:hover {
            background-color: #e0e0e0;
        }

        .fade-in {
            animation: fadeIn 0.3s ease-out forwards;
        }

        .fade-out {
            animation: fadeOut 0.3s ease-in forwards;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        @keyframes fadeOut {
            from {
                opacity: 1;
            }
            to {
                opacity: 0;
            }
        }

        /* Location hunt styles */
        .lochunt-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            overflow: hidden;
            padding-top: 20px;
            box-sizing: border-box;
        }

        .scrollable-content {
            width: 100%;
            height: calc(100% - 60px);
            overflow-y: auto;
            padding: 10px;
            box-sizing: border-box;
        }

        .location-image {
            width: 100%;
            max-height: 300px;
            object-fit: cover;
            border-radius: 12px;
            margin-bottom: 15px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .lochunt-content {
            background-color: rgba(255, 255, 255, 0.95);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            text-align: center;
            margin-bottom: 20px;
        }

        .lochunt-info {
            margin-bottom: 20px;
        }

        .location-name {
            font-size: 24px;
            font-weight: 600;
            color: #333;
            margin-bottom: 8px;
        }

        .location-city, .location-creator {
            font-size: 16px;
            color: #666;
            margin-bottom: 5px;
        }

        .audio-player {
            width: 100%;
            margin-top: 20px;
        }

        .audio-progress {
            margin-bottom: 10px;
        }

        .progress {
            width: 100%;
            height: 8px;
            background-color: #ddd;
            border-radius: 4px;
            overflow: hidden;
            cursor: pointer;
        }

        .progress-bar {
            height: 100%;
            width: 0;
            background-color: var(--primary-color);
            transition: width 0.1s ease-in-out;
        }

        .audio-time {
            display: flex;
            justify-content: space-between;
            font-size: 14px;
            color: #666;
            margin-bottom: 10px;
        }

        .audio-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
        }

        .audio-button {
            background: none;
            border: none;
            font-size: 20px;
            color: var(--primary-color);
            cursor: pointer;
            transition: color 0.2s;
        }

        .audio-button:hover {
            color: #004b7d;
        }

        .location-action-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
        }

        .source-info-button, .feedback-email-button {
            background-color: rgba(255, 255, 255, 0.1);
            border: none;
            color: white;
            border-radius: 8px;
            padding: 8px 12px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .source-info-button:hover, .feedback-email-button:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }

        /* Source info popup styles */
        .source-info-popup {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 4000;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            transition: opacity 0.3s ease-out;
            pointer-events: auto;
        }

        .source-info-content {
            background-color: white;
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
            max-width: 85%;
            width: 400px;
            text-align: center;
            transform: translateY(20px);
            transition: transform 0.3s ease-out;
        }

        .source-info-title {
            font-size: 22px;
            font-weight: 600;
            color: var(--primary-color);
            margin-bottom: 15px;
        }

        .source-info-text {
            font-size: 16px;
            color: #333;
            line-height: 1.5;
            margin-bottom: 25px;
        }

        .source-close-button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 10px 20px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.2s;
        }

        .source-close-button:hover {
            background-color: #004b7d;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"></script>
    <script src="/locations_test.js?v=1.0.4"></script>
</head>
<body>
    <!-- Map -->
    <div id="map"></div>
    <div id="distanceBox">Initializing...</div>

    <!-- Location Hunt Container -->
    <div class="lochunt-container">
        <img id="locationImage" src="/placeholder.svg" alt="Location Image">
        <div class="lochunt-content">
            <div class="lochunt-info">
                <h2 id="locationTitle" class="mb-2 text-primary"></h2>
                <p id="locationCity" class="text-muted mb-1"></p>
                <p id="locationCreator" class="text-muted mb-3"></p>
            </div>
            <div class="audio-player">
                <div class="audio-progress">
                    <div class="progress">
                        <div id="progressBar" class="progress-bar" role="progressbar" style="width: 0%"></div>
                    </div>
                </div>
                <div class="audio-time">
                    <span id="currentTime">0:00</span>
                    <span id="duration">0:00</span>
                </div>
                <div class="audio-controls">
                    <button id="rewindBtn" class="audio-button"><i class="fas fa-backward"></i></button>
                    <button id="playPauseBtn" class="audio-button"><i class="fas fa-play"></i></button>
                    <button id="forwardBtn" class="audio-button"><i class="fas fa-forward"></i></button>
                </div>
                <audio id="locationAudio" src="/placeholder.svg"></audio>
            </div>
        </div>
    </div>

    <!-- Additional Info Container -->
    <div class="additional-info-container">
        <h3 class="mb-3 text-primary text-center">Did You Know?</h3>
        <p id="additionalInfo" class="mb-3 fs-6"></p>
        <div class="d-flex justify-content-center">
            <button id="continueButton" class="btn btn-primary">Continue</button>
        </div>
    </div>
    
    <!-- Map Buttons -->
    <div class="map-buttons">
        <button id="recenterButton" class="map-button"><i class="fas fa-crosshairs"></i></button>
        <button id="returnButton" class="map-button"><i class="fas fa-sign-out-alt"></i></button>
        <button id="tipsButton" class="map-button"><i class="fas fa-question-circle"></i></button>
    </div>

    <!-- Navigation Tips -->
    <div class="navigation-tips">
        <button class="close-button">&times;</button>
        <h3 style="color: darkblue; text-align: center;">Navigation Tips</h3>
        <ul>
            <li>Use the map to navigate to the marked locations.</li>
            <li>Tap the recenter button to focus on your current position.</li>
            <li>The distance box shows how far you are from the closest location.</li>
            <li>When you're within 20 feet of a location, you'll be able to interact with it.</li>
            <li>Listen to the audio information for each location.</li>
            <li>After the audio, you'll see additional information about the location.</li>
        </ul>
    </div>

    <!-- Summary Modal -->
    <div id="summaryModal" class="modal">
        <div class="modal-content">
            <p id="summaryContent"></p>
        </div>
    </div>

    <script>
    // Global variables
    let map, userMarker, markerClusterGroup;
    let tracking;
    let currentLocationIndex = 0;
    let visitedLocations = [];
    let gameLocations = [];
    let isLocationHuntVisible = false;
    let lastPosition = null;
    let positionBuffer = [];
    let filteredPosition = null;
    let followUser = true;
    let locationCooldowns = {};
    let lastVisitedLocationId = null;
    let lastKnownPosition = null;
    let lastResetTime = Date.now();        
    let isTransitioning = false;
    let lastVelocity = { lat: 0, lng: 0 };
    let isMapInteracting = false;
    let isStationary = false;
    let stationaryStartTime = null;
    let stationaryCheckTimeout = null;
    let lastUpdateTime = null;
    let lastUpdateTimestamp = null;
    let stationaryBuffer = [];
    let stationaryPosition = null;
    let stationaryCount = 0;
    let lastSmoothedPosition = null;
    let lastHiddenTime = 0;
    let retryCount = 0;
    let inactivityTimer;
    let animationFrameId = null;
    
    // Touch interaction tracking
    let touchInteractionState = {
        isActive: false,
        startTime: null,
        lastMoveTime: null,
        initialTouches: [],
        lastTouches: [],
        initialDistance: 0,
        initialCenter: null,
        isPinching: false,
        isPanning: false,
        preventRecenter: false,
        interactionTimeout: null
    };

    // Configuration constants
    const DISTANCE_THRESHOLD = 20; // feet
    const MAX_BUFFER_SIZE = 5;
    const MAX_ACCEPTABLE_ACCURACY = 39; // meters
    const THROTTLE_TIME = 200; // ms
    const BACKGROUND_THRESHOLD = 25000; // ms
    const INACTIVITY_TIMEOUT = 29000; // ms
    const UPDATE_INTERVAL = 50; // ms
    const MICRO_MOVEMENT_THRESHOLD = 0.3; // meters
    const STATIONARY_ACCURACY_MULTIPLIER = 1.1;
    const MAX_SPEED = 50; // m/s
    const MIN_DISTANCE_THRESHOLD = 2; // meters
    const VELOCITY_DECAY = 0.8;
    const BEARING_WEIGHT = 0.3;
    const SMOOTHING_FACTOR = 0.3;
    const EXTENDED_DISTANCE_THRESHOLD = 100; // meters
    const STATIONARY_THRESHOLD = 2;
    const STATIONARY_TIME_THRESHOLD = 5000; // ms
    const STATIONARY_CHECK_INTERVAL = 2500; // ms
    const STATIONARY_SMOOTHING = 0.95;
    const STATIONARY_BUFFER_SIZE = 10;
    const STATIONARY_ACCURACY_WEIGHT = 0.7;
    const STATIONARY_THRESHOLDB = 3;
    const MAX_ALPHA = 0.2;
    const MIN_ALPHA = 0.025;
    const MAX_RETRIES = 3;
    const RETRY_DELAY = 1000; // ms
    const EDGE_THRESHOLD_PERCENTAGE = 0.25;
    const STRICT_EDGE_THRESHOLD_PERCENTAGE = 0.15;
    const CRITICAL_EDGE_THRESHOLD_PERCENTAGE = 0.07;
    const MAX_ACCURACY_THRESHOLD = 2500;
    const TARGET_ACCURACY_THRESHOLD = 100;
    const MIN_RECENTER_INTERVAL = 2000; // ms

    // Touch interaction constants
    const TOUCH_INTERACTION_COOLDOWN = 1000; // ms to wait after touch interaction before recentering
    const PINCH_THRESHOLD = 10; // Minimum pixel distance to detect a pinch
    const PAN_THRESHOLD = 10; // Minimum pixel distance to detect a pan
    const TOUCH_INTERACTION_TIMEOUT = 60000; // ms to keep interaction state active after last touch

    // Proximity zoom constants - optimized for better performance
    const PROXIMITY_THRESHOLD = 50; // 50 feet trigger
    const PROXIMITY_EXIT_THRESHOLD = 65; // 65 feet to exit (hysteresis)
    const BASE_ZOOM = 17;           // Default zoom level 
    const CLOSE_ZOOM = 18;          // Zoom when within threshold
    const ZOOM_COOLDOWN = 2000;     // 2 seconds between zoom changes (reduced from 3s)
    const PROXIMITY_CHECK_INTERVAL = 1000; // Check proximity every 1 second

    // Initialize map and core functionality
    function initMap() {
        // Create map with optimized settings
        map = L.map('map', {
            zoomControl: false,
            attributionControl: false,
            zoomSnap: 0.1,
            zoomDelta: 0.5,
            wheelDebounceTime: 100,
            tapTolerance: 15,
            bounceAtZoomLimits: false,
            preferCanvas: true, // Better performance for many markers
            renderer: L.canvas(),
            // Disable built-in touch zoom to use our custom implementation
            touchZoom: false,
            dragging: true,
            tap: true,
            keyboard: false
        }).fitWorld();

        // Add tile layer with performance optimizations
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 18,
            attribution: '© OpenStreetMap contributors',
            updateWhenIdle: true,
            updateWhenZooming: false,
            keepBuffer: 2
        }).addTo(map);

        // Initialize marker cluster group with custom styling
        markerClusterGroup = L.markerClusterGroup({
            showCoverageOnHover: false,
            zoomToBoundsOnClick: true,
            spiderfyOnMaxZoom: true,
            animate: true,
            animateAddingMarkers: true,
            chunkedLoading: true,
            chunkProgress: updateLoadingStatus,
            maxClusterRadius: function(zoom) {
                return zoom > 16 ? 40 : 80; // Adaptive clustering based on zoom
            },
            iconCreateFunction: function(cluster) {
                return L.divIcon({
                    html: '<div><span>' + cluster.getChildCount() + '</span></div>',
                    className: 'marker-cluster-custom',
                    iconSize: L.point(40, 40)
                });
            }
        });
        map.addLayer(markerClusterGroup);

        // Create user location marker
        const userIcon = L.divIcon({
            className: 'user-marker',
            html: '<div class="user-marker-icon"></div>',
            iconSize: [20, 20],
            iconAnchor: [10, 10]
        });
        userMarker = L.marker([0, 0], { icon: userIcon, zIndexOffset: 1000 }).addTo(map);
        
        showLoadingMessage();

        // Initialize geolocation with fallback
        if ("geolocation" in navigator) {
            const options = {
                enableHighAccuracy: true,
                timeout: 45000,
                maximumAge: 0
            };

            // Try to get initial position with retry
            navigator.geolocation.getCurrentPosition(
                initializeUserLocation,
                (error) => {
                    // On error, try one more time before falling back
                    navigator.geolocation.getCurrentPosition(
                        initializeUserLocation,
                        handleLocationError,
                        options
                    );
                },
                options
            );
        } else {
            showPopup("Geolocation Error", "Geolocation is not supported by your browser");
            map.setView([44.9778, -93.2650], 17); // Default to Minneapolis
            hideLoadingMessage();
        }
        
        // Set up event listeners
        document.addEventListener('visibilitychange', handleVisibilityChange);

        // Enhanced touch event handling for map
        setupTouchInteractions();
        
        // Standard map event listeners
        map.on('movestart zoomstart', () => {
            followUser = false;
            isMapInteracting = true;
        });

        map.on('moveend zoomend', () => {
            isMapInteracting = false;
            resetInactivityTimer();
        });

        map.on("zoomend", () => {
            const currentZoom = map.getZoom();
            const maxZoom = map.getMaxZoom();
            if (currentZoom > maxZoom - 1) {
                map.setZoom(maxZoom - 1);
            }
        });

        // Enable touch interactions
        map.touchZoom.enable();
        map.doubleClickZoom.enable();

        // Set up recenter button
        document.getElementById('recenterButton').addEventListener('click', () => {
            if (userMarker && userMarker.getLatLng()) {
                followUser = true;
                map.setView(userMarker.getLatLng(), 17, { animate: true });
            }
        });

        // Set up tips button
        document.getElementById('tipsButton').addEventListener('click', () => {
            document.querySelector('.navigation-tips').style.display = 'block';
        });

        // Set up close button for tips
        document.querySelector('.navigation-tips .close-button').addEventListener('click', () => {
            document.querySelector('.navigation-tips').style.display = 'none';
        });

        // Set up inactivity timer
        resetInactivityTimer();
    }

    // New function to set up enhanced touch interactions
    function setupTouchInteractions() {
        const mapContainer = map.getContainer();
        
        // Touch start handler
        mapContainer.addEventListener('touchstart', function(e) {
            // Prevent default only for multi-touch to avoid interfering with taps
            if (e.touches.length > 1) {
                e.preventDefault();
            }
            
            // Initialize touch state
            touchInteractionState.isActive = true;
            touchInteractionState.startTime = Date.now();
            touchInteractionState.lastMoveTime = Date.now();
            
            // Store initial touch points
            touchInteractionState.initialTouches = Array.from(e.touches).map(touch => ({
                identifier: touch.identifier,
                clientX: touch.clientX,
                clientY: touch.clientY
            }));
            
            touchInteractionState.lastTouches = touchInteractionState.initialTouches;
            
            // Calculate initial distance for pinch detection
            if (e.touches.length === 2) {
                touchInteractionState.initialDistance = getTouchDistance(e.touches[0], e.touches[1]);
                touchInteractionState.initialCenter = getTouchCenter(e.touches[0], e.touches[1]);
            }
            
            // Set interaction flags
            touchInteractionState.isPinching = false;
            touchInteractionState.isPanning = false;
            
            // Disable auto-recentering during touch interaction
            followUser = false;
            isMapInteracting = true;
            
            // Clear any existing timeout
            if (touchInteractionState.interactionTimeout) {
                clearTimeout(touchInteractionState.interactionTimeout);
            }
        }, { passive: false });
        
        // Touch move handler
        mapContainer.addEventListener('touchmove', function(e) {
            if (!touchInteractionState.isActive) return;
            
            // Update last move time
            touchInteractionState.lastMoveTime = Date.now();
            
            // Store current touches
            const currentTouches = Array.from(e.touches).map(touch => ({
                identifier: touch.identifier,
                clientX: touch.clientX,
                clientY: touch.clientY
            }));
            
            // Handle pinch gesture (two fingers)
            if (e.touches.length === 2) {
                const currentDistance = getTouchDistance(e.touches[0], e.touches[1]);
                const currentCenter = getTouchCenter(e.touches[0], e.touches[1]);
                
                // Detect if this is a pinch
                if (!touchInteractionState.isPinching && 
                    Math.abs(currentDistance - touchInteractionState.initialDistance) > PINCH_THRESHOLD) {
                    touchInteractionState.isPinching = true;
                    touchInteractionState.preventRecenter = true;
                }
                
                // Handle pinch-to-zoom
                if (touchInteractionState.isPinching) {
                    // Calculate zoom delta based on pinch distance change
                    const zoomDelta = Math.log2(currentDistance / touchInteractionState.initialDistance) * 0.5;
                    
                    // Get current zoom and calculate new zoom
                    const currentZoom = map.getZoom();
                    const newZoom = Math.max(1, Math.min(map.getMaxZoom(), currentZoom + zoomDelta));
                    
                    // Apply zoom centered on pinch point
                    if (Math.abs(newZoom - currentZoom) > 0.01) {
                        map.setView(
                            map.containerPointToLatLng([currentCenter.x, currentCenter.y]),
                            newZoom,
                            { animate: false }
                        );
                    }
                    
                    // Update initial values for next move
                    touchInteractionState.initialDistance = currentDistance;
                    touchInteractionState.initialCenter = currentCenter;
                }
            }
            
            // Handle pan gesture (one or two fingers)
            if (!touchInteractionState.isPanning) {
                // Check if we've moved enough to consider it a pan
                const initialTouch = touchInteractionState.initialTouches[0];
                const currentTouch = currentTouches.find(t => t.identifier === initialTouch.identifier);
                
                if (currentTouch) {
                    const dx = currentTouch.clientX - initialTouch.clientX;
                    const dy = currentTouch.clientY - initialTouch.clientY;
                    
                    if (Math.sqrt(dx*dx + dy*dy) > PAN_THRESHOLD) {
                        touchInteractionState.isPanning = true;
                        touchInteractionState.preventRecenter = true;
                    }
                }
            }
            
            // Update last touches
            touchInteractionState.lastTouches = currentTouches;
            
            // Reset inactivity timer
            resetInactivityTimer();
        }, { passive: false });
        
        // Touch end handler
        mapContainer.addEventListener('touchend', function(e) {
            // Keep track of remaining touches
            if (e.touches.length === 0) {
                // All touches ended
                const interactionDuration = Date.now() - touchInteractionState.startTime;
                
                // Set a timeout before allowing recentering
                touchInteractionState.interactionTimeout = setTimeout(() => {
                    touchInteractionState.isActive = false;
                    touchInteractionState.preventRecenter = false;
                    isMapInteracting = false;
                    
                    // Only re-enable followUser if it's been long enough since the interaction
                    if (Date.now() - touchInteractionState.lastMoveTime > TOUCH_INTERACTION_COOLDOWN) {
                        // Don't automatically recenter, just allow it for future updates
                        followUser = true;
                    }
                }, TOUCH_INTERACTION_COOLDOWN);
            } else {
                // Update remaining touches
                touchInteractionState.lastTouches = Array.from(e.touches).map(touch => ({
                    identifier: touch.identifier,
                    clientX: touch.clientX,
                    clientY: touch.clientY
                }));
            }
            
            // Reset inactivity timer
            resetInactivityTimer();
        }, { passive: true });
        
        // Touch cancel handler
        mapContainer.addEventListener('touchcancel', function() {
            // Reset touch state
            touchInteractionState.isActive = false;
            
            // Set a timeout before allowing recentering
            setTimeout(() => {
                touchInteractionState.preventRecenter = false;
                isMapInteracting = false;
            }, TOUCH_INTERACTION_COOLDOWN);
            
            // Reset inactivity timer
            resetInactivityTimer();
        }, { passive: true });
    }
    
    // Helper function to calculate distance between two touch points
    function getTouchDistance(touch1, touch2) {
        const dx = touch1.clientX - touch2.clientX;
        const dy = touch1.clientY - touch2.clientY;
        return Math.sqrt(dx * dx + dy * dy);
    }
    
    // Helper function to calculate center point between two touches
    function getTouchCenter(touch1, touch2) {
        return {
            x: (touch1.clientX + touch2.clientX) / 2,
            y: (touch1.clientY + touch2.clientY) / 2
        };
    }

    function updateLoadingStatus(processed, total, elapsed) {
        if (processed === total) {
            // All markers loaded
            console.log(`Loaded ${processed} markers in ${elapsed.toFixed(2)}ms`);
        }
    }

    // Global variable to prevent premature dismissal
    let loadingMessageMinDisplayTime = 0;

    function showLoadingMessage() {
        const existingMessage = document.getElementById('loadingMessage');
        if (existingMessage) return;

        // Set the minimum display time to 8 seconds from now
        loadingMessageMinDisplayTime = Date.now() + 8000; // 8 seconds

        // Create main container with background image and transition properties
        const loadingMessage = document.createElement('div');
        loadingMessage.id = 'loadingMessage';
        loadingMessage.className = 'loading-message';

        // Create content container with improved appearance and initial state for animation
        const contentContainer = document.createElement('div');
        contentContainer.className = 'loading-content';
        
        // Create image with slightly enhanced styling
        const logoImage = document.createElement('img');
        logoImage.src = 'https://mnthen.com/images/logo.webp';
        logoImage.alt = 'Logo';
        logoImage.className = 'loading-logo';

        // Create welcome message with improved typography
        const welcomeMessage = document.createElement('h2');
        welcomeMessage.className = 'loading-title';
        welcomeMessage.textContent = 'Every Step Tells A Story';

        // Create status text with improved styling and stability
        const statusText = document.createElement('p');
        statusText.id = 'loadingStatusText';
        statusText.className = 'loading-status';
        statusText.textContent = 'Initializing...';

        // Create progress bar container with improved depth
        const progressContainer = document.createElement('div');
        progressContainer.className = 'progress-container';

        // Improved progress bar with gradient, glow, and smoother transition
        const progressBar = document.createElement('div');
        progressBar.id = 'loadingProgressBar';
        progressBar.className = 'progress-bar';

        progressContainer.appendChild(progressBar);

        // Assemble and add to document
        contentContainer.appendChild(logoImage);
        contentContainer.appendChild(welcomeMessage);
        contentContainer.appendChild(statusText);
        contentContainer.appendChild(progressContainer);
        loadingMessage.appendChild(contentContainer);
        document.body.appendChild(loadingMessage);

        // Use requestAnimationFrame to ensure the initial styles are applied
        requestAnimationFrame(() => {
            loadingMessage.style.opacity = '1';
            loadingMessage.style.visibility = 'visible';
            contentContainer.style.opacity = '1';
            contentContainer.style.transform = 'scale(1) translateY(0)';
        });

        // Animation Logic
        const totalDuration = 10000; // 10 seconds total animation
        const updateInterval = 100; // Update every 100ms
        const steps = totalDuration / updateInterval;
        let progress = 0;

        const animations = [
            "Initializing map data...",
            "Processing location coordinates...",
            "Preparing exhibit data...",
            "Calibrating view perspective...",
            "Loading nearby points of interest...",
            "Finalizing your experience..."
        ];
        
        // Set initial status text more accurately
        statusText.textContent = animations[0];

        const progressInterval = setInterval(() => {
            progress += (100 / steps);
            const currentProgress = Math.min(progress, 100);

            // Update progress bar width
            if (progressBar) {
                progressBar.style.width = `${currentProgress}%`;
            }

            // Update status text periodically
            if (statusText) {
                const animationIndex = Math.min(
                    Math.floor(currentProgress / (100 / animations.length)),
                    animations.length - 1
                );
                // Only update if the text is different
                if (statusText.textContent !== animations[animationIndex]) {
                    statusText.textContent = animations[animationIndex];
                }
            }

            if (currentProgress >= 100) {
                clearInterval(progressInterval);
                tryHideLoadingMessage();
            }
        }, updateInterval);

        // Store the interval ID if needed
        loadingMessage.dataset.progressInterval = progressInterval;
    }

    function tryHideLoadingMessage() {
        // Only fade out if minimum display time has been reached
        if (Date.now() >= loadingMessageMinDisplayTime) {
            fadeOutLoadingMessage();
        } else {
            // Schedule another check for when the minimum time is reached
            const timeRemaining = loadingMessageMinDisplayTime - Date.now();
            setTimeout(fadeOutLoadingMessage, timeRemaining + 100); // Add a small buffer
        }
    }

    function fadeOutLoadingMessage() {
        const loadingMessage = document.getElementById('loadingMessage');
        if (!loadingMessage) return;
        
        // Clear any ongoing timers
        if (loadingMessage.dataset.progressInterval) {
            clearInterval(parseInt(loadingMessage.dataset.progressInterval));
        }
        
        // Complete progress bar if not already complete
        const progressBar = document.getElementById('loadingProgressBar');
        if (progressBar) {
            progressBar.style.width = '100%';
        }
        
        // Fade out and remove
        loadingMessage.style.opacity = '0';
        setTimeout(() => {
            if (loadingMessage && loadingMessage.parentNode) {
                loadingMessage.parentNode.removeChild(loadingMessage);
            }
        }, 500); // 500ms fade-out transition
    }

    // Public API function to hide loading message (respects minimum display time)
    function hideLoadingMessage() {
        tryHideLoadingMessage();
    }

    function initializeUserLocation(position) {
        console.log("Initial position data:", JSON.stringify(position));

        if (!position || !position.coords) {
            console.error("Invalid initial position object");
            handleLocationError(new Error("Invalid initial position"));
            return;
        }

        const { latitude: userLat, longitude: userLng, accuracy } = position.coords;

        if (isNaN(userLat) || isNaN(userLng)) {
            console.error("Invalid initial coordinates:", { userLat, userLng });
            handleLocationError(new Error("Invalid initial coordinates"));
            return;
        }

        console.log("Valid initial position:", { userLat, userLng, accuracy });

        try {
            userMarker.setLatLng([userLat, userLng]);
            map.setView([userLat, userLng], 19);
            
            // Initialize Kalman filter with first position
            kalmanFilter.reset({
                lat: userLat,
                lng: userLng,
                accuracy: accuracy || 20
            });
            
            hideLoadingMessage();
            startPositionUpdates();
            startHunt();
            
            // Pulse the distance box to draw attention
            const distanceBox = document.getElementById('distanceBox');
            distanceBox.classList.add('pulse');
            setTimeout(() => distanceBox.classList.remove('pulse'), 3000);
        } catch (error) {
            console.error("Error setting initial user location:", error);
            handleLocationError(error);
        }
    }

    function startPositionUpdates() {
        // Store the watch ID to allow stopping if needed
        const watchId = navigator.geolocation.watchPosition(
            handlePositionUpdate,
            handleLocationError,
            {
                enableHighAccuracy: true,
                maximumAge: 1000,
                timeout: 10000
            }
        );
        
        // Optional: Store watchId for later use (to stop tracking)
        window.positionWatchId = watchId;
        
        // Add error recovery mechanism
        window.addEventListener('online', () => {
            // If connection was lost and restored, restart position tracking
            if (window.positionWatchId) {
                navigator.geolocation.clearWatch(window.positionWatchId);
                window.positionWatchId = navigator.geolocation.watchPosition(
                    handlePositionUpdate,
                    handleLocationError,
                    {
                        enableHighAccuracy: true,
                        maximumAge: 1000,
                        timeout: 10000
                    }
                );
            }
        });
        
        // Start periodic proximity checks
        startProximityChecks();
        
        // Return the watchId for external use
        return watchId;
    }

    function startProximityChecks() {
        // Clear any existing interval
        if (window.proximityCheckInterval) {
            clearInterval(window.proximityCheckInterval);
        }
        
        // Set up periodic proximity checks
        window.proximityCheckInterval = setInterval(() => {
            if (!isMapInteracting && followUser && !touchInteractionState.preventRecenter) {
                checkProximityForZoom();
            }
        }, PROXIMITY_CHECK_INTERVAL);
    }

    function handlePositionUpdate(position) {
        // Validate position data
        if (!position || !position.coords || 
            isNaN(position.coords.latitude) || 
            isNaN(position.coords.longitude)) {
            console.warn("Invalid position data received");
            return;
        }
        
        // Add timestamp validation to prevent processing outdated positions
        const positionTimestamp = position.timestamp || new Date().getTime();
        const currentTime = new Date().getTime();
        const maxAgeMs = 30000; // 30 seconds
        
        if (currentTime - positionTimestamp > maxAgeMs) {
            console.warn("Position data too old, ignoring");
            return;
        }
        
        // Update accuracy information
        const accuracy = position.coords.accuracy || 0;
        window.lastPositionAccuracy = accuracy;
        
        // Store last valid position for recovery purposes
        window.lastValidPosition = {
            lat: position.coords.latitude,
            lng: position.coords.longitude,
            timestamp: positionTimestamp,
            accuracy: accuracy
        };
        
        // Process valid position update
        updateUserLocation(position);
    }
        
    function handleVisibilityChange() {
        if (document.hidden) {
            lastHiddenTime = Date.now();
            lastKnownPosition = userMarker ? userMarker.getLatLng() : null;
        } else {
            const hiddenDuration = Date.now() - lastHiddenTime;
            if (hiddenDuration > BACKGROUND_THRESHOLD) {
                updateLocationAfterBackground();
            } else {
                // Just refresh the map size
                map.invalidateSize();
            }
        }
        resetInactivityTimer();
    }

    function updateLocationAfterBackground() {
        if (!("geolocation" in navigator)) {
            console.warn("Geolocation is not available");
            return;
        }
        
        // First try with cached position to get quick response
        const quickOptions = {
            enableHighAccuracy: false,
            timeout: 5000,
            maximumAge: 60000,  // Use a position from last minute if available
        };
        
        // Then try with high accuracy
        const accurateOptions = {
            enableHighAccuracy: true,
            timeout: 15000,
            maximumAge: 30000,
        };
        
        // Final fallback with very permissive settings
        const fallbackOptions = {
            enableHighAccuracy: false,
            timeout: 25000,
            maximumAge: 120000, // Accept positions up to 2 minutes old
        };

        const handleSuccess = (position) => {
            console.log("Background update raw position:", JSON.stringify(position));
            
            if (!position?.coords) {
                console.warn("Invalid position object in background update");
                return;
            }
            const { latitude, longitude, accuracy } = position.coords;
            if (isNaN(latitude) || isNaN(longitude)) {
                console.warn("Invalid coordinates in background update:", { latitude, longitude });
                return;
            }
            console.log("Valid background position update:", { lat: latitude, lng: longitude });
            
            try {
                updateUserLocation(position, true);
                
                // Reset tracking state
                lastPosition = null;
                positionBuffer = [];
                velocity = { lat: 0, lng: 0 };
                lastVelocity = { lat: 0, lng: 0 };
                isStationary = false;
                stationaryStartTime = null;
                stationaryCount = 0;
                stationaryPositionHistory = [];
                lastStationaryPosition = null;
                stationaryPositionLocked = false;
                positionHistory = [];
                suddenMovementCount = 0;
                isJumpDetected = false;
                // Reset Kalman filter
                kalmanFilter.reset({
                    lat: latitude,
                    lng: longitude,
                    accuracy: accuracy,
                    heading: position.coords.heading || 0,
                    timestamp: Date.now(),
                });
                // Restart animation if needed
                if (!animationFrameId) {
                    requestAnimationFrame(render);
                }

                updateDistanceBox();
                followUser = true;
                map.invalidateSize();
            } catch (error) {
                console.error("Error in updateUserLocation during background update:", error);
            }
        };
        
        const handleError = (error, stage) => {
            console.error(`Error getting location during ${stage} attempt:`, error);
            
            switch (error.code) {
                case error.PERMISSION_DENIED:
                    console.warn("User denied geolocation access");
                    break;
                    
                case error.POSITION_UNAVAILABLE:
                    if (stage === "quick") {
                        console.log("Quick position unavailable, trying accurate position...");
                        navigator.geolocation.getCurrentPosition(
                            handleSuccess,
                            (err) => handleError(err, "accurate"),
                            accurateOptions
                        );
                    } else if (stage === "accurate") {
                        console.log("Accurate position unavailable, trying fallback...");
                        navigator.geolocation.getCurrentPosition(
                            handleSuccess,
                            (err) => handleError(err, "fallback"),
                            fallbackOptions
                        );
                    } else {
                        console.warn("All position attempts failed - location unavailable");
                    }
                    break;
                    
                case error.TIMEOUT:
                    if (stage === "quick") {
                        console.log("Quick position timed out, trying accurate position...");
                        navigator.geolocation.getCurrentPosition(
                            handleSuccess,
                            (err) => handleError(err, "accurate"),
                            accurateOptions
                        );
                    } else if (stage === "accurate") {
                        console.log("Accurate position timed out, trying fallback...");
                        navigator.geolocation.getCurrentPosition(
                            handleSuccess,
                            (err) => handleError(err, "fallback"),
                            fallbackOptions
                        );
                    } else {
                        console.warn("All position attempts timed out");
                    }
                    break;
                    
                default:
                    if (stage !== "fallback") {
                        console.log("Unknown error, trying fallback options...");
                        navigator.geolocation.getCurrentPosition(
                            handleSuccess,
                            (err) => handleError(err, "fallback"),
                            fallbackOptions
                        );
                    } else {
                        console.warn("All position attempts failed with unknown error");
                    }
            }
        };

        // Start with quick attempt to get position
        navigator.geolocation.getCurrentPosition(
            handleSuccess,
            (error) => handleError(error, "quick"),
            quickOptions
        );
    }

    // Kalman filter implementation for position smoothing
    const kalmanFilter = {
        x: { estimate: 0, error: 1 },
        y: { estimate: 0, error: 1 },
        q: 0.015, // Process noise
        r: 1,     // Measurement noise
        
        update: function(measurement) {
            // Initialize if first measurement
            if (this.x.estimate === 0 && this.y.estimate === 0) {
                this.x.estimate = measurement.lng;
                this.y.estimate = measurement.lat;
                return measurement;
            }
            
            // X coordinate (longitude)
            const predX = this.x.estimate;
            const predErrX = this.x.error + this.q;
            const gainX = predErrX / (predErrX + this.r);
            this.x.estimate = predX + gainX * (measurement.lng - predX);
            this.x.error = (1 - gainX) * predErrX;
            
            // Y coordinate (latitude)
            const predY = this.y.estimate;
            const predErrY = this.y.error + this.q;
            const gainY = predErrY / (predErrY + this.r);
            this.y.estimate = predY + gainY * (measurement.lat - predY);
            this.y.error = (1 - gainY) * predErrY;
            
            return {
                lat: this.y.estimate,
                lng: this.x.estimate,
                accuracy: measurement.accuracy,
                timestamp: measurement.timestamp,
                heading: measurement.heading,
                speedMPS: measurement.speedMPS
            };
        },
        
        reset: function(measurement) {
            this.x.estimate = measurement.lng;
            this.y.estimate = measurement.lat;
            this.x.error = 1;
            this.y.error = 1;
        }
    };

    function updatePositionBuffer(position) {
        // Add new position to buffer
        positionBuffer.push({
            lat: position.lat,
            lng: position.lng,
            accuracy: position.accuracy,
            timestamp: position.timestamp,
            heading: position.heading,
            speedMPS: position.speedMPS
        });

        // Remove old positions if buffer exceeds maxSize
        while (positionBuffer.length > MAX_BUFFER_SIZE) {
            positionBuffer.shift();
        }
    }

    function calculateWeightedPosition(positions, smoothingFactor = 0.8) {
        if (!Array.isArray(positions) || positions.length === 0) {
            return null;
        }

        // Filter out invalid positions
        const validPositions = positions.filter(pos => 
            pos && typeof pos.lat === 'number' && typeof pos.lng === 'number' && 
            !isNaN(pos.lat) && !isNaN(pos.lng)
        );

        if (validPositions.length === 0) {
            return null;
        }

        let sumLat = 0, sumLng = 0, totalWeight = 0;

        for (let i = 0; i < validPositions.length; i++) {
            const position = validPositions[i];
            const weight = Math.pow(smoothingFactor, validPositions.length - i - 1);
            sumLat += position.lat * weight;
            sumLng += position.lng * weight;
            totalWeight += weight;
        }

        const result = {
            lat: sumLat / totalWeight,
            lng: sumLng / totalWeight,
            accuracy: Math.min(...validPositions.map(p => p.accuracy || 20)),
            timestamp: validPositions[validPositions.length - 1].timestamp,
            heading: validPositions[validPositions.length - 1].heading,
            speedMPS: validPositions[validPositions.length - 1].speedMPS
        };

        return result;
    }

    function render() {
        // Update the map view if needed
        map.invalidateSize();
        
        // Update user marker position
        if (userMarker) {
            userMarker.update();
        }
        
        // Update any other dynamic elements
        updateUIElements();
        
        // Clear the animation frame ID since this is a one-time render
        animationFrameId = null;
    }

    // Helper function to update UI elements
    function updateUIElements() {
        // Update distance indicators
        updateDistanceBox();
    }

    // OPTIMIZED: Completely rewritten proximity zoom function with better performance
    function checkProximityForZoom() {
        // Ensure we have all required objects and values
        if (!userMarker || !map || !gameLocations || !Array.isArray(gameLocations) || gameLocations.length === 0) {
            return;
        }
        
        // Don't run during touch interactions
        if (touchInteractionState.isActive || touchInteractionState.preventRecenter) {
            return;
        }
        
        // Initialize proximityState if needed
        if (!proximityState) {
            proximityState = {
                lastProximityCheck: 0,
                lastZoomChangeTime: 0,
                isNearLocation: false,
                zoomTransitionInProgress: false
            };
        }
        
        // Rate limit checks
        const now = Date.now();
        if (now - (proximityState.lastProximityCheck || 0) < 500) {
            return;
        }
        proximityState.lastProximityCheck = now;
        
        // Don't run during user interactions or transitions
        if (isMapInteracting || proximityState.zoomTransitionInProgress) {
            return;
        }
        
        // Get and validate user position
        const userPos = userMarker.getLatLng();
        if (!userPos || typeof userPos.lat !== 'number' || typeof userPos.lng !== 'number') {
            return;
        }
        
        // Find closest location efficiently
        let closestDistance = Infinity;
        
        for (let i = 0; i < gameLocations.length; i++) {
            const loc = gameLocations[i];
            if (!loc || typeof loc.lat !== 'number' || typeof loc.lng !== 'number') {
                continue;
            }
            
            // Fast approximate distance check first
            const latDiff = userPos.lat - loc.lat;
            const lngDiff = userPos.lng - loc.lng;
            const quickDistSquared = latDiff * latDiff + lngDiff * lngDiff;
            
            // If potentially closer than current best, do accurate calculation
            if (quickDistSquared < closestDistance / 69000) {
                const dist = calculateDistance(userPos, loc);
                if (dist < closestDistance) {
                    closestDistance = dist;
                }
            }
        }
        
        // Convert to feet for threshold comparison
        const distanceFeet = closestDistance * 3.28084;
        
        // Handle entering proximity zone
        if (!proximityState.isNearLocation && distanceFeet <= PROXIMITY_THRESHOLD) {
            if (now - (proximityState.lastZoomChangeTime || 0) >= ZOOM_COOLDOWN) {
                proximityState.isNearLocation = true;
                proximityState.lastZoomChangeTime = now;
                
                if (followUser !== false && !touchInteractionState.preventRecenter) {
                    proximityState.zoomTransitionInProgress = true;
                    
                    // Use setView instead of flyTo to avoid rubber banding
                    map.setView([userPos.lat, userPos.lng], CLOSE_ZOOM, {
                        animate: true,
                        duration: 0.8,
                        noMoveStart: true
                    });
                    
                    setTimeout(() => {
                        proximityState.zoomTransitionInProgress = false;
                    }, 1000);
                }
            }
        } 
        // Handle exiting proximity zone
        else if (proximityState.isNearLocation && distanceFeet >= PROXIMITY_EXIT_THRESHOLD) {
            if (now - (proximityState.lastZoomChangeTime || 0) >= ZOOM_COOLDOWN) {
                proximityState.isNearLocation = false;
                proximityState.lastZoomChangeTime = now;
                
                if (followUser !== false && !touchInteractionState.preventRecenter) {
                    proximityState.zoomTransitionInProgress = true;
                    
                    // Use setView instead of flyTo to avoid rubber banding
                    map.setView([userPos.lat, userPos.lng], BASE_ZOOM, {
                        animate: true,
                        duration: 0.8,
                        noMoveStart: true
                    });
                    
                    setTimeout(() => {
                        proximityState.zoomTransitionInProgress = false;
                    }, 1000);
                }
            }
        }
    }
        
    // OPTIMIZED: Completely rewritten speed-based zoom function with better performance
    function getSpeedBasedZoom(speedMPS) {
        // Get current time for time-based calculations
        const now = Date.now();
        
        // Convert speed to mph for easier human-readable thresholds
        const speedMPH = speedMPS * 2.23694;
        
        // Constants
        const WALKING_THRESHOLD = 3.0;  // mph
        const SIGNIFICANT_TRAVEL_THRESHOLD = 10.0; // mph
        const TEMPORARY_STOP_MAX = 90000; // 90 seconds
        const ARRIVAL_DELAY = 20000; // 20 seconds
        const ZOOM_UPDATE_THRESHOLD = 1000; // ms between zoom updates
        
        // State tracking
        const state = speedZoomState;
        
        // Throttle updates to avoid excessive zoom changes
        if (now - state.lastZoomUpdateTime < ZOOM_UPDATE_THRESHOLD) {
            return state.lastSpeedBasedZoom;
        }
        
        // Update state tracking time
        state.lastZoomUpdateTime = now;
        
        // Detect when we're truly in transit vs. just temporary stops
        if (speedMPH >= SIGNIFICANT_TRAVEL_THRESHOLD) {
            state.isInTransit = true;
            state.lastSignificantMove = now;
            state.destinationArrivalTime = null;
            state.lowSpeedStartTime = null;
        }
        
        // Handle low speed/walking/stopping with improved logic
        if (speedMPH <= WALKING_THRESHOLD) {
            if (!state.lowSpeedStartTime) {
                state.lowSpeedStartTime = now;
            }
            
            const lowSpeedDuration = now - state.lowSpeedStartTime;
            
            // Have we been in transit and now stopping for more than the arrival delay?
            if (state.isInTransit && lowSpeedDuration >= ARRIVAL_DELAY) {
                // If we've been stopped long enough, consider it a destination arrival
                if (!state.destinationArrivalTime) {
                    state.destinationArrivalTime = now;
                }
                
                // We've arrived at destination - set zoom to 17
                if (now - state.destinationArrivalTime >= 5000) {
                    state.isInTransit = false; // Reset transit state
                    state.lastSpeedBasedZoom = 17;
                    return 17;
                }
            }
            
            // For temporary stops during active travel, maintain previous zoom
            if (state.isInTransit && now - state.lastSignificantMove < TEMPORARY_STOP_MAX) {
                return state.lastSpeedBasedZoom || 17;
            }
            
            // Walking or stationary gets zoom level 17
            state.lastSpeedBasedZoom = 17;
            return 17;
        } else {
            // Reset low speed tracking when moving faster than walking
            state.lowSpeedStartTime = null;
            state.destinationArrivalTime = null;
        }
        
        // Optimized speed-based zoom logic with binary search for larger threshold arrays
        let zoom = 17; // Default zoom
        
        // For our small array, a simple loop is still efficient
        for (const threshold of SPEED_ZOOM_THRESHOLDS) {
            if (speedMPH >= threshold.speed) {
                zoom = threshold.zoom;
                break;
            }
        }
        
        state.lastSpeedBasedZoom = zoom;
        return zoom;
    }
        
    // Validates if a position object contains valid coordinates and accuracy data
    function isValidPosition(position) {
        // Check basic structure
        if (!position || typeof position !== 'object') return false;
        
        // Determine which format we're dealing with
        const isGeolocationFormat = position.coords && typeof position.coords === 'object';
        const coords = isGeolocationFormat ? position.coords : position;
        
        // Get lat/lng values depending on format
        const lat = isGeolocationFormat ? coords.latitude : coords.lat;
        const lng = isGeolocationFormat ? coords.longitude : coords.lng;
        const accuracy = coords.accuracy;
        
        // Validate essential coordinates
        const hasValidCoordinates = 
            Number.isFinite(lat) && 
            Number.isFinite(lng) &&
            lat >= -90 && lat <= 90 && 
            lng >= -180 && lng <= 180;
            
        if (!hasValidCoordinates) return false;
        
        // If accuracy is provided, validate it
        if ('accuracy' in coords && !Number.isFinite(accuracy)) return false;
        
        // If timestamp is provided, validate it's a reasonable value
        if ('timestamp' in position) {
            const timestamp = Number(position.timestamp);
            if (!Number.isFinite(timestamp) || timestamp <= 0) return false;
        }
        
        return true;
    }

    function applyExponentialSmoothing(newPosition, lastPosition, baseAlpha = 0.25) {
        // Validate inputs
        if (!isValidPosition(newPosition) || !isValidPosition(lastPosition)) {
            return newPosition;
        }

        // Initialize lastSmoothedPosition if it doesn't exist
        if (!lastSmoothedPosition) {
            lastSmoothedPosition = lastPosition;
        }

        const distance = calculateDistance(newPosition, lastSmoothedPosition);
        
        // Enhanced stationary detection
        if (distance < MIN_DISTANCE_THRESHOLD) {
            stationaryCount = Math.min(stationaryCount + 1, STATIONARY_THRESHOLD);
        } else {
            stationaryCount = Math.max(stationaryCount - 1, 0);
        }

        // Calculate adaptive alpha
        let alpha = baseAlpha;

        // Adjust alpha based on movement state
        if (stationaryCount >= STATIONARY_THRESHOLD) {
            alpha = MIN_ALPHA;
        } else {
            // Gradually reduce alpha as we approach stationary state
            alpha = MAX_ALPHA - (stationaryCount / STATIONARY_THRESHOLD) * (MAX_ALPHA - MIN_ALPHA);
        }

        // Accuracy-based adjustment
        const accuracyRatio = Math.max(0, Math.min(1, 1 - (newPosition.accuracy / MAX_ACCEPTABLE_ACCURACY)));
        alpha = alpha * (0.5 + 0.5 * accuracyRatio);

        // Speed-based adjustment
        if (newPosition.speedMPS !== undefined && newPosition.speedMPS < 0.5) {
            alpha *= 0.4; // Extra smoothing at very low speeds
        }

        // Time-based adjustment to handle GPS jitter
        const timeDelta = newPosition.timestamp - lastPosition.timestamp;
        if (timeDelta < 1000) { // If updates are very frequent
            alpha *= 0.7; // Reduce impact of rapid updates
        }

        // Apply smoothing with weighted factors
        const smoothedPosition = {
            lat: lastSmoothedPosition.lat + alpha * (newPosition.lat - lastSmoothedPosition.lat),
            lng: lastSmoothedPosition.lng + alpha * (newPosition.lng - lastSmoothedPosition.lng),
            accuracy: Math.min(newPosition.accuracy, lastSmoothedPosition.accuracy),
            heading: newPosition.heading,
            timestamp: newPosition.timestamp,
            speedMPS: newPosition.speedMPS ? 
                      lastSmoothedPosition.speedMPS * 0.7 + newPosition.speedMPS * 0.3 : // Smooth speed changes
                      newPosition.speedMPS
        };

        // Apply additional smoothing to heading when stationary
        if (stationaryCount >= STATIONARY_THRESHOLD && lastSmoothedPosition.heading !== undefined) {
            smoothedPosition.heading = alpha * newPosition.heading + (1 - alpha) * lastSmoothedPosition.heading;
        }

        // Additional stabilization for very small movements
        if (distance < MIN_DISTANCE_THRESHOLD * 0.5) {
            smoothedPosition.lat = lastSmoothedPosition.lat * 0.95 + smoothedPosition.lat * 0.05;
            smoothedPosition.lng = lastSmoothedPosition.lng * 0.95 + smoothedPosition.lng * 0.05;
        }

        // Update last smoothed position
        lastSmoothedPosition = smoothedPosition;

        return smoothedPosition;
    }

    function calculateVelocityFilter(newPos, lastPos) {
        if (!lastVelocity) {
            lastVelocity = { lat: 0, lng: 0 };
        }

        if (!newPos || !lastPos || 
            typeof newPos.lat !== 'number' || typeof newPos.lng !== 'number' || 
            typeof lastPos.lat !== 'number' || typeof lastPos.lng !== 'number') {
            return newPos;
        }

        const dt = (newPos.timestamp - lastPos.timestamp) / 1000;
        if (dt <= 0 || dt > 10) {
            return newPos;
        }

        const currentVelocity = {
            lat: (newPos.lat - lastPos.lat) / dt,
            lng: (newPos.lng - lastPos.lng) / dt
        };

        lastVelocity = {
            lat: lastVelocity.lat * VELOCITY_DECAY + currentVelocity.lat * (1 - VELOCITY_DECAY),
            lng: lastVelocity.lng * VELOCITY_DECAY + currentVelocity.lng * (1 - VELOCITY_DECAY)
        };

        // Apply velocity prediction
        return {
            lat: lastPos.lat + lastVelocity.lat * dt,
            lng: lastPos.lng + lastVelocity.lng * dt,
            accuracy: newPos.accuracy,
            timestamp: newPos.timestamp,
            heading: newPos.heading,
            speedMPS: newPos.speedMPS
        };
    }

    function checkStationaryState(newPosition) {
        if (!lastPosition) return;
        
        const distance = calculateDistance(lastPosition, newPosition);
        
        if (distance >= MICRO_MOVEMENT_THRESHOLD) {
            isStationary = false;
            stationaryStartTime = null;
            console.debug("Movement detected, resuming normal updates");
        }
        
        if (stationaryCheckTimeout) {
            clearTimeout(stationaryCheckTimeout);
            stationaryCheckTimeout = null;
        }
        
        if (isStationary) {
            stationaryCheckTimeout = setTimeout(() => checkStationaryState(newPosition), STATIONARY_CHECK_INTERVAL);
        }
    }

    function calculateFinalPosition() {
        // If buffer is empty, return null
        if (positionBuffer.length === 0) {
            return null;
        }
        
        // If only one position in buffer, return it
        if (positionBuffer.length === 1) {
            return positionBuffer[0];
        }
        
        // Calculate weighted average of positions in buffer
        return calculateWeightedPosition(positionBuffer);
    }

    function updateMarkerAndMap(position, speedMPS) {
        if (!position || typeof position.lat !== 'number' || typeof position.lng !== 'number') {
            console.warn("Invalid position for marker update");
            return;
        }
        
        // Update marker position with animation
        userMarker.setLatLng([position.lat, position.lng], { animate: true, duration: 0.3 });
        
        // Check if we need to recenter map based on user position
        if (followUser && !isMapInteracting && !touchInteractionState.preventRecenter) {
            const recenterInfo = shouldRecenter(map, userMarker);
            
            if (recenterInfo.needsRecenter) {
                const newCenter = recenterInfo.isEmergency ? 
                    [position.lat, position.lng] : 
                    calculateOptimalCenter(map, position, recenterInfo.edgeInfo);
                    
                map.panTo(newCenter, {
                    animate: true,
                    duration: recenterInfo.isEmergency ? 0.1 : 0.5,
                    easeLinearity: 0.5
                });
            }
            
            // Adjust zoom based on speed if needed
            const zoomLevel = getSpeedBasedZoom(speedMPS);
            if (zoomLevel !== -1 && Math.abs(map.getZoom() - zoomLevel) > 0.5) {
                map.setZoom(zoomLevel, { animate: true, duration: 1 });
            }
        }
        
        // Update distance box
        updateDistanceBox();
    }

    function updateUserLocation(position, forceUpdate = false) {
        // Validate input position
        if (!position?.coords?.latitude || !position?.coords?.longitude) {
            console.warn("Invalid position data received");
            return;
        }

        // Cancel any pending animation frame
        if (animationFrameId !== null) {
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
        }

        const currentTime = Date.now();
        const timeDelta = lastUpdateTime ? (currentTime - lastUpdateTime) / 1000 : 0;

        const newPosition = {
            lat: position.coords.latitude,
            lng: position.coords.longitude,
            accuracy: position.coords.accuracy || 20,
            heading: position.coords.heading ?? null,
            timestamp: currentTime,
            speedMPS: position.coords.speed || 0
        };

        // First position initialization
        if (!lastPosition) {
            lastPosition = newPosition;
            userMarker.setLatLng([newPosition.lat, newPosition.lng]);
            kalmanFilter.reset(newPosition);
            lastUpdateTime = currentTime;
            stationaryStartTime = currentTime;
            positionBuffer = [newPosition];
            
            const zoomLevel = getSpeedBasedZoom(newPosition.speedMPS);
            if (zoomLevel !== -1) {
                map.setZoom(zoomLevel, { animate: false });
            }
            map.setView([newPosition.lat, newPosition.lng], map.getZoom(), { animate: false });
            updateDistanceBox();
            return;
        }

        const distance = calculateDistance(lastPosition, newPosition);

        // Enhanced adaptive filtering based on speed
        const speedFactor = Math.min(1, Math.max(0.1, newPosition.speedMPS / 10));
        kalmanFilter.q = BASE_PROCESS_NOISE * speedFactor;
        kalmanFilter.r = newPosition.accuracy / (100 * (1 + speedFactor));

        // Extended distance handling with improved smoothing
        if (distance > EXTENDED_DISTANCE_THRESHOLD || forceUpdate) {
            if (stationaryCheckTimeout) {
                clearTimeout(stationaryCheckTimeout);
                stationaryCheckTimeout = null;
            }
            isStationary = false;
            stationaryStartTime = null;

            const transitionPosition = {
                lat: newPosition.lat,
                lng: newPosition.lng,
                accuracy: newPosition.accuracy,
                heading: newPosition.heading,
                timestamp: currentTime,
                speedMPS: newPosition.speedMPS
            };

            userMarker.setLatLng([transitionPosition.lat, transitionPosition.lng], { animate: false });
            lastPosition = transitionPosition;
            positionBuffer = [transitionPosition];
            kalmanFilter.reset(transitionPosition);
            lastVelocity = { lat: 0, lng: 0 };

            const zoomLevel = getSpeedBasedZoom(newPosition.speedMPS);
            if (zoomLevel !== -1) {
                map.setZoom(zoomLevel, { animate: false });
            }
            
            // Only update map view if not in touch interaction
            if (!touchInteractionState.isActive && !touchInteractionState.preventRecenter) {
                map.setView([transitionPosition.lat, transitionPosition.lng], map.getZoom(), 
                    animate: false, 
                    duration: 0,
                    noMoveStart: true
                });
            }
            
            lastUpdateTime = currentTime;
            lastUpdateTimestamp = currentTime;
            updateDistanceBox();
            
            if (map._container) {
                map._onResize();
            }
            return;
        }

        // Enhanced stationary detection with improved filtering
        if (distance < MICRO_MOVEMENT_THRESHOLD && !forceUpdate) {
            if (!isStationary) {
                if (!stationaryStartTime) {
                    stationaryStartTime = currentTime;
                } else if (currentTime - stationaryStartTime >= STATIONARY_TIME_THRESHOLD) {
                    isStationary = true;
                    
                    kalmanFilter.r = Math.min(newPosition.accuracy, lastPosition.accuracy) / 200;
                    kalmanFilter.q = BASE_PROCESS_NOISE * 0.1;
                    
                    const stationaryPosition = kalmanFilter.update({
                        lat: newPosition.lat,
                        lng: newPosition.lng,
                        accuracy: Math.min(lastPosition.accuracy, newPosition.accuracy) * STATIONARY_ACCURACY_MULTIPLIER,
                        heading: newPosition.heading,
                        timestamp: newPosition.timestamp,
                        speedMPS: 0
                    });
                    
                    userMarker.setLatLng([stationaryPosition.lat, stationaryPosition.lng], { animate: false });
                    lastPosition = stationaryPosition;
                    positionBuffer = [stationaryPosition];
                    
                    if (stationaryCheckTimeout) clearTimeout(stationaryCheckTimeout);
                    stationaryCheckTimeout = setTimeout(() => checkStationaryState(newPosition), STATIONARY_CHECK_INTERVAL);
                    
                    updateDistanceBox();
                    return;
                }
            }
            
            if (isStationary) {
                if (newPosition.accuracy < lastPosition.accuracy * 0.9) {
                    kalmanFilter.r = newPosition.accuracy / 400;
                    kalmanFilter.q = BASE_PROCESS_NOISE * 0.05;
                    
                    const refinedPosition = kalmanFilter.update({
                        lat: newPosition.lat,
                        lng: newPosition.lng,
                        accuracy: newPosition.accuracy,
                        heading: newPosition.heading,
                        timestamp: newPosition.timestamp,
                        speedMPS: 0
                    });
                    
                    if (calculateDistance(lastPosition, refinedPosition) < MICRO_MOVEMENT_THRESHOLD / 2) {
                        userMarker.setLatLng([refinedPosition.lat, refinedPosition.lng], { animate: false });
                        lastPosition = refinedPosition;
                        updateDistanceBox();
                    }
                }
                return;
            }
        } else {
            isStationary = false;
            stationaryStartTime = null;
            if (stationaryCheckTimeout) {
                clearTimeout(stationaryCheckTimeout);
                stationaryCheckTimeout = null;
            }
        }

        // Skip updates with poor accuracy or unrealistic movement
        if (!forceUpdate && (
            newPosition.accuracy > MAX_ACCEPTABLE_ACCURACY ||
            distance < MIN_DISTANCE_THRESHOLD ||
            (timeDelta > 0 && distance / timeDelta > MAX_SPEED)
        )) {
            return;
        }

        try {
            // Apply Kalman filter with adaptive parameters
            const filteredPosition = kalmanFilter.update({
                lat: newPosition.lat,
                lng: newPosition.lng,
                accuracy: newPosition.accuracy,
                heading: newPosition.heading,
                timestamp: newPosition.timestamp,
                speedMPS: newPosition.speedMPS
            });

            updatePositionBuffer(filteredPosition);
            
            const finalPosition = calculateFinalPosition();
            if (!finalPosition) throw new Error("Final position calculation failed");

            const predictedPosition = calculateEnhancedVelocityFilter(finalPosition, lastPosition, timeDelta, newPosition.speedMPS);
            
            const smoothingFactor = Math.min(0.8, Math.max(0.2, 0.3 + (speedFactor * 0.5)));
            const smoothedPosition = {
                lat: lastPosition.lat * (1 - smoothingFactor) + predictedPosition.lat * smoothingFactor,
                lng: lastPosition.lng * (1 - smoothingFactor) + predictedPosition.lng * smoothingFactor,
                accuracy: predictedPosition.accuracy,
                heading: predictedPosition.heading,
                timestamp: currentTime,
                speedMPS: predictedPosition.speedMPS
            };

            const animDuration = Math.min(0.3, Math.max(0.1, 0.2 / (1 + speedFactor)));
            
            userMarker.setLatLng([smoothedPosition.lat, smoothedPosition.lng], {
                animate: true,
                duration: animDuration
            });
            
            // Only update map if we're following user and not in touch interaction
            if (followUser && !touchInteractionState.isActive && !touchInteractionState.preventRecenter && 
                (currentTime - lastMapUpdateTime > MAP_UPDATE_INTERVAL || distance > POSITION_UPDATE_THRESHOLD)) {
                
                // Call proximity check function
                checkProximityForZoom();
                
                const lookAheadFactor = Math.min(0.5, speedFactor * 0.3);
                
                const lookAheadPosition = {
                    lat: smoothedPosition.lat + (predictedPosition.lat - lastPosition.lat) * lookAheadFactor,
                    lng: smoothedPosition.lng + (predictedPosition.lng - lastPosition.lng) * lookAheadFactor
                };
                
                // Use requestAnimationFrame for smoother panning
                animationFrameId = requestAnimationFrame(() => {
                    map.panTo([lookAheadPosition.lat, lookAheadPosition.lng], {
                        animate: true,
                        duration: 0.5,
                        easeLinearity: 0.5
                    });
                    
                    const zoomLevel = getSpeedBasedZoom(newPosition.speedMPS);
                    if (zoomLevel !== -1 && Math.abs(map.getZoom() - zoomLevel) >= 1) {
                        map.setZoom(zoomLevel, { animate: true, duration: 1 });
                    }
                    
                    animationFrameId = null;
                });
                
                lastMapUpdateTime = currentTime;
            }

            lastPosition = smoothedPosition;
            lastUpdateTime = currentTime;
            lastUpdateTimestamp = currentTime;
            updateDistanceBox();

        } catch (error) {
            console.error("Location update error:", error);
            // Cancel any pending animation frame on error
            if (animationFrameId !== null) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            
            kalmanFilter.r = newPosition.accuracy / 50;
            const fallbackPosition = kalmanFilter.update(newPosition);
            userMarker.setLatLng([fallbackPosition.lat, fallbackPosition.lng], { animate: true, duration: 0.3 });
            lastPosition = fallbackPosition;
            positionBuffer = [fallbackPosition];
            updateDistanceBox();
        }
    }

    // New helper function for enhanced velocity prediction with acceleration
    function calculateEnhancedVelocityFilter(currentPosition, lastPosition, timeDelta, speed) {
        if (!timeDelta || timeDelta <= 0) {
            return currentPosition;
        }
        
        // Calculate current velocity components
        const currentVelocity = {
            lat: (currentPosition.lat - lastPosition.lat) / timeDelta,
            lng: (currentPosition.lng - lastPosition.lng) / timeDelta
        };
        
        // If no last velocity, initialize it
        if (!lastVelocity) {
            lastVelocity = currentVelocity;
        }
        
        // Calculate acceleration (change in velocity)
        const acceleration = {
            lat: (currentVelocity.lat - lastVelocity.lat) / timeDelta,
            lng: (currentVelocity.lng - lastVelocity.lng) / timeDelta
        };
        
        // Apply acceleration damping at higher speeds to prevent oscillation
        const accelerationDamping = Math.min(1, Math.max(0.2, 1 - (speed / 20)));
        const dampedAcceleration = {
            lat: acceleration.lat * accelerationDamping,
            lng: acceleration.lng * accelerationDamping
        };
        
        // Store current velocity for next update
        lastVelocity = currentVelocity;
        
        // Calculate predicted position using velocity and damped acceleration
        const predictionTimeFactor = Math.min(0.5, Math.max(0.1, timeDelta)); // Limit prediction time
        
        const predictedPosition = {
            lat: currentPosition.lat + (currentVelocity.lat * predictionTimeFactor) + (0.5 * dampedAcceleration.lat * predictionTimeFactor * predictionTimeFactor),
            lng: currentPosition.lng + (currentVelocity.lng * predictionTimeFactor) + (0.5 * dampedAcceleration.lng * predictionTimeFactor * predictionTimeFactor),
            accuracy: currentPosition.accuracy,
            heading: currentPosition.heading,
            timestamp: currentPosition.timestamp,
            speedMPS: speed
        };
        
        return predictedPosition;
    }

    function calculateEdgeProximity(map, point) {
        const bounds = map.getBounds();
        const latSpan = bounds.getNorth() - bounds.getSouth();
        const lngSpan = bounds.getEast() - bounds.getWest();
        
        return {
            north: Math.abs(point.lat - bounds.getNorth()) / latSpan,
            south: Math.abs(point.lat - bounds.getSouth()) / latSpan,
            east: Math.abs(point.lng - bounds.getEast()) / lngSpan,
            west: Math.abs(point.lng - bounds.getWest()) / lngSpan
        };
    }

    function isMarkerNearEdge(map, marker, isStrict = false) {
        const bounds = map.getBounds();
        const point = marker.getLatLng();
        const proximities = calculateEdgeProximity(map, point);
        
        const thresholdPercentage = isStrict ? 
            STRICT_EDGE_THRESHOLD_PERCENTAGE : 
            EDGE_THRESHOLD_PERCENTAGE;
        
        const edges = {
            north: proximities.north < thresholdPercentage,
            south: proximities.south < thresholdPercentage,
            east: proximities.east < thresholdPercentage,
            west: proximities.west < thresholdPercentage
        };
        
        return {
            isNearEdge: Object.values(edges).some(edge => edge),
            edges: edges,
            proximities: proximities
        };
    }

    function calculateOptimalCenter(map, markerPosition, edgeInfo) {
        const bounds = map.getBounds();
        
        let latOffset = 0;
        let lngOffset = 0;
        
        if (edgeInfo.edges.north) latOffset = -1 * (bounds.getNorth() - bounds.getSouth()) * 0.2;
        if (edgeInfo.edges.south) latOffset = (bounds.getNorth() - bounds.getSouth()) * 0.2;
        if (edgeInfo.edges.east) lngOffset = -1 * (bounds.getEast() - bounds.getWest()) * 0.2;
        if (edgeInfo.edges.west) lngOffset = (bounds.getEast() - bounds.getWest()) * 0.2;
        
        return {
            lat: markerPosition.lat + latOffset,
            lng: markerPosition.lng + lngOffset
        };
    }

    let lastRecenterTime = Date.now();

    function shouldRecenter(map, marker) {
        const now = Date.now();
        if (now - lastRecenterTime < MIN_RECENTER_INTERVAL) {
            return { needsRecenter: false };
        }
        
        // Don't recenter during touch interactions
        if (touchInteractionState.isActive || touchInteractionState.preventRecenter) {
            return { needsRecenter: false };
        }
        
        const edgeInfo = isMarkerNearEdge(map, marker);
        const proximities = edgeInfo.proximities;
        
        const isCritical = Object.values(proximities).some(
            proximity => proximity < CRITICAL_EDGE_THRESHOLD_PERCENTAGE
        );
        
        if (isCritical) {
            lastRecenterTime = now;
            return {
                needsRecenter: true,
                isEmergency: true,
                edgeInfo: edgeInfo
            };
        }
        
        if (edgeInfo.isNearEdge) {
            lastRecenterTime = now;
            return {
                needsRecenter: true,
                isEmergency: false,
                edgeInfo: edgeInfo
            };
        }
        
        return {
            needsRecenter: false,
            isEmergency: false,
            edgeInfo: edgeInfo
        };
    }

    function updateDistanceBox() {
        const distanceBox = document.getElementById('distanceBox');
        
        // Initial validation
        if (!userMarker || !gameLocations || gameLocations.length === 0) {
            distanceBox.innerText = 'Initializing...';
            return;
        }

        // Get user coordinates
        const userLatLng = userMarker.getLatLng();
        let userLat = userLatLng.lat;
        let userLng = userLatLng.lng;

        // Coordinate validation
        if (!isFinite(userLat) || !isFinite(userLng)) {
            console.warn('Invalid user coordinates:', userLat, userLng);
            distanceBox.innerText = 'Initializing...';
            return;
        }

        // Use map center if at origin
        if (userLat === 0 && userLng === 0) {
            const center = map.getCenter();
            userLat = center.lat;
            userLng = center.lng;
        }

        // Find closest location
        let closestDistance = Infinity;
        let closestLocation = null;
        const userPos = { lat: userLat, lng: userLng };

        for (const location of gameLocations) {
            if (!location || typeof location.lat !== 'number' || typeof location.lng !== 'number') {
                console.warn('Invalid location data:', location);
                continue;
            }

            const locationPos = { lat: location.lat, lng: location.lng };
            const distance = calculateDistance(userPos, locationPos);

            if (isFinite(distance) && distance < closestDistance) {
                closestDistance = distance;
                closestLocation = location;
            }
        }

        // Validate final distance calculation
        if (!isFinite(closestDistance) || closestDistance === Infinity) {
            console.warn('Invalid distance calculation:', closestDistance);
            distanceBox.innerText = 'Initializing...';
            return;
        }

        // Calculate and display distance
        const distanceFeet = Math.round(closestDistance * 3.28084);
        const distanceText = distanceFeet < 5280 
            ? `${distanceFeet.toLocaleString()} feet` 
            : `${(distanceFeet / 5280).toFixed(2)} miles`;
        
        distanceBox.innerText = `Closest Stop: ${distanceText}`;

        // Check if we should show location hunt
        if (distanceFeet <= DISTANCE_THRESHOLD && !isLocationHuntVisible && closestLocation) {
            showLocationHunt(closestLocation);
        }
    }

    function getGeolocationOptions(retryNumber) {
        return {
            enableHighAccuracy: retryNumber < 2,
            timeout: 10000 + (retryNumber * 5000),
            maximumAge: retryNumber * 5000
        };
    }

    function handleLocationError(error) {
        console.warn("Error getting user location:", error);
        
        if (retryCount < MAX_RETRIES) {
            retryCount++;
            console.log(`Retrying to get location (Attempt ${retryCount} of ${MAX_RETRIES})`);
            
            // Use increasing timeout for subsequent retries
            const currentRetryDelay = RETRY_DELAY * retryCount;
            
            setTimeout(() => {
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        console.log("Location retrieved successfully after retry");
                        hideLoadingMessage();
                        updateUserLocation(position, true);
                        retryCount = 0;
                    }, 
                    handleLocationError, 
                    getGeolocationOptions(retryCount) 
                );
            }, currentRetryDelay);
            return;
        }
        
        retryCount = 0;
        hideLoadingMessage();
        
        let errorMessage = "An error occurred while getting your location.";
        if (error && error.code) {
            switch(error.code) {
                case 1: // PERMISSION_DENIED
                    errorMessage = "Please allow access to your location to use this feature.";
                    break;
                case 2: // POSITION_UNAVAILABLE
                    errorMessage = "Your location is currently unavailable. Please try again later.";
                    break;
                case 3: // TIMEOUT
                    errorMessage = "Getting your location took too long. Please try again.";
                    break;
            }
        }
        
        showPopup("Location Error", errorMessage);
        
        // Signal that the location request failed
        if (typeof onLocationFailure === 'function') {
            onLocationFailure(error);
        }
    }

    function showPopup(title, message, type = 'info', callback = null) {
        // Remove any existing popups
        const existingPopups = document.querySelectorAll('.popup');
        existingPopups.forEach(popup => {
            document.body.removeChild(popup);
        });
        
        const popup = document.createElement('div');
        popup.classList.add('popup', 'fade-in');
        
        const popupContent = document.createElement('div');
        popupContent.classList.add('popup-content');
        
        const titleElement = document.createElement('h3');
        titleElement.textContent = title;
        
        const messageElement = document.createElement('p');
        messageElement.textContent = message;
        
        const buttonContainer = document.createElement('div');
        buttonContainer.classList.add('button-container');
        
        const okButton = document.createElement('button');
        okButton.textContent = 'OK';
        okButton.classList.add('ok-button');
        
        okButton.addEventListener('click', () => {
            popup.classList.add('fade-out');
            setTimeout(() => {
                if (document.body.contains(popup)) {
                    document.body.removeChild(popup);
                }
                if (callback) callback();
            }, 300);
        });
        
        buttonContainer.appendChild(okButton);
        
        if (type === 'info') {
            const cancelButton = document.createElement('button');
            cancelButton.textContent = 'Cancel';
            cancelButton.classList.add('cancel-button');
            
            cancelButton.addEventListener('click', () => {
                popup.classList.add('fade-out');
                setTimeout(() => {
                    if (document.body.contains(popup)) {
                        document.body.removeChild(popup);
                    }
                }, 300);
            });
            buttonContainer.appendChild(cancelButton);
        }
        
        popupContent.appendChild(titleElement);
        popupContent.appendChild(messageElement);
        popupContent.appendChild(buttonContainer);
        popup.appendChild(popupContent);
        document.body.appendChild(popup);
    }

    let lastVisitTime = 0;
    const cooldownPeriod = 3 * 60 * 1000; // 3 minutes

    function showLocationHunt(location) {
        const now = performance.now();
        if (location.id === lastVisitedLocationId && now - lastVisitTime < cooldownPeriod) {
            console.log(`Location ${location.id} is on cooldown. Skipping.`);
            return;
        }
        
        lastVisitedLocationId = location.id;
        lastVisitTime = now;
        isLocationHuntVisible = true;

        const lochuntContainer = document.querySelector('.lochunt-container');
        lochuntContainer.innerHTML = '';
        lochuntContainer.style.display = 'flex';
        lochuntContainer.classList.add('fade-in');

        const scrollableContent = document.createElement('div');
        scrollableContent.classList.add('scrollable-content');

        const locationImage = document.createElement('img');
        locationImage.src = location.image;
        locationImage.alt = location.name;
        locationImage.classList.add('location-image');
        locationImage.loading = "eager"; // Prioritize image loading

        scrollableContent.appendChild(locationImage);

        const contentContainer = document.createElement('div');
        contentContainer.classList.add('lochunt-content');
        
        const locationInfo = document.createElement('div');
        locationInfo.classList.add('lochunt-info');
        
        const locationName = document.createElement('h1');
        locationName.textContent = location.name;
        locationName.classList.add('location-name');
        
        const locationCity = document.createElement('p');
        locationCity.textContent = `${location.city}`;
        locationCity.classList.add('location-city');
        
        const locationCreator = document.createElement('p');
        locationCreator.textContent = `Created by: ${location.creator}`;
        locationCreator.classList.add('location-creator');
        
        locationInfo.appendChild(locationName);
        locationInfo.appendChild(locationCity);
        locationInfo.appendChild(locationCreator);
        contentContainer.appendChild(locationInfo);
        
        const audioPlayerContainer = createAudioPlayer(location.audio);
        contentContainer.appendChild(audioPlayerContainer);
        scrollableContent.appendChild(contentContainer);
        lochuntContainer.appendChild(scrollableContent);
        
        const bottomActionBar = createBottomActionBar(location);
        lochuntContainer.appendChild(bottomActionBar);
        
        // Initialize audio player after DOM is updated
        setTimeout(() => {
            initAudioPlayer();
        }, 100);
    }

    function createAudioPlayer(audioSrc) {
        const audioPlayerContainer = document.createElement('div');
        audioPlayerContainer.classList.add('audio-player');

        const audio = document.createElement('audio');
        audio.id = 'locationAudio';
        audio.src = audioSrc;
        audio.preload = "auto";

        const audioProgress = document.createElement('div');
        audioProgress.classList.add('audio-progress');

        const progressContainer = document.createElement('div');
        progressContainer.classList.add('progress');

        const progressBar = document.createElement('div');
        progressBar.id = 'progressBar';
        progressBar.classList.add('progress-bar');

        progressContainer.appendChild(progressBar);
        audioProgress.appendChild(progressContainer);

        const timeInfo = document.createElement('div');
        timeInfo.classList.add('audio-time');

        const currentTimeSpan = document.createElement('span');
        currentTimeSpan.id = 'currentTime';
        currentTimeSpan.textContent = '0:00';

        const durationSpan = document.createElement('span');
        durationSpan.id = 'duration';
        durationSpan.textContent = '0:00';

        timeInfo.appendChild(currentTimeSpan);
        timeInfo.appendChild(durationSpan);

        const audioControls = document.createElement('div');
        audioControls.classList.add('audio-controls');

        const rewindBtn = createAudioButton('skip-backward', 'rewindBtn', 'Rewind 10 seconds');
        const playPauseBtn = createAudioButton('play', 'playPauseBtn', 'Play');
        const forwardBtn = createAudioButton('skip-forward', 'forwardBtn', 'Forward 10 seconds');

        audioControls.appendChild(rewindBtn);
        audioControls.appendChild(playPauseBtn);
        audioControls.appendChild(forwardBtn);

        audioPlayerContainer.appendChild(audio);
        audioPlayerContainer.appendChild(audioProgress);
        audioPlayerContainer.appendChild(timeInfo);
        audioPlayerContainer.appendChild(audioControls);

        return audioPlayerContainer;
    }

    function createAudioButton(iconName, id, ariaLabel) {
        const button = document.createElement('button');
        button.id = id;
        button.classList.add('audio-button');
        button.setAttribute('aria-label', ariaLabel);
        button.innerHTML = `<i class="bi bi-${iconName}"></i>`;
        
        return button;
    }

    function createBottomActionBar(location) {
        const actionBar = document.createElement('div');
        actionBar.classList.add('location-action-bar');
        
        const imgSourceBtn = document.createElement('button');
        imgSourceBtn.classList.add('source-info-button', 'btn', 'btn-sm', 'me-2');
        imgSourceBtn.innerHTML = '<i class="bi bi-info-circle-fill text-white" style="font-size: 1.5rem;"></i>';
        imgSourceBtn.setAttribute('aria-label', 'Image source information');
        imgSourceBtn.onclick = () => {
            if (location && location.imageSource) {
                showSourcePopup('Image Source', location.imageSource);
            } else {
                showSourcePopup('Image Source', 'Image source information is not available');
            }
        };

        const feedbackButton = document.createElement('a');
        feedbackButton.href = 'mailto:mattreicher@protonmail.com?subject=Feedback';
        feedbackButton.target = '_blank';
        feedbackButton.rel = 'noopener noreferrer';
        feedbackButton.setAttribute('aria-label', 'Send feedback email');
        feedbackButton.innerHTML = '<i class="bi bi-envelope-fill text-white" style="font-size: 1.5rem;"></i>';
        feedbackButton.classList.add('feedback-email-button', 'btn', 'btn-sm');

        actionBar.appendChild(imgSourceBtn);
        actionBar.appendChild(feedbackButton);
        return actionBar;
    }

    // Completely new implementation of showPopup focused on image source
    function showSourcePopup(title, content) {
        // Remove any existing popups first
        const existingPopup = document.getElementById('sourceInfoPopup');
        if (existingPopup) {
            document.body.removeChild(existingPopup);
        }
        
        // Create overlay container that covers the entire screen
        const overlay = document.createElement('div');
        overlay.id = 'sourceInfoPopup';
        overlay.classList.add('source-info-popup');

        // Create the popup content box
        const popup = document.createElement('div');
        popup.classList.add('source-info-content');

        // Create title
        const popupTitle = document.createElement('h3');
        popupTitle.textContent = title;
        popupTitle.classList.add('source-info-title');

        // Create content
        const popupContent = document.createElement('div');
        popupContent.classList.add('source-info-text');
        popupContent.textContent = content;

        // Create close button
        const closeButton = document.createElement('button');
        closeButton.textContent = 'Close';
        closeButton.classList.add('source-close-button', 'btn');
        
        closeButton.addEventListener('click', () => {
            document.body.removeChild(overlay);
        });

        // Add click event to close when clicking outside the popup
        overlay.addEventListener('click', (e) => {
            if (e.target === overlay) {
                document.body.removeChild(overlay);
            }
        });

        // Assemble popup
        popup.appendChild(popupTitle);
        popup.appendChild(popupContent);
        popup.appendChild(closeButton);
        overlay.appendChild(popup);
        document.body.appendChild(overlay);

        // Add animation
        overlay.style.opacity = '0';
        popup.style.transform = 'translateY(20px)';
        
        // Trigger animation
        setTimeout(() => {
            overlay.style.opacity = '1';
            popup.style.transform = 'translateY(0)';
        }, 10);
    }

    function initAudioPlayer() {
        const audio = document.getElementById('locationAudio');
        const playPauseBtn = document.getElementById('playPauseBtn');
        const rewindBtn = document.getElementById('rewindBtn');
        const forwardBtn = document.getElementById('forwardBtn');
        const progressBar = document.getElementById('progressBar');
        const progressContainer = document.querySelector('.progress');
        const currentTimeSpan = document.getElementById('currentTime');
        const durationSpan = document.getElementById('duration');

        if (!audio || !playPauseBtn || !progressBar) {
            console.error("Audio player elements not found");
            return;
        }

        // Set up event listeners
        playPauseBtn.addEventListener('click', togglePlay);
        rewindBtn.addEventListener('click', () => seek(-10));
        forwardBtn.addEventListener('click', () => seek(10));
        audio.addEventListener('timeupdate', updateProgress);
        audio.addEventListener('loadedmetadata', setDuration);
        audio.addEventListener('ended', () => {
            playPauseBtn.innerHTML = '<i class="bi bi-play"></i>';
            playPauseBtn.setAttribute('aria-label', 'Play');
            showAdditionalInfo();
        });
        
        if (progressContainer) {
            progressContainer.addEventListener('click', setProgress);
        }

        // Preload audio
        audio.load();

        function togglePlay() {
            if (audio.paused) {
                const playPromise = audio.play();
                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        playPauseBtn.innerHTML = '<i class="bi bi-pause"></i>';
                        playPauseBtn.setAttribute('aria-label', 'Pause');
                    }).catch(error => {
                        console.error("Audio play error:", error);
                        showSourcePopup("Audio Error", "There was a problem playing the audio. Please try again.");
                    });
                }
            } else {
                audio.pause();
                playPauseBtn.innerHTML = '<i class="bi bi-play"></i>';
                playPauseBtn.setAttribute('aria-label', 'Play');
            }
        }

        function seek(seconds) {
            audio.currentTime = Math.max(0, Math.min(audio.currentTime + seconds, audio.duration));
        }

        function updateProgress() {
            if (!isFinite(audio.duration)) return;
            
            const percent = (audio.currentTime / audio.duration) * 100;
            progressBar.style.width = `${percent}%`;
            currentTimeSpan.textContent = formatTime(audio.currentTime);
        }

        function setProgress(e) {
            const width = this.clientWidth;
            const clickX = e.offsetX;
            const duration = audio.duration;
            
            if (isFinite(duration) && width > 0) {
                audio.currentTime = (clickX / width) * duration;
            }
        }

        function setDuration() {
            if (isFinite(audio.duration)) {
                durationSpan.textContent = formatTime(audio.duration);
            }
        }

        function formatTime(time) {
            if (!isFinite(time)) return "0:00";
            
            const minutes = Math.floor(time / 60);
            const seconds = Math.floor(time % 60);
            return `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }
    }

    function showAdditionalInfo() {
        const additionalInfoContainer = document.querySelector('.additional-info-container');
        const additionalInfo = document.getElementById('additionalInfo');

        if (!additionalInfoContainer || !additionalInfo) {
            console.error("Additional info elements not found");
            return;
        }

        // Get the current location
        const currentLocation = gameLocations.find(loc => loc.id === lastVisitedLocationId);

        if (!currentLocation || !currentLocation.additionalInfo) {
            console.warn("Additional info not found for location:", lastVisitedLocationId);
            additionalInfo.textContent = "Additional information is not available for this location.";
        } else {
            additionalInfo.textContent = currentLocation.additionalInfo;
        }

        additionalInfoContainer.style.display = 'block';
        additionalInfoContainer.classList.add('fade-in');

        // Remove existing event listeners to prevent multiple calls
        const continueButton = document.getElementById('continueButton');
        const newContinueButton = continueButton.cloneNode(true);
        continueButton.parentNode.replaceChild(newContinueButton, continueButton);

        newContinueButton.addEventListener('click', () => {
            additionalInfoContainer.classList.remove('fade-in');
            additionalInfoContainer.classList.add('fade-out');

            setTimeout(() => {
                additionalInfoContainer.style.display = 'none';
                additionalInfoContainer.classList.remove('fade-out');
                hideLocationHunt();
            }, 300);
        });
    }

    function hideLocationHunt() {
        const lochuntContainer = document.querySelector('.lochunt-container');
        if (lochuntContainer) {
            lochuntContainer.classList.remove('fade-in');
            lochuntContainer.classList.add('fade-out');

            setTimeout(() => {
                lochuntContainer.style.display = 'none';
                lochuntContainer.classList.remove('fade-out');
                isLocationHuntVisible = false;
            }, 300);
        }
    }

    function calculateDistance(point1, point2) {
        // Haversine formula for calculating distance between two points
        const R = 6371e3; // Earth radius in meters
        const φ1 = point1.lat * Math.PI / 180;
        const φ2 = point2.lat * Math.PI / 180;
        const Δφ = (point2.lat - point1.lat) * Math.PI / 180;
        const Δλ = (point2.lng - point1.lng) * Math.PI / 180;

        const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
                Math.cos(φ1) * Math.cos(φ2) *
                Math.sin(Δλ/2) * Math.sin(Δλ/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

        return R * c; // Distance in meters
    }

    function startHunt() {
        // Load game locations
        if (typeof locations !== 'undefined' && Array.isArray(locations)) {
            gameLocations = locations;
            
            // Add markers to the map
            for (const location of gameLocations) {
                if (location && typeof location.lat === 'number' && typeof location.lng === 'number') {
                    const marker = L.marker([location.lat, location.lng], {
                        icon: L.divIcon({
                            className: 'location-marker',
                            html: '<div class="location-marker-icon"></div>',
                            iconSize: [30, 30],
                            iconAnchor: [15, 15]
                        })
                    });
                    
                    marker.bindPopup(`<b>${location.name}</b><br>${location.city}`);
                    markerClusterGroup.addLayer(marker);
                }
            }
            
            console.log(`Loaded ${gameLocations.length} locations`);
            updateDistanceBox();
        } else {
            console.error("Locations data not available");
        }
    }

    // Initialize the map when the page loads
    window.addEventListener('load', initMap);
    </script>
</body>
</html>
