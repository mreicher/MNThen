<!DOCTYPE html>
<html lang="en">
<head> 
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Minnesota Then | Museum Without Walls</title>
    <link rel="shortcut icon" type="image/x-icon" href="https://www.mnthen.com/images/mnthenfav.ico">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css">
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css" />

    <link rel="stylesheet" href="https://www.mnthen.com/css/mainmap.css">
    <link rel="stylesheet" href="https://www.mnthen.com/css/mnthen_main_map2.css">

    <style>
        #map {
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
        }
    </style>
</head>
<body>
    <!-- Map -->
    <div id="map"></div>
    <div id="distanceBox">Initializing...</div>

    <!-- Location Hunt Container -->
    <div class="lochunt-container">
        <img id="locationImage" src="/placeholder.svg" alt="Location Image">
        <div class="lochunt-content">
            <div class="lochunt-info">
                <h2 id="locationTitle" class="mb-2 text-primary"></h2>
                <p id="locationCity" class="text-muted mb-1"></p>
                <p id="locationCreator" class="text-muted mb-3"></p>
            </div>
            <div class="audio-player">
                <div class="audio-progress">
                    <div class="progress">
                        <div id="progressBar" class="progress-bar" role="progressbar" style="width: 0%"></div>
                    </div>
                </div>
                <div class="audio-time">
                    <span id="currentTime">0:00</span>
                    <span id="duration">0:00</span>
                </div>
                <div class="audio-controls">
                    <button id="rewindBtn" class="audio-button"><i class="fas fa-backward"></i></button>
                    <button id="playPauseBtn" class="audio-button"><i class="fas fa-play"></i></button>
                    <button id="forwardBtn" class="audio-button"><i class="fas fa-forward"></i></button>
                </div>
                <audio id="locationAudio" src="/placeholder.svg"></audio>
            </div>
        </div>
    </div>

    <!-- Additional Info Container -->
    <div class="additional-info-container">
        <h3 class="mb-3 text-primary text-center">Did You Know?</h3>
        <p id="additionalInfo" class="mb-3 fs-6"></p>
        <div class="d-flex justify-content-center">
            <button id="continueButton" class="btn btn-primary">Continue</button>
        </div>
    </div>
    
    <!-- Map Buttons -->
    <div class="map-buttons">
        <button id="recenterButton" class="map-button"><i class="fas fa-crosshairs"></i></button>
        <button id="returnButton" class="map-button"><i class="fas fa-sign-out-alt"></i></button>
        <button id="tipsButton" class="map-button"><i class="fas fa-question-circle"></i></button>
    </div>

    <!-- Navigation Tips -->
    <div class="navigation-tips">
        <button class="close-button">&times;</button>
        <h3 style="color: darkblue; text-align: center;">Navigation Tips</h3>
        <ul>
            <li>Use the map to navigate to the marked locations.</li>
            <li>Tap the recenter button to focus on your current position.</li>
            <li>The distance box shows how far you are from the closest location.</li>
            <li>When you're within 20 feet of a location, you'll be able to interact with it.</li>
            <li>Listen to the audio information for each location.</li>
            <li>After the audio, you'll see additional information about the location.</li>
        </ul>
    </div>

    <!-- Summary Modal -->
    <div id="summaryModal" class="modal">
        <div class="modal-content">
            <p id="summaryContent"></p>
        </div>
    </div>

<script src="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
<script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"></script>
<script src="/locations_test.js?v=1.0.4"></script>

<script>
// Global variables
let map, userMarker, markerClusterGroup;
let tracking;
let currentLocationIndex = 0;
let visitedLocations = [];
let gameLocations = [];
let isLocationHuntVisible = false;
let watchId = null;
let geolocationAbortController = null;
let positionUpdateCount = 0;
let lastPosition = null;
let positionBuffer = [];
let filteredPosition = null;
let followUser = true;
let locationCooldowns = {};
let lastVisitedLocationId = null;
let lastKnownPosition = null;
let isTransitioning = false;
let lastVelocity = { lat: 0, lng: 0 };
let isMapInteracting = false;
let isStationary = false;
let stationaryStartTime = null;
let stationaryCheckTimeout = null;
let lastUpdateTime = null;
let lastUpdateTimestamp = null;
let stationaryBuffer = [];
let stationaryPosition = null;
let stationaryCount = 0;
let lastSmoothedPosition = null;
let lastHiddenTime = 0;
let retryCount = 0;
let inactivityTimer;
let animationFrameId = null;    
let isAnimationRunning = false;
let userPosition = null;
let lastPositionLogTime = 0;
let lastUserPosition;
let velocity = { lat: 0, lng: 0 };
let stationaryPositionHistory = [];
let lastStationaryPosition = null;
let stationaryPositionLocked = false;
let suddenMovementCount = 0;
let isJumpDetected = false;
    
// State tracking for proximity and speed-based zoom
let proximityState = {
    isNearLocation: false,
    lastZoomChangeTime: 0,
    lastProximityCheck: 0,
    zoomTransitionInProgress: false
};
    
let speedZoomState = {
    lowSpeedStartTime: null,
    isInTransit: false,
    lastSignificantMove: Date.now(),
    destinationArrivalTime: null,
    previousZoom: null,
    lastSpeedBasedZoom: 17,
    lastZoomUpdateTime: 0
};

// Configuration constants
const DISTANCE_THRESHOLD = 20; // feet
const MAX_BUFFER_SIZE = 5;
const MAX_ACCEPTABLE_ACCURACY = 39; // meters
const BACKGROUND_THRESHOLD = 25000; // ms
const INACTIVITY_TIMEOUT = 29000; // ms
const UPDATE_INTERVAL = 50; // ms
const MICRO_MOVEMENT_THRESHOLD = 0.3; // meters
const STATIONARY_ACCURACY_MULTIPLIER = 1.1;
const MAX_SPEED = 50; // m/s
const MIN_DISTANCE_THRESHOLD = 2; // meters
const VELOCITY_DECAY = 0.8;
const BEARING_WEIGHT = 0.3;
const SMOOTHING_FACTOR = 0.3;
const EXTENDED_DISTANCE_THRESHOLD = 100; // meters
const STATIONARY_THRESHOLD = 2;
const STATIONARY_TIME_THRESHOLD = 5000; // ms
const STATIONARY_CHECK_INTERVAL = 2500; // ms
const STATIONARY_SMOOTHING = 0.95;
const STATIONARY_BUFFER_SIZE = 10;
const STATIONARY_ACCURACY_WEIGHT = 0.7;
const STATIONARY_THRESHOLDB = 3;
const MAX_ALPHA = 0.2;
const MIN_ALPHA = 0.025;
const MAX_RETRIES = 3;
const RETRY_DELAY = 1000; // ms
const EDGE_THRESHOLD_PERCENTAGE = 0.25;
const STRICT_EDGE_THRESHOLD_PERCENTAGE = 0.15;
const CRITICAL_EDGE_THRESHOLD_PERCENTAGE = 0.07;
const MAX_ACCURACY_THRESHOLD = 2500;
const TARGET_ACCURACY_THRESHOLD = 100;
const MIN_RECENTER_INTERVAL = 2000; // ms
const FORCE_UPDATE_INTERVAL = 5000; // ms

const positionHistory = {
    previous: null,
    current: null,
    maxHistory: 5,
    history: []
};
    
// Speed-based zoom thresholds
const SPEED_ZOOM_THRESHOLDS = [
    { speed: 35, zoom: 14 }, // Highway speeds
    { speed: 25, zoom: 15 }, // Major roads
    { speed: 15, zoom: 16 }, // Urban driving
    { speed: 0, zoom: 17 }   // Walking speed or stationary
];
    
// Proximity zoom constants - optimized for better performance
const PROXIMITY_THRESHOLD = 50; // 50 feet trigger
const PROXIMITY_EXIT_THRESHOLD = 65; // 65 feet to exit (hysteresis)
const BASE_ZOOM = 17;           // Default zoom level 
const CLOSE_ZOOM = 18;          // Zoom when within threshold
const ZOOM_COOLDOWN = 2000;     // 2 seconds between zoom changes
const PROXIMITY_CHECK_INTERVAL = 1000; // Check proximity every 1 second
    
// Kalman filter constants
const BASE_PROCESS_NOISE = 0.01; // Base process noise for Kalman filter
const MAP_UPDATE_INTERVAL = 500; // Milliseconds between map view updates
const POSITION_UPDATE_THRESHOLD = 20; // Meters of movement that triggers a map update
let lastMapUpdateTime = 0; // Track when we last updated the map view

// Geolocation options
let geolocationOptions = {
    enableHighAccuracy: true,
    maximumAge: 0,
    timeout: 10000
};

// Define which geolocation API we're using
let usingGeolocationSensorAPI = false;

// Check if the Geolocation Sensor API is available
if (typeof navigator.permissions !== 'undefined' && 
    typeof navigator.permissions.query === 'function' && 
    typeof AbortController !== 'undefined') {
    try {
        // This is just a check - we'll set the actual value when we initialize geolocation
        navigator.permissions.query({ name: 'geolocation' })
            .then(result => {
                if (result.state !== 'denied') {
                    console.log("Modern geolocation APIs available");
                    // We'll set usingGeolocationSensorAPI = true when we actually use it
                }
            })
            .catch(error => {
                console.log("Using standard Geolocation API due to error:", error);
            });
    } catch (error) {
        console.log("Using standard Geolocation API due to exception:", error);
    }
}
        
// Initialize map and core functionality
function initMap() {
    // Check if map already exists to prevent double initialization
    if (map) {
        console.log("Map already initialized");
        return;
    }
        
    // Create map with optimized settings
    map = L.map('map', {
        zoomControl: false,
        attributionControl: false,
        zoomSnap: 0.1,
        zoomDelta: 0.5,
        wheelDebounceTime: 100,
        tapTolerance: 15,
        bounceAtZoomLimits: false,
        preferCanvas: true,
        renderer: L.canvas()
    }).fitWorld();
        
    // Add tile layer with performance optimizations
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 18,
        attribution: 'Â© OpenStreetMap contributors',
        updateWhenIdle: true,
        updateWhenZooming: false,
        keepBuffer: 2
    }).addTo(map);
        
    // Initialize marker cluster group with custom styling
    markerClusterGroup = L.markerClusterGroup({
        showCoverageOnHover: false,
        zoomToBoundsOnClick: true,
        spiderfyOnMaxZoom: true,
        animate: true,
        animateAddingMarkers: true,
        chunkedLoading: true,
        chunkProgress: updateLoadingStatus,
        maxClusterRadius: function(zoom) {
            return zoom > 16 ? 40 : 80;
        },
        iconCreateFunction: function(cluster) {
            return L.divIcon({
                html: '<div><span>' + cluster.getChildCount() + '</span></div>',
                className: 'marker-cluster-custom',
                iconSize: L.point(40, 40)
            });
        }
    });
    map.addLayer(markerClusterGroup);
        
    // Create user location marker
    const userIcon = L.divIcon({
        className: 'user-marker',
        html: '<div class="user-marker-icon"></div>',
        iconSize: [20, 20],
        iconAnchor: [10, 10]
    });
    userMarker = L.marker([0, 0], { icon: userIcon, zIndexOffset: 1000 }).addTo(map);
        
    showLoadingMessage();
        
    // Initialize geolocation with fallback
    if ("geolocation" in navigator) {
        const options = {
            enableHighAccuracy: true,
            timeout: 45000,
            maximumAge: 0
        };
            
        // Try to get initial position with retry
        navigator.geolocation.getCurrentPosition(
            initializeUserLocation,
            (error) => {
                // On error, try one more time before falling back
                navigator.geolocation.getCurrentPosition(
                    initializeUserLocation,
                    handleLocationError,
                    options
                );
            },
            options
        );
    } else {
        showPopup("Geolocation Error", "Geolocation is not supported by your browser");
        map.setView([44.9778, -93.2650], 17); // Default to Minneapolis
        hideLoadingMessage();
    }
        
    // Set up document event listeners
    document.addEventListener('visibilitychange', handleVisibilityChange);
        
    // Add all map-specific event listeners
    addMapEventListeners();
        
    // Enable touch interactions
    map.touchZoom.enable();
    map.doubleClickZoom.enable();
}

// Add map event listeners
function addMapEventListeners() {
    // Map interaction events
    map.on('dragstart', () => {
        isMapInteracting = true;
        followUser = false;
    });
        
    map.on('zoomstart', () => {
        isMapInteracting = true;
    });
        
    map.on('dragend zoomend', () => {
        setTimeout(() => {
            isMapInteracting = false;
        }, 200);
    });
        
    // Button event listeners
    document.getElementById('recenterButton').addEventListener('click', () => {
        if (userMarker && userMarker.getLatLng()) {
            map.setView(userMarker.getLatLng(), map.getZoom(), {
                animate: true,
                duration: 0.5
            });
            followUser = true;
            isMapInteracting = false;
        }
    });
        
    document.getElementById('returnButton').addEventListener('click', returnToIndex);
        
    document.getElementById('tipsButton').addEventListener('click', () => {
        document.querySelector('.navigation-tips').style.display = 'block';
    });
        
    document.querySelector('.navigation-tips .close-button').addEventListener('click', () => {
        document.querySelector('.navigation-tips').style.display = 'none';
    });
}

function handleError(error) {
    console.error("Geolocation error:", error);
        
    let errorMessage;
    switch(error.code) {
        case error.PERMISSION_DENIED:
            errorMessage = "Location permission denied by user.";
            break;
        case error.POSITION_UNAVAILABLE:
            errorMessage = "Location information is unavailable.";
            break;
        case error.TIMEOUT:
            errorMessage = "Location request timed out.";
            break;
        case error.UNKNOWN_ERROR:
            errorMessage = "An unknown error occurred.";
            break;
    }
        
    // Assuming showError is defined elsewhere in your code
    showError(errorMessage);
        
    // If this is a critical error, you might want to try the fallback
    if (error.code === error.POSITION_UNAVAILABLE || error.code === error.TIMEOUT) {
        usingGeolocationSensorAPI = false;
        initFallbackGeolocation();
    }
}
        
/**
 * Initialize geolocation services with fallbacks and error handling
 */
function initGeolocation() {
    console.log("Initializing geolocation services...");
        
    // Check if geolocation is available at all
    if (!navigator.geolocation) {
        showError("Geolocation is not supported by your browser");
        return;
    }
        
    // Clear any existing watch
    clearGeolocationWatch();
        
    // Try to use the modern Geolocation API if available
    if (typeof navigator.permissions !== 'undefined' && 
        typeof navigator.permissions.query === 'function' && 
        typeof AbortController !== 'undefined') {
            
        navigator.permissions.query({ name: 'geolocation' })
            .then(permissionStatus => {
                console.log(`Geolocation permission status: ${permissionStatus.state}`);
                
                if (permissionStatus.state === 'denied') {
                    showError("Location permission denied. Please enable location services.");
                    usingGeolocationSensorAPI = false;
                    return;
                }
                
                // Set up permission change listener
                permissionStatus.addEventListener('change', () => {
                    console.log(`Geolocation permission changed to: ${permissionStatus.state}`);
                    if (permissionStatus.state === 'denied') {
                        showError("Location permission was denied");
                        clearGeolocationWatch();
                    } else if (permissionStatus.state === 'granted' && !watchId) {
                        // Restart geolocation if permission was granted again
                        initGeolocation();
                    }
                });
                
                try {
                    // Try to use the modern API with AbortController for better control
                    geolocationAbortController = new AbortController();
                    const signal = geolocationAbortController.signal;
                        
                    usingGeolocationSensorAPI = true;
                    console.log("Using enhanced Geolocation API with AbortController");
                        
                    watchId = navigator.geolocation.watchPosition(
                        handleSuccess,
                        handleError,
                        {
                            ...geolocationOptions,
                            signal
                        }
                    );
                        
                    console.log(`Geolocation watch started with ID: ${watchId}`);
                } catch (error) {
                    console.error("Error initializing enhanced Geolocation:", error);
                    usingGeolocationSensorAPI = false;
                    initFallbackGeolocation();
                }
            })
            .catch(error => {
                console.error("Error querying geolocation permission:", error);
                usingGeolocationSensorAPI = false;
                initFallbackGeolocation();
            });
    } else {
        console.log("Modern geolocation features not available, using standard API");
        usingGeolocationSensorAPI = false;
        initFallbackGeolocation();
    }
        
    // Set up periodic background updates to ensure we keep getting position updates
    setupBackgroundUpdates();
}

/**
 * Initialize standard geolocation API as fallback
 */
function initFallbackGeolocation() {
    console.log("Initializing standard Geolocation API");
        
    try {
        watchId = navigator.geolocation.watchPosition(
            handleSuccess,
            handleError,
            geolocationOptions
        );
            
        console.log(`Standard geolocation watch started with ID: ${watchId}`);
    } catch (error) {
        console.error("Error initializing standard Geolocation:", error);
        showError("Failed to initialize location services");
    }
}

/**
 * Clear any active geolocation watch
 */
function clearGeolocationWatch() {
    if (watchId !== null) {
        console.log(`Clearing geolocation watch ID: ${watchId}`);
        navigator.geolocation.clearWatch(watchId);
        watchId = null;
    }
        
    if (geolocationAbortController !== null) {
        console.log("Aborting geolocation controller");
        geolocationAbortController.abort();
        geolocationAbortController = null;
    }
}

/**
 * Set up periodic background updates to ensure continuous position tracking
 */
function setupBackgroundUpdates() {
    // Check every 30 seconds if we're still getting position updates
    const checkInterval = setInterval(() => {
        const now = Date.now();
            
        // If we haven't received a position update in 60 seconds, try to restart
        if (lastKnownPosition && (now - lastKnownPosition.timestamp > 60000)) {
            console.log("No position updates received recently, restarting geolocation");
            initGeolocation(); // Restart geolocation services
        }
            
        // Perform a manual position update in the background
        updateUserLocation(true);
    }, 30000);
        
    // Clean up interval when page is unloaded
    window.addEventListener('beforeunload', () => {
        clearInterval(checkInterval);
        clearGeolocationWatch();
    });
}
        
function updateLoadingStatus(processed, total, elapsed) {
    if (processed === total) {
        // All markers loaded
        console.log(`Loaded ${processed} markers in ${elapsed.toFixed(2)}ms`);
    }
}

// Global variable to prevent premature dismissal
let loadingMessageMinDisplayTime = 0;

function showLoadingMessage() {
    const existingMessage = document.getElementById('loadingMessage');
    if (existingMessage) return;
        
    // Set the minimum display time to 8 seconds from now
    loadingMessageMinDisplayTime = Date.now() + 8000;
        
    // Create main container with background image
    const loadingMessage = document.createElement('div');
    loadingMessage.id = 'loadingMessage';
    loadingMessage.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        background-image: url('https://raw.githubusercontent.com/mreicher/MNThen/refs/heads/main/images/splash_screen.webp');
        background-size: cover;
        background-position: center;
        z-index: 1000;
        font-family: 'Segoe UI', 'Roboto', 'Arial', sans-serif;
        transition: opacity 0.5s ease;
    `;
        
    // Keep original content container
    const contentContainer = document.createElement('div');
    contentContainer.style.cssText = `
        display: flex;
        flex-direction: column;
        align-items: center;
        background-color: white;
        padding: clamp(20px, 5vw, 40px);
        border-radius: 16px;
        box-shadow: 0 15px 40px rgba(0, 0, 0, 0.25);
        width: clamp(280px, 85%, 500px);
        text-align: center;
    `;
        
    // Create image with same styling
    const logoImage = document.createElement('img');
    logoImage.src = 'https://mnthen.com/images/logo.webp';
    logoImage.style.cssText = `
        width: clamp(130px, 60%, 250px);
        height: auto;
        margin-bottom: clamp(15px, 4vw, 25px);
        border-radius: 8px;
        object-fit: contain;
    `;
        
    // Add the new "The Museum Without Walls" title
    const mainTitle = document.createElement('h1');
    mainTitle.style.cssText = `
        margin: 0 0 clamp(5px, 1.5vw, 10px) 0;
        font-size: clamp(19px, 4.5vw, 25px);
        font-weight: 600;
        color: #002855;
        text-align: center;
        line-height: 1.3;
        letter-spacing: -0.01em;
    `;
    mainTitle.textContent = 'The Museum Without Walls';
        
    // Update the tagline 
    const welcomeMessage = document.createElement('h2');
    welcomeMessage.style.cssText = `
        margin: 0 0 clamp(15px, 4vw, 25px) 0;
        font-size: clamp(16px, 3.5vw, 20px);
        font-weight: 500;
        color: #0066cc;
        text-align: center;
        line-height: 1.3;
        letter-spacing: -0.01em;
    `;
    welcomeMessage.textContent = 'Where Every Step Tells A Story';
        
    // Improved status text with original styling
    const statusText = document.createElement('p');
    statusText.id = 'loadingStatusText';
    statusText.style.cssText = `
        margin: 0 0 clamp(15px, 4vw, 25px) 0;
        font-size: clamp(14px, 4vw, 16px);
        font-weight: 400;
        text-align: center;
        color: #0066cc;
        line-height: 1.5;
    `;
    statusText.textContent = 'Location found, proceeding to stabilization...';
        
    // Create progress bar container with improved styling
    const progressContainer = document.createElement('div');
    progressContainer.style.cssText = `
        width: 100%;
        height: 6px;
        background-color: rgba(0, 51, 102, 0.1);
        border-radius: 8px;
        overflow: hidden;
        margin-top: 5px;
    `;
        
    // Improved progress bar with animation
    const progressBar = document.createElement('div');
    progressBar.id = 'loadingProgressBar';
    progressBar.style.cssText = `
        height: 100%;
        width: 0%;
        background: linear-gradient(90deg, #0066cc, #0099ff);
        border-radius: 8px;
        transition: width 0.2s ease-out;
        box-shadow: 0 0 8px rgba(0, 102, 204, 0.5);
    `;
        
    progressContainer.appendChild(progressBar);
        
    // Assemble and add to document
    contentContainer.appendChild(logoImage);
    contentContainer.appendChild(mainTitle);
    contentContainer.appendChild(welcomeMessage);
    contentContainer.appendChild(statusText);
    contentContainer.appendChild(progressContainer);
    loadingMessage.appendChild(contentContainer);
    document.body.appendChild(loadingMessage);
        
    // Set animation parameters
    const totalDuration = 10000;
    const updateInterval = 100;
    const steps = totalDuration / updateInterval;
    let progress = 0;
        
    // Text animations to improve perceived performance
    const animations = [
        "Initializing map data...",
        "Processing location coordinates...",
        "Preparing exhibit data...",
        "Calibrating view perspective...",
        "Loading nearby points of interest...",
        "Finalizing your experience..."
    ];
        
    // Animate progress bar over 10 seconds with status text updates
    const progressInterval = setInterval(() => {
        progress += (100 / steps);
            
        if (progressBar) {
            progressBar.style.width = `${Math.min(progress, 100)}%`;
        }
            
        // Update status text periodically
        if (statusText) {
            const animationIndex = Math.min(
                Math.floor(progress / (100 / animations.length)),
                animations.length - 1
            );
            statusText.textContent = animations[animationIndex];
        }
            
        if (progress >= 100) {
            clearInterval(progressInterval);
            tryHideLoadingMessage();
        }
    }, updateInterval);
        
    // Store the interval ID
    loadingMessage.dataset.progressInterval = progressInterval;
}

function tryHideLoadingMessage() {
    // Only fade out if minimum display time has been reached
    if (Date.now() >= loadingMessageMinDisplayTime) {
        fadeOutLoadingMessage();
    } else {
        // Schedule another check for when the minimum time is reached
        const timeRemaining = loadingMessageMinDisplayTime - Date.now();
        setTimeout(fadeOutLoadingMessage, timeRemaining + 100); // Add a small buffer
    }
}

function fadeOutLoadingMessage() {
    const loadingMessage = document.getElementById('loadingMessage');
    if (!loadingMessage) return;
        
    // Clear any ongoing timers
    if (loadingMessage.dataset.progressInterval) {
        clearInterval(parseInt(loadingMessage.dataset.progressInterval));
    }
        
    // Complete progress bar if not already complete
    const progressBar = document.getElementById('loadingProgressBar');
    if (progressBar) {
        progressBar.style.width = '100%';
    }
        
    // Fade out and remove
    loadingMessage.style.opacity = '0';
    setTimeout(() => {
        if (loadingMessage && loadingMessage.parentNode) {
            loadingMessage.parentNode.removeChild(loadingMessage);
        }
    }, 500); // 500ms fade-out transition
}

// Public API function to hide loading message (respects minimum display time)
function hideLoadingMessage() {
    tryHideLoadingMessage();
}

function initializeUserLocation(position) {
    console.log("Initial position data:", JSON.stringify(position));

    if (!position || !position.coords) {
        console.error("Invalid initial position object");
        handleLocationError(new Error("Invalid initial position"));
        return;
    }

    const { latitude: userLat, longitude: userLng, accuracy } = position.coords;

    if (isNaN(userLat) || isNaN(userLng)) {
        console.error("Invalid initial coordinates:", { userLat, userLng });
        handleLocationError(new Error("Invalid initial coordinates"));
        return;
    }

    console.log("Valid initial position:", { userLat, userLng, accuracy });

    try {
        userMarker.setLatLng([userLat, userLng]);
        map.setView([userLat, userLng], 19);
            
        // Initialize Kalman filter with first position
        kalmanFilter.reset({
            lat: userLat,
            lng: userLng,
            accuracy: accuracy || 20
        });
            
        hideLoadingMessage();
        startPositionUpdates();
        startHunt();
            
        // Pulse the distance box to draw attention
        const distanceBox = document.getElementById('distanceBox');
        distanceBox.classList.add('pulse');
        setTimeout(() => distanceBox.classList.remove('pulse'), 3000);
    } catch (error) {
        console.error("Error setting initial user location:", error);
        handleLocationError(error);
    }
}

function startPositionUpdates() {
    // Store the watch ID to allow stopping if needed
    const watchId = navigator.geolocation.watchPosition(
        handlePositionUpdate,
        handleLocationError,
        {
            enableHighAccuracy: true,
            maximumAge: 1000,
            timeout: 10000
        }
    );
        
    // Optional: Store watchId for later use (to stop tracking)
    window.positionWatchId = watchId;
        
    // Add error recovery mechanism
    window.addEventListener('online', () => {
        // If connection was lost and restored, restart position tracking
        if (window.positionWatchId) {
            navigator.geolocation.clearWatch(window.positionWatchId);
            window.positionWatchId = navigator.geolocation.watchPosition(
                handlePositionUpdate,
                handleLocationError,
                {
                    enableHighAccuracy: true,
                    maximumAge: 1000,
                    timeout: 10000
                }
            );
        }
    });
        
    // Start periodic proximity checks
    startProximityChecks();
        
    // Return the watchId for external use
    return watchId;
}

function startProximityChecks() {
    // Clear any existing interval
    if (window.proximityCheckInterval) {
        clearInterval(window.proximityCheckInterval);
    }
        
    // Set up periodic proximity checks
    window.proximityCheckInterval = setInterval(() => {
        if (!isMapInteracting && followUser) {
            checkProximityForZoom();
        }
    }, PROXIMITY_CHECK_INTERVAL);
}

function handlePositionUpdate(position) {
    // Validate position data
    if (!position || !position.coords || 
        isNaN(position.coords.latitude) || 
        isNaN(position.coords.longitude)) {
        console.warn("Invalid position data received");
        return;
    }
        
    // Add timestamp validation to prevent processing outdated positions
    const positionTimestamp = position.timestamp || new Date().getTime();
    const currentTime = new Date().getTime();
    const maxAgeMs = 30000; // 30 seconds
        
    if (currentTime - positionTimestamp > maxAgeMs) {
        console.warn("Position data too old, ignoring");
        return;
    }
        
    // Update accuracy information
    const accuracy = position.coords.accuracy || 0;
    window.lastPositionAccuracy = accuracy;
        
    // Store last valid position for recovery purposes
    window.lastValidPosition = {
        lat: position.coords.latitude,
        lng: position.coords.longitude,
        timestamp: positionTimestamp,
        accuracy: accuracy
    };
        
    // Process valid position update (keeping original functionality)
    updateUserLocation(position);
}
        
function handleVisibilityChange() {
    if (document.hidden) {
        lastHiddenTime = Date.now();
        lastKnownPosition = userMarker ? userMarker.getLatLng() : null;
    } else {
        const hiddenDuration = Date.now() - lastHiddenTime;
        if (hiddenDuration > BACKGROUND_THRESHOLD) {
            updateLocationAfterBackground();
        } else {
            // Just refresh the map size
            map.invalidateSize();
        }
    }
    resetInactivityTimer();
}

// Rewritten startAnimationLoop function with better error handling
function startAnimationLoop() {
    // Prevent multiple animation loops
    if (isAnimationRunning) {
        console.log("Animation loop already running, not starting another");
        return;
    }
        
    // Cancel any existing animation frame
    if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
    }
        
    console.log("Starting animation loop");
    isAnimationRunning = true;
        
    // Define the animation function
    function animate() {
        try {
            // Call updateMap if it exists
            if (typeof updateMap === 'function') {
                updateMap();
            } else {
                console.error("updateMap function is not defined");
            }
                
            // Request the next frame
            animationFrameId = requestAnimationFrame(animate);
        } catch (error) {
            console.error("Error in animation loop:", error);
            // Attempt to recover from error
            isAnimationRunning = false;
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            // Try to restart after a short delay
            setTimeout(() => {
                startAnimationLoop();
            }, 1000);
        }
    }
        
    // Start the animation
    animate();
}

// Add a function to safely stop the animation loop
function stopAnimationLoop() {
    if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
    }
    isAnimationRunning = false;
    console.log("Animation loop stopped");
}

function updateMap() {
    // Comprehensive initialization checks
    if (!map) {
        console.warn("Map not initialized yet");
        return;
    }
        
    // Detailed position validation
    if (!userPosition || !userPosition.coords || 
        isNaN(userPosition.coords.latitude) || 
        isNaN(userPosition.coords.longitude)) {
        console.warn("No valid user position available");
        return;
    }
        
    // Marker creation with immediate return
    if (!userMarker) {
        console.log("Creating user marker");
        createUserMarker();
        return; // Wait for next update cycle
    }
        
    try {
        // Safely update marker position
        userMarker.setLatLng([
            userPosition.coords.latitude,
            userPosition.coords.longitude
        ]);
            
        // Optional: Add smooth transition effects here
        // map.panTo(userMarker.getLatLng(), {animate: true, duration: 0.5});
            
    } catch (error) {
        console.error("Error updating marker position:", error);
            
        // Optional recovery: Attempt to recreate marker on failure
        if (error.message.includes("invalid LatLng")) {
            console.log("Attempting marker recovery...");
            createUserMarker();
        }
    }
}
        
function updateLocationAfterBackground() {
    if (!("geolocation" in navigator)) {
        console.warn("Geolocation is not available");
        return;
    }
        
    // First try with cached position to get quick response
    const quickOptions = {
        enableHighAccuracy: false,
        timeout: 5000,
        maximumAge: 60000,  // Use a position from last minute if available
    };
        
    // Then try with high accuracy
    const accurateOptions = {
        enableHighAccuracy: true,
        timeout: 15000,
        maximumAge: 30000,
    };
        
    // Final fallback with very permissive settings
    const fallbackOptions = {
        enableHighAccuracy: false,
        timeout: 25000,
        maximumAge: 120000, // Accept positions up to 2 minutes old
    };
        
    const handleError = (error, stage) => {
        console.error(`Error getting location during ${stage} attempt:`, error);
            
        switch (error.code) {
            case error.PERMISSION_DENIED:
                console.warn("User denied geolocation access");
                break;
                    
            case error.POSITION_UNAVAILABLE:
                if (stage === "quick") {
                    console.log("Quick position unavailable, trying accurate position...");
                    navigator.geolocation.getCurrentPosition(
                        handleSuccess,
                        (err) => handleError(err, "accurate"),
                        accurateOptions
                    );
                } else if (stage === "accurate") {
                    console.log("Accurate position unavailable, trying fallback...");
                    navigator.geolocation.getCurrentPosition(
                        handleSuccess,
                        (err) => handleError(err, "fallback"),
                        fallbackOptions
                    );
                } else {
                    console.warn("All position attempts failed - location unavailable");
                }
                break;
                    
            case error.TIMEOUT:
                if (stage === "quick") {
                    console.log("Quick position timed out, trying accurate position...");
                    navigator.geolocation.getCurrentPosition(
                        handleSuccess,
                        (err) => handleError(err, "accurate"),
                        accurateOptions
                    );
                } else if (stage === "accurate") {
                    console.log("Accurate position timed out, trying fallback...");
                    navigator.geolocation.getCurrentPosition(
                        handleSuccess,
                        (err) => handleError(err, "fallback"),
                        fallbackOptions
                    );
                } else {
                    console.warn("All position attempts timed out");
                }
                break;
                    
            default:
                if (stage !== "fallback") {
                    console.log("Unknown error, trying fallback options...");
                    navigator.geolocation.getCurrentPosition(
                        handleSuccess,
                        (err) => handleError(err, "fallback"),
                        fallbackOptions
                    );
                } else {
                    console.warn("All position attempts failed with unknown error");
                }
        }
    };

    // Start with quick attempt to get position
    navigator.geolocation.getCurrentPosition(
        handleSuccess,
        (error) => handleError(error, "quick"),
        quickOptions
    );
}

// Kalman filter implementation for position smoothing
const kalmanFilter = {
    x: { estimate: 0, error: 1 },
    y: { estimate: 0, error: 1 },
    q: 0.015, // Process noise
    r: 1,     // Measurement noise
        
    update: function(measurement) {
        // Initialize if first measurement
        if (this.x.estimate === 0 && this.y.estimate === 0) {
            this.x.estimate = measurement.lng;
            this.y.estimate = measurement.lat;
            return measurement;
        }
            
        // X coordinate (longitude)
        const predX = this.x.estimate;
        const predErrX = this.x.error + this.q;
        const gainX = predErrX / (predErrX + this.r);
        this.x.estimate = predX + gainX * (measurement.lng - predX);
        this.x.error = (1 - gainX) * predErrX;
            
        // Y coordinate (latitude)
        const predY = this.y.estimate;
        const predErrY = this.y.error + this.q;
        const gainY = predErrY / (predErrY + this.r);
        this.y.estimate = predY + gainY * (measurement.lat - predY);
        this.y.error = (1 - gainY) * predErrY;
            
        return {
            lat: this.y.estimate,
            lng: this.x.estimate,
            accuracy: measurement.accuracy,
            timestamp: measurement.timestamp,
            heading: measurement.heading,
            speedMPS: measurement.speedMPS
        };
    },
        
    reset: function(measurement) {
        this.x.estimate = measurement.lng;
        this.y.estimate = measurement.lat;
        this.x.error = 1;
        this.y.error = 1;
    }
};

function updatePositionBuffer(position) {
    // Add new position to buffer
    positionBuffer.push({
        lat: position.lat,
        lng: position.lng,
        accuracy: position.accuracy,
        timestamp: position.timestamp,
        heading: position.heading,
        speedMPS: position.speedMPS
    });

    // Remove old positions if buffer exceeds maxSize
    while (positionBuffer.length > MAX_BUFFER_SIZE) {
        positionBuffer.shift();
    }
}

function calculateWeightedPosition(positions, smoothingFactor = 0.8) {
    if (!Array.isArray(positions) || positions.length === 0) {
        return null;
    }

    // Filter out invalid positions
    const validPositions = positions.filter(pos => 
        pos && typeof pos.lat === 'number' && typeof pos.lng === 'number' && 
        !isNaN(pos.lat) && !isNaN(pos.lng)
    );

    if (validPositions.length === 0) {
        return null;
    }

    let sumLat = 0, sumLng = 0, totalWeight = 0;

    for (let i = 0; i < validPositions.length; i++) {
        const position = validPositions[i];
        const weight = Math.pow(smoothingFactor, validPositions.length - i - 1);
        sumLat += position.lat * weight;
        sumLng += position.lng * weight;
        totalWeight += weight;
    }

    const result = {
        lat: sumLat / totalWeight,
        lng: sumLng / totalWeight,
        accuracy: Math.min(...validPositions.map(p => p.accuracy || 20)),
        timestamp: validPositions[validPositions.length - 1].timestamp,
        heading: validPositions[validPositions.length - 1].heading,
        speedMPS: validPositions[validPositions.length - 1].speedMPS
    };

    return result;
}

/**
 * Handle successful position acquisition
 */
function handleSuccess(position) {
    try {
        positionUpdateCount++;
            
        // Process the position data
        const rawPosition = {
            lat: position.coords.latitude,
            lng: position.coords.longitude,
            accuracy: position.coords.accuracy,
            heading: position.coords.heading,
            timestamp: position.timestamp,
            speedMPS: position.coords.speed || 0
        };
            
        // Check for valid coordinates
        if (isNaN(rawPosition.lat) || isNaN(rawPosition.lng)) {
            console.warn("Invalid coordinates:", { lat: rawPosition.lat, lng: rawPosition.lng });
            return;
        }
            
        // Update last known position timestamp
        lastKnownPosition = {
            ...rawPosition,
            timestamp: Date.now()
        };
            
        // Process position (apply filters, etc.)
        processPosition(rawPosition);
            
        // Start animation loop if needed
        if (!isAnimationRunning) {
            startAnimationLoop();
        }
            
        // Update UI to show we're receiving position updates
        updatePositionStatus("active");
            
        // Reset tracking state if this is a background update
        const isBackgroundUpdate = arguments.length > 1 && arguments[1] === true;
        if (isBackgroundUpdate) {
            // Reset position tracking state
            lastPosition = null;
            positionBuffer = [];
            velocity = { lat: 0, lng: 0 };
            lastVelocity = { lat: 0, lng: 0 };
            isStationary = false;
            stationaryStartTime = null;
            stationaryCount = 0;
            stationaryPositionHistory = [];
            lastStationaryPosition = null;
            stationaryPositionLocked = false;
            positionHistory = [];
            suddenMovementCount = 0;
            isJumpDetected = false;
                
            // Reset Kalman filter if available
            if (kalmanFilter && typeof kalmanFilter.reset === 'function') {
                kalmanFilter.reset({
                    lat: rawPosition.lat,
                    lng: rawPosition.lng,
                    accuracy: rawPosition.accuracy,
                    heading: position.coords.heading || 0,
                    timestamp: Date.now(),
                });
            }
                
            // Enable user following
            followUser = true;
            map.invalidateSize();
            updateDistanceBox();
        }
            
        // Log occasional debug info (every 10 updates)
        if (positionUpdateCount % 10 === 0) {
            console.log(`Position update #${positionUpdateCount}:`, 
                `Lat: ${rawPosition.lat.toFixed(6)}, ` +
                `Lng: ${rawPosition.lng.toFixed(6)}, ` +
                `Accuracy: ${rawPosition.accuracy.toFixed(1)}m`);
        }
    } catch (error) {
        console.error("Error in handleSuccess:", error);
    }
}

// Define the missing function
function checkProximityToPoints() {
    // Exit early if user position isn't set
    if (!userPosition) return;
        
    // Assuming you have an array of points of interest
    const pointsOfInterest = window.pointsOfInterest || [];
        
    // Check distance to each point
    pointsOfInterest.forEach(point => {
        // Calculate distance (using Haversine formula for GPS coordinates)
        const distance = calculateDistance(userPosition, point.position);
            
        // If within threshold distance
        if (distance < (point.proximityThreshold || 50)) { // Default 50 meters
            // Trigger proximity event if not already triggered
            if (!point.inProximity) {
                point.inProximity = true;
                triggerProximityEvent(point);
            }
        } else if (point.inProximity) {
            // Reset proximity flag when moving away
            point.inProximity = false;
        }
    });
}

// Enhanced proximity event trigger with validation
function triggerProximityEvent(point) {
    // Validate the point object
    if (!point || typeof point !== 'object') {
        console.error('Invalid point object received:', point);
        return false;
    }

    // Validate required point properties
    const requiredProps = ['latitude', 'longitude', 'name'];
    const missingProps = requiredProps.filter(prop => !(prop in point));
        
    if (missingProps.length > 0) {
        console.error('Point missing required properties:', missingProps.join(', '));
        return false;
    }

    // Validate coordinates
    if (isNaN(point.latitude) || isNaN(point.longitude)) {
        console.error('Invalid coordinates in point:', point);
        return false;
    }

    try {
        // Log proximity event
        console.log(`User is near point: ${point.name || 'Unnamed point'}`);
            
        // Dispatch custom event with timestamp
        const event = new CustomEvent('pointProximity', { 
            detail: { 
                point: point,
                timestamp: new Date().toISOString(),
                valid: true
            }
        });
            
        document.dispatchEvent(event);

        // Safely call point-specific callback
        if (typeof point.onEnterProximity === 'function') {
            try {
                point.onEnterProximity();
            } catch (callbackError) {
                console.error('Error in onEnterProximity callback:', callbackError);
            }
        }

        return true;
            
    } catch (eventError) {
        console.error('Error triggering proximity event:', eventError);
        return false;
    }
}     

function updateUserPositionOnMap(position) {
    // Validate input
    if (!position || !position.coords) {
        console.error("Invalid position data in updateUserPositionOnMap");
        return;
    }
        
    const { latitude, longitude } = position.coords;
        
    // Update existing marker position (assuming userMarker already exists)
    if (userMarker) {
        // Update marker position
        userMarker.setLatLng([latitude, longitude]);
            
        // Center map on user if following is enabled
        if (followUser && !isMapInteracting) {
            map.setView([latitude, longitude], map.getZoom(), {
                animate: true,
                duration: 0.5
            });
        }
    } else {
        console.warn("User marker doesn't exist yet. Make sure it's created before calling updateUserPositionOnMap");
    }
        
    // Update last known position
    lastKnownPosition = { lat: latitude, lng: longitude };
        
    return true;
}
        
//Processes and validates raw position data, applies filtering, and updates application state
function processPosition(rawPosition) {
    // Validate input structure
    if (!rawPosition || typeof rawPosition !== 'object') {
        console.error('Invalid position data structure:', rawPosition);
        return false;
    }

    // Normalize position format (handle both lat/lng and latitude/longitude)
    const normalizedPosition = {
        coords: {
            latitude: rawPosition.coords?.latitude ?? rawPosition.lat,
            longitude: rawPosition.coords?.longitude ?? rawPosition.lng,
            accuracy: rawPosition.coords?.accuracy ?? rawPosition.accuracy,
            heading: rawPosition.coords?.heading ?? rawPosition.heading,
            speed: rawPosition.coords?.speed ?? rawPosition.speed
        },
        timestamp: rawPosition.timestamp
    };

    // Validate required coordinate properties
    const requiredCoordProps = ['latitude', 'longitude', 'accuracy'];
    const missingProps = requiredCoordProps.filter(prop => {
        return !(prop in normalizedPosition.coords) || isNaN(normalizedPosition.coords[prop]);
    });

    if (missingProps.length > 0) {
        console.error('Position missing required coordinate properties:', missingProps.join(', '));
        return false;
    }

    // Validate coordinate ranges
    const { latitude, longitude, accuracy } = normalizedPosition.coords;
    if (Math.abs(latitude) > 90 || Math.abs(longitude) > 180 || accuracy <= 0) {
        console.error('Invalid coordinate ranges:', { latitude, longitude, accuracy });
        return false;
    }

    // Validate timestamp
    if (!normalizedPosition.timestamp || isNaN(normalizedPosition.timestamp)) {
        console.warn('Position missing valid timestamp, using current time');
        normalizedPosition.timestamp = Date.now();
    }

    try {
        // Apply position filtering/smoothing
        const filteredPosition = applyPositionFiltering(normalizedPosition);
            
        // Additional validation after filtering
        if (!filteredPosition || !filteredPosition.coords) {
            console.error('Position filtering returned invalid result');
            return false;
        }

        // Update application state
        userPosition = filteredPosition;
            
        // Update UI elements
        updateUserPositionOnMap(userPosition);
            
        // Check proximity (with error handling)
        try {
            checkProximityToPoints();
        } catch (proximityError) {
            console.error('Error in proximity check:', proximityError);
        }

        // Debug logging
        if (window.debugMode) {
            console.log('Position processed successfully:', {
                coords: {
                    lat: filteredPosition.coords.latitude.toFixed(6),
                    lng: filteredPosition.coords.longitude.toFixed(6),
                    accuracy: Math.round(filteredPosition.coords.accuracy)
                },
                timestamp: new Date(filteredPosition.timestamp).toISOString()
            });
        }

        return true;

    } catch (filterError) {
        console.error('Error processing position:', filterError);
        return false;
    }
}
        
// Helper function for position filtering (simple example)
// Enhanced position filtering with history tracking
function applyPositionFiltering(newPosition) {
    try {
        // Validate input
        if (!newPosition || !newPosition.coords) {
            throw new Error('Invalid position input');
        }

        // Store current position as previous before updating
        positionHistory.previous = positionHistory.current;
        positionHistory.current = {...newPosition};
            
        // Add to history (for more advanced filtering if needed)
        positionHistory.history.push({...newPosition});
        if (positionHistory.history.length > positionHistory.maxHistory) {
            positionHistory.history.shift();
        }

        // Simple smoothing example - adjust based on your needs
        if (positionHistory.previous) {
            // Apply weighted average (adjust weights as needed)
            const filteredCoords = {
                latitude: (positionHistory.previous.coords.latitude * 0.3 + 
                          newPosition.coords.latitude * 0.7),
                longitude: (positionHistory.previous.coords.longitude * 0.3 + 
                           newPosition.coords.longitude * 0.7),
                accuracy: Math.min(
                    positionHistory.previous.coords.accuracy,
                    newPosition.coords.accuracy
                ),
                heading: newPosition.coords.heading,
                speed: newPosition.coords.speed
            };

            return {
                coords: filteredCoords,
                timestamp: newPosition.timestamp
            };
        }

        // If no previous position, return current with slight accuracy buffer
        return {
            coords: {
                ...newPosition.coords,
                accuracy: newPosition.coords.accuracy * 1.1 // 10% accuracy buffer
            },
            timestamp: newPosition.timestamp
        };

    } catch (error) {
        console.error('Position filtering error:', error);
        return newPosition; // Fallback to unfiltered position
    }
}

/**
 * Update the UI to show position status
 */
function updatePositionStatus(status) {
    // Update UI elements to show status (active, inactive, error)
    const statusIndicator = document.getElementById('position-status');
    if (statusIndicator) {
        statusIndicator.className = `status-indicator ${status}`;
        statusIndicator.textContent = status === "active" ? "GPS Active" : 
                                     (status === "error" ? "GPS Error" : "GPS Inactive");
    }
}

/**
 * Show error message to user
 */
function showError(message) {
    console.error(message);
        
    // Display error in UI
    const errorElement = document.getElementById('error-message');
    if (errorElement) {
        errorElement.textContent = message;
        errorElement.style.display = 'block';
            
        // Hide after 5 seconds
        setTimeout(() => {
            errorElement.style.display = 'none';
        }, 5000);
    }
}
        
// OPTIMIZED: Completely rewritten proximity zoom function with better performance
function checkProximityForZoom() {
    // Ensure we have all required objects and values
    if (!userMarker || !map || !gameLocations || !Array.isArray(gameLocations) || gameLocations.length === 0) {
        return;
    }
        
    // Initialize proximityState if needed
    if (!proximityState) {
        proximityState = {
            lastProximityCheck: 0,
            lastZoomChangeTime: 0,
            isNearLocation: false,
            zoomTransitionInProgress: false
        };
    }
        
    // Rate limit checks
    const now = Date.now();
    if (now - (proximityState.lastProximityCheck || 0) < 500) {
        return;
    }
    proximityState.lastProximityCheck = now;
        
    // Don't run during user interactions or transitions
    if (isMapInteracting || proximityState.zoomTransitionInProgress) {
        return;
    }
        
    // Get and validate user position
    const userPos = userMarker.getLatLng();
    if (!userPos || typeof userPos.lat !== 'number' || typeof userPos.lng !== 'number') {
        return;
    }
        
    // Find closest location efficiently
    let closestDistance = Infinity;
        
    for (let i = 0; i < gameLocations.length; i++) {
        const loc = gameLocations[i];
        if (!loc || typeof loc.lat !== 'number' || typeof loc.lng !== 'number') {
            continue;
        }
            
        // Fast approximate distance check first
        const latDiff = userPos.lat - loc.lat;
        const lngDiff = userPos.lng - loc.lng;
        const quickDistSquared = latDiff * latDiff + lngDiff * lngDiff;
            
        // If potentially closer than current best, do accurate calculation
        if (quickDistSquared < closestDistance / 69000) {
            const dist = calculateDistance(userPos, loc);
            if (dist < closestDistance) {
                closestDistance = dist;
            }
        }
    }
        
    // Convert to feet for threshold comparison
    const distanceFeet = closestDistance * 3.28084;
        
    // Handle entering proximity zone
    if (!proximityState.isNearLocation && distanceFeet <= PROXIMITY_THRESHOLD) {
        if (now - (proximityState.lastZoomChangeTime || 0) >= ZOOM_COOLDOWN) {
            proximityState.isNearLocation = true;
            proximityState.lastZoomChangeTime = now;
                
            if (followUser !== false) {
                proximityState.zoomTransitionInProgress = true;
                    
                // Use setView instead of flyTo to avoid rubber banding
                map.setView([userPos.lat, userPos.lng], CLOSE_ZOOM, {
                    animate: true,
                    duration: 0.8,
                    noMoveStart: true
                });
                    
                setTimeout(() => {
                    proximityState.zoomTransitionInProgress = false;
                }, 1000);
            }
        }
    } 
    // Handle exiting proximity zone
    else if (proximityState.isNearLocation && distanceFeet >= PROXIMITY_EXIT_THRESHOLD) {
        if (now - (proximityState.lastZoomChangeTime || 0) >= ZOOM_COOLDOWN) {
            proximityState.isNearLocation = false;
            proximityState.lastZoomChangeTime = now;
                
            if (followUser !== false) {
                proximityState.zoomTransitionInProgress = true;
                    
                // Use setView instead of flyTo to avoid rubber banding
                map.setView([userPos.lat, userPos.lng], BASE_ZOOM, {
                    animate: true,
                    duration: 0.8,
                    noMoveStart: true
                });
                    
                setTimeout(() => {
                    proximityState.zoomTransitionInProgress = false;
                }, 1000);
            }
        }
    }
}
        
// OPTIMIZED: Completely rewritten speed-based zoom function with better performance
function getSpeedBasedZoom(speedMPS) {
    // State tracking variables (define these outside the function or use a closure)
    if (typeof window.speedTrackingState === 'undefined') {
        window.speedTrackingState = {
            lowSpeedStartTime: null,
            isInTransit: false,
            lastSignificantMove: Date.now(),
            destinationArrivalTime: null,
            previousZoom: null
        };
    }
        
    const state = window.speedTrackingState;
    const speedMPH = speedMPS * 2.23694;
        
    // Constants
    const WALKING_THRESHOLD = 3.0;  // mph (to better capture walking)
    const SIGNIFICANT_TRAVEL_THRESHOLD = 10.0; // mph
    const TEMPORARY_STOP_MAX = 90000; // 90 seconds (traffic light/sign)
    const ARRIVAL_DELAY = 20000; // 20 seconds after stopping to confirm arrival
        
    // Detect when we're truly in transit vs. just temporary stops
    if (speedMPH >= SIGNIFICANT_TRAVEL_THRESHOLD) {
        state.isInTransit = true;
        state.lastSignificantMove = Date.now();
        state.destinationArrivalTime = null;
    }
        
    // Handle low speed/walking/stopping
    if (speedMPH <= WALKING_THRESHOLD) {
        if (!state.lowSpeedStartTime) {
            state.lowSpeedStartTime = Date.now();
        }
            
        const lowSpeedDuration = Date.now() - state.lowSpeedStartTime;
            
        // Have we been in transit and now stopping for more than the arrival delay?
        if (state.isInTransit && lowSpeedDuration >= ARRIVAL_DELAY) {
            // If we've been stopped long enough, consider it a destination arrival
            if (!state.destinationArrivalTime) {
                state.destinationArrivalTime = Date.now();
            }
                
            // We've arrived at destination - set zoom to 17
            if (Date.now() - state.destinationArrivalTime >= 5000) {
                state.isInTransit = false; // Reset transit state
                state.previousZoom = 17;
                return 17;
            }
        }
            
        // For temporary stops during active travel, maintain previous zoom
        if (state.isInTransit && Date.now() - state.lastSignificantMove < TEMPORARY_STOP_MAX) {
            return state.previousZoom || 17; // Default to 17 if previousZoom is null
        }
            
        // Walking or stationary gets zoom level 17
        state.previousZoom = 17;
        return 17;
    } else {
        // Reset low speed tracking when moving faster than walking
        state.lowSpeedStartTime = null;
        state.destinationArrivalTime = null;
    }
        
    // Standard speed-based zoom logic for faster speeds
    for (const threshold of SPEED_ZOOM_THRESHOLDS) {
        if (speedMPH >= threshold.speed) {
            state.previousZoom = threshold.zoom;
            return threshold.zoom;
        }
    }
        
    // Fallback - should not reach here with our thresholds, but just in case
    state.previousZoom = 17;
    return 17;
}
        
// Validates if a position object contains valid coordinates and accuracy data
function isValidPosition(position) {
    // Check basic structure
    if (!position || typeof position !== 'object') return false;
        
    // Determine which format we're dealing with
    const isGeolocationFormat = position.coords && typeof position.coords === 'object';
    const coords = isGeolocationFormat ? position.coords : position;
        
    // Get lat/lng values depending on format
    const lat = isGeolocationFormat ? coords.latitude : coords.lat;
    const lng = isGeolocationFormat ? coords.longitude : coords.lng;
    const accuracy = coords.accuracy;
        
    // Validate essential coordinates
    const hasValidCoordinates = 
        Number.isFinite(lat) && 
        Number.isFinite(lng) &&
        lat >= -90 && lat <= 90 && 
        lng >= -180 && lng <= 180;
            
    if (!hasValidCoordinates) return false;
        
    // If accuracy is provided, validate it
    if ('accuracy' in coords && !Number.isFinite(accuracy)) return false;
        
    // If timestamp is provided, validate it's a reasonable value
    if ('timestamp' in position) {
        const timestamp = Number(position.timestamp);
        if (!Number.isFinite(timestamp) || timestamp <= 0) return false;
    }
        
    return true;
}

function applyExponentialSmoothing(newPosition, lastPosition, baseAlpha = 0.25) {
    // Validate inputs
    if (!isValidPosition(newPosition) || !isValidPosition(lastPosition)) {
        return newPosition;
    }

    // Initialize lastSmoothedPosition if it doesn't exist
    if (!lastSmoothedPosition) {
        lastSmoothedPosition = lastPosition;
    }

    const distance = calculateDistance(newPosition, lastSmoothedPosition);
        
    // Enhanced stationary detection
    if (distance < MIN_DISTANCE_THRESHOLD) {
        stationaryCount = Math.min(stationaryCount + 1, STATIONARY_THRESHOLD);
    } else {
        stationaryCount = Math.max(stationaryCount - 1, 0);
    }

    // Calculate adaptive alpha
    let alpha = baseAlpha;

    // Adjust alpha based on movement state
    if (stationaryCount >= STATIONARY_THRESHOLD) {
        alpha = MIN_ALPHA;
    } else {
        // Gradually reduce alpha as we approach stationary state
        alpha = MAX_ALPHA - (stationaryCount / STATIONARY_THRESHOLD) * (MAX_ALPHA - MIN_ALPHA);
    }

    // Accuracy-based adjustment
    const accuracyRatio = Math.max(0, Math.min(1, 1 - (newPosition.accuracy / MAX_ACCEPTABLE_ACCURACY)));
    alpha = alpha * (0.5 + 0.5 * accuracyRatio);

    // Speed-based adjustment
    if (newPosition.speedMPS !== undefined && newPosition.speedMPS < 0.5) {
        alpha *= 0.4; // Extra smoothing at very low speeds
    }

    // Time-based adjustment to handle GPS jitter
    const timeDelta = newPosition.timestamp - lastPosition.timestamp;
    if (timeDelta < 1000) { // If updates are very frequent
        alpha *= 0.7; // Reduce impact of rapid updates
    }

    // Apply smoothing with weighted factors
    const smoothedPosition = {
        lat: lastSmoothedPosition.lat + alpha * (newPosition.lat - lastSmoothedPosition.lat),
        lng: lastSmoothedPosition.lng + alpha * (newPosition.lng - lastSmoothedPosition.lng),
        accuracy: Math.min(newPosition.accuracy, lastSmoothedPosition.accuracy),
        heading: newPosition.heading,
        timestamp: newPosition.timestamp,
        speedMPS: newPosition.speedMPS ? 
                  lastSmoothedPosition.speedMPS * 0.7 + newPosition.speedMPS * 0.3 : // Smooth speed changes
                  newPosition.speedMPS
    };

    // Apply additional smoothing to heading when stationary
    if (stationaryCount >= STATIONARY_THRESHOLD && lastSmoothedPosition.heading !== undefined) {
        smoothedPosition.heading = alpha * newPosition.heading + (1 - alpha) * lastSmoothedPosition.heading;
    }

    // Additional stabilization for very small movements
    if (distance < MIN_DISTANCE_THRESHOLD * 0.5) {
        smoothedPosition.lat = lastSmoothedPosition.lat * 0.95 + smoothedPosition.lat * 0.05;
        smoothedPosition.lng = lastSmoothedPosition.lng * 0.95 + smoothedPosition.lng * 0.05;
    }

    // Update last smoothed position
    lastSmoothedPosition = smoothedPosition;

    return smoothedPosition;
}

function calculateVelocityFilter(newPos, lastPos) {
    if (!lastVelocity) {
        lastVelocity = { lat: 0, lng: 0 };
    }

    if (!newPos || !lastPos || 
        typeof newPos.lat !== 'number' || typeof newPos.lng !== 'number' || 
        typeof lastPos.lat !== 'number' || typeof lastPos.lng !== 'number') {
        return newPos;
    }

    const dt = (newPos.timestamp - lastPos.timestamp) / 1000;
    if (dt <= 0 || dt > 10) {
        return newPos;
    }

    const currentVelocity = {
        lat: (newPos.lat - lastPos.lat) / dt,
        lng: (newPos.lng - lastPos.lng) / dt
    };

    lastVelocity = {
        lat: lastVelocity.lat * VELOCITY_DECAY + currentVelocity.lat * (1 - VELOCITY_DECAY),
        lng: lastVelocity.lng * VELOCITY_DECAY + currentVelocity.lng * (1 - VELOCITY_DECAY)
    };

    // Apply velocity prediction
    return {
        lat: lastPos.lat + lastVelocity.lat * dt,
        lng: lastPos.lng + lastVelocity.lng * dt,
        accuracy: newPos.accuracy,
        timestamp: newPos.timestamp,
        heading: newPos.heading,
        speedMPS: newPos.speedMPS
    };
}

function checkStationaryState(newPosition) {
    if (!lastPosition) return;
        
    const distance = calculateDistance(lastPosition, newPosition);
        
    if (distance >= MICRO_MOVEMENT_THRESHOLD) {
        isStationary = false;
        stationaryStartTime = null;
        console.debug("Movement detected, resuming normal updates");
    }
        
    if (stationaryCheckTimeout) {
        clearTimeout(stationaryCheckTimeout);
        stationaryCheckTimeout = null;
    }
        
    if (isStationary) {
        stationaryCheckTimeout = setTimeout(() => checkStationaryState(newPosition), STATIONARY_CHECK_INTERVAL);
    }
}

function calculateFinalPosition() {
    // If buffer is empty, return null
    if (positionBuffer.length === 0) {
        return null;
    }
        
    // If only one position in buffer, return it
    if (positionBuffer.length === 1) {
        return positionBuffer[0];
    }
        
    // Calculate weighted average of positions in buffer
    return calculateWeightedPosition(positionBuffer);
}

function updateMarkerAndMap(position, speedMPS) {
    if (!position || typeof position.lat !== 'number' || typeof position.lng !== 'number') {
        console.warn("Invalid position for marker update");
        return;
    }
        
    // Update marker position with animation
    userMarker.setLatLng([position.lat, position.lng], { animate: true, duration: 0.3 });
        
    // Check if we need to recenter map based on user position
    if (followUser && !isMapInteracting) {
        const recenterInfo = shouldRecenter(map, userMarker);
            
        if (recenterInfo.needsRecenter) {
            const newCenter = recenterInfo.isEmergency ? 
                [position.lat, position.lng] : 
                calculateOptimalCenter(map, position, recenterInfo.edgeInfo);
                    
            map.panTo(newCenter, {
                animate: true,
                duration: recenterInfo.isEmergency ? 0.1 : 0.5,
                easeLinearity: 0.5
            });
        }
            
        // Adjust zoom based on speed if needed
        const zoomLevel = getSpeedBasedZoom(speedMPS);
        if (zoomLevel !== -1 && Math.abs(map.getZoom() - zoomLevel) > 0.5) {
            map.setZoom(zoomLevel, { animate: true, duration: 1 });
        }
    }
        
    // Update distance box
    updateDistanceBox();
}

// Add these variables at the top of your script or in an appropriate scope
let cachedPosition = null;
let cachedTimestamp = 0;
let consecutiveFailures = 0;
let isLocationUpdateInProgress = false;
let backgroundUpdateCount = 0;

/**
 * Enhanced updateUserLocation function with reduced logging
 * @param {boolean} isBackgroundUpdate - Whether this is a background update
 * @param {boolean} highAccuracy - Whether to use high accuracy
 * @param {number} retryCount - Current retry count (internal use)
 * @returns {Promise} - Promise that resolves with position
 */
function updateUserLocation(isBackgroundUpdate = false, highAccuracy = true, retryCount = 0) {
    // Don't allow concurrent updates
    if (isLocationUpdateInProgress) {
        // No logging for skipped background updates
        return Promise.resolve(cachedPosition);
    }
        
    // For background updates, only log every 20th update to reduce console clutter
    const shouldLog = !isBackgroundUpdate || (backgroundUpdateCount % 20 === 0);
        
    if (isBackgroundUpdate) {
        // Count background updates (but don't log every one)
        backgroundUpdateCount++;
            
        // No minimum interval - allow updates as frequently as called
    }
        
    if (!navigator.geolocation) {
        if (shouldLog) console.warn("Geolocation not supported");
        return Promise.reject(new Error("Geolocation not supported"));
    }
        
    isLocationUpdateInProgress = true;
        
    // Determine appropriate timeout based on context
    let timeout;
    if (isBackgroundUpdate) {
        timeout = 8000; // Shorter timeout for background updates
    } else {
        timeout = highAccuracy ? 15000 : 10000; // 15s for high accuracy, 10s for low
    }
        
    // Adjust timeout based on consecutive failures
    if (consecutiveFailures > 3) {
        timeout *= 1.5;
    }
        
    // Create options object based on geolocationOptions but override some properties
    const options = {...geolocationOptions};
    options.enableHighAccuracy = highAccuracy;
    options.timeout = timeout;
    options.maximumAge = isBackgroundUpdate ? 30000 : 0; // Allow cached positions for background updates
        
    // Only log if it's a foreground update or every 20th background update
    if (shouldLog) {
        console.log(`Getting position (background: ${isBackgroundUpdate}, highAccuracy: ${highAccuracy}, retry: ${retryCount}, timeout: ${timeout}ms)`);
    }
        
    return new Promise((resolve, reject) => {
        navigator.geolocation.getCurrentPosition(
            (position) => {
                try {
                    // Success! Reset failure counter
                    consecutiveFailures = 0;
                        
                    // Update cache
                    cachedPosition = position;
                    cachedTimestamp = Date.now();
                    lastUpdateTime = Date.now();
                        
                    // Process position
                    processUserPosition(position, isBackgroundUpdate);
                        
                    // Only log success for foreground or occasional background updates
                    if (shouldLog) {
                        console.log(`Position updated successfully (accuracy: ${position.coords.accuracy.toFixed(1)}m)`);
                    }
                        
                    isLocationUpdateInProgress = false;
                    resolve(position);
                } catch (error) {
                    // Always log errors
                    console.error(`Error processing position:`, error);
                    isLocationUpdateInProgress = false;
                    reject(error);
                }
            },
            (error) => {
                // Increment failure counter
                consecutiveFailures++;
                    
                // Always log errors
                console.warn(`Location error (code: ${error.code}, background: ${isBackgroundUpdate}, highAccuracy: ${highAccuracy}, retry: ${retryCount})`);
                    
                // Handle based on error type and context
                if (error.code === 3) { // TIMEOUT
                    // If high accuracy timed out, try low accuracy
                    if (highAccuracy) {
                        if (shouldLog) console.log("High accuracy timed out, falling back to low accuracy");
                        isLocationUpdateInProgress = false;
                        return updateUserLocation(isBackgroundUpdate, false, retryCount)
                            .then(resolve)
                            .catch(reject);
                    } 
                    // If low accuracy and retries available, retry after delay
                    else if (retryCount < 3) { // Max 3 retries
                        const delay = calculateRetryDelay(retryCount);
                        if (shouldLog) console.log(`Low accuracy timed out, retrying in ${delay}ms (retry ${retryCount + 1}/3)`);
                            
                        setTimeout(() => {
                            isLocationUpdateInProgress = false;
                            updateUserLocation(isBackgroundUpdate, false, retryCount + 1)
                                .then(resolve)
                                .catch(reject);
                        }, delay);
                        return;
                    }
                }
                    
                // If we get here, we've exhausted our options
                if (!isBackgroundUpdate) {
                    handleError(error);
                }
                    
                // Use cached position as fallback if available and not too old
                if (cachedPosition && (Date.now() - cachedTimestamp) < 120000) { // 2 minutes
                    if (shouldLog) console.log(`Using cached position from ${Math.round((Date.now() - cachedTimestamp)/1000)}s ago as fallback`);
                    isLocationUpdateInProgress = false;
                    resolve(cachedPosition);
                } else {
                    isLocationUpdateInProgress = false;
                    reject(error);
                }
            },
            options
        );
    }).catch(error => {
        // Final catch to prevent unhandled promise rejections
        console.error("Location update ultimately failed:", error);
        isLocationUpdateInProgress = false;
            
        // If we have a last known position, we could use that as a fallback
        if (lastKnownPosition && shouldLog) {
            console.log("Using last known position as fallback");
        }
            
        return cachedPosition || null;
    });
}

/**
 * Calculate retry delay with exponential backoff
 * @param {number} retryCount - Current retry count
 * @returns {number} - Delay in milliseconds
 */
function calculateRetryDelay(retryCount) {
    // Exponential backoff with jitter
    const baseDelay = 2000;
    const exponentialDelay = baseDelay * Math.pow(1.5, retryCount);
    const jitter = Math.random() * 1000; // Add up to 1s of jitter
        
    return Math.min(30000, exponentialDelay + jitter); // Cap at 30 seconds
}

/**
 * Process and filter user position data
 * @param {GeolocationPosition} position - Raw position from geolocation API
 * @param {boolean} isBackgroundUpdate - Whether this is a background update
 */
function processUserPosition(position, isBackgroundUpdate = false) {
    // Validate input position
    if (!position?.coords?.latitude || !position?.coords?.longitude) {
        console.warn("Invalid position data received");
        return;
    }

    // Cancel any pending animation frame
    if (animationFrameId !== null) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
    }

    const currentTime = Date.now();
    const timeDelta = lastUpdateTime ? (currentTime - lastUpdateTime) / 1000 : 0;

    const newPosition = {
        lat: position.coords.latitude,
        lng: position.coords.longitude,
        accuracy: position.coords.accuracy || 20,
        heading: position.coords.heading ?? null,
        timestamp: currentTime,
        speedMPS: position.coords.speed || 0
    };

    // First position initialization
    if (!lastPosition) {
        lastPosition = newPosition;
        userMarker.setLatLng([newPosition.lat, newPosition.lng]);
        kalmanFilter.reset(newPosition);
        lastUpdateTime = currentTime;
        stationaryStartTime = currentTime;
        positionBuffer = [newPosition];
            
        const zoomLevel = getSpeedBasedZoom(newPosition.speedMPS);
        if (zoomLevel !== -1) {
            map.setZoom(zoomLevel, { animate: false });
        }
        map.setView([newPosition.lat, newPosition.lng], map.getZoom(), { animate: false });
        updateDistanceBox();
            
        // Start animation loop if needed
        if (!isAnimationRunning) {
            startAnimationLoop();
        }
            
        // Store initial user position for recentering logic
        if (typeof lastUserPosition !== 'undefined') {
            lastUserPosition = map.latLngToContainerPoint(userMarker.getLatLng());
        }
            
        return;
    }

    const distance = calculateDistance(lastPosition, newPosition);
    const forceUpdate = isBackgroundUpdate === false && currentTime - lastUpdateTime > FORCE_UPDATE_INTERVAL;

    // Enhanced adaptive filtering based on speed
    const speedFactor = Math.min(1, Math.max(0.1, newPosition.speedMPS / 10));
    kalmanFilter.q = BASE_PROCESS_NOISE * speedFactor;
    kalmanFilter.r = newPosition.accuracy / (100 * (1 + speedFactor));

    // Extended distance handling with improved smoothing
    if (distance > EXTENDED_DISTANCE_THRESHOLD || forceUpdate) {
        // Clear timers and reset stationary state
        if (stationaryCheckTimeout) {
            clearTimeout(stationaryCheckTimeout);
            stationaryCheckTimeout = null;
        }
        isStationary = false;
        stationaryStartTime = null;

        const transitionPosition = {
            lat: newPosition.lat,
            lng: newPosition.lng,
            accuracy: newPosition.accuracy,
            heading: newPosition.heading,
            timestamp: currentTime,
            speedMPS: newPosition.speedMPS
        };

        // Update user marker position immediately without animation
        userMarker.setLatLng([transitionPosition.lat, transitionPosition.lng], { animate: false });
            
        // Reset tracking variables
        lastPosition = transitionPosition;
        positionBuffer = [transitionPosition];
        kalmanFilter.reset(transitionPosition);
        lastVelocity = { lat: 0, lng: 0 };

        // Apply appropriate zoom level
        const zoomLevel = getSpeedBasedZoom(newPosition.speedMPS);
        if (zoomLevel !== -1) {
            map.setZoom(zoomLevel, { animate: false });
        }
            
        // Force immediate view update to user position - no animation whatsoever
        map.setView([transitionPosition.lat, transitionPosition.lng], map.getZoom(), { 
            animate: false, 
            duration: 0,
            noMoveStart: true,
            noAnimation: true
        });
            
        // Ensure we're following the user
        followUser = true;
        isMapInteracting = false;
            
        // Update tracking variables
        lastUpdateTime = currentTime;
        lastUpdateTimestamp = currentTime;
        updateDistanceBox();
            
        // Update lastUserPosition for recentering logic
        if (typeof lastUserPosition !== 'undefined') {
            lastUserPosition = map.latLngToContainerPoint(userMarker.getLatLng());
        }
            
        // Force a container resize to ensure proper rendering
        if (map._container) {
            map._onResize();
        }
            
        return;
    }

    // Enhanced stationary detection with improved filtering
    if (distance < MICRO_MOVEMENT_THRESHOLD && !forceUpdate) {
        if (!isStationary) {
            if (!stationaryStartTime) {
                stationaryStartTime = currentTime;
            } else if (currentTime - stationaryStartTime >= STATIONARY_TIME_THRESHOLD) {
                isStationary = true;
                    
                // Optimize Kalman filter for stationary state
                kalmanFilter.r = Math.min(newPosition.accuracy, lastPosition.accuracy) / 200;
                kalmanFilter.q = BASE_PROCESS_NOISE * 0.1;
                    
                const stationaryPosition = kalmanFilter.update({
                    lat: newPosition.lat,
                    lng: newPosition.lng,
                    accuracy: Math.min(lastPosition.accuracy, newPosition.accuracy) * STATIONARY_ACCURACY_MULTIPLIER,
                    heading: newPosition.heading,
                    timestamp: newPosition.timestamp,
                    speedMPS: 0
                });
                    
                userMarker.setLatLng([stationaryPosition.lat, stationaryPosition.lng], { animate: false });
                lastPosition = stationaryPosition;
                positionBuffer = [stationaryPosition];
                    
                if (stationaryCheckTimeout) clearTimeout(stationaryCheckTimeout);
                stationaryCheckTimeout = setTimeout(() => checkStationaryState(newPosition), STATIONARY_CHECK_INTERVAL);
                    
                updateDistanceBox();
                    
                // Update lastUserPosition for recentering logic
                if (typeof lastUserPosition !== 'undefined') {
                    lastUserPosition = map.latLngToContainerPoint(userMarker.getLatLng());
                }
                    
                return;
            }
        }
            
        if (isStationary) {
            // Only refine stationary position if accuracy has significantly improved
            if (newPosition.accuracy < lastPosition.accuracy * 0.9) {
                kalmanFilter.r = newPosition.accuracy / 400;
                kalmanFilter.q = BASE_PROCESS_NOISE * 0.05;
                    
                const refinedPosition = kalmanFilter.update({
                    lat: newPosition.lat,
                    lng: newPosition.lng,
                    accuracy: newPosition.accuracy,
                    heading: newPosition.heading,
                    timestamp: newPosition.timestamp,
                    speedMPS: 0
                });
                    
                if (calculateDistance(lastPosition, refinedPosition) < MICRO_MOVEMENT_THRESHOLD / 2) {
                    userMarker.setLatLng([refinedPosition.lat, refinedPosition.lng], { animate: false });
                    lastPosition = refinedPosition;
                    updateDistanceBox();
                        
                    // Update lastUserPosition for recentering logic
                    if (typeof lastUserPosition !== 'undefined') {
                        lastUserPosition = map.latLngToContainerPoint(userMarker.getLatLng());
                    }
                }
                return;
            }
        }
    } else {
        // Not stationary, reset stationary state
        isStationary = false;
        stationaryStartTime = null;
        if (stationaryCheckTimeout) {
            clearTimeout(stationaryCheckTimeout);
            stationaryCheckTimeout = null;
        }
    }

    // Skip updates with poor accuracy or unrealistic movement
    if (!forceUpdate && (
        newPosition.accuracy > MAX_ACCEPTABLE_ACCURACY ||
        distance < MIN_DISTANCE_THRESHOLD ||
        (timeDelta > 0 && distance / timeDelta > MAX_SPEED)
    )) {
        return;
    }

    try {
        // Apply Kalman filter with adaptive parameters
        const filteredPosition = kalmanFilter.update({
            lat: newPosition.lat,
            lng: newPosition.lng,
            accuracy: newPosition.accuracy,
            heading: newPosition.heading,
            timestamp: newPosition.timestamp,
            speedMPS: newPosition.speedMPS
        });

        updatePositionBuffer(filteredPosition);
            
        const finalPosition = calculateFinalPosition();
        if (!finalPosition) throw new Error("Final position calculation failed");

        const predictedPosition = calculateEnhancedVelocityFilter(finalPosition, lastPosition, timeDelta, newPosition.speedMPS);
            
        // Apply dynamic smoothing based on speed
        const smoothingFactor = Math.min(0.8, Math.max(0.2, 0.3 + (speedFactor * 0.5)));
        const smoothedPosition = {
            lat: lastPosition.lat * (1 - smoothingFactor) + predictedPosition.lat * smoothingFactor,
            lng: lastPosition.lng * (1 - smoothingFactor) + predictedPosition.lng * smoothingFactor,
            accuracy: predictedPosition.accuracy,
            heading: predictedPosition.heading,
            timestamp: currentTime,
            speedMPS: predictedPosition.speedMPS
        };

        // Calculate optimal animation duration based on speed
        const animDuration = Math.min(0.3, Math.max(0.1, 0.2 / (1 + speedFactor)));
            
        userMarker.setLatLng([smoothedPosition.lat, smoothedPosition.lng], {
            animate: true,
            duration: animDuration
        });
            
        // Only update map view when necessary
        if (currentTime - lastMapUpdateTime > MAP_UPDATE_INTERVAL || distance > POSITION_UPDATE_THRESHOLD) {
            // Check for special zoom situations
            checkProximityForZoom();
                
            // Apply look-ahead for smoother experience at higher speeds
            const lookAheadFactor = Math.min(0.5, speedFactor * 0.3);
                
            const lookAheadPosition = {
                lat: smoothedPosition.lat + (predictedPosition.lat - lastPosition.lat) * lookAheadFactor,
                lng: smoothedPosition.lng + (predictedPosition.lng - lastPosition.lng) * lookAheadFactor
            };
                
            // Only animate map if user is following
            if (followUser) {
                // Use requestAnimationFrame for smoother panning
                animationFrameId = requestAnimationFrame(() => {
                    map.panTo([lookAheadPosition.lat, lookAheadPosition.lng], {
                        animate: true,
                        duration: 0.5,
                        easeLinearity: 0.5
                    });
                        
                    const zoomLevel = getSpeedBasedZoom(newPosition.speedMPS);
                    if (zoomLevel !== -1 && Math.abs(map.getZoom() - zoomLevel) >= 1) {
                        map.setZoom(zoomLevel, { animate: true, duration: 1 });
                    }
                        
                    animationFrameId = null;
                });
            }
                
            lastMapUpdateTime = currentTime;
                
            // Update lastUserPosition for recentering logic
            if (typeof lastUserPosition !== 'undefined') {
                lastUserPosition = map.latLngToContainerPoint(userMarker.getLatLng());
            }
        }

        lastPosition = smoothedPosition;
        lastUpdateTime = currentTime;
        lastUpdateTimestamp = currentTime;
        updateDistanceBox();

    } catch (error) {
        console.error("Location update error:", error);
        // Cancel any pending animation frame on error
        if (animationFrameId !== null) {
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
        }
            
        // Fallback to simpler positioning in case of error
        kalmanFilter.r = newPosition.accuracy / 50;
        const fallbackPosition = kalmanFilter.update(newPosition);
        userMarker.setLatLng([fallbackPosition.lat, fallbackPosition.lng], { animate: true, duration: 0.3 });
        lastPosition = fallbackPosition;
        positionBuffer = [fallbackPosition];
        updateDistanceBox();
            
        // Update lastUserPosition for recentering logic
        if (typeof lastUserPosition !== 'undefined') {
            lastUserPosition = map.latLngToContainerPoint(userMarker.getLatLng());
        }
    }
        
    // Start animation loop if needed and not already running
    if (!isAnimationRunning) {
        startAnimationLoop();
    }
}

/**
 * Process user position with minimal logging and no counter
 * @param {GeolocationPosition} position - The position from geolocation API
 * @param {boolean} isBackgroundUpdate - Whether this is from a background update
 */
function processUserPosition(position, isBackgroundUpdate = false) {
    // Store the raw position data
    userPosition = position;
        
    // Only log if it's a foreground update or if enough time has passed since last log
    const now = Date.now();
    if (!isBackgroundUpdate || (now - lastPositionLogTime > 30000)) { // Log at most once every 30 seconds
        console.log("Received position:", 
            position.coords.latitude.toFixed(6), 
            position.coords.longitude.toFixed(6),
            `(accuracy: ${position.coords.accuracy.toFixed(1)}m)`
        );
        lastPositionLogTime = now;
    }
        
    // If animation not running, start it
    if (!isAnimationRunning) {
        startAnimationLoop();
    }
}

// Initialize and setup geolocation
function setupGeolocation() {
    // Check if geolocation is available
    if (!navigator.geolocation) {
        console.error("Geolocation is not supported by this browser");
        return;
    }
        
    // Start watching position
    const watchId = navigator.geolocation.watchPosition(
        // Success callback
        function(position) {
            processUserPosition(position);
        },
        // Error callback
        function(error) {
            console.error("Geolocation error:", error.message);
        },
        // Options
        {
            enableHighAccuracy: true,
            maximumAge: 0,
            timeout: 5000
        }
    );
        
    console.log("Geolocation watching started");
        
    // Return watch ID in case we need to stop watching later
    return watchId;
}

// Example of how to initialize everything
function initializeApp() {
    // First initialize the map
    initMap();
        
    // Then setup geolocation
    const geolocationWatchId = setupGeolocation();
        
    // Store watch ID for cleanup later if needed
    window.geolocationWatchId = geolocationWatchId;
}

// Initialize when document is ready
document.addEventListener('DOMContentLoaded', function() {
    initializeApp();
});

// New helper function for enhanced velocity prediction with acceleration
function calculateEnhancedVelocityFilter(currentPosition, lastPosition, timeDelta, speed) {
    if (!timeDelta || timeDelta <= 0) {
        return currentPosition;
    }
        
    // Calculate current velocity components
    const currentVelocity = {
        lat: (currentPosition.lat - lastPosition.lat) / timeDelta,
        lng: (currentPosition.lng - lastPosition.lng) / timeDelta
    };
        
    // If no last velocity, initialize it
    if (!lastVelocity) {
        lastVelocity = currentVelocity;
    }
        
    // Calculate acceleration (change in velocity)
    const acceleration = {
        lat: (currentVelocity.lat - lastVelocity.lat) / timeDelta,
        lng: (currentVelocity.lng - lastVelocity.lng) / timeDelta
    };
        
    // Apply acceleration damping at higher speeds to prevent oscillation
    const accelerationDamping = Math.min(1, Math.max(0.2, 1 - (speed / 20)));
    const dampedAcceleration = {
        lat: acceleration.lat * accelerationDamping,
        lng: acceleration.lng * accelerationDamping
    };
        
    // Store current velocity for next update
    lastVelocity = currentVelocity;
        
    // Calculate predicted position using velocity and damped acceleration
    const predictionTimeFactor = Math.min(0.5, Math.max(0.1, timeDelta)); // Limit prediction time
        
    const predictedPosition = {
        lat: currentPosition.lat + (currentVelocity.lat * predictionTimeFactor) + (0.5 * dampedAcceleration.lat * predictionTimeFactor * predictionTimeFactor),
        lng: currentPosition.lng + (currentVelocity.lng * predictionTimeFactor) + (0.5 * dampedAcceleration.lng * predictionTimeFactor * predictionTimeFactor),
        accuracy: currentPosition.accuracy,
        heading: currentPosition.heading,
        timestamp: currentPosition.timestamp,
        speedMPS: speed
    };
        
    return predictedPosition;
}

function calculateEdgeProximity(map, point) {
    const bounds = map.getBounds();
    const latSpan = bounds.getNorth() - bounds.getSouth();
    const lngSpan = bounds.getEast() - bounds.getWest();
        
    return {
        north: Math.abs(point.lat - bounds.getNorth()) / latSpan,
        south: Math.abs(point.lat - bounds.getSouth()) / latSpan,
        east: Math.abs(point.lng - bounds.getEast()) / lngSpan,
        west: Math.abs(point.lng - bounds.getWest()) / lngSpan
    };
}

function isMarkerNearEdge(map, marker, isStrict = false) {
    const bounds = map.getBounds();
    const point = marker.getLatLng();
    const proximities = calculateEdgeProximity(map, point);
        
    const thresholdPercentage = isStrict ? 
        STRICT_EDGE_THRESHOLD_PERCENTAGE : 
        EDGE_THRESHOLD_PERCENTAGE;
        
    const edges = {
        north: proximities.north < thresholdPercentage,
        south: proximities.south < thresholdPercentage,
        east: proximities.east < thresholdPercentage,
        west: proximities.west < thresholdPercentage
    };
        
    return {
        isNearEdge: Object.values(edges).some(edge => edge),
        edges: edges,
        proximities: proximities
    };
}

function calculateOptimalCenter(map, markerPosition, edgeInfo) {
    const bounds = map.getBounds();
        
    let latOffset = 0;
    let lngOffset = 0;
        
    if (edgeInfo.edges.north) latOffset = -1 * (bounds.getNorth() - bounds.getSouth()) * 0.2;
    if (edgeInfo.edges.south) latOffset = (bounds.getNorth() - bounds.getSouth()) * 0.2;
    if (edgeInfo.edges.east) lngOffset = -1 * (bounds.getEast() - bounds.getWest()) * 0.2;
    if (edgeInfo.edges.west) lngOffset = (bounds.getEast() - bounds.getWest()) * 0.2;
        
    return {
        lat: markerPosition.lat + latOffset,
        lng: markerPosition.lng + lngOffset
    };
}

let lastRecenterTime = Date.now();

function shouldRecenter(map, marker) {
    const now = Date.now();
    if (now - lastRecenterTime < MIN_RECENTER_INTERVAL) {
        return { needsRecenter: false };
    }
        
    const edgeInfo = isMarkerNearEdge(map, marker);
    const proximities = edgeInfo.proximities;
        
    const isCritical = Object.values(proximities).some(
        proximity => proximity < CRITICAL_EDGE_THRESHOLD_PERCENTAGE
    );
        
    if (isCritical) {
        lastRecenterTime = now;
        return {
            needsRecenter: true,
            isEmergency: true,
            edgeInfo: edgeInfo
        };
    }
        
    if (edgeInfo.isNearEdge) {
        lastRecenterTime = now;
        return {
            needsRecenter: true,
            isEmergency: false,
            edgeInfo: edgeInfo
        };
    }
        
    return {
        needsRecenter: false,
        isEmergency: false,
        edgeInfo: edgeInfo
    };
}

function updateDistanceBox() {
    const distanceBox = document.getElementById('distanceBox');
        
    // Initial validation
    if (!userMarker || !gameLocations || gameLocations.length === 0) {
        distanceBox.innerText = 'Initializing...';
        return;
    }

    // Get user coordinates
    const userLatLng = userMarker.getLatLng();
    let userLat = userLatLng.lat;
    let userLng = userLatLng.lng;

    // Coordinate validation
    if (!isFinite(userLat) || !isFinite(userLng)) {
        console.warn('Invalid user coordinates:', userLat, userLng);
        distanceBox.innerText = 'Initializing...';
        return;
    }

    // Use map center if at origin
    if (userLat === 0 && userLng === 0) {
        const center = map.getCenter();
        userLat = center.lat;
        userLng = center.lng;
    }

    // Find closest location
    let closestDistance = Infinity;
    let closestLocation = null;
    const userPos = { lat: userLat, lng: userLng };

    for (const location of gameLocations) {
        if (!location || typeof location.lat !== 'number' || typeof location.lng !== 'number') {
            console.warn('Invalid location data:', location);
            continue;
        }

        const locationPos = { lat: location.lat, lng: location.lng };
        const distance = calculateDistance(userPos, locationPos);

        if (isFinite(distance) && distance < closestDistance) {
            closestDistance = distance;
            closestLocation = location;
        }
    }

    // Validate final distance calculation
    if (!isFinite(closestDistance) || closestDistance === Infinity) {
        console.warn('Invalid distance calculation:', closestDistance);
        distanceBox.innerText = 'Initializing...';
        return;
    }

    // Calculate and display distance
    const distanceFeet = Math.round(closestDistance * 3.28084);
    const distanceText = distanceFeet < 5280 
        ? `${distanceFeet.toLocaleString()} feet` 
        : `${(distanceFeet / 5280).toFixed(2)} miles`;
        
    distanceBox.innerText = `Closest Stop: ${distanceText}`;

    // Check if we should show location hunt
    if (distanceFeet <= DISTANCE_THRESHOLD && !isLocationHuntVisible && closestLocation) {
        showLocationHunt(closestLocation);
    }
}

function getGeolocationOptions(retryNumber) {
    return {
        enableHighAccuracy: retryNumber < 2,
        timeout: 10000 + (retryNumber * 5000),
        maximumAge: retryNumber * 5000
    };
}

function handleLocationError(error) {
    console.warn("Error getting user location:", error);
        
    if (retryCount < MAX_RETRIES) {
        retryCount++;
        console.log(`Retrying to get location (Attempt ${retryCount} of ${MAX_RETRIES})`);
            
        // Use increasing timeout for subsequent retries
        const currentRetryDelay = RETRY_DELAY * retryCount;
            
        setTimeout(() => {
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    console.log("Location retrieved successfully after retry");
                    hideLoadingMessage();
                    updateUserLocation(position, true);
                    retryCount = 0;
                }, 
                handleLocationError, 
                getGeolocationOptions(retryCount) 
            );
        }, currentRetryDelay);
        return;
    }
        
    retryCount = 0;
    hideLoadingMessage();
        
    let errorMessage = "An error occurred while getting your location.";
    if (error && error.code) {
        switch(error.code) {
            case 1: // PERMISSION_DENIED
                errorMessage = "Please allow access to your location to use this feature.";
                break;
            case 2: // POSITION_UNAVAILABLE
                errorMessage = "Your location is currently unavailable. Please try again later.";
                break;
            case 3: // TIMEOUT
                errorMessage = "Getting your location took too long. Please try again.";
                break;
        }
    }
        
    showPopup("Location Error", errorMessage);
        
    // Signal that the location request failed
    if (typeof onLocationFailure === 'function') {
        onLocationFailure(error);
    }
}

function showPopup(title, message, type = 'info', callback = null) {
    // Remove any existing popups
    const existingPopups = document.querySelectorAll('.popup');
    existingPopups.forEach(popup => {
        document.body.removeChild(popup);
    });
        
    const popup = document.createElement('div');
    popup.classList.add('popup', 'fade-in');
    popup.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        z-index: 3000;
        display: flex;
        justify-content: center;
        align-items: center;
    `;

    const popupContent = document.createElement('div');
    popupContent.style.cssText = `
        background-color: white;
        padding: 25px;
        border-radius: 12px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
        max-width: 85%;
        width: 350px;
        text-align: center;
        position: relative;
        left: 0;
        transform: none;
        margin: 0 auto;
    `;

    const titleElement = document.createElement('h3');
    titleElement.textContent = title;
    titleElement.style.cssText = `
        margin-bottom: 15px;
        font-size: 20px;
        font-weight: 600;
        color: var(--primary-color);
    `;

    const messageElement = document.createElement('p');
    messageElement.textContent = message;
    messageElement.style.cssText = `
        margin-bottom: 25px;
        font-size: 16px;
        line-height: 1.5;
        color: #333;
    `;

    const buttonContainer = document.createElement('div');
    buttonContainer.style.cssText = `
        display: flex;
        justify-content: center;
        gap: 15px;
    `;

    const okButton = document.createElement('button');
    okButton.textContent = 'OK';
    okButton.style.cssText = `
        padding: 10px 25px;
        background-color: var(--primary-color);
        color: white;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-size: 16px;
        font-weight: 500;
        transition: background-color 0.2s;
    `;
    okButton.onmouseover = () => { okButton.style.backgroundColor = '#004b7d'; };
    okButton.onmouseout = () => { okButton.style.backgroundColor = 'var(--primary-color)'; };

    okButton.addEventListener('click', () => {
        popup.classList.add('fade-out');
        setTimeout(() => {
            if (document.body.contains(popup)) {
                document.body.removeChild(popup);
            }
            if (callback) callback();
        }, 300);
    });

    buttonContainer.appendChild(okButton);

    if (type === 'info') {
        const cancelButton = document.createElement('button');
        cancelButton.textContent = 'Cancel';
        cancelButton.style.cssText = `
            padding: 10px 25px;
            background-color: #f2f2f2;
            color: #333;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            transition: background-color 0.2s;
        `;
        cancelButton.onmouseover = () => { cancelButton.style.backgroundColor = '#e0e0e0'; };
        cancelButton.onmouseout = () => { cancelButton.style.backgroundColor = '#f2f2f2'; };

        cancelButton.addEventListener('click', () => {
            popup.classList.add('fade-out');
            setTimeout(() => {
                if (document.body.contains(popup)) {
                    document.body.removeChild(popup);
                }
            }, 300);
        });

        buttonContainer.appendChild(cancelButton);
    }

    popupContent.appendChild(titleElement);
    popupContent.appendChild(messageElement);
    popupContent.appendChild(buttonContainer);
    popup.appendChild(popupContent);
    document.body.appendChild(popup);
}

let lastVisitTime = 0;
const cooldownPeriod = 3 * 60 * 1000; // 3 minutes

function showLocationHunt(location) {
    const now = performance.now();
    if (location.id === lastVisitedLocationId && now - lastVisitTime < cooldownPeriod) {
        console.log(`Location ${location.id} is on cooldown. Skipping.`);
        return;
    }
        
    lastVisitedLocationId = location.id;
    lastVisitTime = now;
    isLocationHuntVisible = true;

    const lochuntContainer = document.querySelector('.lochunt-container');
    lochuntContainer.innerHTML = '';
    lochuntContainer.style.display = 'flex';
    lochuntContainer.classList.add('fade-in');

    const scrollableContent = document.createElement('div');
    scrollableContent.style.cssText = `
        flex: 1;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
        scroll-behavior: smooth;
        will-change: scroll-position;
    `;

    const locationImage = document.createElement('img');
    locationImage.src = location.image;
    locationImage.alt = location.name;
    locationImage.style.cssText = `
        width: 100%;
        height: 45vh;
        object-fit: cover;
        object-position: center;
    `;
    locationImage.loading = "eager"; // Prioritize image loading

    scrollableContent.appendChild(locationImage);

    const contentContainer = document.createElement('div');
    contentContainer.classList.add('lochunt-content');
    contentContainer.style.cssText = `
        padding: 24px;
        display: flex;
        flex-direction: column;
        align-items: center;
        max-width: 800px;
        margin: 0 auto;
    `;
        
    const locationInfo = document.createElement('div');
    locationInfo.classList.add('lochunt-info');
    locationInfo.style.cssText = `
        text-align: center;
        width: 100%;
        margin-bottom: 15px;
    `;
        
    const locationName = document.createElement('h1');
    locationName.textContent = location.name;
    locationName.style.cssText = `
        font-size: clamp(1.8rem, 4vw, 2.5rem);
        font-weight: 700;
        color: #1a1a1a;
        margin-bottom: 8px;
        line-height: 1.2;
    `;
        
    const locationCity = document.createElement('p');
    locationCity.textContent = `${location.city}`;
    locationCity.style.cssText = `
        font-size: clamp(1.1rem, 2vw, 1.3rem);
        color: #2c5282;
        font-weight: 600;
        margin-bottom: 4px;
    `;
        
    const locationCreator = document.createElement('p');
    locationCreator.textContent = `Created by: ${location.creator}`;
    locationCreator.style.cssText = `
        font-size: calc(0.9rem + 0.4vw);
        color: #666666;
        font-weight: 500;
    `;
        
    locationInfo.appendChild(locationName);
    locationInfo.appendChild(locationCity);
    locationInfo.appendChild(locationCreator);
    contentContainer.appendChild(locationInfo);
        
    const audioPlayerContainer = createAudioPlayer(location.audio);
    contentContainer.appendChild(audioPlayerContainer);
    scrollableContent.appendChild(contentContainer);
    lochuntContainer.appendChild(scrollableContent);
        
    const bottomActionBar = createBottomActionBar(location);
    bottomActionBar.style.cssText += `
        position: sticky;
        bottom: 0;
        width: 100%;
    `;
    lochuntContainer.appendChild(bottomActionBar);
        
    // Initialize audio player after DOM is updated
    setTimeout(() => {
        initAudioPlayer();
    }, 100);
}

function createAudioPlayer(audioSrc) {
    const audioPlayerContainer = document.createElement('div');
    audioPlayerContainer.classList.add('audio-player');
    audioPlayerContainer.style.cssText = `
        width: 100%;
        max-width: 400px;
        margin-bottom: 15px;
    `;

    const audio = document.createElement('audio');
    audio.id = 'locationAudio';
    audio.src = audioSrc;
    audio.preload = "auto";

    const audioProgress = document.createElement('div');
    audioProgress.classList.add('audio-progress');
    audioProgress.style.cssText = `
        width: 100%;
        margin-bottom: 15px;
    `;

    const progressContainer = document.createElement('div');
    progressContainer.classList.add('progress');
    progressContainer.style.cssText = `
        height: 8px;
        background-color: #e2e8f0;
        border-radius: 4px;
        cursor: pointer;
        margin-bottom: 12px;
        overflow: hidden;
    `;

    const progressBar = document.createElement('div');
    progressBar.id = 'progressBar';
    progressBar.classList.add('progress-bar');
    progressBar.style.cssText = `
        height: 100%;
        background-color: #2c5282;
        width: 0%;
        transition: width 0.1s linear;
    `;

    progressContainer.appendChild(progressBar);
    audioProgress.appendChild(progressContainer);

    const timeInfo = document.createElement('div');
    timeInfo.classList.add('audio-time');
    timeInfo.style.cssText = `
        display: flex;
        justify-content: space-between;
        color: #4a5568;
        font-size: 0.875rem;
        margin-bottom: 16px;
        font-weight: 500;
    `;

    const currentTimeSpan = document.createElement('span');
    currentTimeSpan.id = 'currentTime';
    currentTimeSpan.textContent = '0:00';

    const durationSpan = document.createElement('span');
    durationSpan.id = 'duration';
    durationSpan.textContent = '0:00';

    timeInfo.appendChild(currentTimeSpan);
    timeInfo.appendChild(durationSpan);

    const audioControls = document.createElement('div');
    audioControls.classList.add('audio-controls');
    audioControls.style.cssText = `
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 24px;
    `;

    const rewindBtn = createAudioButton('skip-backward', 'rewindBtn', 'Rewind 10 seconds');
    const playPauseBtn = createAudioButton('play', 'playPauseBtn', 'Play');
    const forwardBtn = createAudioButton('skip-forward', 'forwardBtn', 'Forward 10 seconds');

    audioControls.appendChild(rewindBtn);
    audioControls.appendChild(playPauseBtn);
    audioControls.appendChild(forwardBtn);

    audioPlayerContainer.appendChild(audio);
    audioPlayerContainer.appendChild(audioProgress);
    audioPlayerContainer.appendChild(timeInfo);
    audioPlayerContainer.appendChild(audioControls);

    return audioPlayerContainer;
}

function createAudioButton(iconName, id, ariaLabel) {
    const button = document.createElement('button');
    button.id = id;
    button.classList.add('audio-button');
    button.setAttribute('aria-label', ariaLabel);
    button.innerHTML = `<i class="bi bi-${iconName}"></i>`;
    button.style.cssText = `
        background-color: white;
        color: var(--primary-color);
        border: 2px solid var(--primary-color);
        border-radius: 50%;
        width: 55px;
        height: 55px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.3s ease;
    `;

    button.addEventListener('mouseover', () => {
        button.style.backgroundColor = 'var(--hover-color)';
    });

    button.addEventListener('mouseout', () => {
        button.style.backgroundColor = 'white';
    });

    button.addEventListener('click', () => {
        button.style.backgroundColor = 'var(--primary-color)';
        button.style.color = 'white';
        button.style.transform = 'scale(0.95)';
            
        setTimeout(() => {
            button.style.backgroundColor = 'white';
            button.style.color = 'var(--primary-color)';
            button.style.transform = 'scale(1)';
        }, 200);
    });

    return button;
}

function createBottomActionBar(location) {
    const actionBar = document.createElement('div');
    actionBar.classList.add('location-action-bar');
    actionBar.style.cssText = `
        width: 100%;
        height: 60px;
        background: linear-gradient(to right, #2c5282, #2b6cb0);
        margin-top: auto;
        box-shadow: 0 -2px 10px rgba(0,0,0,0.025);
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0 24px;
        position: sticky;
        bottom: 0;
    `;
        
    const imgSourceBtn = document.createElement('button');
    imgSourceBtn.classList.add('source-info-button', 'btn', 'btn-sm', 'me-2');
    imgSourceBtn.innerHTML = '<i class="bi bi-info-circle-fill text-white" style="font-size: 1.5rem;"></i>';
    imgSourceBtn.setAttribute('aria-label', 'Image source information');
    imgSourceBtn.onclick = () => {
        if (location && location.imageSource) {
            showSourcePopup('Image Source', location.imageSource);
        } else {
            showSourcePopup('Image Source', 'Image source information is not available');
        }
    };

    const feedbackButton = document.createElement('a');
    feedbackButton.href = 'mailto:mattreicher@protonmail.com?subject=Feedback';
    feedbackButton.target = '_blank';
    feedbackButton.rel = 'noopener noreferrer';
    feedbackButton.setAttribute('aria-label', 'Send feedback email');
    feedbackButton.innerHTML = '<i class="bi bi-envelope-fill text-white" style="font-size: 1.5rem;"></i>';
    feedbackButton.classList.add('feedback-email-button', 'btn', 'btn-sm');

    actionBar.appendChild(imgSourceBtn);
    actionBar.appendChild(feedbackButton);
    return actionBar;
}

// Completely new implementation of showPopup focused on image source
function showSourcePopup(title, content) {
    // Remove any existing popups first
    const existingPopup = document.getElementById('sourceInfoPopup');
    if (existingPopup) {
        document.body.removeChild(existingPopup);
    }
        
    // Create overlay container that covers the entire screen
    const overlay = document.createElement('div');
    overlay.id = 'sourceInfoPopup';
    overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 9999;
        backdrop-filter: blur(3px);
    `;

    // Create the popup content box
    const popup = document.createElement('div');
    popup.classList.add('source-info-content');
    popup.style.cssText = `
        background-color: white;
        border-radius: 8px;
        padding: 24px;
        width: 90%;
        max-width: 500px;
        max-height: 80vh;
        overflow-y: auto;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
        display: flex;
        flex-direction: column;
    `;

    // Create title
    const popupTitle = document.createElement('h3');
    popupTitle.textContent = title;
    popupTitle.style.cssText = `
        font-size: 1.5rem;
        font-weight: 600;
        color: #2c5282;
        margin-bottom: 16px;
        border-bottom: 1px solid #e2e8f0;
        padding-bottom: 12px;
    `;

    // Create content
    const popupContent = document.createElement('div');
    popupContent.style.cssText = `
        margin-bottom: 20px;
        line-height: 1.6;
        font-size: 1rem;
    `;
    popupContent.textContent = content;

    // Create close button
    const closeButton = document.createElement('button');
    closeButton.textContent = 'Close';
    closeButton.classList.add('source-close-button', 'btn');
    closeButton.style.cssText = `
        background: linear-gradient(to right, #2c5282, #2b6cb0);
        border: none;
        color: white;
        padding: 8px 24px;
        border-radius: 4px;
        font-weight: 500;
        cursor: pointer;
        align-self: flex-end;
        transition: all 0.2s ease;
    `;
        
    closeButton.addEventListener('mouseover', () => {
        closeButton.style.backgroundColor = '#2b6cb0';
    });
        
    closeButton.addEventListener('mouseout', () => {
        closeButton.style.backgroundColor = '#2c5282';
    });

    closeButton.addEventListener('click', () => {
        document.body.removeChild(overlay);
    });

    // Assemble the popup
    popup.appendChild(popupTitle);
    popup.appendChild(popupContent);
    popup.appendChild(closeButton);
    overlay.appendChild(popup);
    document.body.appendChild(overlay);
}

function returnToIndex() {
    window.location.href = 'https://www.mnthen.com/';
}

function initAudioPlayer() {
    const audio = document.getElementById('locationAudio');
    const playPauseBtn = document.getElementById('playPauseBtn');
    const rewindBtn = document.getElementById('rewindBtn');
    const forwardBtn = document.getElementById('forwardBtn');
    const progressBar = document.getElementById('progressBar');
    const currentTime = document.getElementById('currentTime');
    const duration = document.getElementById('duration');

    // Load metadata to get duration
    audio.addEventListener('loadedmetadata', () => {
        duration.textContent = formatTime(audio.duration);
    });

    // Play/Pause functionality
    playPauseBtn.addEventListener('click', () => {
        if (audio.paused) {
            audio.play();
            playPauseBtn.innerHTML = '<i class="bi bi-pause"></i>';
            playPauseBtn.setAttribute('aria-label', 'Pause');
        } else {
            audio.pause();
            playPauseBtn.innerHTML = '<i class="bi bi-play"></i>';
            playPauseBtn.setAttribute('aria-label', 'Play');
        }
    });

    // Rewind functionality
    rewindBtn.addEventListener('click', () => {
        audio.currentTime -= 10;
    });

    // Forward functionality
    forwardBtn.addEventListener('click', () => {
        audio.currentTime += 10;
    });

    // Update progress bar
    audio.addEventListener('timeupdate', () => {
        const progress = (audio.currentTime / audio.duration) * 100;
        progressBar.style.width = `${progress}%`;
        currentTime.textContent = formatTime(audio.currentTime);
    });

    // Progress bar click functionality
    const progressContainer = document.querySelector('.progress');
    progressContainer.addEventListener('click', (e) => {
        const width = progressContainer.offsetWidth;
        const clickX = e.offsetX;
        const songDuration = audio.duration;
        audio.currentTime = (clickX / width) * songDuration;
    });

    // Format time
    function formatTime(time) {
        const minutes = Math.floor(time / 60);
        const seconds = Math.floor(time - minutes * 60);
        return `${minutes}:${seconds < 10 ? '0' + seconds : seconds}`;
    }

    // Audio ended event
    audio.addEventListener('ended', () => {
        playPauseBtn.innerHTML = '<i class="bi bi-play"></i>';
        playPauseBtn.setAttribute('aria-label', 'Play');
        audio.currentTime = 0;
        progressBar.style.width = '0%';
        currentTime.textContent = '0:00';
    });
}

// Utility function to calculate distance between two coordinates using the Haversine formula
function calculateDistance(pos1, pos2) {
    const R = 6371e3; // Earth radius in meters
    const lat1 = pos1.lat * Math.PI / 180;
    const lat2 = pos2.lat * Math.PI / 180;
    const deltaLat = (pos2.lat - pos1.lat) * Math.PI / 180;
    const deltaLng = (pos2.lng - pos1.lng) * Math.PI / 180;

    const a = Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) +
              Math.cos(lat1) * Math.cos(lat2) *
              Math.sin(deltaLng / 2) * Math.sin(deltaLng / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

    return R * c;
}
</script>
</body>
</html>
