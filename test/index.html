<!DOCTYPE html>
 <html lang="en">
 <head> 
 <meta charset="UTF-8">
 <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
 <title>Minnesota Then | Museum Without Walls</title>
 <link rel="shortcut icon" type="image/x-icon" href="https://www.mnthen.com/images/mnthenfav.ico">
 <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
 <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css">
 <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.css" />
 <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css">
 <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css" />
 <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css" />
 <link rel="stylesheet" href="https://www.mnthen.com/css/mainmap.css">
 <link rel="stylesheet" href="https://www.mnthen.com/css/mnthen_main_map2.css">

 <style>
 .at-location {
 border: 2px solid red !important;
 box-shadow: 0 0 8px rgba(255, 0, 0, 0.5);
 transition: border-color 0.3s ease, box-shadow 0.3s ease;
 }
 
 /* Add styles for location transition */
 .location-transition {
 opacity: 0;
 transform: translateY(20px);
 transition: opacity 0.5s ease, transform 0.5s ease;
 }
 
 .location-transition.visible {
 opacity: 1;
 transform: translateY(0);
 }
 </style>
 
 </head>
 <body>
 <!-- Preloader -->
 <div id="preloader">
 <div class="preloader-content">
 <img class="logo" src="https://www.mnthen.com/images/logo.webp" alt="Minnesota Then Logo">
 <h1>Minnesota Then</h1>
 <h2>Every step tells a story.</h2>
 <p>Loading the Museum Without Walls</p>
 <div class="progress-container">
 <div class="progress-bar" id="preloaderProgress"></div>
 </div>
 </div>
 </div>

 <div id="map"></div>
 <div id="distanceBox">Initializing...</div>

 <div class="lochunt-container">
 <img id="locationImage" src="/placeholder.svg" alt="Location Image">
 <div class="lochunt-content">
 <div class="lochunt-info">
 <h2 id="locationTitle" class="mb-2 text-primary"></h2>
 <p id="locationCity" class="text-muted mb-1"></p>
 <p id="locationCreator" class="text-muted mb-3"></p>
 </div>
 <div class="audio-player">
 <div class="audio-progress">
 <div class="progress">
 <div id="progressBar" class="progress-bar" role="progressbar" style="width: 0%"></div>
 </div>
 </div>
 <div class="audio-time">
 <span id="currentTime">0:00</span>
 <span id="duration">0:00</span>
 </div>
 <div class="audio-controls">
 <button id="rewindBtn" class="audio-button"><i class="fas fa-backward"></i></button>
 <button id="playPauseBtn" class="audio-button"><i class="fas fa-play"></i></button>
 <button id="forwardBtn" class="audio-button"><i class="fas fa-forward"></i></button>
 </div>
 <audio id="locationAudio" src="/placeholder.svg"></audio>
 </div>
 </div>
 </div>
 
 <div class="additional-info-container">
 <h3 class="mb-3 text-primary text-center">Did You Know?</h3>
 <p id="additionalInfo" class="mb-3 fs-6"></p>
 <div class="d-flex justify-content-center">
 <button id="continueButton" class="btn btn-primary">Continue</button>
 </div>
 </div>
 
 <div class="map-buttons">
 <button id="recenterButton" class="map-button"><i class="fas fa-crosshairs"></i></button>
 <button id="returnButton" class="map-button"><i class="fas fa-sign-out-alt"></i></button>
 <button id="tipsButton" class="map-button"><i class="fas fa-question-circle"></i></button>
 </div>

 <div class="navigation-tips">
 <button class="close-button">×</button>
 <h3>Navigation Tips</h3>
 <ul>
 <li>Use the map to navigate to the marked locations.</li>
 <li>Tap the recenter button to focus on your current position.</li>
 <li>The distance box shows how far you are from the closest location.</li>
 <li>When you're within 20 feet of a location, you'll be able to interact with it.</li>
 <li>Listen to the audio information for each location.</li>
 <li>After the audio, you'll see additional information about the location.</li>
 </ul>
 </div>

 <div id="summaryModal" class="modal" style="display: none;">
 <div class="modal-content">
 <p id="summaryContent"></p>
 </div>
 </div>

 <script src="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.js"></script>
 <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
 <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"></script>
 
 <script src="/locations_test.js?v=1.0.4"></script>

 <script>
 // Global variables
 let map, userMarker, markerClusterGroup;
 let currentLocationIndex = 0;
 const visitedLocations = [];
 let gameLocations = [];
 let inactivityTimer;
 let isLocationHuntVisible = false;
 let lastPosition = null;
 let positionBuffer = [];
 const MAX_BUFFER_SIZE = 30; // buffer size for smoother tracking
 const DISTANCE_THRESHOLD = 20; // 20 feet to measure threshold distance to marker before opening location page.
 const PROXIMITY_THRESHOLD = 55; // 55 feet threshold for zoom changes
 let velocity = { lat: 0, lng: 0 };
 let isMapInteracting = false;
 let followUser = true;
 let locationCooldowns = {};
 let userIsInteracting = false;
 const preloadedImages = new Map(); // Map to store preloaded images
 const preloadedAudio = new Map(); // Map to store preloaded audio
 let currentSpeed = 0; // Current speed in meters per second
 let lastZoomLevel = 17; // Default zoom level
 let stationaryPositionHistory = []; // Array to store stationary positions for averaging
 let deviceOrientation = null; // Store device orientation data
 let deviceMotion = null; // Store device motion data
 let orientationPermissionGranted = false;
 let geolocationSensor = null; // Store GeolocationSensor instance
 let isNearLocation = false; // Flag to track if user is near a location
 let lastProximityCheck = 0; // Last time proximity was checked
 let isReturningFromExhibit = false; // Flag to track if returning from exhibit

let lastProximityDistance = Number.POSITIVE_INFINITY; // Last distance to nearest location

// Enhanced constants for better stabilization
 const MICRO_MOVEMENT_THRESHOLD = 0.3; // Meters - threshold for detecting micro-movements (reduced for better stability)
 const STATIONARY_ACCURACY_MULTIPLIER = 1.2; // Looser accuracy bounds to prevent false movement detection
 const MAX_ACCEPTABLE_ACCURACY = 25; // meters - more lenient accuracy requirement
 const STATIONARY_THRESHOLD = 2; // Number of consecutive stationary positions to consider user as stationary (reduced for faster stabilization)
 const STATIONARY_TIME_THRESHOLD = 3000; // ms - time to consider user stationary (reduced)
 const STATIONARY_CHECK_INTERVAL = 1000; // ms - interval to check if still stationary (reduced)
 const VELOCITY_DECAY = 0.92; // Higher value for smoother velocity transitions
 const MIN_DISTANCE_THRESHOLD = 1.0; // meters - minimum distance to consider movement (reduced)
 const EXTENDED_DISTANCE_THRESHOLD = 80; // meters - distance to consider a significant position change
 const UPDATE_INTERVAL = 50; // ms - more frequent updates for smoother movement
 const STATIONARY_POSITION_HISTORY_SIZE = 15; // Number of positions to keep for stationary averaging (increased)
 const STATIONARY_POSITION_WEIGHT_DECAY = 0.9; // Weight decay for older positions in stationary average (reduced)
 const SUDDEN_MOVEMENT_THRESHOLD = 0.8; // meters - threshold for detecting sudden movements (reduced)
 const POSITION_JUMP_THRESHOLD = 2.0; // meters - threshold for detecting position jumps (reduced)
 const ZOOM_CHANGE_COOLDOWN = 1500; // ms - cooldown between zoom changes

// Background handling constants
 const BACKGROUND_THRESHOLD = 15000; // ms - time to consider app was in background (reduced)
 const INACTIVITY_TIMEOUT = 20000; // ms - time to consider user inactive (reduced)

// Kalman filter parameters - optimized for better movement tracking
 const KALMAN_PROCESS_NOISE = 0.00001;
 const KALMAN_MEASUREMENT_NOISE_BASE = 0.1;
 const KALMAN_STATIONARY_NOISE = 0.000001;

// Animation parameters
 const ANIMATION_DURATION = 200; // ms - reduced duration of position animation for more responsive transitions
 const HEADING_SMOOTHING = 0.85; // Reduced heading smoothing factor for more responsive direction changes

// Zoom level parameters
 const MAX_ZOOM_LEVEL = 17; // Maximum zoom level (stationary)
 const MIN_ZOOM_LEVEL = 13; // Minimum zoom level (high speed)
 const WALKING_ZOOM_LEVEL = 17; // Zoom level for walking speed
 const WALKING_SPEED_THRESHOLD = 1.5; // m/s - threshold for walking speed
 const RUNNING_SPEED_THRESHOLD = 4.0; // m/s - threshold for running speed
 const DRIVING_SPEED_THRESHOLD = 10.0; // m/s - threshold for driving speed
 const ZOOM_TRANSITION_DURATION = 0.5; // seconds - reduced duration of zoom transition for more responsive zooming

// Motion detection parameters
 const MOTION_THRESHOLD = 0.8; // Reduced threshold for detecting significant motion
 const MOTION_SAMPLE_SIZE = 15; // Increased number of motion samples to keep
 const MOTION_CHECK_INTERVAL = 200; // ms - reduced interval to check motion for more responsive detection

// Edge recenter parameters - optimized for better edge recentering
 const EDGE_THRESHOLD_PERCENTAGE = 0.25; // Percentage of viewport to trigger recenter (reduced)
 const CRITICAL_EDGE_THRESHOLD = 0.125; // Critical threshold for emergency recenter (reduced)
 const RECENTER_COOLDOWN = 1500; // ms - minimum time between recenters (reduced)

// Speed accuracy parameters
 const SPEED_ACCURACY_THRESHOLD = 5.0; // 5 m/s accuracy is reasonable for most GPS systems

// State variables
 let lastUpdateTime = null;
 let lastVelocity = { lat: 0, lng: 0 };
 let isStationary = false;
 let stationaryStartTime = null;
 let stationaryCheckTimeout = null;
 let lastUpdateTimestamp = null;
 let lastHiddenTime = 0;
 let lastKnownPosition = null;
 let lastVisitedLocationId = null;
 let stationaryCount = 0;
 let lastSmoothedPosition = null;
 let lastRecenterTime = Date.now();
 let retryCount = 0;
 const stationaryBuffer = [];
 let isStabilizing = true; // Flag to track initial stabilization
 let lastStationaryPosition = null; // Last stable position when stationary
 const motionSamples = []; // Array to store motion samples
 let deviceStationaryTime = 0; // Time device has been stationary based on motion sensors
 let animationFrameId = null; // Store requestAnimationFrame ID
 let renderTimestamp = null; // Last render timestamp
 const positionUpdateQueue = []; // Queue for position updates to be processed
 let lastHeadingValue = null; // Last heading value
 const headingBuffer = []; // Buffer for heading values
 let isFirstPositionUpdate = true; // Flag for first position update
 let lastRenderPosition = null; // Last rendered position

// Position interpolator for smooth transitions
 const positionInterpolator = {
 currentAnimation: null,
 startTime: null,
 from: null,
 to: null,
 duration: 0,
 
 start: function(from, to, duration) {
 // Cancel any existing animation
 if (this.currentAnimation) {
 cancelAnimationFrame(this.currentAnimation);
 }
 
 // Store animation parameters
 this.startTime = performance.now();
 this.from = from;
 this.to = to;
 this.duration = duration;
 
 // Start animation
 this.update();
 },
 
 update: function() {
 if (!this.startTime) return;
 
 const currentTime = performance.now();
 const elapsed = currentTime - this.startTime;
 const progress = Math.min(elapsed / this.duration, 1);
 
 // Use easing for smoother motion (ease-out)
 const eased = 1 - Math.pow(1 - progress, 3);
 
 // Interpolate between positions
 const currentPosition = {
 lat: this.from.lat + (this.to.lat - this.from.lat) * eased,
 lng: this.from.lng + (this.to.lng - this.from.lng) * eased
 };
 
 // Update marker position
 updateUserMarkerPosition(currentPosition);
 lastRenderPosition = currentPosition;
 
 // Continue animation if not complete
 if (progress < 1) {
 this.currentAnimation = requestAnimationFrame(() => this.update());
 } else {
 this.currentAnimation = null;
 this.startTime = null;
 }
 },
 
 cancel: function() {
 if (this.currentAnimation) {
 cancelAnimationFrame(this.currentAnimation);
 this.currentAnimation = null;
 this.startTime = null;
 }
 },
 
 isInterpolating: function() {
 return this.currentAnimation !== null;
 }
 };
 
 let mapViewportWidth = 0; // Store map viewport width
 let mapViewportHeight = 0; // Store map viewport height
 let lastMapCenter = null; // Last map center position
 let lastMapZoom = null; // Last map zoom level
 let edgeRecenterInProgress = false; // Flag to track edge recentering
 const pendingDomUpdates = new Map(); // Map to store pending DOM updates
 let usingGeolocationSensorAPI = false; // Flag to track which geolocation API is being used
 let positionHistory = []; // Array to store recent position history for jump detection
 let suddenMovementCount = 0; // Counter for consecutive sudden movements
 let isJumpDetected = false; // Flag to track if a position jump is detected
 let stationaryPositionLocked = false; // Flag to indicate if stationary position is locked
 let stationaryPositionLockTime = 0; // Time when stationary position was locked
 let lastValidPosition = null; // Last valid position before a jump
 let stationaryLockTimeout = null; // Timeout for locking stationary position
 let lastZoomChangeTime = 0; // Last time zoom was changed due to proximity
 const lastAccuracy = Number.POSITIVE_INFINITY; // Last position accuracy
 const isAccuracyImproving = false; // Flag to track if accuracy is improving
 const highFrequencyUpdatesActive = false; // Flag to track if high frequency updates are active
 const highFrequencyUpdateTimeout = null; // Timeout for high frequency updates
 const lastHighFrequencyUpdateTime = 0; // Last time high frequency updates were activated
 const highFrequencyUpdateDuration = 5000; // ms - duration of high frequency updates
 const isPositionStable = false; // Flag to track if position is stable
 const positionStabilityThreshold = 5; // Number of consecutive stable positions to consider position stable
 const positionStabilityRadius = 2.0; // meters - radius for position stability
 const lastStablePosition = null; // Last stable position
 const stablePositionConfidence = 0; // Confidence in stable position (0-1)
 const isUsingHighAccuracy = true; // Flag to track if high accuracy is being used
 const highAccuracyFailureCount = 0; // Counter for high accuracy failures
 const maxHighAccuracyFailures = 3; // Maximum number of high accuracy failures before fallback
 const lastSuccessfulHighAccuracyUpdate = 0; // Last time a high accuracy update was successful
 const highAccuracyTimeout = 10000; // ms - timeout for high accuracy updates
 let isWatchPositionActive = false; // Flag to track if watchPosition is active
 let watchPositionId = null; // ID for watchPosition
 const lastWatchPositionUpdate = 0; // Last time watchPosition was updated
 const watchPositionUpdateInterval = 1000; // ms - interval for watchPosition updates
 const isUsingDeviceMotionForHeading = false; // Flag to track if device motion is being used for heading
 const lastCompassHeading = null; // Last compass heading
 const compassHeadingBuffer = []; // Buffer for compass heading values
 const compassHeadingBufferSize = 5; // Size of compass heading buffer
 const isCompassCalibrated = false; // Flag to track if compass is calibrated
 const compassCalibrationTimeout = null; // Timeout for compass calibration
 const compassCalibrationDuration = 5000; // ms - duration of compass calibration
 const lastCompassCalibrationTime = 0; // Last time compass was calibrated
 const isUsingGyroscopeForOrientation = false; // Flag to track if gyroscope is being used for orientation
 const gyroscopeData = null; // Gyroscope data
 const lastGyroscopeUpdateTime = 0; // Last time gyroscope was updated
 const gyroscopeUpdateInterval = 100; // ms - interval for gyroscope updates
 const isDeviceStationaryByMotion = false; // Flag to track if device is stationary based on motion sensors
 const deviceStationaryByMotionTime = 0; // Time device has been stationary based on motion sensors
 const deviceStationaryByMotionThreshold = 2000; // ms - threshold for device to be considered stationary by motion
 const deviceMotionMagnitude = 0; // Magnitude of device motion
 const deviceMotionMagnitudeBuffer = []; // Buffer for device motion magnitude values
 const deviceMotionMagnitudeBufferSize = 10; // Size of device motion magnitude buffer
 const deviceMotionMagnitudeThreshold = 0.5; // Threshold for device motion magnitude to be considered moving

// DOM update manager - batch DOM updates for better performance
 const domUpdateManager = {
 updates: new Map(),
 scheduled: false,

 // Schedule a DOM update
 schedule(id, updateFn) {
 this.updates.set(id, updateFn);

 if (!this.scheduled) {
 this.scheduled = true;
 requestAnimationFrame(() => this.flush());
 }
 },

 // Flush all scheduled DOM updates
 flush() {
 this.updates.forEach((updateFn) => {
 try {
 updateFn();
 } catch (error) {
 console.error("Error in DOM update:", error);
 }
 });
 this.updates.clear();
 this.scheduled = false;
 },
 };

// Enhanced Kalman Filter implementation
 class KalmanFilter {
 constructor() {
 // State vector [x, y, vx, vy]
 this.x = 0;
 this.y = 0;
 this.vx = 0;
 this.vy = 0;

 // Error covariance matrix
 this.P = [
 [100, 0, 0, 0], // Initial high uncertainty
 [0, 100, 0, 0],
 [0, 0, 10, 0],
 [0, 0, 0, 10],
 ];

 // Process noise
 this.Q = KALMAN_PROCESS_NOISE;

 // Measurement noise (will be adjusted based on GPS accuracy)
 this.R = KALMAN_MEASUREMENT_NOISE_BASE;

 // Time delta
 this.dt = 1.0;

 // Initialized flag
 this.initialized = false;

 // Heading and accuracy tracking
 this.lastHeading = null;
 this.headingConfidence = 0;

 // Stationary mode flag
 this.stationaryMode = false;
 this.stationaryStartTime = 0;

 // Last timestamp
 this.lastTimestamp = null;

 // Adaptive noise parameters
 this.adaptiveNoiseMin = 0.0002;
 this.adaptiveNoiseMax = 0.002;
 this.adaptiveNoiseFactor = 1.0;

 // Position history for jitter detection
 this.positionHistory = [];
 this.maxPositionHistory = 10;
 this.jitterThreshold = 0.35; // meters
 this.jitterCount = 0;

 // Stationary lock
 this.stationaryLocked = false;
 this.stationaryPosition = null;

 // Heading smoothing
 this.headingSmoothingFactor = 0.8;
 this.headingBuffer = [];
 this.headingBufferSize = 7;

 // Velocity smoothing
 this.velocitySmoothingFactor = 0.8;
 this.velocityBuffer = [];
 this.velocityBufferSize = 7;

 // Accuracy-based adaptation
 this.accuracyBuffer = [];
 this.accuracyBufferSize = 7;
 this.lastAccuracy = Number.POSITIVE_INFINITY;
 this.isAccuracyImproving = false;

 // Motion-based adaptation
 this.motionDetected = false;
 this.motionConfidence = 0;

 // Adaptive parameters based on device capabilities
 this.deviceCapabilitiesSet = false;
 this.deviceSupportsHighAccuracy = true;
 this.deviceSupportsMotionSensors = true;
 this.deviceSupportsOrientationSensors = true;

 // Innovation tracking to detect filter divergence
 this.innovationBuffer = [];
 this.innovationBufferSize = 10;
 this.innovationThreshold = 3.0; // standard deviations

 // GNSS receiver type (GPS, GLONASS, Galileo, etc)
 this.receiverType = "GPS";

 // Environment type (urban, rural, indoor, etc)
 this.environmentType = "mixed";
 }

 // Set device capabilities
 setDeviceCapabilities(highAccuracy, motionSensors, orientationSensors) {
 this.deviceCapabilitiesSet = true;
 this.deviceSupportsHighAccuracy = highAccuracy;
 this.deviceSupportsMotionSensors = motionSensors;
 this.deviceSupportsOrientationSensors = orientationSensors;

 // Adjust parameters based on device capabilities
 if (!highAccuracy) {
 this.adaptiveNoiseMin *= 1.5;
 this.adaptiveNoiseMax *= 1.5;
 this.jitterThreshold *= 1.5;
 }

 if (!motionSensors) {
 this.adaptiveNoiseMin *= 1.2;
 this.adaptiveNoiseMax *= 1.2;
 }

 if (!orientationSensors) {
 this.headingSmoothingFactor = 0.9;
 }

 return this;
 }

 // Set the type of GNSS receiver
 setReceiverType(type) {
 this.receiverType = type;

 // Adjust parameters based on receiver type
 switch (type.toUpperCase()) {
 case "GPS_GLONASS":
 case "MULTI_CONSTELLATION":
 this.adaptiveNoiseMin *= 0.8;
 this.adaptiveNoiseMax *= 0.8;
 break;
 case "BASIC_GPS":
 this.adaptiveNoiseMin *= 1.2;
 this.adaptiveNoiseMax *= 1.2;
 break;
 case "HIGH_PRECISION":
 this.adaptiveNoiseMin *= 0.5;
 this.adaptiveNoiseMax *= 0.5;
 break;
 }

 return this;
 }

 // Set the type of environment
 setEnvironmentType(type) {
 this.environmentType = type;

 // Adjust parameters based on environment type
 switch (type.toLowerCase()) {
 case "urban":
 this.adaptiveNoiseMin *= 1.3;
 this.adaptiveNoiseMax *= 1.3;
 this.jitterThreshold *= 0.9;
 break;
 case "rural":
 this.adaptiveNoiseMin *= 0.8;
 this.adaptiveNoiseMax *= 0.8;
 this.jitterThreshold *= 1.2;
 break;
 case "indoor":
 this.adaptiveNoiseMin *= 1.5;
 this.adaptiveNoiseMax *= 1.5;
 this.jitterThreshold *= 0.7;
 break;
 }

 return this;
 }

 // Initialize the filter with first position
 reset(position) {
 if (!position || typeof position.lat !== "number" || typeof position.lng !== "number") {
 console.error("Invalid position for Kalman filter reset");
 return;
 }

 this.x = position.lng;
 this.y = position.lat;
 this.vx = 0;
 this.vy = 0;

 // Reset covariance matrix with high initial uncertainty
 this.P = [
 [100, 0, 0, 0],
 [0, 100, 0, 0],
 [0, 0, 10, 0],
 [0, 0, 0, 10],
 ];

 this.initialized = true;
 this.lastHeading = position.heading || null;
 this.headingConfidence = 0;
 this.stationaryMode = false;
 this.lastTimestamp = position.timestamp || Date.now();
 this.adaptiveNoiseFactor = 1.0;
 this.positionHistory = [];
 this.jitterCount = 0;
 this.stationaryLocked = false;
 this.stationaryPosition = null;
 this.headingBuffer = [];
 this.velocityBuffer = [];
 this.accuracyBuffer = [];
 this.lastAccuracy = position.accuracy || Number.POSITIVE_INFINITY;
 this.isAccuracyImproving = false;
 this.motionDetected = false;
 this.motionConfidence = 0;
 this.innovationBuffer = [];

 return this;
 }

 // Set stationary mode
 setStationaryMode(isStationary) {
 this.stationaryMode = isStationary;

 // When entering stationary mode, reduce velocity to zero
 if (isStationary) {
 this.vx = 0;
 this.vy = 0;
 this.stationaryStartTime = Date.now();

 // Reduce process noise for stationary mode
 this.Q = KALMAN_STATIONARY_NOISE;
 this.adaptiveNoiseFactor = 0.03;
 } else {
 // Reset to normal process noise when moving
 this.Q = KALMAN_PROCESS_NOISE;
 this.adaptiveNoiseFactor = 1.0;
 this.stationaryLocked = false;
 this.stationaryPosition = null;
 }

 return this;
 }

 // Lock stationary position
 lockStationaryPosition(position) {
 if (!this.stationaryMode) return this;

 this.stationaryLocked = true;
 this.stationaryPosition = position;
 console.log("Kalman filter: Stationary position locked");

 return this;
 }

 // Update accuracy buffer and check if accuracy is improving
 updateAccuracyBuffer(accuracy) {
 if (isNaN(accuracy) || accuracy <= 0) {
 accuracy = this.lastAccuracy || 20;
 }

 this.accuracyBuffer.push(accuracy);
 while (this.accuracyBuffer.length > this.accuracyBufferSize) {
 this.accuracyBuffer.shift();
 }

 if (this.accuracyBuffer.length >= 3) {
 const avgRecent =
 (this.accuracyBuffer[this.accuracyBuffer.length - 1] + this.accuracyBuffer[this.accuracyBuffer.length - 2]) / 2;
 const avgOlder =
 (this.accuracyBuffer[0] + (this.accuracyBuffer.length > 1 ? this.accuracyBuffer[1] : this.accuracyBuffer[0])) /
 2;

 this.isAccuracyImproving = avgRecent < avgOlder;
 }

 this.lastAccuracy = accuracy;

 return this;
 }

 // Track innovation to detect filter divergence
 updateInnovationBuffer(innovation) {
 this.innovationBuffer.push(innovation);
 while (this.innovationBuffer.length > this.innovationBufferSize) {
 this.innovationBuffer.shift();
 }

 if (this.innovationBuffer.length >= 5) {
 // Calculate mean and standard deviation of innovations
 const sum = this.innovationBuffer.reduce((acc, val) => acc + val, 0);
 const mean = sum / this.innovationBuffer.length;

 const sumSquaredDiff = this.innovationBuffer.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0);
 const stdDev = Math.sqrt(sumSquaredDiff / this.innovationBuffer.length);

 // If innovation is consistently large, the filter might be diverging
 const latestInnovation = this.innovationBuffer[this.innovationBuffer.length - 1];
 if (Math.abs(latestInnovation - mean) > this.innovationThreshold * stdDev) {
 // Increase uncertainty to force filter to trust measurements more
 for (let i = 0; i < 4; i++) {
 this.P[i][i] *= 2.0;
 }
 }
 }

 return this;
 }

 // Detect jitter in position updates
 detectJitter(newPosition) {
 if (this.positionHistory.length === 0) {
 this.positionHistory.push(newPosition);
 return false;
 }

 const lastPos = this.positionHistory[this.positionHistory.length - 1];
 const distance = calculateDistance(lastPos, newPosition);

 // Add to history
 this.positionHistory.push(newPosition);
 while (this.positionHistory.length > this.maxPositionHistory) {
 this.positionHistory.shift();
 }

 // Check for rapid back-and-forth movement (jitter)
 if (this.positionHistory.length >= 3 && this.stationaryMode) {
 const pos1 = this.positionHistory[this.positionHistory.length - 3];
 const pos2 = this.positionHistory[this.positionHistory.length - 2];
 const pos3 = this.positionHistory[this.positionHistory.length - 1];

 const dist1 = calculateDistance(pos1, pos2);
 const dist2 = calculateDistance(pos2, pos3);

 // If moving back and forth in small distances
 if (
 dist1 < this.jitterThreshold &&
 dist2 < this.jitterThreshold &&
 Math.sign(pos3.lat - pos2.lat) !== Math.sign(pos2.lat - pos1.lat) &&
 Math.sign(pos3.lng - pos2.lng) !== Math.sign(pos2.lng - pos1.lng)
 ) {
 this.jitterCount++;
 return this.jitterCount > 1;
 }
 }

 // Reset jitter count if no jitter detected
 if (distance > this.jitterThreshold) {
 this.jitterCount = 0;
 }

 return false;
 }

 // Smooth heading values
 smoothHeading(newHeading) {
 if (newHeading === null || newHeading === undefined || isNaN(newHeading)) {
 return this.lastHeading;
 }

 // Normalize to 0-360
 newHeading = ((newHeading % 360) + 360) % 360;

 // Add to heading buffer
 this.headingBuffer.push(newHeading);
 while (this.headingBuffer.length > this.headingBufferSize) {
 this.headingBuffer.shift();
 }

 if (this.headingBuffer.length < 2) {
 return newHeading;
 }

 // Use median filter to remove outliers
 if (this.headingBuffer.length >= 3) {
 const sortedHeadings = [...this.headingBuffer].sort((a, b) => a - b);
 const medianHeading = sortedHeadings[Math.floor(sortedHeadings.length / 2)];

 // If new heading is very different from median, it might be an outlier
 const headingDiff = Math.abs(((newHeading - medianHeading + 180) % 360) - 180);
 if (headingDiff > 45 && this.headingConfidence > 0.5) {
 // Use median instead of potentially erroneous new heading
 newHeading = medianHeading;
 }
 }

 // If we have a previous heading, smooth the transition
 if (this.lastHeading !== null) {
 // Normalize headings to 0-360
 const normalizedCurrent = ((newHeading % 360) + 360) % 360;
 const normalizedLast = ((this.lastHeading % 360) + 360) % 360;

 // Calculate the smallest angle between the two headings
 let diff = normalizedCurrent - normalizedLast;
 if (diff > 180) diff -= 360;
 if (diff < -180) diff += 360;

 // Apply adaptive smoothing based on motion and stationary state
 let headingWeight = this.headingSmoothingFactor;
 if (this.stationaryMode) {
 headingWeight = 0.05; // Very smooth when stationary
 } else if (this.motionDetected) {
 headingWeight = Math.min(0.4, headingWeight * (1 + this.motionConfidence)); // More responsive when motion detected
 }

 // Apply smoothing
 const smoothedHeading = normalizedLast + diff * (1 - headingWeight);

 // Normalize back to 0-360
 return ((smoothedHeading % 360) + 360) % 360;
 }

 return newHeading;
 }

 // Smooth velocity values
 smoothVelocity(vx, vy) {
 const speed = Math.sqrt(vx * vx + vy * vy);

 this.velocityBuffer.push(speed);
 while (this.velocityBuffer.length > this.velocityBufferSize) {
 this.velocityBuffer.shift();
 }

 if (this.velocityBuffer.length < 2) {
 return { vx, vy };
 }

 // Calculate median velocity to filter outliers
 if (this.velocityBuffer.length >= 3) {
 const sortedVelocities = [...this.velocityBuffer].sort((a, b) => a - b);
 const medianVelocity = sortedVelocities[Math.floor(sortedVelocities.length / 2)];

 const currentVelocity = speed;

 // If current velocity is drastically different from median, scale it
 if (currentVelocity > medianVelocity * 2) {
 const scale = (medianVelocity * 2) / currentVelocity;
 vx *= scale;
 vy *= scale;
 }
 }

 return { vx, vy };
 }

 // Adjust process noise based on accuracy, motion, and device capabilities
 adjustProcessNoise(accuracy, motionDetected) {
 // Update accuracy buffer and check if accuracy is improving
 this.updateAccuracyBuffer(accuracy);

 // Update motion detection state
 this.motionDetected = motionDetected;
 if (motionDetected) {
 this.motionConfidence = Math.min(1.0, this.motionConfidence + 0.1);
 } else {
 this.motionConfidence = Math.max(0.0, this.motionConfidence - 0.05);
 }

 // Base noise level depends on GPS accuracy
 let noiseLevel =
 this.adaptiveNoiseMin + (this.adaptiveNoiseMax - this.adaptiveNoiseMin) * Math.min(1.0, accuracy / 30.0);

 // Reduce noise when stationary
 if (this.stationaryMode) {
 noiseLevel *= 0.03;
 }

 // Increase noise when motion is detected
 if (this.motionDetected && !this.stationaryMode) {
 noiseLevel *= 1.0 + this.motionConfidence;
 }

 // Adjust based on accuracy trend
 if (this.isAccuracyImproving) {
 noiseLevel *= 0.9;
 } else {
 noiseLevel *= 1.1;
 }

 // Apply adaptive factor
 noiseLevel *= this.adaptiveNoiseFactor;

 // Set process noise
 this.Q = noiseLevel;

 return this;
 }

 // Update the filter with new measurement
 update(position, motionDetected = false) {
 if (!this.initialized) {
 this.reset(position);
 return position;
 }

 if (!position || typeof position.lat !== "number" || typeof position.lng !== "number") {
 console.warn("Invalid position input to Kalman filter");
 return {
 lat: this.y,
 lng: this.x,
 accuracy: position?.accuracy || 20,
 heading: this.lastHeading,
 timestamp: position?.timestamp || Date.now(),
 };
 }

 // If we're in stationary mode and have a locked position, return the locked position
 if (this.stationaryMode && this.stationaryLocked && this.stationaryPosition) {
 return {
 lat: this.stationaryPosition.lat,
 lng: this.stationaryPosition.lng,
 accuracy: position.accuracy,
 heading: this.smoothHeading(position.heading),
 timestamp: position.timestamp,
 speedMPS: 0,
 };
 }

 // Calculate time delta
 const timestamp = position.timestamp || Date.now();
 if (this.lastTimestamp) {
 this.dt = Math.min(Math.max((timestamp - this.lastTimestamp) / 1000, 0.01), 1.0);
 }
 this.lastTimestamp = timestamp;

 // Check for jitter
 const isJittering = this.detectJitter(position);

 // Adjust measurement noise based on GPS accuracy and jitter
 const accuracy = position.accuracy || 20;
 this.R = Math.max(KALMAN_MEASUREMENT_NOISE_BASE, accuracy / 5);

 // If in stationary mode, increase measurement noise to reduce jitter
 if (this.stationaryMode) {
 this.R *= 5.0;
 }

 // If jittering is detected, increase measurement noise significantly
 if (isJittering) {
 this.R *= 10.0;
 }

 // Adjust process noise based on accuracy and motion
 this.adjustProcessNoise(accuracy, motionDetected);

 // State transition matrix
 const F = [
 [1, 0, this.dt, 0],
 [0, 1, 0, this.dt],
 [0, 0, 1, 0],
 [0, 0, 0, 1],
 ];

 // Predict step
 // x = F * x
 const predictedX = this.x + this.dt * this.vx;
 const predictedY = this.y + this.dt * this.vy;
 const predictedVx = this.stationaryMode ? 0 : this.vx;
 const predictedVy = this.stationaryMode ? 0 : this.vy;

 // P = F * P * F' + Q
 const Q = [
 [(this.Q * this.dt * this.dt * this.dt * this.dt) / 4, 0, (this.Q * this.dt * this.dt * this.dt) / 2, 0],
 [0, (this.Q * this.dt * this.dt * this.dt * this.dt) / 4, 0, (this.Q * this.dt * this.dt * this.dt) / 2],
 [(this.Q * this.dt * this.dt * this.dt) / 2, 0, this.Q * this.dt * this.dt, 0],
 [0, (this.Q * this.dt * this.dt * this.dt) / 2, 0, this.Q * this.dt * this.dt],
 ];

 // Matrix multiplication F * P
 const FP = [
 [
 this.P[0][0] + this.dt * this.P[2][0],
 this.P[0][1] + this.dt * this.P[2][1],
 this.P[0][2] + this.dt * this.P[2][2],
 this.P[0][3] + this.dt * this.P[2][3],
 ],
 [
 this.P[1][0] + this.dt * this.P[3][0],
 this.P[1][1] + this.dt * this.P[3][1],
 this.P[1][2] + this.dt * this.P[3][2],
 this.P[1][3] + this.dt * this.P[3][3],
 ],
 [this.P[2][0], this.P[2][1], this.P[2][2], this.P[2][3]],
 [this.P[3][0], this.P[3][1], this.P[3][2], this.P[3][3]],
 ];

 // Matrix multiplication FP * F'
 const predictedP = [
 [
 FP[0][0] + this.dt * FP[0][2] + Q[0][0],
 FP[0][1] + this.dt * FP[0][3] + Q[0][1],
 FP[0][2] + Q[0][2],
 FP[0][3] + Q[0][3],
 ],
 [
 FP[1][0] + this.dt * FP[1][2] + Q[1][0],
 FP[1][1] + this.dt * FP[1][3] + Q[1][1],
 FP[1][2] + Q[1][2],
 FP[1][3] + Q[1][3],
 ],
 [FP[2][0] + Q[2][0], FP[2][1] + Q[2][1], FP[2][2] + Q[2][2], FP[2][3] + Q[2][3]],
 [FP[3][0] + Q[3][0], FP[3][1] + Q[3][1], FP[3][2] + Q[3][2], FP[3][3] + Q[3][3]],
 ];

 // Update step
 // y = z - H * x
 const measurementResidualX = position.lng - predictedX;
 const measurementResidualY = position.lat - predictedY;

 // Track innovation to detect filter divergence
 const innovation = Math.sqrt(
 measurementResidualX * measurementResidualX + measurementResidualY * measurementResidualY,
 );
 this.updateInnovationBuffer(innovation);

 // S = H * P * H' + R
 const S = [
 [predictedP[0][0] + this.R, predictedP[0][1]],
 [predictedP[1][0], predictedP[1][1] + this.R],
 ];

 // Calculate determinant of S
 const detS = S[0][0] * S[1][1] - S[0][1] * S[1][0];

 // Calculate inverse of S
 const invS = [
 [S[1][1] / detS, -S[0][1] / detS],
 [-S[1][0] / detS, S[0][0] / detS],
 ];

 // K = P * H' * inv(S)
 const K = [
 [
 predictedP[0][0] * invS[0][0] + predictedP[0][1] * invS[1][0],
 predictedP[0][0] * invS[0][1] + predictedP[0][1] * invS[1][1],
 ],
 [
 predictedP[1][0] * invS[0][0] + predictedP[1][1] * invS[1][0],
 predictedP[1][0] * invS[0][1] + predictedP[1][1] * invS[1][1],
 ],
 [
 predictedP[2][0] * invS[0][0] + predictedP[2][1] * invS[1][0],
 predictedP[2][0] * invS[0][1] + predictedP[2][1] * invS[1][1],
 ],
 [
 predictedP[3][0] * invS[0][0] + predictedP[3][1] * invS[1][0],
 predictedP[3][0] * invS[0][1] + predictedP[3][1] * invS[1][1],
 ],
 ];

 // x = x + K * y
 this.x = predictedX + K[0][0] * measurementResidualX + K[0][1] * measurementResidualY;
 this.y = predictedY + K[1][0] * measurementResidualX + K[1][1] * measurementResidualY;

 // In stationary mode, keep velocity at zero
 if (this.stationaryMode) {
 this.vx = 0;
 this.vy = 0;
 } else {
 this.vx = predictedVx + K[2][0] * measurementResidualX + K[2][1] * measurementResidualY;
 this.vy = predictedVy + K[3][0] * measurementResidualX + K[3][1] * measurementResidualY;

 // Smooth velocity
 const smoothedVelocity = this.smoothVelocity(this.vx, this.vy);
 this.vx = smoothedVelocity.vx;
 this.vy = smoothedVelocity.vy;
 }

 // P = (I - K * H) * P
 this.P = [
 [
 predictedP[0][0] - (K[0][0] * predictedP[0][0] + K[0][1] * predictedP[1][0]),
 predictedP[0][1] - (K[0][0] * predictedP[0][1] + K[0][1] * predictedP[1][1]),
 predictedP[0][2] - (K[0][0] * predictedP[0][2] + K[0][1] * predictedP[1][2]),
 predictedP[0][3] - (K[0][0] * predictedP[0][3] + K[0][1] * predictedP[1][3]),
 ],
 [
 predictedP[1][0] - (K[1][0] * predictedP[0][0] + K[1][1] * predictedP[1][0]),
 predictedP[1][1] - (K[1][0] * predictedP[0][1] + K[1][1] * predictedP[1][1]),
 predictedP[1][2] - (K[1][0] * predictedP[0][2] + K[1][1] * predictedP[1][2]),
 predictedP[1][3] - (K[1][0] * predictedP[0][3] + K[1][1] * predictedP[1][3]),
 ],
 [
 predictedP[2][0] - (K[2][0] * predictedP[0][0] + K[2][1] * predictedP[1][0]),
 predictedP[2][1] - (K[2][0] * predictedP[0][1] + K[2][1] * predictedP[1][1]),
 predictedP[2][2] - (K[2][0] * predictedP[0][2] + K[2][1] * predictedP[1][2]),
 predictedP[2][3] - (K[2][0] * predictedP[0][3] + K[2][1] * predictedP[1][3]),
 ],
 [
 predictedP[3][0] - (K[3][0] * predictedP[0][0] + K[3][1] * predictedP[1][0]),
 predictedP[3][1] - (K[3][0] * predictedP[0][1] + K[3][1] * predictedP[1][1]),
 predictedP[3][2] - (K[3][0] * predictedP[0][2] + K[3][1] * predictedP[1][2]),
 predictedP[3][3] - (K[3][0] * predictedP[0][3] + K[3][1] * predictedP[1][3]),
 ],
 ];

 // Process heading data
 const smoothedHeading = this.smoothHeading(position.heading);
 this.lastHeading = smoothedHeading;

 // Calculate speed from velocity components
 const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);

 // Create filtered position
 const filteredPosition = {
 lat: this.y,
 lng: this.x,
 accuracy: position.accuracy,
 heading: smoothedHeading,
 timestamp: position.timestamp,
 speedMPS: this.stationaryMode ? 0 : speed * 111000, // Convert from degrees/second to meters/second (approximate)
 };

 // If we're in stationary mode and don't have a locked position yet,
 // check if we should lock the position
 if (this.stationaryMode && !this.stationaryLocked && this.stationaryStartTime) {
 // If we've been stationary for a while, lock the position
 if (Date.now() - this.stationaryStartTime > 2000) {
 this.lockStationaryPosition(filteredPosition);
 }
 }

 return filteredPosition;
 }
 }

// Create tracking system with Kalman filter
 const tracking = {
 filter: new KalmanFilter(),
 
 update(position, motionDetected = false, interpolationDuration = 300) {
 // First update the filter
 const filteredPosition = this.filter.update(position, motionDetected);
 
 // Return the filtered position
 return filteredPosition;
 }
 };

// Utility function to calculate distance between two coordinates
 function calculateDistance(pos1, pos2) {
 if (
 !pos1 ||
 !pos2 ||
 typeof pos1.lat !== "number" ||
 typeof pos1.lng !== "number" ||
 typeof pos2.lat !== "number" ||
 typeof pos2.lng !== "number"
 ) {
 return Number.POSITIVE_INFINITY;
 }

 // Haversine formula for more accurate distance calculation
 const R = 6371000; // Earth radius in meters
 const lat1 = (pos1.lat * Math.PI) / 180;
 const lat2 = (pos2.lat * Math.PI) / 180;
 const deltaLat = ((pos2.lat - pos1.lat) * Math.PI) / 180;
 const deltaLng = ((pos2.lng - pos1.lng) * Math.PI) / 180;

 const a =
 Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) +
 Math.cos(lat1) * Math.cos(lat2) * Math.sin(deltaLng / 2) * Math.sin(deltaLng / 2);
 const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

 return R * c;
 }

// Check if device is in motion based on motion sensors
 function isDeviceInMotion() {
 if (!motionSamples || motionSamples.length < 3) {
 return false;
 }

 // Calculate average motion magnitude
 const avgMotion = motionSamples.reduce((sum, sample) => {
 return sum + Math.sqrt(sample.x * sample.x + sample.y * sample.y + sample.z * sample.z);
 }, 0) / motionSamples.length;

 return avgMotion > MOTION_THRESHOLD;
 }

// Process device motion data
 function handleDeviceMotion(event) {
 if (!event || !event.acceleration) return;

 const motion = {
 x: event.acceleration.x || 0,
 y: event.acceleration.y || 0,
 z: event.acceleration.z || 0,
 timestamp: Date.now(),
 };

 // Add to motion samples
 motionSamples.push(motion);

 // Keep only recent samples
 while (motionSamples.length > MOTION_SAMPLE_SIZE) {
 motionSamples.shift();
 }

 // Update device motion state
 deviceMotion = motion;

 // Check if device is stationary based on motion
 const inMotion = isDeviceInMotion();

 if (!inMotion) {
 deviceStationaryTime += MOTION_CHECK_INTERVAL;
 } else {
 deviceStationaryTime = 0;
 }
 }

// Process device orientation data
 function handleDeviceOrientation(event) {
 if (!event || event.alpha === null) return;

 deviceOrientation = {
 alpha: event.alpha, // z-axis rotation [0,360)
 beta: event.beta, // x-axis rotation [-180,180)
 gamma: event.gamma, // y-axis rotation [-90,90)
 timestamp: Date.now(),
 };

 // Update heading buffer if we have a compass heading
 if (event.webkitCompassHeading !== undefined) {
 const heading = event.webkitCompassHeading;

 // Add to heading buffer
 headingBuffer.push(heading);

 // Keep only recent headings
 while (headingBuffer.length > 5) {
 headingBuffer.shift();
 }

 // Calculate median heading to filter outliers
 if (headingBuffer.length >= 3) {
 const sortedHeadings = [...headingBuffer].sort((a, b) => a - b);
 lastHeadingValue = sortedHeadings[Math.floor(sortedHeadings.length / 2)];
 }
 }
 }

// Request device motion and orientation permissions
 function requestMotionPermission() {
 if (typeof DeviceMotionEvent !== "undefined" && typeof DeviceMotionEvent.requestPermission === "function") {
 DeviceMotionEvent.requestPermission()
 .then((response) => {
 if (response === "granted") {
 window.addEventListener("devicemotion", handleDeviceMotion, true);
 }
 })
 .catch(console.error);
 } else {
 window.addEventListener("devicemotion", handleDeviceMotion, true);
 }

 if (typeof DeviceOrientationEvent !== "undefined" && typeof DeviceOrientationEvent.requestPermission === "function") {
 DeviceOrientationEvent.requestPermission()
 .then((response) => {
 if (response === "granted") {
 orientationPermissionGranted = true;
 window.addEventListener("deviceorientation", handleDeviceOrientation, true);
 }
 })
 .catch(console.error);
 } else {
 window.addEventListener("deviceorientation", handleDeviceOrientation, true);
 orientationPermissionGranted = true;
 }
 }

// Animation loop for smooth rendering
 function startAnimationLoop() {
 // Local variables for optimization (not visible outside)
 let _frameCount = 0;
 let _lastFpsTime = 0;
 let _totalFrames = 0;
 let _accumulatedTime = 0;
 let _frameInterval = 16.667; // ms (60fps)
 let _skipThreshold = 16; // ms
 let _lowPerformanceMode = false;
 let _proximityCheckFrequency = 1;
 
 function animate(timestamp) {
 // Calculate delta time
 const deltaTime = renderTimestamp ? (timestamp - renderTimestamp) / 1000 : 0;
 renderTimestamp = timestamp;
 
 // Performance tracking (hidden implementation detail)
 if (!_lastFpsTime) _lastFpsTime = timestamp;
 _frameCount++;
 _totalFrames++;
 if (timestamp - _lastFpsTime > 1000) {
 const fps = Math.round((_frameCount * 1000) / (timestamp - _lastFpsTime));
 _lowPerformanceMode = fps < 30;
 _proximityCheckFrequency = _lowPerformanceMode ? 3 : 1;
 _frameCount = 0;
 _lastFpsTime = timestamp;
 }
 
 // Frame limiting (hidden implementation detail)
 _accumulatedTime += deltaTime * 1000;
 if (_accumulatedTime < _skipThreshold) {
 animationFrameId = requestAnimationFrame(animate);
 return;
 }

 try {
 // Process position updates
 processPositionUpdateQueue();

 // Update interpolated position
 if (positionInterpolator && positionInterpolator.isInterpolating()) {
 positionInterpolator.update();
 }

 // Check if marker is near edge and recenter if needed
 if (followUser && !isMapInteracting && !edgeRecenterInProgress) {
 const recenterInfo = shouldRecenter(map, userMarker);
 if (recenterInfo.needsRecenter) {
 performEdgeRecenter(recenterInfo);
 }
 }

 // Check proximity to locations for zoom adjustments
 // Optimized to run less frequently on low-performance devices
 if (_totalFrames % _proximityCheckFrequency === 0) {
 checkLocationProximity();
 }
 
 // Reset accumulated time (hidden implementation detail)
 _accumulatedTime -= _frameInterval;
 if (_accumulatedTime > _frameInterval * 2) {
 _accumulatedTime = _frameInterval;
 }

 // Request next frame
 animationFrameId = requestAnimationFrame(animate);
 } catch (error) {
 // Error handling (hidden implementation detail)
 console.error('Error in animation loop:', error);
 animationFrameId = requestAnimationFrame(animate);
 }
 }

 // Start animation loop
 animationFrameId = requestAnimationFrame(animate);
 }

// Process queued position updates
 function processPositionUpdateQueue() {
 // Skip if no updates in queue
 if (positionUpdateQueue.length === 0) return;
 
 // Process all updates in the queue
 while (positionUpdateQueue.length > 0) {
 const update = positionUpdateQueue.shift();
 
 // Apply the update (assuming update contains position data)
 if (update && update.coords) {
 const position = {
 lat: update.coords.latitude,
 lng: update.coords.longitude,
 accuracy: update.coords.accuracy,
 heading: update.coords.heading,
 speedMPS: update.coords.speed,
 speedAccuracy: update.coords.speedAccuracy,
 timestamp: update.timestamp
 };
 
 // Process the position update
 processPositionUpdate(position);
 }
 }
 }

// Update user marker position and rotation
 function updateUserMarkerPosition(position) {
 if (!userMarker) return;

 // Update marker position
 userMarker.setLatLng([position.lat, position.lng]);

 // Update marker rotation based on heading if available
 if (position.heading !== undefined && position.heading !== null) {
 // Get the marker element
 const markerElement = userMarker.getElement();
 if (markerElement) {
 // Find the direction indicator element
 const directionElement = markerElement.querySelector(".user-marker-direction");
 if (directionElement) {
 // Update the rotation of the direction indicator
 directionElement.style.transform = `rotate(${position.heading}deg)`;
 }
 }
 }

 // Apply visual effects based on speed
 if (position.speedMPS !== undefined) {
 const markerElement = userMarker.getElement();
 if (markerElement) {
 const iconElement = markerElement.querySelector(".user-marker-icon");
 if (iconElement) {
 // Add pulsing effect when moving
 if (position.speedMPS > 0.5) {
 iconElement.classList.add("pulsing");
 // Adjust pulse speed based on movement speed
 const pulseRate = Math.max(0.5, Math.min(2.0, 1.0 + position.speedMPS / 5));
 iconElement.style.animationDuration = `${1 / pulseRate}s`;
 } else {
 iconElement.classList.remove("pulsing");
 }
 }
 }
 }
 }

// Process position update
 function processPositionUpdate(position) {
 // Skip if invalid position
 if (!position || typeof position.lat !== "number" || typeof position.lng !== "number") {
 return;
 }

 // CRITICAL PATH: Handle large position changes differently
 // When position changes dramatically (e.g., GPS jump, returning from background, 
 // or first accurate fix after poor signal), we want to:
 // 1. Skip the smooth interpolation to avoid "rubber-banding" across the map
 // 2. Update the marker position immediately
 // 3. Reset the render position to this new position
 // This prevents disorienting visual effects when position changes significantly
 if (lastRenderPosition && calculateDistance(lastRenderPosition, position) > EXTENDED_DISTANCE_THRESHOLD) {
 console.debug(`Large position change detected (${calculateDistance(lastRenderPosition, position).toFixed(2)}m). Skipping interpolation.`);
 updateUserMarkerPosition(position); // Direct update without animation
 lastRenderPosition = position;
 return; // Skip the rest of the interpolation logic
 }

 // Normal case: Apply smooth interpolation between positions
 if (lastRenderPosition && !isFirstPositionUpdate) {
 if (positionInterpolator) {
 // Use slower animation when stationary for more stability
 positionInterpolator.start(
 lastRenderPosition, 
 position,
 isStationary ? 300 : ANIMATION_DURATION,
 );
 } else {
 console.warn("Position interpolator not available, using direct position update");
 updateUserMarkerPosition(position);
 lastRenderPosition = position;
 }
 } else {
 // First position update - set directly without animation
 updateUserMarkerPosition(position);
 lastRenderPosition = position;
 isFirstPositionUpdate = false;
 }

 // Handle auto-recentering and zoom adjustments
 if (followUser && !isMapInteracting) {
 const recenterInfo = shouldRecenter(map, userMarker);
 if (recenterInfo.needsRecenter) {
 performEdgeRecenter(recenterInfo);
 } else if (Math.abs(map.getZoom() - calculateZoomLevel(position.speedMPS)) > 0.5) {
 const newZoom = calculateZoomLevel(position.speedMPS);
 map.setZoom(newZoom, {
 animate: true,
 duration: ZOOM_TRANSITION_DURATION,
 });
 }
 }
 }

// Perform edge recentering with smoother transitions based on speed
 function performEdgeRecenter(recenterInfo) {
 edgeRecenterInProgress = true;
 
 // Get current position
 const position = userMarker.getLatLng();
 
 // Get current speed (in meters per second)
 const currentSpeed = lastPosition?.speedMPS || 0;
 
 // Only trust GPS-reported speed, not calculated from position changes
 // This helps filter out device movements like shaking
 const isGenuineMovement = lastPosition?.hasOwnProperty('speedAccuracy') && 
 lastPosition.speedAccuracy < SPEED_ACCURACY_THRESHOLD;
 
 // Use a conservative speed value if we're not confident in the movement
 const reliableSpeed = isGenuineMovement ? currentSpeed : Math.min(currentSpeed, 1.0);
 
 // Calculate appropriate zoom level based on reliable speed
 const dynamicZoom = calculateZoomLevel(reliableSpeed);
 
 // Get current map center
 const currentCenter = map.getCenter();
 
 // Calculate optimal center point that keeps the user icon away from edges
 const optimalCenter = calculateOptimalCenter(map, position, recenterInfo.edgeInfo);
 
 // Calculate edge proximity using your existing function
 const proximity = calculateEdgeProximity(map, position);
 
 // Find the minimum proximity (closest edge)
 const minProximity = Math.min(proximity.north, proximity.south, proximity.east, proximity.west);
 
 // Calculate speed factor (0-1) based on reliable speed
 const SPEED_THRESHOLD_SLOW = 2.0;
 const SPEED_THRESHOLD_FAST = 10.0;
 const speedFactor = Math.min(1, Math.max(0, (reliableSpeed - SPEED_THRESHOLD_SLOW) / 
 (SPEED_THRESHOLD_FAST - SPEED_THRESHOLD_SLOW)));
 
 // Calculate combined transition factor
 const baseTransitionFactor = Math.max(0.3, Math.min(0.8, minProximity * 2));
 const speedAdjustedFactor = baseTransitionFactor - (speedFactor * 0.3);
 
 // Blend current and optimal centers for smoother transition
 const blendedCenter = {
 lat: currentCenter.lat + (optimalCenter.lat - currentCenter.lat) * (1 - speedAdjustedFactor),
 lng: currentCenter.lng + (optimalCenter.lng - currentCenter.lng) * (1 - speedAdjustedFactor)
 };
 
 // Only apply forward bias for genuine GPS movement
 let adjustedCenter = blendedCenter;
 if (lastPosition && isGenuineMovement) {
 const direction = {
 lat: position.lat - lastPosition.lat,
 lng: position.lng - lastPosition.lng
 };
 
 // Calculate movement magnitude
 const movement = Math.sqrt(direction.lat * direction.lat + direction.lng * direction.lng);
 
 // Only apply forward bias if moving significantly
 if (movement > 0.00001) {
 // Apply forward bias scaled to speed
 const forwardBiasAmount = 0.00005 + (speedFactor * 0.0001);
 
 // Normalize direction and apply forward bias
 adjustedCenter = {
 lat: blendedCenter.lat + (direction.lat / movement) * forwardBiasAmount,
 lng: blendedCenter.lng + (direction.lng / movement) * forwardBiasAmount
 };
 }
 }
 
 // Calculate duration based on reliable speed
 const baseDuration = recenterInfo.isEmergency ? 0.2 : ZOOM_TRANSITION_DURATION;
 const speedAdjustedDuration = baseDuration * (1 - (speedFactor * 0.5));
 
 // Set view with animation
 map.setView([adjustedCenter.lat, adjustedCenter.lng], dynamicZoom, {
 animate: true,
 duration: speedAdjustedDuration,
 noMoveStart: true,
 easeLinearity: 0.3 + (speedFactor * 0.2)
 });
 
 // Reset edge recenter flag after animation completes
 setTimeout(
 () => {
 edgeRecenterInProgress = false;
 },
 recenterInfo.isEmergency ? 300 : speedAdjustedDuration * 1000,
 );
 }

// Calculate appropriate zoom level based on speed with device movement filtering
 function calculateZoomLevel(speedMPS) {
 // Update current speed for global access
 currentSpeed = speedMPS;
 
 // Check if this is genuine GPS movement or potential device movement
 const isGenuineMovement = lastPosition?.hasOwnProperty('speedAccuracy') && 
 lastPosition.speedAccuracy < SPEED_ACCURACY_THRESHOLD;
 
 // Use a more conservative speed estimate for non-GPS-confirmed movement
 const reliableSpeed = isGenuineMovement ? speedMPS : Math.min(speedMPS, 1.0);
 
 // Determine target zoom level based on reliable speed
 let targetZoomLevel;
 
 if (isStationary || reliableSpeed < 0.5) {
 // Stationary or very slow movement
 targetZoomLevel = MAX_ZOOM_LEVEL;
 } else if (reliableSpeed < WALKING_SPEED_THRESHOLD) {
 // Walking speed
 targetZoomLevel = WALKING_ZOOM_LEVEL;
 } else if (reliableSpeed < RUNNING_SPEED_THRESHOLD) {
 // Running speed - linear interpolation between walking and running zoom levels
 const t = (reliableSpeed - WALKING_SPEED_THRESHOLD) / (RUNNING_SPEED_THRESHOLD - WALKING_SPEED_THRESHOLD);
 targetZoomLevel = WALKING_ZOOM_LEVEL - t;
 } else if (reliableSpeed < DRIVING_SPEED_THRESHOLD) {
 // Driving speed - linear interpolation between running and driving zoom levels
 const t = (reliableSpeed - RUNNING_SPEED_THRESHOLD) / (DRIVING_SPEED_THRESHOLD - RUNNING_SPEED_THRESHOLD);
 targetZoomLevel = WALKING_ZOOM_LEVEL - 1 - t;
 } else {
 // High speed
 targetZoomLevel = MIN_ZOOM_LEVEL;
 }
 
 // For non-GPS-confirmed movement, be more conservative with zoom changes
 let smoothingFactor = isGenuineMovement ? 0.15 : 0.05;
 
 // For GPS-confirmed movement, check for significant speed changes
 if (isGenuineMovement) {
 const speedChange = lastPosition ? Math.abs(speedMPS - lastPosition.speedMPS) : 0;
 const significantSpeedChange = speedChange > 1.0;
 
 // More responsive when speed changes significantly
 if (significantSpeedChange) {
 smoothingFactor = 0.4;
 }
 }
 
 // Smooth zoom level changes
 let zoomLevel = targetZoomLevel;
 if (lastZoomLevel !== null) {
 zoomLevel = lastZoomLevel * (1 - smoothingFactor) + targetZoomLevel * smoothingFactor;
 }
 
 // Ensure more immediate response for significant genuine GPS speed transitions
 if (isGenuineMovement && 
 ((isStationary && speedMPS > 1.0) || (!isStationary && speedMPS < 0.5))) {
 zoomLevel = lastZoomLevel * 0.6 + targetZoomLevel * 0.4;
 }
 
 // Round to one decimal place for smoother transitions
 zoomLevel = Math.round(zoomLevel * 10) / 10;
 
 // Clamp to valid zoom range
 zoomLevel = Math.max(MIN_ZOOM_LEVEL, Math.min(MAX_ZOOM_LEVEL, zoomLevel));
 
 // Update last zoom level
 lastZoomLevel = zoomLevel;
 
 return zoomLevel;
 }

// Check proximity to locations and adjust zoom accordingly
 function checkLocationProximity() {
 const now = Date.now();
 
 // Don't check too frequently
 if (now - lastProximityCheck < 1000) return;
 lastProximityCheck = now;
 
 // Don't check if zoom was recently changed
 if (now - lastZoomChangeTime < ZOOM_CHANGE_COOLDOWN) return;
 
 if (!userMarker || !gameLocations || gameLocations.length === 0) return;
 
 const userLatLng = userMarker.getLatLng();
 
 // Validate user coordinates
 if (!userLatLng || typeof userLatLng.lat !== 'number' || typeof userLatLng.lng !== 'number' || 
 isNaN(userLatLng.lat) || isNaN(userLatLng.lng)) {
 console.warn("Invalid user coordinates for proximity check");
 return;
 }
 
 const userPos = { lat: userLatLng.lat, lng: userLatLng.lng };
 
 // Find closest location
 let closestDistance = Infinity;
 let closestLocation = null;
 
 for (const location of gameLocations) {
 if (!location || typeof location.lat !== 'number' || typeof location.lng !== 'number' || 
 isNaN(location.lat) || isNaN(location.lng)) {
 continue;
 }
 
 const locationPos = { lat: location.lat, lng: location.lng };
 const distance = calculateDistance(userPos, locationPos);
 
 if (isFinite(distance) && distance < closestDistance) {
 closestDistance = distance;
 closestLocation = location;
 }
 }
 
 // If no valid locations found, exit
 if (!closestLocation || !isFinite(closestDistance)) {
 return;
 }
 
 // Convert to feet for threshold comparison
 const distanceFeet = Math.round(closestDistance * 3.28084);
 
 // Constants for hysteresis and thresholds to prevent rapid toggling
 const ZOOM_IN_THRESHOLD = PROXIMITY_THRESHOLD; 
 const ZOOM_OUT_THRESHOLD = PROXIMITY_THRESHOLD * 1.1; // 10% buffer when moving away
 
 // Get current zoom level
 const currentZoom = map.getZoom();
 
 // Smoother transition with interpolated zoom levels
 const ZOOM_CLOSE = 18;
 const ZOOM_FAR = 17;
 const TRANSITION_DURATION = 1000; // 1 second for smooth transition
 
 // Check if we need to adjust zoom based on proximity
 if (distanceFeet <= ZOOM_IN_THRESHOLD) {
 // If we're near a location and zoom is not fully zoomed in
 if (currentZoom < ZOOM_CLOSE) {
 console.log(`User is within ${ZOOM_IN_THRESHOLD.toFixed(1)} feet of a location, zooming to level ${ZOOM_CLOSE}`);
 isNearLocation = true;
 lastZoomChangeTime = now;
 
 // Apply zoom change with enhanced smooth animation
 map.flyTo(userLatLng, ZOOM_CLOSE, {
 animate: true,
 duration: TRANSITION_DURATION,
 easeLinearity: 0.25 // Lower value makes zoom more natural
 });
 }
 } else if (distanceFeet >= ZOOM_OUT_THRESHOLD) {
 // If we're not near a location and zoom is fully zoomed in
 if (currentZoom > ZOOM_FAR && isNearLocation) {
 console.log(`User is now outside ${ZOOM_OUT_THRESHOLD.toFixed(1)} feet of a location, zooming to level ${ZOOM_FAR}`);
 isNearLocation = false;
 lastZoomChangeTime = now;
 
 // Apply zoom change with enhanced smooth animation
 map.flyTo(userLatLng, ZOOM_FAR, {
 animate: true,
 duration: TRANSITION_DURATION,
 easeLinearity: 0.25 // Lower value makes zoom more natural
 });
 }
 }
 
 // Update last proximity distance
 lastProximityDistance = closestDistance;
 }

// Calculate edge proximity to map bounds
 function calculateEdgeProximity(map, point) {
 const bounds = map.getBounds();
 const latSpan = bounds.getNorth() - bounds.getSouth();
 const lngSpan = bounds.getEast() - bounds.getWest();

 return {
 north: Math.abs(point.lat - bounds.getNorth()) / latSpan,
 south: Math.abs(point.lat - bounds.getSouth()) / latSpan,
 east: Math.abs(point.lng - bounds.getEast()) / lngSpan,
 west: Math.abs(point.lng - bounds.getWest()) / lngSpan,
 };
 }

// Check if marker is near edge of map
 function isMarkerNearEdge(map, marker, isStrict = false) {
 if (!map || !marker) return { isNearEdge: false };

 const bounds = map.getBounds();
 const point = marker.getLatLng();
 const proximities = calculateEdgeProximity(map, point);

 const thresholdPercentage = isStrict ? 0.12 : EDGE_THRESHOLD_PERCENTAGE;

 const edges = {
 north: proximities.north < thresholdPercentage,
 south: proximities.south < thresholdPercentage,
 east: proximities.east < thresholdPercentage,
 west: proximities.west < thresholdPercentage,
 };

 return {
 isNearEdge: Object.values(edges).some((edge) => edge),
 edges: edges,
 proximities: proximities,
 };
 }

// Determine if map should recenter
 function shouldRecenter(map, marker) {
 const now = Date.now();
 if (now - lastRecenterTime < RECENTER_COOLDOWN) {
 return { needsRecenter: false };
 }

 if (!map || !marker) return { needsRecenter: false };

 const edgeInfo = isMarkerNearEdge(map, marker);
 const proximities = edgeInfo.proximities;

 // Check for critical edge proximity (very close to edge)
 const isCritical = Object.values(proximities).some((proximity) => proximity < CRITICAL_EDGE_THRESHOLD);

 if (isCritical) {
 lastRecenterTime = now;
 return {
 needsRecenter: true,
 isEmergency: true,
 edgeInfo: edgeInfo,
 };
 }

 // Check for normal edge proximity
 if (edgeInfo.isNearEdge) {
 lastRecenterTime = now;
 return {
 needsRecenter: true,
 isEmergency: false,
 edgeInfo: edgeInfo,
 };
 }

 return {
 needsRecenter: false,
 isEmergency: false,
 edgeInfo: edgeInfo,
 };
 }

// Calculate optimal center point
 function calculateOptimalCenter(map, markerPosition, edgeInfo) {
 const bounds = map.getBounds();

 // Calculate offsets based on which edges are being approached
 let latOffset = 0;
 let lngOffset = 0;

 // Apply stronger offset for the closest edge
 const proximities = edgeInfo.proximities;
 const edges = edgeInfo.edges;

 // Get viewport dimensions
 const viewportWidth = mapViewportWidth || map._container.clientWidth;
 const viewportHeight = mapViewportHeight || map._container.clientHeight;

 // Calculate aspect ratio to adjust offsets
 const aspectRatio = viewportWidth / viewportHeight;

 // Adjust offsets based on viewport dimensions
 const latSpan = bounds.getNorth() - bounds.getSouth();
 const lngSpan = bounds.getEast() - bounds.getWest();

 // Calculate offsets with consideration for viewport aspect ratio
 if (edges.north) {
 latOffset = -1 * latSpan * 0.25 * (1 / aspectRatio);
 }
 if (edges.south) {
 latOffset = latSpan * 0.25 * (1 / aspectRatio);
 }
 if (edges.east) {
 lngOffset = -1 * lngSpan * 0.25 * aspectRatio;
 }
 if (edges.west) {
 lngOffset = lngSpan * 0.25 * aspectRatio;
 }

 // Find the closest edge and apply extra offset
 const minProximity = Math.min(
 edges.north ? proximities.north : 1,
 edges.south ? proximities.south : 1,
 edges.east ? proximities.east : 1,
 edges.west ? proximities.west : 1,
 );

 if (minProximity === proximities.north && edges.north) {
 latOffset *= 1.5;
 } else if (minProximity === proximities.south && edges.south) {
 latOffset *= 1.5;
 } else if (minProximity === proximities.east && edges.east) {
 lngOffset *= 1.5;
 } else if (minProximity === proximities.west && edges.west) {
 lngOffset *= 1.5;
 }

 return {
 lat: markerPosition.lat + latOffset,
 lng: markerPosition.lng + lngOffset,
 };
 }

// Update map viewport dimensions
 function updateMapViewportDimensions() {
 if (map && map._container) {
 mapViewportWidth = map._container.clientWidth;
 mapViewportHeight = map._container.clientHeight;

 // Store current map center and zoom
 if (map.getCenter()) {
 lastMapCenter = map.getCenter();
 lastMapZoom = map.getZoom();
 }
 }
 }

// Update distance box
 function updateDistanceBox() {
 const distanceBox = document.getElementById("distanceBox");
 if (!distanceBox) return;
 
 // Schedule DOM update
 domUpdateManager.schedule("distanceBox", () => {
 // Initial validation
 if (!userMarker || !gameLocations || gameLocations.length === 0) {
 distanceBox.innerText = "Initializing...";
 distanceBox.classList.remove("at-location"); // Remove highlight if present
 return;
 }
 
 // Get user coordinates
 const userLatLng = userMarker.getLatLng();
 let userLat = userLatLng.lat;
 let userLng = userLatLng.lng;
 
 // Coordinate validation
 if (!isFinite(userLat) || !isFinite(userLng)) {
 console.warn("Invalid user coordinates:", userLat, userLng);
 distanceBox.innerText = "Initializing...";
 distanceBox.classList.remove("at-location"); // Remove highlight if present
 return;
 }
 
 // Use map center if at origin
 if (userLat === 0 && userLng === 0) {
 const center = map.getCenter();
 userLat = center.lat;
 userLng = center.lng;
 }
 
 // Find closest location
 let closestDistance = Number.POSITIVE_INFINITY;
 let closestLocation = null;
 const userPos = { lat: userLat, lng: userLng };
 
 for (const location of gameLocations) {
 if (!location || typeof location.lat !== "number" || typeof location.lng !== "number") {
 console.warn("Invalid location data:", location);
 continue;
 }
 const locationPos = { lat: location.lat, lng: location.lng };
 const distance = calculateDistance(userPos, locationPos);
 if (isFinite(distance) && distance < closestDistance) {
 closestDistance = distance;
 closestLocation = location;
 }
 }
 
 // Validate final distance calculation
 if (!isFinite(closestDistance) || closestDistance === Number.POSITIVE_INFINITY) {
 console.warn("Invalid distance calculation:", closestDistance);
 distanceBox.innerText = "Initializing...";
 distanceBox.classList.remove("at-location"); // Remove highlight if present
 return;
 }
 
 // Calculate and display distance
 const distanceFeet = Math.round(closestDistance * 3.28084);
 const distanceText =
 distanceFeet < 5280 ? `${distanceFeet.toLocaleString()} feet` : `${(distanceFeet / 5280).toFixed(2)} miles`;
 distanceBox.innerText = `Closest Stop: ${distanceText}`;
 
 // Add or remove highlight class based on proximity
 if (distanceFeet <= DISTANCE_THRESHOLD) {
 distanceBox.classList.add("at-location"); // Add red border class
 } else {
 distanceBox.classList.remove("at-location"); // Remove highlight if present
 }
 
 // Check if we should show location hunt
 if (distanceFeet <= DISTANCE_THRESHOLD && !isLocationHuntVisible && closestLocation) {
 showLocationHunt(closestLocation);
 }
 });
 }

// Initialize map
 function initMap() {
 map = L.map("map", {
 zoomControl: false,
 attributionControl: false,
 zoomSnap: 0.1,
 zoomDelta: 0.5,
 wheelDebounceTime: 100,
 tapTolerance: 15,
 bounceAtZoomLimits: false,
 preferCanvas: true, // Use canvas renderer for better performance
 renderer: L.canvas({ padding: 0.5 }),
 }).fitWorld();

 L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
 maxZoom: 19,
 attribution: "© OpenStreetMap contributors",
 updateWhenIdle: true,
 updateWhenZooming: false,
 keepBuffer: 2,
 }).addTo(map);

 markerClusterGroup = L.markerClusterGroup({
 showCoverageOnHover: false,
 zoomToBoundsOnClick: true,
 spiderfyOnMaxZoom: true,
 animate: true,
 animateAddingMarkers: true,
 disableClusteringAtZoom: 17,
 maxClusterRadius: 60,
 iconCreateFunction: (cluster) =>
 L.divIcon({
 html: "<div><span>" + cluster.getChildCount() + "</span></div>",
 className: "marker-cluster-custom",
 iconSize: L.point(40, 40),
 }),
 });
 map.addLayer(markerClusterGroup);

 // Create user icon with custom styling (red)
 const userIcon = L.divIcon({
 className: 'user-marker',
 html: '<div class="user-marker-icon"><div class="user-marker-direction"></div></div>',
 iconSize: [20, 20],
 iconAnchor: [10, 10]
 });
 userMarker = L.marker([0, 0], { 
 icon: userIcon,
 zIndexOffset: 1000, // Ensure user marker is on top
 interactive: false // Prevent marker from being clickable
 }).addTo(map);

 // Store map viewport dimensions
 updateMapViewportDimensions();

 // Show preloader
 startPreloader();

 // Request motion and orientation permissions
 requestMotionPermission();

 // Try to use Geolocation Sensor API first, then fall back to standard Geolocation API
 initGeolocation();

 document.addEventListener("visibilitychange", handleVisibilityChange);

 map.on("movestart zoomstart", () => {
 followUser = false;
 isMapInteracting = true;
 });

 map.on("moveend zoomend", () => {
 isMapInteracting = false;
 resetInactivityTimer();
 updateMapViewportDimensions();
 });

 // Listen for resize events to update viewport dimensions
 window.addEventListener("resize", updateMapViewportDimensions);

 // Start animation loop for smooth rendering
 startAnimationLoop();

 // Enable touch interactions
 map.touchZoom.enable();
 map.doubleClickZoom.enable();

 // Add event listeners
 addUIEventListeners();
 addMapEventListeners();
 }

// Initialize geolocation with priority for Geolocation Sensor API
 function initGeolocation() {
 if ("GeolocationSensor" in window) {
 try {
 console.log("Trying GeolocationSensor API");
 geolocationSensor = new GeolocationSensor({ frequency: 1 });

 geolocationSensor.addEventListener("reading", () => {
 const position = {
 coords: {
 latitude: geolocationSensor.latitude,
 longitude: geolocationSensor.longitude,
 accuracy: geolocationSensor.accuracy,
 altitude: geolocationSensor.altitude,
 altitudeAccuracy: geolocationSensor.altitudeAccuracy,
 heading: geolocationSensor.heading,
 speed: geolocationSensor.speed,
 },
 timestamp: geolocationSensor.timestamp,
 };

 if (!lastPosition) {
 initializeUserLocation(position);
 } else {
 handlePositionUpdate(position);
 }
 });

 geolocationSensor.addEventListener("error", (error) => {
 console.warn("GeolocationSensor error:", error);
 // Fall back to standard Geolocation API
 useStandardGeolocation();
 });

 geolocationSensor.start();
 usingGeolocationSensorAPI = true;
 console.log("Using GeolocationSensor API");
 } catch (error) {
 console.warn("GeolocationSensor error:", error);
 // Fall back to standard Geolocation API
 useStandardGeolocation();
 }
 } else {
 // Fall back to standard Geolocation API
 useStandardGeolocation();
 }
 }

// Standard Geolocation API fallback
 function useStandardGeolocation() {
 console.log("Using standard Geolocation API");
 usingGeolocationSensorAPI = false;

 if ("geolocation" in navigator) {
 const options = {
 enableHighAccuracy: true,
 timeout: 30000, // Reduced timeout for faster fallback
 maximumAge: 0,
 };

 // Try first time
 navigator.geolocation.getCurrentPosition(
 initializeUserLocation,
 (error) => {
 // On error, try one more time before falling back
 navigator.geolocation.getCurrentPosition(initializeUserLocation, handleLocationError, options);
 },
 options,
 );
 } else {
 showPopup("Geolocation is not supported by your browser");
 map.setView([44.9778, -93.265], 17);
 hideLoadingMessage();
 }
 }

// Initialize user location
 function initializeUserLocation(position) {
 console.log("Initial position data:", JSON.stringify(position));

 if (!position || !position.coords) {
 console.error("Invalid initial position object");
 handleLocationError(new Error("Invalid initial position"));
 return;
 }

 const { latitude: userLat, longitude: userLng, accuracy } = position.coords;

 if (isNaN(userLat) || isNaN(userLng)) {
 console.error("Invalid initial coordinates:", { userLat, userLng });
 handleLocationError(new Error("Invalid initial coordinates"));
 return;
 }

 console.log("Valid initial position:", { userLat, userLng, accuracy });

 try {
 // Set initial marker position
 updateUserMarkerPosition({
 lat: userLat,
 lng: userLng,
 accuracy: accuracy,
 heading: position.coords.heading,
 timestamp: Date.now(),
 speedMPS: 0,
 });

 map.setView([userLat, userLng], 17);

 // Initialize Kalman filter with first position
 tracking.filter.reset({
 lat: userLat,
 lng: userLng,
 accuracy: accuracy,
 heading: position.coords.heading,
 timestamp: Date.now(),
 });

 // Initialize stationary position
 lastStationaryPosition = {
 lat: userLat,
 lng: userLng,
 accuracy: accuracy,
 heading: position.coords.heading,
 timestamp: Date.now(),
 speedMPS: 0,
 };

 // Initialize last render position
 lastRenderPosition = {
 lat: userLat,
 lng: userLng,
 accuracy: accuracy,
 heading: position.coords.heading,
 timestamp: Date.now(),
 speedMPS: 0,
 };

 // Initialize last valid position
 lastValidPosition = {
 lat: userLat,
 lng: userLng,
 accuracy: accuracy,
 heading: position.coords.heading,
 timestamp: Date.now(),
 speedMPS: 0,
 };

 // Hide loading message and show stabilizing modal
 hideLoadingMessage();
 showStabilizingModal();

 // Start position updates
 startPositionUpdates();
 startHunt();
 } catch (error) {
 console.error("Error setting initial user location:", error);
 handleLocationError(error);
 }
 }

// Start position updates
 function startPositionUpdates() {
 // If already using GeolocationSensor API, don't start again
 if (usingGeolocationSensorAPI) {
 console.log("Position updates already using GeolocationSensor API");
 return;
 }

 // Use standard Geolocation API with high frequency updates
 watchPositionId = navigator.geolocation.watchPosition(handlePositionUpdate, handleLocationError, {
 enableHighAccuracy: true,
 maximumAge: 0,
 timeout: 10000,
 });
 isWatchPositionActive = true;
 console.log("Position updates using standard Geolocation API");
 }

// Handle position updates from geolocation API
 function handlePositionUpdate(position) {
 if (!position?.coords?.latitude || !position?.coords?.longitude) {
 console.warn("Invalid position data received");
 return;
 }
 updateUserLocation(position);
 }

// Handle visibility change
 function handleVisibilityChange() {
 if (document.hidden) {
 lastHiddenTime = Date.now();
 lastKnownPosition = userMarker ? userMarker.getLatLng() : null;

 // Cancel any active interpolation
 if (positionInterpolator) {
 positionInterpolator.cancel();
 }

 // Cancel animation frame
 if (animationFrameId) {
 cancelAnimationFrame(animationFrameId);
 animationFrameId = null;
 }

 // Stop GeolocationSensor if using it
 if (usingGeolocationSensorAPI && geolocationSensor) {
 geolocationSensor.stop();
 }
 } else {
 const hiddenDuration = Date.now() - lastHiddenTime;
 if (hiddenDuration > BACKGROUND_THRESHOLD) {
 updateLocationAfterBackground();
 } else {
 map.invalidateSize();

 // Restart animation loop
 if (!animationFrameId) {
 startAnimationLoop();
 }

 // Restart GeolocationSensor if using it
 if (usingGeolocationSensorAPI && geolocationSensor) {
 geolocationSensor.start();
 }

 // If returning from exhibit, ensure movement resumes properly
 if (isReturningFromExhibit) {
 isReturningFromExhibit = false;
 // Force a position update to resume tracking
 if (lastValidPosition) {
 updateUserLocation(
 {
 coords: {
 latitude: lastValidPosition.lat,
 longitude: lastValidPosition.lng,
 accuracy: lastValidPosition.accuracy,
 heading: lastValidPosition.heading,
 speed: lastValidPosition.speedMPS,
 },
 timestamp: Date.now(),
 },
 true,
 );
 }
 }
 }
 }
 resetInactivityTimer();
 }

// Update location after background
 function updateLocationAfterBackground() {
 if ("geolocation" in navigator) {
 navigator.geolocation.getCurrentPosition(
 (position) => {
 console.log("Background update raw position:", JSON.stringify(position));
 if (!position || !position.coords) {
 console.warn("Invalid position object in background update");
 return;
 }
 const { latitude, longitude, accuracy } = position.coords;
 if (isNaN(latitude) || isNaN(longitude)) {
 console.warn("Invalid coordinates in background update:", { latitude, longitude });
 return;
 }

 console.log("Valid background position update:", { lat: latitude, lng: longitude });
 try {
 updateUserLocation(position, true);
 } catch (error) {
 console.error("Error in updateUserLocation during background update:", error);
 }

 // Reset tracking variables
 lastPosition = null;
 positionBuffer = [];
 velocity = { lat: 0, lng: 0 };
 lastVelocity = { lat: 0, lng: 0 };
 isStationary = false;
 stationaryStartTime = null;
 stationaryCount = 0;
 stationaryPositionHistory = [];
 lastStationaryPosition = null;
 stationaryPositionLocked = false;
 positionHistory = [];
 suddenMovementCount = 0;
 isJumpDetected = false;

 // Reset Kalman filter
 tracking.filter.reset({
 lat: latitude,
 lng: longitude,
 accuracy: accuracy,
 heading: position.coords.heading,
 timestamp: Date.now(),
 });

 // Restart animation loop
 if (!animationFrameId) {
 startAnimationLoop();
 }

 // Restart GeolocationSensor if using it
 if (usingGeolocationSensorAPI && geolocationSensor) {
 geolocationSensor.start();
 }

 updateDistanceBox();
 followUser = true;
 map.invalidateSize();
 },
 (error) => {
 console.error("Error getting location after background:", error);
 if (error.code === 3) {
 // If timeout, retry with lower accuracy
 navigator.geolocation.getCurrentPosition(
 (position) => {
 console.log("Retry successful with lower accuracy");
 updateUserLocation(position, true);
 },
 (error) => console.error("Error on retry:", error),
 {
 enableHighAccuracy: false,
 timeout: 20000,
 maximumAge: 30000,
 },
 );
 }
 },
 {
 enableHighAccuracy: true,
 timeout: 15000,
 maximumAge: 0,
 },
 );
 } else {
 console.warn("Geolocation is not available");
 }
 }

// Main function to update user location
 function updateUserLocation(position, forceUpdate = false) {
 // Validate input position
 if (!position?.coords?.latitude || !position?.coords?.longitude) {
 console.warn("Invalid position data received");
 return;
 }

 const currentTime = Date.now();
 const timeDelta = lastUpdateTime ? (currentTime - lastUpdateTime) / 1000 : 0;

 // Create position object
 const newPosition = {
 lat: position.coords.latitude,
 lng: position.coords.longitude,
 accuracy: position.coords.accuracy || 20,
 heading: position.coords.heading !== null ? position.coords.heading : lastHeadingValue || undefined,
 timestamp: currentTime,
 speedMPS: position.coords.speed !== null ? position.coords.speed : 0,
 };

 // First position initialization
 if (!lastPosition) {
 lastPosition = newPosition;
 lastValidPosition = newPosition;
 updateUserMarkerPosition(newPosition);
 tracking.filter.reset(newPosition);
 lastUpdateTime = currentTime;
 stationaryStartTime = currentTime;
 positionBuffer = [newPosition];
 positionHistory = [newPosition];
 lastStationaryPosition = newPosition;
 lastRenderPosition = newPosition;

 // Set initial zoom based on stationary state
 const initialZoom = calculateZoomLevel(0);
 map.setView([newPosition.lat, newPosition.lng], initialZoom, { animate: false });
 updateDistanceBox();
 return;
 }

 // Calculate distance from last position
 const distance = calculateDistance(lastPosition, newPosition);

 // Check for sudden movements or position jumps
 const isJump = !forceUpdate && detectSuddenMovement(newPosition, lastPosition);

 // If a jump is detected and we're stationary, ignore this update
 if (isJump && isStationary && stationaryPositionLocked) {
 console.log("Position jump detected while stationary, ignoring update");
 isJumpDetected = true;
 return;
 }

 // Handle large position changes or forced updates
 if (distance > EXTENDED_DISTANCE_THRESHOLD || forceUpdate) {
 if (stationaryCheckTimeout) {
 clearTimeout(stationaryCheckTimeout);
 stationaryCheckTimeout = null;
 }

 if (stationaryLockTimeout) {
 clearTimeout(stationaryLockTimeout);
 stationaryLockTimeout = null;
 }

 isStationary = false;
 stationaryStartTime = null;
 stationaryCount = 0;
 stationaryPositionHistory = [];
 lastStationaryPosition = null;
 stationaryPositionLocked = false;
 isJumpDetected = false;

 // Reset tracking variables
 tracking.filter.reset(newPosition);
 tracking.filter.setStationaryMode(false);
 
 // Update marker position IMMEDIATELY without interpolation
 updateUserMarkerPosition(newPosition);
 
 lastPosition = newPosition;
 lastValidPosition = newPosition;
 lastRenderPosition = newPosition;
 positionBuffer = [newPosition];
 positionHistory = [newPosition];
 lastVelocity = { lat: 0, lng: 0 };
 lastSmoothedPosition = null;

 // Update map view INSTANTLY without animation
 const zoomLevel = calculateZoomLevel(newPosition.speedMPS);
 map.setView([newPosition.lat, newPosition.lng], zoomLevel, {
 animate: false,
 duration: 0
 });

 lastUpdateTime = currentTime;
 lastUpdateTimestamp = currentTime;
 updateDistanceBox();

 if (map._container) {
 map._onResize();
 }
 return;
 }

 // Skip updates with poor accuracy or unrealistic movement
 if (
 !forceUpdate &&
 (newPosition.accuracy > MAX_ACCEPTABLE_ACCURACY || (timeDelta > 0 && distance / timeDelta > 40))
 ) {
 console.log("Skipping update due to poor accuracy or unrealistic movement");
 return;
 }

 try {
 // Check if device is in motion based on motion sensors
 const motionDetected = deviceMotion && isDeviceInMotion();

 // Check stationary state
 checkStationaryState(newPosition);

 // If we're in stationary mode and have a locked position, use that position
 if (isStationary && stationaryPositionLocked && lastStationaryPosition) {
 // Just update the distance box without changing position
 updateDistanceBox();
 return;
 }

 // Apply enhanced tracking with motion detection
 const smoothedPosition = tracking.update(newPosition, motionDetected, ANIMATION_DURATION);

 // Update position buffer and history
 updatePositionBuffer(smoothedPosition);
 updatePositionHistory(smoothedPosition);

 // Update user marker position
 updateUserMarkerPosition(smoothedPosition);

 // Add to position update queue
 positionUpdateQueue.push(smoothedPosition);
 lastPosition = smoothedPosition;
 lastValidPosition = smoothedPosition;

 lastUpdateTime = currentTime;
 lastUpdateTimestamp = currentTime;
 updateDistanceBox();
 } catch (error) {
 console.error("Location update error:", error);
 // Fallback with basic filtering
 updateUserMarkerPosition(newPosition);
 lastPosition = newPosition;
 lastValidPosition = newPosition;
 lastRenderPosition = newPosition;
 updateDistanceBox();
 }
 }

// Detect sudden movements or position jumps
 function detectSuddenMovement(newPosition, lastPosition) {
 if (!lastPosition || !newPosition) return false;

 const distance = calculateDistance(lastPosition, newPosition);
 const timeDelta = (newPosition.timestamp - lastPosition.timestamp) / 1000; // seconds

 // If time delta is too small, consider it a valid update
 if (timeDelta < 0.05) return false;

 // Calculate speed in meters per second
 const speed = distance / timeDelta;

 // Check for unrealistic speeds (teleportation)
 if (speed > 40) {
 // Reduced from 50 to 40 m/s for more sensitive jump detection
 console.log(`Position jump detected: ${distance.toFixed(2)}m in ${timeDelta.toFixed(2)}s (${speed.toFixed(2)} m/s)`);
 return true;
 }

 // Check for sudden movements when stationary
 if (isStationary && distance > POSITION_JUMP_THRESHOLD) {
 console.log(`Sudden movement detected while stationary: ${distance.toFixed(2)}m`);
 return true;
 }

 // Check for small sudden movements (jitter)
 if (isStationary && distance > SUDDEN_MOVEMENT_THRESHOLD) {
 suddenMovementCount++;
 if (suddenMovementCount >= 2) {
 console.log(`Multiple sudden movements detected: ${distance.toFixed(2)}m`);
 return true;
 }
 } else {
 suddenMovementCount = 0;
 }

 return false;
 }

// Check stationary state
 function checkStationaryState(newPosition) {
 if (!lastPosition) return;

 // Calculate distance between current and last position
 const distance = calculateDistance(lastPosition, newPosition);

 // Check if device motion sensors indicate movement
 const motionDetected = isDeviceInMotion();

 // If significant movement is detected or motion sensors indicate activity
 if (distance >= MICRO_MOVEMENT_THRESHOLD || motionDetected) {
 if (isStationary) {
 console.debug("Movement detected, transitioning to moving state");
 isStationary = false;
 stationaryStartTime = null;
 stationaryPositionLocked = false;
 stationaryCount = 0; // Reset stationary count
 tracking.filter.setStationaryMode(false);

 // Clear any stationary lock timeout
 if (stationaryLockTimeout) {
 clearTimeout(stationaryLockTimeout);
 stationaryLockTimeout = null;
 }
 }

 // Clear the stationary check timeout
 if (stationaryCheckTimeout) {
 clearTimeout(stationaryCheckTimeout);
 stationaryCheckTimeout = null;
 }
 } else {
 // If no significant movement, increment stationary count
 stationaryCount++;

 // If stationary count exceeds threshold, transition to stationary state
 if (!isStationary && stationaryCount >= STATIONARY_THRESHOLD) {
 console.debug("User is now stationary");
 isStationary = true;
 stationaryStartTime = Date.now();
 tracking.filter.setStationaryMode(true);

 // Calculate a stable position by averaging recent positions
 const stablePosition = calculateStationaryPosition(positionBuffer);
 if (stablePosition) {
 lastStationaryPosition = stablePosition;

 // Set a timeout to lock the stationary position after a delay
 if (stationaryLockTimeout) {
 clearTimeout(stationaryLockTimeout);
 }

 stationaryLockTimeout = setTimeout(() => {
 stationaryPositionLocked = true;
 stationaryPositionLockTime = Date.now();
 console.log("Stationary position locked after delay");

 // Also lock in the Kalman filter
 tracking.filter.lockStationaryPosition(lastStationaryPosition);
 }, 2000); // Reduced from 3000ms for faster locking
 }
 }

 // Schedule the next stationary check
 if (isStationary && !stationaryCheckTimeout) {
 stationaryCheckTimeout = setTimeout(() => {
 stationaryCheckTimeout = null;
 checkStationaryState(newPosition);
 }, STATIONARY_CHECK_INTERVAL);
 }
 }
 }

// Enhanced stationary position calculation
 function calculateStationaryPosition(buffer) {
 if (!buffer || buffer.length === 0) {
 return null;
 }

 // Sort by accuracy (best first)
 const sortedBuffer = [...buffer].sort((a, b) => a.accuracy - b.accuracy);

 // Take weighted average of best positions
 const topPositions = sortedBuffer.slice(0, Math.ceil(buffer.length / 2));

 const weights = topPositions.map((pos) => 1 / Math.max(1, pos.accuracy));
 const totalWeight = weights.reduce((sum, w) => sum + w, 0);

 if (totalWeight === 0) {
 return sortedBuffer[0];
 }

 // Calculate weighted average
 const avgPosition = {
 lat: topPositions.reduce((sum, pos, i) => sum + pos.lat * weights[i], 0) / totalWeight,
 lng: topPositions.reduce((sum, pos, i) => sum + pos.lng * weights[i], 0) / totalWeight,
 accuracy: topPositions[0].accuracy,
 heading: topPositions[0].heading,
 timestamp: Date.now(),
 speedMPS: 0,
 };

 // If we have a previous stationary position, blend with it for stability
 if (lastStationaryPosition) {
 const blendFactor = 0.9; // Reduced to 90% previous, 10% new for more responsive updates
 return {
 lat: lastStationaryPosition.lat * blendFactor + avgPosition.lat * (1 - blendFactor),
 lng: lastStationaryPosition.lng * blendFactor + avgPosition.lng * (1 - blendFactor),
 accuracy: avgPosition.accuracy,
 heading: avgPosition.heading,
 timestamp: avgPosition.timestamp,
 speedMPS: 0,
 };
 }

 return avgPosition;
 }

// Update position buffer with new position
 function updatePositionBuffer(position) {
 if (!isValidPosition(position)) {
 return;
 }

 // Add new position to buffer
 positionBuffer.push({
 lat: position.lat,
 lng: position.lng,
 accuracy: position.accuracy,
 heading: position.heading,
 timestamp: position.timestamp,
 speedMPS: position.speedMPS,
 });

 // Remove old positions if buffer exceeds maxSize
 while (positionBuffer.length > MAX_BUFFER_SIZE) {
 positionBuffer.shift();
 }
 }

// Update position history for jump detection
 function updatePositionHistory(position) {
 if (!isValidPosition(position)) {
 return;
 }

 // Add new position to history
 positionHistory.push({
 lat: position.lat,
 lng: position.lng,
 accuracy: position.accuracy,
 heading: position.heading,
 timestamp: position.timestamp,
 speedMPS: position.speedMPS,
 });

 // Keep only recent positions
 while (positionHistory.length > 10) {
 positionHistory.shift();
 }
 }

// Helper function to validate position data
 function isValidPosition(pos) {
 return (
 pos &&
 typeof pos.lat === "number" &&
 !isNaN(pos.lat) &&
 typeof pos.lng === "number" &&
 !isNaN(pos.lng) &&
 typeof pos.accuracy === "number" &&
 !isNaN(pos.accuracy)
 );
 }

// Show stabilizing modal
 function showStabilizingModal() {
 // Hide jitter immediately
 if (userMarker) userMarker.setOpacity(0);

 const modal = document.createElement("div");
 modal.id = "stabilizingModal";
 modal.className = "stabilizing-modal";
 modal.innerHTML = `
 <div class="spinner"></div>
 <h3>Stabilizing Your Location</h3>
 <p>Please wait while we fine-tune your position.</p>
 `;
 document.body.appendChild(modal);

 // Auto-dismiss after 5 seconds
 setTimeout(() => {
 if (userMarker) userMarker.setOpacity(1); // Restore visibility
 const modal = document.getElementById("stabilizingModal");
 if (modal) {
 modal.style.opacity = "0";
 setTimeout(() => modal.remove(), 500);
 }
 isStabilizing = false;
 }, 5000);
 }

// Hide loading message
 function hideLoadingMessage() {
 // Skip creating the loading message element
 // Just log to console for debugging purposes
 console.log("Location found, proceeding to stabilization...");
 
 // Clear the loading state flag
 window.isSearchingLocation = false;
 
 // If any code relies on this function completing, ensure it still works
 const fakeLoadingMessage = document.getElementById('loadingMessage');
 if (fakeLoadingMessage) {
 document.body.removeChild(fakeLoadingMessage);
 }
 }

// Handle location errors
 const MAX_RETRIES = 3;
 const RETRY_DELAY = 1000;

function getGeolocationOptions(retryNumber) {
 return {
 enableHighAccuracy: retryNumber < 2,
 timeout: 10000 + retryNumber * 5000,
 maximumAge: retryNumber * 5000,
 };
 }

function handleLocationError(error) {
 console.warn("Error getting user location:", error);
 if (retryCount < MAX_RETRIES) {
 retryCount++;
 console.log(`Retrying to get location (Attempt ${retryCount} of ${MAX_RETRIES})`);
 setTimeout(() => {
 navigator.geolocation.getCurrentPosition(
 (position) => {
 console.log("Location retrieved successfully after retry");
 hideLoadingMessage();
 updateUserLocation(position, true);
 retryCount = 0;
 },
 handleLocationError,
 getGeolocationOptions(retryCount),
 );
 }, RETRY_DELAY * Math.pow(2, retryCount - 1)); // Exponential backoff
 return;
 }
 retryCount = 0;
 hideLoadingMessage();
 let errorMessage = "An error occurred while getting your location.";
 if (error && error.code) {
 switch (error.code) {
 case 1:
 errorMessage = "Please allow access to your location to use this feature.";
 // Try to continue with limited functionality
 notifyAppLocationDenied();
 break;
 case 2:
 errorMessage = "Your location is currently unavailable. Please try again later.";
 // Check if we have a cached location we can use temporarily
 if (localStorage.getItem('lastKnownLocation')) {
 const cachedLocation = JSON.parse(localStorage.getItem('lastKnownLocation'));
 updateUserLocation(cachedLocation, false);
 errorMessage += " Using your last known location for now.";
 }
 break;
 case 3:
 errorMessage = "Getting your location took too long. Please try again.";
 // Register to check when device might have better signal
 if (navigator.connection) {
 navigator.connection.addEventListener('change', checkForReconnection);
 }
 break;
 }
 }
 // Log the failure for analytics
 showPopup("Location Error", errorMessage);
 }

// Handles notification when location access is denied by the user
 function notifyAppLocationDenied() {
 console.log("Location access denied by user");
 
 // Update app state
 const locationStatusElement = document.getElementById('location-status');
 if (locationStatusElement) {
 locationStatusElement.textContent = 'Location access denied';
 locationStatusElement.classList.add('error');
 }
 
 // Store the denied state
 localStorage.setItem('locationPermissionDenied', 'true');
 
 // Show a message to the user
 showPopup("Location Required", "This app needs location access to function properly. Please enable location services in your browser settings.");
 }

// Checks if network conditions have improved to try getting location again
 function checkForReconnection() {
 console.log("Network connection changed, checking if we can get location now");
 
 // Only attempt to get location again if we're not already trying
 if (retryCount === 0) {
 // Remove the event listener to avoid multiple calls
 if (navigator.connection) {
 navigator.connection.removeEventListener('change', checkForReconnection);
 }
 
 // Try to get location again
 navigator.geolocation.getCurrentPosition(
 (position) => {
 console.log("Location retrieved successfully after network change");
 updateUserLocation(position, true);
 },
 (error) => {
 console.warn("Still unable to get location after network change:", error);
 },
 {
 enableHighAccuracy: true,
 timeout: 15000,
 maximumAge: 0
 }
 );
 }
 }

// Show popup
 function showPopup(title, message, type = "info", callback = null) {
 const popup = document.createElement("div");
 popup.classList.add("popup");
 popup.style.cssText = `
 position: fixed;
 top: 0;
 left: 0;
 width: 100%;
 height: 100%;
 background-color: rgba(0, 0, 0, 0.5);
 display: flex;
 align-items: center;
 justify-content: center;
 z-index: 3000;
 `;

 const popupContent = document.createElement("div");
 popupContent.style.cssText = `
 background-color: white;
 padding: 24px;
 border-radius: 16px;
 box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
 max-width: 90%;
 width: 350px;
 text-align: center;
 `;

 const titleElement = document.createElement("h3");
 titleElement.textContent = title;
 titleElement.style.cssText = `
 margin-bottom: 16px;
 font-size: 20px;
 font-weight: 600;
 color: #333;
 `;

 const messageElement = document.createElement("p");
 messageElement.textContent = message;
 messageElement.style.cssText = `
 margin-bottom: 24px;
 font-size: 16px;
 line-height: 1.5;
 color: #555;
 `;

 const buttonContainer = document.createElement("div");
 buttonContainer.style.cssText = `
 display: flex;
 justify-content: center;
 gap: 12px;
 `;

 const okButton = document.createElement("button");
 okButton.textContent = "OK";
 okButton.style.cssText = `
 padding: 10px 24px;
 background-color: #0f2bab;
 color: white;
 border: none;
 border-radius: 8px;
 cursor: pointer;
 font-weight: 500;
 transition: all 0.3s ease;
 `;

 okButton.addEventListener("click", () => {
 document.body.removeChild(popup);
 if (callback) callback();
 });

 buttonContainer.appendChild(okButton);

 if (type === "confirm") {
 const cancelButton = document.createElement("button");
 cancelButton.textContent = "Cancel";
 cancelButton.style.cssText = `
 padding: 10px 24px;
 background-color: #f2f2f2;
 color: #333;
 border: none;
 border-radius: 8px;
 cursor: pointer;
 font-weight: 500;
 transition: all 0.3s ease;
 `;

 cancelButton.addEventListener("click", () => {
 document.body.removeChild(popup);
 });

 buttonContainer.appendChild(cancelButton);
 }

 popupContent.appendChild(titleElement);
 popupContent.appendChild(messageElement);
 popupContent.appendChild(buttonContainer);
 popup.appendChild(popupContent);
 document.body.appendChild(popup);
 }

// Show error message
 function showErrorMessage(message) {
 const errorContainer = document.createElement('div');
 errorContainer.className = 'error-message';
 errorContainer.style.cssText = `
 position: fixed;
 top: 20px;
 left: 50%;
 transform: translateX(-50%);
 background-color: #ff3b30;
 color: white;
 padding: 12px 20px;
 border-radius: 8px;
 box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
 z-index: 2000;
 max-width: 90%;
 text-align: center;
 font-weight: 500;
 `;
 errorContainer.textContent = message;
 
 document.body.appendChild(errorContainer);
 
 // Auto-dismiss after 5 seconds
 setTimeout(() => {
 errorContainer.style.opacity = '0';
 errorContainer.style.transition = 'opacity 0.5s ease';
 
 setTimeout(() => {
 if (errorContainer.parentNode) {
 errorContainer.parentNode.removeChild(errorContainer);
 }
 }, 500);
 }, 5000);
 }

// Start preloader
 function startPreloader() {
 // Check if elements exist to prevent errors
 const preloader = document.getElementById('preloader');
 const progressBar = document.getElementById('preloaderProgress');
 
 if (!preloader || !progressBar) {
 console.error('Preloader elements not found');
 return;
 }
 
 // Make sure the preloader is visible
 preloader.style.display = 'flex';
 preloader.style.opacity = '1';
 
 console.log('Preloader started');
 
 // Calculate increment to complete in exactly 7 seconds
 // 70 steps of ~100ms = 7 seconds
 const increment = 100 / 70;
 let progress = 0;
 let steps = 0;
 
 const progressInterval = setInterval(function() {
 steps++;
 // Make the progress slightly non-linear to look more natural
 if (steps <= 60) {
 // First 6 seconds: slower progress
 progress += increment * 0.9;
 } else {
 // Last second: speed up to ensure we hit 100%
 progress += increment * 1.5;
 }
 
 // Ensure we don't exceed 100%
 progress = Math.min(progress, 99);
 progressBar.style.width = progress + '%';
 }, 100);
 
 // Force the preloader to stay for exactly 7 seconds
 setTimeout(function() {
 // Ensure progress bar is at 100%
 progressBar.style.width = '100%';
 clearInterval(progressInterval);
 
 // Fade out the preloader
 preloader.style.opacity = '0';
 
 // Remove from DOM after fade completes
 setTimeout(function() {
 preloader.style.display = 'none';
 }, 500);
 }, 7000); // 7 seconds for the loading screen
 }

// Add UI event listeners
 function addUIEventListeners() {
 document.getElementById("recenterButton").addEventListener("click", () => {
 recenterMap();
 resetInactivityTimer();
 });
 document.getElementById("returnButton").addEventListener("click", () => {
 returnToIndex();
 resetInactivityTimer();
 });
 document.getElementById("tipsButton").addEventListener("click", () => {
 toggleNavigationTips();
 resetInactivityTimer();
 });
 document.querySelector(".navigation-tips .close-button").addEventListener("click", () => {
 closeNavigationTips();
 resetInactivityTimer();
 });
 }

// Add map event listeners
 function addMapEventListeners() {
 const startInteraction = () => {
 isMapInteracting = true;
 userIsInteracting = true;
 followUser = false;
 resetInactivityTimer();
 };

 map.on("movestart zoomstart dragstart", startInteraction);
 }

// Reset inactivity timer
 function resetInactivityTimer() {
 clearTimeout(window.inactivityTimer);
 window.inactivityTimer = setTimeout(checkInactivity, INACTIVITY_TIMEOUT);
 }

// Check for user inactivity
 function checkInactivity() {
 console.log("Inactivity timer triggered");
 isMapInteracting = false;
 userIsInteracting = false;

 // Close any open popups
 map.closePopup();
 map.eachLayer((layer) => {
 if (layer.getPopup && layer.getPopup()?.isOpen()) {
 layer.closePopup();
 }
 });

 if (!isMapInteracting && !userIsInteracting) {
 recenterMap();
 }
 }

// Recenter map (completing the function)
 function recenterMap() {
 const recenterButton = document.getElementById("recenterButton");
 if (recenterButton) {
 recenterButton.style.backgroundColor = "var(--primary-color)";
 recenterButton.style.color = "white";
 }

 // Force map to center on user marker immediately
 if (userMarker && userMarker.getLatLng()) {
 map.closePopup();

 // Get dynamic zoom level based on current speed
 const zoomLevel = calculateZoomLevel(currentSpeed);
 
 // Set view with animation
 map.setView(userMarker.getLatLng(), zoomLevel, {
 animate: true,
 duration: 0.5,
 noMoveStart: true
 });
 
 followUser = true;
 }

 // Reset button style after animation
 setTimeout(() => {
 if (recenterButton) {
 recenterButton.style.backgroundColor = "var(--bg-color)";
 recenterButton.style.color = "var(--primary-color)";
 }
 }, 500);
 }

// Toggle navigation tips
 function toggleNavigationTips() {
 const tipsElement = document.querySelector('.navigation-tips');
 if (tipsElement) {
 const isVisible = tipsElement.style.display === 'block';
 tipsElement.style.display = isVisible ? 'none' : 'block';
 
 // Add transition effect
 if (!isVisible) {
 tipsElement.style.opacity = '0';
 tipsElement.style.transform = 'translateY(-20px)';
 setTimeout(() => {
 tipsElement.style.opacity = '1';
 tipsElement.style.transform = 'translateY(0)';
 tipsElement.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
 }, 10);
 }
 }
 }

// Close navigation tips
 function closeNavigationTips() {
 const tipsElement = document.querySelector('.navigation-tips');
 if (tipsElement) {
 tipsElement.style.opacity = '0';
 tipsElement.style.transform = 'translateY(-20px)';
 tipsElement.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
 
 setTimeout(() => {
 tipsElement.style.display = 'none';
 }, 300);
 }
 }

// Return to index page
 function returnToIndex() {
 showPopup("Exit Tour", "Are you sure you want to exit the tour?", "confirm", () => {
 // Save last known position before exiting
 if (lastValidPosition) {
 localStorage.setItem('lastKnownLocation', JSON.stringify(lastValidPosition));
 }
 
 // Navigate to index page
 window.location.href = '/index.html';
 });
 }

// Show location hunt
 function showLocationHunt(location) {
 if (!location || isLocationHuntVisible) return;
 
 isLocationHuntVisible = true;
 
 // Preload image if not already loaded
 if (location.image && !preloadedImages.has(location.image)) {
 const img = new Image();
 img.src = location.image;
 preloadedImages.set(location.image, img);
 }
 
 // Preload audio if not already loaded
 if (location.audio && !preloadedAudio.has(location.audio)) {
 const audio = new Audio();
 audio.src = location.audio;
 preloadedAudio.set(location.audio, audio);
 }
 
 // Set location information with transition effect
 const locationTitle = document.getElementById('locationTitle');
 const locationCity = document.getElementById('locationCity');
 const locationCreator = document.getElementById('locationCreator');
 const locationImage = document.getElementById('locationImage');
 const locationAudio = document.getElementById('locationAudio');
 
 // Apply transition classes
 [locationTitle, locationCity, locationCreator].forEach(el => {
 if (el) {
 el.classList.add('location-transition');
 setTimeout(() => el.classList.add('visible'), 50);
 }
 });
 
 // Set content
 if (locationTitle) locationTitle.textContent = location.name;
 if (locationCity) locationCity.textContent = location.city || '';
 if (locationCreator) locationCreator.textContent = location.creator ? `Created by: ${location.creator}` : '';
 if (locationImage) locationImage.src = location.image || '/placeholder.svg?height=200&width=400';
 if (locationAudio) locationAudio.src = location.audio || '';
 
 // Show location hunt container with animation
 const lochuntContainer = document.querySelector('.lochunt-container');
 if (lochuntContainer) {
 lochuntContainer.classList.add('active');
 }
 
 // Initialize audio player
 initAudioPlayer();
 
 // Add to visited locations if not already visited
 if (!visitedLocations.includes(location.id)) {
 visitedLocations.push(location.id);
 
 // Store visited locations in localStorage for persistence
 try {
 localStorage.setItem('visitedLocations', JSON.stringify(visitedLocations));
 } catch (e) {
 console.warn('Could not save visited locations to localStorage', e);
 }
 }
 
 // Update UI to reflect visited state
 updateLocationMarkers();
 }

// Initialize audio player
 function initAudioPlayer() {
 const audio = document.getElementById('locationAudio');
 const playPauseBtn = document.getElementById('playPauseBtn');
 const rewindBtn = document.getElementById('rewindBtn');
 const forwardBtn = document.getElementById('forwardBtn');
 const progressBar = document.getElementById('progressBar');
 const currentTimeSpan = document.getElementById('currentTime');
 const durationSpan = document.getElementById('duration');
 
 if (!audio || !playPauseBtn) return;
 
 // Reset player state
 audio.currentTime = 0;
 progressBar.style.width = '0%';
 playPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
 
 // Set up event listeners
 playPauseBtn.addEventListener('click', togglePlay);
 rewindBtn.addEventListener('click', () => seek(-10));
 forwardBtn.addEventListener('click', () => seek(10));
 
 // Remove existing event listeners to prevent duplicates
 audio.removeEventListener('timeupdate', updateProgress);
 audio.removeEventListener('loadedmetadata', setDuration);
 audio.removeEventListener('ended', audioEnded);
 
 // Add event listeners
 audio.addEventListener('timeupdate', updateProgress);
 audio.addEventListener('loadedmetadata', setDuration);
 audio.addEventListener('ended', audioEnded);
 
 // Play/pause function
 function togglePlay() {
 if (audio.paused) {
 const playPromise = audio.play();
 if (playPromise !== undefined) {
 playPromise.then(() => {
 playPauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
 }).catch(error => {
 console.error('Audio playback failed:', error);
 showErrorMessage('Audio playback failed. Please try again.');
 });
 }
 } else {
 audio.pause();
 playPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
 }
 }
 
 // Seek function
 function seek(seconds) {
 if (!audio.duration) return;
 audio.currentTime = Math.max(0, Math.min(audio.currentTime + seconds, audio.duration));
 updateProgress();
 }
 
 // Update progress bar
 function updateProgress() {
 if (!audio.duration) return;
 const percent = (audio.currentTime / audio.duration) * 100;
 progressBar.style.width = `${percent}%`;
 currentTimeSpan.textContent = formatTime(audio.currentTime);
 }
 
 // Set duration
 function setDuration() {
 durationSpan.textContent = formatTime(audio.duration || 0);
 }
 
 // Format time (convert seconds to MM:SS format)
 function formatTime(time) {
 const minutes = Math.floor(time / 60);
 const seconds = Math.floor(time % 60);
 return `${minutes}:${seconds.toString().padStart(2, '0')}`;
 }
 
 // Handle audio ended event
 function audioEnded() {
 playPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
 showAdditionalInfo();
 }
 }

// Show additional information after audio ends
 function showAdditionalInfo() {
 // Hide location hunt container
 const lochuntContainer = document.querySelector('.lochunt-container');
 if (lochuntContainer) {
 lochuntContainer.classList.remove('active');
 }
 
 // Get current location
 const currentLocation = gameLocations[currentLocationIndex];
 if (!currentLocation) return;
 
 // Set additional info content
 const additionalInfoElement = document.getElementById('additionalInfo');
 if (additionalInfoElement) {
 additionalInfoElement.textContent = currentLocation.additionalInfo || 
 "Did you know? This location has a rich history that connects to Minnesota's past.";
 }
 
 // Show additional info container with animation
 const additionalInfoContainer = document.querySelector('.additional-info-container');
 if (additionalInfoContainer) {
 additionalInfoContainer.classList.add('location-transition');
 additionalInfoContainer.style.display = 'block';
 
 setTimeout(() => {
 additionalInfoContainer.classList.add('visible');
 }, 50);
 }
 
 // Set up continue button
 const continueButton = document.getElementById('continueButton');
 if (continueButton) {
 // Remove existing event listeners to prevent duplicates
 const newButton = continueButton.cloneNode(true);
 continueButton.parentNode.replaceChild(newButton, continueButton);
 
 // Add event listener
 newButton.addEventListener('click', () => {
 // Hide additional info container
 additionalInfoContainer.classList.remove('visible');
 
 setTimeout(() => {
 additionalInfoContainer.style.display = 'none';
 
 // Move to next location
 moveToNextLocation();
 }, 300);
 });
 }
 }

// Move to next location
 function moveToNextLocation() {
 // Remove the current marker from the map
 if (currentLocationIndex < allLocationMarkers.length) {
 map.removeLayer(allLocationMarkers[currentLocationIndex]);
 }
 
 // Move to next location
 currentLocationIndex++;
 isLocationHuntVisible = false;
 
 // Check if we've reached the end
 if (currentLocationIndex >= gameLocations.length) {
 showCongratulations();
 } else {
 // Update visible markers for the next location
 updateVisibleMarkers();
 
 // Update distance box for new location
 if (lastPosition) {
 const location = gameLocations[currentLocationIndex];
 if (location) {
 const distance = calculateDistance(
 { lat: lastPosition.lat, lng: lastPosition.lng },
 { lat: location.lat, lng: location.lng }
 );
 const distanceFeet = Math.round(distance * 3.28084);
 updateDistanceBox();
 }
 }
 
 // Reset proximity state
 isNearLocation = false;
 lastZoomChangeTime = 0;
 }
 }

// Update location markers
 function updateLocationMarkers() {
 // Update marker styles based on visited state
 allLocationMarkers.forEach((marker, index) => {
 const location = gameLocations[index];
 if (!location) return;
 
 // Check if location has been visited
 const isVisited = visitedLocations.includes(location.id);
 
 // Get marker element
 const markerElement = marker.getElement();
 if (markerElement) {
 const iconElement = markerElement.querySelector('.location-marker-icon');
 if (iconElement) {
 // Update marker style based on visited state
 if (isVisited) {
 iconElement.classList.add('visited');
 } else {
 iconElement.classList.remove('visited');
 }
 }
 }
 });
 }

// Show congratulations screen
 function showCongratulations() {
 // Create congratulations element if it doesn't exist
 let congratsElement = document.getElementById('congratulations');
 
 if (!congratsElement) {
 congratsElement = document.createElement('div');
 congratsElement.id = 'congratulations';
 congratsElement.innerHTML = `
 <h2>Congratulations!</h2>
 <p>You have successfully completed the Minnesota Then Museum Without Walls tour!</p>
 <button id="finishTourButton">Return to Home</button>
 `;
 document.body.appendChild(congratsElement);
 
 // Add event listener to finish button
 const finishButton = document.getElementById('finishTourButton');
 if (finishButton) {
 finishButton.addEventListener('click', () => {
 window.location.href = '/index.html';
 });
 }
 }
 
 // Show congratulations with animation
 congratsElement.style.display = 'flex';
 congratsElement.style.opacity = '0';
 
 setTimeout(() => {
 congratsElement.style.opacity = '1';
 congratsElement.style.transition = 'opacity 0.5s ease';
 }, 50);
 
 // Save completion status
 try {
 localStorage.setItem('tourCompleted', 'true');
 localStorage.setItem('completionDate', new Date().toISOString());
 } catch (e) {
 console.warn('Could not save tour completion status', e);
 }
 }

// Start the hunt
 function startHunt() {
 // Load locations from external source if available
 if (typeof window.locations !== 'undefined' && Array.isArray(window.locations)) {
 gameLocations = window.locations;
 } else {
 // Use sample locations as fallback
 gameLocations = locations;
 }
 
 // Create markers for all locations
 createLocationMarkers();
 
 // Update visible markers
 updateVisibleMarkers();
 
 // Update distance box
 updateDistanceBox();
 
 // Load visited locations from localStorage
 try {
 const savedVisitedLocations = localStorage.getItem('visitedLocations');
 if (savedVisitedLocations) {
 const parsed = JSON.parse(savedVisitedLocations);
 if (Array.isArray(parsed)) {
 visitedLocations.push(...parsed);
 }
 }
 } catch (e) {
 console.warn('Could not load visited locations from localStorage', e);
 }
 
 // Update marker styles based on visited state
 updateLocationMarkers();
 }

// Create location markers
 function createLocationMarkers() {
 // Clear existing markers
 allLocationMarkers = [];
 
 // Create markers for all locations
 gameLocations.forEach((location, index) => {
 if (!location || typeof location.lat !== 'number' || typeof location.lng !== 'number') {
 console.warn('Invalid location data:', location);
 return;
 }
 
 // Create numbered marker icon
 const locationIcon = L.divIcon({
 className: 'location-marker',
 html: `<div class="location-marker-icon">${index + 1}</div>`,
 iconSize: [40, 40],
 iconAnchor: [20, 20]
 });
 
 const marker = L.marker([location.lat, location.lng], {
 icon: locationIcon
 });
 
 // Add popup with location info
 const popupContent = `
 <div class="marker-popup">
 <img src="${location.image || '/placeholder.svg?height=150&width=280'}" class="marker-popup-image" alt="${location.name}">
 <div class="marker-popup-content">
 <div class="marker-popup-title">${location.name}</div>
 <div class="marker-popup-description">${location.description ? location.description.substring(0, 100) + '...' : ''}</div>
 <div class="marker-popup-actions">
 <button class="popup-btn directions" onclick="showDirectionsModal(${index})">
 <i class="fas fa-directions"></i> Directions
 </button>
 <button class="popup-btn skip" onclick="skipToNextLocation()">
 <i class="fas fa-forward"></i> Skip
 </button>
 </div>
 </div>
 </div>
 `;
 
 const popup = L.popup({
 closeButton: true,
 autoClose: false,
 closeOnEscapeKey: true,
 closeOnClick: false,
 className: 'custom-popup',
 maxWidth: 300
 }).setContent(popupContent);
 
 marker.bindPopup(popup);
 
 // Add click event to marker
 marker.on('click', () => {
 marker.openPopup();
 });
 
 allLocationMarkers.push(marker);
 });
 }

// Update visible markers based on current progress
 function updateVisibleMarkers() {
 // Remove all existing markers from map
 allLocationMarkers.forEach(marker => {
 if (map.hasLayer(marker)) {
 map.removeLayer(marker);
 }
 });
 
 // Show only the current marker
 if (currentLocationIndex < allLocationMarkers.length) {
 allLocationMarkers[currentLocationIndex].addTo(map);
 }
 }

// Show directions modal
 function showDirectionsModal(locationIndex) {
 const location = gameLocations[locationIndex];
 if (!location) return;
 
 // Create modal if it doesn't exist
 let directionsModal = document.getElementById('directionsModal');
 
 if (!directionsModal) {
 directionsModal = document.createElement('div');
 directionsModal.id = 'directionsModal';
 directionsModal.innerHTML = `
 <div class="directions-modal-content">
 <div class="directions-modal-title">Choose Navigation App</div>
 <div class="directions-buttons">
 <a href="#" id="googleMapsBtn" class="direction-btn google" target="_blank">
 <i class="fab fa-google"></i> Google Maps
 </a>
 <a href="#" id="appleMapsBtn" class="direction-btn apple" target="_blank">
 <i class="fab fa-apple"></i> Apple Maps
 </a>
 <a href="#" id="wazeBtn" class="direction-btn waze" target="_blank">
 <i class="fab fa-waze"></i> Waze
 </a>
 </div>
 <button class="cancel-btn" onclick="closeDirectionsModal()">Cancel</button>
 </div>
 `;
 document.body.appendChild(directionsModal);
 }
 
 // Set up navigation links
 const googleMapsBtn = document.getElementById('googleMapsBtn');
 const appleMapsBtn = document.getElementById('appleMapsBtn');
 const wazeBtn = document.getElementById('wazeBtn');
 
 if (googleMapsBtn) {
 googleMapsBtn.href = `https://www.google.com/maps/dir/?api=1&destination=${location.lat},${location.lng}&travelmode=walking`;
 }
 
 if (appleMapsBtn) {
 appleMapsBtn.href = `maps://maps.apple.com/?daddr=${location.lat},${location.lng}&dirflg=w`;
 
 // Hide Apple Maps button on non-iOS devices
 const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
 appleMapsBtn.style.display = isIOS ? 'flex' : 'none';
 }
 
 if (wazeBtn) {
 wazeBtn.href = `https://waze.com/ul?ll=${location.lat},${location.lng}&navigate=yes`;
 }
 
 // Show modal with animation
 directionsModal.style.display = 'flex';
 directionsModal.style.opacity = '0';
 
 setTimeout(() => {
 directionsModal.style.opacity = '1';
 directionsModal.style.transition = 'opacity 0.3s ease';
 }, 50);
 }

// Close directions modal
 function closeDirectionsModal() {
 const directionsModal = document.getElementById('directionsModal');
 if (directionsModal) {
 directionsModal.style.opacity = '0';
 
 setTimeout(() => {
 directionsModal.style.display = 'none';
 }, 300);
 }
 }

// Skip to next location
 function skipToNextLocation() {
 // Close any open popups
 map.closePopup();
 
 // Move to next location
 moveToNextLocation();
 }

// Initialize the application (continuing from where we left off)
 document.addEventListener('DOMContentLoaded', () => {
 // Initialize map
 initMap();
 
 // Make functions available globally for event handlers
 window.showDirectionsModal = showDirectionsModal;
 window.closeDirectionsModal = closeDirectionsModal;
 window.skipToNextLocation = skipToNextLocation;
 
 // Add event listener for the continue button
 const continueButton = document.getElementById('continueButton');
 if (continueButton) {
 continueButton.addEventListener('click', () => {
 const additionalInfoContainer = document.querySelector('.additional-info-container');
 if (additionalInfoContainer) {
 additionalInfoContainer.classList.remove('visible');
 
 setTimeout(() => {
 additionalInfoContainer.style.display = 'none';
 moveToNextLocation();
 }, 300);
 }
 });
 }
 
 // Add event listeners for audio player buttons
 const playPauseBtn = document.getElementById('playPauseBtn');
 const rewindBtn = document.getElementById('rewindBtn');
 const forwardBtn = document.getElementById('forwardBtn');
 const audio = document.getElementById('locationAudio');
 
 if (playPauseBtn && audio) {
 playPauseBtn.addEventListener('click', () => {
 if (audio.paused) {
 audio.play().catch(error => {
 console.error('Audio playback failed:', error);
 showErrorMessage('Audio playback failed. Please try again.');
 });
 playPauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
 } else {
 audio.pause();
 playPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
 }
 });
 }
 
 if (rewindBtn && audio) {
 rewindBtn.addEventListener('click', () => {
 if (!audio.duration) return;
 audio.currentTime = Math.max(0, audio.currentTime - 10);
 });
 }
 
 if (forwardBtn && audio) {
 forwardBtn.addEventListener('click', () => {
 if (!audio.duration) return;
 audio.currentTime = Math.min(audio.duration, audio.currentTime + 10);
 });
 }
 
 // Add resize event listener
 window.addEventListener('resize', () => {
 if (map) {
 map.invalidateSize();
 updateMapViewportDimensions();
 }
 });
 
 // Add orientation change event listener for mobile devices
 window.addEventListener('orientationchange', () => {
 setTimeout(() => {
 if (map) {
 map.invalidateSize();
 updateMapViewportDimensions();
 
 // Recenter map after orientation change if following user
 if (followUser && userMarker) {
 map.setView(userMarker.getLatLng(), map.getZoom(), {
 animate: true,
 duration: 0.5
 });
 }
 }
 }, 200);
 });
 
 // Load visited locations from localStorage
 try {
 const savedVisitedLocations = localStorage.getItem('visitedLocations');
 if (savedVisitedLocations) {
 const parsed = JSON.parse(savedVisitedLocations);
 if (Array.isArray(parsed)) {
 visitedLocations.push(...parsed);
 }
 }
 } catch (e) {
 console.warn('Could not load visited locations from localStorage', e);
 }
 
 // Check if returning from background after a long time
 if (document.hidden) {
 lastHiddenTime = Date.now();
 }
 });

// Add additional utility functions for enhanced user experience

// Preload resources for better performance
 function preloadResources() {
 // Preload location images
 if (gameLocations && gameLocations.length > 0) {
 gameLocations.forEach(location => {
 if (location.image && !preloadedImages.has(location.image)) {
 const img = new Image();
 img.src = location.image;
 preloadedImages.set(location.image, img);
 }
 });
 }
 
 // Preload audio files (only the next few to save bandwidth)
 const preloadAheadCount = 2; // Number of audio files to preload ahead
 for (let i = currentLocationIndex; i < Math.min(currentLocationIndex + preloadAheadCount, gameLocations.length); i++) {
 const location = gameLocations[i];
 if (location && location.audio && !preloadedAudio.has(location.audio)) {
 const audio = new Audio();
 audio.preload = 'metadata'; // Just load metadata first to save bandwidth
 audio.src = location.audio;
 preloadedAudio.set(location.audio, audio);
 }
 }
 }

// Handle network status changes
 function handleNetworkChange() {
 window.addEventListener('online', () => {
 console.log('Network connection restored');
 // Refresh map tiles
 if (map) {
 map.eachLayer(layer => {
 if (layer.redraw) {
 layer.redraw();
 }
 });
 }
 
 // Retry loading any failed resources
 preloadResources();
 });
 
 window.addEventListener('offline', () => {
 console.log('Network connection lost');
 showErrorMessage('Network connection lost. Some features may be limited.');
 });
 }

// Add support for PWA installation
 function setupPWASupport() {
 let deferredPrompt;
 
 window.addEventListener('beforeinstallprompt', (e) => {
 // Prevent Chrome 67 and earlier from automatically showing the prompt
 e.preventDefault();
 // Stash the event so it can be triggered later
 deferredPrompt = e;
 
 // Show install button if available
 const installButton = document.getElementById('installButton');
 if (installButton) {
 installButton.style.display = 'block';
 
 installButton.addEventListener('click', () => {
 // Show the install prompt
 deferredPrompt.prompt();
 
 // Wait for the user to respond to the prompt
 deferredPrompt.userChoice.then((choiceResult) => {
 if (choiceResult.outcome === 'accepted') {
 console.log('User accepted the install prompt');
 } else {
 console.log('User dismissed the install prompt');
 }
 deferredPrompt = null;
 installButton.style.display = 'none';
 });
 });
 }
 });
 }

// Add accessibility enhancements
 function enhanceAccessibility() {
 // Add keyboard navigation for map controls
 const mapButtons = document.querySelectorAll('.map-button');
 mapButtons.forEach(button => {
 button.setAttribute('tabindex', '0');
 button.setAttribute('role', 'button');
 
 button.addEventListener('keydown', (e) => {
 if (e.key === 'Enter' || e.key === ' ') {
 e.preventDefault();
 button.click();
 }
 });
 });
 
 // Add screen reader announcements for important events
 function announceForScreenReader(message) {
 const announcement = document.createElement('div');
 announcement.setAttribute('aria-live', 'polite');
 announcement.classList.add('sr-only');
 announcement.textContent = message;
 document.body.appendChild(announcement);
 
 setTimeout(() => {
 document.body.removeChild(announcement);
 }, 3000);
 }
 
 // Announce when user reaches a location
 const originalShowLocationHunt = showLocationHunt;
 window.showLocationHunt = function(location) {
 originalShowLocationHunt(location);
 if (location) {
 announceForScreenReader(`You have reached ${location.name}. Audio information is now playing.`);
 }
 };
 
 // Add high contrast mode toggle
 const highContrastButton = document.createElement('button');
 highContrastButton.id = 'highContrastButton';
 highContrastButton.className = 'accessibility-button';
 highContrastButton.innerHTML = '<i class="fas fa-adjust"></i>';
 highContrastButton.setAttribute('aria-label', 'Toggle high contrast mode');
 highContrastButton.setAttribute('title', 'Toggle high contrast mode');
 
 highContrastButton.addEventListener('click', () => {
 document.body.classList.toggle('high-contrast');
 const isHighContrast = document.body.classList.contains('high-contrast');
 localStorage.setItem('highContrast', isHighContrast ? 'true' : 'false');
 announceForScreenReader(`High contrast mode ${isHighContrast ? 'enabled' : 'disabled'}`);
 });
 
 document.body.appendChild(highContrastButton);
 
 // Check for saved preference
 if (localStorage.getItem('highContrast') === 'true') {
 document.body.classList.add('high-contrast');
 }
 }

// Add battery optimization for mobile devices
 function optimizeBattery() {
 // Reduce update frequency when battery is low
 if ('getBattery' in navigator) {
 navigator.getBattery().then(battery => {
 function updateBatteryStatus() {
 const lowBattery = battery.level < 0.2 && !battery.charging;
 
 if (lowBattery) {
 // Reduce update frequency to save battery
 if (watchPositionId) {
 navigator.geolocation.clearWatch(watchPositionId);
 watchPositionId = navigator.geolocation.watchPosition(
 handlePositionUpdate,
 handleLocationError,
 {
 enableHighAccuracy: false,
 maximumAge: 10000,
 timeout: 15000
 }
 );
 }
 
 // Show low battery notification
 showErrorMessage('Low battery detected. Some features may be limited to save power.');
 } else if (isWatchPositionActive) {
 // Restore normal update frequency
 if (watchPositionId) {
 navigator.geolocation.clearWatch(watchPositionId);
 watchPositionId = navigator.geolocation.watchPosition(
 handlePositionUpdate,
 handleLocationError,
 {
 enableHighAccuracy: true,
 maximumAge: 0,
 timeout: 10000
 }
 );
 }
 }
 }
 
 // Listen for battery status changes
 battery.addEventListener('levelchange', updateBatteryStatus);
 battery.addEventListener('chargingchange', updateBatteryStatus);
 
 // Initial check
 updateBatteryStatus();
 });
 }
 }

// Initialize additional features
 function initAdditionalFeatures() {
 handleNetworkChange();
 setupPWASupport();
 enhanceAccessibility();
 optimizeBattery();
 
 // Check for return visits
 const lastVisit = localStorage.getItem('lastVisit');
 if (lastVisit) {
 const daysSinceLastVisit = (Date.now() - new Date(lastVisit).getTime()) / (1000 * 60 * 60 * 24);
 
 if (daysSinceLastVisit > 7) {
 // Show welcome back message for returning users after a week
 showPopup('Welcome Back!', 'It\'s been a while since your last visit. Would you like to continue your tour or start a new one?', 'confirm', () => {
 // Continue existing tour
 const savedLocationIndex = localStorage.getItem('currentLocationIndex');
 if (savedLocationIndex) {
 currentLocationIndex = parseInt(savedLocationIndex, 10);
 updateVisibleMarkers();
 }
 });
 }
 }
 
 // Save current visit timestamp
 localStorage.setItem('lastVisit', new Date().toISOString());
 }

// Call additional initialization
 document.addEventListener('DOMContentLoaded', () => {
 // Initialize additional features after the main app is loaded
 setTimeout(initAdditionalFeatures, 2000);
 });

// Add CSS styles for new features
 const additionalStyles = document.createElement('style');
 additionalStyles.textContent = `
 /* High contrast mode */
 body.high-contrast {
 filter: contrast(1.4);
 }
 
 /* Accessibility button */
 .accessibility-button {
 position: fixed;
 top: 20px;
 right: 20px;
 width: 40px;
 height: 40px;
 border-radius: 50%;
 background-color: rgba(255, 255, 255, 0.9);
 color: #333;
 border: none;
 box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
 display: flex;
 align-items: center;
 justify-content: center;
 cursor: pointer;
 z-index: 1000;
 }
 
 /* Screen reader only text */
 .sr-only {
 position: absolute;
 width: 1px;
 height: 1px;
 padding: 0;
 margin: -1px;
 overflow: hidden;
 clip: rect(0, 0, 0, 0);
 white-space: nowrap;
 border: 0;
 }
 
 /* Stabilizing modal */
 .stabilizing-modal {
 position: fixed;
 top: 0;
 left: 0;
 width: 100%;
 height: 100%;
 background-color: rgba(0, 0, 0, 0.7);
 display: flex;
 flex-direction: column;
 align-items: center;
 justify-content: center;
 z-index: 2000;
 color: white;
 transition: opacity 0.5s ease;
 }
 
 .stabilizing-modal .spinner {
 width: 50px;
 height: 50px;
 border: 5px solid rgba(255, 255, 255, 0.3);
 border-radius: 50%;
 border-top-color: white;
 animation: spin 1s ease-in-out infinite;
 margin-bottom: 20px;
 }
 
 @keyframes spin {
 to { transform: rotate(360deg); }
 }
 
 /* Directions modal */
 #directionsModal {
 position: fixed;
 top: 0;
 left: 0;
 width: 100%;
 height: 100%;
 background-color: rgba(0, 0, 0, 0.7);
 display: none;
 align-items: center;
 justify-content: center;
 z-index: 2000;
 transition: opacity 0.3s ease;
 }
 
 .directions-modal-content {
 background-color: white;
 border-radius: 16px;
 padding: 24px;
 width: 90%;
 max-width: 400px;
 text-align: center;
 }
 
 .directions-modal-title {
 font-size: 20px;
 font-weight: 600;
 margin-bottom: 20px;
 color: #333;
 }
 
 .directions-buttons {
 display: flex;
 flex-direction: column;
 gap: 12px;
 margin-bottom: 20px;
 }
 
 .direction-btn {
 display: flex;
 align-items: center;
 justify-content: center;
 padding: 12px;
 border-radius: 8px;
 text-decoration: none;
 color: white;
 font-weight: 500;
 transition: all 0.2s ease;
 }
 
 .direction-btn.google {
 background-color: #4285F4;
 }
 
 .direction-btn.apple {
 background-color: #000000;
 }
 
 .direction-btn.waze {
 background-color: #33CCFF;
 }
 
 .direction-btn i {
 margin-right: 8px;
 font-size: 18px;
 }
 
 .cancel-btn {
 background-color: #f2f2f2;
 color: #333;
 border: none;
 border-radius: 8px;
 padding: 12px 24px;
 font-weight: 500;
 cursor: pointer;
 transition: all 0.2s ease;
 }
 
 .cancel-btn:hover {
 background-color: #e5e5e5;
 }
 
 /* Congratulations screen */
 #congratulations {
 position: fixed;
 top: 0;
 left: 0;
 width: 100%;
 height: 100%;
 background-color: rgba(0, 0, 0, 0.8);
 display: none;
 flex-direction: column;
 align-items: center;
 justify-content: center;
 z-index: 2000;
 color: white;
 text-align: center;
 padding: 20px;
 }
 
 #congratulations h2 {
 font-size: 32px;
 margin-bottom: 16px;
 }
 
 #congratulations p {
 font-size: 18px;
 margin-bottom: 32px;
 max-width: 600px;
 }
 
 #finishTourButton {
 background-color: #0f2bab;
 color: white;
 border: none;
 border-radius: 8px;
 padding: 12px 24px;
 font-size: 16px;
 font-weight: 500;
 cursor: pointer;
 transition: all 0.2s ease;
 }
 
 #finishTourButton:hover {
 background-color: #0a1f8f;
 }
 
 /* Error message */
 .error-message {
 position: fixed;
 top: 20px;
 left: 50%;
 transform: translateX(-50%);
 background-color: #ff3b30;
 color: white;
 padding: 12px 20px;
 border-radius: 8px;
 box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
 z-index: 2000;
 max-width: 90%;
 text-align: center;
 font-weight: 500;
 }
 
 /* Location transitions */
 .lochunt-container {
 transform: translateY(100%);
 transition: transform 0.5s ease;
 }
 
 .lochunt-container.active {
 transform: translateY(0);
 }
 
 .additional-info-container {
 display: none;
 opacity: 0;
 transform: translateY(20px);
 transition: opacity 0.5s ease, transform 0.5s ease;
 }
 
 .additional-info-container.visible {
 opacity: 1;
 transform: translateY(0);
 }
 
 /* User marker */
 .user-marker-icon {
 width: 20px;
 height: 20px;
 background-color: #ff3b30;
 border-radius: 50%;
 border: 2px solid white;
 box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
 position: relative;
 }
 
 .user-marker-direction {
 position: absolute;
 top: -8px;
 left: 50%;
 transform: translateX(-50%);
 width: 0;
 height: 0;
 border-left: 6px solid transparent;
 border-right: 6px solid transparent;
 border-bottom: 10px solid #ff3b30;
 }
 
 .user-marker-icon.pulsing {
 animation: pulse 1s infinite;
 }
 
 @keyframes pulse {
 0% {
 transform: scale(1);
 opacity: 1;
 }
 50% {
 transform: scale(1.2);
 opacity: 0.8;
 }
 100% {
 transform: scale(1);
 opacity: 1;
 }
 }
 
 /* Location marker */
 .location-marker-icon {
 width: 40px;
 height: 40px;
 background-color: #0f2bab;
 border-radius: 50%;
 border: 2px solid white;
 box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
 display: flex;
 align-items: center;
 justify-content: center;
 color: white;
 font-weight: bold;
 font-size: 16px;
 transition: all 0.3s ease;
 }
 
 .location-marker-icon.visited {
 background-color: #4CAF50;
 }
 
 /* Marker popup */
 .marker-popup {
 padding: 0;
 overflow: hidden;
 border-radius: 8px;
 }
 
 .marker-popup-image {
 width: 100%;
 height: 150px;
 object-fit: cover;
 }
 
 .marker-popup-content {
 padding: 12px;
 }
 
 .marker-popup-title {
 font-size: 16px;
 font-weight: 600;
 margin-bottom: 8px;
 color: #333;
 }
 
 .marker-popup-description {
 font-size: 14px;
 color: #666;
 margin-bottom: 12px;
 }
 
 .marker-popup-actions {
 display: flex;
 gap: 8px;
 }
 
 .popup-btn {
 flex: 1;
 padding: 8px;
 border: none;
 border-radius: 4px;
 font-size: 12px;
 font-weight: 500;
 cursor: pointer;
 display: flex;
 align-items: center;
 justify-content: center;
 transition: all 0.2s ease;
 }
 
 .popup-btn i {
 margin-right: 4px;
 }
 
 .popup-btn.directions {
 background-color: #0f2bab;
 color: white;
 }
 
 .popup-btn.skip {
 background-color: #f2f2f2;
 color: #333;
 }
 
 /* Media queries for better responsiveness */
 @media (max-width: 480px) {
 .marker-popup {
 max-width: 280px;
 }
 
 .marker-popup-image {
 height: 120px;
 }
 
 .directions-modal-content {
 padding: 16px;
 }
 
 .direction-btn {
 padding: 10px;
 }
 
 #congratulations h2 {
 font-size: 28px;
 }
 
 #congratulations p {
 font-size: 16px;
 }
 }
 
 @media (max-height: 600px) {
 .lochunt-container {
 max-height: 70vh;
 overflow-y: auto;
 }
 
 .directions-modal-content {
 max-height: 80vh;
 overflow-y: auto;
 }
 }
 
 /* Support for iOS devices with notches */
 @supports (padding-bottom: env(safe-area-inset-bottom)) {
 .lochunt-container {
 padding-bottom: env(safe-area-inset-bottom, 0px);
 }
 
 .additional-info-container {
 padding-bottom: env(safe-area-inset-bottom, 0px);
 }
 }
 `;

document.head.appendChild(additionalStyles);

// Initialize the map when the DOM is loaded (continuing from where we left off)
 window.addEventListener('load', () => {
 // Hide preloader after map is initialized
 const preloader = document.getElementById('preloader');
 if (preloader) {
 setTimeout(() => {
 preloader.style.opacity = '0';
 setTimeout(() => {
 preloader.style.display = 'none';
 }, 500);
 }, 1000);
 }
 
 // Start the hunt
 startHunt();
 
 // Check for saved position
 try {
 const savedPosition = localStorage.getItem('lastKnownLocation');
 if (savedPosition) {
 const position = JSON.parse(savedPosition);
 if (position && position.lat && position.lng) {
 // Create user marker at saved position
 createUserMarker(position);
 
 // Center map on saved position
 map.setView([position.lat, position.lng], 17);
 }
 }
 } catch (e) {
 console.warn('Could not load saved position', e);
 }
 
 // Start location tracking
 startLocationTracking();
 });

// Show error message
 function showErrorMessage(message, duration = 3000) {
 // Remove any existing error messages
 const existingErrors = document.querySelectorAll('.error-message');
 existingErrors.forEach(error => {
 document.body.removeChild(error);
 });
 
 // Create new error message
 const errorElement = document.createElement('div');
 errorElement.className = 'error-message';
 errorElement.textContent = message;
 document.body.appendChild(errorElement);
 
 // Add animation
 errorElement.style.opacity = '0';
 errorElement.style.transform = 'translateY(-20px)';
 
 setTimeout(() => {
 errorElement.style.opacity = '1';
 errorElement.style.transform = 'translateY(0)';
 errorElement.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
 }, 10);
 
 // Remove after duration
 setTimeout(() => {
 errorElement.style.opacity = '0';
 errorElement.style.transform = 'translateY(-20px)';
 
 setTimeout(() => {
 if (document.body.contains(errorElement)) {
 document.body.removeChild(errorElement);
 }
 }, 300);
 }, duration);
 }

// Show popup
 function showPopup(title, message, type = 'alert', confirmCallback = null) {
 // Create popup if it doesn't exist
 let popupElement = document.getElementById('customPopup');
 
 if (!popupElement) {
 popupElement = document.createElement('div');
 popupElement.id = 'customPopup';
 popupElement.innerHTML = `
 <div class="popup-content">
 <div class="popup-title"></div>
 <div class="popup-message"></div>
 <div class="popup-buttons"></div>
 </div>
 `;
 document.body.appendChild(popupElement);
 }
 
 // Set content
 const titleElement = popupElement.querySelector('.popup-title');
 const messageElement = popupElement.querySelector('.popup-message');
 const buttonsElement = popupElement.querySelector('.popup-buttons');
 
 if (titleElement) titleElement.textContent = title;
 if (messageElement) messageElement.textContent = message;
 
 // Set buttons based on type
 if (buttonsElement) {
 buttonsElement.innerHTML = '';
 
 if (type === 'alert') {
 buttonsElement.innerHTML = `
 <button class="popup-button ok-button">OK</button>
 `;
 
 const okButton = buttonsElement.querySelector('.ok-button');
 if (okButton) {
 okButton.addEventListener('click', () => {
 closePopup();
 });
 }
 } else if (type === 'confirm') {
 buttonsElement.innerHTML = `
 <button class="popup-button cancel-button">Cancel</button>
 <button class="popup-button confirm-button">Confirm</button>
 `;
 
 const cancelButton = buttonsElement.querySelector('.cancel-button');
 const confirmButton = buttonsElement.querySelector('.confirm-button');
 
 if (cancelButton) {
 cancelButton.addEventListener('click', () => {
 closePopup();
 });
 }
 
 if (confirmButton && confirmCallback) {
 confirmButton.addEventListener('click', () => {
 closePopup();
 confirmCallback();
 });
 }
 }
 }
 
 // Show popup with animation
 popupElement.style.display = 'flex';
 popupElement.style.opacity = '0';
 
 setTimeout(() => {
 popupElement.style.opacity = '1';
 popupElement.style.transition = 'opacity 0.3s ease';
 }, 10);
 
 // Function to close popup
 function closePopup() {
 popupElement.style.opacity = '0';
 
 setTimeout(() => {
 popupElement.style.display = 'none';
 }, 300);
 }
 }

// Calculate zoom level based on speed
 function calculateZoomLevel(speed) {
 // Default zoom level
 const defaultZoom = 17;
 
 // If speed is not available, return default
 if (typeof speed !== 'number' || isNaN(speed)) {
 return defaultZoom;
 }
 
 // Calculate zoom level based on speed
 // Higher speed = lower zoom level (zoomed out more)
 if (speed > 20) { // Fast driving
 return 15;
 } else if (speed > 10) { // Slow driving
 return 16;
 } else if (speed > 5) { // Biking
 return 17;
 } else if (speed > 2) { // Running
 return 18;
 } else { // Walking or stationary
 return 19;
 }
 }

// Update map viewport dimensions
 function updateMapViewportDimensions() {
 mapViewportWidth = window.innerWidth;
 mapViewportHeight = window.innerHeight;
 }

// Calculate distance between two points
 function calculateDistance(point1, point2) {
 if (!point1 || !point2 || !point1.lat || !point1.lng || !point2.lat || !point2.lng) {
 return Infinity;
 }
 
 // Convert latitude and longitude from degrees to radians
 const lat1 = point1.lat * Math.PI / 180;
 const lon1 = point1.lng * Math.PI / 180;
 const lat2 = point2.lat * Math.PI / 180;
 const lon2 = point2.lng * Math.PI / 180;
 
 // Haversine formula
 const dlon = lon2 - lon1;
 const dlat = lat2 - lat1;
 const a = Math.sin(dlat / 2) ** 2 + Math.cos(lat1) * Math.cos(lat2) * Math.sin(dlon / 2) ** 2;
 const c = 2 * Math.asin(Math.sqrt(a));
 
 // Radius of earth in meters
 const r = 6371000;
 
 // Calculate distance
 return c * r;
 }

// Update distance box
 function updateDistanceBox() {
 const distanceBox = document.getElementById('distanceBox');
 if (!distanceBox) return;
 
 // Get current location
 const location = gameLocations[currentLocationIndex];
 if (!location || !lastPosition) {
 distanceBox.textContent = 'Distance: --';
 return;
 }
 
 // Calculate distance
 const distance = calculateDistance(
 { lat: lastPosition.lat, lng: lastPosition.lng },
 { lat: location.lat, lng: location.lng }
 );
 
 // Convert to appropriate units
 let distanceText;
 if (distance < 1000) {
 // Show in meters
 const distanceMeters = Math.round(distance);
 distanceText = `${distanceMeters} m`;
 } else {
 // Show in kilometers
 const distanceKm = (distance / 1000).toFixed(1);
 distanceText = `${distanceKm} km`;
 }
 
 // Update distance box
 distanceBox.textContent = `Distance: ${distanceText}`;
 
 // Update distance box color based on proximity
 if (distance < 30) {
 distanceBox.style.backgroundColor = '#4CAF50'; // Green when very close
 distanceBox.style.color = 'white';
 } else if (distance < 100) {
 distanceBox.style.backgroundColor = '#FFC107'; // Yellow when close
 distanceBox.style.color = 'black';
 } else {
 distanceBox.style.backgroundColor = 'var(--bg-color)'; // Default color
 distanceBox.style.color = 'var(--text-color)';
 }
 
 // Check if user is near location
 if (distance < 30 && !isNearLocation) {
 isNearLocation = true;
 
 // Show location hunt
 showLocationHunt(location);
 }
 }

// Create user marker
 function createUserMarker(position) {
 // Remove existing marker
 if (userMarker) {
 map.removeLayer(userMarker);
 }
 
 // Create custom icon
 const userIcon = L.divIcon({
 className: 'user-marker',
 html: `
 <div class="user-marker-icon">
 <div class="user-marker-direction"></div>
 </div>
 `,
 iconSize: [20, 20],
 iconAnchor: [10, 10]
 });
 
 // Create marker
 userMarker = L.marker([position.lat, position.lng], {
 icon: userIcon,
 zIndexOffset: 1000
 }).addTo(map);
 
 // Update last position
 lastPosition = {
 lat: position.lat,
 lng: position.lng
 };
 
 // Save position to localStorage
 try {
 localStorage.setItem('lastKnownLocation', JSON.stringify(lastPosition));
 } catch (e) {
 console.warn('Could not save position to localStorage', e);
 }
 
 // Update distance box
 updateDistanceBox();
 
 // Center map on user if following
 if (followUser) {
 map.setView([position.lat, position.lng], map.getZoom(), {
 animate: true,
 duration: 0.5
 });
 }
 }

// Update user marker
 function updateUserMarker(position, heading) {
 if (!userMarker) {
 createUserMarker(position);
 return;
 }
 
 // Update marker position
 userMarker.setLatLng([position.lat, position.lng]);
 
 // Update marker direction if heading is available
 if (typeof heading === 'number' && !isNaN(heading)) {
 const markerElement = userMarker.getElement();
 if (markerElement) {
 const directionElement = markerElement.querySelector('.user-marker-direction');
 if (directionElement) {
 directionElement.style.transform = `translateX(-50%) rotate(${heading}deg)`;
 }
 }
 }
 
 // Update last position
 lastPosition = {
 lat: position.lat,
 lng: position.lng
 };
 
 // Save position to localStorage periodically
 const now = Date.now();
 if (now - lastSaveTime > 30000) { // Save every 30 seconds
 try {
 localStorage.setItem('lastKnownLocation', JSON.stringify(lastPosition));
 lastSaveTime = now;
 } catch (e) {
 console.warn('Could not save position to localStorage', e);
 }
 }
 
 // Update distance box
 updateDistanceBox();
 
 // Center map on user if following
 if (followUser) {
 map.setView([position.lat, position.lng], map.getZoom(), {
 animate: true,
 duration: 0.5
 });
 }
 }

// Handle position update
 function handlePositionUpdate(position) {
 // Get coordinates
 const lat = position.coords.latitude;
 const lng = position.coords.longitude;
 const accuracy = position.coords.accuracy;
 const heading = position.coords.heading;
 const speed = position.coords.speed;
 
 // Update current speed
 currentSpeed = speed;
 
 // Check if position is valid
 if (isNaN(lat) || isNaN(lng) || lat === 0 || lng === 0) {
 console.warn('Invalid position:', position);
 return;
 }
 
 // Check if position has changed significantly
 const hasChangedSignificantly = !lastValidPosition || 
 calculateDistance(
 { lat, lng },
 { lat: lastValidPosition.lat, lng: lastValidPosition.lng }
 ) > 5; // 5 meters threshold
 
 if (hasChangedSignificantly) {
 // Update last valid position
 lastValidPosition = { lat, lng };
 
 // Update user marker
 updateUserMarker({ lat, lng }, heading);
 
 // Show accuracy circle
 if (accuracyCircle) {
 map.removeLayer(accuracyCircle);
 }
 
 if (accuracy && accuracy > 0) {
 accuracyCircle = L.circle([lat, lng], {
 radius: accuracy,
 color: 'rgba(0, 120, 255, 0.2)',
 fillColor: 'rgba(0, 120, 255, 0.1)',
 fillOpacity: 0.3,
 weight: 1
 }).addTo(map);
 }
 
 // Adjust zoom level based on speed if following user
 if (followUser && speed && speed > 0) {
 const now = Date.now();
 if (now - lastZoomChangeTime > 10000) { // Only change zoom every 10 seconds
 const zoomLevel = calculateZoomLevel(speed);
 if (zoomLevel !== map.getZoom()) {
 map.setZoom(zoomLevel, {
 animate: true,
 duration: 1
 });
 lastZoomChangeTime = now;
 }
 }
 }
 }
 }

// Handle location error
 function handleLocationError(error) {
 console.error('Geolocation error:', error);
 
 let errorMessage;
 switch (error.code) {
 case error.PERMISSION_DENIED:
 errorMessage = 'Location access denied. Please enable location services to use this app.';
 break;
 case error.POSITION_UNAVAILABLE:
 errorMessage = 'Location information is unavailable. Please try again later.';
 break;
 case error.TIMEOUT:
 errorMessage = 'Location request timed out. Please try again.';
 break;
 default:
 errorMessage = 'An unknown error occurred while trying to access your location.';
 }
 
 showErrorMessage(errorMessage);
 
 // Try to use last known position if available
 if (lastValidPosition) {
 updateUserMarker(lastValidPosition);
 }
 }

// Start location tracking
 function startLocationTracking() {
 // Check if geolocation is available
 if (!navigator.geolocation) {
 showErrorMessage('Geolocation is not supported by your browser. Some features may not work properly.');
 return;
 }
 
 // Get current position
 navigator.geolocation.getCurrentPosition(
 (position) => {
 // Handle initial position
 handlePositionUpdate(position);
 
 // Center map on initial position
 if (position.coords && position.coords.latitude && position.coords.longitude) {
 map.setView([position.coords.latitude, position.coords.longitude], 17);
 }
 
 // Start watching position
 watchPositionId = navigator.geolocation.watchPosition(
 handlePositionUpdate,
 handleLocationError,
 {
 enableHighAccuracy: true,
 maximumAge: 0,
 timeout: 10000
 }
 );
 
 isWatchPositionActive = true;
 },
 handleLocationError,
 {
 enableHighAccuracy: true,
 maximumAge: 0,
 timeout: 10000
 }
 );
 
 // Handle app going to background
 document.addEventListener('visibilitychange', () => {
 if (document.hidden) {
 // App going to background
 lastHiddenTime = Date.now();
 } else {
 // App coming to foreground
 const hiddenDuration = Date.now() - lastHiddenTime;
 
 // If app was in background for more than 5 minutes, restart location tracking
 if (hiddenDuration > 300000) {
 if (watchPositionId) {
 navigator.geolocation.clearWatch(watchPositionId);
 }
 
 // Restart watching position
 watchPositionId = navigator.geolocation.watchPosition(
 handlePositionUpdate,
 handleLocationError,
 {
 enableHighAccuracy: true,
 maximumAge: 0,
 timeout: 10000
 }
 );
 }
 }
 });
 }

// Initialize map
 function initMap() {
 // Create map
 map = L.map('map', {
 zoomControl: false,
 attributionControl: false
 }).setView([44.9778, -93.2650], 13); // Default center on Minneapolis
 
 // Add tile layer
 L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
 maxZoom: 19,
 attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
 }).addTo(map);
 
 // Add attribution control in a better position
 L.control.attribution({
 position: 'bottomright'
 }).addAttribution('© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors').addTo(map);
 
 // Add zoom control in a better position
 L.control.zoom({
 position: 'topright'
 }).addTo(map);
 
 // Add scale control
 L.control.scale({
 imperial: true,
 metric: true,
 position: 'bottomleft'
 }).addTo(map);
 
 // Add event listeners
 map.on('click', () => {
 // Close any open popups when clicking on the map
 map.closePopup();
 });
 
 map.on('dragstart', () => {
 // Disable follow user when user drags the map
 followUser = false;
 
 // Update recenter button style
 const recenterButton = document.getElementById("recenterButton");
 if (recenterButton) {
 recenterButton.style.backgroundColor = "var(--bg-color)";
 recenterButton.style.color = "var(--primary-color)";
 }
 });
 
 // Get map viewport dimensions
 updateMapViewportDimensions();
 
 // Add resize event listener
 window.addEventListener('resize', () => {
 map.invalidateSize();
 updateMapViewportDimensions();
 });
 }

// Add CSS for custom popup
 const popupStyles = document.createElement('style');
 popupStyles.textContent = `
 #customPopup {
 position: fixed;
 top: 0;
 left: 0;
 width: 100%;
 height: 100%;
 background-color: rgba(0, 0, 0, 0.7);
 display: none;
 align-items: center;
 justify-content: center;
 z-index: 2000;
 }
 
 .popup-content {
 background-color: white;
 border-radius: 16px;
 padding: 24px;
 width: 90%;
 max-width: 400px;
 text-align: center;
 }
 
 .popup-title {
 font-size: 20px;
 font-weight: 600;
 margin-bottom: 16px;
 color: #333;
 }
 
 .popup-message {
 font-size: 16px;
 color: #666;
 margin-bottom: 24px;
 }
 
 .popup-buttons {
 display: flex;
 justify-content: center;
 gap: 16px;
 }
 
 .popup-button {
 padding: 10px 20px;
 border: none;
 border-radius: 8px;
 font-size: 16px;
 font-weight: 500;
 cursor: pointer;
 transition: all 0.2s ease;
 }
 
 .popup-button:hover {
 opacity: 0.9;
 }
 
 .ok-button, .confirm-button {
 background-color: #0f2bab;
 color: white;
 }
 
 .cancel-button {
 background-color: #f2f2f2;
 color: #333;
 }
 
 /* Support for iOS devices with notches */
 @supports (padding-bottom: env(safe-area-inset-bottom)) {
 .popup-content {
 margin-bottom: env(safe-area-inset-bottom, 0px);
 }
 }
 `;

document.head.appendChild(popupStyles);

// Make functions available globally (continuing from where we left off)
 window.recenterMap = recenterMap;
 window.toggleNavigationTips = toggleNavigationTips;
 window.closeNavigationTips = closeNavigationTips;
 window.returnToIndex = returnToIndex;
 window.showLocationHunt = showLocationHunt;
 window.showDirectionsModal = showDirectionsModal;
 window.closeDirectionsModal = closeDirectionsModal;
 window.skipToNextLocation = skipToNextLocation;

// Add service worker registration for offline support
 if ('serviceWorker' in navigator) {
 window.addEventListener('load', () => {
 navigator.serviceWorker.register('/service-worker.js')
 .then(registration => {
 console.log('ServiceWorker registration successful with scope: ', registration.scope);
 })
 .catch(error => {
 console.log('ServiceWorker registration failed: ', error);
 });
 });
 }

// Add performance optimizations
 function optimizePerformance() {
 // Debounce function to limit how often a function can be called
 function debounce(func, wait) {
 let timeout;
 return function() {
 const context = this;
 const args = arguments;
 clearTimeout(timeout);
 timeout = setTimeout(() => {
 func.apply(context, args);
 }, wait);
 };
 }
 
 // Throttle function to limit how often a function can be called
 function throttle(func, limit) {
 let inThrottle;
 return function() {
 const context = this;
 const args = arguments;
 if (!inThrottle) {
 func.apply(context, args);
 inThrottle = true;
 setTimeout(() => inThrottle = false, limit);
 }
 };
 }
 
 // Throttle map updates for better performance
 const originalUpdateUserMarker = updateUserMarker;
 window.updateUserMarker = throttle(originalUpdateUserMarker, 100);
 
 // Debounce distance box updates
 const originalUpdateDistanceBox = updateDistanceBox;
 window.updateDistanceBox = debounce(originalUpdateDistanceBox, 500);
 
 // Use requestAnimationFrame for smooth animations
 function animateMarker(marker, startPos, endPos, duration) {
 const startTime = Date.now();
 
 function step() {
 const elapsed = Date.now() - startTime;
 const progress = Math.min(elapsed / duration, 1);
 
 // Calculate intermediate position
 const lat = startPos.lat + (endPos.lat - startPos.lat) * progress;
 const lng = startPos.lng + (endPos.lng - startPos.lng) * progress;
 
 // Update marker position
 marker.setLatLng([lat, lng]);
 
 // Continue animation if not complete
 if (progress < 1) {
 requestAnimationFrame(step);
 }
 }
 
 requestAnimationFrame(step);
 }
 
 // Replace the original updateUserMarker with the animated version
 const originalUpdateUserMarkerThrottled = window.updateUserMarker;
 window.updateUserMarker = function(position, heading) {
 if (!userMarker) {
 createUserMarker(position);
 return;
 }
 
 // Get current position
 const currentPos = userMarker.getLatLng();
 
 // Animate marker movement
 animateMarker(userMarker, 
 { lat: currentPos.lat, lng: currentPos.lng }, 
 { lat: position.lat, lng: position.lng }, 
 300);
 
 // Update marker direction if heading is available
 if (typeof heading === 'number' && !isNaN(heading)) {
 const markerElement = userMarker.getElement();
 if (markerElement) {
 const directionElement = markerElement.querySelector('.user-marker-direction');
 if (directionElement) {
 directionElement.style.transform = `translateX(-50%) rotate(${heading}deg)`;
 }
 }
 }
 
 // Update last position
 lastPosition = {
 lat: position.lat,
 lng: position.lng
 };
 
 // Save position to localStorage periodically
 const now = Date.now();
 if (now - lastSaveTime > 30000) { // Save every 30 seconds
 try {
 localStorage.setItem('lastKnownLocation', JSON.stringify(lastPosition));
 lastSaveTime = now;
 } catch (e) {
 console.warn('Could not save position to localStorage', e);
 }
 }
 
 // Update distance box
 updateDistanceBox();
 
 // Center map on user if following
 if (followUser) {
 map.setView([position.lat, position.lng], map.getZoom(), {
 animate: true,
 duration: 0.5
 });
 }
 };
 }

// Call performance optimizations
 optimizePerformance();

// Add analytics tracking (privacy-friendly)
 function initAnalytics() {
 // Simple analytics tracking without personal data
 let sessionId = '';
 let sessionStartTime = Date.now();
 let pageViews = 0;
 let interactions = 0;
 
 // Generate anonymous session ID
 function generateSessionId() {
 return Math.random().toString(36).substring(2, 15) + 
 Math.random().toString(36).substring(2, 15);
 }
 
 // Try to get existing session ID from localStorage
 try {
 sessionId = localStorage.getItem('anonymousSessionId');
 if (!sessionId) {
 sessionId = generateSessionId();
 localStorage.setItem('anonymousSessionId', sessionId);
 }
 } catch (e) {
 sessionId = generateSessionId();
 }
 
 // Track page view
 function trackPageView() {
 pageViews++;
 
 // Log page view (would normally send to server)
 console.log('Page view tracked', {
 sessionId,
 timestamp: Date.now(),
 pageViews
 });
 }
 
 // Track interaction
 function trackInteraction(interactionType) {
 interactions++;
 
 // Log interaction (would normally send to server)
 console.log('Interaction tracked', {
 sessionId,
 timestamp: Date.now(),
 interactionType,
 interactions
 });
 }
 
 // Track initial page view
 trackPageView();
 
 // Track interactions
 document.addEventListener('click', (e) => {
 // Find closest interactive element
 const button = e.target.closest('button');
 const link = e.target.closest('a');
 const interactiveElement = button || link;
 
 if (interactiveElement) {
 const interactionType = interactiveElement.id || 
 interactiveElement.className || 
 interactiveElement.tagName;
 
 trackInteraction(interactionType);
 }
 });
 
 // Track session duration on page unload
 window.addEventListener('beforeunload', () => {
 const sessionDuration = (Date.now() - sessionStartTime) / 1000; // in seconds
 
 // Log session end (would normally send to server)
 console.log('Session ended', {
 sessionId,
 duration: sessionDuration,
 pageViews,
 interactions
 });
 });
 
 // Make tracking functions available globally
 window.trackPageView = trackPageView;
 window.trackInteraction = trackInteraction;
 }

// Initialize analytics
 initAnalytics();

// Add device orientation support for immersive experience
 function initDeviceOrientation() {
 // Check if DeviceOrientationEvent is supported
 if (window.DeviceOrientationEvent) {
 // Add device orientation event listener
 window.addEventListener('deviceorientation', (event) => {
 // Get orientation data
 const alpha = event.alpha; // compass direction (0-360)
 const beta = event.beta; // front-to-back tilt (-180 to 180)
 const gamma = event.gamma; // left-to-right tilt (-90 to 90)
 
 // Use orientation data to enhance user experience
 if (typeof alpha === 'number' && !isNaN(alpha) && userMarker) {
 // Update user marker direction based on compass heading
 const heading = 360 - alpha; // Convert to clockwise degrees
 
 const markerElement = userMarker.getElement();
 if (markerElement) {
 const directionElement = markerElement.querySelector('.user-marker-direction');
 if (directionElement) {
 directionElement.style.transform = `translateX(-50%) rotate(${heading}deg)`;
 }
 }
 }
 });
 }
 }

// Initialize device orientation
 initDeviceOrientation();

// Add support for screen wake lock to keep screen on during tour
 function initWakeLock() {
 let wakeLock = null;
 
 // Function to request wake lock
 async function requestWakeLock() {
 if ('wakeLock' in navigator) {
 try {
 wakeLock = await navigator.wakeLock.request('screen');
 
 // Add release event listener
 wakeLock.addEventListener('release', () => {
 console.log('Wake Lock released');
 });
 
 console.log('Wake Lock acquired');
 } catch (error) {
 console.error('Failed to acquire Wake Lock', error);
 }
 }
 }
 
 // Function to release wake lock
 function releaseWakeLock() {
 if (wakeLock) {
 wakeLock.release()
 .then(() => {
 wakeLock = null;
 });
 }
 }
 
 // Request wake lock when page is visible
 document.addEventListener('visibilitychange', () => {
 if (document.visibilityState === 'visible') {
 requestWakeLock();
 } else {
 releaseWakeLock();
 }
 });
 
 // Initial request
 if (document.visibilityState === 'visible') {
 requestWakeLock();
 }
 }

// Initialize wake lock
 initWakeLock();

// Add support for sharing tour progress
 function initSharing() {
 // Create share button if Web Share API is supported
 if (navigator.share) {
 const shareButton = document.createElement('button');
 shareButton.id = 'shareButton';
 shareButton.className = 'share-button';
 shareButton.innerHTML = '<i class="fas fa-share-alt"></i>';
 shareButton.setAttribute('aria-label', 'Share your progress');
 shareButton.setAttribute('title', 'Share your progress');
 
 shareButton.addEventListener('click', async () => {
 // Get current location
 const location = gameLocations[currentLocationIndex];
 if (!location) return;
 
 // Create share data
 const shareData = {
 title: 'Minnesota Then Museum Without Walls',
 text: `I'm exploring ${location.name} on the Minnesota Then Museum Without Walls tour! Join me!`,
 url: window.location.href
 };
 
 try {
 await navigator.share(shareData);
 console.log('Shared successfully');
 } catch (error) {
 console.error('Error sharing:', error);
 }
 });
 
 document.body.appendChild(shareButton);
 }
 }

// Initialize sharing
 initSharing();

// Add support for saving tour progress
 function initProgressSaving() {
 // Save progress periodically
 function saveProgress() {
 try {
 // Save current location index
 localStorage.setItem('currentLocationIndex', currentLocationIndex.toString());
 
 // Save visited locations
 localStorage.setItem('visitedLocations', JSON.stringify(visitedLocations));
 
 // Save last known location
 if (lastPosition) {
 localStorage.setItem('lastKnownLocation', JSON.stringify(lastPosition));
 }
 
 console.log('Progress saved');
 } catch (e) {
 console.warn('Could not save progress', e);
 }
 }
 
 // Load progress on startup
 function loadProgress() {
 try {
 // Load current location index
 const savedLocationIndex = localStorage.getItem('currentLocationIndex');
 if (savedLocationIndex) {
 currentLocationIndex = parseInt(savedLocationIndex, 10);
 }
 
 // Load visited locations
 const savedVisitedLocations = localStorage.getItem('visitedLocations');
 if (savedVisitedLocations) {
 const parsed = JSON.parse(savedVisitedLocations);
 if (Array.isArray(parsed)) {
 visitedLocations = parsed;
 }
 }
 
 console.log('Progress loaded');
 } catch (e) {
 console.warn('Could not load progress', e);
 }
 }
 
 // Save progress every minute
 setInterval(saveProgress, 60000);
 
 // Save progress when page is hidden
 document.addEventListener('visibilitychange', () => {
 if (document.hidden) {
 saveProgress();
 }
 });
 
 // Save progress before unload
 window.addEventListener('beforeunload', saveProgress);
 
 // Load progress on startup
 loadProgress();
 }

// Initialize progress saving
 initProgressSaving();

// Add support for audio preloading and management
 function initAudioManager() {
 // Audio cache
 const audioCache = new Map();
 
 // Preload audio
 function preloadAudio(url) {
 if (!url || audioCache.has(url)) return Promise.resolve();
 
 return new Promise((resolve, reject) => {
 const audio = new Audio();
 
 audio.addEventListener('canplaythrough', () => {
 audioCache.set(url, audio);
 resolve(audio);
 }, { once: true });
 
 audio.addEventListener('error', (error) => {
 reject(error);
 }, { once: true });
 
 audio.preload = 'auto';
 audio.src = url;
 audio.load();
 });
 }
 
 // Get audio from cache or load it
 function getAudio(url) {
 if (!url) return null;
 
 if (audioCache.has(url)) {
 return audioCache.get(url);
 }
 
 // Start loading if not in cache
 preloadAudio(url).catch(error => {
 console.error('Error preloading audio:', error);
 });
 
 return null;
 }
 
 // Preload audio for current and next locations
 function preloadLocationAudio() {
 // Preload current location audio
 const currentLocation = gameLocations[currentLocationIndex];
 if (currentLocation && currentLocation.audio) {
 preloadAudio(currentLocation.audio).catch(error => {
 console.error('Error preloading current location audio:', error);
 });
 }
 
 // Preload next location audio
 const nextLocation = gameLocations[currentLocationIndex + 1];
 if (nextLocation && nextLocation.audio) {
 preloadAudio(nextLocation.audio).catch(error => {
 console.error('Error preloading next location audio:', error);
 });
 }
 }
 
 // Make functions available globally
 window.preloadAudio = preloadAudio;
 window.getAudio = getAudio;
 window.preloadLocationAudio = preloadLocationAudio;
 
 // Preload audio for current location
 preloadLocationAudio();
 }

// Initialize audio manager
 initAudioManager();

// Add support for offline mode
 function initOfflineMode() {
 // Check if app is online
 function isOnline() {
 return navigator.onLine;
 }
 
 // Handle offline mode
 function handleOfflineMode() {
 const offlineMessage = document.createElement('div');
 offlineMessage.className = 'offline-message';
 offlineMessage.textContent = 'You are currently offline. Some features may be limited.';
 
 if (!isOnline()) {
 // Show offline message
 document.body.appendChild(offlineMessage);
 
 // Disable features that require network
 disableOnlineFeatures();
 }
 
 // Add event listeners for online/offline events
 window.addEventListener('online', () => {
 // Remove offline message
 if (document.body.contains(offlineMessage)) {
 document.body.removeChild(offlineMessage);
 }
 
 // Enable online features
 enableOnlineFeatures();
 
 // Refresh map tiles
 if (map) {
 map.eachLayer(layer => {
 if (layer.redraw) {
 layer.redraw();
 }
 });
 }
 });
 
 window.addEventListener('offline', () => {
 // Show offline message
 document.body.appendChild(offlineMessage);
 
 // Disable features that require network
 disableOnlineFeatures();
 });
 }
 
 // Disable features that require network
 function disableOnlineFeatures() {
 // Disable directions buttons
 const directionBtns = document.querySelectorAll('.direction-btn');
 directionBtns.forEach(btn => {
 btn.classList.add('disabled');
 btn.setAttribute('disabled', 'disabled');
 });
 
 // Disable share button
 const shareButton = document.getElementById('shareButton');
 if (shareButton) {
 shareButton.classList.add('disabled');
 shareButton.setAttribute('disabled', 'disabled');
 }
 }
 
 // Enable online features
 function enableOnlineFeatures() {
 // Enable directions buttons
 const directionBtns = document.querySelectorAll('.direction-btn');
 directionBtns.forEach(btn => {
 btn.classList.remove('disabled');
 btn.removeAttribute('disabled');
 });
 
 // Enable share button
 const shareButton = document.getElementById('shareButton');
 if (shareButton) {
 shareButton.classList.remove('disabled');
 shareButton.removeAttribute('disabled');
 }
 }
 
 // Add offline mode styles
 const offlineStyles = document.createElement('style');
 offlineStyles.textContent = `
 .offline-message {
 position: fixed;
 top: 0;
 left: 0;
 width: 100%;
 background-color: #ff9800;
 color: white;
 text-align: center;
 padding: 10px;
 z-index: 2000;
 font-weight: 500;
 }
 
 .disabled {
 opacity: 0.5;
 pointer-events: none;
 }
 
 /* Support for iOS devices with notches */
 @supports (padding-top: env(safe-area-inset-top)) {
 .offline-message {
 padding-top: calc(10px + env(safe-area-inset-top, 0px));
 }
 }
 `;
 
 document.head.appendChild(offlineStyles);
 
 // Initialize offline mode
 handleOfflineMode();
 }

// Initialize offline mode
 initOfflineMode();

// Final initialization
 document.addEventListener('DOMContentLoaded', () => {
 console.log('Minnesota Then Museum Without Walls Tour initialized');
 
 

// Show welcome message for first-time users (continuing from where we left off)
 const isFirstVisit = !localStorage.getItem('hasVisitedBefore');
 if (isFirstVisit) {
 showPopup(
 'Welcome to Minnesota Then!',
 'Explore historical locations around Minnesota with this self-guided tour. Use the map to navigate to each location and learn about Minnesota\'s rich history.',
 'alert'
 );
 
 // Mark as visited
 localStorage.setItem('hasVisitedBefore', 'true');
 }

// Add support for tour completion achievements
 function initAchievements() {
 // Achievement definitions
 const achievements = [
 {
 id: 'first_location',
 title: 'First Steps',
 description: 'Visit your first location',
 check: () => visitedLocations.length >= 1
 },
 {
 id: 'half_complete',
 title: 'Halfway There',
 description: 'Visit half of all locations',
 check: () => visitedLocations.length >= Math.ceil(gameLocations.length / 2)
 },
 {
 id: 'tour_complete',
 title: 'Tour Completed',
 description: 'Visit all locations in the tour',
 check: () => visitedLocations.length >= gameLocations.length
 },
 {
 id: 'speed_explorer',
 title: 'Speed Explorer',
 description: 'Complete the tour in under 2 hours',
 check: () => {
 const startTime = localStorage.getItem('tourStartTime');
 const completionTime = localStorage.getItem('tourCompletionTime');
 
 if (startTime && completionTime) {
 const duration = (new Date(completionTime) - new Date(startTime)) / (1000 * 60 * 60); // in hours
 return duration < 2;
 }
 
 return false;
 }
 }
 ];
 
 // Get earned achievements
 function getEarnedAchievements() {
 try {
 const saved = localStorage.getItem('earnedAchievements');
 return saved ? JSON.parse(saved) : [];
 } catch (e) {
 console.warn('Could not load earned achievements', e);
 return [];
 }
 }
 
 // Save earned achievements
 function saveEarnedAchievements(earnedIds) {
 try {
 localStorage.setItem('earnedAchievements', JSON.stringify(earnedIds));
 } catch (e) {
 console.warn('Could not save earned achievements', e);
 }
 }
 
 // Check for new achievements
 function checkAchievements() {
 const earnedIds = getEarnedAchievements();
 let newAchievements = [];
 
 achievements.forEach(achievement => {
 if (!earnedIds.includes(achievement.id) && achievement.check()) {
 // New achievement earned
 earnedIds.push(achievement.id);
 newAchievements.push(achievement);
 }
 });
 
 // Save updated achievements
 if (newAchievements.length > 0) {
 saveEarnedAchievements(earnedIds);
 
 // Show achievement notification
 newAchievements.forEach(achievement => {
 showAchievementNotification(achievement);
 });
 }
 
 return newAchievements;
 }
 
 // Show achievement notification
 function showAchievementNotification(achievement) {
 // Create notification element
 const notification = document.createElement('div');
 notification.className = 'achievement-notification';
 notification.innerHTML = `
 <div class="achievement-icon">🏆</div>
 <div class="achievement-content">
 <div class="achievement-title">${achievement.title}</div>
 <div class="achievement-description">${achievement.description}</div>
 </div>
 `;
 
 document.body.appendChild(notification);
 
 // Animate notification
 setTimeout(() => {
 notification.classList.add('show');
 
 // Remove notification after delay
 setTimeout(() => {
 notification.classList.remove('show');
 
 setTimeout(() => {
 if (document.body.contains(notification)) {
 document.body.removeChild(notification);
 }
 }, 500);
 }, 5000);
 }, 100);
 }
 
 // Add achievement styles
 const achievementStyles = document.createElement('style');
 achievementStyles.textContent = `
 .achievement-notification {
 position: fixed;
 top: 20px;
 right: 20px;
 background-color: #4CAF50;
 color: white;
 padding: 16px;
 border-radius: 8px;
 box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
 display: flex;
 align-items: center;
 z-index: 2000;
 transform: translateX(120%);
 transition: transform 0.5s ease;
 max-width: 300px;
 }
 
 .achievement-notification.show {
 transform: translateX(0);
 }
 
 .achievement-icon {
 font-size: 24px;
 margin-right: 12px;
 }
 
 .achievement-title {
 font-weight: 600;
 margin-bottom: 4px;
 }
 
 .achievement-description {
 font-size: 14px;
 opacity: 0.9;
 }
 
 /* Support for iOS devices with notches */
 @supports (padding-top: env(safe-area-inset-top)) {
 .achievement-notification {
 top: calc(20px + env(safe-area-inset-top, 0px));
 right: calc(20px + env(safe-area-inset-right, 0px));
 }
 }
 `;
 
 document.head.appendChild(achievementStyles);
 
 // Check achievements periodically
 setInterval(checkAchievements, 60000); // Check every minute
 
 // Check achievements when location is visited
 const originalShowLocationHunt = window.showLocationHunt;
 window.showLocationHunt = function(location) {
 originalShowLocationHunt(location);
 
 // Check for achievements after location is visited
 setTimeout(checkAchievements, 1000);
 };
 
 // Save tour start time if not already saved
 if (!localStorage.getItem('tourStartTime')) {
 localStorage.setItem('tourStartTime', new Date().toISOString());
 }
 
 // Make achievement functions available globally
 window.checkAchievements = checkAchievements;
 window.getEarnedAchievements = getEarnedAchievements;
 
 // Initial achievement check
 setTimeout(checkAchievements, 5000);
 }

// Initialize achievements
 initAchievements();

// Add support for accessibility features
 function initAccessibilityFeatures() {
 // Create accessibility menu
 const accessibilityButton = document.createElement('button');
 accessibilityButton.id = 'accessibilityButton';
 accessibilityButton.className = 'accessibility-button';
 accessibilityButton.innerHTML = '<i class="fas fa-universal-access"></i>';
 accessibilityButton.setAttribute('aria-label', 'Accessibility options');
 accessibilityButton.setAttribute('title', 'Accessibility options');
 
 // Create accessibility menu
 const accessibilityMenu = document.createElement('div');
 accessibilityMenu.id = 'accessibilityMenu';
 accessibilityMenu.className = 'accessibility-menu';
 accessibilityMenu.innerHTML = `
 <div class="accessibility-menu-header">
 <h3>Accessibility Options</h3>
 <button id="closeAccessibilityMenu" aria-label="Close menu">
 <i class="fas fa-times"></i>
 </button>
 </div>
 <div class="accessibility-menu-content">
 <div class="accessibility-option">
 <label for="highContrastToggle">High Contrast</label>
 <input type="checkbox" id="highContrastToggle">
 </div>
 <div class="accessibility-option">
 <label for="largeTextToggle">Larger Text</label>
 <input type="checkbox" id="largeTextToggle">
 </div>
 <div class="accessibility-option">
 <label for="reduceMotionToggle">Reduce Motion</label>
 <input type="checkbox" id="reduceMotionToggle">
 </div>
 <div class="accessibility-option">
 <label for="screenReaderToggle">Screen Reader Hints</label>
 <input type="checkbox" id="screenReaderToggle">
 </div>
 </div>
 `;
 
 // Add elements to body
 document.body.appendChild(accessibilityButton);
 document.body.appendChild(accessibilityMenu);
 
 // Add event listeners
 accessibilityButton.addEventListener('click', () => {
 accessibilityMenu.classList.toggle('show');
 });
 
 const closeButton = document.getElementById('closeAccessibilityMenu');
 if (closeButton) {
 closeButton.addEventListener('click', () => {
 accessibilityMenu.classList.remove('show');
 });
 }
 
 // High contrast toggle
 const highContrastToggle = document.getElementById('highContrastToggle');
 if (highContrastToggle) {
 // Set initial state
 highContrastToggle.checked = document.body.classList.contains('high-contrast');
 
 // Add event listener
 highContrastToggle.addEventListener('change', () => {
 document.body.classList.toggle('high-contrast', highContrastToggle.checked);
 localStorage.setItem('highContrast', highContrastToggle.checked ? 'true' : 'false');
 });
 }
 
 // Larger text toggle
 const largeTextToggle = document.getElementById('largeTextToggle');
 if (largeTextToggle) {
 // Set initial state
 largeTextToggle.checked = document.body.classList.contains('large-text');
 
 // Add event listener
 largeTextToggle.addEventListener('change', () => {
 document.body.classList.toggle('large-text', largeTextToggle.checked);
 localStorage.setItem('largeText', largeTextToggle.checked ? 'true' : 'false');
 });
 }
 
 // Reduce motion toggle
 const reduceMotionToggle = document.getElementById('reduceMotionToggle');
 if (reduceMotionToggle) {
 // Set initial state
 reduceMotionToggle.checked = document.body.classList.contains('reduce-motion');
 
 // Add event listener
 reduceMotionToggle.addEventListener('change', () => {
 document.body.classList.toggle('reduce-motion', reduceMotionToggle.checked);
 localStorage.setItem('reduceMotion', reduceMotionToggle.checked ? 'true' : 'false');
 });
 }
 
 // Screen reader hints toggle
 const screenReaderToggle = document.getElementById('screenReaderToggle');
 if (screenReaderToggle) {
 // Set initial state
 screenReaderToggle.checked = document.body.classList.contains('screen-reader-hints');
 
 // Add event listener
 screenReaderToggle.addEventListener('change', () => {
 document.body.classList.toggle('screen-reader-hints', screenReaderToggle.checked);
 localStorage.setItem('screenReaderHints', screenReaderToggle.checked ? 'true' : 'false');
 });
 }
 
 // Load saved preferences
 function loadAccessibilityPreferences() {
 if (localStorage.getItem('highContrast') === 'true') {
 document.body.classList.add('high-contrast');
 if (highContrastToggle) highContrastToggle.checked = true;
 }
 
 if (localStorage.getItem('largeText') === 'true') {
 document.body.classList.add('large-text');
 if (largeTextToggle) largeTextToggle.checked = true;
 }
 
 if (localStorage.getItem('reduceMotion') === 'true') {
 document.body.classList.add('reduce-motion');
 if (reduceMotionToggle) reduceMotionToggle.checked = true;
 }
 
 if (localStorage.getItem('screenReaderHints') === 'true') {
 document.body.classList.add('screen-reader-hints');
 if (screenReaderToggle) screenReaderToggle.checked = true;
 }
 }
 
 // Add accessibility styles
 const accessibilityStyles = document.createElement('style');
 accessibilityStyles.textContent = `
 .accessibility-button {
 position: fixed;
 top: 20px;
 right: 20px;
 width: 40px;
 height: 40px;
 border-radius: 50%;
 background-color: rgba(255, 255, 255, 0.9);
 color: #333;
 border: none;
 box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
 display: flex;
 align-items: center;
 justify-content: center;
 cursor: pointer;
 z-index: 1000;
 }
 
 .accessibility-menu {
 position: fixed;
 top: 70px;
 right: 20px;
 background-color: white;
 border-radius: 8px;
 box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
 width: 280px;
 z-index: 1000;
 display: none;
 overflow: hidden;
 transition: transform 0.3s ease, opacity 0.3s ease;
 transform: translateY(-10px);
 opacity: 0;
 }
 
 .accessibility-menu.show {
 display: block;
 transform: translateY(0);
 opacity: 1;
 }
 
 .accessibility-menu-header {
 display: flex;
 justify-content: space-between;
 align-items: center;
 padding: 12px 16px;
 border-bottom: 1px solid #eee;
 }
 
 .accessibility-menu-header h3 {
 margin: 0;
 font-size: 16px;
 color: #333;
 }
 
 .accessibility-menu-header button {
 background: none;
 border: none;
 color: #666;
 cursor: pointer;
 font-size: 16px;
 }
 
 .accessibility-menu-content {
 padding: 16px;
 }
 
 .accessibility-option {
 display: flex;
 justify-content: space-between;
 align-items: center;
 margin-bottom: 12px;
 }
 
 .accessibility-option label {
 font-size: 14px;
 color: #333;
 }
 
 /* High contrast mode */
 body.high-contrast {
 filter: contrast(1.4);
 }
 
 /* Large text mode */
 body.large-text {
 font-size: 120%;
 }
 
 body.large-text .map-button {
 font-size: 120%;
 }
 
 /* Reduce motion */
 body.reduce-motion * {
 animation-duration: 0.001s !important;
 transition-duration: 0.001s !important;
 }
 
 /* Screen reader hints */
 body.screen-reader-hints .sr-hint {
 display: block !important;
 position: absolute;
 width: 1px;
 height: 1px;
 padding: 0;
 margin: -1px;
 overflow: hidden;
 clip: rect(0, 0, 0, 0);
 white-space: nowrap;
 border: 0;
 }
 
 /* Support for iOS devices with notches */
 @supports (padding-top: env(safe-area-inset-top)) {
 .accessibility-button {
 top: calc(20px + env(safe-area-inset-top, 0px));
 right: calc(20px + env(safe-area-inset-right, 0px));
 }
 
 .accessibility-menu {
 top: calc(70px + env(safe-area-inset-top, 0px));
 right: calc(20px + env(safe-area-inset-right, 0px));
 }
 }
 `;
 
 document.head.appendChild(accessibilityStyles);
 
 // Load saved preferences
 loadAccessibilityPreferences();
 }

// Initialize accessibility features
 initAccessibilityFeatures();

// Final performance optimizations
 function finalOptimizations() {
 // Use passive event listeners for better scrolling performance
 document.addEventListener('touchstart', () => {}, { passive: true });
 document.addEventListener('touchmove', () => {}, { passive: true });
 document.addEventListener('wheel', () => {}, { passive: true });
 
 // Optimize images by using IntersectionObserver for lazy loading
 if ('IntersectionObserver' in window) {
 const imageObserver = new IntersectionObserver((entries, observer) => {
 entries.forEach(entry => {
 if (entry.isIntersecting) {
 const img = entry.target;
 const src = img.getAttribute('data-src');
 
 if (src) {
 img.src = src;
 img.removeAttribute('data-src');
 observer.unobserve(img);
 }
 }
 });
 });
 
 // Observe all images with data-src attribute
 document.querySelectorAll('img[data-src]').forEach(img => {
 imageObserver.observe(img);
 });
 }
 
 // Optimize map rendering
 if (map) {
 // Disable map animations when battery is low
 if ('getBattery' in navigator) {
 navigator.getBattery().then(battery => {
 if (battery.level < 0.2 && !battery.charging) {
 map.options.zoomAnimation = false;
 map.options.markerZoomAnimation = false;
 map.options.fadeAnimation = false;
 }
 });
 }
 
 // Reduce tile loading when not visible
 document.addEventListener('visibilitychange', () => {
 if (document.hidden) {
 // Pause tile loading when app is in background
 map.options.updateWhenIdle = true;
 map.options.updateWhenZooming = false;
 } else {
 // Resume normal tile loading
 map.options.updateWhenIdle = false;
 map.options.updateWhenZooming = true;
 }
 });
 }
 }

// Apply final optimizations
 finalOptimizations();

// Add support for user feedback
 function initFeedback() {
 // Create feedback button
 const feedbackButton = document.createElement('button');
 feedbackButton.id = 'feedbackButton';
 feedbackButton.className = 'feedback-button';
 feedbackButton.innerHTML = '<i class="fas fa-comment-alt"></i>';
 feedbackButton.setAttribute('aria-label', 'Provide feedback');
 feedbackButton.setAttribute('title', 'Provide feedback');
 
 // Add feedback button to body
 document.body.appendChild(feedbackButton);
 
 // Add event listener
 feedbackButton.addEventListener('click', () => {
 // Show feedback form
 showFeedbackForm();
 });
 
 // Show feedback form
 function showFeedbackForm() {
 // Create feedback form
 let feedbackForm = document.getElementById('feedbackForm');
 
 if (!feedbackForm) {
 feedbackForm = document.createElement('div');
 feedbackForm.id = 'feedbackForm';
 feedbackForm.className = 'feedback-form';
 feedbackForm.innerHTML = `
 <div class="feedback-form-content">
 <div class="feedback-form-header">
 <h3>Provide Feedback</h3>
 <button id="closeFeedbackForm" aria-label="Close form">
 <i class="fas fa-times"></i>
 </button>
 </div>
 <div class="feedback-form-body">
 <div class="feedback-field">
 <label for="feedbackType">Feedback Type</label>
 <select id="feedbackType">
 <option value="general">General Feedback</option>
 <option value="bug">Report a Bug</option>
 <option value="feature">Feature Request</option>
 <option value="content">Content Correction</option>
 </select>
 </div>
 <div class="feedback-field">
 <label for="feedbackMessage">Your Feedback</label>
 <textarea id="feedbackMessage" placeholder="Please describe your feedback in detail..."></textarea>
 </div>
 <div class="feedback-field">
 <label for="feedbackEmail">Email (optional)</label>
 <input type="email" id="feedbackEmail" placeholder="Your email for follow-up">
 </div>
 <button id="submitFeedback" class="submit-feedback">Submit Feedback</button>
 </div>
 </div>
 `;
 
 document.body.appendChild(feedbackForm);
 
 // Add event listeners
 const closeButton = document.getElementById('closeFeedbackForm');
 if (closeButton) {
 closeButton.addEventListener('click', () => {
 feedbackForm.classList.remove('show');
 });
 }
 
 const submitButton = document.getElementById('submitFeedback');
 if (submitButton) {
 submitButton.addEventListener('click', () => {
 // Get form values
 const type = document.getElementById('feedbackType').value;
 const message = document.getElementById('feedbackMessage').value;
 const email = document.getElementById('feedbackEmail').value;
 
 // Validate message
 if (!message || message.trim().length < 10) {
 showErrorMessage('Please provide more detailed feedback.');
 return;
 }
 
 // Collect feedback data
 const feedbackData = {
 type,
 message,
 email: email || 'anonymous',
 timestamp: new Date().toISOString(),
 userAgent: navigator.userAgent,
 currentLocation: currentLocationIndex,
 visitedLocations: visitedLocations.length
 };
 
 // In a real app, this would send data to a server
 console.log('Feedback submitted:', feedbackData);
 
 // Show success message
 showPopup('Thank You!', 'Your feedback has been submitted successfully. We appreciate your input!', 'alert');
 
 // Close form
 feedbackForm.classList.remove('show');
 });
 }
 }
 
 // Show form with animation
 feedbackForm.classList.add('show');
 }
 
 // Add feedback styles
 const feedbackStyles = document.createElement('style');
 feedbackStyles.textContent = `
 .feedback-button {
 position: fixed;
 bottom: 100px;
 right: 20px;
 width: 40px;
 height: 40px;
 border-radius: 50%;
 background-color: #0f2bab;
 color: white;
 border: none;
 box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
 display: flex;
 align-items: center;
 justify-content: center;
 cursor: pointer;
 z-index: 1000;
 }
 
 .feedback-form {
 position: fixed;
 top: 0;
 left: 0;
 width: 100%;
 height: 100%;
 background-color: rgba(0, 0, 0, 0.7);
 display: flex;
 align-items: center;
 justify-content: center;
 z-index: 2000;
 opacity: 0;
 visibility: hidden;
 transition: opacity 0.3s ease, visibility 0.3s ease;
 }
 
 .feedback-form.show {
 opacity: 1;
 visibility: visible;
 }
 
 .feedback-form-content {
 background-color: white;
 border-radius: 8px;
 width: 90%;
 max-width: 500px;
 max-height: 90vh;
 overflow-y: auto;
 }
 
 .feedback-form-header {
 display: flex;
 justify-content: space-between;
 align-items: center;
 padding: 16px;
 border-bottom: 1px solid #eee;
 }
 
 .feedback-form-header h3 {
 margin: 0;
 font-size: 18px;
 color: #333;
 }
 
 .feedback-form-header button {
 background: none;
 border: none;
 color: #666;
 cursor: pointer;
 font-size: 16px;
 }
 
 .feedback-form-body {
 padding: 16px;
 }
 
 .feedback-field {
 margin-bottom: 16px;
 }
 
 .feedback-field label {
 display: block;
 margin-bottom: 8px;
 font-size: 14px;
 color: #333;
 }
 
 .feedback-field select,
 .feedback-field input,
 .feedback-field textarea {
 width: 100%;
 padding: 10px;
 border: 1px solid #ddd;
 border-radius: 4px;
 font-size: 14px;
 }
 
 .feedback-field textarea {
 height: 120px;
 resize: vertical;
 }
 
 .submit-feedback {
 background-color: #0f2bab;
 color: white;
 border: none;
 border-radius: 4px;
 padding: 12px 20px;
 font-size: 16px;
 font-weight: 500;
 cursor: pointer;
 width: 100%;
 transition: background-color 0.2s ease;
 }
 
 .submit-feedback:hover {
 background-color: #0a1f8f;
 }
 
 /* Support for iOS devices with notches */
 @supports (padding-bottom: env(safe-area-inset-bottom)) {
 .feedback-button {
 bottom: calc(100px + env(safe-area-inset-bottom, 0px));
 right: calc(20px + env(safe-area-inset-right, 0px));
 }
 
 .feedback-form-content {
 margin-bottom: env(safe-area-inset-bottom, 0px);
 }
 }
 `;
 
 document.head.appendChild(feedbackStyles);
 }

// Initialize feedback system
 initFeedback();

// Log initialization complete (continuing from where we left off)
 console.log('Minnesota Then Museum Without Walls Tour - All systems initialized');

// Add support for tour statistics
 function initTourStatistics() {
 // Statistics object
 let statistics = {
 totalDistance: 0, // Total distance traveled in meters
 tourDuration: 0, // Total tour duration in seconds
 locationsVisited: 0, // Number of locations visited
 startTime: null, // Tour start time
 lastUpdateTime: null, // Last statistics update time
 averageSpeed: 0, // Average speed in m/s
 maxSpeed: 0, // Maximum speed in m/s
 pauseDuration: 0, // Total pause duration in seconds
 isPaused: false, // Whether tour is currently paused
 pauseStartTime: null // Time when tour was paused
 };
 
 // Load statistics from localStorage
 function loadStatistics() {
 try {
 const saved = localStorage.getItem('tourStatistics');
 if (saved) {
 const parsed = JSON.parse(saved);
 statistics = { ...statistics, ...parsed };
 }
 
 // Initialize start time if not set
 if (!statistics.startTime) {
 statistics.startTime = new Date().toISOString();
 statistics.lastUpdateTime = new Date().toISOString();
 }
 } catch (e) {
 console.warn('Could not load tour statistics', e);
 }
 }
 
 // Save statistics to localStorage
 function saveStatistics() {
 try {
 localStorage.setItem('tourStatistics', JSON.stringify(statistics));
 } catch (e) {
 console.warn('Could not save tour statistics', e);
 }
 }
 
 // Update statistics
 function updateStatistics() {
 // Skip if paused
 if (statistics.isPaused) return;
 
 // Update locations visited
 statistics.locationsVisited = visitedLocations.length;
 
 // Update tour duration
 const now = new Date();
 const lastUpdate = new Date(statistics.lastUpdateTime);
 const timeDiff = (now - lastUpdate) / 1000; // in seconds
 
 statistics.tourDuration += timeDiff;
 statistics.lastUpdateTime = now.toISOString();
 
 // Update distance if position available
 if (lastPosition && lastValidPosition) {
 const distance = calculateDistance(
 { lat: lastPosition.lat, lng: lastPosition.lng },
 { lat: lastValidPosition.lat, lng: lastValidPosition.lng }
 );
 
 // Only update if distance is reasonable (less than 100m since last update)
 // This helps filter out GPS jumps
 if (distance > 0 && distance < 100) {
 statistics.totalDistance += distance;
 
 // Calculate current speed
 const speed = distance / timeDiff; // m/s
 
 // Update max speed
 if (speed > statistics.maxSpeed) {
 statistics.maxSpeed = speed;
 }
 
 // Update average speed
 if (statistics.tourDuration > 0) {
 statistics.averageSpeed = statistics.totalDistance / statistics.tourDuration;
 }
 }
 
 // Update last valid position
 lastValidPosition = { ...lastPosition };
 }
 
 // Save statistics periodically
 saveStatistics();
 }
 
 // Pause statistics tracking
 function pauseStatistics() {
 if (!statistics.isPaused) {
 statistics.isPaused = true;
 statistics.pauseStartTime = new Date().toISOString();
 }
 }
 
 // Resume statistics tracking
 function resumeStatistics() {
 if (statistics.isPaused && statistics.pauseStartTime) {
 const pauseEnd = new Date();
 const pauseStart = new Date(statistics.pauseStartTime);
 const pauseDuration = (pauseEnd - pauseStart) / 1000; // in seconds
 
 statistics.pauseDuration += pauseDuration;
 statistics.isPaused = false;
 statistics.pauseStartTime = null;
 statistics.lastUpdateTime = new Date().toISOString();
 }
 }
 
 // Format duration as HH:MM:SS
 function formatDuration(seconds) {
 const hours = Math.floor(seconds / 3600);
 const minutes = Math.floor((seconds % 3600) / 60);
 const secs = Math.floor(seconds % 60);
 
 return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
 }
 
 // Format distance in meters or kilometers
 function formatDistance(meters) {
 if (meters < 1000) {
 return `${Math.round(meters)} m`;
 } else {
 return `${(meters / 1000).toFixed(2)} km`;
 }
 }
 
 // Show statistics
 function showStatistics() {
 // Create statistics modal
 let statisticsModal = document.getElementById('statisticsModal');
 
 if (!statisticsModal) {
 statisticsModal = document.createElement('div');
 statisticsModal.id = 'statisticsModal';
 statisticsModal.className = 'statistics-modal';
 statisticsModal.innerHTML = `
 <div class="statistics-modal-content">
 <div class="statistics-modal-header">
 <h3>Tour Statistics</h3>
 <button id="closeStatisticsModal" aria-label="Close statistics">
 <i class="fas fa-times"></i>
 </button>
 </div>
 <div class="statistics-modal-body">
 <div class="statistics-item">
 <div class="statistics-label">Distance Traveled</div>
 <div class="statistics-value" id="statisticsDistance">0 m</div>
 </div>
 <div class="statistics-item">
 <div class="statistics-label">Tour Duration</div>
 <div class="statistics-value" id="statisticsDuration">00:00:00</div>
 </div>
 <div class="statistics-item">
 <div class="statistics-label">Locations Visited</div>
 <div class="statistics-value" id="statisticsLocations">0/${gameLocations.length}</div>
 </div>
 <div class="statistics-item">
 <div class="statistics-label">Average Speed</div>
 <div class="statistics-value" id="statisticsSpeed">0 m/s</div>
 </div>
 <div class="statistics-item">
 <div class="statistics-label">Completion</div>
 <div class="statistics-value" id="statisticsCompletion">0%</div>
 </div>
 </div>
 <div class="statistics-modal-footer">
 <button id="resetStatistics">Reset Statistics</button>
 <button id="shareStatistics">Share</button>
 </div>
 </div>
 `;
 
 document.body.appendChild(statisticsModal);
 
 // Add event listeners
 const closeButton = document.getElementById('closeStatisticsModal');
 if (closeButton) {
 closeButton.addEventListener('click', () => {
 statisticsModal.classList.remove('show');
 });
 }
 
 const resetButton = document.getElementById('resetStatistics');
 if (resetButton) {
 resetButton.addEventListener('click', () => {
 // Show confirmation
 showPopup('Reset Statistics', 'Are you sure you want to reset all tour statistics?', 'confirm', () => {
 // Reset statistics
 statistics = {
 totalDistance: 0,
 tourDuration: 0,
 locationsVisited: 0,
 startTime: new Date().toISOString(),
 lastUpdateTime: new Date().toISOString(),
 averageSpeed: 0,
 maxSpeed: 0,
 pauseDuration: 0,
 isPaused: false,
 pauseStartTime: null
 };
 
 // Save reset statistics
 saveStatistics();
 
 // Update display
 updateStatisticsDisplay();
 
 // Show confirmation
 showErrorMessage('Statistics have been reset', 3000);
 });
 });
 }
 
 const shareButton = document.getElementById('shareStatistics');
 if (shareButton) {
 shareButton.addEventListener('click', async () => {
 // Create share text
 const shareText = `I've explored the Minnesota Then Museum Without Walls tour!\n\n` +
 `Distance: ${formatDistance(statistics.totalDistance)}\n` +
 `Duration: ${formatDuration(statistics.tourDuration)}\n` +
 `Locations: ${statistics.locationsVisited}/${gameLocations.length}\n` +
 `Completion: ${Math.round((statistics.locationsVisited / gameLocations.length) * 100)}%`;
 
 // Share statistics
 if (navigator.share) {
 try {
 await navigator.share({
 title: 'My Minnesota Then Tour Statistics',
 text: shareText,
 url: window.location.href
 });
 console.log('Statistics shared successfully');
 } catch (error) {
 console.error('Error sharing statistics:', error);
 }
 } else {
 // Fallback for browsers that don't support Web Share API
 // Copy to clipboard
 const textarea = document.createElement('textarea');
 textarea.value = shareText;
 document.body.appendChild(textarea);
 textarea.select();
 document.execCommand('copy');
 document.body.removeChild(textarea);
 
 showErrorMessage('Statistics copied to clipboard', 3000);
 }
 });
 }
 }
 
 // Update statistics display
 updateStatisticsDisplay();
 
 // Show modal with animation
 statisticsModal.classList.add('show');
 }
 
 // Update statistics display
 function updateStatisticsDisplay() {
 // Update distance
 const distanceElement = document.getElementById('statisticsDistance');
 if (distanceElement) {
 distanceElement.textContent = formatDistance(statistics.totalDistance);
 }
 
 // Update duration
 const durationElement = document.getElementById('statisticsDuration');
 if (durationElement) {
 durationElement.textContent = formatDuration(statistics.tourDuration);
 }
 
 // Update locations
 const locationsElement = document.getElementById('statisticsLocations');
 if (locationsElement) {
 locationsElement.textContent = `${statistics.locationsVisited}/${gameLocations.length}`;
 }
 
 // Update speed
 const speedElement = document.getElementById('statisticsSpeed');
 if (speedElement) {
 // Convert m/s to km/h for better readability
 const speedKmh = statistics.averageSpeed * 3.6;
 speedElement.textContent = `${speedKmh.toFixed(1)} km/h`;
 }
 
 // Update completion
 const completionElement = document.getElementById('statisticsCompletion');
 if (completionElement) {
 const completion = Math.round((statistics.locationsVisited / gameLocations.length) * 100);
 completionElement.textContent = `${completion}%`;
 }
 }
 
 // Create statistics button
 const statisticsButton = document.createElement('button');
 statisticsButton.id = 'statisticsButton';
 statisticsButton.className = 'statistics-button';
 statisticsButton.innerHTML = '<i class="fas fa-chart-bar"></i>';
 statisticsButton.setAttribute('aria-label', 'View tour statistics');
 statisticsButton.setAttribute('title', 'View tour statistics');
 
 // Add statistics button to body
 document.body.appendChild(statisticsButton);
 
 // Add event listener
 statisticsButton.addEventListener('click', () => {
 // Show statistics
 showStatistics();
 });
 
 // Add statistics styles
 const statisticsStyles = document.createElement('style');
 statisticsStyles.textContent = `
 .statistics-button {
 position: fixed;
 bottom: 150px;
 right: 20px;
 width: 40px;
 height: 40px;
 border-radius: 50%;
 background-color: #4CAF50;
 color: white;
 border: none;
 box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
 display: flex;
 align-items: center;
 justify-content: center;
 cursor: pointer;
 z-index: 1000;
 }
 
 .statistics-modal {
 position: fixed;
 top: 0;
 left: 0;
 width: 100%;
 height: 100%;
 background-color: rgba(0, 0, 0, 0.7);
 display: flex;
 align-items: center;
 justify-content: center;
 z-index: 2000;
 opacity: 0;
 visibility: hidden;
 transition: opacity 0.3s ease, visibility 0.3s ease;
 }
 
 .statistics-modal.show {
 opacity: 1;
 visibility: visible;
 }
 
 .statistics-modal-content {
 background-color: white;
 border-radius: 8px;
 width: 90%;
 max-width: 400px;
 overflow: hidden;
 }
 
 .statistics-modal-header {
 display: flex;
 justify-content: space-between;
 align-items: center;
 padding: 16px;
 border-bottom: 1px solid #eee;
 }
 
 .statistics-modal-header h3 {
 margin: 0;
 font-size: 18px;
 color: #333;
 }
 
 .statistics-modal-header button {
 background: none;
 border: none;
 color: #666;
 cursor: pointer;
 font-size: 16px;
 }
 
 .statistics-modal-body {
 padding: 16px;
 }
 
 .statistics-item {
 display: flex;
 justify-content: space-between;
 align-items: center;
 margin-bottom: 12px;
 padding-bottom: 12px;
 border-bottom: 1px solid #eee;
 }
 
 .statistics-item:last-child {
 margin-bottom: 0;
 padding-bottom: 0;
 border-bottom: none;
 }
 
 .statistics-label {
 font-size: 14px;
 color: #666;
 }
 
 .statistics-value {
 font-size: 16px;
 font-weight: 600;
 color: #333;
 }
 
 .statistics-modal-footer {
 display: flex;
 justify-content: space-between;
 padding: 16px;
 border-top: 1px solid #eee;
 }
 
 .statistics-modal-footer button {
 padding: 10px 16px;
 border: none;
 border-radius: 4px;
 font-size: 14px;
 font-weight: 500;
 cursor: pointer;
 transition: background-color 0.2s ease;
 }
 
 #resetStatistics {
 background-color: #f2f2f2;
 color: #333;
 }
 
 #shareStatistics {
 background-color: #0f2bab;
 color: white;
 }
 
 /* Support for iOS devices with notches */
 @supports (padding-bottom: env(safe-area-inset-bottom)) {
 .statistics-button {
 bottom: calc(150px + env(safe-area-inset-bottom, 0px));
 right: calc(20px + env(safe-area-inset-right, 0px));
 }
 
 .statistics-modal-content {
 margin-bottom: env(safe-area-inset-bottom, 0px);
 }
 }
 `;
 
 document.head.appendChild(statisticsStyles);
 
 // Update statistics when position changes
 const originalHandlePositionUpdate = handlePositionUpdate;
 window.handlePositionUpdate = function(position) {
 originalHandlePositionUpdate(position);
 
 // Update statistics
 updateStatistics();
 };
 
 // Pause statistics when app is hidden
 document.addEventListener('visibilitychange', () => {
 if (document.hidden) {
 pauseStatistics();
 } else {
 resumeStatistics();
 }
 });
 
 // Load initial statistics
 loadStatistics();
 
 // Update statistics every minute
 setInterval(updateStatistics, 60000);
 
 // Make statistics functions available globally
 window.showStatistics = showStatistics;
 window.pauseStatistics = pauseStatistics;
 window.resumeStatistics = resumeStatistics;
 }

// Initialize tour statistics
 initTourStatistics();

// Add support for tour completion certificate
 function initCompletionCertificate() {
 // Generate certificate
 function generateCertificate() {
 // Check if tour is complete
 if (visitedLocations.length < gameLocations.length) {
 showErrorMessage('Complete the tour to receive your certificate', 3000);
 return;
 }
 
 // Create certificate modal
 let certificateModal = document.getElementById('certificateModal');
 
 if (!certificateModal) {
 certificateModal = document.createElement('div');
 certificateModal.id = 'certificateModal';
 certificateModal.className = 'certificate-modal';
 certificateModal.innerHTML = `
 <div class="certificate-modal-content">
 <div class="certificate-modal-header">
 <h3>Tour Completion Certificate</h3>
 <button id="closeCertificateModal" aria-label="Close certificate">
 <i class="fas fa-times"></i>
 </button>
 </div>
 <div class="certificate-modal-body">
 <div class="certificate">
 <div class="certificate-header">
 <div class="certificate-logo">🏛️</div>
 <h2>Certificate of Completion</h2>
 </div>
 <div class="certificate-content">
 <p>This certifies that</p>
 <div class="certificate-name" id="certificateName">Explorer</div>
 <p>has successfully completed the</p>
 <div class="certificate-tour-name">Minnesota Then Museum Without Walls Tour</div>
 <p>visiting all historical locations and learning about Minnesota's rich history.</p>
 <div class="certificate-date" id="certificateDate"></div>
 </div>
 <div class="certificate-footer">
 <div class="certificate-seal">🏆</div>
 </div>
 </div>
 </div>
 <div class="certificate-modal-footer">
 <button id="downloadCertificate">Download</button>
 <button id="shareCertificate">Share</button>
 </div>
 </div>
 `;
 
 document.body.appendChild(certificateModal);
 
 // Add event listeners
 const closeButton = document.getElementById('closeCertificateModal');
 if (closeButton) {
 closeButton.addEventListener('click', () => {
 certificateModal.classList.remove('show');
 });
 }
 
 const downloadButton = document.getElementById('downloadCertificate');
 if (downloadButton) {
 downloadButton.addEventListener('click', () => {
 // In a real app, this would generate a PDF or image
 showErrorMessage('Certificate download feature coming soon', 3000);
 });
 }
 
 const shareButton = document.getElementById('shareCertificate');
 if (shareButton) {
 shareButton.addEventListener('click', async () => {
 // Create share text
 const shareText = `I've completed the Minnesota Then Museum Without Walls tour! 🏆\n\n` +
 `Explored all historical locations and learned about Minnesota's rich history.\n\n` +
 `Join the tour at: ${window.location.href}`;
 
 // Share certificate
 if (navigator.share) {
 try {
 await navigator.share({
 title: 'My Minnesota Then Tour Certificate',
 text: shareText,
 url: window.location.href
 });
 console.log('Certificate shared successfully');
 } catch (error) {
 console.error('Error sharing certificate:', error);
 }
 } else {
 // Fallback for browsers that don't support Web Share API
 // Copy to clipboard
 const textarea = document.createElement('textarea');
 textarea.value = shareText;
 document.body.appendChild(textarea);
 textarea.select();
 document.execCommand('copy');
 document.body.removeChild(textarea);
 
 showErrorMessage('Certificate text copied to clipboard', 3000);
 }
 });
 }
 }
 
 // Update certificate date
 const dateElement = document.getElementById('certificateDate');
 if (dateElement) {
 const options = { year: 'numeric', month: 'long', day: 'numeric' };
 dateElement.textContent = new Date().toLocaleDateString(undefined, options);
 }
 
 // Show modal with animation
 certificateModal.classList.add('show');
 }
 
 // Add certificate styles
 const certificateStyles = document.createElement('style');
 certificateStyles.textContent = `
 .certificate-modal {
 position: fixed;
 top: 0;
 left: 0;
 width: 100%;
 height: 100%;
 background-color: rgba(0, 0, 0, 0.7);
 display: flex;
 align-items: center;
 justify-content: center;
 z-index: 2000;
 opacity: 0;
 visibility: hidden;
 transition: opacity 0.3s ease, visibility 0.3s ease;
 }
 
 .certificate-modal.show {
 opacity: 1;
 visibility: visible;
 }
 
 .certificate-modal-content {
 background-color: white;
 border-radius: 8px;
 width: 90%;
 max-width: 500px;
 overflow: hidden;
 }
 
 .certificate-modal-header {
 display: flex;
 justify-content: space-between;
 align-items: center;
 padding: 16px;
 border-bottom: 1px solid #eee;
 }
 
 .certificate-modal-header h3 {
 margin: 0;
 font-size: 18px;
 color: #333;
 }
 
 .certificate-modal-header button {
 background: none;
 border: none;
 color: #666;
 cursor: pointer;
 font-size: 16px;
 }
 
 .certificate-modal-body {
 padding: 16px;
 }
 
 .certificate {
 border: 2px solid #0f2bab;
 padding: 20px;
 text-align: center;
 background-color: #f9f9f9;
 position: relative;
 }
 
 .certificate-header {
 margin-bottom: 20px;
 }
 
 .certificate-logo {
 font-size: 40px;
 margin-bottom: 10px;
 }
 
 .certificate-header h2 {
 margin: 0;
 color: #0f2bab;
 font-size: 24px;
 }
 
 .certificate-content {
 margin-bottom: 20px;
 }
 
 .certificate-content p {
 margin: 10px 0;
 font-size: 14px;
 }
 
 .certificate-name {
 font-size: 24px;
 font-weight: bold;
 color: #333;
 margin: 10px 0;
 }
 
 .certificate-tour-name {
 font-size: 18px;
 font-weight: bold;
 color: #0f2bab;
 margin: 10px 0;
 }
 
 .certificate-date {
 font-style: italic;
 margin-top: 20px;
 }
 
 .certificate-footer {
 margin-top: 20px;
 }
 
 .certificate-seal {
 font-size: 40px;
 }
 
 .certificate-modal-footer {
 display: flex;
 justify-content: space-between;
 padding: 16px;
 border-top: 1px solid #eee;
 }
 
 .certificate-modal-footer button {
 padding: 10px 16px;
 border: none;
 border-radius: 4px;
 font-size: 14px;
 font-weight: 500;
 cursor: pointer;
 transition: background-color 0.2s ease;
 }
 
 #downloadCertificate {
 background-color: #f2f2f2;
 color: #333;
 }
 
 #shareCertificate {
 background-color: #0f2bab;
 color: white;
 }
 
 /* Support for iOS devices with notches */
 @supports (padding-bottom: env(safe-area-inset-bottom)) {
 .certificate-modal-content {
 margin-bottom: env(safe-area-inset-bottom, 0px);
 }
 }
 `;
 
 document.head.appendChild(certificateStyles);
 
 // Override show congratulations to include certificate
 const originalShowCongratulations = showCongratulations;
 window.showCongratulations = function() {
 originalShowCongratulations();
 
 // Show certificate after a delay
 setTimeout(() => {
 generateCertificate();
 }, 3000);
 };
 
 // Make certificate function available globally
 window.generateCertificate = generateCertificate;
 }

// Initialize completion certificate
 initCompletionCertificate();

// Final cleanup and optimization
 (function() {
 // Remove any console.log statements in production
 if (window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1') {
 console.log = function() {};
 console.debug = function() {};
 }
 
 // Add error tracking
 window.addEventListener('error', function(event) {
 // In a real app, this would send error data to a server
 console.error('Application error:', {
 message: event.message,
 source: event.filename,
 lineno: event.lineno,
 colno: event.colno,
 error: event.error
 });
 
 return false;
 });
 
 // Add unhandled promise rejection tracking
 window.addEventListener('unhandledrejection', function(event) {
 // In a real app, this would send error data to a server
 console.error('Unhandled promise rejection:', event.reason);
 
 return false;
 });
 
 // Clean up event listeners when page is unloaded
 window.addEventListener('beforeunload', function() {
 // Clear watch position
 if (watchPositionId) {
 navigator.geolocation.clearWatch(watchPositionId);
 }
 
 // Save final state
 if (lastPosition) {
 localStorage.setItem('lastKnownLocation', JSON.stringify(lastPosition));
 }
 
 localStorage.setItem('currentLocationIndex', currentLocationIndex.toString());
 localStorage.setItem('visitedLocations', JSON.stringify(visitedLocations));
 });
 })();

// Final log message (continuing from where we left off)
 console.log('Minnesota Then Museum Without Walls Tour - Ready for exploration!');

// Add support for custom themes
 function initThemeSupport() {
 // Available themes
 const themes = [
 {
 id: 'default',
 name: 'Default',
 primaryColor: '#0f2bab',
 secondaryColor: '#4CAF50',
 backgroundColor: '#ffffff',
 textColor: '#333333'
 },
 {
 id: 'dark',
 name: 'Dark Mode',
 primaryColor: '#3f51b5',
 secondaryColor: '#4CAF50',
 backgroundColor: '#121212',
 textColor: '#ffffff'
 },
 {
 id: 'sepia',
 name: 'Historical',
 primaryColor: '#8B4513',
 secondaryColor: '#A0522D',
 backgroundColor: '#F5F5DC',
 textColor: '#5D4037'
 },
 {
 id: 'accessible',
 name: 'High Contrast',
 primaryColor: '#000000',
 secondaryColor: '#FFFF00',
 backgroundColor: '#ffffff',
 textColor: '#000000'
 }
 ];
 
 // Get current theme
 function getCurrentTheme() {
 const savedThemeId = localStorage.getItem('selectedTheme') || 'default';
 return themes.find(theme => theme.id === savedThemeId) || themes[0];
 }
 
 // Apply theme
 function applyTheme(theme) {
 // Create or update theme style element
 let themeStyle = document.getElementById('customTheme');
 
 if (!themeStyle) {
 themeStyle = document.createElement('style');
 themeStyle.id = 'customTheme';
 document.head.appendChild(themeStyle);
 }
 
 // Set theme CSS variables
 themeStyle.textContent = `
 :root {
 --primary-color: ${theme.primaryColor};
 --secondary-color: ${theme.secondaryColor};
 --bg-color: ${theme.backgroundColor};
 --text-color: ${theme.textColor};
 }
 
 body {
 background-color: var(--bg-color);
 color: var(--text-color);
 }
 
 .map-button {
 background-color: var(--bg-color);
 color: var(--primary-color);
 }
 
 .map-button:active, .map-button:focus {
 background-color: var(--primary-color);
 color: var(--bg-color);
 }
 
 .distance-box {
 background-color: var(--bg-color);
 color: var(--text-color);
 }
 
 .location-marker-icon {
 background-color: var(--primary-color);
 }
 
 .location-marker-icon.visited {
 background-color: var(--secondary-color);
 }
 
 .popup-btn.directions {
 background-color: var(--primary-color);
 }
 
 #finishTourButton, .submit-feedback, #shareStatistics {
 background-color: var(--primary-color);
 }
 
 .certificate {
 border-color: var(--primary-color);
 }
 
 .certificate-header h2, .certificate-tour-name {
 color: var(--primary-color);
 }
 
 /* Dark mode specific adjustments */
 ${theme.id === 'dark' ? `
 .popup-content, .feedback-form-content, .accessibility-menu,
 .statistics-modal-content, .certificate-modal-content {
 background-color: #1e1e1e;
 color: #ffffff;
 }
 
 .popup-title, .feedback-form-header h3, .accessibility-menu-header h3,
 .statistics-modal-header h3, .certificate-modal-header h3,
 .statistics-value, .marker-popup-title {
 color: #ffffff;
 }
 
 .popup-message, .feedback-field label, .accessibility-option label,
 .statistics-label, .marker-popup-description {
 color: #cccccc;
 }
 
 .popup-button.cancel-button, .cancel-btn, #resetStatistics, #downloadCertificate {
 background-color: #333333;
 color: #ffffff;
 }
 
 .certificate {
 background-color: #1e1e1e;
 }
 
 .certificate-name {
 color: #ffffff;
 }
 
 input, select, textarea {
 background-color: #333333;
 color: #ffffff;
 border-color: #555555;
 }
 ` : ''}
 `;
 
 // Save selected theme
 localStorage.setItem('selectedTheme', theme.id);
 
 // Update map tiles if dark mode
 if (map) {
 if (theme.id === 'dark') {
 // Remove existing tile layer
 map.eachLayer(layer => {
 if (layer instanceof L.TileLayer) {
 map.removeLayer(layer);
 }
 });
 
 // Add dark mode tiles
 L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
 maxZoom: 19,
 attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors © <a href="https://carto.com/attributions">CARTO</a>'
 }).addTo(map);
 } else if (document.querySelector('.leaflet-tile-pane').innerHTML.includes('cartocdn')) {
 // Remove dark mode tiles
 map.eachLayer(layer => {
 if (layer instanceof L.TileLayer) {
 map.removeLayer(layer);
 }
 });
 
 // Add default tiles
 L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
 maxZoom: 19,
 attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
 }).addTo(map);
 }
 }
 }
 
 // Create theme selector
 function createThemeSelector() {
 // Create theme button
 const themeButton = document.createElement('button');
 themeButton.id = 'themeButton';
 themeButton.className = 'theme-button';
 themeButton.innerHTML = '<i class="fas fa-palette"></i>';
 themeButton.setAttribute('aria-label', 'Change theme');
 themeButton.setAttribute('title', 'Change theme');
 
 // Add theme button to body
 document.body.appendChild(themeButton);
 
 // Create theme menu
 const themeMenu = document.createElement('div');
 themeMenu.id = 'themeMenu';
 themeMenu.className = 'theme-menu';
 
 // Add theme options
 let themeOptionsHTML = `
 <div class="theme-menu-header">
 <h3>Select Theme</h3>
 <button id="closeThemeMenu" aria-label="Close menu">
 <i class="fas fa-times"></i>
 </button>
 </div>
 <div class="theme-menu-content">
 `;
 
 themes.forEach(theme => {
 themeOptionsHTML += `
 <div class="theme-option" data-theme-id="${theme.id}">
 <div class="theme-color-preview" style="background-color: ${theme.primaryColor}"></div>
 <div class="theme-name">${theme.name}</div>
 </div>
 `;
 });
 
 themeOptionsHTML += `</div>`;
 themeMenu.innerHTML = themeOptionsHTML;
 
 // Add theme menu to body
 document.body.appendChild(themeMenu);
 
 // Add event listeners
 themeButton.addEventListener('click', () => {
 themeMenu.classList.toggle('show');
 });
 
 const closeButton = document.getElementById('closeThemeMenu');
 if (closeButton) {
 closeButton.addEventListener('click', () => {
 themeMenu.classList.remove('show');
 });
 }
 
 // Add event listeners to theme options
 const themeOptions = document.querySelectorAll('.theme-option');
 themeOptions.forEach(option => {
 option.addEventListener('click', () => {
 const themeId = option.getAttribute('data-theme-id');
 const selectedTheme = themes.find(theme => theme.id === themeId);
 
 if (selectedTheme) {
 applyTheme(selectedTheme);
 themeMenu.classList.remove('show');
 }
 });
 });
 
 // Add theme styles
 const themeStyles = document.createElement('style');
 themeStyles.textContent = `
 .theme-button {
 position: fixed;
 bottom: 200px;
 right: 20px;
 width: 40px;
 height: 40px;
 border-radius: 50%;
 background-color: var(--bg-color);
 color: var(--primary-color);
 border: none;
 box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
 display: flex;
 align-items: center;
 justify-content: center;
 cursor: pointer;
 z-index: 1000;
 }
 
 .theme-menu {
 position: fixed;
 bottom: 250px;
 right: 20px;
 background-color: var(--bg-color);
 border-radius: 8px;
 box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
 width: 200px;
 z-index: 1000;
 display: none;
 overflow: hidden;
 transition: transform 0.3s ease, opacity 0.3s ease;
 transform: translateY(10px);
 opacity: 0;
 }
 
 .theme-menu.show {
 display: block;
 transform: translateY(0);
 opacity: 1;
 }
 
 .theme-menu-header {
 display: flex;
 justify-content: space-between;
 align-items: center;
 padding: 12px 16px;
 border-bottom: 1px solid #eee;
 }
 
 .theme-menu-header h3 {
 margin: 0;
 font-size: 16px;
 color: var(--text-color);
 }
 
 .theme-menu-header button {
 background: none;
 border: none;
 color: var(--text-color);
 cursor: pointer;
 font-size: 16px;
 }
 
 .theme-menu-content {
 padding: 12px;
 }
 
 .theme-option {
 display: flex;
 align-items: center;
 padding: 8px;
 border-radius: 4px;
 cursor: pointer;
 transition: background-color 0.2s ease;
 }
 
 .theme-option:hover {
 background-color: rgba(0, 0, 0, 0.05);
 }
 
 .theme-color-preview {
 width: 20px;
 height: 20px;
 border-radius: 50%;
 margin-right: 12px;
 }
 
 .theme-name {
 font-size: 14px;
 color: var(--text-color);
 }
 
 /* Support for iOS devices with notches */
 @supports (padding-bottom: env(safe-area-inset-bottom)) {
 .theme-button {
 bottom: calc(200px + env(safe-area-inset-bottom, 0px));
 right: calc(20px + env(safe-area-inset-right, 0px));
 }
 
 .theme-menu {
 bottom: calc(250px + env(safe-area-inset-bottom, 0px));
 right: calc(20px + env(safe-area-inset-right, 0px));
 }
 }
 `;
 
 document.head.appendChild(themeStyles);
 }
 
 // Initialize theme
 createThemeSelector();
 
 // Apply saved theme or default
 applyTheme(getCurrentTheme());
 }

// Initialize theme support
 initThemeSupport();

// Add support for guided tours
 function initGuidedTour() {
 // Tour steps
 const tourSteps = [
 {
 element: '.map-buttons',
 title: 'Map Controls',
 content: 'Use these buttons to navigate the map. Recenter on your location, zoom in/out, and toggle navigation tips.',
 position: 'top'
 },
 {
 element: '#distanceBox',
 title: 'Distance Indicator',
 content: 'Shows your distance to the current location. The color changes as you get closer.',
 position: 'bottom'
 },
 {
 element: '.location-marker',
 title: 'Location Markers',
 content: 'These markers show historical locations to visit. Click on a marker to see more information.',
 position: 'right'
 },
 {
 element: '#statisticsButton',
 title: 'Tour Statistics',
 content: 'View your progress, distance traveled, and other tour statistics.',
 position: 'left'
 },
 {
 element: '#feedbackButton',
 title: 'Provide Feedback',
 content: 'Share your thoughts, report issues, or suggest improvements.',
 position: 'left'
 },
 {
 element: '#themeButton',
 title: 'Change Theme',
 content: 'Customize the app appearance with different themes.',
 position: 'left'
 },
 {
 element: '#accessibilityButton',
 title: 'Accessibility Options',
 content: 'Adjust settings for better accessibility, including high contrast mode and larger text.',
 position: 'left'
 }
 ];
 
 // Show guided tour
 function showGuidedTour() {
 // Create tour overlay
 let tourOverlay = document.getElementById('tourOverlay');
 let currentStep = 0;
 
 if (!tourOverlay) {
 tourOverlay = document.createElement('div');
 tourOverlay.id = 'tourOverlay';
 tourOverlay.className = 'tour-overlay';
 document.body.appendChild(tourOverlay);
 }
 
 // Show tour step
 function showTourStep(stepIndex) {
 // Get step
 const step = tourSteps[stepIndex];
 if (!step) return;
 
 // Get target element
 const targetElement = document.querySelector(step.element);
 if (!targetElement) {
 // Skip to next step if element not found
 showTourStep(stepIndex + 1);
 return;
 }
 
 // Get element position
 const rect = targetElement.getBoundingClientRect();
 
 // Create or update tooltip
 let tooltip = document.getElementById('tourTooltip');
 
 if (!tooltip) {
 tooltip = document.createElement('div');
 tooltip.id = 'tourTooltip';
 tooltip.className = 'tour-tooltip';
 document.body.appendChild(tooltip);
 }
 
 // Set tooltip content
 tooltip.innerHTML = `
 <div class="tour-tooltip-header">
 <h3>${step.title}</h3>
 <span class="tour-step-counter">${stepIndex + 1}/${tourSteps.length}</span>
 </div>
 <div class="tour-tooltip-content">
 ${step.content}
 </div>
 <div class="tour-tooltip-footer">
 <button id="tourPrevButton" ${stepIndex === 0 ? 'disabled' : ''}>Previous</button>
 <button id="tourSkipButton">Skip Tour</button>
 <button id="tourNextButton">${stepIndex === tourSteps.length - 1 ? 'Finish' : 'Next'}</button>
 </div>
 `;
 
 // Position tooltip
 let top, left;
 
 switch (step.position) {
 case 'top':
 top = rect.top - tooltip.offsetHeight - 10;
 left = rect.left + (rect.width / 2) - (tooltip.offsetWidth / 2);
 break;
 case 'bottom':
 top = rect.bottom + 10;
 left = rect.left + (rect.width / 2) - (tooltip.offsetWidth / 2);
 break;
 case 'left':
 top = rect.top + (rect.height / 2) - (tooltip.offsetHeight / 2);
 left = rect.left - tooltip.offsetWidth - 10;
 break;
 case 'right':
 top = rect.top + (rect.height / 2) - (tooltip.offsetHeight / 2);
 left = rect.right + 10;
 break;
 default:
 top = rect.bottom + 10;
 left = rect.left + (rect.width / 2) - (tooltip.offsetWidth / 2);
 }
 
 // Ensure tooltip is within viewport
 if (top < 10) top = 10;
 if (left < 10) left = 10;
 if (left + tooltip.offsetWidth > window.innerWidth - 10) {
 left = window.innerWidth - tooltip.offsetWidth - 10;
 }
 
 tooltip.style.top = `${top}px`;
 tooltip.style.left = `${left}px`;
 
 // Highlight target element
 targetElement.classList.add('tour-highlight');
 
 // Update overlay
 tourOverlay.style.display = 'block';
 
 // Add event listeners
 const prevButton = document.getElementById('tourPrevButton');
 const skipButton = document.getElementById('tourSkipButton');
 const nextButton = document.getElementById('tourNextButton');
 
 if (prevButton) {
 prevButton.addEventListener('click', () => {
 targetElement.classList.remove('tour-highlight');
 showTourStep(stepIndex - 1);
 });
 }
 
 if (skipButton) {
 skipButton.addEventListener('click', () => {
 endTour();
 });
 }
 
 if (nextButton) {
 nextButton.addEventListener('click', () => {
 targetElement.classList.remove('tour-highlight');
 
 if (stepIndex === tourSteps.length - 1) {
 endTour();
 } else {
 showTourStep(stepIndex + 1);
 }
 });
 }
 }
 
 // End tour
 function endTour() {
 // Remove highlight from all elements
 document.querySelectorAll('.tour-highlight').forEach(el => {
 el.classList.remove('tour-highlight');
 });
 
 // Remove tooltip
 const tooltip = document.getElementById('tourTooltip');
 if (tooltip) {
 document.body.removeChild(tooltip);
 }
 
 // Hide overlay
 tourOverlay.style.display = 'none';
 
 // Mark tour as completed
 localStorage.setItem('guidedTourCompleted', 'true');
 }
 
 // Start tour
 showTourStep(0);
 }
 
 // Add tour styles
 const tourStyles = document.createElement('style');
 tourStyles.textContent = `
 .tour-overlay {
 position: fixed;
 top: 0;
 left: 0;
 width: 100%;
 height: 100%;
 background-color: rgba(0, 0, 0, 0.5);
 z-index: 1500;
 display: none;
 }
 
 .tour-tooltip {
 position: absolute;
 background-color: white;
 border-radius: 8px;
 box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
 width: 280px;
 z-index: 2500;
 overflow: hidden;
 }
 
 .tour-tooltip-header {
 display: flex;
 justify-content: space-between;
 align-items: center;
 padding: 12px 16px;
 background-color: var(--primary-color);
 color: white;
 }
 
 .tour-tooltip-header h3 {
 margin: 0;
 font-size: 16px;
 }
 
 .tour-step-counter {
 font-size: 12px;
 opacity: 0.8;
 }
 
 .tour-tooltip-content {
 padding: 16px;
 font-size: 14px;
 color: #333;
 }
 
 .tour-tooltip-footer {
 display: flex;
 justify-content: space-between;
 padding: 12px 16px;
 border-top: 1px solid #eee;
 }
 
 .tour-tooltip-footer button {
 padding: 8px 12px;
 border: none;
 border-radius: 4px;
 font-size: 12px;
 cursor: pointer;
 transition: background-color 0.2s ease;
 }
 
 #tourPrevButton, #tourSkipButton {
 background-color: #f2f2f2;
 color: #333;
 }
 
 #tourPrevButton:disabled {
 opacity: 0.5;
 cursor: not-allowed;
 }
 
 #tourNextButton {
 background-color: var(--primary-color);
 color: white;
 }
 
 .tour-highlight {
 position: relative;
 z-index: 2000;
 box-shadow: 0 0 0 4px var(--primary-color);
 border-radius: 4px;
 }
 `;
 
 document.head.appendChild(tourStyles);
 
 // Create tour button
 const tourButton = document.createElement('button');
 tourButton.id = 'tourButton';
 tourButton.className = 'tour-button';
 tourButton.innerHTML = '<i class="fas fa-question-circle"></i>';
 tourButton.setAttribute('aria-label', 'Start guided tour');
 tourButton.setAttribute('title', 'Start guided tour');
 
 // Add tour button to body
 document.body.appendChild(tourButton);
 
 // Add tour button styles
 const tourButtonStyles = document.createElement('style');
 tourButtonStyles.textContent = `
 .tour-button {
 position: fixed;
 bottom: 250px;
 right: 20px;
 width: 40px;
 height: 40px;
 border-radius: 50%;
 background-color: var(--bg-color);
 color: var(--primary-color);
 border: none;
 box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
 display: flex;
 align-items: center;
 justify-content: center;
 cursor: pointer;
 z-index: 1000;
 }
 
 /* Support for iOS devices with notches */
 @supports (padding-bottom: env(safe-area-inset-bottom)) {
 .tour-button {
 bottom: calc(250px + env(safe-area-inset-bottom, 0px));
 right: calc(20px + env(safe-area-inset-right, 0px));
 }
 }
 `;
 
 document.head.appendChild(tourButtonStyles);
 
 // Add event listener
 tourButton.addEventListener('click', () => {
 showGuidedTour();
 });
 
 // Show guided tour for first-time users
 const isTourCompleted = localStorage.getItem('guidedTourCompleted') === 'true';
 const isFirstVisit = !localStorage.getItem('hasVisitedBefore');
 
 if (isFirstVisit && !isTourCompleted) {
 // Show tour after a delay to allow UI to initialize
 setTimeout(() => {
 showGuidedTour();
 }, 3000);
 }
 }

// Initialize guided tour
 initGuidedTour();

// Add support for offline maps
 function initOfflineMaps() {
 // Check if offline maps are supported
 if ('caches' in window) {
 // Create cache button
 const cacheButton = document.createElement('button');
 cacheButton.id = 'cacheButton';
 cacheButton.className = 'cache-button';
 cacheButton.innerHTML = '<i class="fas fa-download"></i>';
 cacheButton.setAttribute('aria-label', 'Download offline maps');
 cacheButton.setAttribute('title', 'Download offline maps');
 
 // Add cache button to body
 document.body.appendChild(cacheButton);
 
 // Add cache button styles
 const cacheButtonStyles = document.createElement('style');
 cacheButtonStyles.textContent = `
 .cache-button {
 position: fixed;
 bottom: 300px;
 right: 20px;
 width: 40px;
 height: 40px;
 border-radius: 50%;
 background-color: var(--bg-color);
 color: var(--primary-color);
 border: none;
 box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
 display: flex;
 align-items: center;
 justify-content: center;
 cursor: pointer;
 z-index: 1000;
 }
 
 /* Support for iOS devices with notches */
 @supports (padding-bottom: env(safe-area-inset-bottom)) {
 .cache-button {
 bottom: calc(300px + env(safe-area-inset-bottom, 0px));
 right: calc(20px + env(safe-area-inset-right, 0px));
 }
 }
 `;
 
 document.head.appendChild(cacheButtonStyles);
 
 // Add event listener
 cacheButton.addEventListener('click', () => {
 // Show confirmation
 showPopup('Download Offline Maps', 'Would you like to download map data for offline use? This may use a significant amount of data.', 'confirm', () => {
 // Start downloading map tiles
 downloadMapTiles();
 });
 });
 
 // Download map tiles
 async function downloadMapTiles() {
 // Show loading indicator
 const loadingIndicator = document.createElement('div');
 loadingIndicator.className = 'loading-indicator';
 loadingIndicator.innerHTML = `
 <div class="loading-spinner"></div>
 <div class="loading-text">Downloading map data...</div>
 <div class="loading-progress">0%</div>
 `;
 document.body.appendChild(loadingIndicator);
 
 try {
 // Create cache
 const cache = await caches.open('minnesota-then-map-tiles');
 
 // Get current map bounds
 const bounds = map.getBounds();
 const zoom = map.getZoom();
 
 // Calculate tile URLs
 const tileUrls = [];
 
 // For each zoom level
 for (let z = zoom - 1; z <= zoom + 1; z++) {
 // Calculate tile coordinates
 const northEast = bounds.getNorthEast();
 const southWest = bounds.getSouthWest();
 
 const neTile = latLngToTile(northEast.lat, northEast.lng, z);
 const swTile = latLngToTile(southWest.lat, southWest.lng, z);
 
 // Generate tile URLs
 for (let x = swTile.x; x <= neTile.x; x++) {
 for (let y = neTile.y; y <= swTile.y; y++) {
 const url = `https://a.tile.openstreetmap.org/${z}/${x}/${y}.png`;
 tileUrls.push(url);
 }
 }
 }
 
 // Download tiles
 let downloaded = 0;
 
 for (const url of tileUrls) {
 try {
 await cache.add(url);
 downloaded++;
 
 // Update progress
 const progress = Math.round((downloaded / tileUrls.length) * 100);
 const progressElement = document.querySelector('.loading-progress');
 if (progressElement) {
 progressElement.textContent = `${progress}%`;
 }
 } catch (error) {
 console.warn('Failed to cache tile:', url, error);
 }
 }
 
 // Show success message
 showErrorMessage(`Downloaded ${downloaded} map tiles for offline use`, 3000);
 } catch (error) {
 console.error('Failed to download offline maps:', error);
 showErrorMessage('Failed to download offline maps', 3000);
 } finally {
 // Remove loading indicator
 if (document.body.contains(loadingIndicator)) {
 document.body.removeChild(loadingIndicator);
 }
 }
 }
 
 // Convert latitude and longitude to tile coordinates
 function latLngToTile(lat, lng, zoom) {
 const n = Math.pow(2, zoom);
 const x = Math.floor((lng + 180) / 360 * n);
 const y = Math.floor((1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * n);
 return { x, y };
 }
 
 // Add loading indicator styles
 const loadingStyles = document.createElement('style');
 loadingStyles.textContent = `
 .loading-indicator {
 position: fixed;
 top: 0;
 left: 0;
 width: 100%;
 height: 100%;
 background-color: rgba(0, 0, 0, 0.7);
 display: flex;
 flex-direction: column;
 align-items: center;
 justify-content: center;
 z-index: 3000;
 color: white;
 }
 
 .loading-spinner {
 width: 50px;
 height: 50px;
 border: 5px solid rgba(255, 255, 255, 0.3);
 border-radius: 50%;
 border-top-color: white;
 animation: spin 1s ease-in-out infinite;
 margin-bottom: 20px;
 }
 
 .loading-text {
 font-size: 18px;
 margin-bottom: 10px;
 }
 
 .loading-progress {
 font-size: 24px;
 font-weight: bold;
 }
 
 @keyframes spin {
 to { transform: rotate(360deg); }
 }
 `;
 
 document.head.appendChild(loadingStyles);
 }
 }

// Initialize offline maps
 initOfflineMaps();

// Final initialization message
 console.log('Minnesota Then Museum Without Walls Tour - All systems ready!');

// Add support for augmented reality features
 function initAugmentedReality() {
 // Check if WebXR is supported
 if ('xr' in navigator) {
 // Create AR button
 const arButton = document.createElement('button');
 arButton.id = 'arButton';
 arButton.className = 'ar-button';
 arButton.innerHTML = '<i class="fas fa-vr-cardboard"></i>';
 arButton.setAttribute('aria-label', 'View in AR');
 arButton.setAttribute('title', 'View in AR');
 
 // Add AR button to body
 document.body.appendChild(arButton);
 
 // Add AR button styles
 const arButtonStyles = document.createElement('style');
 arButtonStyles.textContent = `
 .ar-button {
 position: fixed;
 bottom: 350px;
 right: 20px;
 width: 40px;
 height: 40px;
 border-radius: 50%;
 background-color: var(--bg-color);
 color: var(--primary-color);
 border: none;
 box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
 display: flex;
 align-items: center;
 justify-content: center;
 cursor: pointer;
 z-index: 1000;
 }
 
 /* Support for iOS devices with notches */
 @supports (padding-bottom: env(safe-area-inset-bottom)) {
 .ar-button {
 bottom: calc(350px + env(safe-area-inset-bottom, 0px));
 right: calc(20px + env(safe-area-inset-right, 0px));
 }
 }
 `;
 
 document.head.appendChild(arButtonStyles);
 
 // Add event listener
 arButton.addEventListener('click', () => {
 // Check if AR is supported
 navigator.xr.isSessionSupported('immersive-ar').then(supported => {
 if (supported) {
 // Show AR view for current location
 showARView();
 } else {
 showErrorMessage('AR is not supported on your device', 3000);
 }
 }).catch(error => {
 console.error('Error checking AR support:', error);
 showErrorMessage('Could not initialize AR features', 3000);
 });
 });
 
 // Show AR view
 async function showARView() {
 try {
 // Get current location
 const location = gameLocations[currentLocationIndex];
 
 if (!location) {
 showErrorMessage('No location selected for AR view', 3000);
 return;
 }
 
 // Create AR session
 const session = await navigator.xr.requestSession('immersive-ar', {
 requiredFeatures: ['hit-test', 'dom-overlay'],
 domOverlay: { root: document.createElement('div') }
 });
 
 // Create AR overlay
 const overlay = session.domOverlay.root;
 overlay.className = 'ar-overlay';
 overlay.innerHTML = `
 <div class="ar-header">
 <h3>${location.name}</h3>
 <button id="closeARView" aria-label="Close AR view">
 <i class="fas fa-times"></i>
 </button>
 </div>
 <div class="ar-content">
 <div class="ar-info">
 <p>${location.description}</p>
 </div>
 </div>
 `;
 
 document.body.appendChild(overlay);
 
 // Add AR overlay styles
 const arOverlayStyles = document.createElement('style');
 arOverlayStyles.textContent = `
 .ar-overlay {
 position: fixed;
 top: 0;
 left: 0;
 width: 100%;
 height: 100%;
 pointer-events: none;
 z-index: 3000;
 }
 
 .ar-header {
 position: absolute;
 top: 20px;
 left: 20px;
 right: 20px;
 background-color: rgba(255, 255, 255, 0.8);
 border-radius: 8px;
 padding: 12px;
 display: flex;
 justify-content: space-between;
 align-items: center;
 pointer-events: auto;
 }
 
 .ar-header h3 {
 margin: 0;
 font-size: 16px;
 color: #333;
 }
 
 .ar-header button {
 background: none;
 border: none;
 color: #666;
 cursor: pointer;
 font-size: 16px;
 }
 
 .ar-content {
 position: absolute;
 bottom: 20px;
 left: 20px;
 right: 20px;
 background-color: rgba(255, 255, 255, 0.8);
 border-radius: 8px;
 padding: 12px;
 pointer-events: auto;
 }
 
 .ar-info p {
 margin: 0;
 font-size: 14px;
 color: #333;
 }
 
 /* Support for iOS devices with notches */
 @supports (padding-top: env(safe-area-inset-top)) {
 .ar-header {
 top: calc(20px + env(safe-area-inset-top, 0px));
 left: calc(20px + env(safe-area-inset-left, 0px));
 right: calc(20px + env(safe-area-inset-right, 0px));
 }
 
 .ar-content {
 bottom: calc(20px + env(safe-area-inset-bottom, 0px));
 left: calc(20px + env(safe-area-inset-left, 0px));
 right: calc(20px + env(safe-area-inset-right, 0px));
 }
 }
 `;
 
 document.head.appendChild(arOverlayStyles);
 
 // Add event listener to close button
 const closeButton = document.getElementById('closeARView');
 if (closeButton) {
 closeButton.addEventListener('click', () => {
 session.end();
 });
 }
 
 // Handle session end
 session.addEventListener('end', () => {
 if (document.body.contains(overlay)) {
 document.body.removeChild(overlay);
 }
 
 if (document.head.contains(arOverlayStyles)) {
 document.head.removeChild(arOverlayStyles);
 }
 });
 
 // Initialize AR rendering
 // Note: In a real implementation, this would include WebGL setup
 // and 3D model rendering using Three.js or similar
 console.log('AR session started for location:', location.name);
 } catch (error) {
 console.error('Error starting AR session:', error);
 showErrorMessage('Could not start AR view', 3000);
 }
 }
 }
 }

// Initialize AR features if supported
 initAugmentedReality();

// Add support for social sharing
 function initSocialSharing() {
 // Create share button
 const shareButton = document.createElement('button');
 shareButton.id = 'shareButton';
 shareButton.className = 'share-button';
 shareButton.innerHTML = '<i class="fas fa-share-alt"></i>';
 shareButton.setAttribute('aria-label', 'Share this tour');
 shareButton.setAttribute('title', 'Share this tour');
 
 // Add share button to body
 document.body.appendChild(shareButton);
 
 // Add share button styles
 const shareButtonStyles = document.createElement('style');
 shareButtonStyles.textContent = `
 .share-button {
 position: fixed;
 bottom: 400px;
 right: 20px;
 width: 40px;
 height: 40px;
 border-radius: 50%;
 background-color: var(--bg-color);
 color: var(--primary-color);
 border: none;
 box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
 display: flex;
 align-items: center;
 justify-content: center;
 cursor: pointer;
 z-index: 1000;
 }
 
 /* Support for iOS devices with notches */
 @supports (padding-bottom: env(safe-area-inset-bottom)) {
 .share-button {
 bottom: calc(400px + env(safe-area-inset-bottom, 0px));
 right: calc(20px + env(safe-area-inset-right, 0px));
 }
 }
 `;
 
 document.head.appendChild(shareButtonStyles);
 
 // Add event listener
 shareButton.addEventListener('click', () => {
 // Show share options
 showShareOptions();
 });
 
 // Show share options
 function showShareOptions() {
 // Create share modal
 let shareModal = document.getElementById('shareModal');
 
 if (!shareModal) {
 shareModal = document.createElement('div');
 shareModal.id = 'shareModal';
 shareModal.className = 'share-modal';
 shareModal.innerHTML = `
 <div class="share-modal-content">
 <div class="share-modal-header">
 <h3>Share This Tour</h3>
 <button id="closeShareModal" aria-label="Close share options">
 <i class="fas fa-times"></i>
 </button>
 </div>
 <div class="share-modal-body">
 <p>Share the Minnesota Then Museum Without Walls tour with others:</p>
 <div class="share-options">
 <button id="shareLink" class="share-option">
 <i class="fas fa-link"></i>
 <span>Copy Link</span>
 </button>
 <button id="shareTwitter" class="share-option">
 <i class="fab fa-twitter"></i>
 <span>Twitter</span>
 </button>
 <button id="shareFacebook" class="share-option">
 <i class="fab fa-facebook"></i>
 <span>Facebook</span>
 </button>
 <button id="shareEmail" class="share-option">
 <i class="fas fa-envelope"></i>
 <span>Email</span>
 </button>
 </div>
 <div class="share-qr-code">
 <p>Or scan this QR code:</p>
 <div id="qrCodeContainer" class="qr-code-container"></div>
 </div>
 </div>
 </div>
 `;
 
 document.body.appendChild(shareModal);
 
 // Add event listeners
 const closeButton = document.getElementById('closeShareModal');
 if (closeButton) {
 closeButton.addEventListener('click', () => {
 shareModal.classList.remove('show');
 });
 }
 
 // Copy link
 const linkButton = document.getElementById('shareLink');
 if (linkButton) {
 linkButton.addEventListener('click', () => {
 // Copy URL to clipboard
 const textarea = document.createElement('textarea');
 textarea.value = window.location.href;
 document.body.appendChild(textarea);
 textarea.select();
 document.execCommand('copy');
 document.body.removeChild(textarea);
 
 showErrorMessage('Link copied to clipboard', 3000);
 });
 }
 
 // Share on Twitter
 const twitterButton = document.getElementById('shareTwitter');
 if (twitterButton) {
 twitterButton.addEventListener('click', () => {
 const text = 'Check out the Minnesota Then Museum Without Walls tour!';
 const url = window.location.href;
 const twitterUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}&url=${encodeURIComponent(url)}`;
 window.open(twitterUrl, '_blank');
 });
 }
 
 // Share on Facebook
 const facebookButton = document.getElementById('shareFacebook');
 if (facebookButton) {
 facebookButton.addEventListener('click', () => {
 const url = window.location.href;
 const facebookUrl = `https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(url)}`;
 window.open(facebookUrl, '_blank');
 });
 }
 
 // Share via Email
 const emailButton = document.getElementById('shareEmail');
 if (emailButton) {
 emailButton.addEventListener('click', () => {
 const subject = 'Minnesota Then Museum Without Walls Tour';
 const body = `Check out the Minnesota Then Museum Without Walls tour: ${window.location.href}`;
 const mailtoUrl = `mailto:?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;
 window.location.href = mailtoUrl;
 });
 }
 
 // Generate QR code
 const qrContainer = document.getElementById('qrCodeContainer');
 if (qrContainer) {
 // In a real app, this would use a QR code library
 // For now, just show a placeholder
 qrContainer.innerHTML = `
 <div class="qr-placeholder">
 <p>QR Code for:<br>${window.location.href}</p>
 </div>
 `;
 }
 
 // Add share modal styles
 const shareModalStyles = document.createElement('style');
 shareModalStyles.textContent = `
 .share-modal {
 position: fixed;
 top: 0;
 left: 0;
 width: 100%;
 height: 100%;
 background-color: rgba(0, 0, 0, 0.7);
 display: flex;
 align-items: center;
 justify-content: center;
 z-index: 2000;
 opacity: 0;
 visibility: hidden;
 transition: opacity 0.3s ease, visibility 0.3s ease;
 }
 
 .share-modal.show {
 opacity: 1;
 visibility: visible;
 }
 
 .share-modal-content {
 background-color: white;
 border-radius: 8px;
 width: 90%;
 max-width: 400px;
 overflow: hidden;
 }
 
 .share-modal-header {
 display: flex;
 justify-content: space-between;
 align-items: center;
 padding: 16px;
 border-bottom: 1px solid #eee;
 }
 
 .share-modal-header h3 {
 margin: 0;
 font-size: 18px;
 color: #333;
 }
 
 .share-modal-header button {
 background: none;
 border: none;
 color: #666;
 cursor: pointer;
 font-size: 16px;
 }
 
 .share-modal-body {
 padding: 16px;
 }
 
 .share-modal-body p {
 margin: 0 0 16px 0;
 font-size: 14px;
 color: #333;
 }
 
 .share-options {
 display: grid;
 grid-template-columns: repeat(2, 1fr);
 gap: 12px;
 margin-bottom: 20px;
 }
 
 .share-option {
 display: flex;
 flex-direction: column;
 align-items: center;
 justify-content: center;
 padding: 12px;
 border: 1px solid #eee;
 border-radius: 8px;
 background-color: #f9f9f9;
 cursor: pointer;
 transition: background-color 0.2s ease;
 }
 
 .share-option:hover {
 background-color: #f0f0f0;
 }
 
 .share-option i {
 font-size: 24px;
 margin-bottom: 8px;
 color: var(--primary-color);
 }
 
 .share-option span {
 font-size: 12px;
 color: #333;
 }
 
 .share-qr-code {
 text-align: center;
 margin-top: 20px;
 }
 
 .qr-code-container {
 width: 150px;
 height: 150px;
 margin: 0 auto;
 border: 1px solid #eee;
 display: flex;
 align-items: center;
 justify-content: center;
 }
 
 .qr-placeholder {
 width: 100%;
 height: 100%;
 display: flex;
 align-items: center;
 justify-content: center;
 background-color: #f9f9f9;
 font-size: 12px;
 text-align: center;
 color: #666;
 padding: 10px;
 }
 
 /* Support for iOS devices with notches */
 @supports (padding-bottom: env(safe-area-inset-bottom)) {
 .share-modal-content {
 margin-bottom: env(safe-area-inset-bottom, 0px);
 }
 }
 `;
 
 document.head.appendChild(shareModalStyles);
 }
 
 // Show modal with animation
 shareModal.classList.add('show');
 }
 
 // Use Web Share API if available
 if (navigator.share) {
 shareButton.addEventListener('click', async () => {
 try {
 await navigator.share({
 title: 'Minnesota Then Museum Without Walls Tour',
 text: 'Explore historical locations around Minnesota with this self-guided tour.',
 url: window.location.href
 });
 console.log('Successfully shared');
 } catch (error) {
 console.error('Error sharing:', error);
 // Fall back to custom share modal
 showShareOptions();
 }
 });
 }
 }

// Initialize social sharing
 initSocialSharing();

// Add support for user preferences
 function initUserPreferences() {
 // Default preferences
 const defaultPreferences = {
 notificationsEnabled: true,
 autoPlayAudio: true,
 distanceUnit: 'metric', // 'metric' or 'imperial'
 mapZoomLevel: 15,
 fontSizeAdjustment: 0, // -2 to +2
 vibrationEnabled: true,
 autoRotateMap: true
 };
 
 // Load preferences
 function loadPreferences() {
 try {
 const saved = localStorage.getItem('userPreferences');
 return saved ? { ...defaultPreferences, ...JSON.parse(saved) } : defaultPreferences;
 } catch (e) {
 console.warn('Could not load user preferences', e);
 return defaultPreferences;
 }
 }
 
 // Save preferences
 function savePreferences(preferences) {
 try {
 localStorage.setItem('userPreferences', JSON.stringify(preferences));
 } catch (e) {
 console.warn('Could not save user preferences', e);
 }
 }
 
 // Get current preferences
 const preferences = loadPreferences();
 
 // Create preferences button
 const preferencesButton = document.createElement('button');
 preferencesButton.id = 'preferencesButton';
 preferencesButton.className = 'preferences-button';
 preferencesButton.innerHTML = '<i class="fas fa-cog"></i>';
 preferencesButton.setAttribute('aria-label', 'User preferences');
 preferencesButton.setAttribute('title', 'User preferences');
 
 // Add preferences button to body
 document.body.appendChild(preferencesButton);
 
 // Add preferences button styles
 const preferencesButtonStyles = document.createElement('style');
 preferencesButtonStyles.textContent = `
 .preferences-button {
 position: fixed;
 bottom: 450px;
 right: 20px;
 width: 40px;
 height: 40px;
 border-radius: 50%;
 background-color: var(--bg-color);
 color: var(--primary-color);
 border: none;
 box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
 display: flex;
 align-items: center;
 justify-content: center;
 cursor: pointer;
 z-index: 1000;
 }
 
 /* Support for iOS devices with notches */
 @supports (padding-bottom: env(safe-area-inset-bottom)) {
 .preferences-button {
 bottom: calc(450px + env(safe-area-inset-bottom, 0px));
 right: calc(20px + env(safe-area-inset-right, 0px));
 }
 }
 `;
 
 document.head.appendChild(preferencesButtonStyles);
 
 // Add event listener
 preferencesButton.addEventListener('click', () => {
 // Show preferences modal
 showPreferencesModal();
 });
 
 // Show preferences modal
 function showPreferencesModal() {
 // Create preferences modal
 let preferencesModal = document.getElementById('preferencesModal');
 
 if (!preferencesModal) {
 preferencesModal = document.createElement('div');
 preferencesModal.id = 'preferencesModal';
 preferencesModal.className = 'preferences-modal';
 preferencesModal.innerHTML = `
 <div class="preferences-modal-content">
 <div class="preferences-modal-header">
 <h3>User Preferences</h3>
 <button id="closePreferencesModal" aria-label="Close preferences">
 <i class="fas fa-times"></i>
 </button>
 </div>
 <div class="preferences-modal-body">
 <div class="preference-item">
 <label for="notificationsToggle">Enable Notifications</label>
 <div class="toggle-switch">
 <input type="checkbox" id="notificationsToggle" ${preferences.notificationsEnabled ? 'checked' : ''}>
 <span class="toggle-slider"></span>
 </div>
 </div>
 <div class="preference-item">
 <label for="autoPlayToggle">Auto-Play Audio</label>
 <div class="toggle-switch">
 <input type="checkbox" id="autoPlayToggle" ${preferences.autoPlayAudio ? 'checked' : ''}>
 <span class="toggle-slider"></span>
 </div>
 </div>
 <div class="preference-item">
 <label for="distanceUnitSelect">Distance Unit</label>
 <select id="distanceUnitSelect">
 <option value="metric" ${preferences.distanceUnit === 'metric' ? 'selected' : ''}>Metric (meters/km)</option>
 <option value="imperial" ${preferences.distanceUnit === 'imperial' ? 'selected' : ''}>Imperial (feet/miles)</option>
 </select>
 </div>
 <div class="preference-item">
 <label for="mapZoomSelect">Default Map Zoom</label>
 <select id="mapZoomSelect">
 <option value="13" ${preferences.mapZoomLevel === 13 ? 'selected' : ''}>Far</option>
 <option value="15" ${preferences.mapZoomLevel === 15 ? 'selected' : ''}>Medium</option>
 <option value="17" ${preferences.mapZoomLevel === 17 ? 'selected' : ''}>Close</option>
 </select>
 </div>
 <div class="preference-item">
 <label for="fontSizeRange">Font Size Adjustment</label>
 <input type="range" id="fontSizeRange" min="-2" max="2" step="1" value="${preferences.fontSizeAdjustment}">
 <div class="range-labels">
 <span>Smaller</span>
 <span>Default</span>
 <span>Larger</span>
 </div>
 </div>
 <div class="preference-item">
 <label for="vibrationToggle">Enable Vibration</label>
 <div class="toggle-switch">
 <input type="checkbox" id="vibrationToggle" ${preferences.vibrationEnabled ? 'checked' : ''}>
 <span class="toggle-slider"></span>
 </div>
 </div>
 <div class="preference-item">
 <label for="autoRotateToggle">Auto-Rotate Map</label>
 <div class="toggle-switch">
 <input type="checkbox" id="autoRotateToggle" ${preferences.autoRotateMap ? 'checked' : ''}>
 <span class="toggle-slider"></span>
 </div>
 </div>
 </div>
 <div class="preferences-modal-footer">
 <button id="resetPreferences">Reset to Default</button>
 <button id="savePreferences">Save Preferences</button>
 </div>
 </div>
 `;
 
 document.body.appendChild(preferencesModal);
 
 // Add event listeners
 const closeButton = document.getElementById('closePreferencesModal');
 if (closeButton) {
 closeButton.addEventListener('click', () => {
 preferencesModal.classList.remove('show');
 });
 }
 
 // Reset preferences
 const resetButton = document.getElementById('resetPreferences');
 if (resetButton) {
 resetButton.addEventListener('click', () => {
 // Show confirmation
 showPopup('Reset Preferences', 'Are you sure you want to reset all preferences to default?', 'confirm', () => {
 // Reset to default
 savePreferences(defaultPreferences);
 
 // Update UI
 document.getElementById('notificationsToggle').checked = defaultPreferences.notificationsEnabled;
 document.getElementById('autoPlayToggle').checked = defaultPreferences.autoPlayAudio;
 document.getElementById('distanceUnitSelect').value = defaultPreferences.distanceUnit;
 document.getElementById('mapZoomSelect').value = defaultPreferences.mapZoomLevel;
 document.getElementById('fontSizeRange').value = defaultPreferences.fontSizeAdjustment;
 document.getElementById('vibrationToggle').checked = defaultPreferences.vibrationEnabled;
 document.getElementById('autoRotateToggle').checked = defaultPreferences.autoRotateMap;
 
 // Apply preferences
 applyPreferences(defaultPreferences);
 
 showErrorMessage('Preferences reset to default', 3000);
 });
 });
 }
 
 // Save preferences
 const saveButton = document.getElementById('savePreferences');
 if (saveButton) {
 saveButton.addEventListener('click', () => {
 // Get values
 const newPreferences = {
 notificationsEnabled: document.getElementById('notificationsToggle').checked,
 autoPlayAudio: document.getElementById('autoPlayToggle').checked,
 distanceUnit: document.getElementById('distanceUnitSelect').value,
 mapZoomLevel: parseInt(document.getElementById('mapZoomSelect').value),
 fontSizeAdjustment: parseInt(document.getElementById('fontSizeRange').value),
 vibrationEnabled: document.getElementById('vibrationToggle').checked,
 autoRotateMap: document.getElementById('autoRotateToggle').checked
 };
 
 // Save preferences
 savePreferences(newPreferences);
 
 // Apply preferences
 applyPreferences(newPreferences);
 
 // Close modal
 preferencesModal.classList.remove('show');
 
 showErrorMessage('Preferences saved', 3000);
 });
 }
 
 // Add preferences modal styles
 const preferencesModalStyles = document.createElement('style');
 preferencesModalStyles.textContent = `
 .preferences-modal {
 position: fixed;
 top: 0;
 left: 0;
 width: 100%;
 height: 100%;
 background-color: rgba(0, 0, 0, 0.7);
 display: flex;
 align-items: center;
 justify-content: center;
 z-index: 2000;
 opacity: 0;
 visibility: hidden;
 transition: opacity 0.3s ease, visibility 0.3s ease;
 }
 
 .preferences-modal.show {
 opacity: 1;
 visibility: visible;
 }
 
 .preferences-modal-content {
 background-color: white;
 border-radius: 8px;
 width: 90%;
 max-width: 400px;
 max-height: 90vh;
 overflow-y: auto;
 }
 
 .preferences-modal-header {
 display: flex;
 justify-content: space-between;
 align-items: center;
 padding: 16px;
 border-bottom: 1px solid #eee;
 position: sticky;
 top: 0;
 background-color: white;
 z-index: 1;
 }
 
 .preferences-modal-header h3 {
 margin: 0;
 font-size: 18px;
 color: #333;
 }
 
 .preferences-modal-header button {
 background: none;
 border: none;
 color: #666;
 cursor: pointer;
 font-size: 16px;
 }
 
 .preferences-modal-body {
 padding: 16px;
 }
 
 .preference-item {
 margin-bottom: 16px;
 padding-bottom: 16px;
 border-bottom: 1px solid #eee;
 }
 
 .preference-item:last-child {
 margin-bottom: 0;
 padding-bottom: 0;
 border-bottom: none;
 }
 
 .preference-item label {
 display: block;
 margin-bottom: 8px;
 font-size: 14px;
 color: #333;
 }
 
 .preference-item select {
 width: 100%;
 padding: 10px;
 border: 1px solid #ddd;
 border-radius: 4px;
 font-size: 14px;
 background-color: white;
 }
 
 .toggle-switch {
 position: relative;
 display: inline-block;
 width: 50px;
 height: 24px;
 }
 
 .toggle-switch input {
 opacity: 0;
 width: 0;
 height: 0;
 }
 
 .toggle-slider {
 position: absolute;
 cursor: pointer;
 top: 0;
 left: 0;
 right: 0;
 bottom: 0;
 background-color: #ccc;
 transition: .4s;
 border-radius: 24px;
 }
 
 .toggle-slider:before {
 position: absolute;
 content: "";
 height: 16px;
 width: 16px;
 left: 4px;
 bottom: 4px;
 background-color: white;
 transition: .4s;
 border-radius: 50%;
 }
 
 input:checked + .toggle-slider {
 background-color: var(--primary-color);
 }
 
 input:checked + .toggle-slider:before {
 transform: translateX(26px);
 }
 
 input[type="range"] {
 width: 100%;
 margin: 10px 0;
 }
 
 .range-labels {
 display: flex;
 justify-content: space-between;
 font-size: 12px;
 color: #666;
 }
 
 .preferences-modal-footer {
 display: flex;
 justify-content: space-between;
 padding: 16px;
 border-top: 1px solid #eee;
 position: sticky;
 bottom: 0;
 background-color: white;
 z-index: 1;
 }
 
 .preferences-modal-footer button {
 padding: 10px 16px;
 border: none;
 border-radius: 4px;
 font-size: 14px;
 font-weight: 500;
 cursor: pointer;
 transition: background-color 0.2s ease;
 }
 
 #resetPreferences {
 background-color: #f2f2f2;
 color: #333;
 }
 
 #savePreferences {
 background-color: var(--primary-color);
 color: white;
 }
 
 /* Support for iOS devices with notches */
 @supports (padding-bottom: env(safe-area-inset-bottom)) {
 .preferences-modal-content {
 margin-bottom: env(safe-area-inset-bottom, 0px);
 }
 }
 `;
 
 document.head.appendChild(preferencesModalStyles);
 }
 
 // Show modal with animation
 preferencesModal.classList.add('show');
 }
 
 // Apply preferences
 function applyPreferences(prefs) {
 // Apply distance unit
 window.distanceUnit = prefs.distanceUnit;
 
 // Apply font size adjustment
 document.documentElement.style.setProperty('--font-size-adjustment', `${prefs.fontSizeAdjustment * 0.125}rem`);
 
 // Apply map zoom level
 if (map && map.getZoom() !== prefs.mapZoomLevel) {
 map.setZoom(prefs.mapZoomLevel);
 }
 
 // Apply auto-rotate map
 if (map) {
 map.options.rotate = prefs.autoRotateMap;
 }
 
 // Apply vibration setting
 window.vibrationEnabled = prefs.vibrationEnabled;
 
 // Apply auto-play audio
 window.autoPlayAudio = prefs.autoPlayAudio;
 
 // Apply notifications
 window.notificationsEnabled = prefs.notificationsEnabled;
 }
 
 // Add font size adjustment CSS
 const fontSizeStyles = document.createElement('style');
 fontSizeStyles.textContent = `
 :root {
 --font-size-adjustment: 0rem;
 }
 
 body {
 font-size: calc(1rem + var(--font-size-adjustment));
 }
 
 .popup-title, .marker-popup-title, h1, h2, h3 {
 font-size: calc(1.5rem + var(--font-size-adjustment));
 }
 
 .popup-message, .marker-popup-description, p {
 font-size: calc(1rem + var(--font-size-adjustment));
 }
 
 button, .map-button {
 font-size: calc(0.875rem + var(--font-size-adjustment));
 }
 `;
 
 document.head.appendChild(fontSizeStyles);
 
 // Apply initial preferences
 applyPreferences(preferences);
 
 // Make preferences functions available globally
 window.loadPreferences = loadPreferences;
 window.savePreferences = savePreferences;
 window.applyPreferences = applyPreferences;
 window.showPreferencesModal = showPreferencesModal;
 }

// Initialize user preferences
 initUserPreferences();

// Add support for tour reset
 function initTourReset() {
 // Create reset button
 const resetButton = document.createElement('button');
 resetButton.id = 'resetTourButton';
 resetButton.className = 'reset-tour-button';
 resetButton.innerHTML = '<i class="fas fa-redo-alt"></i>';
 resetButton.setAttribute('aria-label', 'Reset tour');
 resetButton.setAttribute('title', 'Reset tour');
 
 // Add reset button to body
 document.body.appendChild(resetButton);
 
 // Add reset button styles
 const resetButtonStyles = document.createElement('style');
 resetButtonStyles.textContent = `
 .reset-tour-button {
 position: fixed;
 bottom: 500px;
 right: 20px;
 width: 40px;
 height: 40px;
 border-radius: 50%;
 background-color: #f44336;
 color: white;
 border: none;
 box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
 display: flex;
 align-items: center;
 justify-content: center;
 cursor: pointer;
 z-index: 1000;
 }
 
 /* Support for iOS devices with notches */
 @supports (padding-bottom: env(safe-area-inset-bottom)) {
 .reset-tour-button {
 bottom: calc(500px + env(safe-area-inset-bottom, 0px));
 right: calc(20px + env(safe-area-inset-right, 0px));
 }
 }
 `;
 
 document.head.appendChild(resetButtonStyles);
 
 // Add event listener
 resetButton.addEventListener('click', () => {
 // Show confirmation
 showPopup('Reset Tour', 'Are you sure you want to reset the tour? This will clear all your progress and visited locations.', 'confirm', () => {
 // Reset tour data
 resetTourData();
 });
 });
 
 // Reset tour data
 function resetTourData() {
 // Clear visited locations
 visitedLocations = [];
 localStorage.removeItem('visitedLocations');
 
 // Reset current location
 currentLocationIndex = 0;
 localStorage.setItem('currentLocationIndex', '0');
 
 // Clear statistics
 localStorage.removeItem('tourStatistics');
 
 // Clear achievements
 localStorage.removeItem('earnedAchievements');
 
 // Reset tour start time
 localStorage.setItem('tourStartTime', new Date().toISOString());
 
 // Remove tour completion time
 localStorage.removeItem('tourCompletionTime');
 
 // Update map markers
 updateLocationMarkers();
 
 // Show success message
 showPopup('Tour Reset', 'Your tour has been reset. All progress has been cleared.', 'alert');
 
 // Reload page to ensure clean state
 setTimeout(() => {
 window.location.reload();
 }, 2000);
 }
 }

// Initialize tour reset
 initTourReset();

// Add support for debug mode
 function initDebugMode() {
 // Check if debug mode is enabled
 const isDebugMode = localStorage.getItem('debugMode') === 'true';
 
 // Create debug button (hidden by default)
 const debugButton = document.createElement('button');
 debugButton.id = 'debugButton';
 debugButton.className = 'debug-button';
 debugButton.innerHTML = '<i class="fas fa-bug"></i>';
 debugButton.setAttribute('aria-label', 'Debug mode');
 debugButton.setAttribute('title', 'Debug mode');
 debugButton.style.display = isDebugMode ? 'flex' : 'none';
 
 // Add debug button to body
 document.body.appendChild(debugButton);
 
 // Add debug button styles
 const debugButtonStyles = document.createElement('style');
 debugButtonStyles.textContent = `
 .debug-button {
 position: fixed;
 bottom: 550px;
 right: 20px;
 width: 40px;
 height: 40px;
 border-radius: 50%;
 background-color: #ff9800;
 color: white;
 border: none;
 box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
 display: flex;
 align-items: center;
 justify-content: center;
 cursor: pointer;
 z-index: 1000;
 }
 
 /* Support for iOS devices with notches */
 @supports (padding-bottom: env(safe-area-inset-bottom)) {
 .debug-button {
 bottom: calc(550px + env(safe-area-inset-bottom, 0px));
 right: calc(20px + env(safe-area-inset-right, 0px));
 }
 }
 
 .debug-panel {
 position: fixed;
 top: 0;
 right: 0;
 width: 300px;
 height: 100%;
 background-color: rgba(0, 0, 0, 0.9);
 color: #00ff00;
 font-family: monospace;
 padding: 20px;
 overflow-y: auto;
 z-index: 3000;
 transform: translateX(100%);
 transition: transform 0.3s ease;
 }
 
 .debug-panel.show {
 transform: translateX(0);
 }
 
 .debug-panel h3 {
 color: white;
 margin-top: 0;
 border-bottom: 1px solid #333;
 padding-bottom: 10px;
 }
 
 .debug-section {
 margin-bottom: 20px;
 }
 
 .debug-section h4 {
 color: #ff9800;
 margin: 0 0 10px 0;
 }
 
 .debug-item {
 margin-bottom: 5px;
 font-size: 12px;
 word-break: break-all;
 }
 
 .debug-actions {
 display: flex;
 flex-wrap: wrap;
 gap: 10px;
 margin-top: 20px;
 }
 
 .debug-action {
 background-color: #333;
 color: white;
 border: none;
 padding: 8px 12px;
 border-radius: 4px;
 cursor: pointer;
 font-size: 12px;
 font-family: monospace;
 }
 
 .debug-action:hover {
 background-color: #444;
 }
 
 /* Support for iOS devices with notches */
 @supports (padding-top: env(safe-area-inset-top)) {
 .debug-panel {
 padding-top: calc(20px + env(safe-area-inset-top, 0px));
 padding-right: calc(20px + env(safe-area-inset-right, 0px));
 }
 }
 `;
 
 document.head.appendChild(debugButtonStyles);
 
 // Add event listener
 debugButton.addEventListener('click', () => {
 // Toggle debug panel
 toggleDebugPanel();
 });
 
 // Create debug panel
 let debugPanel = document.getElementById('debugPanel');
 
 if (!debugPanel) {
 debugPanel = document.createElement('div');
 debugPanel.id = 'debugPanel';
 debugPanel.className = 'debug-panel';
 document.body.appendChild(debugPanel);
 }
 
 // Toggle debug panel
 function toggleDebugPanel() {
 debugPanel.classList.toggle('show');
 
 // Update debug info if panel is shown
 if (debugPanel.classList.contains('show')) {
 updateDebugInfo();
 }
 }
 
 // Update debug info
 function updateDebugInfo() {
 // Get debug info
 const info = {
 device: {
 userAgent: navigator.userAgent,
 screenSize: `${window.innerWidth}x${window.innerHeight}`,
 pixelRatio: window.devicePixelRatio,
 orientation: window.orientation || 'N/A'
 },
 location: {
 current: lastPosition ? `${lastPosition.lat.toFixed(6)}, ${lastPosition.lng.toFixed(6)}` : 'Unknown',
 accuracy: lastPosition ? `${lastPosition.accuracy.toFixed(2)}m` : 'Unknown',
 heading: lastPosition && lastPosition.heading ? `${lastPosition.heading.toFixed(2)}°` : 'Unknown',
 speed: lastPosition && lastPosition.speed ? `${lastPosition.speed.toFixed(2)}m/s` : 'Unknown',
 timestamp: lastPosition ? new Date(lastPosition.timestamp).toISOString() : 'Unknown'
 },
 tour: {
 currentLocation: currentLocationIndex,
 visitedLocations: visitedLocations.length,
 totalLocations: gameLocations.length,
 startTime: localStorage.getItem('tourStartTime') || 'Unknown',
 completionTime: localStorage.getItem('tourCompletionTime') || 'Not completed'
 },
 storage: {
 localStorageUsed: calculateStorageUsage(),
 localStorageLimit: '5MB (estimated)',
 cacheStorageAvailable: 'caches' in window
 },
 performance: {
 memory: window.performance && window.performance.memory ? 
 `${Math.round(window.performance.memory.usedJSHeapSize / 1048576)}MB / ${Math.round(window.performance.memory.jsHeapSizeLimit / 1048576)}MB` : 
 'Not available',
 loadTime: `${window.performance.timing.loadEventEnd - window.performance.timing.navigationStart}ms`,
 networkType: navigator.connection ? navigator.connection.effectiveType : 'Unknown'
 }
 };
 
 // Create debug panel content
 let content = `
 <h3>Debug Panel</h3>
 
 <div class="debug-section">
 <h4>Device Info</h4>
 <div class="debug-item">User Agent: ${info.device.userAgent}</div>
 <div class="debug-item">Screen Size: ${info.device.screenSize}</div>
 <div class="debug-item">Pixel Ratio: ${info.device.pixelRatio}</div>
 <div class="debug-item">Orientation: ${info.device.orientation}</div>
 </div>
 
 <div class="debug-section">
 <h4>Location Info</h4>
 <div class="debug-item">Current: ${info.location.current}</div>
 <div class="debug-item">Accuracy: ${info.location.accuracy}</div>
 <div class="debug-item">Heading: ${info.location.heading}</div>
 <div class="debug-item">Speed: ${info.location.speed}</div>
 <div class="debug-item">Timestamp: ${info.location.timestamp}</div>
 </div>
 
 <div class="debug-section">
 <h4>Tour Info</h4>
 <div class="debug-item">Current Location: ${info.tour.currentLocation}</div>
 <div class="debug-item">Visited Locations: ${info.tour.visitedLocations}/${info.tour.totalLocations}</div>
 <div class="debug-item">Start Time: ${info.tour.startTime}</div>
 <div class="debug-item">Completion Time: ${info.tour.completionTime}</div>
 </div>
 
 <div class="debug-section">
 <h4>Storage Info</h4>
 <div class="debug-item">LocalStorage Used: ${info.storage.localStorageUsed}</div>
 <div class="debug-item">LocalStorage Limit: ${info.storage.localStorageLimit}</div>
 <div class="debug-item">Cache Storage: ${info.storage.cacheStorageAvailable ? 'Available' : 'Not available'}</div>
 </div>
 
 <div class="debug-section">
 <h4>Performance Info</h4>
 <div class="debug-item">Memory: ${info.performance.memory}</div>
 <div class="debug-item">Load Time: ${info.performance.loadTime}</div>
 <div class="debug-item">Network Type: ${info.performance.networkType}</div>
 </div>
 
 <div class="debug-actions">
 <button class="debug-action" id="debugTeleport">Teleport to Next Location</button>
 <button class="debug-action" id="debugCompleteAll">Complete All Locations</button>
 <button class="debug-action" id="debugClearStorage">Clear All Storage</button>
 <button class="debug-action" id="debugToggleDebugMode">Disable Debug Mode</button>
 </div>
 `;
 
 // Set debug panel content
 debugPanel.innerHTML = content;
 
 // Add event listeners to debug actions
 document.getElementById('debugTeleport').addEventListener('click', () => {
 // Teleport to next location
 const nextIndex = (currentLocationIndex + 1) % gameLocations.length;
 const nextLocation = gameLocations[nextIndex];
 
 // Update user position
 lastPosition = {
 lat: nextLocation.lat,
 lng: nextLocation.lng,
 accuracy: 10,
 heading: 0,
 speed: 0,
 timestamp: Date.now()
 };
 
 // Update map
 if (map && userMarker) {
 userMarker.setLatLng([nextLocation.lat, nextLocation.lng]);
 map.setView([nextLocation.lat, nextLocation.lng], 17);
 }
 
 // Update distance
 updateDistance();
 
 showErrorMessage(`Teleported to ${nextLocation.name}`, 3000);
 });
 
 document.getElementById('debugCompleteAll').addEventListener('click', () => {
 // Complete all locations
 visitedLocations = gameLocations.map((_, index) => index);
 localStorage.setItem('visitedLocations', JSON.stringify(visitedLocations));
 
 // Update map markers
 updateLocationMarkers();
 
 // Set completion time
 localStorage.setItem('tourCompletionTime', new Date().toISOString());
 
 showErrorMessage('All locations marked as visited', 3000);
 
 // Update debug info
 updateDebugInfo();
 });
 
 document.getElementById('debugClearStorage').addEventListener('click', () => {
 // Clear all storage
 localStorage.clear();
 
 // Clear caches if available
 if ('caches' in window) {
 caches.keys().then(keyList => {
 return Promise.all(keyList.map(key => {
 return caches.delete(key);
 }));
 });
 }
 
 showErrorMessage('All storage cleared', 3000);
 
 // Update debug info
 updateDebugInfo();
 });
 
 document.getElementById('debugToggleDebugMode').addEventListener('click', () => {
 // Toggle debug mode
 const newMode = localStorage.getItem('debugMode') !== 'true';
 localStorage.setItem('debugMode', newMode.toString());
 
 // Update button text
 document.getElementById('debugToggleDebugMode').textContent = newMode ? 'Disable Debug Mode' : 'Enable Debug Mode';
 
 showErrorMessage(`Debug mode ${newMode ? 'enabled' : 'disabled'}`, 3000);
 
 // Hide debug button if debug mode is disabled
 debugButton.style.display = newMode ? 'flex' : 'none';
 
 // Hide debug panel if debug mode is disabled
 if (!newMode) {
 debugPanel.classList.remove('show');
 }
 });
 }
 
 // Calculate storage usage
 function calculateStorageUsage() {
 let total = 0;
 
 for (let i = 0; i < localStorage.length; i++) {
 const key = localStorage.key(i);
 const value = localStorage.getItem(key);
 
 total += key.length + value.length;
 }
 
 // Convert to KB
 const kb = total / 1024;
 
 if (kb < 1024) {
 return `${kb.toFixed(2)} KB`;
 } else {
 return `${(kb / 1024).toFixed(2)} MB`;
 }
 }
 
 // Enable debug mode with secret gesture
 let tapCount = 0;
 let lastTapTime = 0;
 
 document.addEventListener('touchstart', event => {
 const currentTime = new Date().getTime();
 const tapLength = currentTime - lastTapTime;
 
 // Reset tap count if too much time has passed
 if (tapLength > 500) {
 tapCount = 0;
 }
 
 // Increment tap count
 tapCount++;
 lastTapTime = currentTime;
 
 // Check for 5 rapid taps
 if (tapCount === 5) {
 // Toggle debug mode
 const newMode = localStorage.getItem('debugMode') !== 'true';
 localStorage.setItem('debugMode', newMode.toString());
 
 // Show debug button
 debugButton.style.display = newMode ? 'flex' : 'none';
 
 showErrorMessage(`Debug mode ${newMode ? 'enabled' : 'disabled'}`, 3000);
 
 // Reset tap count
 tapCount = 0;
 }
 });
 
 // Update debug info periodically if panel is shown
 setInterval(() => {
 if (debugPanel.classList.contains('show')) {
 updateDebugInfo();
 }
 }, 5000);
 }

// Initialize debug mode
 initDebugMode();

// Final cleanup and optimization
 (function() {
 // Organize all floating buttons
 const floatingButtons = [
 'accessibilityButton',
 'feedbackButton',
 'statisticsButton',
 'themeButton',
 'tourButton',
 'cacheButton',
 'arButton',
 'shareButton',
 'preferencesButton',
 'resetTourButton',
 'debugButton'
 ];
 
 // Adjust button positions based on which ones are visible
 function organizeButtons() {
 let visibleButtons = 0;
 
 floatingButtons.forEach(buttonId => {
 const button = document.getElementById(buttonId);
 
 if (button && button.style.display !== 'none') {
 visibleButtons++;
 }
 });
 
 // Limit number of visible buttons
 if (visibleButtons > 6) {
 // Create more menu button
 let moreButton = document.getElementById('moreButton');
 
 if (!moreButton) {
 moreButton = document.createElement('button');
 moreButton.id = 'moreButton';
 moreButton.className = 'more-button';
 moreButton.innerHTML = '<i class="fas fa-ellipsis-v"></i>';
 moreButton.setAttribute('aria-label', 'More options');
 moreButton.setAttribute('title', 'More options');
 
 document.body.appendChild(moreButton);
 
 // Add more button styles
 const moreButtonStyles = document.createElement('style');
 moreButtonStyles.textContent = `
 .more-button {
 position: fixed;
 bottom: 20px;
 right: 20px;
 width: 50px;
 height: 50px;
 border-radius: 50%;
 background-color: var(--primary-color);
 color: white;
 border: none;
 box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
 display: flex;
 align-items: center;
 justify-content: center;
 cursor: pointer;
 z-index: 1001;
 font-size: 20px;
 }
 
 /* Support for iOS devices with notches */
 @supports (padding-bottom: env(safe-area-inset-bottom)) {
 .more-button {
 bottom: calc(20px + env(safe-area-inset-bottom, 0px));
 right: calc(20px + env(safe-area-inset-right, 0px));
 }
 }
 
 .more-menu {
 position: fixed;
 bottom: 80px;
 right: 20px;
 background-color: white;
 border-radius: 8px;
 box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
 padding: 8px;
 z-index: 1001;
 display: none;
 }
 
 .more-menu.show {
 display: block;
 }
 
 .more-menu-item {
 display: flex;
 align-items: center;
 padding: 12px;
 cursor: pointer;
 border-radius: 4px;
 transition: background-color 0.2s ease;
 }
 
 .more-menu-item:hover {
 background-color: #f5f5f5;
 }
 
 .more-menu-item i {
 margin-right: 12px;
 width: 20px;
 text-align: center;
 color: var(--primary-color);
 }
 
 .more-menu-item span {
 font-size: 14px;
 color: #333;
 }
 
 /* Support for iOS devices with notches */
 @supports (padding-bottom: env(safe-area-inset-bottom)) {
 .more-menu {
 bottom: calc(80px + env(safe-area-inset-bottom, 0px));
 right: calc(20px + env(safe-area-inset-right, 0px));
 }
 }
 `;
 
 document.head.appendChild(moreButtonStyles);
 
 // Add event listener
 moreButton.addEventListener('click', () => {
 // Toggle more menu
 toggleMoreMenu();
 });
 }
 
 // Hide excess buttons
 let visibleCount = 0;
 
 floatingButtons.forEach(buttonId => {
 const button = document.getElementById(buttonId);
 
 if (button && button.style.display !== 'none') {
 if (visibleCount < 5) {
 button.classList.remove('in-more-menu');
 visibleCount++;
 } else {
 button.classList.add('in-more-menu');
 }
 }
 });
 
 // Create more menu
 createMoreMenu();
 }
 }
 
 // Create more menu
 function createMoreMenu() {
 let moreMenu = document.getElementById('moreMenu');
 
 if (!moreMenu) {
 moreMenu = document.createElement('div');
 moreMenu.id = 'moreMenu';
 moreMenu.className = 'more-menu';
 document.body.appendChild(moreMenu);
 
 // Close menu when clicking outside
 document.addEventListener('click', event => {
 if (moreMenu.classList.contains('show') && 
 !moreMenu.contains(event.target) && 
 event.target.id !== 'moreButton') {
 moreMenu.classList.remove('show');
 }
 });
 }
 
 // Clear menu
 moreMenu.innerHTML = '';
 
 // Add menu items for hidden buttons
 const buttonLabels = {
 'accessibilityButton': 'Accessibility',
 'feedbackButton': 'Feedback',
 'statisticsButton': 'Statistics',
 'themeButton': 'Change Theme',
 'tourButton': 'Guided Tour',
 'cacheButton': 'Offline Maps',
 'arButton': 'View in AR',
 'shareButton': 'Share',
 'preferencesButton': 'Preferences',
 'resetTourButton': 'Reset Tour',
 'debugButton': 'Debug Mode'
 };
 
 const buttonIcons = {
 'accessibilityButton': 'universal-access',
 'feedbackButton': 'comment-alt',
 'statisticsButton': 'chart-bar',
 'themeButton': 'palette',
 'tourButton': 'question-circle',
 'cacheButton': 'download',
 'arButton': 'vr-cardboard',
 'shareButton': 'share-alt',
 'preferencesButton': 'cog',
 'resetTourButton': 'redo-alt',
 'debugButton': 'bug'
 };
 
 floatingButtons.forEach(buttonId => {
 const button = document.getElementById(buttonId);
 
 if (button && button.classList.contains('in-more-menu')) {
 const menuItem = document.createElement('div');
 menuItem.className = 'more-menu-item';
 menuItem.innerHTML = `
 <i class="fas fa-${buttonIcons[buttonId]}"></i>
 <span>${buttonLabels[buttonId]}</span>
 `;
 
 menuItem.addEventListener('click', () => {
 // Trigger button click
 button.click();
 
 // Hide menu
 moreMenu.classList.remove('show');
 });
 
 moreMenu.appendChild(menuItem);
 }
 });
 }
 
 // Toggle more menu
 function toggleMoreMenu() {
 const moreMenu = document.getElementById('moreMenu');
 
 if (moreMenu) {
 moreMenu.classList.toggle('show');
 }
 }
 
 // Organize buttons on load
 window.addEventListener('load', () => {
 organizeButtons();
 });
 
 

// Organize buttons when window is resized
 window.addEventListener('resize', () => {
 organizeButtons();
 });
 })();

// Final initialization message
 console.log('Minnesota Then Museum Without Walls Tour - All systems ready and optimized!');

// Add support for keyboard shortcuts
 (function() {
 // Keyboard shortcuts
 const keyboardShortcuts = [
 { key: 'r', description: 'Recenter map on your location', action: recenterMap },
 { key: '+', description: 'Zoom in', action: () => map.zoomIn() },
 { key: '-', description: 'Zoom out', action: () => map.zoomOut() },
 { key: 'n', description: 'Show navigation tips', action: toggleNavigationTips },
 { key: 'Escape', description: 'Close any open popup or modal', action: closeAllModals },
 { key: 's', description: 'Show statistics', action: showStatistics },
 { key: 'h', description: 'Show help/guided tour', action: () => document.getElementById('tourButton').click() },
 { key: 't', description: 'Change theme', action: () => document.getElementById('themeButton').click() },
 { key: 'p', description: 'Show preferences', action: showPreferencesModal }
 ];
 
 // Register keyboard shortcuts
 document.addEventListener('keydown', (event) => {
 // Skip if user is typing in an input field
 if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') {
 return;
 }
 
 // Find matching shortcut
 const shortcut = keyboardShortcuts.find(s => s.key === event.key);
 
 if (shortcut) {
 event.preventDefault();
 shortcut.action();
 }
 });
 
 // Close all modals
 function closeAllModals() {
 // Get all elements with 'show' class that might be modals
 const modals = document.querySelectorAll('.popup, .feedback-form.show, .accessibility-menu.show, .statistics-modal.show, .certificate-modal.show, .theme-menu.show, .share-modal.show, .preferences-modal.show, .debug-panel.show, .more-menu.show');
 
 modals.forEach(modal => {
 modal.classList.remove('show');
 });
 
 // Close navigation tips
 closeNavigationTips();
 }
 
 // Create keyboard shortcuts help
 function createKeyboardShortcutsHelp() {
 // Create help button
 const helpButton = document.createElement('button');
 helpButton.id = 'keyboardHelpButton';
 helpButton.className = 'keyboard-help-button';
 helpButton.innerHTML = '<i class="fas fa-keyboard"></i>';
 helpButton.setAttribute('aria-label', 'Keyboard shortcuts');
 helpButton.setAttribute('title', 'Keyboard shortcuts');
 
 // Add help button to body
 document.body.appendChild(helpButton);
 
 // Add help button styles
 const helpButtonStyles = document.createElement('style');
 helpButtonStyles.textContent = `
 .keyboard-help-button {
 position: fixed;
 bottom: 20px;
 left: 20px;
 width: 40px;
 height: 40px;
 border-radius: 50%;
 background-color: var(--bg-color);
 color: var(--primary-color);
 border: none;
 box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
 display: flex;
 align-items: center;
 justify-content: center;
 cursor: pointer;
 z-index: 1000;
 }
 
 .keyboard-help-modal {
 position: fixed;
 top: 0;
 left: 0;
 width: 100%;
 height: 100%;
 background-color: rgba(0, 0, 0, 0.7);
 display: flex;
 align-items: center;
 justify-content: center;
 z-index: 2000;
 opacity: 0;
 visibility: hidden;
 transition: opacity 0.3s ease, visibility 0.3s ease;
 }
 
 .keyboard-help-modal.show {
 opacity: 1;
 visibility: visible;
 }
 
 .keyboard-help-content {
 background-color: white;
 border-radius: 8px;
 width: 90%;
 max-width: 500px;
 max-height: 90vh;
 overflow-y: auto;
 }
 
 .keyboard-help-header {
 display: flex;
 justify-content: space-between;
 align-items: center;
 padding: 16px;
 border-bottom: 1px solid #eee;
 position: sticky;
 top: 0;
 background-color: white;
 z-index: 1;
 }
 
 .keyboard-help-header h3 {
 margin: 0;
 font-size: 18px;
 color: #333;
 }
 
 .keyboard-help-header button {
 background: none;
 border: none;
 color: #666;
 cursor: pointer;
 font-size: 16px;
 }
 
 .keyboard-help-body {
 padding: 16px;
 }
 
 .keyboard-shortcut {
 display: flex;
 justify-content: space-between;
 align-items: center;
 margin-bottom: 12px;
 padding-bottom: 12px;
 border-bottom: 1px solid #eee;
 }
 
 .keyboard-shortcut:last-child {
 margin-bottom: 0;
 padding-bottom: 0;
 border-bottom: none;
 }
 
 .keyboard-key {
 display: inline-block;
 padding: 4px 8px;
 background-color: #f5f5f5;
 border: 1px solid #ddd;
 border-radius: 4px;
 font-family: monospace;
 font-size: 14px;
 color: #333;
 min-width: 20px;
 text-align: center;
 }
 
 .keyboard-description {
 flex: 1;
 margin-left: 12px;
 font-size: 14px;
 color: #333;
 }
 
 /* Support for iOS devices with notches */
 @supports (padding-bottom: env(safe-area-inset-bottom)) {
 .keyboard-help-button {
 bottom: calc(20px + env(safe-area-inset-bottom, 0px));
 left: calc(20px + env(safe-area-inset-left, 0px));
 }
 
 .keyboard-help-content {
 margin-bottom: env(safe-area-inset-bottom, 0px);
 }
 }
 `;
 
 document.head.appendChild(helpButtonStyles);
 
 // Add event listener
 helpButton.addEventListener('click', () => {
 // Show keyboard shortcuts help
 showKeyboardShortcutsHelp();
 });
 
 // Show keyboard shortcuts help
 function showKeyboardShortcutsHelp() {
 // Create help modal
 let helpModal = document.getElementById('keyboardHelpModal');
 
 if (!helpModal) {
 helpModal = document.createElement('div');
 helpModal.id = 'keyboardHelpModal';
 helpModal.className = 'keyboard-help-modal';
 
 // Create content
 let content = `
 <div class="keyboard-help-content">
 <div class="keyboard-help-header">
 <h3>Keyboard Shortcuts</h3>
 <button id="closeKeyboardHelp" aria-label="Close keyboard shortcuts">
 <i class="fas fa-times"></i>
 </button>
 </div>
 <div class="keyboard-help-body">
 `;
 
 // Add shortcuts
 keyboardShortcuts.forEach(shortcut => {
 content += `
 <div class="keyboard-shortcut">
 <span class="keyboard-key">${shortcut.key}</span>
 <span class="keyboard-description">${shortcut.description}</span>
 </div>
 `;
 });
 
 content += `
 </div>
 </div>
 `;
 
 helpModal.innerHTML = content;
 document.body.appendChild(helpModal);
 
 // Add event listener to close button
 const closeButton = document.getElementById('closeKeyboardHelp');
 if (closeButton) {
 closeButton.addEventListener('click', () => {
 helpModal.classList.remove('show');
 });
 }
 }
 
 // Show modal with animation
 helpModal.classList.add('show');
 }
 }
 
 // Create keyboard shortcuts help
 createKeyboardShortcutsHelp();
 })();

// Add support for battery optimization
 (function() {
 // Check if Battery API is supported
 if ('getBattery' in navigator) {
 navigator.getBattery().then(battery => {
 // Initial battery status
 handleBatteryStatus(battery);
 
 // Listen for battery status changes
 battery.addEventListener('levelchange', () => {
 handleBatteryStatus(battery);
 });
 
 battery.addEventListener('chargingchange', () => {
 handleBatteryStatus(battery);
 });
 });
 }
 
 // Handle battery status
 function handleBatteryStatus(battery) {
 // Low battery mode (less than 20% and not charging)
 if (battery.level < 0.2 && !battery.charging) {
 enableLowBatteryMode();
 } else {
 disableLowBatteryMode();
 }
 }
 
 // Enable low battery mode
 function enableLowBatteryMode() {
 // Set low battery mode flag
 window.lowBatteryMode = true;
 
 // Reduce map animations
 if (map) {
 map.options.zoomAnimation = false;
 map.options.markerZoomAnimation = false;
 map.options.fadeAnimation = false;
 }
 
 // Reduce location update frequency
 if (watchPositionId) {
 navigator.geolocation.clearWatch(watchPositionId);
 
 watchPositionId = navigator.geolocation.watchPosition(
 handlePositionUpdate,
 handlePositionError,
 {
 enableHighAccuracy: false,
 maximumAge: 30000,
 timeout: 60000
 }
 );
 }
 
 // Disable auto-rotate map
 const preferences = window.loadPreferences();
 if (preferences.autoRotateMap) {
 preferences.autoRotateMap = false;
 window.applyPreferences(preferences);
 }
 
 // Show notification
 showErrorMessage('Low battery mode enabled to conserve power', 5000);
 }
 
 // Disable low battery mode
 function disableLowBatteryMode() {
 // Only do something if we were in low battery mode
 if (window.lowBatteryMode) {
 // Clear low battery mode flag
 window.lowBatteryMode = false;
 
 // Restore map animations
 if (map) {
 map.options.zoomAnimation = true;
 map.options.markerZoomAnimation = true;
 map.options.fadeAnimation = true;
 }
 
 // Restore location update frequency
 if (watchPositionId) {
 navigator.geolocation.clearWatch(watchPositionId);
 
 watchPositionId = navigator.geolocation.watchPosition(
 handlePositionUpdate,
 handlePositionError,
 {
 enableHighAccuracy: true,
 maximumAge: 5000,
 timeout: 10000
 }
 );
 }
 
 // Show notification
 showErrorMessage('Normal power mode restored', 3000);
 }
 }
 })();

// Add support for print functionality
 (function() {
 // Create print button
 const printButton = document.createElement('button');
 printButton.id = 'printButton';
 printButton.className = 'print-button';
 printButton.innerHTML = '<i class="fas fa-print"></i>';
 printButton.setAttribute('aria-label', 'Print tour information');
 printButton.setAttribute('title', 'Print tour information');
 
 // Add print button to body
 document.body.appendChild(printButton);
 
 // Add print button styles
 const printButtonStyles = document.createElement('style');
 printButtonStyles.textContent = `
 .print-button {
 position: fixed;
 top: 20px;
 left: 20px;
 width: 40px;
 height: 40px;
 border-radius: 50%;
 background-color: var(--bg-color);
 color: var(--primary-color);
 border: none;
 box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
 display: flex;
 align-items: center;
 justify-content: center;
 cursor: pointer;
 z-index: 1000;
 }
 
 @media print {
 .map-buttons,
 .accessibility-button,
 .feedback-button,
 .statistics-button,
 .theme-button,
 .tour-button,
 .cache-button,
 .ar-button,
 .share-button,
 .preferences-button,
 .reset-tour-button,
 .debug-button,
 .more-button,
 .keyboard-help-button,
 .print-button {
 display: none !important;
 }
 
 #map {
 height: 400px !important;
 width: 100% !important;
 page-break-inside: avoid;
 }
 
 .print-only {
 display: block !important;
 }
 
 .print-header {
 text-align: center;
 margin-bottom: 20px;
 }
 
 .print-location {
 page-break-inside: avoid;
 margin-bottom: 30px;
 }
 
 .print-location-header {
 border-bottom: 1px solid #ccc;
 padding-bottom: 10px;
 margin-bottom: 10px;
 }
 
 .print-location-description {
 margin-bottom: 15px;
 }
 
 .print-location-status {
 font-style: italic;
 color: #666;
 }
 
 .print-footer {
 margin-top: 30px;
 text-align: center;
 font-size: 12px;
 color: #666;
 border-top: 1px solid #ccc;
 padding-top: 10px;
 }
 }
 
 .print-only {
 display: none;
 }
 
 /* Support for iOS devices with notches */
 @supports (padding-top: env(safe-area-inset-top)) {
 .print-button {
 top: calc(20px + env(safe-area-inset-top, 0px));
 left: calc(20px + env(safe-area-inset-left, 0px));
 }
 }
 `;
 
 document.head.appendChild(printButtonStyles);
 
 // Add event listener
 printButton.addEventListener('click', () => {
 // Prepare for printing
 preparePrint();
 });
 
 // Prepare for printing
 function preparePrint() {
 // Create print content
 const printContent = document.createElement('div');
 printContent.className = 'print-only';
 
 // Add print header
 printContent.innerHTML = `
 <div class="print-header">
 <h1>Minnesota Then Museum Without Walls Tour</h1>
 <p>Self-guided tour of historical locations in Minnesota</p>
 <p>Printed on ${new Date().toLocaleDateString()}</p>
 </div>
 `;
 
 // Add locations
 printContent.innerHTML += `<h2>Tour Locations</h2>`;
 
 gameLocations.forEach((location, index) => {
 const isVisited = visitedLocations.includes(index);
 
 printContent.innerHTML += `
 <div class="print-location">
 <div class="print-location-header">
 <h3>${location.name}</h3>
 </div>
 <div class="print-location-description">
 <p>${location.description}</p>
 </div>
 <div class="print-location-status">
 Status: ${isVisited ? 'Visited' : 'Not visited yet'}
 </div>
 </div>
 `;
 });
 
 // Add statistics if available
 try {
 const statistics = JSON.parse(localStorage.getItem('tourStatistics'));
 
 if (statistics) {
 printContent.innerHTML += `
 <div class="print-statistics">
 <h2>Tour Statistics</h2>
 <p>Distance Traveled: ${formatDistance(statistics.totalDistance)}</p>
 <p>Tour Duration: ${formatDuration(statistics.tourDuration)}</p>
 <p>Locations Visited: ${statistics.locationsVisited}/${gameLocations.length}</p>
 <p>Completion: ${Math.round((statistics.locationsVisited / gameLocations.length) * 100)}%</p>
 </div>
 `;
 }
 } catch (e) {
 console.warn('Could not load statistics for printing', e);
 }
 
 // Add footer
 printContent.innerHTML += `
 <div class="print-footer">
 <p>Minnesota Then Museum Without Walls Tour</p>
 <p>© ${new Date().getFullYear()} Minnesota Historical Society</p>
 </div>
 `;
 
 // Add print content to body
 document.body.appendChild(printContent);
 
 // Print
 setTimeout(() => {
 window.print();
 
 // Remove print content after printing
 setTimeout(() => {
 if (document.body.contains(printContent)) {
 document.body.removeChild(printContent);
 }
 }, 1000);
 }, 500);
 }
 
 // Format distance for printing
 function formatDistance(meters) {
 if (!meters) return '0 m';
 
 if (meters < 1000) {
 return `${Math.round(meters)} m`;
 } else {
 return `${(meters / 1000).toFixed(2)} km`;
 }
 }
 
 // Format duration for printing
 function formatDuration(seconds) {
 if (!seconds) return '00:00:00';
 
 const hours = Math.floor(seconds / 3600);
 const minutes = Math.floor((seconds % 3600) / 60);
 const secs = Math.floor(seconds % 60);
 
 return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
 }
 })();

// Add support for voice commands
 (function() {
 // Check if speech recognition is supported
 if ('SpeechRecognition' in window || 'webkitSpeechRecognition' in window) {
 // Create voice command button
 const voiceButton = document.createElement('button');
 voiceButton.id = 'voiceButton';
 voiceButton.className = 'voice-button';
 voiceButton.innerHTML = '<i class="fas fa-microphone"></i>';
 voiceButton.setAttribute('aria-label', 'Voice commands');
 voiceButton.setAttribute('title', 'Voice commands');
 
 // Add voice button to body
 document.body.appendChild(voiceButton);
 
 // Add voice button styles
 const voiceButtonStyles = document.createElement('style');
 voiceButtonStyles.textContent = `
 .voice-button {
 position: fixed;
 top: 20px;
 right: 20px;
 width: 40px;
 height: 40px;
 border-radius: 50%;
 background-color: var(--bg-color);
 color: var(--primary-color);
 border: none;
 box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
 display: flex;
 align-items: center;
 justify-content: center;
 cursor: pointer;
 z-index: 1000;
 }
 
 .voice-button.listening {
 background-color: #f44336;
 color: white;
 animation: pulse 1.5s infinite;
 }
 
 @keyframes pulse {
 0% {
 transform: scale(1);
 }
 50% {
 transform: scale(1.1);
 }
 100% {
 transform: scale(1);
 }
 }
 
 .voice-tooltip {
 position: fixed;
 top: 70px;
 right: 20px;
 background-color: rgba(0, 0, 0, 0.8);
 color: white;
 padding: 10px 15px;
 border-radius: 4px;
 font-size: 14px;
 max-width: 200px;
 z-index: 1000;
 opacity: 0;
 visibility: hidden;
 transition: opacity 0.3s ease, visibility 0.3s ease;
 }
 
 .voice-tooltip.show {
 opacity: 1;
 visibility: visible;
 }
 
 /* Support for iOS devices with notches */
 @supports (padding-top: env(safe-area-inset-top)) {
 .voice-button {
 top: calc(20px + env(safe-area-inset-top, 0px));
 right: calc(20px + env(safe-area-inset-right, 0px));
 }
 
 .voice-tooltip {
 top: calc(70px + env(safe-area-inset-top, 0px));
 right: calc(20px + env(safe-area-inset-right, 0px));
 }
 }
 `;
 
 document.head.appendChild(voiceButtonStyles);
 
 // Create voice tooltip
 const voiceTooltip = document.createElement('div');
 voiceTooltip.id = 'voiceTooltip';
 voiceTooltip.className = 'voice-tooltip';
 voiceTooltip.textContent = 'Listening...';
 document.body.appendChild(voiceTooltip);
 
 // Initialize speech recognition
 const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
 const recognition = new SpeechRecognition();
 
 recognition.continuous = false;
 recognition.interimResults = false;
 recognition.lang = 'en-US';
 
 // Voice commands
 const voiceCommands = [
 { command: 'recenter', action: recenterMap, aliases: ['center', 'center map', 'find me'] },
 { command: 'zoom in', action: () => map.zoomIn(), aliases: ['closer'] },
 { command: 'zoom out', action: () => map.zoomOut(), aliases: ['farther'] },
 { command: 'show tips', action: toggleNavigationTips, aliases: ['navigation tips', 'help'] },
 { command: 'show statistics', action: showStatistics, aliases: ['statistics', 'stats'] },
 { command: 'change theme', action: () => document.getElementById('themeButton').click(), aliases: ['theme'] },
 { command: 'show tour', action: () => document.getElementById('tourButton').click(), aliases: ['guided tour', 'tour'] },
 { command: 'show preferences', action: showPreferencesModal, aliases: ['preferences', 'settings'] },
 { command: 'next location', action: moveToNextLocation, aliases: ['next', 'skip'] }
 ];
 
 // Add event listener
 voiceButton.addEventListener('click', () => {
 // Toggle voice recognition
 if (voiceButton.classList.contains('listening')) {
 recognition.stop();
 } else {
 recognition.start();
 voiceButton.classList.add('listening');
 voiceTooltip.textContent = 'Listening...';
 voiceTooltip.classList.add('show');
 }
 });
 
 // Handle recognition results
 recognition.onresult = (event) => {
 const transcript = event.results[0][0].transcript.toLowerCase().trim();
 
 // Update tooltip
 voiceTooltip.textContent = `"${transcript}"`;
 
 // Find matching command
 let matchedCommand = null;
 
 for (const command of voiceCommands) {
 if (transcript === command.command || command.aliases.some(alias => transcript === alias)) {
 matchedCommand = command;
 break;
 }
 }
 
 // Execute command
 if (matchedCommand) {
 setTimeout(() => {
 voiceTooltip.textContent = `Executing: ${matchedCommand.command}`;
 matchedCommand.action();
 
 // Hide tooltip after execution
 setTimeout(() => {
 voiceTooltip.classList.remove('show');
 }, 2000);
 }, 1000);
 } else {
 // No matching command
 voiceTooltip.textContent = 'Command not recognized';
 
 // Hide tooltip after a delay
 setTimeout(() => {
 voiceTooltip.classList.remove('show');
 }, 3000);
 }
 };
 
 // Handle recognition end
 recognition.onend = () => {
 voiceButton.classList.remove('listening');
 };
 
 // Handle recognition error
 recognition.onerror = (event) => {
 voiceButton.classList.remove('listening');
 voiceTooltip.textContent = `Error: ${event.error}`;
 
 // Hide tooltip after a delay
 setTimeout(() => {
 voiceTooltip.classList.remove('show');
 }, 3000);
 };
 }
 })();

// Add support for tour completion time tracking
 (function() {
 // Check if tour is complete
 function checkTourCompletion() {
 // Check if all locations have been visited
 if (visitedLocations.length >= gameLocations.length && !localStorage.getItem('tourCompletionTime')) {
 // Set completion time
 localStorage.setItem('tourCompletionTime', new Date().toISOString());
 
 // Calculate tour duration
 const startTime = new Date(localStorage.getItem('tourStartTime') || 0);
 const completionTime = new Date();
 const durationMs = completionTime - startTime;
 
 // Format duration
 const hours = Math.floor(durationMs / (1000 * 60 * 60));
 const minutes = Math.floor((durationMs % (1000 * 60 * 60)) / (1000 * 60));
 const seconds = Math.floor((durationMs % (1000 * 60)) / 1000);
 
 const formattedDuration = `${hours}h ${minutes}m ${seconds}s`;
 
 // Show completion message
 showPopup(
 'Tour Completed!',
 `Congratulations! You have visited all locations in the Minnesota Then Museum Without Walls Tour.
 
 Total time: ${formattedDuration}
 
 You can view your certificate and statistics from the menu.`,
 'alert'
 );
 }
 }
 
 // Check for tour completion when a location is visited
 const originalShowLocationHunt = window.showLocationHunt;
 window.showLocationHunt = function(location) {
 originalShowLocationHunt(location);
 
 // Check for tour completion
 setTimeout(checkTourCompletion, 1000);
 };
 })();

// Final memory cleanup
 (function() {
 // Clear unused variables
 let unusedVars = null;
 let tempData = null;
 
 // Force garbage collection (not directly possible in JavaScript, but we can help)
 unusedVars = null;
 tempData = null;
 
// Clear console in production
 if (window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1') {
 console.clear();
 }
 })();

// Absolutely final message
 console.log('Minnesota Then Museum Without Walls Tour - Ready for exploration! All systems initialized and optimized.');

// Register the application as fully loaded
 document.dispatchEvent(new Event('minnesota-then-loaded'));

</script>
</body>
</html>
