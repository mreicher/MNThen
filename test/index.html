<!DOCTYPE html>
<html lang="en">
<head> 
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Minnesota Then | Museum Without Walls</title>
    <link rel="shortcut icon" type="image/x-icon" href="https://www.mnthen.com/images/mnthenfav.ico">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css">
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css" />
    <link rel="stylesheet" href="https://www.mnthen.com/css/mainmap.css">
    <style>
/* Base variables */
:root {
  --primary: #0f2bab;
  --primary-dark: #0a1f7d;
  --primary-light: #3a51c6;
  --secondary: #ff3b30;
  --dark: #333333;
  --light: #f8f9fa;
  --gray: #6c757d;
  --gray-light: #e9ecef;
  --shadow-sm: 0 2px 4px rgba(0, 0, 0, 0.1);
  --shadow-md: 0 4px 8px rgba(0, 0, 0, 0.1);
  --shadow-lg: 0 8px 16px rgba(0, 0, 0, 0.1);
  --transition-normal: all 0.2s ease;
  --white: #ffffff;
}

/* Map container */
#map {
  width: 100%;
  height: 100vh;
  position: relative;
  z-index: 1;
}

/* Preloader - full screen */
#preloader {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-image: url('your-background-image.jpg'); /* Add your image path here */
  background-size: cover;
  background-position: center;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  z-index: 9999;
  color: white;
}

/* Dark overlay to improve text readability */
#preloader::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.7); /* Dark overlay with 70% opacity */
  z-index: -1;
}

/* Title styling */
#preloader h1 {
  font-size: 32px;
  font-weight: 700;
  margin-bottom: 10px;
  text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
}

/* Tagline styling */
#preloader h2 {
  font-size: 18px;
  font-weight: 400;
  margin-bottom: 30px;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
  opacity: 0.9;
}

#preloader .spinner {
  width: 50px;
  height: 50px;
  border: 5px solid rgba(255, 255, 255, 0.3);
  border-top: 5px solid white;
  border-radius: 50%;
  animation: spin 1s linear infinite;
  margin-bottom: 20px;
}

#preloader p {
  margin-top: 15px;
  font-size: 18px;
  font-weight: 500;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
}

#preloader .progress-container {
  width: 80%;
  max-width: 300px;
  height: 8px;
  background-color: rgba(255, 255, 255, 0.2);
  border-radius: 4px;
  margin-top: 20px;
  overflow: hidden;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
}

#preloader .progress-bar {
  height: 100%;
  background-color: white;
  width: 0;
  transition: width 0.3s ease;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* User marker styling with pulse effect */
.user-marker {
  z-index: 1000;
}

.user-marker-icon {
  width: 16px;
  height: 16px;
  background-color: var(--secondary);
  border-radius: 50%;
  border: 2px solid white;
  box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
  position: relative;
}

/* Double pulse effect with two ::before and ::after elements */
.user-marker-icon::before,
.user-marker-icon::after {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  width: 100%;
  height: 100%;
  background-color: rgba(255, 100, 100, 0.6);
  border-radius: 50%;
  transform: translate(-50%, -50%) scale(1.5);
  z-index: -1;
}

.user-marker-icon::before {
  animation: pulse1 3.5s infinite; 
}

.user-marker-icon::after {
  animation: pulse2 3.5s infinite; 
  animation-delay: 1.75s; 
}

@keyframes pulse1 {
  0% {
    transform: translate(-50%, -50%) scale(1.5);
    opacity: 0.8;
  }
  100% {
    transform: translate(-50%, -50%) scale(3.5);
    opacity: 0;
  }
}

@keyframes pulse2 {
  0% {
    transform: translate(-50%, -50%) scale(1.5);
    opacity: 0.8;
  }
  100% {
    transform: translate(-50%, -50%) scale(3.5);
    opacity: 0;
  }
}

/* Loading and stabilizing modals */
.stabilizing-modal {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: rgba(255, 255, 255, 0.95);
  padding: 24px;
  border-radius: 12px;
  z-index: 2000;
  text-align: center;
  box-shadow: var(--shadow-lg);
  max-width: 80%;
  width: 320px;
}

.stabilizing-modal h3 {
  margin: 12px 0;
  font-size: 18px;
  font-weight: 600;
  color: var(--dark);
}

.stabilizing-modal p {
  margin-bottom: 0;
  font-size: 14px;
  color: var(--gray);
  line-height: 1.5;
}

.spinner {
  width: 40px;
  height: 40px;
  border: 4px solid rgba(15, 43, 171, 0.2);
  border-top: 4px solid var(--primary);
  border-radius: 50%;
  margin: 0 auto 15px;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}

/* Ensures smooth marker transition after stabillity found */
.leaflet-marker-icon {
  transition: opacity 0.5s ease !important;
}

        /* Green route button and dark blue summary button */
.button.route-button {
    background-color: #1b5e20 !important; /* Dark green color */
    color: white !important;
    border: none !important;
    padding: 8px 15px !important;
    border-radius: 0px !important;
    cursor: pointer !important;
    font-size: 17px !important;
    font-weight: 500 !important;
    transition: background-color 0.3s ease !important;
}

.button.summary-button {
    background-color: #0f2bab !important; /* Dark blue color */
    color: white !important;
    border: none !important;
    padding: 8px 15px !important;
    border-radius: 0px !important;
    cursor: pointer !important;
    font-size: 17px !important;
    font-weight: 500 !important;
    transition: background-color 0.3s ease !important;
}

.button.route-button:hover {
    background-color: #0d3c12 !important; /* Darker green on hover */
}

.button.summary-button {
     background-color: #0f2bab !important;
}

.button.summary-button:hover {
    background-color: #0a1f80 !important; /* Darker blue on hover */
}
        
/* Controls */
.map-controls {
  position: absolute;
  bottom: 20px;
  right: 20px;
  display: flex;
  flex-direction: column;
  gap: 10px;
  z-index: 500;
}

.control-button {
  width: 50px;
  height: 50px;
  border-radius: 50%;
  background-color: var(--white);
  border: none;
  box-shadow: var(--shadow-md);
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: var(--transition-normal);
  color: var(--primary);
}

.control-button:hover {
  transform: scale(1.05);
  box-shadow: var(--shadow-lg);
}

.control-button.active {
  background-color: var(--primary);
  color: var(--white);
}

/* Popup styling */
.custom-popup {
  padding: 0;
  border-radius: 12px;
  overflow: hidden;
  box-shadow: var(--shadow-lg);
  max-width: 280px;
}

.popup-content {
  padding: 0;
}

.location-image {
  width: 100%;
  height: 175px;
  object-fit: cover;
  display: block;
}

.location-name {
  padding: 12px 16px;
  margin: 0;
  font-size: 18px;
  font-weight: 600;
  color: var(--dark);
}

.popup-buttons {
  display: flex;
  border-top: 1px solid var(--gray-light);
}

.popup-buttons .button {
  flex: 1;
  padding: 10px;
  background: none;
  border: none;
  font-size: 14px;
  font-weight: 500;
  color: var(--primary);
  cursor: pointer;
  transition: var(--transition-normal);
}

.popup-buttons .button:hover {
  background-color: var(--gray-light);
}

.popup-buttons .button:first-child {
  border-right: 1px solid var(--gray-light);
}

/* Modal styling - fixed issues */
.modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 2000;
}

.modal-content {
  background-color: var(--white);
  padding: 24px;
  border-radius: 12px;
  max-width: 90%;
  width: 320px;
  box-shadow: var(--shadow-lg);
}

.modal-content h3 {
  margin-top: 0;
  margin-bottom: 16px;
  font-size: 18px;
  font-weight: 600;
  color: var(--dark);
  text-align: center;
}

.modal-buttons {
  display: flex;
  flex-direction: column;
  gap: 10px;
  margin-top: 20px;
}

.modal-button {
  padding: 12px;
  border-radius: 8px;
  border: none;
  background-color: var(--primary);
  color: var(--white);
  font-weight: 500;
  cursor: pointer;
  transition: var(--transition-normal);
}

.modal-button:hover {
  background-color: var(--primary-dark);
}

.modal-button.cancel {
  background-color: var(--gray-light);
  color: var(--dark);
}

.modal-button.cancel:hover {
  background-color: var(--gray);
  color: var(--white);
}

/* Location hunt container */
.lochunt-container {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.8);
  display: none;
  flex-direction: column;
  z-index: 2000;
  overflow-y: auto;
}

.lochunt-content {
  background-color: var(--white);
  margin: auto;
  width: 90%;
  max-width: 500px;
  border-radius: 12px;
  overflow: hidden;
  box-shadow: var(--shadow-lg);
  display: flex;
  flex-direction: column;
}

.lochunt-image {
  width: 100%;
  height: 200px;
  object-fit: cover;
}

.lochunt-details {
  padding: 20px;
}

.lochunt-title {
  font-size: 22px;
  font-weight: 600;
  margin: 0 0 8px 0;
  color: var(--dark);
}

.lochunt-city {
  font-size: 16px;
  color: var(--gray);
  margin: 0 0 4px 0;
}

.lochunt-creator {
  font-size: 14px;
  color: var(--gray);
  margin: 0 0 20px 0;
}

/* Audio player */
.audio-player {
  background-color: var(--gray-light);
  border-radius: 8px;
  padding: 16px;
  margin-bottom: 20px;
}

.audio-controls {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 12px;
}

.audio-button {
  background: none;
  border: none;
  cursor: pointer;
  color: var(--dark);
  font-size: 18px;
  width: 40px;
  height: 40px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 50%;
  transition: var(--transition-normal);
}

.audio-button:hover {
  background-color: rgba(0, 0, 0, 0.1);
}

.audio-button.play-pause {
  background-color: var(--primary);
  color: var(--white);
}

.audio-button.play-pause:hover {
  background-color: var(--primary-dark);
}

.progress-container {
  position: relative;
  height: 6px;
  background-color: rgba(0, 0, 0, 0.1);
  border-radius: 3px;
  cursor: pointer;
  margin-bottom: 8px;
}

.progress {
  height: 100%;
  background-color: var(--primary);
  border-radius: 3px;
  width: 0;
}

.time-display {
  display: flex;
  justify-content: space-between;
  font-size: 12px;
  color: var(--gray);
}

/* Additional info container */
.additional-info-container {
  display: none;
  background-color: var(--white);
  padding: 20px;
  border-radius: 0 0 12px 12px;
  margin-top: -12px;
}

.additional-info-title {
  font-size: 18px;
  font-weight: 600;
  margin: 0 0 12px 0;
  color: var(--dark);
}

.additional-info-text {
  font-size: 14px;
  line-height: 1.6;
  color: var(--dark);
  margin-bottom: 20px;
}

.continue-button {
  display: block;
  width: 100%;
  padding: 12px;
  background-color: var(--primary);
  color: var(--white);
  border: none;
  border-radius: 8px;
  font-weight: 500;
  cursor: pointer;
  transition: var(--transition-normal);
}

.continue-button:hover {
  background-color: var(--primary-dark);
}

/* Summary modal */
#summaryModal {
  display: none;
}

.summary-content {
  background-color: var(--white);
  padding: 24px;
  border-radius: 12px;
  max-width: 90%;
  width: 400px;
  box-shadow: var(--shadow-lg);
}

.summary-heading {
  font-size: 20px;
  font-weight: 600;
  margin: 0 0 16px 0;
  color: var(--dark);
}

/* Navigation tips */
.navigation-tips {
    position: fixed;
    top: 50%; /* Center vertically */
    left: 50%; /* Center horizontally */
    transform: translate(-50%, -50%); /* Adjust to true center */
    background-color: var(--white);
    padding: 24px; /* Increased padding for better spacing */
    border-radius: 12px;
    box-shadow: var(--shadow-lg);
    max-width: 90%; /* Take up to 80% of the screen width */
    max-height: 80%; /* take up to 80% of the screen height */
    overflow-y: auto; /* Add scroll if content exceeds height */
    display: none;
    z-index: 1500;
    box-sizing: border-box; /* Include padding in width/height calculations */
}

.navigation-tips h3 {
  font-size: 20px;
  font-weight: 600;
  margin: 0 0 12px 0;
  color: var(--dark);
}

.navigation-tips ul {
  margin: 0;
  padding: 0 0 0 20px;
}

.navigation-tips li {
  margin-bottom: 8px;
  font-size: 18px;
  color: var(--dark);
}

.close-button {
  position: absolute;
  top: 8px;
  right: 8px;
  background: none;
  border: none;
  font-size: 16px;
  color: var(--gray);
  cursor: pointer;
}

/* Marker clusters */
.marker-cluster-custom {
  background-color: rgba(0, 100, 0, .6);
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
}

.marker-cluster-custom div {
  background-color: rgba(47, 99, 47, 1);
  width: 30px;
  height: 30px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
}

.marker-cluster-custom span {
  color: var(--white);
  font-weight: 600;
  font-size: 12px;
}

/* Popup */
.popup {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: var(--white);
  padding: 24px;
  border-radius: 12px;
  box-shadow: var(--shadow-lg);
  z-index: 2000;
  text-align: center;
  max-width: 80%;
  width: 320px;
}

/* Responsive adjustments */
@media (min-width: 768px) {
  .modal-content {
    width: 400px;
  }

  .modal-buttons {
    flex-direction: row;
    justify-content: center;
  }

  .lochunt-content {
    max-width: 600px;
  }

  .lochunt-image {
    height: 300px;
  }
}
    </style>
</head>
<body>
    <!-- Preloader -->
    <div id="preloader">
        <div class="spinner"></div>
        <p>Loading Minnesota Then...</p>
        <div class="progress-container">
            <div class="progress-bar" id="preloaderProgress"></div>
        </div>
    </div>

    <div id="map"></div>
    <div id="distanceBox">Initializing...</div>

    <div class="lochunt-container">
        <img id="locationImage" src="" alt="Location Image">
            <div class="lochunt-content">
                <div class="lochunt-info">
                    <h2 id="locationTitle" class="mb-2 text-primary"></h2>
                        <p id="locationCity" class="text-muted mb-1"></p>
                        <p id="locationCreator" class="text-muted mb-3"></p>
                </div>
            <div class="audio-player">
                <div class="audio-progress">
                    <div class="progress">
                        <div id="progressBar" class="progress-bar" role="progressbar" style="width: 0%"></div>
                    </div>
                </div>
                <div class="audio-time">
                    <span id="currentTime">0:00</span>
                    <span id="duration">0:00</span>
                </div>
                <div class="audio-controls">
                    <button id="rewindBtn" class="audio-button"><i class="fas fa-backward"></i></button>
                    <button id="playPauseBtn" class="audio-button"><i class="fas fa-play"></i></button>
                    <button id="forwardBtn" class="audio-button"><i class="fas fa-forward"></i></button>
                </div>
                <audio id="locationAudio" src=""></audio>
            </div>
        </div>
    </div>
    
    <div class="additional-info-container">
       <h3 class="mb-3 text-primary text-center">Did You Know?</h3>
       <p id="additionalInfo" class="mb-3 fs-6"></p>
       <div class="d-flex justify-content-center">
           <button id="continueButton" class="btn btn-primary">Continue</button>
       </div>
    </div>
    
    <div class="map-buttons">
        <button id="recenterButton" class="map-button"><i class="fas fa-crosshairs"></i></button>
        <button id="returnButton" class="map-button"><i class="fas fa-sign-out-alt"></i></button>
        <button id="tipsButton" class="map-button"><i class="fas fa-question-circle"></i></button>
    </div>

    <div class="navigation-tips">
        <button class="close-button">&times;</button>
        <h3>Navigation Tips</h3>
        <ul>
            <li>Use the map to navigate to the marked locations.</li>
            <li>The distance box shows how far you are from the current location.</li>
            <li>Tap the recenter button to focus on your current position.</li>
            <li>When you're within 20 feet of a location, you'll be able to interact with it.</li>
            <li>Listen to the audio information for each location.</li>
            <li>After the audio, you'll see additional information about the location.</li>
        </ul>
    </div>

    <div id="summaryModal" class="modal" style="display: none;">
        <div class="modal-content">
            <p id="summaryContent"></p>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"></script>
    <script src="/locations_test.js?v=1.0.4"></script>

    <script>
// Global variables
let map, userMarker, markerClusterGroup
let currentLocationIndex = 0
const visitedLocations = []
let gameLocations = []
let inactivityTimer
let isLocationHuntVisible = false
let lastPosition = null
let positionBuffer = []
const MAX_BUFFER_SIZE = 30 // Increased buffer size for smoother tracking
const DISTANCE_THRESHOLD = 20 // 20 feet to measure threshold distance to marker before opening location page.
const PROXIMITY_THRESHOLD = 40 // 40 feet threshold for zoom changes
let velocity = { lat: 0, lng: 0 }
let isMapInteracting = false
let followUser = true
let locationCooldowns = {}
let userIsInteracting = false
const preloadedImages = new Map() // Map to store preloaded images
const preloadedAudio = new Map() // Map to store preloaded audio
let currentSpeed = 0 // Current speed in meters per second
let lastZoomLevel = 17 // Default zoom level
let stationaryPositionHistory = [] // Array to store stationary positions for averaging
let deviceOrientation = null // Store device orientation data
let deviceMotion = null // Store device motion data
let orientationPermissionGranted = false
let geolocationSensor = null // Store GeolocationSensor instance
let isNearLocation = false // Flag to track if user is near a location
let lastProximityCheck = 0 // Last time proximity was checked
let isReturningFromExhibit = false // Flag to track if returning from exhibit

// Enhanced constants for better stabilization
const MICRO_MOVEMENT_THRESHOLD = 0.3 // Meters - threshold for detecting micro-movements (reduced for better stability)
const STATIONARY_ACCURACY_MULTIPLIER = 1.2 // Looser accuracy bounds to prevent false movement detection
const MAX_ACCEPTABLE_ACCURACY = 25 // meters - more lenient accuracy requirement
const STATIONARY_THRESHOLD = 2 // Number of consecutive stationary positions to consider user as stationary (reduced for faster stabilization)
const STATIONARY_TIME_THRESHOLD = 3000 // ms - time to consider user stationary (reduced)
const STATIONARY_CHECK_INTERVAL = 1000 // ms - interval to check if still stationary (reduced)
const VELOCITY_DECAY = 0.92 // Higher value for smoother velocity transitions
const MIN_DISTANCE_THRESHOLD = 1.0 // meters - minimum distance to consider movement (reduced)
const EXTENDED_DISTANCE_THRESHOLD = 80 // meters - distance to consider a significant position change
const UPDATE_INTERVAL = 50 // ms - more frequent updates for smoother movement
const STATIONARY_POSITION_HISTORY_SIZE = 15 // Number of positions to keep for stationary averaging (increased)
const STATIONARY_POSITION_WEIGHT_DECAY = 0.9 // Weight decay for older positions in stationary average (reduced)
const SUDDEN_MOVEMENT_THRESHOLD = 0.8 // meters - threshold for detecting sudden movements (reduced)
const POSITION_JUMP_THRESHOLD = 2.0 // meters - threshold for detecting position jumps (reduced)
const ZOOM_CHANGE_COOLDOWN = 1500 // ms - cooldown between zoom changes

// Background handling constants
const BACKGROUND_THRESHOLD = 15000 // ms - time to consider app was in background (reduced)
const INACTIVITY_TIMEOUT = 20000 // ms - time to consider user inactive (reduced)

// Kalman filter parameters - optimized for better movement tracking
const KALMAN_PROCESS_NOISE = 0.00001
const KALMAN_MEASUREMENT_NOISE_BASE = 0.1
const KALMAN_STATIONARY_NOISE = 0.000001

// Animation parameters
const ANIMATION_DURATION = 200 // ms - reduced duration of position animation for more responsive transitions
const HEADING_SMOOTHING = 0.85 // Reduced heading smoothing factor for more responsive direction changes

// Zoom level parameters
const MAX_ZOOM_LEVEL = 17 // Maximum zoom level (stationary)
const MIN_ZOOM_LEVEL = 13 // Minimum zoom level (high speed)
const WALKING_ZOOM_LEVEL = 17 // Zoom level for walking speed
const WALKING_SPEED_THRESHOLD = 1.5 // m/s - threshold for walking speed
const RUNNING_SPEED_THRESHOLD = 4.0 // m/s - threshold for running speed
const DRIVING_SPEED_THRESHOLD = 10.0 // m/s - threshold for driving speed
const ZOOM_TRANSITION_DURATION = 0.5 // seconds - reduced duration of zoom transition for more responsive zooming

// Motion detection parameters
const MOTION_THRESHOLD = 0.8 // Reduced threshold for detecting significant motion
const MOTION_SAMPLE_SIZE = 15 // Increased number of motion samples to keep
const MOTION_CHECK_INTERVAL = 200 // ms - reduced interval to check motion for more responsive detection

// Edge recenter parameters - optimized for better edge recentering
const EDGE_THRESHOLD_PERCENTAGE = 0.25 // Percentage of viewport to trigger recenter (reduced)
const CRITICAL_EDGE_THRESHOLD = 0.125 // Critical threshold for emergency recenter (reduced)
const RECENTER_COOLDOWN = 1500 // ms - minimum time between recenters (reduced)

// State variables
let lastUpdateTime = null
let lastVelocity = { lat: 0, lng: 0 }
let isStationary = false
let stationaryStartTime = null
let stationaryCheckTimeout = null
let lastUpdateTimestamp = null
let lastHiddenTime = 0
let lastKnownPosition = null
const isTransitioning = false
let lastVisitedLocationId = null
let stationaryCount = 0
let lastSmoothedPosition = null
let lastRecenterTime = Date.now()
let retryCount = 0
const stationaryBuffer = []
const stationaryPosition = null
let isStabilizing = true // Flag to track initial stabilization
let lastStationaryPosition = null // Last stable position when stationary
const motionSamples = [] // Array to store motion samples
const lastMotionTimestamp = 0 // Last time motion was detected
let deviceStationaryTime = 0 // Time device has been stationary based on motion sensors
let animationFrameId = null // Store requestAnimationFrame ID
let renderTimestamp = null // Last render timestamp
const positionUpdateQueue = [] // Queue for position updates to be processed
let lastHeadingValue = null // Last heading value
const headingBuffer = [] // Buffer for heading values
let isFirstPositionUpdate = true // Flag for first position update
let lastRenderPosition = null // Last rendered position

const positionInterpolator = {
  currentAnimation: null,
  startTime: null,
  from: null,
  to: null,
  duration: 0,
  
  start: function(from, to, duration) {
    // Cancel any existing animation
    if (this.currentAnimation) {
      cancelAnimationFrame(this.currentAnimation);
    }
    
    // Store animation parameters
    this.startTime = performance.now();
    this.from = from;
    this.to = to;
    this.duration = duration;
    
    // Start animation
    this.update();
  },
  
  update: function() {
    if (!this.startTime) return;
    
    const currentTime = performance.now();
    const elapsed = currentTime - this.startTime;
    const progress = Math.min(elapsed / this.duration, 1);
    
    // Use easing for smoother motion (ease-out)
    const eased = 1 - Math.pow(1 - progress, 3);
    
    // Interpolate between positions
    const currentPosition = {
      lat: this.from.lat + (this.to.lat - this.from.lat) * eased,
      lng: this.from.lng + (this.to.lng - this.from.lng) * eased
    };
    
    // Update marker position
    updateUserMarkerPosition(currentPosition);
    lastRenderPosition = currentPosition;
    
    // Continue animation if not complete
    if (progress < 1) {
      this.currentAnimation = requestAnimationFrame(() => this.update());
    } else {
      this.currentAnimation = null;
      this.startTime = null;
    }
  },
  
  cancel: function() {
    if (this.currentAnimation) {
      cancelAnimationFrame(this.currentAnimation);
      this.currentAnimation = null;
      this.startTime = null;
    }
  },
  
  isInterpolating: function() {
    return this.currentAnimation !== null;
  }
};
      
let mapViewportWidth = 0 // Store map viewport width
let mapViewportHeight = 0 // Store map viewport height
let lastMapCenter = null // Last map center position
let lastMapZoom = null // Last map zoom level
let edgeRecenterInProgress = false // Flag to track edge recentering
const domUpdateScheduled = false // Flag to track scheduled DOM updates
const pendingDomUpdates = new Map() // Map to store pending DOM updates
let usingGeolocationSensorAPI = false // Flag to track which geolocation API is being used
const lockStationaryPosition = false // Flag to lock stationary position and prevent jitter
let positionHistory = [] // Array to store recent position history for jump detection
const lastPositionTimestamp = 0 // Last time a position was processed
let suddenMovementCount = 0 // Counter for consecutive sudden movements
let isJumpDetected = false // Flag to track if a position jump is detected
let stationaryPositionLocked = false // Flag to indicate if stationary position is locked
let stationaryPositionLockTime = 0 // Time when stationary position was locked
let lastValidPosition = null // Last valid position before a jump
let stationaryLockTimeout = null // Timeout for locking stationary position
const positionStabilityCounter = 0 // Counter for position stability
let lastZoomChangeTime = 0 // Last time zoom was changed due to proximity
let lastProximityDistance = Number.POSITIVE_INFINITY // Last distance to nearest location
const highPrecisionAvailable = true // Flag to track if high precision is available
const lowPrecisionFallbackActive = false // Flag to track if low precision fallback is active
const devicePixelRatio = window.devicePixelRatio || 1 // Device pixel ratio for smoother rendering
const lastDeviceOrientation = null // Last device orientation for smoother heading changes
const orientationUpdateInterval = null // Interval for orientation updates
const motionUpdateInterval = null // Interval for motion updates
const lastAccuracy = Number.POSITIVE_INFINITY // Last position accuracy
const accuracyTrend = [] // Array to track accuracy trend
const isAccuracyImproving = false // Flag to track if accuracy is improving
const lastHeadingUpdateTime = 0 // Last time heading was updated
const headingUpdateInterval = 100 // ms - interval for heading updates
const isDeviceMoving = false // Flag to track if device is moving based on sensors
const lastDeviceMotionTime = 0 // Last time device motion was detected
const deviceMotionTimeout = null // Timeout for device motion detection
const deviceOrientationTimeout = null // Timeout for device orientation detection
const positionUpdateIntervalId = null // Interval ID for position updates
const positionUpdateRate = 1000 // ms - interval for position updates
const adaptivePositionUpdateRate = true // Flag to enable adaptive position update rate
const lastPositionAccuracy = Number.POSITIVE_INFINITY // Last position accuracy for adaptive update rate
const highFrequencyUpdatesActive = false // Flag to track if high frequency updates are active
const highFrequencyUpdateTimeout = null // Timeout for high frequency updates
const lastHighFrequencyUpdateTime = 0 // Last time high frequency updates were activated
const highFrequencyUpdateDuration = 5000 // ms - duration of high frequency updates
const isPositionStable = false // Flag to track if position is stable
const positionStabilityThreshold = 5 // Number of consecutive stable positions to consider position stable
const positionStabilityRadius = 2.0 // meters - radius for position stability
const lastStablePosition = null // Last stable position
const stablePositionConfidence = 0 // Confidence in stable position (0-1)
const isUsingHighAccuracy = true // Flag to track if high accuracy is being used
const highAccuracyFailureCount = 0 // Counter for high accuracy failures
const maxHighAccuracyFailures = 3 // Maximum number of high accuracy failures before fallback
const lastSuccessfulHighAccuracyUpdate = 0 // Last time a high accuracy update was successful
const highAccuracyTimeout = 10000 // ms - timeout for high accuracy updates
let isWatchPositionActive = false // Flag to track if watchPosition is active
let watchPositionId = null // ID for watchPosition
const lastWatchPositionUpdate = 0 // Last time watchPosition was updated
const watchPositionUpdateInterval = 1000 // ms - interval for watchPosition updates
const isUsingDeviceMotionForHeading = false // Flag to track if device motion is being used for heading
const lastCompassHeading = null // Last compass heading
const compassHeadingBuffer = [] // Buffer for compass heading values
const compassHeadingBufferSize = 5 // Size of compass heading buffer
const isCompassCalibrated = false // Flag to track if compass is calibrated
const compassCalibrationTimeout = null // Timeout for compass calibration
const compassCalibrationDuration = 5000 // ms - duration of compass calibration
const lastCompassCalibrationTime = 0 // Last time compass was calibrated
const isUsingGyroscopeForOrientation = false // Flag to track if gyroscope is being used for orientation
const gyroscopeData = null // Gyroscope data
const lastGyroscopeUpdateTime = 0 // Last time gyroscope was updated
const gyroscopeUpdateInterval = 100 // ms - interval for gyroscope updates
const isDeviceStationaryByMotion = false // Flag to track if device is stationary based on motion sensors
const deviceStationaryByMotionTime = 0 // Time device has been stationary based on motion sensors
const deviceStationaryByMotionThreshold = 2000 // ms - threshold for device to be considered stationary by motion
const deviceMotionMagnitude = 0 // Magnitude of device motion
const deviceMotionMagnitudeBuffer = [] // Buffer for device motion magnitude values
const deviceMotionMagnitudeBufferSize = 10 // Size of device motion magnitude buffer
const deviceMotionMagnitudeThreshold = 0.5 // Threshold for device motion magnitude to be considered moving

// Utility function to calculate distance between two coordinates
function calculateDistance(pos1, pos2) {
  if (
    !pos1 ||
    !pos2 ||
    typeof pos1.lat !== "number" ||
    typeof pos1.lng !== "number" ||
    typeof pos2.lat !== "number" ||
    typeof pos2.lng !== "number"
  ) {
    return Number.POSITIVE_INFINITY
  }

  // Haversine formula for more accurate distance calculation
  const R = 6371000 // Earth radius in meters
  const lat1 = (pos1.lat * Math.PI) / 180
  const lat2 = (pos2.lat * Math.PI) / 180
  const deltaLat = ((pos2.lat - pos1.lat) * Math.PI) / 180
  const deltaLng = ((pos2.lng - pos1.lng) * Math.PI) / 180

  const a =
    Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) +
    Math.cos(lat1) * Math.cos(lat2) * Math.sin(deltaLng / 2) * Math.sin(deltaLng / 2)
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))

  return R * c
}

// Enhanced Kalman Filter implementation
class KalmanFilter {
  constructor() {
    // State vector [x, y, vx, vy]
    this.x = 0
    this.y = 0
    this.vx = 0
    this.vy = 0

    // Error covariance matrix
    this.P = [
      [100, 0, 0, 0], // Initial high uncertainty
      [0, 100, 0, 0],
      [0, 0, 10, 0],
      [0, 0, 0, 10],
    ]

    // Process noise
    this.Q = KALMAN_PROCESS_NOISE

    // Measurement noise (will be adjusted based on GPS accuracy)
    this.R = KALMAN_MEASUREMENT_NOISE_BASE

    // Time delta
    this.dt = 1.0

    // Initialized flag
    this.initialized = false

    // Heading and accuracy tracking
    this.lastHeading = null
    this.headingConfidence = 0

    // Stationary mode flag
    this.stationaryMode = false
    this.stationaryStartTime = 0

    // Last timestamp
    this.lastTimestamp = null

    // Adaptive noise parameters
    this.adaptiveNoiseMin = 0.0002
    this.adaptiveNoiseMax = 0.002
    this.adaptiveNoiseFactor = 1.0

    // Position history for jitter detection
    this.positionHistory = []
    this.maxPositionHistory = 10
    this.jitterThreshold = 0.35 // meters
    this.jitterCount = 0

    // Stationary lock
    this.stationaryLocked = false
    this.stationaryPosition = null

    // Heading smoothing
    this.headingSmoothingFactor = 0.8
    this.headingBuffer = []
    this.headingBufferSize = 7

    // Velocity smoothing
    this.velocitySmoothingFactor = 0.8
    this.velocityBuffer = []
    this.velocityBufferSize = 7

    // Accuracy-based adaptation
    this.accuracyBuffer = []
    this.accuracyBufferSize = 7
    this.lastAccuracy = Number.POSITIVE_INFINITY
    this.isAccuracyImproving = false

    // Motion-based adaptation
    this.motionDetected = false
    this.motionConfidence = 0

    // Adaptive parameters based on device capabilities
    this.deviceCapabilitiesSet = false
    this.deviceSupportsHighAccuracy = true
    this.deviceSupportsMotionSensors = true
    this.deviceSupportsOrientationSensors = true

    // Innovation tracking to detect filter divergence
    this.innovationBuffer = []
    this.innovationBufferSize = 10
    this.innovationThreshold = 3.0 // standard deviations

    // GNSS receiver type (GPS, GLONASS, Galileo, etc)
    this.receiverType = "GPS"

    // Environment type (urban, rural, indoor, etc)
    this.environmentType = "mixed"
  }

  // Set device capabilities
  setDeviceCapabilities(highAccuracy, motionSensors, orientationSensors) {
    this.deviceCapabilitiesSet = true
    this.deviceSupportsHighAccuracy = highAccuracy
    this.deviceSupportsMotionSensors = motionSensors
    this.deviceSupportsOrientationSensors = orientationSensors

    // Adjust parameters based on device capabilities
    if (!highAccuracy) {
      this.adaptiveNoiseMin *= 1.5
      this.adaptiveNoiseMax *= 1.5
      this.jitterThreshold *= 1.5
    }

    if (!motionSensors) {
      this.adaptiveNoiseMin *= 1.2
      this.adaptiveNoiseMax *= 1.2
    }

    if (!orientationSensors) {
      this.headingSmoothingFactor = 0.9
    }

    return this
  }

  // Set the type of GNSS receiver
  setReceiverType(type) {
    this.receiverType = type

    // Adjust parameters based on receiver type
    switch (type.toUpperCase()) {
      case "GPS_GLONASS":
      case "MULTI_CONSTELLATION":
        this.adaptiveNoiseMin *= 0.8
        this.adaptiveNoiseMax *= 0.8
        break
      case "BASIC_GPS":
        this.adaptiveNoiseMin *= 1.2
        this.adaptiveNoiseMax *= 1.2
        break
      case "HIGH_PRECISION":
        this.adaptiveNoiseMin *= 0.5
        this.adaptiveNoiseMax *= 0.5
        break
    }

    return this
  }

  // Set the type of environment
  setEnvironmentType(type) {
    this.environmentType = type

    // Adjust parameters based on environment type
    switch (type.toLowerCase()) {
      case "urban":
        this.adaptiveNoiseMin *= 1.3
        this.adaptiveNoiseMax *= 1.3
        this.jitterThreshold *= 0.9
        break
      case "rural":
        this.adaptiveNoiseMin *= 0.8
        this.adaptiveNoiseMax *= 0.8
        this.jitterThreshold *= 1.2
        break
      case "indoor":
        this.adaptiveNoiseMin *= 1.5
        this.adaptiveNoiseMax *= 1.5
        this.jitterThreshold *= 0.7
        break
    }

    return this
  }

  // Initialize the filter with first position
  reset(position) {
    if (!position || typeof position.lat !== "number" || typeof position.lng !== "number") {
      console.error("Invalid position for Kalman filter reset")
      return
    }

    this.x = position.lng
    this.y = position.lat
    this.vx = 0
    this.vy = 0

    // Reset covariance matrix with high initial uncertainty
    this.P = [
      [100, 0, 0, 0],
      [0, 100, 0, 0],
      [0, 0, 10, 0],
      [0, 0, 0, 10],
    ]

    this.initialized = true
    this.lastHeading = position.heading || null
    this.headingConfidence = 0
    this.stationaryMode = false
    this.lastTimestamp = position.timestamp || Date.now()
    this.adaptiveNoiseFactor = 1.0
    this.positionHistory = []
    this.jitterCount = 0
    this.stationaryLocked = false
    this.stationaryPosition = null
    this.headingBuffer = []
    this.velocityBuffer = []
    this.accuracyBuffer = []
    this.lastAccuracy = position.accuracy || Number.POSITIVE_INFINITY
    this.isAccuracyImproving = false
    this.motionDetected = false
    this.motionConfidence = 0
    this.innovationBuffer = []

    return this
  }

  // Set stationary mode
  setStationaryMode(isStationary) {
    this.stationaryMode = isStationary

    // When entering stationary mode, reduce velocity to zero
    if (isStationary) {
      this.vx = 0
      this.vy = 0
      this.stationaryStartTime = Date.now()

      // Reduce process noise for stationary mode
      this.Q = KALMAN_STATIONARY_NOISE
      this.adaptiveNoiseFactor = 0.03
    } else {
      // Reset to normal process noise when moving
      this.Q = KALMAN_PROCESS_NOISE
      this.adaptiveNoiseFactor = 1.0
      this.stationaryLocked = false
      this.stationaryPosition = null
    }

    return this
  }

  // Lock stationary position
  lockStationaryPosition(position) {
    if (!this.stationaryMode) return this

    this.stationaryLocked = true
    this.stationaryPosition = position
    console.log("Kalman filter: Stationary position locked")

    return this
  }

  // Update accuracy buffer and check if accuracy is improving
  updateAccuracyBuffer(accuracy) {
    if (isNaN(accuracy) || accuracy <= 0) {
      accuracy = this.lastAccuracy || 20
    }

    this.accuracyBuffer.push(accuracy)
    while (this.accuracyBuffer.length > this.accuracyBufferSize) {
      this.accuracyBuffer.shift()
    }

    if (this.accuracyBuffer.length >= 3) {
      const avgRecent =
        (this.accuracyBuffer[this.accuracyBuffer.length - 1] + this.accuracyBuffer[this.accuracyBuffer.length - 2]) / 2
      const avgOlder =
        (this.accuracyBuffer[0] + (this.accuracyBuffer.length > 1 ? this.accuracyBuffer[1] : this.accuracyBuffer[0])) /
        2

      this.isAccuracyImproving = avgRecent < avgOlder
    }

    this.lastAccuracy = accuracy

    return this
  }

  // Track innovation to detect filter divergence
  updateInnovationBuffer(innovation) {
    this.innovationBuffer.push(innovation)
    while (this.innovationBuffer.length > this.innovationBufferSize) {
      this.innovationBuffer.shift()
    }

    if (this.innovationBuffer.length >= 5) {
      // Calculate mean and standard deviation of innovations
      const sum = this.innovationBuffer.reduce((acc, val) => acc + val, 0)
      const mean = sum / this.innovationBuffer.length

      const sumSquaredDiff = this.innovationBuffer.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0)
      const stdDev = Math.sqrt(sumSquaredDiff / this.innovationBuffer.length)

      // If innovation is consistently large, the filter might be diverging
      const latestInnovation = this.innovationBuffer[this.innovationBuffer.length - 1]
      if (Math.abs(latestInnovation - mean) > this.innovationThreshold * stdDev) {
        // Increase uncertainty to force filter to trust measurements more
        for (let i = 0; i < 4; i++) {
          this.P[i][i] *= 2.0
        }
      }
    }

    return this
  }

  // Detect jitter in position updates
  detectJitter(newPosition) {
    if (this.positionHistory.length === 0) {
      this.positionHistory.push(newPosition)
      return false
    }

    const lastPos = this.positionHistory[this.positionHistory.length - 1]
    const distance = calculateDistance(lastPos, newPosition)

    // Add to history
    this.positionHistory.push(newPosition)
    while (this.positionHistory.length > this.maxPositionHistory) {
      this.positionHistory.shift()
    }

    // Check for rapid back-and-forth movement (jitter)
    if (this.positionHistory.length >= 3 && this.stationaryMode) {
      const pos1 = this.positionHistory[this.positionHistory.length - 3]
      const pos2 = this.positionHistory[this.positionHistory.length - 2]
      const pos3 = this.positionHistory[this.positionHistory.length - 1]

      const dist1 = calculateDistance(pos1, pos2)
      const dist2 = calculateDistance(pos2, pos3)

      // If moving back and forth in small distances
      if (
        dist1 < this.jitterThreshold &&
        dist2 < this.jitterThreshold &&
        Math.sign(pos3.lat - pos2.lat) !== Math.sign(pos2.lat - pos1.lat) &&
        Math.sign(pos3.lng - pos2.lng) !== Math.sign(pos2.lng - pos1.lng)
      ) {
        this.jitterCount++
        return this.jitterCount > 1
      }
    }

    // Reset jitter count if no jitter detected
    if (distance > this.jitterThreshold) {
      this.jitterCount = 0
    }

    return false
  }

  // Smooth heading values
  smoothHeading(newHeading) {
    if (newHeading === null || newHeading === undefined || isNaN(newHeading)) {
      return this.lastHeading
    }

    // Normalize to 0-360
    newHeading = ((newHeading % 360) + 360) % 360

    // Add to heading buffer
    this.headingBuffer.push(newHeading)
    while (this.headingBuffer.length > this.headingBufferSize) {
      this.headingBuffer.shift()
    }

    if (this.headingBuffer.length < 2) {
      return newHeading
    }

    // Use median filter to remove outliers
    if (this.headingBuffer.length >= 3) {
      const sortedHeadings = [...this.headingBuffer].sort((a, b) => a - b)
      const medianHeading = sortedHeadings[Math.floor(sortedHeadings.length / 2)]

      // If new heading is very different from median, it might be an outlier
      const headingDiff = Math.abs(((newHeading - medianHeading + 180) % 360) - 180)
      if (headingDiff > 45 && this.headingConfidence > 0.5) {
        // Use median instead of potentially erroneous new heading
        newHeading = medianHeading
      }
    }

    // If we have a previous heading, smooth the transition
    if (this.lastHeading !== null) {
      // Normalize headings to 0-360
      const normalizedCurrent = ((newHeading % 360) + 360) % 360
      const normalizedLast = ((this.lastHeading % 360) + 360) % 360

      // Calculate the smallest angle between the two headings
      let diff = normalizedCurrent - normalizedLast
      if (diff > 180) diff -= 360
      if (diff < -180) diff += 360

      // Apply adaptive smoothing based on motion and stationary state
      let headingWeight = this.headingSmoothingFactor
      if (this.stationaryMode) {
        headingWeight = 0.05 // Very smooth when stationary
      } else if (this.motionDetected) {
        headingWeight = Math.min(0.4, headingWeight * (1 + this.motionConfidence)) // More responsive when motion detected
      }

      // Apply smoothing
      const smoothedHeading = normalizedLast + diff * (1 - headingWeight)

      // Normalize back to 0-360
      return ((smoothedHeading % 360) + 360) % 360
    }

    return newHeading
  }

  // Smooth velocity values
  smoothVelocity(vx, vy) {
    const speed = Math.sqrt(vx * vx + vy * vy)

    this.velocityBuffer.push(speed)
    while (this.velocityBuffer.length > this.velocityBufferSize) {
      this.velocityBuffer.shift()
    }

    if (this.velocityBuffer.length < 2) {
      return { vx, vy }
    }

    // Calculate median velocity to filter outliers
    if (this.velocityBuffer.length >= 3) {
      const sortedVelocities = [...this.velocityBuffer].sort((a, b) => a - b)
      const medianVelocity = sortedVelocities[Math.floor(sortedVelocities.length / 2)]

      const currentVelocity = speed

      // If current velocity is drastically different from median, scale it
      if (currentVelocity > medianVelocity * 2) {
        const scale = (medianVelocity * 2) / currentVelocity
        vx *= scale
        vy *= scale
      }
    }

    return { vx, vy }
  }

  // Adjust process noise based on accuracy, motion, and device capabilities
  adjustProcessNoise(accuracy, motionDetected) {
    // Update accuracy buffer and check if accuracy is improving
    this.updateAccuracyBuffer(accuracy)

    // Update motion detection state
    this.motionDetected = motionDetected
    if (motionDetected) {
      this.motionConfidence = Math.min(1.0, this.motionConfidence + 0.1)
    } else {
      this.motionConfidence = Math.max(0.0, this.motionConfidence - 0.05)
    }

    // Base noise level depends on GPS accuracy
    let noiseLevel =
      this.adaptiveNoiseMin + (this.adaptiveNoiseMax - this.adaptiveNoiseMin) * Math.min(1.0, accuracy / 30.0)

    // Reduce noise when stationary
    if (this.stationaryMode) {
      noiseLevel *= 0.03
    }

    // Increase noise when motion is detected
    if (this.motionDetected && !this.stationaryMode) {
      noiseLevel *= 1.0 + this.motionConfidence
    }

    // Adjust based on accuracy trend
    if (this.isAccuracyImproving) {
      noiseLevel *= 0.9
    } else {
      noiseLevel *= 1.1
    }

    // Apply adaptive factor
    noiseLevel *= this.adaptiveNoiseFactor

    // Set process noise
    this.Q = noiseLevel

    return this
  }

  // Update the filter with new measurement
  update(position, motionDetected = false) {
    if (!this.initialized) {
      this.reset(position)
      return position
    }

    if (!position || typeof position.lat !== "number" || typeof position.lng !== "number") {
      console.warn("Invalid position input to Kalman filter")
      return {
        lat: this.y,
        lng: this.x,
        accuracy: position?.accuracy || 20,
        heading: this.lastHeading,
        timestamp: position?.timestamp || Date.now(),
      }
    }

    // If we're in stationary mode and have a locked position, return the locked position
    if (this.stationaryMode && this.stationaryLocked && this.stationaryPosition) {
      return {
        lat: this.stationaryPosition.lat,
        lng: this.stationaryPosition.lng,
        accuracy: position.accuracy,
        heading: this.smoothHeading(position.heading),
        timestamp: position.timestamp,
        speedMPS: 0,
      }
    }

    // Calculate time delta
    const timestamp = position.timestamp || Date.now()
    if (this.lastTimestamp) {
      this.dt = Math.min(Math.max((timestamp - this.lastTimestamp) / 1000, 0.01), 1.0)
    }
    this.lastTimestamp = timestamp

    // Check for jitter
    const isJittering = this.detectJitter(position)

    // Adjust measurement noise based on GPS accuracy and jitter
    const accuracy = position.accuracy || 20
    this.R = Math.max(KALMAN_MEASUREMENT_NOISE_BASE, accuracy / 5)

    // If in stationary mode, increase measurement noise to reduce jitter
    if (this.stationaryMode) {
      this.R *= 5.0
    }

    // If jittering is detected, increase measurement noise significantly
    if (isJittering) {
      this.R *= 10.0
    }

    // Adjust process noise based on accuracy and motion
    this.adjustProcessNoise(accuracy, motionDetected)

    // State transition matrix
    const F = [
      [1, 0, this.dt, 0],
      [0, 1, 0, this.dt],
      [0, 0, 1, 0],
      [0, 0, 0, 1],
    ]

    // Predict step
    // x = F * x
    const predictedX = this.x + this.dt * this.vx
    const predictedY = this.y + this.dt * this.vy
    const predictedVx = this.stationaryMode ? 0 : this.vx
    const predictedVy = this.stationaryMode ? 0 : this.vy

    // P = F * P * F' + Q
    const Q = [
      [(this.Q * this.dt * this.dt * this.dt * this.dt) / 4, 0, (this.Q * this.dt * this.dt * this.dt) / 2, 0],
      [0, (this.Q * this.dt * this.dt * this.dt * this.dt) / 4, 0, (this.Q * this.dt * this.dt * this.dt) / 2],
      [(this.Q * this.dt * this.dt * this.dt) / 2, 0, this.Q * this.dt * this.dt, 0],
      [0, (this.Q * this.dt * this.dt * this.dt) / 2, 0, this.Q * this.dt * this.dt],
    ]

    // Matrix multiplication F * P
    const FP = [
      [
        this.P[0][0] + this.dt * this.P[2][0],
        this.P[0][1] + this.dt * this.P[2][1],
        this.P[0][2] + this.dt * this.P[2][2],
        this.P[0][3] + this.dt * this.P[2][3],
      ],
      [
        this.P[1][0] + this.dt * this.P[3][0],
        this.P[1][1] + this.dt * this.P[3][1],
        this.P[1][2] + this.dt * this.P[3][2],
        this.P[1][3] + this.dt * this.P[3][3],
      ],
      [this.P[2][0], this.P[2][1], this.P[2][2], this.P[2][3]],
      [this.P[3][0], this.P[3][1], this.P[3][2], this.P[3][3]],
    ]

    // Matrix multiplication FP * F'
    const predictedP = [
      [
        FP[0][0] + this.dt * FP[0][2] + Q[0][0],
        FP[0][1] + this.dt * FP[0][3] + Q[0][1],
        FP[0][2] + Q[0][2],
        FP[0][3] + Q[0][3],
      ],
      [
        FP[1][0] + this.dt * FP[1][2] + Q[1][0],
        FP[1][1] + this.dt * FP[1][3] + Q[1][1],
        FP[1][2] + Q[1][2],
        FP[1][3] + Q[1][3],
      ],
      [FP[2][0] + Q[2][0], FP[2][1] + Q[2][1], FP[2][2] + Q[2][2], FP[2][3] + Q[2][3]],
      [FP[3][0] + Q[3][0], FP[3][1] + Q[3][1], FP[3][2] + Q[3][2], FP[3][3] + Q[3][3]],
    ]

    // Update step
    // y = z - H * x
    const measurementResidualX = position.lng - predictedX
    const measurementResidualY = position.lat - predictedY

    // Track innovation to detect filter divergence
    const innovation = Math.sqrt(
      measurementResidualX * measurementResidualX + measurementResidualY * measurementResidualY,
    )
    this.updateInnovationBuffer(innovation)

    // S = H * P * H' + R
    const S = [
      [predictedP[0][0] + this.R, predictedP[0][1]],
      [predictedP[1][0], predictedP[1][1] + this.R],
    ]

    // Calculate determinant of S
    const detS = S[0][0] * S[1][1] - S[0][1] * S[1][0]

    // Calculate inverse of S
    const invS = [
      [S[1][1] / detS, -S[0][1] / detS],
      [-S[1][0] / detS, S[0][0] / detS],
    ]

    // K = P * H' * inv(S)
    const K = [
      [
        predictedP[0][0] * invS[0][0] + predictedP[0][1] * invS[1][0],
        predictedP[0][0] * invS[0][1] + predictedP[0][1] * invS[1][1],
      ],
      [
        predictedP[1][0] * invS[0][0] + predictedP[1][1] * invS[1][0],
        predictedP[1][0] * invS[0][1] + predictedP[1][1] * invS[1][1],
      ],
      [
        predictedP[2][0] * invS[0][0] + predictedP[2][1] * invS[1][0],
        predictedP[2][0] * invS[0][1] + predictedP[2][1] * invS[1][1],
      ],
      [
        predictedP[3][0] * invS[0][0] + predictedP[3][1] * invS[1][0],
        predictedP[3][0] * invS[0][1] + predictedP[3][1] * invS[1][1],
      ],
    ]

    // x = x + K * y
    this.x = predictedX + K[0][0] * measurementResidualX + K[0][1] * measurementResidualY
    this.y = predictedY + K[1][0] * measurementResidualX + K[1][1] * measurementResidualY

    // In stationary mode, keep velocity at zero
    if (this.stationaryMode) {
      this.vx = 0
      this.vy = 0
    } else {
      this.vx = predictedVx + K[2][0] * measurementResidualX + K[2][1] * measurementResidualY
      this.vy = predictedVy + K[3][0] * measurementResidualX + K[3][1] * measurementResidualY

      // Smooth velocity
      const smoothedVelocity = this.smoothVelocity(this.vx, this.vy)
      this.vx = smoothedVelocity.vx
      this.vy = smoothedVelocity.vy
    }

    // P = (I - K * H) * P
    this.P = [
      [
        predictedP[0][0] - (K[0][0] * predictedP[0][0] + K[0][1] * predictedP[1][0]),
        predictedP[0][1] - (K[0][0] * predictedP[0][1] + K[0][1] * predictedP[1][1]),
        predictedP[0][2] - (K[0][0] * predictedP[0][2] + K[0][1] * predictedP[1][2]),
        predictedP[0][3] - (K[0][0] * predictedP[0][3] + K[0][1] * predictedP[1][3]),
      ],
      [
        predictedP[1][0] - (K[1][0] * predictedP[0][0] + K[1][1] * predictedP[1][0]),
        predictedP[1][1] - (K[1][0] * predictedP[0][1] + K[1][1] * predictedP[1][1]),
        predictedP[1][2] - (K[1][0] * predictedP[0][2] + K[1][1] * predictedP[1][2]),
        predictedP[1][3] - (K[1][0] * predictedP[0][3] + K[1][1] * predictedP[1][3]),
      ],
      [
        predictedP[2][0] - (K[2][0] * predictedP[0][0] + K[2][1] * predictedP[1][0]),
        predictedP[2][1] - (K[2][0] * predictedP[0][1] + K[2][1] * predictedP[1][1]),
        predictedP[2][2] - (K[2][0] * predictedP[0][2] + K[2][1] * predictedP[1][2]),
        predictedP[2][3] - (K[2][0] * predictedP[0][3] + K[2][1] * predictedP[1][3]),
      ],
      [
        predictedP[3][0] - (K[3][0] * predictedP[0][0] + K[3][1] * predictedP[1][0]),
        predictedP[3][1] - (K[3][0] * predictedP[0][1] + K[3][1] * predictedP[1][1]),
        predictedP[3][2] - (K[3][0] * predictedP[0][2] + K[3][1] * predictedP[1][2]),
        predictedP[3][3] - (K[3][0] * predictedP[0][3] + K[3][1] * predictedP[1][3]),
      ],
    ]

    // Process heading data
    const smoothedHeading = this.smoothHeading(position.heading)
    this.lastHeading = smoothedHeading

    // Calculate speed from velocity components
    const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy)

    // Create filtered position
    const filteredPosition = {
      lat: this.y,
      lng: this.x,
      accuracy: position.accuracy,
      heading: smoothedHeading,
      timestamp: position.timestamp,
      speedMPS: this.stationaryMode ? 0 : speed * 111000, // Convert from degrees/second to meters/second (approximate)
    }

    // If we're in stationary mode and don't have a locked position yet,
    // check if we should lock the position
    if (this.stationaryMode && !this.stationaryLocked && this.stationaryStartTime) {
      // If we've been stationary for a while, lock the position
      if (Date.now() - this.stationaryStartTime > 2000) {
        this.lockStationaryPosition(filteredPosition)
      }
    }

    return filteredPosition
  }
}

// Position interpolator for smooth transitions
class PositionInterpolator {
  constructor() {
    this.startPosition = null
    this.targetPosition = null
    this.startTime = null
    this.duration = 0
    this.isActive = false
    this.lastInterpolatedPosition = null
    this.interpolationMethod = "cubic" // "cubic", "linear", "spring"
    this.springParams = {
      stiffness: 100,
      damping: 10,
      mass: 1,
    }
  }

  setInterpolationMethod(method, params = {}) {
    this.interpolationMethod = method

    if (method === "spring" && params) {
      this.springParams.stiffness = params.stiffness || 100
      this.springParams.damping = params.damping || 10
      this.springParams.mass = params.mass || 1
    }

    return this
  }

  start(startPos, targetPos, duration) {
    if (!startPos || !targetPos) return this

    this.startPosition = { ...startPos }
    this.targetPosition = { ...targetPos }
    this.startTime = performance.now()
    this.duration = duration
    this.isActive = true

    // For spring animation, we need initial velocity
    if (this.interpolationMethod === "spring") {
      this.velocity = {
        lat: 0,
        lng: 0,
      }
      this.lastUpdateTime = this.startTime
    }

    return this
  }

  update() {
    if (!this.isActive) return null

    const now = performance.now()
    const elapsed = now - this.startTime

    if (elapsed >= this.duration && this.interpolationMethod !== "spring") {
      this.isActive = false
      this.lastInterpolatedPosition = { ...this.targetPosition }
      return this.targetPosition
    }

    let interpolatedPosition

    switch (this.interpolationMethod) {
      case "linear":
        interpolatedPosition = this.linearInterpolation(elapsed / this.duration)
        break
      case "spring":
        interpolatedPosition = this.springInterpolation(now)
        // Check if spring has settled
        const distToTarget = calculateDistance(interpolatedPosition, this.targetPosition)
        if (distToTarget < 0.1 && Math.abs(this.velocity.lat) < 0.0001 && Math.abs(this.velocity.lng) < 0.0001) {
          this.isActive = false
        }
        break
      case "cubic":
      default:
        interpolatedPosition = this.cubicInterpolation(elapsed / this.duration)
        break
    }

    this.lastInterpolatedPosition = interpolatedPosition
    return interpolatedPosition
  }

  // Linear interpolation
  linearInterpolation(t) {
    // Clamp t between 0 and 1
    t = Math.max(0, Math.min(1, t))

    return {
      lat: this.startPosition.lat + (this.targetPosition.lat - this.startPosition.lat) * t,
      lng: this.startPosition.lng + (this.targetPosition.lng - this.startPosition.lng) * t,
      accuracy: this.targetPosition.accuracy,
      heading: this.targetPosition.heading,
      timestamp: performance.now(),
      speedMPS: this.targetPosition.speedMPS,
    }
  }

  // Cubic easing function for smoother motion
  cubicInterpolation(t) {
    // Clamp t between 0 and 1
    t = Math.max(0, Math.min(1, t))

    // Apply easing
    const easedT = this.easeOutCubic(t)

    return {
      lat: this.startPosition.lat + (this.targetPosition.lat - this.startPosition.lat) * easedT,
      lng: this.startPosition.lng + (this.targetPosition.lng - this.startPosition.lng) * easedT,
      accuracy: this.targetPosition.accuracy,
      heading: this.interpolateHeading(this.startPosition.heading, this.targetPosition.heading, easedT),
      timestamp: performance.now(),
      speedMPS: this.targetPosition.speedMPS,
    }
  }

  // Spring-based physics interpolation
  springInterpolation(now) {
    const dt = (now - this.lastUpdateTime) / 1000 // Convert to seconds
    this.lastUpdateTime = now

    // Spring physics parameters
    const k = this.springParams.stiffness
    const b = this.springParams.damping
    const m = this.springParams.mass

    // Calculate spring force for latitude and longitude
    const forceLatSpring = -k * (this.lastInterpolatedPosition.lat - this.targetPosition.lat)
    const forceLngSpring = -k * (this.lastInterpolatedPosition.lng - this.targetPosition.lng)

    // Calculate damping force
    const forceLatDamping = -b * this.velocity.lat
    const forceLngDamping = -b * this.velocity.lng

    // Calculate total force
    const totalForceLat = forceLatSpring + forceLatDamping
    const totalForceLng = forceLngSpring + forceLngDamping

    // Calculate acceleration (F = ma, so a = F/m)
    const accLat = totalForceLat / m
    const accLng = totalForceLng / m

    // Update velocity (v = v0 + a*t)
    this.velocity.lat += accLat * dt
    this.velocity.lng += accLng * dt

    // Update position (x = x0 + v*t)
    const newLat = this.lastInterpolatedPosition.lat + this.velocity.lat * dt
    const newLng = this.lastInterpolatedPosition.lng + this.velocity.lng * dt

    return {
      lat: newLat,
      lng: newLng,
      accuracy: this.targetPosition.accuracy,
      heading: this.interpolateHeading(this.lastInterpolatedPosition.heading, this.targetPosition.heading, 0.1),
      timestamp: now,
      speedMPS: this.targetPosition.speedMPS,
    }
  }

  // Interpolate heading (special case due to circular nature)
  interpolateHeading(startHeading, endHeading, t) {
    if (startHeading === null || endHeading === null) {
      return endHeading
    }

    // Normalize headings to 0-360
    startHeading = ((startHeading % 360) + 360) % 360
    endHeading = ((endHeading % 360) + 360) % 360

    // Find the shortest path around the circle
    let diff = endHeading - startHeading
    if (diff > 180) diff -= 360
    if (diff < -180) diff += 360

    // Interpolate
    const result = (startHeading + diff * t) % 360
    return result < 0 ? result + 360 : result
  }

  // Cubic easing function
  easeOutCubic(t) {
    return 1 - Math.pow(1 - t, 3)
  }

  // Smoother Hermite easing function with configurable smoothness
  easeHermite(t, smoothness = 0) {
    // Clamp t between 0 and 1
    t = Math.max(0, Math.min(1, t))

    // Apply Hermite interpolation with smoothness parameter
    return t * t * (3 - 2 * t - smoothness * (t - 1) * t)
  }

  isInterpolating() {
    return this.isActive
  }

  cancel() {
    this.isActive = false
    return this
  }

  getLastPosition() {
    return this.lastInterpolatedPosition || this.targetPosition || this.startPosition
  }
}

// Adaptive Kalman Filter Factory
class AdaptiveKalmanFilterFactory {
  static createForDevice(deviceInfo) {
    const filter = new KalmanFilter()

    // Configure based on device type and capabilities
    if (deviceInfo) {
      // Set device capabilities
      filter.setDeviceCapabilities(
        deviceInfo.highAccuracySupported || true,
        deviceInfo.motionSensorsAvailable || true,
        deviceInfo.orientationSensorsAvailable || true,
      )

      // Set receiver type based on device
      if (deviceInfo.gnssType) {
        filter.setReceiverType(deviceInfo.gnssType)
      }

      // Set environment type if known
      if (deviceInfo.environment) {
        filter.setEnvironmentType(deviceInfo.environment)
      }
    }

    return filter
  }

  static createFilterAndInterpolator(deviceInfo, interpolationMethod = "cubic") {
    const filter = this.createForDevice(deviceInfo)
    const interpolator = new PositionInterpolator().setInterpolationMethod(interpolationMethod)

    return {
      filter,
      interpolator,

      // Convenience method to update and interpolate in one step
      update(position, motionDetected = false, interpolationDuration = 300) {
        // First update the filter
        const filteredPosition = filter.update(position, motionDetected)

        // Then start interpolation to the new filtered position
        if (!interpolator.isInterpolating()) {
          const startPos = interpolator.getLastPosition() || position
          interpolator.start(startPos, filteredPosition, interpolationDuration)
        } else {
          // Update target while keeping the interpolation
          interpolator.targetPosition = filteredPosition
        }

        // Return the current interpolated position
        return interpolator.update() || filteredPosition
      },
    }
  }
}

// DOM update manager - batch DOM updates for better performance
const domUpdateManager = {
  updates: new Map(),
  scheduled: false,

  // Schedule a DOM update
  schedule(id, updateFn) {
    this.updates.set(id, updateFn)

    if (!this.scheduled) {
      this.scheduled = true
      requestAnimationFrame(() => this.flush())
    }
  },

  // Flush all scheduled DOM updates
  flush() {
    this.updates.forEach((updateFn) => updateFn())
    this.updates.clear()
    this.scheduled = false
  },
}

// Create tracking system with optimized filter and interpolator
const tracking = AdaptiveKalmanFilterFactory.createFilterAndInterpolator(
  {
    highAccuracySupported: true,
    motionSensorsAvailable: true,
    orientationSensorsAvailable: true,
    gnssType: "GPS_GLONASS",
    environment: "urban",
  },
  "cubic",
)

// Calculate appropriate zoom level based on speed
function calculateZoomLevel(speedMPS) {
  // Update current speed for global access
  currentSpeed = speedMPS

  // Determine zoom level based on speed
  let zoomLevel
  if (isStationary || speedMPS < 0.5) {
    // Stationary or very slow movement
    zoomLevel = MAX_ZOOM_LEVEL
  } else if (speedMPS < WALKING_SPEED_THRESHOLD) {
    // Walking speed
    zoomLevel = WALKING_ZOOM_LEVEL
  } else if (speedMPS < RUNNING_SPEED_THRESHOLD) {
    // Running speed - linear interpolation between walking and running zoom levels
    const t = (speedMPS - WALKING_SPEED_THRESHOLD) / (RUNNING_SPEED_THRESHOLD - WALKING_SPEED_THRESHOLD)
    zoomLevel = WALKING_ZOOM_LEVEL - t
  } else if (speedMPS < DRIVING_SPEED_THRESHOLD) {
    // Driving speed - linear interpolation between running and driving zoom levels
    const t = (speedMPS - RUNNING_SPEED_THRESHOLD) / (DRIVING_SPEED_THRESHOLD - RUNNING_SPEED_THRESHOLD)
    zoomLevel = WALKING_ZOOM_LEVEL - 1 - t
  } else {
    // High speed
    zoomLevel = MIN_ZOOM_LEVEL
  }

  // Smooth zoom level changes
  if (lastZoomLevel !== null) {
    // Apply smoothing to avoid abrupt zoom changes
    zoomLevel = lastZoomLevel * 0.85 + zoomLevel * 0.15 // More responsive zoom changes
  }

  // Round to one decimal place for smoother transitions
  zoomLevel = Math.round(zoomLevel * 10) / 10

  // Clamp to valid zoom range
  zoomLevel = Math.max(MIN_ZOOM_LEVEL, Math.min(MAX_ZOOM_LEVEL, zoomLevel))

  // Update last zoom level
  lastZoomLevel = zoomLevel

  return zoomLevel
}

// Enhanced stationary position calculation
function calculateStationaryPosition(buffer) {
  if (!buffer || buffer.length === 0) {
    return null
  }

  // Sort by accuracy (best first)
  const sortedBuffer = [...buffer].sort((a, b) => a.accuracy - b.accuracy)

  // Take weighted average of best positions
  const topPositions = sortedBuffer.slice(0, Math.ceil(buffer.length / 2))

  const weights = topPositions.map((pos) => 1 / Math.max(1, pos.accuracy))
  const totalWeight = weights.reduce((sum, w) => sum + w, 0)

  if (totalWeight === 0) {
    return sortedBuffer[0]
  }

  // Calculate weighted average
  const avgPosition = {
    lat: topPositions.reduce((sum, pos, i) => sum + pos.lat * weights[i], 0) / totalWeight,
    lng: topPositions.reduce((sum, pos, i) => sum + pos.lng * weights[i], 0) / totalWeight,
    accuracy: topPositions[0].accuracy,
    heading: topPositions[0].heading,
    timestamp: Date.now(),
    speedMPS: 0,
  }

  // If we have a previous stationary position, blend with it for stability
  if (lastStationaryPosition) {
    const blendFactor = 0.9 // Reduced to 90% previous, 10% new for more responsive updates
    return {
      lat: lastStationaryPosition.lat * blendFactor + avgPosition.lat * (1 - blendFactor),
      lng: lastStationaryPosition.lng * blendFactor + avgPosition.lng * (1 - blendFactor),
      accuracy: avgPosition.accuracy,
      heading: avgPosition.heading,
      timestamp: avgPosition.timestamp,
      speedMPS: 0,
    }
  }

  return avgPosition
}

// Update stationary position history
function updateStationaryHistory(position) {
  // Add new position to history
  stationaryPositionHistory.push(position)

  // Keep history at maximum size
  while (stationaryPositionHistory.length > STATIONARY_POSITION_HISTORY_SIZE) {
    stationaryPositionHistory.shift()
  }

  // Calculate weighted average of positions
  let totalWeight = 0
  let weightedLat = 0
  let weightedLng = 0

  // Newer positions have higher weight
  for (let i = 0; i < stationaryPositionHistory.length; i++) {
    const pos = stationaryPositionHistory[i]
    const weight = Math.pow(STATIONARY_POSITION_WEIGHT_DECAY, stationaryPositionHistory.length - i - 1)
    totalWeight += weight
    weightedLat += pos.lat * weight
    weightedLng += pos.lng * weight
  }

  return {
    lat: weightedLat / totalWeight,
    lng: weightedLng / totalWeight,
    accuracy: position.accuracy,
    heading: position.heading,
    timestamp: position.timestamp,
    speedMPS: 0,
  }
}

// Check if device is in motion based on motion sensors
function isDeviceInMotion() {
  if (!motionSamples || motionSamples.length < 3) {
    return false
  }

  // Calculate average motion magnitude
  const avgMotion =
    motionSamples.reduce((sum, sample) => {
      return sum + Math.sqrt(sample.x * sample.x + sample.y * sample.y + sample.z * sample.z)
    }, 0) / motionSamples.length

  return avgMotion > MOTION_THRESHOLD
}

// Process device motion data
function handleDeviceMotion(event) {
  if (!event || !event.acceleration) return

  const motion = {
    x: event.acceleration.x || 0,
    y: event.acceleration.y || 0,
    z: event.acceleration.z || 0,
    timestamp: Date.now(),
  }

  // Add to motion samples
  motionSamples.push(motion)

  // Keep only recent samples
  while (motionSamples.length > MOTION_SAMPLE_SIZE) {
    motionSamples.shift()
  }

  // Update device motion state
  deviceMotion = motion

  // Check if device is stationary based on motion
  const inMotion = isDeviceInMotion()

  if (!inMotion) {
    deviceStationaryTime += MOTION_CHECK_INTERVAL
  } else {
    deviceStationaryTime = 0
  }
}

// Process device orientation data
function handleDeviceOrientation(event) {
  if (!event || event.alpha === null) return

  deviceOrientation = {
    alpha: event.alpha, // z-axis rotation [0,360)
    beta: event.beta, // x-axis rotation [-180,180)
    gamma: event.gamma, // y-axis rotation [-90,90)
    timestamp: Date.now(),
  }

  // Update heading buffer if we have a compass heading
  if (event.webkitCompassHeading !== undefined) {
    const heading = event.webkitCompassHeading

    // Add to heading buffer
    headingBuffer.push(heading)

    // Keep only recent headings
    while (headingBuffer.length > 5) {
      headingBuffer.shift()
    }

    // Calculate median heading to filter outliers
    if (headingBuffer.length >= 3) {
      const sortedHeadings = [...headingBuffer].sort((a, b) => a - b)
      lastHeadingValue = sortedHeadings[Math.floor(sortedHeadings.length / 2)]
    }
  }
}

// Request device motion and orientation permissions
function requestMotionPermission() {
  if (typeof DeviceMotionEvent !== "undefined" && typeof DeviceMotionEvent.requestPermission === "function") {
    DeviceMotionEvent.requestPermission()
      .then((response) => {
        if (response === "granted") {
          window.addEventListener("devicemotion", handleDeviceMotion, true)
        }
      })
      .catch(console.error)
  } else {
    window.addEventListener("devicemotion", handleDeviceMotion, true)
  }

  if (typeof DeviceOrientationEvent !== "undefined" && typeof DeviceOrientationEvent.requestPermission === "function") {
    DeviceOrientationEvent.requestPermission()
      .then((response) => {
        if (response === "granted") {
          orientationPermissionGranted = true
          window.addEventListener("deviceorientation", handleDeviceOrientation, true)
        }
      })
      .catch(console.error)
  } else {
    window.addEventListener("deviceorientation", handleDeviceOrientation, true)
    orientationPermissionGranted = true
  }
}

// Image preloading function
function preloadImages(locations) {
  return new Promise((resolve) => {
    if (!locations || locations.length === 0) {
      resolve()
      return
    }

    const totalImages = locations.length
    let loadedImages = 0
    const progressBar = document.getElementById("preloaderProgress")

    locations.forEach((location, index) => {
      if (!location.image) {
        loadedImages++
        updateProgress()
        if (loadedImages === totalImages) resolve()
        return
      }

      // Skip if already preloaded
      if (preloadedImages.has(location.image)) {
        loadedImages++
        updateProgress()
        if (loadedImages === totalImages) resolve()
        return
      }

      const img = new Image()
      img.crossOrigin = "anonymous" // Set crossOrigin for canvas operations
      img.onload = () => {
        preloadedImages.set(location.image, img)
        loadedImages++
        updateProgress()
        if (loadedImages === totalImages) resolve()
      }

      img.onerror = () => {
        console.warn(`Failed to load image: ${location.image}`)
        loadedImages++
        updateProgress()
        if (loadedImages === totalImages) resolve()
      }

      img.src = location.image
    })

    // Also preload audio files
    locations.forEach((location) => {
      if (location.audio && !preloadedAudio.has(location.audio)) {
        const audio = new Audio()
        audio.preload = "auto"
        audio.oncanplaythrough = () => {
          preloadedAudio.set(location.audio, audio)
        }
        audio.src = location.audio
      }
    })

    function updateProgress() {
      const percent = (loadedImages / totalImages) * 100
      domUpdateManager.schedule("preloaderProgress", () => {
        if (progressBar) {
          progressBar.style.width = `${percent}%`
        }
      })
    }
  })
}

// Detect sudden movements or position jumps
function detectSuddenMovement(newPosition, lastPosition) {
  if (!lastPosition || !newPosition) return false

  const distance = calculateDistance(lastPosition, newPosition)
  const timeDelta = (newPosition.timestamp - lastPosition.timestamp) / 1000 // seconds

  // If time delta is too small, consider it a valid update
  if (timeDelta < 0.05) return false

  // Calculate speed in meters per second
  const speed = distance / timeDelta

  // Check for unrealistic speeds (teleportation)
  if (speed > 40) {
    // Reduced from 50 to 40 m/s for more sensitive jump detection
    console.log(`Position jump detected: ${distance.toFixed(2)}m in ${timeDelta.toFixed(2)}s (${speed.toFixed(2)} m/s)`)
    return true
  }

  // Check for sudden movements when stationary
  if (isStationary && distance > POSITION_JUMP_THRESHOLD) {
    console.log(`Sudden movement detected while stationary: ${distance.toFixed(2)}m`)
    return true
  }

  // Check for small sudden movements (jitter)
  if (isStationary && distance > SUDDEN_MOVEMENT_THRESHOLD) {
    suddenMovementCount++
    if (suddenMovementCount >= 2) {
      console.log(`Multiple sudden movements detected: ${distance.toFixed(2)}m`)
      return true
    }
  } else {
    suddenMovementCount = 0
  }

  return false
}

// Check proximity to locations and adjust zoom accordingly
function checkLocationProximity() {
    const now = Date.now();
    
    // Don't check too frequently
    if (now - lastProximityCheck < 1000) return;
    lastProximityCheck = now;
    
    // Don't check if zoom was recently changed
    if (now - lastZoomChangeTime < ZOOM_CHANGE_COOLDOWN) return;
    
    if (!userMarker || !gameLocations || gameLocations.length === 0) return;
    
    const userLatLng = userMarker.getLatLng();
    
    // Validate user coordinates
    if (!userLatLng || typeof userLatLng.lat !== 'number' || typeof userLatLng.lng !== 'number' || 
        isNaN(userLatLng.lat) || isNaN(userLatLng.lng)) {
        console.warn("Invalid user coordinates for proximity check");
        return;
    }
    
    const userPos = { lat: userLatLng.lat, lng: userLatLng.lng };
    
    // Find closest location
    let closestDistance = Infinity;
    let closestLocation = null;
    
    for (const location of gameLocations) {
        if (!location || typeof location.lat !== 'number' || typeof location.lng !== 'number' || 
            isNaN(location.lat) || isNaN(location.lng)) {
            continue;
        }
        
        const locationPos = { lat: location.lat, lng: location.lng };
        const distance = calculateDistance(userPos, locationPos);
        
        if (isFinite(distance) && distance < closestDistance) {
            closestDistance = distance;
            closestLocation = location;
        }
    }
    
    // If no valid locations found, exit
    if (!closestLocation || !isFinite(closestDistance)) {
        return;
    }
    
    // Convert to feet for threshold comparison
    const distanceFeet = Math.round(closestDistance * 3.28084);

    // Constants for hysteresis and thresholds
    const HYSTERESIS_FACTOR = 1.1; // 10% buffer to prevent rapid toggling
    const ZOOM_IN_THRESHOLD = PROXIMITY_THRESHOLD * 0.9; // 90% of PROXIMITY_THRESHOLD
    const ZOOM_OUT_THRESHOLD = PROXIMITY_THRESHOLD * 1.1; // 110% of PROXIMITY_THRESHOLD

    // Check if we need to adjust zoom based on proximity
    if (distanceFeet <= ZOOM_IN_THRESHOLD) {
        // If we weren't near a location before, zoom in
        if (!isNearLocation && Math.abs(lastProximityDistance - closestDistance) > 1) {
            console.log(`User is now within ${ZOOM_IN_THRESHOLD.toFixed(1)} feet of a location, zooming in`);
            isNearLocation = true;
            lastZoomChangeTime = now;

            // Calculate new zoom level (clamped to MAX_ZOOM_LEVEL)
            const currentZoom = map.getZoom();
            const newZoom = Math.min(currentZoom + 1, MAX_ZOOM_LEVEL);

            // Apply zoom change with smooth animation
            map.setZoom(newZoom, {
                animate: true,
                duration: ZOOM_TRANSITION_DURATION
            });
        }
    } else if (distanceFeet >= ZOOM_OUT_THRESHOLD && isNearLocation) {
        // If we were near a location but now we're not, zoom out
        console.log(`User is now outside ${ZOOM_OUT_THRESHOLD.toFixed(1)} feet of a location, zooming out`);
        isNearLocation = false;
        lastZoomChangeTime = now;

        // Calculate new zoom level (clamped to MIN_ZOOM_LEVEL)
        const currentZoom = map.getZoom();
        const newZoom = Math.max(currentZoom - 1, MIN_ZOOM_LEVEL);

        // Apply zoom change with smooth animation
        map.setZoom(newZoom, {
            animate: true,
            duration: ZOOM_TRANSITION_DURATION
        });
    }
    
    // Update last proximity distance
    lastProximityDistance = closestDistance;
}

function initMap() {
  // L variable was undeclared. Please fix the import or declare the variable before using it.
  // Declaring L here
  const L = window.L

  map = L.map("map", {
    zoomControl: false,
    attributionControl: false,
    zoomSnap: 0.1,
    zoomDelta: 0.5,
    wheelDebounceTime: 100,
    tapTolerance: 15,
    bounceAtZoomLimits: false,
    preferCanvas: true, // Use canvas renderer for better performance
    renderer: L.canvas({ padding: 0.5 }),
  }).fitWorld()

  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    maxZoom: 19,
    attribution: " OpenStreetMap contributors",
    updateWhenIdle: true,
    updateWhenZooming: false,
    keepBuffer: 2,
  }).addTo(map)

  markerClusterGroup = L.markerClusterGroup({
    showCoverageOnHover: false,
    zoomToBoundsOnClick: true,
    spiderfyOnMaxZoom: true,
    animate: true,
    animateAddingMarkers: true,
    disableClusteringAtZoom: 17,
    maxClusterRadius: 60,
    iconCreateFunction: (cluster) =>
      L.divIcon({
        html: "<div><span>" + cluster.getChildCount() + "</span></div>",
        className: "marker-cluster-custom",
        iconSize: L.point(40, 40),
      }),
  })
  map.addLayer(markerClusterGroup)

    // Create user icon with custom styling (red)
    const userIcon = L.divIcon({
        className: 'user-marker',
        html: '<div class="user-marker-icon"></div>',
        iconSize: [20, 20],
        iconAnchor: [10, 10]
    });
    userMarker = L.marker([0, 0], { 
        icon: userIcon,
        zIndexOffset: 1000, // Ensure user marker is on top
        interactive: false // Prevent marker from being clickable
    }).addTo(map);

  // Store map viewport dimensions
  updateMapViewportDimensions()

  showLoadingMessage()

  // Request motion and orientation permissions
  requestMotionPermission()

  // Try to use Geolocation Sensor API first, then fall back to standard Geolocation API
  initGeolocation()

  document.addEventListener("visibilitychange", handleVisibilityChange)

  map.on("movestart zoomstart", () => {
    followUser = false
    isMapInteracting = true
  })

  map.on("moveend zoomend", () => {
    isMapInteracting = false
    resetInactivityTimer()
    updateMapViewportDimensions()
  })

  // Listen for resize events to update viewport dimensions
  window.addEventListener("resize", updateMapViewportDimensions)

  // Start animation loop for smooth rendering
  startAnimationLoop()

  // Enable touch interactions
  map.touchZoom.enable()
  map.doubleClickZoom.enable()

  // Add CSS for user marker direction indicator
  addUserMarkerStyles()
}

// Add CSS styles for user marker direction indicator
function addUserMarkerStyles() {
  const style = document.createElement("style")
  style.textContent = `
        .user-marker-icon {
            width: 16px;
            height: 16px;
            background-color: #ff3b30;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            position: relative;
        }
        
        .user-marker-direction {
            position: absolute;
            top: -4px;
            left: 50%;
            margin-left: -2px;
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-bottom: 12px solid #ff3b30;
            transform-origin: center bottom;
            z-index: -1;
        }
        
        .user-marker-icon.pulsing {
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(1.2);
                opacity: 0.8;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }
    `
  document.head.appendChild(style)
}

// Initialize geolocation with priority for Geolocation Sensor API
function initGeolocation() {
  // GeolocationSensor variable was undeclared. Please fix the import or declare the variable before using it.
  // Declaring GeolocationSensor here
  const GeolocationSensor = window.GeolocationSensor

  if ("GeolocationSensor" in window) {
    try {
      console.log("Trying GeolocationSensor API")
      geolocationSensor = new GeolocationSensor({ frequency: 1 })

      geolocationSensor.addEventListener("reading", () => {
        const position = {
          coords: {
            latitude: geolocationSensor.latitude,
            longitude: geolocationSensor.longitude,
            accuracy: geolocationSensor.accuracy,
            altitude: geolocationSensor.altitude,
            altitudeAccuracy: geolocationSensor.altitudeAccuracy,
            heading: geolocationSensor.heading,
            speed: geolocationSensor.speed,
          },
          timestamp: geolocationSensor.timestamp,
        }

        if (!lastPosition) {
          initializeUserLocation(position)
        } else {
          handlePositionUpdate(position)
        }
      })

      geolocationSensor.addEventListener("error", (error) => {
        console.warn("GeolocationSensor error:", error)
        // Fall back to standard Geolocation API
        useStandardGeolocation()
      })

      geolocationSensor.start()
      usingGeolocationSensorAPI = true
      console.log("Using GeolocationSensor API")
    } catch (error) {
      console.warn("GeolocationSensor error:", error)
      // Fall back to standard Geolocation API
      useStandardGeolocation()
    }
  } else {
    // Fall back to standard Geolocation API
    useStandardGeolocation()
  }
}

// Update map viewport dimensions
function updateMapViewportDimensions() {
  if (map && map._container) {
    mapViewportWidth = map._container.clientWidth
    mapViewportHeight = map._container.clientHeight

    // Store current map center and zoom
    if (map.getCenter()) {
      lastMapCenter = map.getCenter()
      lastMapZoom = map.getZoom()
    }
  }
}

// Standard Geolocation API fallback
function useStandardGeolocation() {
  console.log("Using standard Geolocation API")
  usingGeolocationSensorAPI = false

  if ("geolocation" in navigator) {
    const options = {
      enableHighAccuracy: true,
      timeout: 30000, // Reduced timeout for faster fallback
      maximumAge: 0,
    }

    // Try first time
    navigator.geolocation.getCurrentPosition(
      initializeUserLocation,
      (error) => {
        // On error, try one more time before falling back
        navigator.geolocation.getCurrentPosition(initializeUserLocation, handleLocationError, options)
      },
      options,
    )
  } else {
    showPopup("Geolocation is not supported by your browser")
    map.setView([44.9778, -93.265], 17)
    hideLoadingMessage()
  }
}

// Animation loop for smooth rendering
function startAnimationLoop() {
  function animate(timestamp) {
    // Calculate delta time
    const deltaTime = renderTimestamp ? (timestamp - renderTimestamp) / 1000 : 0
    renderTimestamp = timestamp

    // Process position updates
    processPositionUpdateQueue()

    // Update interpolated position
    if (positionInterpolator && positionInterpolator.isInterpolating()) {
      const interpolatedPosition = positionInterpolator.update()
      if (interpolatedPosition) {
        // Update marker position and rotation
        updateUserMarkerPosition(interpolatedPosition)
        lastRenderPosition = interpolatedPosition
      }
    }

    // Check if marker is near edge and recenter if needed
    if (followUser && !isMapInteracting && !edgeRecenterInProgress) {
      const recenterInfo = shouldRecenter(map, userMarker)
      if (recenterInfo.needsRecenter) {
        performEdgeRecenter(recenterInfo)
      }
    }

    // Check proximity to locations for zoom adjustments
    checkLocationProximity()

    // Request next frame
    animationFrameId = requestAnimationFrame(animate)
  }

  // Start animation loop
  animationFrameId = requestAnimationFrame(animate)
}

// Update user marker position and rotation
function updateUserMarkerPosition(position) {
  if (!userMarker) return

  // Update marker position
  userMarker.setLatLng([position.lat, position.lng])

  // Update marker rotation based on heading if available
  if (position.heading !== undefined && position.heading !== null) {
    // Get the marker element
    const markerElement = userMarker.getElement()
    if (markerElement) {
      // Find the direction indicator element
      const directionElement = markerElement.querySelector(".user-marker-direction")
      if (directionElement) {
        // Update the rotation of the direction indicator
        directionElement.style.transform = `rotate(${position.heading}deg)`
      }
    }
  }

  // Apply visual effects based on speed
  if (position.speedMPS !== undefined) {
    const markerElement = userMarker.getElement()
    if (markerElement) {
      const iconElement = markerElement.querySelector(".user-marker-icon")
      if (iconElement) {
        // Add pulsing effect when moving
        if (position.speedMPS > 0.5) {
          iconElement.classList.add("pulsing")
          // Adjust pulse speed based on movement speed
          const pulseRate = Math.max(0.5, Math.min(2.0, 1.0 + position.speedMPS / 5))
          iconElement.style.animationDuration = `${1 / pulseRate}s`
        } else {
          iconElement.classList.remove("pulsing")
        }
      }
    }
  }
}

// Process position update queue
function processPositionUpdateQueue() {
  if (positionUpdateQueue.length === 0) return

  // Process all updates in queue
  while (positionUpdateQueue.length > 0) {
    const update = positionUpdateQueue.shift()
    processPositionUpdate(update)
  }
}

// Process position update
function processPositionUpdate(position) {
 // Skip if invalid position
 if (!position || typeof position.lat !== "number" || typeof position.lng !== "number") {
   return;
 }
 
 // Update last position
 lastPosition = position;
 
 // Start interpolation to new position
 if (lastRenderPosition && !isFirstPositionUpdate) {
   // Add null check for positionInterpolator
   if (positionInterpolator) {
     positionInterpolator.start(
       lastRenderPosition, 
       position,
       isStationary ? 300 : ANIMATION_DURATION, // Faster animation when stationary
     );
   } else {
     // Fallback to direct position update if interpolator is not available
     console.warn("Position interpolator not available, using direct position update");
     updateUserMarkerPosition(position);
     lastRenderPosition = position;
   }
 } else {
   // First update, just set position directly
   updateUserMarkerPosition(position);
   lastRenderPosition = position;
   isFirstPositionUpdate = false;
 }
 
 // Auto-recenter map if following user
 if (followUser && !isMapInteracting) {
   const recenterInfo = shouldRecenter(map, userMarker);
   if (recenterInfo.needsRecenter) {
     performEdgeRecenter(recenterInfo);
   } else if (Math.abs(map.getZoom() - calculateZoomLevel(position.speedMPS)) > 0.5) {
     // If zoom level should change significantly but no recenter needed
     const newZoom = calculateZoomLevel(position.speedMPS);
     map.setZoom(newZoom, {
       animate: true,
       duration: ZOOM_TRANSITION_DURATION,
     });
   }
 }
}

// Perform edge recentering
function performEdgeRecenter(recenterInfo) {
  edgeRecenterInProgress = true

  // Get current position
  const position = userMarker.getLatLng()

  // Calculate appropriate zoom level based on speed
  const dynamicZoom = calculateZoomLevel(lastPosition?.speedMPS || 0)

  // Calculate optimal center point that keeps the user icon away from edges
  const optimalCenter = calculateOptimalCenter(map, position, recenterInfo.edgeInfo)

  // Set view with animation
  map.setView([optimalCenter.lat, optimalCenter.lng], dynamicZoom, {
    animate: true,
    duration: recenterInfo.isEmergency ? 0.2 : ZOOM_TRANSITION_DURATION,
    noMoveStart: true,
    easeLinearity: 0.5,
  })

  // Reset edge recenter flag after animation completes
  setTimeout(
    () => {
      edgeRecenterInProgress = false
    },
    recenterInfo.isEmergency ? 300 : ZOOM_TRANSITION_DURATION * 1000,
  )
}

function showLoadingMessage() {
    const loadingMessage = document.createElement('div');
    loadingMessage.id = 'loadingMessage';
    loadingMessage.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: rgba(255, 255, 255, 0.9);
        padding: 20px;
        border-radius: 10px;
        z-index: 1000;
        text-align: center;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    `;
    loadingMessage.innerHTML = `
        <div style="margin-bottom: 15px;">
            <div style="width: 40px; height: 40px; border: 4px solid rgba(255, 0, 0, 0.2); border-top: 4px solid #ff0000; border-radius: 50%; margin: 0 auto 15px; animation: spin 1s linear infinite;"></div>
        </div>
        <p style="font-weight: 500; color: #333;">Searching for your location...</p>
    `;
    document.body.appendChild(loadingMessage);
}

function hideLoadingMessage() {
    const loadingMessage = document.getElementById('loadingMessage');
    if (loadingMessage) {
        document.body.removeChild(loadingMessage);
    }
}

function showStabilizingModal() {
  // Hide jitter immediately
  if (userMarker) userMarker.setOpacity(0);

  const modal = document.createElement("div");
  modal.id = "stabilizingModal";
  modal.className = "stabilizing-modal";
  modal.innerHTML = `
    <div class="spinner"></div>
    <h3>Stabilizing Your Location</h3>
    <p>Please wait while we fine-tune your position.</p>
  `;
  document.body.appendChild(modal);

  // Auto-dismiss after 5 seconds
  setTimeout(() => {
    if (userMarker) userMarker.setOpacity(1); // Restore visibility
    const modal = document.getElementById("stabilizingModal");
    if (modal) {
      modal.style.opacity = "0";
      setTimeout(() => modal.remove(), 500);
    }
    isStabilizing = false;
  }, 5000);
}

function initializeUserLocation(position) {
  console.log("Initial position data:", JSON.stringify(position))

  if (!position || !position.coords) {
    console.error("Invalid initial position object")
    handleLocationError(new Error("Invalid initial position"))
    return
  }

  const { latitude: userLat, longitude: userLng, accuracy } = position.coords

  if (isNaN(userLat) || isNaN(userLng)) {
    console.error("Invalid initial coordinates:", { userLat, userLng })
    handleLocationError(new Error("Invalid initial coordinates"))
    return
  }

  console.log("Valid initial position:", { userLat, userLng, accuracy })

  try {
    // Set initial marker position
    updateUserMarkerPosition({
      lat: userLat,
      lng: userLng,
      accuracy: accuracy,
      heading: position.coords.heading,
      timestamp: Date.now(),
      speedMPS: 0,
    })

    map.setView([userLat, userLng], 17)

    // Initialize Kalman filter with first position
    tracking.filter.reset({
      lat: userLat,
      lng: userLng,
      accuracy: accuracy,
      heading: position.coords.heading,
      timestamp: Date.now(),
    })

    // Initialize stationary position
    lastStationaryPosition = {
      lat: userLat,
      lng: userLng,
      accuracy: accuracy,
      heading: position.coords.heading,
      timestamp: Date.now(),
      speedMPS: 0,
    }

    // Initialize last render position
    lastRenderPosition = {
      lat: userLat,
      lng: userLng,
      accuracy: accuracy,
      heading: position.coords.heading,
      timestamp: Date.now(),
      speedMPS: 0,
    }

    // Initialize last valid position
    lastValidPosition = {
      lat: userLat,
      lng: userLng,
      accuracy: accuracy,
      heading: position.coords.heading,
      timestamp: Date.now(),
      speedMPS: 0,
    }

    // Show stabilizing modal
    hideLoadingMessage()
    showStabilizingModal()

    // Start position updates
    startPositionUpdates()
    startHunt()
  } catch (error) {
    console.error("Error setting initial user location:", error)
    handleLocationError(error)
  }
}

function startPositionUpdates() {
  // If already using GeolocationSensor API, don't start again
  if (usingGeolocationSensorAPI) {
    console.log("Position updates already using GeolocationSensor API")
    return
  }

  // Use standard Geolocation API with high frequency updates
  watchPositionId = navigator.geolocation.watchPosition(handlePositionUpdate, handleLocationError, {
    enableHighAccuracy: true,
    maximumAge: 0,
    timeout: 10000,
  })
  isWatchPositionActive = true
  console.log("Position updates using standard Geolocation API")
}

function handlePositionUpdate(position) {
  if (!position?.coords?.latitude || !position?.coords?.longitude) {
    console.warn("Invalid position data received")
    return
  }
  updateUserLocation(position)
}

function handleVisibilityChange() {
  if (document.hidden) {
    lastHiddenTime = Date.now()
    lastKnownPosition = userMarker ? userMarker.getLatLng() : null

    // Cancel any active interpolation
    if (positionInterpolator) {
      positionInterpolator.cancel()
    }

    // Cancel animation frame
    if (animationFrameId) {
      cancelAnimationFrame(animationFrameId)
      animationFrameId = null
    }

    // Stop GeolocationSensor if using it
    if (usingGeolocationSensorAPI && geolocationSensor) {
      geolocationSensor.stop()
    }
  } else {
    const hiddenDuration = Date.now() - lastHiddenTime
    if (hiddenDuration > BACKGROUND_THRESHOLD) {
      updateLocationAfterBackground()
    } else {
      map.invalidateSize()

      // Restart animation loop
      if (!animationFrameId) {
        startAnimationLoop()
      }

      // Restart GeolocationSensor if using it
      if (usingGeolocationSensorAPI && geolocationSensor) {
        geolocationSensor.start()
      }

      // If returning from exhibit, ensure movement resumes properly
      if (isReturningFromExhibit) {
        isReturningFromExhibit = false
        // Force a position update to resume tracking
        if (lastValidPosition) {
          updateUserLocation(
            {
              coords: {
                latitude: lastValidPosition.lat,
                longitude: lastValidPosition.lng,
                accuracy: lastValidPosition.accuracy,
                heading: lastValidPosition.heading,
                speed: lastValidPosition.speedMPS,
              },
              timestamp: Date.now(),
            },
            true,
          )
        }
      }
    }
  }
  resetInactivityTimer()
}

// Fix the updateLocationAfterBackground function
function updateLocationAfterBackground() {
  if ("geolocation" in navigator) {
    navigator.geolocation.getCurrentPosition(
      (position) => {
        console.log("Background update raw position:", JSON.stringify(position))
        if (!position || !position.coords) {
          console.warn("Invalid position object in background update")
          return
        }
        const { latitude, longitude, accuracy } = position.coords
        if (isNaN(latitude) || isNaN(longitude)) {
          console.warn("Invalid coordinates in background update:", { latitude, longitude })
          return
        }

        console.log("Valid background position update:", { lat: latitude, lng: longitude })
        try {
          updateUserLocation(position, true)
        } catch (error) {
          console.error("Error in updateUserLocation during background update:", error)
        }

        // Reset tracking variables
        lastPosition = null
        positionBuffer = []
        velocity = { lat: 0, lng: 0 }
        lastVelocity = { lat: 0, lng: 0 }
        isStationary = false
        stationaryStartTime = null
        stationaryCount = 0
        stationaryPositionHistory = []
        lastStationaryPosition = null
        stationaryPositionLocked = false
        positionHistory = []
        suddenMovementCount = 0
        isJumpDetected = false

        // Reset Kalman filter
        tracking.filter.reset({
          lat: latitude,
          lng: longitude,
          accuracy: accuracy,
          heading: position.coords.heading,
          timestamp: Date.now(),
        })

        // Restart animation loop
        if (!animationFrameId) {
          startAnimationLoop()
        }

        // Restart GeolocationSensor if using it
        if (usingGeolocationSensorAPI && geolocationSensor) {
          geolocationSensor.start()
        }

        updateDistanceBox()
        followUser = true
        map.invalidateSize()
      },
      (error) => {
        console.error("Error getting location after background:", error)
        if (error.code === 3) {
          // If timeout, retry with lower accuracy
          navigator.geolocation.getCurrentPosition(
            (position) => {
              console.log("Retry successful with lower accuracy")
              updateUserLocation(position, true)
            },
            (error) => console.error("Error on retry:", error),
            {
              enableHighAccuracy: false,
              timeout: 20000,
              maximumAge: 30000,
            },
          )
        }
      },
      {
        enableHighAccuracy: true,
        timeout: 10000,
        maximumAge: 0,
      },
    )
  } else {
    console.warn("Geolocation is not available")
  }
}

// Helper function to validate position data
function isValidPosition(pos) {
  return (
    pos &&
    typeof pos.lat === "number" &&
    !isNaN(pos.lat) &&
    typeof pos.lng === "number" &&
    !isNaN(pos.lng) &&
    typeof pos.accuracy === "number" &&
    !isNaN(pos.accuracy)
  )
}

// Linear interpolation helper
function lerp(a, b, t) {
  if (typeof a !== "number" || typeof b !== "number" || typeof t !== "number") {
    return a
  }

  return a + (b - a) * Math.max(0, Math.min(1, t))
}

// Update position buffer with new position
function updatePositionBuffer(position) {
  if (!isValidPosition(position)) {
    return
  }

  // Add new position to buffer
  positionBuffer.push({
    lat: position.lat,
    lng: position.lng,
    accuracy: position.accuracy,
    heading: position.heading,
    timestamp: position.timestamp,
    speedMPS: position.speedMPS,
  })

  // Remove old positions if buffer exceeds maxSize
  while (positionBuffer.length > MAX_BUFFER_SIZE) {
    positionBuffer.shift()
  }
}

// Update position history for jump detection
function updatePositionHistory(position) {
  if (!isValidPosition(position)) {
    return
  }

  // Add new position to history
  positionHistory.push({
    lat: position.lat,
    lng: position.lng,
    accuracy: position.accuracy,
    heading: position.heading,
    timestamp: position.timestamp,
    speedMPS: position.speedMPS,
  })

  // Keep only recent positions
  while (positionHistory.length > 10) {
    positionHistory.shift()
  }
}

// Check stationary state
function checkStationaryState(newPosition) {
  if (!lastPosition) return

  // Calculate distance between current and last position
  const distance = calculateDistance(lastPosition, newPosition)

  // Check if device motion sensors indicate movement
  const motionDetected = isDeviceInMotion()

  // If significant movement is detected or motion sensors indicate activity
  if (distance >= MICRO_MOVEMENT_THRESHOLD || motionDetected) {
    if (isStationary) {
      console.debug("Movement detected, transitioning to moving state")
      isStationary = false
      stationaryStartTime = null
      stationaryPositionLocked = false
      stationaryCount = 0 // Reset stationary count
      tracking.filter.setStationaryMode(false)

      // Clear any stationary lock timeout
      if (stationaryLockTimeout) {
        clearTimeout(stationaryLockTimeout)
        stationaryLockTimeout = null
      }
    }

    // Clear the stationary check timeout
    if (stationaryCheckTimeout) {
      clearTimeout(stationaryCheckTimeout)
      stationaryCheckTimeout = null
    }
  } else {
    // If no significant movement, increment stationary count
    stationaryCount++

    // If stationary count exceeds threshold, transition to stationary state
    if (!isStationary && stationaryCount >= STATIONARY_THRESHOLD) {
      console.debug("User is now stationary")
      isStationary = true
      stationaryStartTime = Date.now()
      tracking.filter.setStationaryMode(true)

      // Calculate a stable position by averaging recent positions
      const stablePosition = calculateStationaryPosition(positionBuffer)
      if (stablePosition) {
        lastStationaryPosition = stablePosition

        // Set a timeout to lock the stationary position after a delay
        if (stationaryLockTimeout) {
          clearTimeout(stationaryLockTimeout)
        }

        stationaryLockTimeout = setTimeout(() => {
          stationaryPositionLocked = true
          stationaryPositionLockTime = Date.now()
          console.log("Stationary position locked after delay")

          // Also lock in the Kalman filter
          tracking.filter.lockStationaryPosition(lastStationaryPosition)
        }, 2000) // Reduced from 3000ms for faster locking
      }
    }

    // Schedule the next stationary check
    if (isStationary && !stationaryCheckTimeout) {
      stationaryCheckTimeout = setTimeout(() => {
        stationaryCheckTimeout = null
        checkStationaryState(newPosition)
      }, STATIONARY_CHECK_INTERVAL)
    }
  }
}

// Main function to update user location
function updateUserLocation(position, forceUpdate = false) {
  // Validate input position
  if (!position?.coords?.latitude || !position?.coords?.longitude) {
    console.warn("Invalid position data received")
    return
  }

  const currentTime = Date.now()
  const timeDelta = lastUpdateTime ? (currentTime - lastUpdateTime) / 1000 : 0

  // Create position object
  const newPosition = {
    lat: position.coords.latitude,
    lng: position.coords.longitude,
    accuracy: position.coords.accuracy || 20,
    heading: position.coords.heading !== null ? position.coords.heading : lastHeadingValue || undefined,
    timestamp: currentTime,
    speedMPS: position.coords.speed !== null ? position.coords.speed : 0,
  }

  // First position initialization
  if (!lastPosition) {
    lastPosition = newPosition
    lastValidPosition = newPosition
    updateUserMarkerPosition(newPosition)
    tracking.filter.reset(newPosition)
    lastUpdateTime = currentTime
    stationaryStartTime = currentTime
    positionBuffer = [newPosition]
    positionHistory = [newPosition]
    lastStationaryPosition = newPosition
    lastRenderPosition = newPosition

    // Set initial zoom based on stationary state
    const initialZoom = calculateZoomLevel(0)
    map.setView([newPosition.lat, newPosition.lng], initialZoom, { animate: false })
    updateDistanceBox()
    return
  }

  // Calculate distance from last position
  const distance = calculateDistance(lastPosition, newPosition)

  // Check for sudden movements or position jumps
  const isJump = !forceUpdate && detectSuddenMovement(newPosition, lastPosition)

  // If a jump is detected and we're stationary, ignore this update
  if (isJump && isStationary && stationaryPositionLocked) {
    console.log("Position jump detected while stationary, ignoring update")
    isJumpDetected = true
    return
  }

  // Handle large position changes or forced updates
  if (distance > EXTENDED_DISTANCE_THRESHOLD || forceUpdate) {
    if (stationaryCheckTimeout) {
      clearTimeout(stationaryCheckTimeout)
      stationaryCheckTimeout = null
    }

    if (stationaryLockTimeout) {
      clearTimeout(stationaryLockTimeout)
      stationaryLockTimeout = null
    }

    isStationary = false
    stationaryStartTime = null
    stationaryCount = 0
    stationaryPositionHistory = []
    lastStationaryPosition = null
    stationaryPositionLocked = false
    isJumpDetected = false

    // Reset tracking variables
    updateUserMarkerPosition(newPosition)
    lastPosition = newPosition
    lastValidPosition = newPosition
    lastRenderPosition = newPosition
    positionBuffer = [newPosition]
    positionHistory = [newPosition]
    tracking.filter.reset(newPosition)
    tracking.filter.setStationaryMode(false)
    lastVelocity = { lat: 0, lng: 0 }
    lastSmoothedPosition = null

    // Cancel any active interpolation
    if (positionInterpolator) {
      positionInterpolator.cancel()
    }

    // Calculate zoom level based on speed
    const zoomLevel = calculateZoomLevel(newPosition.speedMPS)

    map.setView([newPosition.lat, newPosition.lng], zoomLevel, {
      animate: true,
      duration: 0.3,
      noMoveStart: true,
    })

    lastUpdateTime = currentTime
    lastUpdateTimestamp = currentTime
    updateDistanceBox()

    if (map._container) {
      map._onResize()
    }
    return
  }

  // Skip updates with poor accuracy or unrealistic movement
  if (
    !forceUpdate &&
    (newPosition.accuracy > MAX_ACCEPTABLE_ACCURACY || (timeDelta > 0 && distance / timeDelta > 40)) // Max speed check (reduced from 50 to 40 m/s)
  ) {
    console.log("Skipping update due to poor accuracy or unrealistic movement")
    return
  }

  try {
    // Check if device is in motion based on motion sensors
    const motionDetected = deviceMotion && isDeviceInMotion()

    // Check stationary state
    checkStationaryState(newPosition)

    // If we're in stationary mode and have a locked position, use that position
    if (isStationary && stationaryPositionLocked && lastStationaryPosition) {
      // Just update the distance box without changing position
      updateDistanceBox()
      return
    }

    // Apply enhanced tracking with motion detection
    const smoothedPosition = tracking.update(newPosition, motionDetected, ANIMATION_DURATION)

    // Update position buffer and history
    updatePositionBuffer(smoothedPosition)
    updatePositionHistory(smoothedPosition)

    // Add to position update queue
    positionUpdateQueue.push(smoothedPosition)
    lastPosition = smoothedPosition
    lastValidPosition = smoothedPosition

    lastUpdateTime = currentTime
    lastUpdateTimestamp = currentTime
    updateDistanceBox()
  } catch (error) {
    console.error("Location update error:", error)
    // Fallback with basic filtering
    updateUserMarkerPosition(newPosition)
    lastPosition = newPosition
    lastValidPosition = newPosition
    lastRenderPosition = newPosition
    updateDistanceBox()
  }
}

// Predict position based on heading and speed
function predictPositionFromHeading(position, heading, distance) {
  // Input validation
  if (
    !position ||
    typeof heading !== "number" ||
    typeof distance !== "number" ||
    !position.lat ||
    !position.lng ||
    isNaN(heading) ||
    isNaN(distance)
  ) {
    return position
  }

  // Normalize heading to 0-360 range
  heading = ((heading % 360) + 360) % 360

  // Earth's radius in meters
  const R = 6371e3

  // Convert to radians
  const d = distance / R
  const  = (heading * Math.PI) / 180
  const 1 = (position.lat * Math.PI) / 180
  const 1 = (position.lng * Math.PI) / 180

  // Calculate predicted position with error handling
  try {
    const sin1 = Math.sin(1)
    const cos1 = Math.cos(1)
    const cosd = Math.cos(d)
    const sind = Math.sin(d)
    const cos = Math.cos()

    const 2 = Math.asin(sin1 * cosd + cos1 * sind * cos)

    const 2 = 1 + Math.atan2(Math.sin() * sind * cos1, cosd - sin1 * Math.sin(2))

    // Convert back to degrees with bounds checking
    const newLat = Math.max(-90, Math.min(90, (2 * 180) / Math.PI))
    const newLng = (((2 * 180) / Math.PI + 540) % 360) - 180

    return {
      lat: newLat,
      lng: newLng,
    }
  } catch (error) {
    // Fallback to original position if calculation fails
    return position
  }
}

// Check if marker is near edge of map
function isMarkerNearEdge(map, marker, isStrict = false) {
  if (!map || !marker) return { isNearEdge: false }

  const bounds = map.getBounds()
  const point = marker.getLatLng()
  const proximities = calculateEdgeProximity(map, point)

  const thresholdPercentage = isStrict ? 0.12 : EDGE_THRESHOLD_PERCENTAGE

  const edges = {
    north: proximities.north < thresholdPercentage,
    south: proximities.south < thresholdPercentage,
    east: proximities.east < thresholdPercentage,
    west: proximities.west < thresholdPercentage,
  }

  return {
    isNearEdge: Object.values(edges).some((edge) => edge),
    edges: edges,
    proximities: proximities,
  }
}

// Calculate proximity to map edges
function calculateEdgeProximity(map, point) {
  const bounds = map.getBounds()
  const latSpan = bounds.getNorth() - bounds.getSouth()
  const lngSpan = bounds.getEast() - bounds.getWest()

  return {
    north: Math.abs(point.lat - bounds.getNorth()) / latSpan,
    south: Math.abs(point.lat - bounds.getSouth()) / latSpan,
    east: Math.abs(point.lng - bounds.getEast()) / lngSpan,
    west: Math.abs(point.lng - bounds.getWest()) / lngSpan,
  }
}

// Determine if map should recenter
function shouldRecenter(map, marker) {
  const now = Date.now()
  if (now - lastRecenterTime < RECENTER_COOLDOWN) {
    return { needsRecenter: false }
  }

  if (!map || !marker) return { needsRecenter: false }

  const edgeInfo = isMarkerNearEdge(map, marker)
  const proximities = edgeInfo.proximities

  // Check for critical edge proximity (very close to edge)
  const isCritical = Object.values(proximities).some((proximity) => proximity < CRITICAL_EDGE_THRESHOLD)

  if (isCritical) {
    lastRecenterTime = now
    return {
      needsRecenter: true,
      isEmergency: true,
      edgeInfo: edgeInfo,
    }
  }

  // Check for normal edge proximity
  if (edgeInfo.isNearEdge) {
    lastRecenterTime = now
    return {
      needsRecenter: true,
      isEmergency: false,
      edgeInfo: edgeInfo,
    }
  }

  return {
    needsRecenter: false,
    isEmergency: false,
    edgeInfo: edgeInfo,
  }
}

// Calculate optimal center point
function calculateOptimalCenter(map, markerPosition, edgeInfo) {
  const bounds = map.getBounds()

  // Calculate offsets based on which edges are being approached
  let latOffset = 0
  let lngOffset = 0

  // Apply stronger offset for the closest edge
  const proximities = edgeInfo.proximities
  const edges = edgeInfo.edges

  // Get viewport dimensions
  const viewportWidth = mapViewportWidth || map._container.clientWidth
  const viewportHeight = mapViewportHeight || map._container.clientHeight

  // Calculate aspect ratio to adjust offsets
  const aspectRatio = viewportWidth / viewportHeight

  // Adjust offsets based on viewport dimensions
  const latSpan = bounds.getNorth() - bounds.getSouth()
  const lngSpan = bounds.getEast() - bounds.getWest()

  // Calculate offsets with consideration for viewport aspect ratio
  if (edges.north) {
    latOffset = -1 * latSpan * 0.25 * (1 / aspectRatio)
  }
  if (edges.south) {
    latOffset = latSpan * 0.25 * (1 / aspectRatio)
  }
  if (edges.east) {
    lngOffset = -1 * lngSpan * 0.25 * aspectRatio
  }
  if (edges.west) {
    lngOffset = lngSpan * 0.25 * aspectRatio
  }

  // Find the closest edge and apply extra offset
  const minProximity = Math.min(
    edges.north ? proximities.north : 1,
    edges.south ? proximities.south : 1,
    edges.east ? proximities.east : 1,
    edges.west ? proximities.west : 1,
  )

  if (minProximity === proximities.north && edges.north) {
    latOffset *= 1.5
  } else if (minProximity === proximities.south && edges.south) {
    latOffset *= 1.5
  } else if (minProximity === proximities.east && edges.east) {
    lngOffset *= 1.5
  } else if (minProximity === proximities.west && edges.west) {
    lngOffset *= 1.5
  }

  return {
    lat: markerPosition.lat + latOffset,
    lng: markerPosition.lng + lngOffset,
  }
}

function updateDistanceBox() {
  const distanceBox = document.getElementById("distanceBox")
  if (!distanceBox) return

  // Schedule DOM update
  domUpdateManager.schedule("distanceBox", () => {
    // Initial validation
    if (!userMarker || !gameLocations || gameLocations.length === 0) {
      distanceBox.innerText = "Initializing..."
      return
    }

    // Get user coordinates
    const userLatLng = userMarker.getLatLng()
    let userLat = userLatLng.lat
    let userLng = userLatLng.lng

    // Coordinate validation
    if (!isFinite(userLat) || !isFinite(userLng)) {
      console.warn("Invalid user coordinates:", userLat, userLng)
      distanceBox.innerText = "Initializing..."
      return
    }

    // Use map center if at origin
    if (userLat === 0 && userLng === 0) {
      const center = map.getCenter()
      userLat = center.lat
      userLng = center.lng
    }

    // Find closest location
    let closestDistance = Number.POSITIVE_INFINITY
    let closestLocation = null
    const userPos = { lat: userLat, lng: userLng }

    for (const location of gameLocations) {
      if (!location || typeof location.lat !== "number" || typeof location.lng !== "number") {
        console.warn("Invalid location data:", location)
        continue
      }

      const locationPos = { lat: location.lat, lng: location.lng }
      const distance = calculateDistance(userPos, locationPos)

      if (isFinite(distance) && distance < closestDistance) {
        closestDistance = distance
        closestLocation = location
      }
    }

    // Validate final distance calculation
    if (!isFinite(closestDistance) || closestDistance === Number.POSITIVE_INFINITY) {
      console.warn("Invalid distance calculation:", closestDistance)
      distanceBox.innerText = "Initializing..."
      return
    }

    // Calculate and display distance
    const distanceFeet = Math.round(closestDistance * 3.28084)
    const distanceText =
      distanceFeet < 5280 ? `${distanceFeet.toLocaleString()} feet` : `${(distanceFeet / 5280).toFixed(2)} miles`

    distanceBox.innerText = `Closest Stop: ${distanceText}`

    // Check if we should show location hunt
    if (distanceFeet <= DISTANCE_THRESHOLD && !isLocationHuntVisible && closestLocation) {
      showLocationHunt(closestLocation)
    }
  })
}

const MAX_RETRIES = 3
const RETRY_DELAY = 1000

function getGeolocationOptions(retryNumber) {
  return {
    enableHighAccuracy: retryNumber < 2,
    timeout: 10000 + retryNumber * 5000,
    maximumAge: retryNumber * 5000,
  }
}

function handleLocationError(error) {
  console.warn("Error getting user location:", error)

  if (retryCount < MAX_RETRIES) {
    retryCount++
    console.log(`Retrying to get location (Attempt ${retryCount} of ${MAX_RETRIES})`)

    setTimeout(() => {
      navigator.geolocation.getCurrentPosition(
        (position) => {
          console.log("Location retrieved successfully after retry")
          hideLoadingMessage()
          updateUserLocation(position, true)
          retryCount = 0
        },
        handleLocationError,
        getGeolocationOptions(retryCount),
      )
    }, RETRY_DELAY)
    return
  }

  retryCount = 0
  hideLoadingMessage()

  let errorMessage = "An error occurred while getting your location."
  if (error && error.code) {
    switch (error.code) {
      case 1:
        errorMessage = "Please allow access to your location to use this feature."
        break
      case 2:
        errorMessage = "Your location is currently unavailable. Please try again later."
        break
      case 3:
        errorMessage = "Getting your location took too long. Please try again."
        break
    }
  }
  showPopup("Location Error", errorMessage)
}

function showPopup(title, message, type = "info", callback = null) {
  const popup = document.createElement("div")
  popup.classList.add("popup")
  popup.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: white;
        padding: 24px;
        border-radius: 16px;
        box-shadow: var(--shadow-lg);
        z-index: 2000;
        text-align: center;
        max-width: 80%;
    `

  const titleElement = document.createElement("h3")
  titleElement.textContent = title
  titleElement.style.cssText = `
        margin-bottom: 16px;
        font-size: 20px;
        font-weight: 600;
        color: var(--dark);
    `

  const messageElement = document.createElement("p")
  messageElement.textContent = message
  messageElement.style.cssText = `
        margin-bottom: 24px;
        font-size: 16px;
        line-height: 1.5;
    `

  const buttonContainer = document.createElement("div")
  buttonContainer.style.cssText = `
        display: flex;
        justify-content: center;
        gap: 12px;
    `

  const okButton = document.createElement("button")
  okButton.textContent = "OK"
  okButton.style.cssText = `
        padding: 10px 24px;
        background-color: var(--primary);
        color: white;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-weight: 500;
        transition: var(--transition-normal);
    `

  okButton.addEventListener("click", () => {
    document.body.removeChild(popup)
    if (callback) callback()
  })

  buttonContainer.appendChild(okButton)

  if (type === "info") {
    const cancelButton = document.createElement("button")
    cancelButton.textContent = "Cancel"
    cancelButton.style.cssText = `
            padding: 10px 24px;
            background-color: #f2f2f2;
            color: var(--dark);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: var(--transition-normal);
        `

    cancelButton.addEventListener("click", () => {
      document.body.removeChild(popup)
    })

    buttonContainer.appendChild(cancelButton)
  }

  popup.appendChild(titleElement)
  popup.appendChild(messageElement)
  popup.appendChild(buttonContainer)
  document.body.appendChild(popup)
}

function recenterMap() {
  const recenterButton = document.getElementById("recenterButton")
  recenterButton.style.backgroundColor = "var(--primary)"
  recenterButton.style.color = "var(--white)"

  // Force map to center on user marker immediately
  if (userMarker && userMarker.getLatLng()) {
    map.closePopup()

    // Get dynamic zoom level based on current speed
    const dynamicZoom = calculateZoomLevel(currentSpeed)

    // Use flyTo instead of setView for smoother animation
    map.flyTo(userMarker.getLatLng(), dynamicZoom, {
      duration: 0.5,
    })

    followUser = true

    // onMapRecentered variable is undeclared. Please fix the import or declare the variable before using it.
    // Declaring onMapRecentered here
    const onMapRecentered = () => {}

    // Make sure any other code knows the map has been recentered
    if (typeof onMapRecentered === "function") {
      onMapRecentered()
    }
  }

  setTimeout(() => {
    recenterButton.style.backgroundColor = "var(--white)"
    recenterButton.style.color = "var(--primary)"
  }, 500)
}

function addUIEventListeners() {
  document.getElementById("recenterButton").addEventListener("click", () => {
    recenterMap()
    resetInactivityTimer()
  })
  document.getElementById("returnButton").addEventListener("click", () => {
    returnToIndex()
    resetInactivityTimer()
  })
  document.getElementById("tipsButton").addEventListener("click", () => {
    toggleNavigationTips()
    resetInactivityTimer()
  })
  document.querySelector(".navigation-tips .close-button").addEventListener("click", () => {
    closeNavigationTips()
    resetInactivityTimer()
  })
}

function addMapEventListeners() {
  const startInteraction = () => {
    isMapInteracting = true
    userIsInteracting = true
    followUser = false
    resetInactivityTimer()
  }

  map.on("movestart zoomstart dragstart", startInteraction)
}

function resetInactivityTimer() {
  clearTimeout(window.inactivityTimer)
  window.inactivityTimer = setTimeout(checkInactivity, INACTIVITY_TIMEOUT)
}

function checkInactivity() {
  console.log("Inactivity timer triggered")
  isMapInteracting = false
  userIsInteracting = false

  // Close any open popups
  map.closePopup()
  map.eachLayer((layer) => {
    if (layer.getPopup && layer.getPopup()?.isOpen()) {
      layer.closePopup()
    }
  })

  if (!isMapInteracting && !userIsInteracting) {
    recenterMap()
  }
}

function closeAllPopups() {
  if (map) {
    map.closePopup()
  }
}

let lastVisitTime = 0
const cooldownPeriod = 3 * 60 * 1000

function showLocationHunt(location) {
  const now = performance.now()
  if (location.id === lastVisitedLocationId && now - lastVisitTime < cooldownPeriod) {
    console.log(`Location ${location.id} is on cooldown. Skipping.`)
    return
  }

  lastVisitedLocationId = location.id
  lastVisitTime = now
  isLocationHuntVisible = true

  // Use DOM batch updates for better performance
  domUpdateManager.schedule("locationHunt", () => {
    const lochuntContainer = document.querySelector(".lochunt-container")
    lochuntContainer.style.display = "flex"

    // Use preloaded image if available
    const locationImage = document.getElementById("locationImage")
    if (preloadedImages.has(location.image)) {
      locationImage.src = location.image
    } else {
      locationImage.src = location.image
      // Preload for next time
      const img = new Image()
      img.crossOrigin = "anonymous" // Set crossOrigin for canvas operations
      img.src = location.image
      preloadedImages.set(location.image, img)
    }
    locationImage.alt = location.name

    const locationTitle = document.getElementById("locationTitle")
    locationTitle.textContent = location.name

    const locationCity = document.getElementById("locationCity")
    locationCity.textContent = location.city

    const locationCreator = document.getElementById("locationCreator")
    locationCreator.textContent = `Created by: ${location.creator}`

    // Set up audio
    const locationAudio = document.getElementById("locationAudio")
    if (preloadedAudio.has(location.audio)) {
      locationAudio.src = location.audio
    } else {
      locationAudio.src = location.audio
      // Preload for next time
      const audioPreload = new Audio()
      audioPreload.preload = "auto"
      audioPreload.src = location.audio
      preloadedAudio.set(location.audio, audioPreload)
    }

    // Initialize audio player after DOM is updated
    requestAnimationFrame(initAudioPlayer)
  })
}

function initAudioPlayer() {
  const audio = document.getElementById("locationAudio")
  const playPauseBtn = document.getElementById("playPauseBtn")
  const rewindBtn = document.getElementById("rewindBtn")
  const forwardBtn = document.getElementById("forwardBtn")
  const progressBar = document.getElementById("progressBar")
  const progressContainer = document.querySelector(".progress")
  const currentTimeSpan = document.getElementById("currentTime")
  const durationSpan = document.getElementById("duration")

  if (
    !audio ||
    !playPauseBtn ||
    !rewindBtn ||
    !forwardBtn ||
    !progressBar ||
    !progressContainer ||
    !currentTimeSpan ||
    !durationSpan
  ) {
    console.warn("Audio player elements not found, retrying...")
    requestAnimationFrame(initAudioPlayer)
    return
  }

  // Debounce progress updates to reduce DOM operations
  let lastProgressUpdate = 0
  const PROGRESS_UPDATE_INTERVAL = 250 // ms

  playPauseBtn.addEventListener("click", togglePlay)
  rewindBtn.addEventListener("click", () => seek(-10))
  forwardBtn.addEventListener("click", () => seek(10))

  // Use throttled event listener for timeupdate
  audio.addEventListener("timeupdate", () => {
    const now = Date.now()
    if (now - lastProgressUpdate > PROGRESS_UPDATE_INTERVAL) {
      lastProgressUpdate = now
      updateProgress()
    }
  })

  audio.addEventListener("loadedmetadata", setDuration)
  audio.addEventListener("ended", () => {
    domUpdateManager.schedule("playPauseBtn", () => {
      playPauseBtn.innerHTML = '<i class="fas fa-play"></i>'
    })
    showAdditionalInfo()
  })

  // Use event delegation for progress container clicks
  progressContainer.addEventListener("click", setProgress)

  function togglePlay() {
    if (audio.paused) {
      const playPromise = audio.play()
      if (playPromise !== undefined) {
        playPromise
          .then(() => {
            domUpdateManager.schedule("playPauseBtn", () => {
              playPauseBtn.innerHTML = '<i class="fas fa-pause"></i>'
            })
          })
          .catch((error) => {
            console.error("Audio playback failed:", error)
          })
      }
    } else {
      audio.pause()
      domUpdateManager.schedule("playPauseBtn", () => {
        playPauseBtn.innerHTML = '<i class="fas fa-play"></i>'
      })
    }
  }

  function seek(seconds) {
    audio.currentTime = Math.max(0, Math.min(audio.currentTime + seconds, audio.duration))
  }

  function updateProgress() {
    const percent = (audio.currentTime / audio.duration) * 100
    domUpdateManager.schedule("audioProgress", () => {
      progressBar.style.width = `${percent}%`
      currentTimeSpan.textContent = formatTime(audio.currentTime)
    })
  }

  function setProgress(e) {
    const width = this.clientWidth
    const clickX = e.offsetX
    const duration = audio.duration
    audio.currentTime = (clickX / width) * duration
  }

  function setDuration() {
    domUpdateManager.schedule("audioDuration", () => {
      durationSpan.textContent = formatTime(audio.duration)
    })
  }

  function formatTime(time) {
    const minutes = Math.floor(time / 60)
    const seconds = Math.floor(time % 60)
    return `${minutes}:${seconds.toString().padStart(2, "0")}`
  }
}

function showAdditionalInfo() {
    // Find the location using lastVisitedLocationId
    const location = gameLocations.find(loc => loc.id === lastVisitedLocationId);
    console.log('Current location:', location);
    
    // Set flag to indicate we're returning from exhibit
    isReturningFromExhibit = true;
    
    domUpdateManager.schedule('additionalInfo', () => {
        const additionalInfoContainer = document.querySelector('.additional-info-container');
        if (!additionalInfoContainer) {
            console.error("Additional info container not found");
            return;
        }
        
        additionalInfoContainer.style.display = 'block';
        
        // Add transition class
        additionalInfoContainer.classList.add('location-transition');
        
        // Trigger reflow to ensure transition works
        void additionalInfoContainer.offsetWidth;
        
        // Make visible with transition
        additionalInfoContainer.classList.add('visible');
        
        const additionalInfoElement = document.getElementById('additionalInfo');
        if (additionalInfoElement && location) {
            additionalInfoElement.textContent = location.additionalInfo;
        }

        const continueButton = document.getElementById('continueButton');
        if (continueButton) {
            continueButton.onclick = () => {
                // Fade out with transition
                additionalInfoContainer.classList.remove('visible');
                
                // Hide after transition completes
                setTimeout(() => {
                    additionalInfoContainer.style.display = 'none';
                    
                    // Also hide location hunt container with transition
                    const lochuntContainer = document.querySelector('.lochunt-container');
                    if (lochuntContainer) {
                        lochuntContainer.classList.remove('visible');
                        
                        setTimeout(() => {
                            lochuntContainer.style.display = 'none';
                            isLocationHuntVisible = false;
                            updateDistanceBox();
                        }, 500);
                    }
                }, 500);
            };
        }
    });
}

function showDirectionsModal(lat, lng) {
    const modal = document.getElementById('directionsModal');
    if (!modal) {
        console.error("Directions modal not found");
        return;
    }
    
    modal.style.display = 'block';

    const mapBtn = document.getElementById('mapButton');
    const cancelBtn = document.getElementById('cancelButton');

    if (mapBtn) {
        mapBtn.onclick = () => {
            window.open(`https://www.google.com/maps/dir/?api=1&destination=${lat},${lng}`, '_blank');
            modal.style.display = 'none';
        };
    }

    if (cancelBtn) {
        cancelBtn.onclick = () => {
            modal.style.display = 'none';
        };
    }

    window.onclick = (event) => {
        if (event.target == modal) {
            modal.style.display = 'none';
        }
    };
}

function showLocationSummary(locationId) {
    console.log("Showing summary for location ID:", locationId);
    console.log("All locations:", gameLocations);
    console.log("Location IDs:", gameLocations.map(loc => loc.id));
    console.log("Location ID type:", typeof locationId);
    
    if (gameLocations.length > 0) {
        console.log("Location ID type:", typeof gameLocations[0].id);
    }
    
    const location = gameLocations.find(loc => loc.id === locationId);
    console.log("Found location:", location);
    
    if (location && location.summary) {
        domUpdateManager.schedule('summaryModal', () => {
            const modal = document.getElementById('summaryModal');
            const summaryContent = document.getElementById('summaryContent');
            
            if (!modal || !summaryContent) {
                console.error("Summary modal elements not found");
                return;
            }
            
            modal.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
            modal.style.display = 'flex';
            modal.style.justifyContent = 'center';
            modal.style.alignItems = 'center';
            
            const modalContent = modal.querySelector('.modal-content');
            if (modalContent) {
                modalContent.style.cssText = `
                    background-color: white;
                    padding: 30px;
                    border-radius: 10px;
                    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.025);
                    max-width: 500px;
                    width: 90%;
                    max-height: 80vh;
                    overflow-y: auto;
                `;
            }
            
            const closeBtn = modal.querySelector('.close');
            if (closeBtn) {
                closeBtn.remove();
            }
            
            summaryContent.style.textAlign = 'left';
            summaryContent.innerHTML = `
               <h3 class="summary-heading" style="font-size: 22px; margin-bottom: 15px; text-align: center;">${location.name}</h3>
                <p style="line-height: 1.6; margin-bottom: 15px;">
                    ${location.summary}
                </p>
                <p style="line-height: 1.6; margin-bottom: 15px;">
                    <strong>Location:</strong> ${location.today}
                </p>
            `;
            
            const continueButton = document.createElement('button');
            continueButton.textContent = 'Continue';
            continueButton.className = 'summary-button';
            continueButton.style.cssText = `
                display: block;
                width: auto;
                padding: 12px 20px;
                color: white;
                border: none;
                border-radius: 10px;
                cursor: pointer;
                font-size: 18px;
                font-weight: bold;
                transition: background-color 0.3s ease;
                margin: 10px auto -15px;
            `;
            continueButton.onclick = function() {
                modal.style.display = 'none';
            };
            summaryContent.appendChild(continueButton);
            modal.style.display = 'flex';
            window.onclick = function(event) {
                if (event.target === modal) {
                    modal.style.display = 'none';
                }
            };
        });
    } else {
        console.log("Location or summary not found. Location ID:", locationId);
        console.log("Available IDs:", gameLocations.map(loc => loc.id));
        showPopup("Error", "Summary not available for this location.");
    }
}

function startHunt() {
    // Check network status before starting
    if (!navigator.onLine) {
        showErrorMessage("No internet connection. Please connect to the internet and try again.");
        
        // Set a timeout to retry
        setTimeout(() => {
            if (navigator.onLine) {
                startHunt();
            }
        }, 5000);
        
        return;
    }
    
    try {
        // Ensure locations is defined before using it
        if (typeof locations !== 'undefined' && Array.isArray(locations)) {
            gameLocations = locations.sort((a, b) => a.id - b.id);
        } else {
            console.warn("Locations data is not available");
            gameLocations = [];
        }
        
        currentLocationIndex = 0;
        locationCooldowns = {};
        lastVisitedLocationId = null;
        
        // Preload all location images before starting
        preloadImages(gameLocations).then(() => {
            // Hide preloader when images are loaded
            const preloader = document.getElementById('preloader');
            if (preloader) {
                preloader.style.opacity = '0';
                preloader.style.transition = 'opacity 0.5s ease';
                setTimeout(() => {
                    if (preloader && preloader.parentNode) {
                        preloader.parentNode.removeChild(preloader);
                    }
                }, 500);
            }
            
            loadAllLocations();
        }).catch(error => {
            console.error("Error preloading images:", error);
            showErrorMessage("Error loading resources. Please check your connection and try again.");
            
            // Try to continue anyway after a delay
            setTimeout(() => {
                loadAllLocations();
            }, 3000);
        });
    } catch (error) {
        console.error("Error starting hunt:", error);
        showErrorMessage("Error starting the experience. Please reload the page.");
    }
}

function getMarkerColor(tours) {
  switch (tours.toLowerCase()) {
    case "person":
      return "#FFA500"
    case "gangster":
      return "#3f9b0b"
    case "event":
      return "#8B0000"
    case "place":
      return "#0f2bab"
    default:
      return "#0f2bab"
  }
}

function loadAllLocations() {
    gameLocations.forEach((location, index) => {
        const markerColor = getMarkerColor(location.tours);
        
        const locationMarker = L.marker([location.lat, location.lng], {
            icon: L.divIcon({
                className: 'custom-pin-icon',
                html: `<div class="pin-head" style="background-color: ${markerColor};">
                       </div>`,
                iconSize: [30, 30],
                iconAnchor: [15, 30],
            })
        });
                
        const popupContent = `
            <div class="popup-content">
                <img src="${location.image}" alt="${location.name}" class="location-image">
                <h4 class="location-name">
                    <a href="${location.link}" target="_blank" rel="noopener noreferrer" style="text-decoration: none; color: inherit;">${location.name}</a>
                </h4>
                <div class="popup-buttons">
                    <button class="button route-button" data-lat="${location.lat}" data-lng="${location.lng}">Directions</button>
                    <button class="button summary-button" data-location-id="${location.id}">Summary</button>
                </div>
            </div>
        `;
        locationMarker.bindPopup(popupContent, {
            offset: L.point(0, -25),
            className: 'custom-popup'
        });
        
        locationMarker.on('popupopen', function(e) {
            const popup = e.popup._contentNode;
            const routeButton = popup.querySelector('.route-button');
            const summaryButton = popup.querySelector('.summary-button');
            
            if (routeButton) {
                routeButton.addEventListener('click', function(event) {
                    event.preventDefault();
                    const lat = this.getAttribute('data-lat');
                    const lng = this.getAttribute('data-lng');
                    
                    // Create and show the modal
                    const modal = document.createElement('div');
                    modal.className = 'modal';
                    modal.innerHTML = `
                        <div class="modal-content">
                            <h3>Choose your preferred navigation app:</h3>
                            <div class="modal-buttons">
                                <button class="modal-button google-maps">
                                    Google Maps
                                </button>
                                <button class="modal-button waze">
                                    Waze
                                </button>
                                <button class="modal-button apple-maps">
                                    Apple Maps
                                </button>
                                <button class="modal-button cancel">Cancel</button>
                            </div>
                        </div>
                    `;

// direction modal styles
if (!document.querySelector('#modal-styles')) {
    const style = document.createElement('style');
    style.id = 'modal-styles';
    style.textContent = `
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.75);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            padding: 16px;
            backdrop-filter: blur(4px);
        }
        .modal-content {
            background: white;
            padding: 24px 16px;
            border-radius: 16px;
            width: 100%;
            max-width: 320px;
            text-align: center;
            box-shadow: 0 20px 40px rgba(0,0,0,0.2);
        }
        .modal-buttons {
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            align-items: center;
        }
        .modal-button {
            padding: 16px;
            border-radius: 12px;
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: 500;
            border: none;
            cursor: pointer;
            transition: transform 0.15s ease;
        }
        .modal-button:active {
            transform: scale(0.98);
        }
        .google-maps {
            background: #4285F4;
            color: white;
            box-shadow: 0 2px 8px rgba(66,133,244,0.3);
        }
        .waze {
            background: #33ccff;
            color: white;
            box-shadow: 0 2px 8px rgba(51,204,255,0.3);
        }
        .apple-maps {
            background: #000000;
            color: white;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
        .cancel {
            background: #f2f2f2;
            color: #666;
        }
    `;
    document.head.appendChild(style);
}

                    document.body.appendChild(modal);

                    // Handle button clicks
                    modal.querySelector('.google-maps').addEventListener('click', () => {
                        window.location.href = `https://www.google.com/maps/dir/?api=1&destination=${lat},${lng}`;
                        modal.remove();
                    });

                    modal.querySelector('.waze').addEventListener('click', () => {
                        window.location.href = `https://www.waze.com/ul?ll=${lat}%2C${lng}&navigate=yes`;
                        modal.remove();
                    });

                    modal.querySelector('.apple-maps').addEventListener('click', () => {
                        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
                        if (isIOS) {
                            window.location.href = `maps://maps.apple.com/?daddr=${lat},${lng}`;
                            modal.remove();
                        } else {
                            const alertEl = document.createElement('div');
                            alertEl.className = 'modal';
                            alertEl.innerHTML = `
                                <div class="modal-content">
                                    <p>Apple Maps is only available on iOS devices</p>
                                    <button class="modal-button">OK</button>
                                </div>
                            `;
                            document.body.appendChild(alertEl);
                            alertEl.querySelector('button').onclick = () => {
                                alertEl.remove();
                                // Don't remove the original modal when showing the alert
                                return false;
                            };
                        }
                    });
                    
                    modal.querySelector('.cancel').addEventListener('click', () => {
                        modal.remove();
                    });

                    // Close modal if clicking outside
                    modal.addEventListener('click', (e) => {
                        if (e.target === modal) {
                            modal.remove();
                        }
                    });
                });
            }
            
            if (summaryButton) {
                summaryButton.addEventListener('click', function(event) {
                    event.preventDefault();
                    const locationId = this.getAttribute('data-location-id');
                    showLocationSummary(locationId);
                });
            }
        });
        
        markerClusterGroup.addLayer(locationMarker);
    });
    map.addLayer(markerClusterGroup);
    updateDistanceBox();
    resetInactivityTimer();
}    
        
function returnToIndex() {
  showPopup("Confirm", "Are you ready to exit?", "info", () => {
    window.location.href = "/index.html"
  })
  document.getElementById("returnButton").classList.remove("active")
}

function toggleNavigationTips() {
  const tipsElement = document.querySelector(".navigation-tips")
  const computedStyle = window.getComputedStyle(tipsElement)

  if (computedStyle.display === "none") {
    tipsElement.style.display = "block"
  } else {
    tipsElement.style.display = "none"
  }

  document.getElementById("tipsButton").classList.toggle("active")
}

function closeNavigationTips() {
  document.querySelector(".navigation-tips").style.display = "none"
  document.getElementById("tipsButton").classList.remove("active")
}

document.addEventListener("DOMContentLoaded", () => {
  // Initialize the map and start preloading images
  initMap()
  addUIEventListeners()
  addMapEventListeners()
})
    </script>
  </body>
</html>
