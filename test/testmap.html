<!-- 1 -->
function updateUserLocation(position, forceUpdate = false) {
    if (!position?.coords?.latitude || !position?.coords?.longitude) {
        console.warn("Invalid position data received");
        return;
    }
    
    if (animationFrameId !== null) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
    }
    
    const currentTime = Date.now();
    const timeDelta = lastUpdateTime ? (currentTime - lastUpdateTime) / 1000 : 0;
    const newPosition = {
        lat: position.coords.latitude,
        lng: position.coords.longitude,
        accuracy: position.coords.accuracy || 20,
        heading: position.coords.heading ?? null,
        timestamp: currentTime,
        speedMPS: position.coords.speed || 0
    };
    
    const velocityFilteredPosition = calculateVelocityFilter(newPosition, lastPosition || newPosition);
    const smoothedPosition = applyExponentialSmoothing(velocityFilteredPosition, lastSmoothedPosition || velocityFilteredPosition);
    lastSmoothedPosition = smoothedPosition;
    
    if (gameLocations && gameLocations.length > 0) {
        gameLocations.forEach(location => {
            enterpriseCacheManager.cacheLocationData(location, smoothedPosition);
        });
    }
    
    if (!lastPosition) {
        lastPosition = smoothedPosition;
        
        const mapContainer = map.getContainer();
        const originalTransition = mapContainer.style.transition;
        mapContainer.style.transition = 'none';
        
        userMarker.setLatLng([smoothedPosition.lat, smoothedPosition.lng]);
        
        const currentZoom = map.getZoom();
        map.setView([smoothedPosition.lat, smoothedPosition.lng], currentZoom, { 
            animate: false,
            noMoveStart: true
        });
        
        requestAnimationFrame(() => {
            mapContainer.style.transition = originalTransition;
        });
        
        lastUpdateTime = currentTime;
        stationaryStartTime = currentTime;
        positionBuffer = [smoothedPosition];
        
        const intelligentZoom = getSpeedBasedZoom(smoothedPosition.speedMPS);
        if (intelligentZoom) {
            map.setZoom(intelligentZoom, { animate: false, noMoveStart: true });
        }
        
        updateDistanceBox();
        updateAccuracyIndicator(smoothedPosition.accuracy);
        return;
    }
    
    const distance = calculateDistance(lastPosition, smoothedPosition);
    const speedMPH = smoothedPosition.speedMPS * 2.23694;
    
    const latDelta = Math.abs(smoothedPosition.lat - lastPosition.lat);
    const lngDelta = Math.abs(smoothedPosition.lng - lastPosition.lng);
    const eastWestMovement = lngDelta > latDelta * 1.15;
    
    let directionChangeFactor = 1.0;
    let headingDiff = 0;
    
    if (lastPosition.heading !== null && lastPosition.heading !== undefined && 
        smoothedPosition.heading !== null && smoothedPosition.heading !== undefined) {
        headingDiff = Math.abs(smoothedPosition.heading - lastPosition.heading);
        if (headingDiff > 180) headingDiff = 360 - headingDiff;
        
        if (headingDiff > 15) {
            directionChangeFactor = Math.max(0.5, 1 - (headingDiff / 220));
        }
    }
    
    const speedFactor = Math.min(1, Math.max(0.01, smoothedPosition.speedMPS / 15));
    
    const speedTierConfigs = [
        { maxSpeed: 0.5, micro: 0.12, minDist: 0.2, maxAcc: 1.5, mapInt: 1000, mapDist: 1.8, panDur: 2.2, ease: 0.08, zoomTh: 2.8, zoomDur: 3.5 },
        { maxSpeed: 2, micro: 0.25, minDist: 0.35, maxAcc: 1.3, mapInt: 900, mapDist: 2.8, panDur: 1.8, ease: 0.1, zoomTh: 2.4, zoomDur: 3.0 },
        { maxSpeed: 5, micro: 0.4, minDist: 0.5, maxAcc: 1.15, mapInt: 700, mapDist: 4.5, panDur: 1.4, ease: 0.12, zoomTh: 2.0, zoomDur: 2.5 },
        { maxSpeed: 10, micro: 0.35, minDist: 0.45, maxAcc: 1.08, mapInt: 500, mapDist: 3.8, panDur: 1.1, ease: 0.15, zoomTh: 1.6, zoomDur: 2.2 },
        { maxSpeed: 20, micro: 0.5, minDist: 0.6, maxAcc: 1.1, mapInt: 400, mapDist: 7.5, panDur: 0.9, ease: 0.18, zoomTh: 1.3, zoomDur: 1.8 },
        { maxSpeed: 35, micro: 0.9, minDist: 0.9, maxAcc: 1.25, mapInt: 350, mapDist: 13, panDur: 0.7, ease: 0.22, zoomTh: 1.1, zoomDur: 1.5 },
        { maxSpeed: 50, micro: 1.2, minDist: 1.2, maxAcc: 1.35, mapInt: 280, mapDist: 16, panDur: 0.55, ease: 0.28, zoomTh: 0.9, zoomDur: 1.2 },
        { maxSpeed: 65, micro: 1.6, minDist: 1.6, maxAcc: 1.6, mapInt: 200, mapDist: 22, panDur: 0.42, ease: 0.35, zoomTh: 0.7, zoomDur: 1.0 },
        { maxSpeed: 80, micro: 2.0, minDist: 2.0, maxAcc: 1.8, mapInt: 150, mapDist: 28, panDur: 0.35, ease: 0.42, zoomTh: 0.55, zoomDur: 0.8 },
        { maxSpeed: Infinity, micro: 2.5, minDist: 2.5, maxAcc: 2.2, mapInt: 100, mapDist: 35, panDur: 0.28, ease: 0.5, zoomTh: 0.45, zoomDur: 0.6 }
    ];
    
    const config = speedTierConfigs.find(c => speedMPH < c.maxSpeed);
    const speedTier = {
        microMovementThreshold: CONFIG.MICRO_MOVEMENT_THRESHOLD * config.micro,
        minDistanceThreshold: CONFIG.MIN_DISTANCE_THRESHOLD * config.minDist,
        maxAccuracy: CONFIG.MAX_ACCEPTABLE_ACCURACY * config.maxAcc,
        maxSpeedThreshold: CONFIG.MAX_SPEED * (config.maxSpeed === Infinity ? 4.2 : config.maxSpeed * 0.1 + 0.4),
        mapUpdateInterval: config.mapInt,
        mapUpdateDistance: config.mapDist,
        panDuration: config.panDur,
        easeLinearity: config.ease,
        zoomThreshold: config.zoomTh,
        zoomDuration: config.zoomDur
    };
    
    const eastWestAdjustment = eastWestMovement ? 0.88 : 1.0;
    speedTier.panDuration *= eastWestAdjustment;
    speedTier.easeLinearity *= (eastWestMovement ? 0.92 : 1.0);
    speedTier.mapUpdateInterval = Math.max(50, speedTier.mapUpdateInterval * eastWestAdjustment);
    
    if (distance > CONFIG.EXTENDED_DISTANCE_THRESHOLD || forceUpdate) {
        if (stationaryCheckTimeout) {
            clearTimeout(stationaryCheckTimeout);
            stationaryCheckTimeout = null;
        }
        isStationary = false;
        stationaryStartTime = null;
        
        const transitionPosition = smoothedPosition;
        
        const mapContainer = map.getContainer();
        const originalTransition = mapContainer.style.transition;
        mapContainer.style.transition = 'none';
        
        userMarker.setLatLng([transitionPosition.lat, transitionPosition.lng], { animate: false });
        lastPosition = transitionPosition;
        positionBuffer = [transitionPosition];
        lastVelocity = { lat: 0, lng: 0 };
        
        const intelligentZoom = getSpeedBasedZoom(smoothedPosition.speedMPS);
        if (intelligentZoom) {
            map.setZoom(intelligentZoom, { animate: false, noMoveStart: true });
        }
        
        const currentZoom = map.getZoom();
        map.setView([transitionPosition.lat, transitionPosition.lng], currentZoom, { 
            animate: false, 
            duration: 0,
            noMoveStart: true
        });
        
        requestAnimationFrame(() => {
            mapContainer.style.transition = originalTransition;
        });
        
        lastUpdateTime = currentTime;
        lastUpdateTimestamp = currentTime;
        
        if (isSignificantMovement(transitionPosition)) {
            resetInactivityTimer(false);
        }
            
        updateDistanceBox();
        
        if (map._container) {
            map._onResize();
        }
        return;
    }
    
    const dynamicMicroThreshold = Math.max(
    speedTier.microMovementThreshold,
    smoothedPosition.accuracy * 0.8   // never below ~ 80 % of current GPS noise
);
    const jitterSuppression = speedMPH < 2 ? Math.max(dynamicMicroThreshold, distance * 1.3) : dynamicMicroThreshold;
    const directionAdjustedJitterSuppression = jitterSuppression * (eastWestMovement ? 0.92 : 1.0);
    
    if (distance < directionAdjustedJitterSuppression && !forceUpdate) {
        if (!isStationary) {
            if (!stationaryStartTime) {
                stationaryStartTime = currentTime;
            } else if (currentTime - stationaryStartTime >= CONFIG.STATIONARY_TIME_THRESHOLD * 0.75) {
                isStationary = true;
                
                const currentLatLng = userMarker.getLatLng();
                const targetLatLng = L.latLng(smoothedPosition.lat, smoothedPosition.lng);
                const stationaryDistance = currentLatLng.distanceTo(targetLatLng);
                
                if (stationaryDistance > 0.8) {
                    userMarker.setLatLng([smoothedPosition.lat, smoothedPosition.lng], { 
                        animate: true, 
                        duration: 0.6,
                        easeLinearity: 0.08
                    });
                } else {
                    userMarker.setLatLng([smoothedPosition.lat, smoothedPosition.lng], { animate: false });
                }
                
                lastPosition = smoothedPosition;
                positionBuffer = [smoothedPosition];
                
                if (stationaryCheckTimeout) clearTimeout(stationaryCheckTimeout);
                stationaryCheckTimeout = setTimeout(() => checkStationaryState(smoothedPosition), CONFIG.STATIONARY_CHECK_INTERVAL);
                
                updateDistanceBox();
                return;
            }
        }
        
        if (isStationary) {
            if (smoothedPosition.accuracy < lastPosition.accuracy * 0.92) {
                userMarker.setLatLng([smoothedPosition.lat, smoothedPosition.lng], { animate: false });
                lastPosition = smoothedPosition;
                updateDistanceBox();
            }
            return;
        }
    } else {
        isStationary = false;
        stationaryStartTime = null;
        if (stationaryCheckTimeout) {
            clearTimeout(stationaryCheckTimeout);
            stationaryCheckTimeout = null;
        }
    }
    
    const dynamicMinDistance = speedTier.minDistanceThreshold * (eastWestMovement ? 0.92 : 1.0);
    const dynamicMaxAccuracy = speedTier.maxAccuracy;
    const dynamicMaxSpeed = speedTier.maxSpeedThreshold;
    
    const jitterFilteredDistance = speedMPH < 5 ? Math.max(distance, dynamicMinDistance * 1.15) : distance;
    
    if (!forceUpdate && (
        smoothedPosition.accuracy > dynamicMaxAccuracy ||
        jitterFilteredDistance < dynamicMinDistance ||
        (timeDelta > 0 && jitterFilteredDistance / timeDelta > dynamicMaxSpeed)
    )) {
        return;
    }
    
    try {
        updatePositionBuffer(smoothedPosition);
        
        const finalPosition = calculateFinalPosition();
        if (!finalPosition) throw new Error("Final position calculation failed");
        
        const predictedPosition = calculateEnhancedVelocityFilter(finalPosition, lastPosition, timeDelta, smoothedPosition.speedMPS);
        
        const smoothingBrackets = [
            { threshold: 0.5, base: 0.1, mult: 0.12, max: 0.22, min: 0.06 },
            { threshold: 2, base: 0.18, mult: 0.14, max: 0.32, min: 0.12 },
            { threshold: 5, base: 0.28, mult: 0.18, max: 0.46, min: 0.22 },
            { threshold: 10, base: 0.3, mult: 0.23, max: 0.6, min: 0.22 },
            { threshold: 20, base: 0.48, mult: 0.19, max: 0.68, min: 0.4 },
            { threshold: 35, base: 0.58, mult: 0.17, max: 0.76, min: 0.5 },
            { threshold: 50, base: 0.66, mult: 0.14, max: 0.8, min: 0.6 },
            { threshold: 65, base: 0.72, mult: 0.13, max: 0.86, min: 0.68 },
            { threshold: 80, base: 0.77, mult: 0.11, max: 0.89, min: 0.74 },
            { threshold: Infinity, base: 0.81, mult: 0.09, max: 0.92, min: 0.78 }
        ];
        
        const bracket = smoothingBrackets.find(b => speedMPH < b.threshold);
        let baseFactor = Math.min(bracket.max, Math.max(bracket.min, bracket.base + (speedFactor * bracket.mult)));
        
        const distanceAdjustment = Math.min(0.08, distance * 0.005);
        const timeAdjustment = timeDelta > 0 ? Math.min(0.05, Math.max(-0.03, (timeDelta - 0.35) * 0.07)) : 0;
        const jitterDampening = speedMPH < 3 ? Math.max(0, 0.04 - (speedMPH * 0.013)) : 0;
        const directionChangeAdjustment = headingDiff > 25 ? Math.max(0, 0.06 - (headingDiff / 200) * 0.08) : 0;
        const eastWestSmoothingBonus = eastWestMovement ? 0.025 : 0;
        
        const adjustedSmoothingFactor = Math.min(0.94, Math.max(0.04, 
            baseFactor + distanceAdjustment + timeAdjustment - jitterDampening - directionChangeAdjustment + eastWestSmoothingBonus
        ));
        
        const jitterReductionFactor = speedMPH < 3 ? 0.87 : 1.0;
        const finalSmoothingFactor = adjustedSmoothingFactor * jitterReductionFactor * directionChangeFactor;
       
        const finalSmoothedPosition = {
            lat: lastPosition.lat * (1 - finalSmoothingFactor) + predictedPosition.lat * finalSmoothingFactor,
            lng: lastPosition.lng * (1 - finalSmoothingFactor) + predictedPosition.lng * finalSmoothingFactor,
            accuracy: predictedPosition.accuracy,
            heading: predictedPosition.heading,
            timestamp: currentTime,
            speedMPS: predictedPosition.speedMPS
        };
        
        const durationBrackets = [
            { threshold: 0.5, base: 1.0, mult: -0.12, max: 1.3, min: 0.7 },
            { threshold: 2, base: 0.8, mult: -0.14, max: 1.0, min: 0.5 },
            { threshold: 5, base: 0.65, mult: -0.12, max: 0.8, min: 0.4 },
            { threshold: 10, base: 0.45, mult: -0.1, max: 0.65, min: 0.28 },
            { threshold: 20, base: 0.35, mult: -0.08, max: 0.5, min: 0.22 },
            { threshold: 35, base: 0.32, mult: -0.07, max: 0.42, min: 0.2 },
            { threshold: 50, base: 0.28, mult: -0.06, max: 0.36, min: 0.18 },
            { threshold: 65, base: 0.22, mult: -0.04, max: 0.28, min: 0.15 },
            { threshold: 80, base: 0.18, mult: -0.03, max: 0.23, min: 0.12 },
            { threshold: Infinity, base: 0.14, mult: -0.025, max: 0.18, min: 0.08 }
        ];
        
        const durationBracket = durationBrackets.find(b => speedMPH < b.threshold);
        const baseDuration = Math.min(durationBracket.max, Math.max(durationBracket.min, durationBracket.base + (speedFactor * durationBracket.mult)));
        
        const distanceModifier = Math.min(0.05, distance * 0.0015);
        const timeModifier = timeDelta > 0 ? Math.max(-0.02, Math.min(0.03, (0.22 - timeDelta) * 0.07)) : 0;
        const jitterCompensation = speedMPH < 2 ? Math.min(0.06, (2 - speedMPH) * 0.03) : 0;
        const directionChangeCompensation = headingDiff > 20 ? Math.min(0.08, headingDiff / 200 * 0.12) : 0;
        const eastWestDurationBonus = eastWestMovement ? Math.min(0.04, distance * 0.0008) : 0;
        
        const jitterCompensatedDuration = Math.max(0.03, 
            baseDuration - distanceModifier + timeModifier + jitterCompensation + directionChangeCompensation + eastWestDurationBonus
        );
        
        const finalAnimationDuration = jitterCompensatedDuration * directionChangeFactor;
        
        const markerElement = userMarker.getElement();
        if (markerElement) {
            markerElement.style.willChange = 'transform';
            markerElement.style.backfaceVisibility = 'hidden';
            markerElement.style.transform = 'translateZ(0)';
            
            if (eastWestMovement) {
                markerElement.style.imageRendering = 'crisp-edges';
            }
        }
        
        const finalEaseLinearity = eastWestMovement ?
            Math.max(0.02, Math.min(0.18, (0.1 - (speedMPH * 0.0008)) * directionChangeFactor)) :
            Math.max(0.04, Math.min(0.22, (0.12 - (speedMPH * 0.0015)) * directionChangeFactor));
        
        userMarker.setLatLng([finalSmoothedPosition.lat, finalSmoothedPosition.lng], {
            animate: true,
            duration: finalAnimationDuration,
            easeLinearity: finalEaseLinearity
        });
        
        const mapUpdateInterval = speedTier.mapUpdateInterval;
        const mapUpdateDistanceThreshold = speedTier.mapUpdateDistance * (eastWestMovement ? 0.92 : 1.0);
        
        if (currentTime - lastMapUpdateTime > mapUpdateInterval || distance > mapUpdateDistanceThreshold) {
            checkProximityForZoom();
            
            const lookAheadBrackets = [
                { threshold: 0.5, base: 0, mult: 0.025, max: 0.04 },
                { threshold: 2, base: 0, mult: 0.045, max: 0.08 },
                { threshold: 5, base: 0, mult: 0.075, max: 0.12 },
                { threshold: 10, base: 0, mult: 0.12, max: 0.18 },
                { threshold: 20, base: 0, mult: 0.18, max: 0.26 },
                { threshold: 35, base: 0, mult: 0.25, max: 0.36 },
                { threshold: 50, base: 0, mult: 0.34, max: 0.48 },
                { threshold: 65, base: 0, mult: 0.44, max: 0.62 },
                { threshold: 80, base: 0, mult: 0.55, max: 0.75 },
                { threshold: Infinity, base: 0, mult: 0.68, max: 0.9 }
            ];
            
            const lookAheadBracket = lookAheadBrackets.find(b => speedMPH < b.threshold);
            const baseLookAhead = Math.min(lookAheadBracket.max, lookAheadBracket.base + (speedFactor * lookAheadBracket.mult));
            
            const distanceBoost = Math.min(0.15, distance * 0.008);
            const directionChangeLookAheadReduction = headingDiff > 30 ? Math.min(0.25, headingDiff / 180 * 0.35) : 0;
            const eastWestLookAheadBonus = eastWestMovement ? Math.min(0.08, distance * 0.002) : 0;
            
            const lookAheadFactor = Math.min(0.9, Math.max(0.015, 
                baseLookAhead + distanceBoost - directionChangeLookAheadReduction + eastWestLookAheadBonus
            ));
            
            const sophisticatedPrediction = positionBuffer && positionBuffer.length >= 3 ? (() => {
                const recent = positionBuffer.slice(-3);
                const vel1 = { lat: recent[1].lat - recent[0].lat, lng: recent[1].lng - recent[0].lng };
                const vel2 = { lat: recent[2].lat - recent[1].lat, lng: recent[2].lng - recent[1].lng };
                const accel = { lat: vel2.lat - vel1.lat, lng: vel2.lng - vel1.lng };
                
                const curveFactor = Math.min(0.5, Math.sqrt(accel.lat * accel.lat + accel.lng * accel.lng) * 100);
                const adjustedLookAhead = lookAheadFactor * (1 - curveFactor * 0.3);
                
                return {
                    lat: finalSmoothedPosition.lat + (vel2.lat * adjustedLookAhead) + (accel.lat * adjustedLookAhead * 0.5),
                    lng: finalSmoothedPosition.lng + (vel2.lng * adjustedLookAhead) + (accel.lng * adjustedLookAhead * 0.5)
                };
            })() : {
                lat: finalSmoothedPosition.lat + (predictedPosition.lat - lastPosition.lat) * lookAheadFactor,
                lng: finalSmoothedPosition.lng + (predictedPosition.lng - lastPosition.lng) * lookAheadFactor
            };
            
            const lookAheadPosition = sophisticatedPrediction;
            
            animationFrameId = requestAnimationFrame(() => {
                if (followUser && !isMapInteracting) {
                    const userPos = finalSmoothedPosition;
                    const bounds = map.getBounds();
                    
                    if (userPos && bounds) {
                        const userPixelPoint = map.latLngToContainerPoint(userPos);
                        const mapSize = map.getSize();
                        
                        const criticalOffScreenDistance = Math.max(mapSize.x, mapSize.y) * 0.4;
                        const predictedPixelPoint = map.latLngToContainerPoint(lookAheadPosition);
                        const offScreenDistance = Math.max(
                            Math.max(0, -predictedPixelPoint.x, predictedPixelPoint.x - mapSize.x),
                            Math.max(0, -predictedPixelPoint.y, predictedPixelPoint.y - mapSize.y)
                        );
                        
                        if (offScreenDistance > criticalOffScreenDistance) {
                            const emergencyTarget = lookAheadPosition;
                            const mapContainer = map.getContainer();
                            mapContainer.style.transition = 'none';
                            
                            map.setView([emergencyTarget.lat, emergencyTarget.lng], map.getZoom(), {
                                animate: false,
                                noMoveStart: true
                            });
                            
                            requestAnimationFrame(() => {
                                mapContainer.style.transition = '';
                            });
                            
                            lastCenteringTime = Date.now();
                            animationFrameId = null;
                            return;
                        }
                        
                        const pixelBaseThreshold = 0.18;
                        const speedNormalized = Math.min(1, speedMPH / 80);
                        const pixelSpeedAdaptiveThreshold = Math.max(0.04, pixelBaseThreshold - (speedNormalized * 0.12));
                        
                        const eastWestPixelThreshold = eastWestMovement ? pixelSpeedAdaptiveThreshold * 0.85 : pixelSpeedAdaptiveThreshold;
                        const northSouthPixelThreshold = eastWestMovement ? pixelSpeedAdaptiveThreshold * 1.12 : pixelSpeedAdaptiveThreshold;
                        
                        const isNearEdgePixel = (
                            userPixelPoint.x < mapSize.x * eastWestPixelThreshold ||
                            userPixelPoint.x > mapSize.x * (1 - eastWestPixelThreshold) ||
                            userPixelPoint.y < mapSize.y * northSouthPixelThreshold ||
                            userPixelPoint.y > mapSize.y * (1 - northSouthPixelThreshold)
                        );
                        
                        const mapWidth = bounds.getEast() - bounds.getWest();
                        const mapHeight = bounds.getNorth() - bounds.getSouth();
                        
                        const geoBasePadding = 0.18;
                        const geoSpeedAdaptivePadding = Math.max(0.04, geoBasePadding - (speedNormalized * 0.12));
                        
                        const eastWestPaddingMultiplier = eastWestMovement ? 0.85 : 1.0;
                        const northSouthPaddingMultiplier = eastWestMovement ? 1.12 : 1.0;
                        
                        const edgePaddingLng = mapWidth * geoSpeedAdaptivePadding * eastWestPaddingMultiplier;
                        const edgePaddingLat = mapHeight * geoSpeedAdaptivePadding * northSouthPaddingMultiplier;
                        
                        const isNearEdgeGeo = 
                            userPos.lat > (bounds.getNorth() - edgePaddingLat) ||
                            userPos.lat < (bounds.getSouth() + edgePaddingLat) ||
                            userPos.lng > (bounds.getEast() - edgePaddingLng) ||
                            userPos.lng < (bounds.getWest() + edgePaddingLng);
                            
                        const isOutsideBounds = !bounds.contains(userPos);
                        
                        if (isOutsideBounds || isNearEdgePixel || isNearEdgeGeo) {
                            const now = Date.now();
                            if (now - lastCenteringTime > CONFIG.MIN_CENTERING_INTERVAL) {
                                const targetPosition = lookAheadPosition;
                                
                                const basePanDuration = speedTier.panDuration;
                                const panDuration = basePanDuration * directionChangeFactor * (eastWestMovement ? 0.9 : 1.0);
                                const easeLinearity = speedTier.easeLinearity * (eastWestMovement ? 0.82 : 1.0);
                                
                                const mapContainer = map.getContainer();
                                const tiles = mapContainer.querySelectorAll('.leaflet-tile-container');
                                tiles.forEach(container => {
                                    container.style.backfaceVisibility = 'hidden';
                                    container.style.transform = 'translateZ(0)';
                                    container.style.willChange = 'transform';
                                    
                                    if (eastWestMovement) {
                                        container.style.imageRendering = 'crisp-edges';
                                    }
                                });
                                
                                map.panTo([targetPosition.lat, targetPosition.lng], {
                                    animate: true,
                                    duration: panDuration,
                                    easeLinearity: easeLinearity,
                                    noZoom: true,
                                    noMoveStart: true
                                });
                                
                                setTimeout(() => {
                                    tiles.forEach(container => {
                                        if (container) {
                                            container.style.willChange = 'auto';
                                            container.style.imageRendering = '';
                                        }
                                    });
                                }, panDuration * 1000 + 100);
                                
                                lastCenteringTime = now;
                            }
                        } else if (lookAheadPosition) {
                            const targetPosition = lookAheadPosition;
                            const panDuration = speedTier.panDuration * 1.2 * directionChangeFactor * (eastWestMovement ? 0.9 : 1.0);
                            const easeLinearity = speedTier.easeLinearity * 0.8 * (eastWestMovement ? 0.9 : 1.0);
                            
                            map.panTo([targetPosition.lat, targetPosition.lng], {
                                animate: true,
                                duration: panDuration,
                                easeLinearity: easeLinearity,
                                noMoveStart: true
                            });
                        }
                    }
                    
                    const intelligentZoom = getSpeedBasedZoom(smoothedPosition.speedMPS);
                    const zoomThreshold = speedTier.zoomThreshold;
                    
                    if (intelligentZoom && Math.abs(map.getZoom() - intelligentZoom) >= zoomThreshold) {
                        const zoomDuration = speedTier.zoomDuration * directionChangeFactor;
                        
                        const mapContainer = map.getContainer();
                        const originalOverflow = mapContainer.style.overflow;
                        mapContainer.style.overflow = 'hidden';
                        
                        map.setZoom(intelligentZoom, { 
                            animate: true, 
                            duration: zoomDuration,
                            noMoveStart: true
                        });
                        
                        setTimeout(() => {
                            if (mapContainer) {
                                mapContainer.style.overflow = originalOverflow;
                            }
                        }, zoomDuration * 1000 + 50);
                    }
                }
                
                animationFrameId = null;
            });
            
            lastMapUpdateTime = currentTime;
        }
        
        lastPosition = finalSmoothedPosition;
        lastUpdateTime = currentTime;
        lastUpdateTimestamp = currentTime;
        updateDistanceBox();
        
    } catch (error) {
        console.error("Location update error:", error);
        
        if (animationFrameId !== null) {
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
        }
        
        userMarker.setLatLng([smoothedPosition.lat, smoothedPosition.lng], { 
            animate: true, 
            duration: 0.4,
            easeLinearity: 0.15
        });
        lastPosition = smoothedPosition;
        positionBuffer = [smoothedPosition];
        updateDistanceBox();
    }
    
    if (followUser && !isMapInteracting) {
        const SAFETY_DEBOUNCE = 40;
        const now = performance.now();
        if (now - lastCenteringTime > SAFETY_DEBOUNCE) {
            const currentMarkerPos = userMarker.getLatLng();
            const bounds = map.getBounds();

            if (!bounds.contains(currentMarkerPos)) {
                const container = map.getContainer();
                container.style.willChange = 'transform';
                container.style.backfaceVisibility = 'hidden';
                
                map.panTo(currentMarkerPos, { 
                    animate: true, 
                    duration: 0.2, 
                    easeLinearity: 0.25,
                    noMoveStart: true 
                });
                
                setTimeout(() => {
                    if (container) {
                        container.style.willChange = 'auto';
                        container.style.backfaceVisibility = 'visible';
                    }
                }, 250);
            } else {
                const pixelPoint = map.latLngToContainerPoint(currentMarkerPos);
                const mapSize = map.getSize();
                const centerX = mapSize.x / 2;
                const centerY = mapSize.y / 2;
                const maxDist = Math.max(
                    Math.abs(pixelPoint.x - centerX) / centerX,
                    Math.abs(pixelPoint.y - centerY) / centerY
                );
                const dynamicMargin = 0.04 + (1 - maxDist) * 0.05;
                const speedMPH = smoothedPosition.speedMPS * 2.23694;
                const speedFactor = Math.min(1, speedMPH / 50);
                const margin = dynamicMargin * (0.7 + speedFactor * 0.3);

                const isAtEdge =
                    pixelPoint.x < mapSize.x * margin ||
                    pixelPoint.x > mapSize.x * (1 - margin) ||
                    pixelPoint.y < mapSize.y * margin ||
                    pixelPoint.y > mapSize.y * (1 - margin);

                if (isAtEdge) {
                    const container = map.getContainer();
                    container.style.willChange = 'transform';
                    container.style.backfaceVisibility = 'hidden';
                    
                    map.panTo(currentMarkerPos, { 
                        animate: true, 
                        duration: 0.3, 
                        easeLinearity: 0.2,
                        noMoveStart: true 
                    });
                    
                    setTimeout(() => {
                        if (container) {
                            container.style.willChange = 'auto';
                            container.style.backfaceVisibility = 'visible';
                        }
                    }, 350);
                }
            }
            lastCenteringTime = now;
        }
    }
}
<!-- 2 -->
function updateUserLocation(position, forceUpdate = false) {
    if (!position?.coords?.latitude || !position?.coords?.longitude) {
        console.warn("Invalid position data received");
        return;
    }
    
    if (animationFrameId !== null) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
    }
    
    const currentTime = Date.now();
    const timeDelta = lastUpdateTime ? (currentTime - lastUpdateTime) / 1000 : 0;
    const newPosition = {
        lat: position.coords.latitude,
        lng: position.coords.longitude,
        accuracy: position.coords.accuracy || 20,
        heading: position.coords.heading ?? null,
        timestamp: currentTime,
        speedMPS: position.coords.speed || 0
    };
    
    const velocityFilteredPosition = calculateVelocityFilter(newPosition, lastPosition || newPosition);
    const smoothedPosition = applyExponentialSmoothing(velocityFilteredPosition, lastSmoothedPosition || velocityFilteredPosition);
    lastSmoothedPosition = smoothedPosition;
    
    if (gameLocations && gameLocations.length > 0) {
        gameLocations.forEach(location => {
            enterpriseCacheManager.cacheLocationData(location, smoothedPosition);
        });
    }
    
    if (!lastPosition) {
        lastPosition = smoothedPosition;
        
        const mapContainer = map.getContainer();
        const originalTransition = mapContainer.style.transition;
        mapContainer.style.transition = 'none';
        
        userMarker.setLatLng([smoothedPosition.lat, smoothedPosition.lng]);
        
        const currentZoom = map.getZoom();
        map.setView([smoothedPosition.lat, smoothedPosition.lng], currentZoom, { 
            animate: false,
            noMoveStart: true
        });
        
        requestAnimationFrame(() => {
            mapContainer.style.transition = originalTransition;
        });
        
        lastUpdateTime = currentTime;
        stationaryStartTime = currentTime;
        positionBuffer = [smoothedPosition];
        
        const intelligentZoom = getSpeedBasedZoom(smoothedPosition.speedMPS);
        if (intelligentZoom) {
            map.setZoom(intelligentZoom, { animate: false, noMoveStart: true });
        }
        
        updateDistanceBox();
        updateAccuracyIndicator(smoothedPosition.accuracy);
        return;
    }
    
    const distance = calculateDistance(lastPosition, smoothedPosition);
    const speedMPH = smoothedPosition.speedMPS * 2.23694;
    
    const latDelta = Math.abs(smoothedPosition.lat - lastPosition.lat);
    const lngDelta = Math.abs(smoothedPosition.lng - lastPosition.lng);
    const eastWestMovement = lngDelta > latDelta * 1.15;
    
    let directionChangeFactor = 1.0;
    let headingDiff = 0;
    
    if (lastPosition.heading !== null && lastPosition.heading !== undefined && 
        smoothedPosition.heading !== null && smoothedPosition.heading !== undefined) {
        headingDiff = Math.abs(smoothedPosition.heading - lastPosition.heading);
        if (headingDiff > 180) headingDiff = 360 - headingDiff;
        
        if (headingDiff > 15) {
            directionChangeFactor = Math.max(0.5, 1 - (headingDiff / 220));
        }
    }
    
    const speedFactor = Math.min(1, Math.max(0.01, smoothedPosition.speedMPS / 15));
    
    const speedTierConfigs = [
        { maxSpeed: 0.5, micro: 0.12, minDist: 0.2, maxAcc: 1.5, mapInt: 1000, mapDist: 1.8, panDur: 2.2, ease: 0.08, zoomTh: 2.8, zoomDur: 3.5 },
        { maxSpeed: 2, micro: 0.25, minDist: 0.35, maxAcc: 1.3, mapInt: 900, mapDist: 2.8, panDur: 1.8, ease: 0.1, zoomTh: 2.4, zoomDur: 3.0 },
        { maxSpeed: 5, micro: 0.4, minDist: 0.5, maxAcc: 1.15, mapInt: 700, mapDist: 4.5, panDur: 1.4, ease: 0.12, zoomTh: 2.0, zoomDur: 2.5 },
        { maxSpeed: 10, micro: 0.35, minDist: 0.45, maxAcc: 1.08, mapInt: 500, mapDist: 3.8, panDur: 1.1, ease: 0.15, zoomTh: 1.6, zoomDur: 2.2 },
        { maxSpeed: 20, micro: 0.5, minDist: 0.6, maxAcc: 1.1, mapInt: 400, mapDist: 7.5, panDur: 0.9, ease: 0.18, zoomTh: 1.3, zoomDur: 1.8 },
        { maxSpeed: 35, micro: 0.9, minDist: 0.9, maxAcc: 1.25, mapInt: 350, mapDist: 13, panDur: 0.7, ease: 0.22, zoomTh: 1.1, zoomDur: 1.5 },
        { maxSpeed: 50, micro: 1.2, minDist: 1.2, maxAcc: 1.35, mapInt: 280, mapDist: 16, panDur: 0.55, ease: 0.28, zoomTh: 0.9, zoomDur: 1.2 },
        { maxSpeed: 65, micro: 1.6, minDist: 1.6, maxAcc: 1.6, mapInt: 200, mapDist: 22, panDur: 0.42, ease: 0.35, zoomTh: 0.7, zoomDur: 1.0 },
        { maxSpeed: 80, micro: 2.0, minDist: 2.0, maxAcc: 1.8, mapInt: 150, mapDist: 28, panDur: 0.35, ease: 0.42, zoomTh: 0.55, zoomDur: 0.8 },
        { maxSpeed: Infinity, micro: 2.5, minDist: 2.5, maxAcc: 2.2, mapInt: 100, mapDist: 35, panDur: 0.28, ease: 0.5, zoomTh: 0.45, zoomDur: 0.6 }
    ];
    
    const config = speedTierConfigs.find(c => speedMPH < c.maxSpeed);
    const speedTier = {
        microMovementThreshold: CONFIG.MICRO_MOVEMENT_THRESHOLD * config.micro,
        minDistanceThreshold: CONFIG.MIN_DISTANCE_THRESHOLD * config.minDist,
        maxAccuracy: CONFIG.MAX_ACCEPTABLE_ACCURACY * config.maxAcc,
        maxSpeedThreshold: CONFIG.MAX_SPEED * (config.maxSpeed === Infinity ? 4.2 : config.maxSpeed * 0.1 + 0.4),
        mapUpdateInterval: config.mapInt,
        mapUpdateDistance: config.mapDist,
        panDuration: config.panDur,
        easeLinearity: config.ease,
        zoomThreshold: config.zoomTh,
        zoomDuration: config.zoomDur
    };
    
    const eastWestAdjustment = eastWestMovement ? 0.88 : 1.0;
    speedTier.panDuration *= eastWestAdjustment;
    speedTier.easeLinearity *= (eastWestMovement ? 0.92 : 1.0);
    speedTier.mapUpdateInterval = Math.max(50, speedTier.mapUpdateInterval * eastWestAdjustment);
    
    if (distance > CONFIG.EXTENDED_DISTANCE_THRESHOLD || forceUpdate) {
        if (stationaryCheckTimeout) {
            clearTimeout(stationaryCheckTimeout);
            stationaryCheckTimeout = null;
        }
        isStationary = false;
        stationaryStartTime = null;
        
        const transitionPosition = smoothedPosition;
        
        const mapContainer = map.getContainer();
        const originalTransition = mapContainer.style.transition;
        mapContainer.style.transition = 'none';
        
        userMarker.setLatLng([transitionPosition.lat, transitionPosition.lng], { animate: false });
        lastPosition = transitionPosition;
        positionBuffer = [transitionPosition];
        lastVelocity = { lat: 0, lng: 0 };
        
        const intelligentZoom = getSpeedBasedZoom(smoothedPosition.speedMPS);
        if (intelligentZoom) {
            map.setZoom(intelligentZoom, { animate: false, noMoveStart: true });
        }
        
        const currentZoom = map.getZoom();
        map.setView([transitionPosition.lat, transitionPosition.lng], currentZoom, { 
            animate: false, 
            duration: 0,
            noMoveStart: true
        });
        
        requestAnimationFrame(() => {
            mapContainer.style.transition = originalTransition;
        });
        
        lastUpdateTime = currentTime;
        lastUpdateTimestamp = currentTime;
        
        if (isSignificantMovement(transitionPosition)) {
            resetInactivityTimer(false);
        }
            
        updateDistanceBox();
        
        if (map._container) {
            map._onResize();
        }
        return;
    }
    
    const dynamicMicroThreshold = speedTier.microMovementThreshold;
    const jitterSuppression = speedMPH < 2 ? Math.max(dynamicMicroThreshold, distance * 1.3) : dynamicMicroThreshold;
    const directionAdjustedJitterSuppression = jitterSuppression * (eastWestMovement ? 0.92 : 1.0);
    
    if (distance < directionAdjustedJitterSuppression && !forceUpdate) {
        if (!isStationary) {
            if (!stationaryStartTime) {
                stationaryStartTime = currentTime;
            } else if (currentTime - stationaryStartTime >= CONFIG.STATIONARY_TIME_THRESHOLD * 0.75) {
                isStationary = true;
                
                const currentLatLng = userMarker.getLatLng();
                const targetLatLng = L.latLng(smoothedPosition.lat, smoothedPosition.lng);
                const stationaryDistance = currentLatLng.distanceTo(targetLatLng);
                
                if (stationaryDistance > 0.8) {
                    userMarker.setLatLng([smoothedPosition.lat, smoothedPosition.lng], { 
                        animate: true, 
                        duration: 0.6,
                        easeLinearity: 0.08
                    });
                } else {
                    userMarker.setLatLng([smoothedPosition.lat, smoothedPosition.lng], { animate: false });
                }
                
                lastPosition = smoothedPosition;
                positionBuffer = [smoothedPosition];
                
                if (stationaryCheckTimeout) clearTimeout(stationaryCheckTimeout);
                stationaryCheckTimeout = setTimeout(() => checkStationaryState(smoothedPosition), CONFIG.STATIONARY_CHECK_INTERVAL);
                
                updateDistanceBox();
                return;
            }
        }
        
        if (isStationary) {
            if (smoothedPosition.accuracy < lastPosition.accuracy * 0.92) {
                userMarker.setLatLng([smoothedPosition.lat, smoothedPosition.lng], { animate: false });
                lastPosition = smoothedPosition;
                updateDistanceBox();
            }
            return;
        }
    } else {
        isStationary = false;
        stationaryStartTime = null;
        if (stationaryCheckTimeout) {
            clearTimeout(stationaryCheckTimeout);
            stationaryCheckTimeout = null;
        }
    }
    
    const dynamicMinDistance = speedTier.minDistanceThreshold * (eastWestMovement ? 0.92 : 1.0);
    const dynamicMaxAccuracy = speedTier.maxAccuracy;
    const dynamicMaxSpeed = speedTier.maxSpeedThreshold;
    
    const jitterFilteredDistance = speedMPH < 5 ? Math.max(distance, dynamicMinDistance * 1.15) : distance;
    
    if (!forceUpdate && (
        smoothedPosition.accuracy > dynamicMaxAccuracy ||
        jitterFilteredDistance < dynamicMinDistance ||
        (timeDelta > 0 && jitterFilteredDistance / timeDelta > dynamicMaxSpeed)
    )) {
        return;
    }
    
    try {
        updatePositionBuffer(smoothedPosition);
        
        const finalPosition = calculateFinalPosition();
        if (!finalPosition) throw new Error("Final position calculation failed");
        
        const predictedPosition = calculateEnhancedVelocityFilter(finalPosition, lastPosition, timeDelta, smoothedPosition.speedMPS);
        
        const smoothingBrackets = [
            { threshold: 0.5, base: 0.1, mult: 0.12, max: 0.22, min: 0.06 },
            { threshold: 2, base: 0.18, mult: 0.14, max: 0.32, min: 0.12 },
            { threshold: 5, base: 0.28, mult: 0.18, max: 0.46, min: 0.22 },
            { threshold: 10, base: 0.3, mult: 0.23, max: 0.6, min: 0.22 },
            { threshold: 20, base: 0.48, mult: 0.19, max: 0.68, min: 0.4 },
            { threshold: 35, base: 0.58, mult: 0.17, max: 0.76, min: 0.5 },
            { threshold: 50, base: 0.66, mult: 0.14, max: 0.8, min: 0.6 },
            { threshold: 65, base: 0.72, mult: 0.13, max: 0.86, min: 0.68 },
            { threshold: 80, base: 0.77, mult: 0.11, max: 0.89, min: 0.74 },
            { threshold: Infinity, base: 0.81, mult: 0.09, max: 0.92, min: 0.78 }
        ];
        
        const bracket = smoothingBrackets.find(b => speedMPH < b.threshold);
        let baseFactor = Math.min(bracket.max, Math.max(bracket.min, bracket.base + (speedFactor * bracket.mult)));
        
        const distanceAdjustment = Math.min(0.08, distance * 0.005);
        const timeAdjustment = timeDelta > 0 ? Math.min(0.05, Math.max(-0.03, (timeDelta - 0.35) * 0.07)) : 0;
        const jitterDampening = speedMPH < 3 ? Math.max(0, 0.04 - (speedMPH * 0.013)) : 0;
        const directionChangeAdjustment = headingDiff > 25 ? Math.max(0, 0.06 - (headingDiff / 200) * 0.08) : 0;
        const eastWestSmoothingBonus = eastWestMovement ? 0.025 : 0;
        
        const adjustedSmoothingFactor = Math.min(0.94, Math.max(0.04, 
            baseFactor + distanceAdjustment + timeAdjustment - jitterDampening - directionChangeAdjustment + eastWestSmoothingBonus
        ));
        
        const jitterReductionFactor = speedMPH < 3 ? 0.87 : 1.0;
        const finalSmoothingFactor = adjustedSmoothingFactor * jitterReductionFactor * directionChangeFactor;
       
        const finalSmoothedPosition = {
            lat: lastPosition.lat * (1 - finalSmoothingFactor) + predictedPosition.lat * finalSmoothingFactor,
            lng: lastPosition.lng * (1 - finalSmoothingFactor) + predictedPosition.lng * finalSmoothingFactor,
            accuracy: predictedPosition.accuracy,
            heading: predictedPosition.heading,
            timestamp: currentTime,
            speedMPS: predictedPosition.speedMPS
        };
        
        const durationBrackets = [
            { threshold: 0.5, base: 1.0, mult: -0.12, max: 1.3, min: 0.7 },
            { threshold: 2, base: 0.8, mult: -0.14, max: 1.0, min: 0.5 },
            { threshold: 5, base: 0.65, mult: -0.12, max: 0.8, min: 0.4 },
            { threshold: 10, base: 0.45, mult: -0.1, max: 0.65, min: 0.28 },
            { threshold: 20, base: 0.35, mult: -0.08, max: 0.5, min: 0.22 },
            { threshold: 35, base: 0.32, mult: -0.07, max: 0.42, min: 0.2 },
            { threshold: 50, base: 0.28, mult: -0.06, max: 0.36, min: 0.18 },
            { threshold: 65, base: 0.22, mult: -0.04, max: 0.28, min: 0.15 },
            { threshold: 80, base: 0.18, mult: -0.03, max: 0.23, min: 0.12 },
            { threshold: Infinity, base: 0.14, mult: -0.025, max: 0.18, min: 0.08 }
        ];
        
        const durationBracket = durationBrackets.find(b => speedMPH < b.threshold);
        const baseDuration = Math.min(durationBracket.max, Math.max(durationBracket.min, durationBracket.base + (speedFactor * durationBracket.mult)));
        
        const distanceModifier = Math.min(0.05, distance * 0.0015);
        const timeModifier = timeDelta > 0 ? Math.max(-0.02, Math.min(0.03, (0.22 - timeDelta) * 0.07)) : 0;
        const jitterCompensation = speedMPH < 2 ? Math.min(0.06, (2 - speedMPH) * 0.03) : 0;
        const directionChangeCompensation = headingDiff > 20 ? Math.min(0.08, headingDiff / 200 * 0.12) : 0;
        const eastWestDurationBonus = eastWestMovement ? Math.min(0.04, distance * 0.0008) : 0;
        
        const jitterCompensatedDuration = Math.max(0.03, 
            baseDuration - distanceModifier + timeModifier + jitterCompensation + directionChangeCompensation + eastWestDurationBonus
        );
        
        const finalAnimationDuration = jitterCompensatedDuration * directionChangeFactor;
        
        const markerElement = userMarker.getElement();
        if (markerElement) {
            markerElement.style.willChange = 'transform';
            markerElement.style.backfaceVisibility = 'hidden';
            markerElement.style.transform = 'translateZ(0)';
            
            if (eastWestMovement) {
                markerElement.style.imageRendering = 'crisp-edges';
            }
        }
        
        const finalEaseLinearity = eastWestMovement ?
            Math.max(0.02, Math.min(0.18, (0.1 - (speedMPH * 0.0008)) * directionChangeFactor)) :
            Math.max(0.04, Math.min(0.22, (0.12 - (speedMPH * 0.0015)) * directionChangeFactor));
        
        userMarker.setLatLng([finalSmoothedPosition.lat, finalSmoothedPosition.lng], {
            animate: true,
            duration: finalAnimationDuration,
            easeLinearity: finalEaseLinearity
        });
        
        const mapUpdateInterval = speedTier.mapUpdateInterval;
        const mapUpdateDistanceThreshold = speedTier.mapUpdateDistance * (eastWestMovement ? 0.92 : 1.0);
        
        if (currentTime - lastMapUpdateTime > mapUpdateInterval || distance > mapUpdateDistanceThreshold) {
            checkProximityForZoom();
            
            const lookAheadBrackets = [
                { threshold: 0.5, base: 0, mult: 0.015, max: 0.025 },
                { threshold: 2, base: 0, mult: 0.032, max: 0.05 },
                { threshold: 5, base: 0, mult: 0.055, max: 0.085 },
                { threshold: 10, base: 0, mult: 0.09, max: 0.13 },
                { threshold: 20, base: 0, mult: 0.13, max: 0.19 },
                { threshold: 35, base: 0, mult: 0.19, max: 0.28 },
                { threshold: 50, base: 0, mult: 0.26, max: 0.38 },
                { threshold: 65, base: 0, mult: 0.34, max: 0.48 },
                { threshold: 80, base: 0, mult: 0.42, max: 0.58 },
                { threshold: Infinity, base: 0, mult: 0.54, max: 0.7 }
            ];
            
            const lookAheadBracket = lookAheadBrackets.find(b => speedMPH < b.threshold);
            const baseLookAhead = Math.min(lookAheadBracket.max, lookAheadBracket.base + (speedFactor * lookAheadBracket.mult));
            
            const distanceBoost = Math.min(0.1, distance * 0.006);
            const directionChangeLookAheadReduction = headingDiff > 30 ? Math.min(0.18, headingDiff / 200 * 0.25) : 0;
            const eastWestLookAheadBonus = eastWestMovement ? Math.min(0.06, distance * 0.0015) : 0;
            
            const lookAheadFactor = Math.min(0.75, Math.max(0.008, 
                baseLookAhead + distanceBoost - directionChangeLookAheadReduction + eastWestLookAheadBonus
            ));
            
            const lookAheadPosition = {
                lat: finalSmoothedPosition.lat + (predictedPosition.lat - lastPosition.lat) * lookAheadFactor,
                lng: finalSmoothedPosition.lng + (predictedPosition.lng - lastPosition.lng) * lookAheadFactor
            };
            
            animationFrameId = requestAnimationFrame(() => {
                if (followUser && !isMapInteracting) {
                    const userPos = finalSmoothedPosition;
                    const bounds = map.getBounds();
                    
                    if (userPos && bounds) {
                        const userPixelPoint = map.latLngToContainerPoint(userPos);
                        const mapSize = map.getSize();
                        
                        const pixelBaseThreshold = 0.22;
                        const speedNormalized = Math.min(1, speedMPH / 80);
                        const pixelSpeedAdaptiveThreshold = Math.max(0.06, pixelBaseThreshold - (speedNormalized * 0.14));
                        
                        const eastWestPixelThreshold = eastWestMovement ? pixelSpeedAdaptiveThreshold * 0.88 : pixelSpeedAdaptiveThreshold;
                        const northSouthPixelThreshold = eastWestMovement ? pixelSpeedAdaptiveThreshold * 1.08 : pixelSpeedAdaptiveThreshold;
                        
                        const isNearEdgePixel = (
                            userPixelPoint.x < mapSize.x * eastWestPixelThreshold ||
                            userPixelPoint.x > mapSize.x * (1 - eastWestPixelThreshold) ||
                            userPixelPoint.y < mapSize.y * northSouthPixelThreshold ||
                            userPixelPoint.y > mapSize.y * (1 - northSouthPixelThreshold)
                        );
                        
                        const mapWidth = bounds.getEast() - bounds.getWest();
                        const mapHeight = bounds.getNorth() - bounds.getSouth();
                        
                        const geoBasePadding = 0.22;
                        const geoSpeedAdaptivePadding = Math.max(0.06, geoBasePadding - (speedNormalized * 0.14));
                        
                        const eastWestPaddingMultiplier = eastWestMovement ? 0.88 : 1.0;
                        const northSouthPaddingMultiplier = eastWestMovement ? 1.08 : 1.0;
                        
                        const edgePaddingLng = mapWidth * geoSpeedAdaptivePadding * eastWestPaddingMultiplier;
                        const edgePaddingLat = mapHeight * geoSpeedAdaptivePadding * northSouthPaddingMultiplier;
                        
                        const isNearEdgeGeo = 
                            userPos.lat > (bounds.getNorth() - edgePaddingLat) ||
                            userPos.lat < (bounds.getSouth() + edgePaddingLat) ||
                            userPos.lng > (bounds.getEast() - edgePaddingLng) ||
                            userPos.lng < (bounds.getWest() + edgePaddingLng);
                            
                        const isOutsideBounds = !bounds.contains(userPos);
                        
                        if (isOutsideBounds || isNearEdgePixel || isNearEdgeGeo) {
                            const now = Date.now();
                            if (now - lastCenteringTime > CONFIG.MIN_CENTERING_INTERVAL) {
                                const targetPosition = lookAheadPosition;
                                
                                const basePanDuration = speedTier.panDuration;
                                const panDuration = basePanDuration * directionChangeFactor * (eastWestMovement ? 0.92 : 1.0);
                                const easeLinearity = speedTier.easeLinearity * (eastWestMovement ? 0.85 : 1.0);
                                
                                const mapContainer = map.getContainer();
                                const tiles = mapContainer.querySelectorAll('.leaflet-tile-container');
                                tiles.forEach(container => {
                                    container.style.backfaceVisibility = 'hidden';
                                    container.style.transform = 'translateZ(0)';
                                    container.style.willChange = 'transform';
                                    
                                    if (eastWestMovement) {
                                        container.style.imageRendering = 'crisp-edges';
                                    }
                                });
                                
                                map.panTo([targetPosition.lat, targetPosition.lng], {
                                    animate: true,
                                    duration: panDuration,
                                    easeLinearity: easeLinearity,
                                    noZoom: true,
                                    noMoveStart: true
                                });
                                
                                setTimeout(() => {
                                    tiles.forEach(container => {
                                        if (container) {
                                            container.style.willChange = 'auto';
                                            container.style.imageRendering = '';
                                        }
                                    });
                                }, panDuration * 1000 + 100);
                                
                                lastCenteringTime = now;
                            }
                        } else if (lookAheadPosition) {
                            const targetPosition = lookAheadPosition;
                            const panDuration = speedTier.panDuration * 1.15 * directionChangeFactor * (eastWestMovement ? 0.92 : 1.0);
                            const easeLinearity = speedTier.easeLinearity * 0.85 * (eastWestMovement ? 0.92 : 1.0);
                            
                            map.panTo([targetPosition.lat, targetPosition.lng], {
                                animate: true,
                                duration: panDuration,
                                easeLinearity: easeLinearity,
                                noMoveStart: true
                            });
                        }
                    }
                    
                    const intelligentZoom = getSpeedBasedZoom(smoothedPosition.speedMPS);
                    const zoomThreshold = speedTier.zoomThreshold;
                    
                    if (intelligentZoom && Math.abs(map.getZoom() - intelligentZoom) >= zoomThreshold) {
                        const zoomDuration = speedTier.zoomDuration * directionChangeFactor;
                        
                        const mapContainer = map.getContainer();
                        const originalOverflow = mapContainer.style.overflow;
                        mapContainer.style.overflow = 'hidden';
                        
                        map.setZoom(intelligentZoom, { 
                            animate: true, 
                            duration: zoomDuration,
                            noMoveStart: true
                        });
                        
                        setTimeout(() => {
                            if (mapContainer) {
                                mapContainer.style.overflow = originalOverflow;
                            }
                        }, zoomDuration * 1000 + 50);
                    }
                }
                
                animationFrameId = null;
            });
            
            lastMapUpdateTime = currentTime;
        }
        
        lastPosition = finalSmoothedPosition;
        lastUpdateTime = currentTime;
        lastUpdateTimestamp = currentTime;
        updateDistanceBox();
        
    } catch (error) {
        console.error("Location update error:", error);
        
        if (animationFrameId !== null) {
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
        }
        
        userMarker.setLatLng([smoothedPosition.lat, smoothedPosition.lng], { 
            animate: true, 
            duration: 0.4,
            easeLinearity: 0.15
        });
        lastPosition = smoothedPosition;
        positionBuffer = [smoothedPosition];
        updateDistanceBox();
    }
    
    if (followUser && !isMapInteracting) {
        const SAFETY_DEBOUNCE = 60;
        const now = performance.now();
        if (now - lastCenteringTime > SAFETY_DEBOUNCE) {
            const currentMarkerPos = userMarker.getLatLng();
            const bounds = map.getBounds();

            if (!bounds.contains(currentMarkerPos)) {
                const container = map.getContainer();
                container.style.willChange = 'transform';
                container.style.backfaceVisibility = 'hidden';
                
                map.panTo(currentMarkerPos, { 
                    animate: true, 
                    duration: 0.25, 
                    easeLinearity: 0.2,
                    noMoveStart: true 
                });
                
                setTimeout(() => {
                    if (container) {
                        container.style.willChange = 'auto';
                        container.style.backfaceVisibility = 'visible';
                    }
                }, 300);
            } else {
                const pixelPoint = map.latLngToContainerPoint(currentMarkerPos);
                const mapSize = map.getSize();
                const centerX = mapSize.x / 2;
                const centerY = mapSize.y / 2;
                const maxDist = Math.max(
                    Math.abs(pixelPoint.x - centerX) / centerX,
                    Math.abs(pixelPoint.y - centerY) / centerY
                );
                const dynamicMargin = 0.06 + (1 - maxDist) * 0.06;
                const speedMPH = smoothedPosition.speedMPS * 2.23694;
                const speedFactor = Math.min(1, speedMPH / 50);
                const margin = dynamicMargin * (0.75 + speedFactor * 0.25);

                const isAtEdge =
                    pixelPoint.x < mapSize.x * margin ||
                    pixelPoint.x > mapSize.x * (1 - margin) ||
                    pixelPoint.y < mapSize.y * margin ||
                    pixelPoint.y > mapSize.y * (1 - margin);

                if (isAtEdge) {
                    const container = map.getContainer();
                    container.style.willChange = 'transform';
                    container.style.backfaceVisibility = 'hidden';
                    
                    map.panTo(currentMarkerPos, { 
                        animate: true, 
                        duration: 0.35, 
                        easeLinearity: 0.18,
                        noMoveStart: true 
                    });
                    
                    setTimeout(() => {
                        if (container) {
                            container.style.willChange = 'auto';
                            container.style.backfaceVisibility = 'visible';
                        }
                    }, 400);
                }
            }
            lastCenteringTime = now;
        }
    }
}
<!-- 3 -->
function updateUserLocation(position, forceUpdate = false) {
  if (!position?.coords?.latitude || !position?.coords?.longitude) {
      console.warn("Invalid position data received");
      return;
  }
  
  if (animationFrameId !== null) {
      cancelAnimationFrame(animationFrameId);
      animationFrameId = null;
  }
  
  const currentTime = Date.now();
  const timeDelta = lastUpdateTime ? (currentTime - lastUpdateTime) / 1000 : 0;
  const newPosition = {
      lat: position.coords.latitude,
      lng: position.coords.longitude,
      accuracy: position.coords.accuracy || 20,
      heading: position.coords.heading ?? null,
      timestamp: currentTime,
      speedMPS: position.coords.speed || 0
  };
  
  // APPLY FILTERING FUNCTIONS
  const velocityFilteredPosition = calculateVelocityFilter(newPosition, lastPosition || newPosition);
  const smoothedPosition = applyExponentialSmoothing(velocityFilteredPosition, lastSmoothedPosition || velocityFilteredPosition);
  
  // Update lastSmoothedPosition for next iteration
  lastSmoothedPosition = smoothedPosition;
  
  if (gameLocations && gameLocations.length > 0) {
      gameLocations.forEach(location => {
          enterpriseCacheManager.cacheLocationData(location, smoothedPosition);
      });
  }
  
  if (!lastPosition) {
      lastPosition = smoothedPosition;
      
      const mapContainer = map.getContainer();
      const originalTransition = mapContainer.style.transition;
      mapContainer.style.transition = 'none';
      
      userMarker.setLatLng([smoothedPosition.lat, smoothedPosition.lng]);
      
      const currentZoom = map.getZoom();
      map.setView([smoothedPosition.lat, smoothedPosition.lng], currentZoom, { 
          animate: false,
          noMoveStart: true
      });
      
      setTimeout(() => {
          mapContainer.style.transition = originalTransition;
      }, 50);
      
      lastUpdateTime = currentTime;
      stationaryStartTime = currentTime;
      positionBuffer = [smoothedPosition];
      
      const intelligentZoom = getSpeedBasedZoom(smoothedPosition.speedMPS);
      if (intelligentZoom) {
          map.setZoom(intelligentZoom, { animate: false, noMoveStart: true });
      }
      
      updateDistanceBox();
      updateAccuracyIndicator(smoothedPosition.accuracy);
      return;
  }
  
  const distance = calculateDistance(lastPosition, smoothedPosition);
  const speedMPH = smoothedPosition.speedMPS * 2.23694;
  
  const latDelta = Math.abs(smoothedPosition.lat - lastPosition.lat);
  const lngDelta = Math.abs(smoothedPosition.lng - lastPosition.lng);
  const eastWestMovement = lngDelta > latDelta * 1.15;
  
  let directionChangeFactor = 1.0;
  let headingDiff = 0;
  
  if (lastPosition.heading !== null && lastPosition.heading !== undefined && 
      smoothedPosition.heading !== null && smoothedPosition.heading !== undefined) {
      headingDiff = Math.abs(smoothedPosition.heading - lastPosition.heading);
      if (headingDiff > 180) headingDiff = 360 - headingDiff;
      
      if (headingDiff > 15) {
          directionChangeFactor = Math.max(0.5, 1 - (headingDiff / 220));
      }
  }
  
  const speedFactor = Math.min(1, Math.max(0.01, smoothedPosition.speedMPS / 15));
  
  let speedTier = {};
  
  if (speedMPH < 0.5) {
      speedTier = {
          microMovementThreshold: CONFIG.MICRO_MOVEMENT_THRESHOLD * 0.12,
          minDistanceThreshold: CONFIG.MIN_DISTANCE_THRESHOLD * 0.2,
          maxAccuracy: CONFIG.MAX_ACCEPTABLE_ACCURACY * 1.5,
          maxSpeedThreshold: CONFIG.MAX_SPEED * 0.4,
          mapUpdateInterval: 1000,
          mapUpdateDistance: 1.8,
          panDuration: 2.2,
          easeLinearity: 0.08,
          zoomThreshold: 2.8,
          zoomDuration: 3.5
      };
  } else if (speedMPH < 2) {
      speedTier = {
          microMovementThreshold: CONFIG.MICRO_MOVEMENT_THRESHOLD * 0.25,
          minDistanceThreshold: CONFIG.MIN_DISTANCE_THRESHOLD * 0.35,
          maxAccuracy: CONFIG.MAX_ACCEPTABLE_ACCURACY * 1.3,
          maxSpeedThreshold: CONFIG.MAX_SPEED * 0.6,
          mapUpdateInterval: 900,
          mapUpdateDistance: 2.8,
          panDuration: 1.8,
          easeLinearity: 0.1,
          zoomThreshold: 2.4,
          zoomDuration: 3.0
      };
  } else if (speedMPH < 5) {
      speedTier = {
          microMovementThreshold: CONFIG.MICRO_MOVEMENT_THRESHOLD * 0.4,
          minDistanceThreshold: CONFIG.MIN_DISTANCE_THRESHOLD * 0.5,
          maxAccuracy: CONFIG.MAX_ACCEPTABLE_ACCURACY * 1.15,
          maxSpeedThreshold: CONFIG.MAX_SPEED * 0.9,
          mapUpdateInterval: 700,
          mapUpdateDistance: 4.5,
          panDuration: 1.4,
          easeLinearity: 0.12,
          zoomThreshold: 2.0,
          zoomDuration: 2.5
      };
  } else if (speedMPH < 10) {
      speedTier = {
          microMovementThreshold: CONFIG.MICRO_MOVEMENT_THRESHOLD * 0.35,
          minDistanceThreshold: CONFIG.MIN_DISTANCE_THRESHOLD * 0.45,
          maxAccuracy: CONFIG.MAX_ACCEPTABLE_ACCURACY * 1.08,
          maxSpeedThreshold: CONFIG.MAX_SPEED * 1.2,
          mapUpdateInterval: 500,
          mapUpdateDistance: 3.8,
          panDuration: 1.1,
          easeLinearity: 0.15,
          zoomThreshold: 1.6,
          zoomDuration: 2.2
      };
  } else if (speedMPH < 20) {
      speedTier = {
          microMovementThreshold: CONFIG.MICRO_MOVEMENT_THRESHOLD * 0.5,
          minDistanceThreshold: CONFIG.MIN_DISTANCE_THRESHOLD * 0.6,
          maxAccuracy: CONFIG.MAX_ACCEPTABLE_ACCURACY * 1.1,
          maxSpeedThreshold: CONFIG.MAX_SPEED * 1.4,
          mapUpdateInterval: 400,
          mapUpdateDistance: 7.5,
          panDuration: 0.9,
          easeLinearity: 0.18,
          zoomThreshold: 1.3,
          zoomDuration: 1.8
      };
  } else if (speedMPH < 35) {
      speedTier = {
          microMovementThreshold: CONFIG.MICRO_MOVEMENT_THRESHOLD * 0.9,
          minDistanceThreshold: CONFIG.MIN_DISTANCE_THRESHOLD * 0.9,
          maxAccuracy: CONFIG.MAX_ACCEPTABLE_ACCURACY * 1.25,
          maxSpeedThreshold: CONFIG.MAX_SPEED * 1.6,
          mapUpdateInterval: 350,
          mapUpdateDistance: 13,
          panDuration: 0.7,
          easeLinearity: 0.22,
          zoomThreshold: 1.1,
          zoomDuration: 1.5
      };
  } else if (speedMPH < 50) {
      speedTier = {
          microMovementThreshold: CONFIG.MICRO_MOVEMENT_THRESHOLD * 1.2,
          minDistanceThreshold: CONFIG.MIN_DISTANCE_THRESHOLD * 1.2,
          maxAccuracy: CONFIG.MAX_ACCEPTABLE_ACCURACY * 1.35,
          maxSpeedThreshold: CONFIG.MAX_SPEED * 2.0,
          mapUpdateInterval: 280,
          mapUpdateDistance: 16,
          panDuration: 0.55,
          easeLinearity: 0.28,
          zoomThreshold: 0.9,
          zoomDuration: 1.2
      };
  } else if (speedMPH < 65) {
      speedTier = {
          microMovementThreshold: CONFIG.MICRO_MOVEMENT_THRESHOLD * 1.6,
          minDistanceThreshold: CONFIG.MIN_DISTANCE_THRESHOLD * 1.6,
          maxAccuracy: CONFIG.MAX_ACCEPTABLE_ACCURACY * 1.6,
          maxSpeedThreshold: CONFIG.MAX_SPEED * 2.5,
          mapUpdateInterval: 200,
          mapUpdateDistance: 22,
          panDuration: 0.42,
          easeLinearity: 0.35,
          zoomThreshold: 0.7,
          zoomDuration: 1.0
      };
  } else if (speedMPH < 80) {
      speedTier = {
          microMovementThreshold: CONFIG.MICRO_MOVEMENT_THRESHOLD * 2.0,
          minDistanceThreshold: CONFIG.MIN_DISTANCE_THRESHOLD * 2.0,
          maxAccuracy: CONFIG.MAX_ACCEPTABLE_ACCURACY * 1.8,
          maxSpeedThreshold: CONFIG.MAX_SPEED * 3.2,
          mapUpdateInterval: 150,
          mapUpdateDistance: 28,
          panDuration: 0.35,
          easeLinearity: 0.42,
          zoomThreshold: 0.55,
          zoomDuration: 0.8
      };
  } else {
      speedTier = {
          microMovementThreshold: CONFIG.MICRO_MOVEMENT_THRESHOLD * 2.5,
          minDistanceThreshold: CONFIG.MIN_DISTANCE_THRESHOLD * 2.5,
          maxAccuracy: CONFIG.MAX_ACCEPTABLE_ACCURACY * 2.2,
          maxSpeedThreshold: CONFIG.MAX_SPEED * 4.2,
          mapUpdateInterval: 100,
          mapUpdateDistance: 35,
          panDuration: 0.28,
          easeLinearity: 0.5,
          zoomThreshold: 0.45,
          zoomDuration: 0.6
      };
  }
  
  const eastWestAdjustment = eastWestMovement ? 0.88 : 1.0;
  speedTier.panDuration *= eastWestAdjustment;
  speedTier.easeLinearity *= (eastWestMovement ? 0.92 : 1.0);
  speedTier.mapUpdateInterval = Math.max(50, speedTier.mapUpdateInterval * eastWestAdjustment);
  
  if (distance > CONFIG.EXTENDED_DISTANCE_THRESHOLD || forceUpdate) {
      if (stationaryCheckTimeout) {
          clearTimeout(stationaryCheckTimeout);
          stationaryCheckTimeout = null;
      }
      isStationary = false;
      stationaryStartTime = null;
      
      const transitionPosition = smoothedPosition;
      
      const mapContainer = map.getContainer();
      const originalTransition = mapContainer.style.transition;
      mapContainer.style.transition = 'none';
      
      userMarker.setLatLng([transitionPosition.lat, transitionPosition.lng], { animate: false });
      lastPosition = transitionPosition;
      positionBuffer = [transitionPosition];
      lastVelocity = { lat: 0, lng: 0 };
      
      const intelligentZoom = getSpeedBasedZoom(smoothedPosition.speedMPS);
      if (intelligentZoom) {
          map.setZoom(intelligentZoom, { animate: false, noMoveStart: true });
      }
      
      const currentZoom = map.getZoom();
      map.setView([transitionPosition.lat, transitionPosition.lng], currentZoom, { 
          animate: false, 
          duration: 0,
          noMoveStart: true
      });
      
      setTimeout(() => {
          mapContainer.style.transition = originalTransition;
      }, 16);
      
      lastUpdateTime = currentTime;
      lastUpdateTimestamp = currentTime;
      
      if (isSignificantMovement(transitionPosition)) {
          resetInactivityTimer(false);
      }
          
      updateDistanceBox();
      
      if (map._container) {
          map._onResize();
      }
      return;
  }
  
  const dynamicMicroThreshold = speedTier.microMovementThreshold;
  const jitterSuppression = speedMPH < 2 ? Math.max(dynamicMicroThreshold, distance * 1.3) : dynamicMicroThreshold;
  const directionAdjustedJitterSuppression = jitterSuppression * (eastWestMovement ? 0.92 : 1.0);
  
  if (distance < directionAdjustedJitterSuppression && !forceUpdate) {
      if (!isStationary) {
          if (!stationaryStartTime) {
              stationaryStartTime = currentTime;
          } else if (currentTime - stationaryStartTime >= CONFIG.STATIONARY_TIME_THRESHOLD * 0.75) {
              isStationary = true;
              
              const currentLatLng = userMarker.getLatLng();
              const targetLatLng = L.latLng(smoothedPosition.lat, smoothedPosition.lng);
              const stationaryDistance = currentLatLng.distanceTo(targetLatLng);
              
              if (stationaryDistance > 0.8) {
                  userMarker.setLatLng([smoothedPosition.lat, smoothedPosition.lng], { 
                      animate: true, 
                      duration: 0.6,
                      easeLinearity: 0.08
                  });
              } else {
                  userMarker.setLatLng([smoothedPosition.lat, smoothedPosition.lng], { animate: false });
              }
              
              lastPosition = smoothedPosition;
              positionBuffer = [smoothedPosition];
              
              if (stationaryCheckTimeout) clearTimeout(stationaryCheckTimeout);
              stationaryCheckTimeout = setTimeout(() => checkStationaryState(smoothedPosition), CONFIG.STATIONARY_CHECK_INTERVAL);
              
              updateDistanceBox();
              return;
          }
      }
      
      if (isStationary) {
          if (smoothedPosition.accuracy < lastPosition.accuracy * 0.92) {
              userMarker.setLatLng([smoothedPosition.lat, smoothedPosition.lng], { animate: false });
              lastPosition = smoothedPosition;
              updateDistanceBox();
          }
          return;
      }
  } else {
      isStationary = false;
      stationaryStartTime = null;
      if (stationaryCheckTimeout) {
          clearTimeout(stationaryCheckTimeout);
          stationaryCheckTimeout = null;
      }
  }
  
  const dynamicMinDistance = speedTier.minDistanceThreshold * (eastWestMovement ? 0.92 : 1.0);
  const dynamicMaxAccuracy = speedTier.maxAccuracy;
  const dynamicMaxSpeed = speedTier.maxSpeedThreshold;
  
  const jitterFilteredDistance = speedMPH < 5 ? Math.max(distance, dynamicMinDistance * 1.15) : distance;
  
  if (!forceUpdate && (
      smoothedPosition.accuracy > dynamicMaxAccuracy ||
      jitterFilteredDistance < dynamicMinDistance ||
      (timeDelta > 0 && jitterFilteredDistance / timeDelta > dynamicMaxSpeed)
  )) {
      return;
  }
  
  try {
      updatePositionBuffer(smoothedPosition);
      
      const finalPosition = calculateFinalPosition();
      if (!finalPosition) throw new Error("Final position calculation failed");
      
      const predictedPosition = calculateEnhancedVelocityFilter(finalPosition, lastPosition, timeDelta, smoothedPosition.speedMPS);
      
      let baseFactor;
      
      const speedFactorBrackets = [
          { threshold: 0.5, base: 0.1, factorMult: 0.12, max: 0.22, min: 0.06 },
          { threshold: 2, base: 0.18, factorMult: 0.14, max: 0.32, min: 0.12 },
          { threshold: 5, base: 0.28, factorMult: 0.18, max: 0.46, min: 0.22 },
          { threshold: 10, base: 0.3, factorMult: 0.23, max: 0.6, min: 0.22 },
          { threshold: 20, base: 0.48, factorMult: 0.19, max: 0.68, min: 0.4 },
          { threshold: 35, base: 0.58, factorMult: 0.17, max: 0.76, min: 0.5 },
          { threshold: 50, base: 0.66, factorMult: 0.14, max: 0.8, min: 0.6 },
          { threshold: 65, base: 0.72, factorMult: 0.13, max: 0.86, min: 0.68 },
          { threshold: 80, base: 0.77, factorMult: 0.11, max: 0.89, min: 0.74 },
          { threshold: Infinity, base: 0.81, factorMult: 0.09, max: 0.92, min: 0.78 }
      ];
      
      const bracket = speedFactorBrackets.find(b => speedMPH < b.threshold);
      baseFactor = Math.min(bracket.max, Math.max(bracket.min, bracket.base + (speedFactor * bracket.factorMult)));
      
      const distanceAdjustment = Math.min(0.08, distance * 0.005);
      const timeAdjustment = timeDelta > 0 ? Math.min(0.05, Math.max(-0.03, (timeDelta - 0.35) * 0.07)) : 0;
      
      const jitterDampening = speedMPH < 3 ? Math.max(0, 0.04 - (speedMPH * 0.013)) : 0;
      
      const directionChangeAdjustment = headingDiff > 25 ? Math.max(0, 0.06 - (headingDiff / 200) * 0.08) : 0;
      const eastWestSmoothingBonus = eastWestMovement ? 0.025 : 0;
      
      const adjustedSmoothingFactor = Math.min(0.94, Math.max(0.04, 
          baseFactor + distanceAdjustment + timeAdjustment - jitterDampening - directionChangeAdjustment + eastWestSmoothingBonus
      ));
      
       const jitterReductionFactor = speedMPH < 3 ? 0.87 : 1.0;
      const finalSmoothingFactor = adjustedSmoothingFactor * jitterReductionFactor * directionChangeFactor;
     
     const finalSmoothedPosition = {
         lat: lastPosition.lat * (1 - finalSmoothingFactor) + predictedPosition.lat * finalSmoothingFactor,
         lng: lastPosition.lng * (1 - finalSmoothingFactor) + predictedPosition.lng * finalSmoothingFactor,
         accuracy: predictedPosition.accuracy,
         heading: predictedPosition.heading,
         timestamp: currentTime,
         speedMPS: predictedPosition.speedMPS
     };
     
     const durationBrackets = [
         { threshold: 0.5, base: 1.0, factorMult: -0.12, max: 1.3, min: 0.7 },
         { threshold: 2, base: 0.8, factorMult: -0.14, max: 1.0, min: 0.5 },
         { threshold: 5, base: 0.65, factorMult: -0.12, max: 0.8, min: 0.4 },
         { threshold: 10, base: 0.45, factorMult: -0.1, max: 0.65, min: 0.28 },
         { threshold: 20, base: 0.35, factorMult: -0.08, max: 0.5, min: 0.22 },
         { threshold: 35, base: 0.32, factorMult: -0.07, max: 0.42, min: 0.2 },
         { threshold: 50, base: 0.28, factorMult: -0.06, max: 0.36, min: 0.18 },
         { threshold: 65, base: 0.22, factorMult: -0.04, max: 0.28, min: 0.15 },
         { threshold: 80, base: 0.18, factorMult: -0.03, max: 0.23, min: 0.12 },
         { threshold: Infinity, base: 0.14, factorMult: -0.025, max: 0.18, min: 0.08 }
     ];
     
     const durationBracket = durationBrackets.find(b => speedMPH < b.threshold);
     const baseDuration = Math.min(durationBracket.max, Math.max(durationBracket.min, durationBracket.base + (speedFactor * durationBracket.factorMult)));
     
     const distanceModifier = Math.min(0.05, distance * 0.0015);
     const timeModifier = timeDelta > 0 ? Math.max(-0.02, Math.min(0.03, (0.22 - timeDelta) * 0.07)) : 0;
     
     const jitterCompensation = speedMPH < 2 ? Math.min(0.06, (2 - speedMPH) * 0.03) : 0;
     const directionChangeCompensation = headingDiff > 20 ? Math.min(0.08, headingDiff / 200 * 0.12) : 0;
     const eastWestDurationBonus = eastWestMovement ? Math.min(0.04, distance * 0.0008) : 0;
     
     const jitterCompensatedDuration = Math.max(0.03, 
         baseDuration - distanceModifier + timeModifier + jitterCompensation + directionChangeCompensation + eastWestDurationBonus
     );
     
     const finalAnimationDuration = jitterCompensatedDuration * directionChangeFactor;
     
     const markerElement = userMarker.getElement();
     if (markerElement) {
         markerElement.style.willChange = 'transform';
         markerElement.style.backfaceVisibility = 'hidden';
         markerElement.style.transform = 'translateZ(0)';
         
         if (eastWestMovement) {
             markerElement.style.imageRendering = 'crisp-edges';
         }
     }
     
     const finalEaseLinearity = eastWestMovement ?
         Math.max(0.02, Math.min(0.18, (0.1 - (speedMPH * 0.0008)) * directionChangeFactor)) :
         Math.max(0.04, Math.min(0.22, (0.12 - (speedMPH * 0.0015)) * directionChangeFactor));
     
     userMarker.setLatLng([finalSmoothedPosition.lat, finalSmoothedPosition.lng], {
         animate: true,
         duration: finalAnimationDuration,
         easeLinearity: finalEaseLinearity
     });
     
     const mapUpdateInterval = speedTier.mapUpdateInterval;
     const mapUpdateDistanceThreshold = speedTier.mapUpdateDistance * (eastWestMovement ? 0.92 : 1.0);
     
     if (currentTime - lastMapUpdateTime > mapUpdateInterval || distance > mapUpdateDistanceThreshold) {
         checkProximityForZoom();
         
         const lookAheadBrackets = [
             { threshold: 0.5, base: 0, factorMult: 0.015, max: 0.025 },
             { threshold: 2, base: 0, factorMult: 0.032, max: 0.05 },
             { threshold: 5, base: 0, factorMult: 0.055, max: 0.085 },
             { threshold: 10, base: 0, factorMult: 0.09, max: 0.13 },
             { threshold: 20, base: 0, factorMult: 0.13, max: 0.19 },
             { threshold: 35, base: 0, factorMult: 0.19, max: 0.28 },
             { threshold: 50, base: 0, factorMult: 0.26, max: 0.38 },
             { threshold: 65, base: 0, factorMult: 0.34, max: 0.48 },
             { threshold: 80, base: 0, factorMult: 0.42, max: 0.58 },
             { threshold: Infinity, base: 0, factorMult: 0.54, max: 0.7 }
         ];
         
         const lookAheadBracket = lookAheadBrackets.find(b => speedMPH < b.threshold);
         const baseLookAhead = Math.min(lookAheadBracket.max, lookAheadBracket.base + (speedFactor * lookAheadBracket.factorMult));
         
         const distanceBoost = Math.min(0.1, distance * 0.006);
         const directionChangeLookAheadReduction = headingDiff > 30 ? Math.min(0.18, headingDiff / 200 * 0.25) : 0;
         const eastWestLookAheadBonus = eastWestMovement ? Math.min(0.06, distance * 0.0015) : 0;
         
         const lookAheadFactor = Math.min(0.75, Math.max(0.008, 
             baseLookAhead + distanceBoost - directionChangeLookAheadReduction + eastWestLookAheadBonus
         ));
         
         const lookAheadPosition = {
             lat: finalSmoothedPosition.lat + (predictedPosition.lat - lastPosition.lat) * lookAheadFactor,
             lng: finalSmoothedPosition.lng + (predictedPosition.lng - lastPosition.lng) * lookAheadFactor
         };
         
         animationFrameId = requestAnimationFrame(() => {
             if (followUser && !isMapInteracting) {
                 const userPos = finalSmoothedPosition;
                 const bounds = map.getBounds();
                 
                 if (userPos && bounds) {
                     const userPixelPoint = map.latLngToContainerPoint(userPos);
                     const mapSize = map.getSize();
                     
                     const pixelBaseThreshold = 0.22;
                     const speedNormalized = Math.min(1, speedMPH / 80);
                     const pixelSpeedAdaptiveThreshold = Math.max(0.06, pixelBaseThreshold - (speedNormalized * 0.14));
                     
                     const eastWestPixelThreshold = eastWestMovement ? pixelSpeedAdaptiveThreshold * 0.88 : pixelSpeedAdaptiveThreshold;
                     const northSouthPixelThreshold = eastWestMovement ? pixelSpeedAdaptiveThreshold * 1.08 : pixelSpeedAdaptiveThreshold;
                     
                     const isNearEdgePixel = (
                         userPixelPoint.x < mapSize.x * eastWestPixelThreshold ||
                         userPixelPoint.x > mapSize.x * (1 - eastWestPixelThreshold) ||
                         userPixelPoint.y < mapSize.y * northSouthPixelThreshold ||
                         userPixelPoint.y > mapSize.y * (1 - northSouthPixelThreshold)
                     );
                     
                     const mapWidth = bounds.getEast() - bounds.getWest();
                     const mapHeight = bounds.getNorth() - bounds.getSouth();
                     
                     const geoBasePadding = 0.22;
                     const geoSpeedAdaptivePadding = Math.max(0.06, geoBasePadding - (speedNormalized * 0.14));
                     
                     const eastWestPaddingMultiplier = eastWestMovement ? 0.88 : 1.0;
                     const northSouthPaddingMultiplier = eastWestMovement ? 1.08 : 1.0;
                     
                     const edgePaddingLng = mapWidth * geoSpeedAdaptivePadding * eastWestPaddingMultiplier;
                     const edgePaddingLat = mapHeight * geoSpeedAdaptivePadding * northSouthPaddingMultiplier;
                     
                     const isNearEdgeGeo = 
                         userPos.lat > (bounds.getNorth() - edgePaddingLat) ||
                         userPos.lat < (bounds.getSouth() + edgePaddingLat) ||
                         userPos.lng > (bounds.getEast() - edgePaddingLng) ||
                         userPos.lng < (bounds.getWest() + edgePaddingLng);
                         
                     const isOutsideBounds = !bounds.contains(userPos);
                     
                     if (isOutsideBounds || isNearEdgePixel || isNearEdgeGeo) {
                         const now = Date.now();
                         if (now - lastCenteringTime > CONFIG.MIN_CENTERING_INTERVAL) {
                             const targetPosition = lookAheadPosition;
                             
                             const basePanDuration = speedTier.panDuration;
                             const panDuration = basePanDuration * directionChangeFactor * (eastWestMovement ? 0.92 : 1.0);
                             const easeLinearity = speedTier.easeLinearity * (eastWestMovement ? 0.85 : 1.0);
                             
                             const mapContainer = map.getContainer();
                             const tiles = mapContainer.querySelectorAll('.leaflet-tile-container');
                             tiles.forEach(container => {
                                 container.style.backfaceVisibility = 'hidden';
                                 container.style.transform = 'translateZ(0)';
                                 container.style.willChange = 'transform';
                                 
                                 if (eastWestMovement) {
                                     container.style.imageRendering = 'crisp-edges';
                                 }
                             });
                             
                             map.panTo([targetPosition.lat, targetPosition.lng], {
                                 animate: true,
                                 duration: panDuration,
                                 easeLinearity: easeLinearity,
                                 noZoom: true,
                                 noMoveStart: true
                             });
                             
                              setTimeout(() => {
                                 tiles.forEach(container => {
                                     if (container) {
                                         container.style.willChange = 'auto';
                                         container.style.imageRendering = '';
                                     }
                                 });
                             }, panDuration * 1000 + 100);
                             
                             lastCenteringTime = now;
                         }
                     } else if (lookAheadPosition) {
                         const targetPosition = lookAheadPosition;
                         const panDuration = speedTier.panDuration * 1.15 * directionChangeFactor * (eastWestMovement ? 0.92 : 1.0);
                         const easeLinearity = speedTier.easeLinearity * 0.85 * (eastWestMovement ? 0.92 : 1.0);
                         
                         map.panTo([targetPosition.lat, targetPosition.lng], {
                             animate: true,
                             duration: panDuration,
                             easeLinearity: easeLinearity,
                             noMoveStart: true
                         });
                     }
                 }
                 
                 const intelligentZoom = getSpeedBasedZoom(smoothedPosition.speedMPS);
                 const zoomThreshold = speedTier.zoomThreshold;
                 
                 if (intelligentZoom && Math.abs(map.getZoom() - intelligentZoom) >= zoomThreshold) {
                     const zoomDuration = speedTier.zoomDuration * directionChangeFactor;
                     
                     const mapContainer = map.getContainer();
                     const originalOverflow = mapContainer.style.overflow;
                     mapContainer.style.overflow = 'hidden';
                     
                     map.setZoom(intelligentZoom, { 
                         animate: true, 
                         duration: zoomDuration,
                         noMoveStart: true
                     });
                     
                     setTimeout(() => {
                         mapContainer.style.overflow = originalOverflow;
                     }, zoomDuration * 1000 + 50);
                 }
             }
             
             animationFrameId = null;
         });
         
         lastMapUpdateTime = currentTime;
     }
     
     lastPosition = finalSmoothedPosition;
     lastUpdateTime = currentTime;
     lastUpdateTimestamp = currentTime;
     updateDistanceBox();
 } catch (error) {
     console.error("Location update error:", error);
     
     if (animationFrameId !== null) {
         cancelAnimationFrame(animationFrameId);
         animationFrameId = null;
     }
     
     userMarker.setLatLng([smoothedPosition.lat, smoothedPosition.lng], { 
         animate: true, 
         duration: 0.4,
         easeLinearity: 0.15
     });
     lastPosition = smoothedPosition;
     positionBuffer = [smoothedPosition];
     updateDistanceBox();
 }
 
// VIEWPORT SAFETY FAIL-SAFE
if (followUser && !isMapInteracting) {
   const SAFETY_DEBOUNCE = 60;
   const now = performance.now();
   if (now - lastCenteringTime > SAFETY_DEBOUNCE) {
       const currentMarkerPos = userMarker.getLatLng();
       const bounds = map.getBounds();

       if (!bounds.contains(currentMarkerPos)) {
           const container = map.getContainer();
           container.style.willChange = 'transform';
           container.style.backfaceVisibility = 'hidden';
           
           map.panTo(currentMarkerPos, { 
               animate: true, 
               duration: 0.25, 
               easeLinearity: 0.2,
               noMoveStart: true 
           });
           
           setTimeout(() => {
               container.style.willChange = 'auto';
               container.style.backfaceVisibility = 'visible';
           }, 300);
       } else {
           const pixelPoint = map.latLngToContainerPoint(currentMarkerPos);
           const mapSize = map.getSize();
           const centerX = mapSize.x / 2;
           const centerY = mapSize.y / 2;
           const maxDist = Math.max(
               Math.abs(pixelPoint.x - centerX) / centerX,
               Math.abs(pixelPoint.y - centerY) / centerY
           );
           const dynamicMargin = 0.06 + (1 - maxDist) * 0.06;
           const speedMPH = smoothedPosition.speedMPS * 2.23694;
           const speedFactor = Math.min(1, speedMPH / 50);
           const margin = dynamicMargin * (0.75 + speedFactor * 0.25);

           const isAtEdge =
               pixelPoint.x < mapSize.x * margin ||
               pixelPoint.x > mapSize.x * (1 - margin) ||
               pixelPoint.y < mapSize.y * margin ||
               pixelPoint.y > mapSize.y * (1 - margin);

           if (isAtEdge) {
               const container = map.getContainer();
               container.style.willChange = 'transform';
               container.style.backfaceVisibility = 'hidden';
               
               map.panTo(currentMarkerPos, { 
                   animate: true, 
                   duration: 0.35, 
                   easeLinearity: 0.18,
                   noMoveStart: true 
               });
               
               setTimeout(() => {
                   container.style.willChange = 'auto';
                   container.style.backfaceVisibility = 'visible';
               }, 400);
           }
       }
       lastCenteringTime = now;
       }
   }
}
