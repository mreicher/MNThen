<!DOCTYPE html>
<html lang="en">
<head> 
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Minnesota Then | Museum Without Walls</title>
    <link rel="shortcut icon" type="image/x-icon" href="https://www.mnthen.com/images/mnthenfav.ico">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css">
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css" />
    <style>
        :root {
            --primary-color: #005f9e;
            --secondary-color: #0077c2;
            --text-color: #333333;
            --background-color: #f8f9fa;
            --shadow-color: rgba(0, 0, 0, 0.1);
        }

        body, html {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: 'Roboto', Arial, sans-serif;
            color: var(--text-color);
            background-color: var(--background-color);
            font-size: 16px;
            line-height: 1.5;
        }

        #map {
            height: 100vh;
            width: 100%;
        }

        #distanceBox {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 30px;
            box-shadow: 0 4px 10px var(--shadow-color);
            font-size: 1.5rem;
            font-weight: 500;
            z-index: 1000;
            border: 2px solid var(--primary-color);
            color: var(--primary-color);
            transition: all 0.3s ease;
            min-width: 200px;
            text-align: center;
        }

        .marker-cluster-custom {
            background-color: #006400;
            border-radius: 50%;
            font-weight: bold;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 30px;
            height: 30px;
        }

        .marker-cluster-custom div {
            width: 26px;
            height: 26px;
            text-align: center;
            border-radius: 13px;
            font-size: 14px;
            background-color: rgba(0, 100, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.4);
        }

        .modal-content {
            background-color: #fefefe;
            margin: 15% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 400px;
            border-radius: 10px;
            text-align: center;
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close:hover,
        .close:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }

        .modal-buttons {
            margin-top: 20px;
        }

        .modal-buttons button {
            margin: 0 10px;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        #mapButton {
            background-color: #4CAF50;
            color: white;
        }

        #continueButton {
            background-color: #4CAF50;
            color: white;
        }

        #cancelButton {
            background-color: #f44336;
            color: white;
        }

        .user-marker-icon {
            width: 20px;
            height: 20px;
            background-color: red;
            border-radius: 50%;
            border: 2px solid white;
        }

        .lochunt-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #ffffff;
            z-index: 2000;
            display: none;
            flex-direction: column;
            overflow-y: auto;
        }

        .custom-popup .leaflet-popup-content-wrapper {
            padding: 0;
            overflow: hidden;
            border-radius: 10px;
        }

        .custom-popup .leaflet-popup-content {
            margin: 0;
            width: 250px !important;
        }

        .popup-content {
            text-align: center;
            background-color: white;
            border-radius: 10px;
            overflow: hidden;
            width: 100%;
        }

        .location-image {
            width: 100%;
            height: auto;
            display: block;
        }

        .location-name {
            margin: 15px 0;
            font-size: 1.2rem;
            color: var(--text-color);
            padding: 0 15px;
        }

        .popup-buttons {
            display: flex;
            margin-top: 10px;
        }

        .button {
            flex: 1;
            padding: 12px 0;
            font-size: 1rem;
            font-weight: bold;
            color: white;
            border: none;
            cursor: pointer;
            text-decoration: none;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .route-button {
            background-color: #006400;
            width: 50%;
        }

        .summary-button {
            background-color: #0077c2;
            width: 50%;
        }
/*
        .pin-head {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%) rotate(-45deg);
            width: 30px;
            height: 30px;
            border-radius: 50% 50% 50% 0;
            border: 3px solid white;
            box-shadow: 0 0 5px var(--shadow-color);
            background-color: #191970;
            transition: all 0.3s ease;
        }

        .pin-head:hover {
            transform: translateX(-50%) rotate(-45deg) scale(1.1);
            box-shadow: 0 0 15px var(--shadow-color);
        }
*/

        .pin-head {
    position: absolute;
    top: 0;
    left: 50%;
    transform: translateX(-50%) rotate(-45deg);
    width: 30px;
    height: 30px;
    border-radius: 50% 50% 50% 0;
    border: 3px solid white;
    box-shadow: 0 0 5px var(--shadow-color);
    background-color: #191970;
    transition: all 0.3s ease;
    overflow: hidden; /* To ensure the inner circle doesn't overflow */
}

.pin-head:hover {
    transform: translateX(-50%) rotate(-45deg) scale(1.1);
    box-shadow: 0 0 15px var(--shadow-color);
}

.pin-head::after {
   content: '';
   position: absolute;
   top: 50%;
   left: 50%;
   transform: translate(-50%, -50%) rotate(45deg);
   width: 12px;
   height: 12px;
   border-radius: 50%;
   border: 1px solid rgba(255, 255, 255, 0.8);
   background-color: rgba(245, 245, 245, 0.9); /* Dull off-white color */
   box-shadow: 0 0 2px rgba(0, 0, 0, 0.3); /* Subtle shadow for depth */
}
       
        .directions-link {
            display: inline-block;
            margin-top: 15px;
            padding: 10px 20px;
            background-color: #006400;
            color: white;
            border-radius: 25px;
            text-decoration: none;
            transition: all 0.3s ease;
            font-weight: 600;
            font-size: 1.1rem;
        }

        .directions-link:hover {
            background-color: #037f51;
            transform: translateY(-2px);
            box-shadow: 0 6px 8px var(--shadow-color);
        }

        .lochunt-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .audio-player {
            width: 100%;
            max-width: 400px;
            margin: 20px auto;
        }

        .audio-progress {
            width: 100%;
            margin-bottom: 10px;
        }

        .progress {
            height: 8px;
            background-color: #d1d1d1;
            cursor: pointer;
            border-radius: 4px;
        }

        .progress-bar {
            background-color: var(--primary-color);
            border-radius: 4px;
        }

        .audio-time {
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem;
            color: #666;
            margin-bottom: 10px;
        }

        .audio-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 1.5rem;
        }

        .audio-button {
            background-color: white;
            color: var(--primary-color);
            border: 2px solid var(--primary-color);
            border-radius: 50%;
            width: 55px;
            height: 55px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 1111;
        }

        .audio-button:hover {
            background-color: var(--secondary-color);
            color: white;
        }

        .additional-info-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 15px var(--shadow-color);
            border: 2px solid var(--primary-color);
            width: 90%;
            max-width: 600px;
            z-index: 2001;
            display: none;
            font-size: 20px;
        }

        .map-buttons {
            position: fixed;
            bottom: 30px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            padding: 0 25px;
            z-index: 1000;
        }

        .map-button {
            background-color: white;
            border: none;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            display: flex;
            border: 1px solid var(--primary-color);
            justify-content: center;
            align-items: center;
            box-shadow: 0 4px 10px var(--shadow-color);
            font-size: 2rem;
            color: var(--primary-color);
            transition: all 0.3s ease;
        }

        .map-button:hover {
            background-color: var(--primary-color);
            color: white;
            transform: scale(1.1);
        }

        .navigation-tips {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 20px var(--shadow-color);
            z-index: 2001;
            display: none;
            max-width: 90%;
            width: 400px;
        }

        .close-button {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--primary-color);
            transition: color 0.3s ease;
        }

        #congratulations {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.98);
            z-index: 3000;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 30px;
            text-align: center;
        }

        #congratulations h2 {
            font-size: 32px;
            color: var(--primary-color);
            margin-bottom: 20px;
        }

        #congratulations button {
            padding: 12px 24px;
            font-size: 18px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        #congratulations button:hover {
            background-color: var(--hover-color);
        }

        @media (max-width: 768px) {
            body, html {
                font-size: 18px;
            }

            #distanceBox {
                font-size: 1.3rem;
                padding: 6px 10px;
                top: 10px;
                right: 10px;
            }

            .map-buttons {
                bottom: 20px;
            }

            .map-button {
                width: 50px;
                height: 50px;
                font-size: 1.7rem;
            }

            .navigation-tips {
                max-width: 95%;
                padding: 20px;
            }

            #congratulations h2 {
                font-size: 24px;
            }

            #congratulations button {
                font-size: 16px;
                padding: 10px 20px;
            }

            .audio-player {
                max-width: 100%;
            }

            .lochunt-container img {
                height: 30vh;
            }

            .additional-info-container {
                width: 95%;
                padding: 20px;
                font-size: 16px;
            }
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <div id="distanceBox">Initializing...</div>

    <div class="lochunt-container">
        <img id="locationImage" src="" alt="Location Image">
        <div class="lochunt-content">
            <div class="lochunt-info">
                <h2 id="locationTitle" class="mb-2 text-primary"></h2>
                <p id="locationCity" class="text-muted mb-1"></p>
                <p id="locationCreator" class="text-muted mb-3"></p>
            </div>
            <div class="audio-player">
                <div class="audio-progress">
                    <div class="progress">
                        <div id="progressBar" class="progress-bar" role="progressbar" style="width: 0%"></div>
                    </div>
                </div>
                <div class="audio-time">
                    <span  id="currentTime">0:00</span>
                    <span id="duration">0:00</span>
                </div>
                <div class="audio-controls">
                    <button id="rewindBtn" class="audio-button"><i class="fas fa-backward"></i></button>
                    <button id="playPauseBtn" class="audio-button"><i class="fas fa-play"></i></button>
                    <button id="forwardBtn" class="audio-button"><i class="fas fa-forward"></i></button>
                </div>
                <audio id="locationAudio" src=""></audio>
            </div>
        </div>
    </div>
    <div class="additional-info-container">
        <h3 class="mb-3 text-primary">Additional Information</h3>
        <p id="additionalInfo" class="mb-3"></p>
        <button id="continueButton" class="btn btn-primary">Continue</button>
    </div>
    <div class="map-buttons">
        <button id="recenterButton" class="map-button"><i class="fas fa-crosshairs"></i></button>
        <button id="returnButton" class="map-button"><i class="fas fa-sign-out-alt"></i></button>
        <button id="tipsButton" class="map-button"><i class="fas fa-question-circle"></i></button>
    </div>

    <div class="navigation-tips">
        <button class="close-button">&times;</button>
        <h3>Navigation Tips</h3>
        <ul>
            <li>Use the map to navigate to the marked locations.</li>
            <li>The distance box shows how far you are from the current location.</li>
            <li>Tap the recenter button to focus on your current position.</li>
            <li>When you're within 20 feet of a location, you'll be able to interact with it.</li>
            <li>Listen to the audio information for each location.</li>
            <li>After the audio, you'll see additional information about the location.</li>
        </ul>
    </div>
    
    <div id="directionsModal" class="modal">
        <div class="modal-content">
            <p>You are about to leave the site for Google Maps directions. Do you want to continue?</p>
            <div class="modal-buttons">
                <button id="mapButton">Continue</button>
                <button id="cancelButton">Cancel</button>
            </div>
        </div>
    </div>

        <div id="summaryModal" class="modal">
        <div class="modal-content">
            <p id="summaryContent"></p>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"></script>
    <script src="/locations_test.js?v=1.0.4"></script>

    <script>
let map, userMarker, markerClusterGroup;
let currentLocationIndex = 0;
let visitedLocations = [];
let gameLocations = [];
let inactivityTimer;
let isLocationHuntVisible = false;
let lastPosition = null;
let positionBuffer = [];
const bufferSize = 5;
const smoothingFactor = 0.6;
let filteredPosition = null;
const DISTANCE_THRESHOLD = 20; // 20 feet to measure threshold distance to marker before opening location page.
let lastUpdateTime = 0;
let velocity = { lat: 0, lng: 0 };
let isMapInteracting = false;
let followUser = true;
let locationCooldowns = {};

const speedThreshold = 0.5;
const distanceThreshold = 1;

let lastHiddenTime = 0;
const BACKGROUND_THRESHOLD = 25000;
const INACTIVITY_TIMEOUT = 30000;

let lastKnownPosition = null;
let isTransitioning = false;
let lastVisitedLocationId = null;

const UPDATE_INTERVAL = 50;

let userIsInteracting = false;

function initMap() {
    map = L.map('map', {
        zoomControl: false,
        attributionControl: false,
        zoomSnap: 0.1,
        zoomDelta: 0.5,
        wheelDebounceTime: 100,
        tapTolerance: 15,
        bounceAtZoomLimits: false
    }).fitWorld();

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 18,
        attribution: '© OpenStreetMap contributors',
        updateWhenIdle: true,
        updateWhenZooming: false
    }).addTo(map);

    markerClusterGroup = L.markerClusterGroup({
        showCoverageOnHover: false,
        zoomToBoundsOnClick: true,
        spiderfyOnMaxZoom: true,
        animate: true,
        animateAddingMarkers: true,
        iconCreateFunction: function(cluster) {
            return L.divIcon({
                html: '<div><span>' + cluster.getChildCount() + '</span></div>',
                className: 'marker-cluster-custom',
                iconSize: L.point(40, 40)
            });
        }
    });
    map.addLayer(markerClusterGroup);

    const userIcon = L.divIcon({
        className: 'user-marker',
        html: '<div class="user-marker-icon"></div>',
        iconSize: [20, 20],
        iconAnchor: [10, 10]
    });

    userMarker = L.marker([0, 0], { icon: userIcon }).addTo(map);

    showLoadingMessage();

    if ("geolocation" in navigator) {
        navigator.geolocation.getCurrentPosition(initializeUserLocation, handleLocationError, {
            enableHighAccuracy: true,
            timeout: 30000,
            maximumAge: 0
        });
    } else {
        showPopup("Geolocation is not supported by your browser");
        map.setView([44.9778, -93.2650], 18);
        hideLoadingMessage();
    }

    document.addEventListener('visibilitychange', handleVisibilityChange);

    map.on('movestart zoomstart', () => {
        followUser = false;
        isMapInteracting = true;
    });

    map.on('moveend zoomend', () => {
        isMapInteracting = false;
        resetInactivityTimer();
    });

    map.touchZoom.enable();
    map.doubleClickZoom.enable();
}

function showLoadingMessage() {
    const loadingMessage = document.createElement('div');
    loadingMessage.id = 'loadingMessage';
    loadingMessage.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: rgba(255, 255, 255, 0.8);
        padding: 20px;
        border-radius: 10px;
        z-index: 1000;
    `;
    loadingMessage.innerHTML = '<p>Searching for your location...</p>';
    document.body.appendChild(loadingMessage);
}

function hideLoadingMessage() {
    const loadingMessage = document.getElementById('loadingMessage');
    if (loadingMessage) {
        document.body.removeChild(loadingMessage);
    }
}

function initializeUserLocation(position) {
    console.log("Initial position data:", JSON.stringify(position));

    if (!position || !position.coords) {
        console.error("Invalid initial position object");
        handleLocationError(new Error("Invalid initial position"));
        return;
    }

    const { latitude: userLat, longitude: userLng, accuracy } = position.coords;

    if (isNaN(userLat) || isNaN(userLng)) {
        console.error("Invalid initial coordinates:", { userLat, userLng });
        handleLocationError(new Error("Invalid initial coordinates"));
        return;
    }

    console.log("Valid initial position:", { userLat, userLng, accuracy });

    try {
        userMarker.setLatLng([userLat, userLng]);
        map.setView([userLat, userLng], 18);
    } catch (error) {
        console.error("Error setting initial user location:", error);
        handleLocationError(error);
        return;
    }

    hideLoadingMessage();
    startPositionUpdates();
    startHunt();
}

function startPositionUpdates() {
    navigator.geolocation.watchPosition(
        handlePositionUpdate,
        handleLocationError,
        {
            enableHighAccuracy: true,
            maximumAge: 1000,
            timeout: 10000
        }
    );
}

function handlePositionUpdate(position) {
    console.log("Raw position data:", JSON.stringify(position));
    if (!position || !position.coords || isNaN(position.coords.latitude) || isNaN(position.coords.longitude)) {
        console.warn("Invalid position data received:", position);
        return;
    }
    updateUserLocation(position);
}

function handleVisibilityChange() {
    if (document.hidden) {
        lastHiddenTime = Date.now();
        lastKnownPosition = userMarker ? userMarker.getLatLng() : null;
    } else {
        const hiddenDuration = Date.now() - lastHiddenTime;
        if (hiddenDuration > BACKGROUND_THRESHOLD) {
            updateLocationAfterBackground();
        } else {
            map.invalidateSize();
        }
    }
    resetInactivityTimer();
}

function updateLocationAfterBackground() {
    if ("geolocation" in navigator) {
        navigator.geolocation.getCurrentPosition(
            (position) => {
                console.log("Background update raw position:", JSON.stringify(position));

                if (!position || !position.coords) {
                    console.warn("Invalid position object in background update");
                    return;
                }

                const { latitude, longitude, accuracy } = position.coords;

                if (isNaN(latitude) || isNaN(longitude)) {
                    console.warn("Invalid coordinates in background update:", { latitude, longitude });
                    return;
                }

                const newPosition = { lat: latitude, lng: longitude };
                
                console.log("Valid background position update:", newPosition);

                try {
                    updateUserLocation(position, true);
                } catch (error) {
                    console.error("Error in updateUserLocation during background update:", error);
                }

                lastPosition = null;
                positionBuffer = [];
                filteredPosition = null;
                velocity = { lat: 0, lng: 0 };
                
                updateDistanceBox();
                
                followUser = true;
                
                map.invalidateSize();
            },
            (error) => {
                console.error("Error getting location after background:", error);
            },
            {
                enableHighAccuracy: true,
                timeout: 10000,
                maximumAge: 0
            }
        );
    } else {
        console.warn("Geolocation is not available");
    }
}

function calculateSmoothedPosition(positions) {
    if (positions.length === 0) return null;
    let sumLat = 0, sumLng = 0, totalWeight = 0;
    const len = positions.length;
    for (let i = 0; i < len; i++) {
        const weight = (i + 1) / len;
        sumLat += positions[i].lat * weight;
        sumLng += positions[i].lng * weight;
        totalWeight += weight;
    }
    return {
        lat: sumLat / totalWeight,
        lng: sumLng / totalWeight
    };
}

const EXTENDED_DISTANCE_THRESHOLD = 100;
const EDGE_THRESHOLD_PERCENTAGE = 0.25;
const STRICT_EDGE_THRESHOLD_PERCENTAGE = 0.15;
const CRITICAL_EDGE_THRESHOLD_PERCENTAGE = 0.07;
const MAX_ACCURACY_THRESHOLD = 2500;
const TARGET_ACCURACY_THRESHOLD = 100;

let currentAccuracyThreshold = MAX_ACCURACY_THRESHOLD;
let lastVelocity = { lat: 0, lng: 0 };
let lastUpdateTimestamp = Date.now();
let lastRecenterTime = Date.now();
const MIN_RECENTER_INTERVAL = 2000;

function calculateEdgeProximity(map, point) {
    const bounds = map.getBounds();
    const latSpan = bounds.getNorth() - bounds.getSouth();
    const lngSpan = bounds.getEast() - bounds.getWest();
    
    return {
        north: Math.abs(point.lat - bounds.getNorth()) / latSpan,
        south: Math.abs(point.lat - bounds.getSouth()) / latSpan,
        east: Math.abs(point.lng - bounds.getEast()) / lngSpan,
        west: Math.abs(point.lng - bounds.getWest()) / lngSpan
    };
}

function isMarkerNearEdge(map, marker, isStrict = false) {
    const bounds = map.getBounds();
    const point = marker.getLatLng();
    const proximities = calculateEdgeProximity(map, point);
    
    const thresholdPercentage = isStrict ? 
        STRICT_EDGE_THRESHOLD_PERCENTAGE : 
        EDGE_THRESHOLD_PERCENTAGE;
    
    const edges = {
        north: proximities.north < thresholdPercentage,
        south: proximities.south < thresholdPercentage,
        east: proximities.east < thresholdPercentage,
        west: proximities.west < thresholdPercentage
    };
    
    return {
        isNearEdge: Object.values(edges).some(edge => edge),
        edges: edges,
        proximities: proximities
    };
}

function isMarkerVisible(map, marker) {
    const bounds = map.getBounds();
    const point = marker.getLatLng();
    const isVisible = bounds.contains(point);
    
    if (!isVisible) {
        console.warn("Marker has left visible bounds!");
    }
    
    return isVisible;
}

function calculateOptimalCenter(map, markerPosition, edgeInfo) {
    const bounds = map.getBounds();
    const center = map.getCenter();
    
    let latOffset = 0;
    let lngOffset = 0;
    
    if (edgeInfo.edges.north) latOffset = -1 * (bounds.getNorth() - bounds.getSouth()) * 0.2;
    if (edgeInfo.edges.south) latOffset = (bounds.getNorth() - bounds.getSouth()) * 0.2;
    if (edgeInfo.edges.east) lngOffset = -1 * (bounds.getEast() - bounds.getWest()) * 0.2;
    if (edgeInfo.edges.west) lngOffset = (bounds.getEast() - bounds.getWest()) * 0.2;
    
    return {
        lat: markerPosition.lat + latOffset,
        lng: markerPosition.lng + lngOffset
    };
}

function shouldRecenter(map, marker) {
    const now = Date.now();
    if (now - lastRecenterTime < MIN_RECENTER_INTERVAL) {
        return false;
    }
    
    const edgeInfo = isMarkerNearEdge(map, marker);
    const proximities = edgeInfo.proximities;
    
    const isCritical = Object.values(proximities).some(
        proximity => proximity < CRITICAL_EDGE_THRESHOLD_PERCENTAGE
    );
    
    if (isCritical) {
        lastRecenterTime = now;
        return {
            needsRecenter: true,
            isEmergency: true,
            edgeInfo: edgeInfo
        };
    }
    
    if (edgeInfo.isNearEdge) {
        lastRecenterTime = now;
        return {
            needsRecenter: true,
            isEmergency: false,
            edgeInfo: edgeInfo
        };
    }
    
    return {
        needsRecenter: false,
        isEmergency: false,
        edgeInfo: edgeInfo
    };
}       
        
function applyExponentialSmoothing(newPosition, lastPosition, alpha = 0.25) {
    if (!lastPosition) return newPosition;
    return {
        lat: alpha * newPosition.lat + (1 - alpha) * lastPosition.lat,
        lng: alpha * newPosition.lng + (1 - alpha) * lastPosition.lng,
        accuracy: newPosition.accuracy,
        timestamp: newPosition.timestamp
    };
}

function calculateVelocityFilter(newPosition, lastPosition) {
    const timeElapsed = (Date.now() - lastUpdateTimestamp) / 1000;
    if (!lastPosition || timeElapsed <= 0) return newPosition;
    
    const currentVelocity = {
        lat: (newPosition.lat - lastPosition.lat) / timeElapsed,
        lng: (newPosition.lng - lastPosition.lng) / timeElapsed
    };
    
    lastVelocity = {
        lat: 0.85 * lastVelocity.lat + 0.15 * currentVelocity.lat,
        lng: 0.85 * lastVelocity.lng + 0.15 * currentVelocity.lng
    };
    
    return {
        lat: lastPosition.lat + lastVelocity.lat * timeElapsed,
        lng: lastPosition.lng + lastVelocity.lng * timeElapsed,
        accuracy: newPosition.accuracy,
        timestamp: newPosition.timestamp
    };
}

function updateUserLocation(position, forceUpdate = false) {
    console.log("Updating user location with:", JSON.stringify(position));

    if (!position || !position.coords) {
        console.warn("Invalid position object received");
        return;
    }

    const newPosition = {
        lat: Number(position.coords.latitude),
        lng: Number(position.coords.longitude),
        accuracy: Number(position.coords.accuracy),
        timestamp: position.timestamp || Date.now()
    };

    if (isNaN(newPosition.lat) ||   isNaN(newPosition.lng)) {
        console.warn("Invalid coordinates received:", newPosition);
        return;
    }

    if (lastPosition && currentAccuracyThreshold > TARGET_ACCURACY_THRESHOLD) {
        currentAccuracyThreshold = Math.max(
            TARGET_ACCURACY_THRESHOLD,
            currentAccuracyThreshold * 0.95
        );
    }

    if (newPosition.accuracy > currentAccuracyThreshold && !forceUpdate) {
        console.log(`Current accuracy threshold: ${currentAccuracyThreshold}m`);
        console.warn(`Low accuracy position (${newPosition.accuracy}m), skipping update`);
        return;
    }

    const distance = lastPosition ? calculateDistance(lastPosition, newPosition) : 0;
    const timeDelta = lastPosition ? (newPosition.timestamp - lastPosition.timestamp) / 1000 : 0;
    const currentSpeed = timeDelta > 0 ? distance / timeDelta : 0;
    const isMovingFast = currentSpeed > 2.5;

    if (distance > EXTENDED_DISTANCE_THRESHOLD || forceUpdate || !lastPosition) {
        console.log("Large distance or forced update. New position:", newPosition);
        try {
            userMarker.setLatLng([newPosition.lat, newPosition.lng]);
            
            lastPosition = {
                lat: newPosition.lat,
                lng: newPosition.lng,
                accuracy: newPosition.accuracy,
                timestamp: newPosition.timestamp
            };
            positionBuffer = [lastPosition];
            kalmanFilter.reset(lastPosition);
            lastVelocity = { lat: 0, lng: 0 };
            
            if (!isMapInteracting && !userIsInteracting) {
                map.setView([newPosition.lat, newPosition.lng], map.getZoom(), {
                    animate: false,
                    duration: 0
                });
            }
        } catch (error) {
            console.error("Error updating user location for large move:", error);
        }
    } else {
        console.log("Small distance update. Applying enhanced smoothing.");
        try {
            const filteredPosition = kalmanFilter.update(newPosition, currentSpeed);
            const velocityFilteredPosition = calculateVelocityFilter(filteredPosition, lastPosition);
            const exponentialSmoothedPosition = applyExponentialSmoothing(velocityFilteredPosition, lastPosition);
            
            const predictedPosition = {
                lat: exponentialSmoothedPosition.lat + (lastVelocity.lat * timeDelta),
                lng: exponentialSmoothedPosition.lng + (lastVelocity.lng * timeDelta),
                accuracy: exponentialSmoothedPosition.accuracy,
                timestamp: exponentialSmoothedPosition.timestamp
            };
            
            positionBuffer.push(isMovingFast ? predictedPosition : exponentialSmoothedPosition);
            if (positionBuffer.length > bufferSize) {
                positionBuffer.shift();
            }
            
            const smoothedPosition = calculateSmoothedPosition(positionBuffer);

            if (smoothedPosition && isFinite(smoothedPosition.lat) && isFinite(smoothedPosition.lng)) {
                if (userMarker) {
                    userMarker.setLatLng([smoothedPosition.lat, smoothedPosition.lng]);
                    
                    if (!isMapInteracting && !userIsInteracting) {
                        if (!isMarkerVisible(map, userMarker) || isMarkerNearEdge(map, userMarker)) {
                            const animationDuration = isMovingFast ? 0.3 : 0.5;
                            map.setView([smoothedPosition.lat, smoothedPosition.lng], map.getZoom(), {
                                animate: true,
                                duration: animationDuration
                            });
                        }
                    }
                    
                    lastVelocity = {
                        lat: (smoothedPosition.lat - lastPosition.lat) / Math.max(0.1, timeDelta),
                        lng: (smoothedPosition.lng - lastPosition.lng) / Math.max(0.1, timeDelta)
                    };
                    
                    lastPosition = smoothedPosition;
                } else {
                    console.warn("User marker not initialized");
                    return;
                }
            } else {
                console.warn("Invalid smoothed position, falling back to new position");
                if (userMarker) {
                    userMarker.setLatLng([newPosition.lat, newPosition.lng]);
                    
                    if (!isMapInteracting && !userIsInteracting) {
                        if (!isMarkerVisible(map, userMarker) || isMarkerNearEdge(map, userMarker)) {
                            map.setView([newPosition.lat, newPosition.lng], map.getZoom(), {
                                animate: true,
                                duration: 0.5
                            });
                        }
                    }
                }
                lastPosition = newPosition;
            }
        } catch (error) {
            console.error("Error updating user location:", error);
            if (userMarker) {
                userMarker.setLatLng([newPosition.lat, newPosition.lng]);
                lastPosition = newPosition;
            }
        }
    }

    updateDistanceBox();
    lastUpdateTime = Date.now();
    lastUpdateTimestamp = Date.now();
    console.log("User location update complete");
}

const kalmanFilter = {
    x: { estimate: 0, errorEstimate: 1, gain: 0 },
    y: { estimate: 0, errorEstimate: 1, gain: 0 },
    measurementError: 1,
    processError: 0.01,
    lastMeasurement: null,

    update(measurement, speed = 0) {
        if (this.x.estimate === 0 && this.y.estimate === 0) {
            this.x.estimate = measurement.lng;
            this.y.estimate = measurement.lat;
            this.lastMeasurement = measurement;
            return measurement;
        }

        const adaptiveProcessError = speed > 2.5 ? this.processError * 2 : this.processError;
        
        let predictedX = this.x.estimate;
        let predictedY = this.y.estimate;

        if (this.lastMeasurement) {
            const timeDelta = (measurement.timestamp - this.lastMeasurement.timestamp) / 1000;
            if (timeDelta > 0) {
                const velocityX = (measurement.lng - this.lastMeasurement.lng) / timeDelta;
                const velocityY = (measurement.lat - this.lastMeasurement.lat) / timeDelta;
                predictedX += velocityX * timeDelta;
                predictedY += velocityY * timeDelta;
            }
        }

        let predictedErrorX = this.x.errorEstimate + adaptiveProcessError;
        let predictedErrorY = this.y.errorEstimate + adaptiveProcessError;

        const adaptiveMeasurementError = this.measurementError * (measurement.accuracy / 10);

        this.x.gain = predictedErrorX / (predictedErrorX + adaptiveMeasurementError);
        this.y.gain = predictedErrorY / (predictedErrorY + adaptiveMeasurementError);

        this.x.estimate = predictedX + this.x.gain * (measurement.lng - predictedX);
        this.y.estimate = predictedY + this.y.gain * (measurement.lat - predictedY);

        this.x.errorEstimate = (1 - this.x.gain) * predictedErrorX;
        this.y.errorEstimate = (1 - this.y.gain) * predictedErrorY;

        this.lastMeasurement = measurement;

        return {
            lat: this.y.estimate,
            lng: this.x.estimate,
            accuracy: measurement.accuracy,
            timestamp: measurement.timestamp
        };
    },

    reset(measurement) {
        this.x.estimate = measurement.lng;
        this.y.estimate = measurement.lat;
        this.x.errorEstimate = 1;
        this.y.errorEstimate = 1;
        this.lastMeasurement = measurement;
    }
};
        
function calculateWeightedAveragePosition(positions) {
    console.log("Calculating weighted average for positions:", JSON.stringify(positions));

    if (!Array.isArray(positions) || positions.length === 0) {
        console.error("Invalid positions array for weighted average");
        return null;
    }

    let sumLat = 0, sumLng = 0, totalWeight = 0;
    let validPositionsCount = 0;

    for (let i = 0; i < positions.length; i++) {
        if (!positions[i] || typeof positions[i].lat !== 'number' || typeof positions[i].lng !== 'number' || 
            isNaN(positions[i].lat) || isNaN(positions[i].lng)) {
            console.warn("Invalid position at index", i, ":", positions[i]);
            continue;
        }

        const weight = Math.pow(smoothingFactor, positions.length - i - 1);
        sumLat += positions[i].lat * weight;
        sumLng += positions[i].lng * weight;
        totalWeight += weight;
        validPositionsCount++;
    }

    if (validPositionsCount === 0 || totalWeight === 0) {
        console.error("No valid positions for weighted average");
        return null;
    }

    const result = {
        lat: sumLat / totalWeight,
        lng: sumLng / totalWeight
    };

    console.log("Calculated weighted average position:", result);

    if (isNaN(result.lat) || isNaN(result.lng)) {
        console.error("Calculated NaN values in weighted average:", result);
        return null;
    }

    return result;
}
        
function calculateDistance(pos1, pos2) {
    const R = 6371e3;
    
    const φ1 = pos1.lat * Math.PI / 180;
    const φ2 = pos2.lat * Math.PI / 180;
    const Δφ = (pos2.lat - pos1.lat) * Math.PI / 180;
    const Δλ = (pos2.lng - pos1.lng) * Math.PI / 180;

    const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
            Math.cos(φ1) * Math.cos(φ2) *
            Math.sin(Δλ/2) * Math.sin(Δλ/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

    return R * c;
}

function centerMapOnUser(position, immediate = false) {
    if (!map || !position || typeof position.lat !== 'number' || typeof position.lng !== 'number') {
        console.warn('Invalid map or position for centering');
        return;
    }

    const center = map.getCenter();
    const distance = calculateDistance(center, position);

    if (distance > distanceThreshold || immediate) {
        map.panTo(position, {
            animate: !immediate,
            duration: 0.5,
            easeLinearity: 0.25
        });
    }
}
          
const MAX_RETRIES = 3;
const RETRY_DELAY = 1000;
let retryCount = 0;

function handleLocationError(error) {
    console.warn("Error getting user location:", error);
    
    if (retryCount < MAX_RETRIES) {
        retryCount++;
        console.log(`Retrying to get location (Attempt ${retryCount} of ${MAX_RETRIES})`);
        
        setTimeout(() => {
            retryCount = 0;
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    console.log("Location retrieved successfully after retry");
                    hideLoadingMessage();
                    updateUserLocation(position, true);
                },
                handleLocationError,
                {
                    enableHighAccuracy: true,
                    timeout: 10000,
                    maximumAge: 0
                }
            );
        }, RETRY_DELAY);
        return;
    }

    retryCount = 0;
    hideLoadingMessage();

    let errorMessage = "An error occurred while getting your location.";
    if (error && error.code) {
        switch(error.code) {
            case 1:
                errorMessage = "Please allow access to your location to use this feature.";
                break;
            case 2:
                errorMessage = "Your location is currently unavailable. Please try again later.";
                break;
            case 3:
                errorMessage = "Getting your location took too long. Please try again.";
                break;
        }
    }
    showPopup("Location Error", errorMessage);
}     
        
function showPopup(title, message, type = 'info', callback = null) {
    const popup = document.createElement('div');
    popup.classList.add('popup');
    popup.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: white;
        padding: 20px;
        border-radius: 10px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        z-index: 2000;
        text-align: center;
        max-width: 80%;
    `;

    const titleElement = document.createElement('h3');
    titleElement.textContent = title;
    titleElement.style.cssText = `
        margin-bottom: 10px;
        font-size: 18px;
        font-weight: bold;
    `;

    const messageElement = document.createElement('p');
    messageElement.textContent = message;
    messageElement.style.cssText = `
        margin-bottom: 20px;
        font-size: 16px;
    `;

    const buttonContainer = document.createElement('div');
    buttonContainer.style.cssText = `
        display: flex;
        justify-content: center;
        gap: 10px;
    `;

    const okButton = document.createElement('button');
    okButton.textContent = 'OK';
    okButton.style.cssText = `
        padding: 10px 20px;
        background-color: #005f9e;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
    `;

    okButton.addEventListener('click', () => {
        document.body.removeChild(popup);
        if (callback) callback();
    });

    buttonContainer.appendChild(okButton);

    if (type === 'info') {
        const cancelButton = document.createElement('button');
        cancelButton.textContent = 'Cancel';
        cancelButton.style.cssText = `
            padding: 10px  20px;
            background-color: #ccc;
            color: black;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        `;

        cancelButton.addEventListener('click', () => {
            document.body.removeChild(popup);
        });

        buttonContainer.appendChild(cancelButton);
    }

    popup.appendChild(titleElement);
    popup.appendChild(messageElement);
    popup.appendChild(buttonContainer);
    document.body.appendChild(popup);
}

function recenterMap() {
    const recenterButton = document.getElementById('recenterButton');
    recenterButton.style.backgroundColor = '#005f9e';
    recenterButton.style.color = 'white';
    if (userMarker && userMarker.getLatLng()) {
        map.closePopup();
        map.setView(userMarker.getLatLng(), map.getZoom(), {
            animate: true,
            duration: 0.5
        });
        followUser = true;
    }
    setTimeout(() => {
        recenterButton.style.backgroundColor = 'white';
        recenterButton.style.color = '#005f9e';
    }, 500);
}

function addUIEventListeners()  {
    document.getElementById('recenterButton').addEventListener('click', () => {
        recenterMap();
        resetInactivityTimer();
    });
    document.getElementById('returnButton').addEventListener('click', () => {
        returnToIndex();
        resetInactivityTimer();
    });
    document.getElementById('locationHuntButton').addEventListener('click', () => {
        toggleLocationHunt();
        resetInactivityTimer();
    });
    document.getElementById('locationHuntList').addEventListener('click', (event) => {
        if (event.target.tagName === 'LI') {
            const locationId = event.target.dataset.locationId;
            selectLocation(locationId);
        }
        resetInactivityTimer();
    });
}

function addMapEventListeners() {
    map.on('movestart', () => {
        followUser = false;
        isMapInteracting = true;
        resetInactivityTimer();
    });

    map.on('moveend', () => {
        isMapInteracting = false;
        resetInactivityTimer();
    });

    map.on('zoomstart', () => {
        isMapInteracting = true;
        resetInactivityTimer();
    });

    map.on('zoomend', () => {
        isMapInteracting = false;
        resetInactivityTimer();
    });

    map.on('click', () => {
        resetInactivityTimer();
    });
}

function resetInactivityTimer() {
    clearTimeout(inactivityTimer);
    inactivityTimer = setTimeout(() => {
        if (!isMapInteracting && !isLocationHuntVisible) {
            recenterMap();
        }
    }, INACTIVITY_TIMEOUT);
}

function returnToIndex() {
    window.location.href = 'index.html';
}

function toggleLocationHunt() {
    const locationHuntList = document.getElementById('locationHuntList');
    const locationHuntButton = document.getElementById('locationHuntButton');

    if (isLocationHuntVisible) {
        locationHuntList.style.display = 'none';
        locationHuntButton.textContent = 'Show Location Hunt';
    } else {
        locationHuntList.style.display = 'block';
        locationHuntButton.textContent = 'Hide Location Hunt';
        updateLocationHuntList();
    }

    isLocationHuntVisible = !isLocationHuntVisible;
}

function updateLocationHuntList() {
    const locationHuntList = document.getElementById('locationHuntList');
    locationHuntList.innerHTML = '';

    gameLocations.forEach((location, index) => {
        const listItem = document.createElement('li');
        listItem.textContent = `Location ${index + 1}`;
        listItem.dataset.locationId = location.id;
        if (visitedLocations.includes(location.id)) {
            listItem.classList.add('visited');
        }
        locationHuntList.appendChild(listItem);
    });
}

function selectLocation(locationId) {
    const selectedLocation = gameLocations.find(location => location.id === locationId);
    if (selectedLocation) {
        map.setView([selectedLocation.lat, selectedLocation.lng], 18);
    }
}

function startHunt() {
    gameLocations = generateGameLocations();
    addLocationMarkers();
    updateLocationHuntList();
}

function generateGameLocations() {
    const userLocation = userMarker.getLatLng();
    const locations = [];

    for (let i = 0; i < 5; i++) {
        const angle = Math.random() * 2 * Math.PI;
        const distance = Math.random() * 0.005 + 0.005; // 0.005 to 0.01 degrees (roughly 500m to 1km)
        const lat = userLocation.lat + distance * Math.cos(angle);
        const lng = userLocation.lng + distance * Math.sin(angle);

        locations.push({
            id: `location-${i + 1}`,
            lat: lat,
            lng: lng
        });
    }

    return locations;
}

function addLocationMarkers() {
    gameLocations.forEach(location => {
        const marker = L.marker([location.lat, location.lng], {
            icon: L.divIcon({
                className: 'game-location-marker',
                html: '<div class="marker-inner"></div>',
                iconSize: [20, 20]
            })
        });

        marker.addTo(markerClusterGroup);
        marker.on('click', () => handleLocationClick(location));
    });
}

function handleLocationClick(location) {
    if (visitedLocations.includes(location.id)) {
        showPopup('Already Visited', 'You have already discovered this location!');
        return;
    }

    const userLocation = userMarker.getLatLng();
    const distance = calculateDistance(userLocation, location);

    if (distance <= DISTANCE_THRESHOLD) {
        visitedLocations.push(location.id);
        showPopup('Location Discovered!', 'Congratulations! You have discovered a new location.');
        updateLocationHuntList();
        checkHuntCompletion();
    } else {
        showPopup('Too Far', 'You are too far from this location. Get closer to discover it!');
    }
}

function checkHuntCompletion() {
    if (visitedLocations.length === gameLocations.length) {
        showPopup('Hunt Completed!', 'Congratulations! You have discovered all locations!', 'success', () => {
            startHunt();
        });
    }
}

function updateDistanceBox() {
    const distanceBox = document.getElementById('distanceBox');
    if (!distanceBox) return;

    const nearestLocation = findNearestLocation();
    if (nearestLocation) {
        const distance = calculateDistance(userMarker.getLatLng(), nearestLocation);
        distanceBox.textContent = `Nearest: ${Math.round(distance)} m`;
    } else {
        distanceBox.textContent = 'No locations nearby';
    }
}

function findNearestLocation() {
    if (!userMarker) return null;

    const userLocation = userMarker.getLatLng();
    let nearestLocation = null;
    let minDistance = Infinity;

    gameLocations.forEach(location => {
        if (!visitedLocations.includes(location.id)) {
            const distance = calculateDistance(userLocation, location);
            if (distance < minDistance) {
                minDistance = distance;
                nearestLocation = location;
            }
        }
    });

    return nearestLocation;
}

function createAudioPlayer(audioUrl) {
    const audio = new Audio(audioUrl);
    audio.loop = true;
    return audio;
}

function playBackgroundMusic() {
    const backgroundMusic = createAudioPlayer('path/to/background-music.mp3');
    backgroundMusic.volume = 0.3;
    backgroundMusic.play();
}

function playSoundEffect(effectName) {
    const soundEffects = {
        discover: createAudioPlayer('path/to/discover-sound.mp3'),
        complete: createAudioPlayer('path/to/complete-sound.mp3')
    };

    if (soundEffects[effectName]) {
        soundEffects[effectName].play();
    }
}

function vibrate(duration) {
    if ('vibrate' in navigator) {
        navigator.vibrate(duration);
    }
}

function showNotification(title, body) {
    if ('Notification' in window) {
        Notification.requestPermission().then(permission => {
            if (permission === 'granted') {
                new Notification(title, { body });
            }
        });
    }
}

function handleDeviceOrientation(event) {
    const { alpha, beta, gamma } = event;
    // Use alpha (rotation around z-axis), beta (front/back tilt), and gamma (left/right tilt)
    // to update the map view or game mechanics
}

function enableDeviceOrientation() {
    if ('DeviceOrientationEvent' in window) {
        window.addEventListener('deviceorientation', handleDeviceOrientation);
    }
}

function disableDeviceOrientation() {
    window.removeEventListener('deviceorientation', handleDeviceOrientation);
}

function handleDeviceMotion(event) {
    const { acceleration, rotationRate, interval } = event;
    // Use acceleration and rotationRate to detect shaking or specific movements
}

function enableDeviceMotion() {
    if ('DeviceMotionEvent' in window) {
        window.addEventListener('devicemotion', handleDeviceMotion);
    }
}

function disableDeviceMotion() {
    window.removeEventListener('devicemotion', handleDeviceMotion);
}

function saveGameState() {
    const gameState = {
        visitedLocations,
        gameLocations,
        userPosition: userMarker ? userMarker.getLatLng() : null
    };
    localStorage.setItem('gameState', JSON.stringify(gameState));
}

function loadGameState() {
    const savedState = localStorage.getItem('gameState');
    if (savedState) {
        const gameState = JSON.parse(savedState);
        visitedLocations = gameState.visitedLocations;
        gameLocations = gameState.gameLocations;
        if (gameState.userPosition && userMarker) {
            userMarker.setLatLng(gameState.userPosition);
        }
        updateLocationHuntList();
    }
}

function clearGameState() {
    localStorage.removeItem('gameState');
}

function showTutorial() {
    const steps = [
        { element: '#map', title: 'Map', content: 'This is where you will see your location and game markers.' },
        { element: '#recenterButton', title: 'Recenter', content: 'Click here to center the map on your location.' },
        { element: '#locationHuntButton', title: 'Location Hunt', content: 'Toggle the list of locations to find.' },
        { element: '#returnButton', title: 'Return', content: 'Go back to the main menu.' }
    ];

    steps.forEach((step, index) => {
        setTimeout(() => {
            showPopup(step.title, step.content, 'info', () => {
                if (index === steps.length - 1) {
                    showPopup('Ready!', 'You're all set to start your adventure!');
                }
            });
        }, index * 5000);
    });
}

function addSwipeGestures() {
    let touchStartX = 0;
    let touchEndX = 0;

    document.addEventListener('touchstart', e => {
        touchStartX = e.changedTouches[0].screenX;
    });

    document.addEventListener('touchend', e => {
        touchEndX = e.changedTouches[0].screenX;
        handleSwipe();
    });

    function handleSwipe() {
        if (touchEndX < touchStartX) {
            // Swipe left
            toggleLocationHunt();
        }
        if (touchEndX > touchStartX) {
            // Swipe right
            recenterMap();
        }
    }
}

function handleNetworkChange() {
    window.addEventListener('online', () => {
        showPopup('Connection Restored', 'You are back online. Game data will now sync.');
        // Implement sync logic here
    });

    window.addEventListener('offline', () => {
        showPopup('No Connection', 'You are offline. The game will continue, but some features may be limited.');
    });
}

function implementProgressSystem() {
    let userLevel = 1;
    let userExperience = 0;

    function gainExperience(amount) {
        userExperience += amount;
        checkLevelUp();
    }

    function checkLevelUp() {
        const experienceToNextLevel = userLevel * 100;
        if (userExperience >= experienceToNextLevel) {
            userLevel++;
            userExperience -= experienceToNextLevel;
            showPopup('Level Up!', `Congratulations! You are now level ${userLevel}!`);
            // Implement level-up rewards or new features here
        }
    }

    // Example usage
    // gainExperience(50); // Call this when user discovers a location
}

function createLeaderboard() {
    const leaderboard = [
        { name: 'Player1', score: 1000 },
        { name: 'Player2', score: 850 },
        { name: 'Player3', score: 750 },
        // ... more players
    ];

    function updateLeaderboard(playerName, newScore) {
        const playerIndex = leaderboard.findIndex(p => p.name === playerName);
        if (playerIndex !== -1) {
            leaderboard[playerIndex].score = newScore;
        } else {
            leaderboard.push({ name: playerName, score: newScore });
        }
        leaderboard.sort((a, b) => b.score - a.score);
        displayLeaderboard();
    }

    function displayLeaderboard() {
        const leaderboardElement = document.getElementById('leaderboard');
        if (leaderboardElement) {
            leaderboardElement.innerHTML = '';
            leaderboard.forEach((player, index) => {
                const playerElement = document.createElement('div');
                playerElement.textContent = `${index + 1}. ${player.name}: ${player.score}`;
                leaderboardElement.appendChild(playerElement);
            });
        }
    }

    // Example usage
    // updateLeaderboard('Player4', 900);
}

function implementDailyChallenge() {
    const challenges = [
        { description: 'Visit 3 new locations', reward: 100 },
        { description: 'Travel 5km in the game', reward: 150 },
        { description: 'Discover a rare location', reward: 200 },
        // ... more challenges
    ];

    function selectDailyChallenge() {
        const today = new Date().toDateString();
        const savedChallenge = localStorage.getItem('dailyChallenge');
        if (savedChallenge) {
            const { date, challenge } = JSON.parse(savedChallenge);
            if (date === today) {
                return challenge;
            }
        }
        const newChallenge = challenges[Math.floor(Math.random() * challenges.length)];
        localStorage.setItem('dailyChallenge', JSON.stringify({ date: today, challenge: newChallenge }));
        return newChallenge;
    }

    function displayDailyChallenge() {
        const challenge = selectDailyChallenge();
        showPopup('Daily Challenge', `Today's challenge: ${challenge.description}\nReward: ${challenge.reward} XP`);
    }

    // Call displayDailyChallenge() when the game starts or at midnight
}

function createInventorySystem() {
    const inventory = [];

    function addItemToInventory(item) {
        inventory.push(item);
        updateInventoryDisplay();
    }

    function removeItemFromInventory(itemIndex) {
        if (itemIndex >= 0 && itemIndex < inventory.length) {
            inventory.splice(itemIndex, 1);
            updateInventoryDisplay();
        }
    }

    function updateInventoryDisplay() {
        const inventoryElement = document.getElementById('inventory');
        if (inventoryElement) {
            inventoryElement.innerHTML = '';
            inventory.forEach((item, index) => {
                const itemElement = document.createElement('div');
                itemElement.textContent = item.name;
                itemElement.addEventListener('click', () => useItem(index));
                inventoryElement.appendChild(itemElement);
            });
        }
    }

    function useItem(itemIndex) {
        const item = inventory[itemIndex];
        if (item) {
            // Implement item usage logic here
            showPopup('Item Used', `You used ${item.name}`);
            removeItemFromInventory(itemIndex);
        }
    }

    // Example usage
    // addItemToInventory({ name: 'Map', type: 'tool' });
    // addItemToInventory({ name: 'Compass', type: 'tool' });
}

function implementWeatherSystem() {
    async function fetchWeather(lat, lon) {
        const apiKey = 'your_openweathermap_api_key';
        const url = `https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lon}&appid=${apiKey}&units=metric`;
        
        try {
            const response = await fetch(url);
            const data = await response.json();
            return data;
        } catch (error) {
            console.error('Error fetching weather data:', error);
            return null;
        }
    }

    function updateGameBasedOnWeather(weatherData) {
        if (!weatherData) return;

        const { main, weather } = weatherData;
        const temperature = main.temp;
        const conditions = weather[0].main.toLowerCase();

        // Adjust game mechanics based on weather
        if (temperature < 0) {
            // Implement cold weather effects
        } else if (temperature > 30) {
            // Implement hot weather effects
        }

        if (conditions.includes('rain') || conditions.includes('snow')) {
            // Implement precipitation effects
        } else if (conditions.includes('clear')) {
            // Implement clear weather bonuses
        }

        // Update UI to show current weather
        updateWeatherUI(weatherData);
    }

    function updateWeatherUI(weatherData) {
        const weatherElement = document.getElementById('weatherInfo');
        if (weatherElement && weatherData) {
            weatherElement.textContent = `${weatherData.main.temp}°C, ${weatherData.weather[0].description}`;
        }
    }

    // Call this function periodically or when the user's location changes significantly
    async function updateWeather() {
        if (userMarker) {
            const { lat, lng } = userMarker.getLatLng();
            const weatherData = await fetchWeather(lat, lng);
            updateGameBasedOnWeather(weatherData);
        }
    }

    // Example usage
    // setInterval(updateWeather, 600000); // Update weather every 10 minutes
}

function createQuestSystem() {
    const quests = [
        { id: 1, name: 'Beginner\'s Journey', description: 'Visit 5 locations', progress: 0, goal: 5, reward: 100 },
        { id: 2, name: 'Explorer', description: 'Discover a rare location', progress: 0, goal: 1, reward: 200 },
        // ... more quests
    ];

    let activeQuests = [];

    function startQuest(questId) {
        const quest = quests.find(q => q.id === questId);
        if (quest && !activeQuests.some(q => q.id === questId)) {
            activeQuests.push({ ...quest });
            updateQuestLog();
        }
    }

    function updateQuestProgress(questId, amount = 1) {
        const questIndex = activeQuests.findIndex(q => q.id === questId);
        if (questIndex !== -1) {
            activeQuests[questIndex].progress += amount;
            checkQuestCompletion(questIndex);
            updateQuestLog();
        }
    }

    function checkQuestCompletion(questIndex) {
        const quest = activeQuests[questIndex];
        if (quest.progress >= quest.goal) {
            showPopup('Quest Completed!', `You've completed "${quest.name}"! Reward: ${quest.reward} XP`);
            // Add reward to player's experience
            activeQuests.splice(questIndex, 1);
        }
    }

    function updateQuestLog() {
        const questLogElement = document.getElementById('questLog');
        if (questLogElement) {
            questLogElement.innerHTML = '';
            activeQuests.forEach(quest => {
                const questElement = document.createElement('div');
                questElement.textContent = `${quest.name}: ${quest.progress}/${quest.goal}`;
                questLogElement.appendChild(questElement);
            });
        }
    }

    // Example usage
    // startQuest(1);
    // updateQuestProgress(1); // Call this when a relevant game event occurs
}

function implementTimeBasedEvents() {
    const events = [
        { name: 'Double XP Hour', duration: 60 * 60 * 1000, effect: () => { /* Implement double XP logic */ } },
        { name: 'Rare Spawn Increase', duration: 30 * 60 * 1000, effect: () => { /* Increase rare location spawns */ } },
        // ... more events
    ];

    let activeEvent = null;

    function startRandomEvent() {
        if (activeEvent) return;

        const event = events[Math.floor(Math.random() * events.length)];
        activeEvent = event;
        showPopup('Event Started!', `${event.name} has begun!`);
        event.effect();

        setTimeout(() => {
            showPopup('Event Ended', `${event.name} has ended.`);
            activeEvent = null;
        }, event.duration);
    }

    // Start a random event every 3 hours
    setInterval(startRandomEvent, 3 * 60 * 60 * 1000);
}

function createAchievementSystem() {
    const achievements = [
        { id: 1, name: 'First Steps', description: 'Visit your first location', unlocked: false },
        { id: 2, name: 'Explorer', description: 'Visit 50 unique locations', progress: 0, goal: 50, unlocked: false },
        // ... more achievements
    ];

    function checkAchievement(achievementId) {
        const achievement = achievements.find(a => a.id === achievementId);
        if (achievement && !achievement.unlocked) {
            if (achievement.goal) {
                achievement.progress++;
                if (achievement.progress >= achievement.goal) {
                    unlockAchievement(achievement);
                }
            } else {
                unlockAchievement(achievement);
            }
        }
    }

    function unlockAchievement(achievement) {
        achievement.unlocked = true;
        showPopup('Achievement Unlocked!', `You've earned the "${achievement.name}" achievement!`);
        updateAchievementDisplay();
    }

    function updateAchievementDisplay() {
        const achievementElement = document.getElementById('achievements');
        if (achievementElement) {
            achievementElement.innerHTML = '';
            achievements.forEach(achievement => {
                const achievementDiv = document.createElement('div');
                achievementDiv.textContent = `${achievement.name}: ${achievement.unlocked ? 'Unlocked' : 'Locked'}`;
                if (achievement.goal) {
                    achievementDiv.textContent += ` (${achievement.progress}/${achievement.goal})`;
                }
                achievementElement.appendChild(achievementDiv);
            });
        }
    }

    // Example usage
    // checkAchievement(1); // Call this when visiting the first location
    // checkAchievement(2); // Call this every time a new location is visited
}

function implementFriendSystem() {
    const friends = [];

    function addFriend(friendId, friendName) {
        if (!friends.some(friend => friend.id === friendId)) {
            friends.push({ id: friendId, name: friendName });
            updateFriendList();
        }
    }

    function removeFriend(friendId) {
        const index = friends.findIndex(friend => friend.id === friendId);
        if (index !== -1) {
            friends.splice(index, 1);
            updateFriendList();
        }
    }

    function updateFriendList() {
        const friendListElement = document.getElementById('friendList');
        if (friendListElement) {
            friendListElement.innerHTML = '';
            friends.forEach(friend => {
                const friendElement = document.createElement('div');
                friendElement.textContent = friend.name;
                friendListElement.appendChild(friendElement);
            });
        }
    }

    function sendFriendRequest(friendId) {
        // Implement logic to send a friend request
        console.log(`Friend request sent to ${friendId}`);
    }

    function acceptFriendRequest(friendId, friendName) {
        addFriend(friendId, friendName);
        // Implement logic to update server about accepted friend request
    }

    // Example usage
    // addFriend('user123', 'John Doe');
    // sendFriendRequest('user456');
}

function createChatSystem() {
    let chatMessages = [];

    function sendMessage(message) {
        const newMessage = {
            id: Date.now(),
            sender: 'currentUser', // Replace with actual user ID
            content: message,
            timestamp: new Date().toISOString()
        };
        chatMessages.push(newMessage);
        updateChatDisplay();
        // Implement logic to send message to server or other players
    }

    function receiveMessage(message) {
        chatMessages.push(message);
        updateChatDisplay();
    }

    function updateChatDisplay() {
        const chatElement = document.getElementById('chatBox');
        if (chatElement) {
            chatElement.innerHTML = '';
            chatMessages.forEach(message => {
                const messageElement = document.createElement('div');
                messageElement.textContent = `${message.sender}: ${message.content}`;
                chatElement.appendChild(messageElement);
            });
            chatElement.scrollTop = chatElement.scrollHeight;
        }
    }

    // Example usage
    // sendMessage('Hello, everyone!');
    // receiveMessage({ id: 123, sender: 'user456', content: 'Hi there!', timestamp: new Date().toISOString() });
}

function implementTradeSystem() {
    function initiateTradeRequest(targetPlayerId, offeredItems, requestedItems) {
        // Send trade request to server or directly to the target player
        console.log(`Trade request sent to ${targetPlayerId}`);
        // Implement logic to wait for response
    }

    function respondToTradeRequest(tradeId, accepted) {
        if (accepted) {
            // Implement logic to exchange items
            console.log(`Trade ${tradeId} accepted`);
        } else {
            console.log(`Trade ${tradeId} declined`);
        }
        // Notify other player of the decision
    }

    function displayTradeUI(tradeData) {
        // Create and display a trade UI with offered and requested items
        // Implement UI logic here
    }

    // Example usage
    // initiateTradeRequest('player123', ['item1', 'item2'], ['item3']);
    // respondToTradeRequest('trade456', true);
}

function createMiniGames() {
    const miniGames = [
        {
            name: 'Memory Match',
            start: () => {
                // Implement memory matching game logic
                console.log('Starting Memory Match mini-game');
            }
        },
        {
            name: 'Trivia Challenge',
            start: () => {
                // Implement trivia game logic
                console.log('Starting Trivia Challenge mini-game');
            }
        }
        // Add more mini-games here
    ];

    function startRandomMiniGame() {
        const game = miniGames[Math.floor(Math.random() * miniGames.length)];
        game.start();
    }

    // Example usage
    // startRandomMiniGame();
}

function implementDayNightCycle() {
    let isNightTime = false;
    const DAY_DURATION = 10 * 60 * 1000; // 10 minutes for testing, adjust as needed

    function toggleDayNight() {
        isNightTime = !isNightTime;
        if (isNightTime) {
            // Implement night-time changes
            document.body.classList.add('night-mode');
            // Adjust game mechanics for night time
        } else {
            // Implement day-time changes
            document.body.classList.remove('night-mode');
            // Adjust game mechanics for day time
        }
        console.log(isNightTime ? 'Night has fallen' : 'A new day has dawned');
    }

    // Start the day/night cycle
    setInterval(toggleDayNight, DAY_DURATION);
}

function createCraftingSystem() {
    const recipes = [
        { name: 'Super Compass', ingredients: ['compass', 'rare_crystal'], result: 'super_compass' },
        { name: 'Speed Boots', ingredients: ['boots', 'feather'], result: 'speed_boots' },
        // Add more recipes
    ];

    function craft(recipeName) {
        const recipe = recipes.find(r => r.name === recipeName);
        if (recipe) {
            // Check if player has all ingredients
            const hasAllIngredients = recipe.ingredients.every(ingredient => playerHasItem(ingredient));
            if (hasAllIngredients) {
                // Remove ingredients from inventory
                recipe.ingredients.forEach(ingredient => removeItemFromInventory(ingredient));
                // Add crafted item to inventory
                addItemToInventory(recipe.result);
                console.log(`Successfully crafted ${recipe.name}`);
            } else {
                console.log(`Missing ingredients for ${recipe.name}`);
            }
        } else {
            console.log('Recipe not found');
        }
    }

    function playerHasItem(itemName) {
        // Implement logic to check if player has the item in their inventory
        return true; // Placeholder
    }

    // Example usage
    // craft('Super Compass');
}

function implementSeasonalEvents() {
    const seasons = ['spring', 'summer', 'autumn', 'winter'];
    let currentSeason = 'spring';
    const SEASON_DURATION = 7 * 24 * 60 * 60 * 1000; // 7 days

    function changeSeason() {
        const currentIndex = seasons.indexOf(currentSeason);
        currentSeason = seasons[(currentIndex + 1) % seasons.length];
        console.log(`The season has changed to ${currentSeason}`);
        // Implement season-specific changes
        updateSeasonalContent();
    }

    function updateSeasonalContent() {
        // Update game content based on the current season
        switch (currentSeason) {
            case 'spring':
                // Implement spring-specific content
                break;
            case 'summer':
                // Implement summer-specific content
                break;
            case 'autumn':
                // Implement autumn-specific content
                break;
            case 'winter':
                // Implement winter-specific content
                break;
        }
    }

    // Start the seasonal cycle
    setInterval(changeSeason, SEASON_DURATION);
}

// Main game initialization
document.addEventListener('DOMContentLoaded', function() {
    initMap();
    addUIEventListeners();
    addMapEventListeners();
    loadGameState();
    showTutorial();
    addSwipeGestures();
    handleNetworkChange();
    implementProgressSystem();
    createLeaderboard();
    implementDailyChallenge();
    createInventorySystem();
    implementWeatherSystem();
    createQuestSystem();
    implementTimeBasedEvents();
    createAchievementSystem();
    implementFriendSystem();
    createChatSystem();
    implementTradeSystem();
    createMiniGames();
    implementDayNightCycle();
    createCraftingSystem();
    implementSeasonalEvents();

    // Start background music
    playBackgroundMusic();

    // Enable device orientation and motion if needed
    enableDeviceOrientation();
    enableDeviceMotion();

    // Set up periodic game state saving
    setInterval(saveGameState, 60000); // Save every minute

    console.log("Location-based game initialized and ready to play!");
});
    </script>
  </body>
</html>
