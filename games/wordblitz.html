<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Scrabble-Bingo Hybrid Game</title>
  <style>
:root {
  --primary-color: #3a0ca3;
  --secondary-color: #f72585;
  --background-color: #4cc9f0;
  --board-color: #ffffff;
  --tile-color: #ffd166;
  --text-color: #ffffff;
  --border-radius: 10px;
}

body {
  display: flex;
  flex-direction: column;
  align-items: center;
  background-color: var(--background-color);
  font-family: 'Roboto', sans-serif;
  padding: 10px;
  color: var(--text-color);
  min-height: 100vh;
  margin: 0;
}

#game-container {
  background-color: rgba(255, 255, 255, 0.1);
  border-radius: var(--border-radius);
  padding: 10px;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
  backdrop-filter: blur(10px);
}

#game-board {
  display: grid;
  grid-template-columns: repeat(6, 1fr);
  grid-template-rows: repeat(6, 1fr);
  gap: 3px;
  margin-bottom: 10px;
  border: 2px solid var(--primary-color);
  padding: 5px;
  background-color: var(--board-color);
  border-radius: var(--border-radius);
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

.square {
  width: 45px;
  height: 45px;
  background-color: var(--board-color);
  border: 1px solid rgba(0, 0, 0, 0.2);
  display: flex;
  justify-content: center;
  align-items: center;
  font-size: 18px;
  font-weight: bold;
  cursor: pointer;
  transition: all 0.3s ease;
  border-radius: 5px;
  color: var(--primary-color);
}

.square:hover {
  transform: scale(1.05);
  box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
}

.blocked {
  background-color: rgba(0, 0, 0, 0.55) !important;
  cursor: not-allowed
}

.double-letter { background-color: rgba(173, 216, 230, 0.5); }
.triple-letter { background-color: rgba(70, 130, 180, 0.5); }
.double-word { background-color: rgba(255, 160, 122, 0.5); }
.triple-word { background-color: rgba(255, 99, 71, 0.5); }
.word-highlight { background-color: rgba(144, 238, 144, 0.5); }

#tile-container {
  display: flex;
  gap: 5px;
  margin-bottom: 10px;
  justify-content: center;
}

.tile {
  width: 50px;
  height: 50px;
  background-color: var(--tile-color);
  border: 2px solid var(--primary-color);
  border-radius: var(--border-radius);
  display: flex;
  justify-content: center;
  align-items: center;
  font-size: 20px;
  font-weight: bold;
  cursor: pointer;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
  transition: all 0.3s ease;
  color: var(--primary-color);
  position: relative;
  overflow: hidden;
}

.tile::before {
  content: '';
  position: absolute;
  top: -50%;
  left: -50%;
  width: 200%;
  height: 200%;
  background: radial-gradient(circle, rgba(255,255,255,0.3) 0%, rgba(255,255,255,0) 70%);
  transform: scale(0);
  transition: transform 0.3s ease-out;
}

.tile:hover::before {
  transform: scale(1);
}

.tile.dragging {
  opacity: 0.7;
  transform: scale(1.1);
}

#score, #round {
  font-size: 24px;
  font-weight: bold;
  margin-bottom: 10px;
  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
}

#controls {
  display: flex;
  gap: 10px;
  margin-top: 10px;
}

button {
  padding: 8px 16px;
  font-size: 16px;
  font-weight: bold;
  background-color: var(--secondary-color);
  color: var(--text-color);
  border: none;
  border-radius: var(--border-radius);
  cursor: pointer;
  transition: all 0.3s ease;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

button:hover {
  transform: translateY(-3px);
  box-shadow: 0 6px 8px rgba(0, 0, 0, 0.2);
}

.popup {
  display: none;
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: var(--primary-color);
  color: var(--text-color);
  padding: 20px;
  border-radius: var(--border-radius);
  box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
  z-index: 1000;
  text-align: center;
  animation: popupFadeIn 0.3s ease-in-out;
}

@keyframes popupFadeIn {
  0% { opacity: 0; transform: translate(-50%, -60%); }
  100% { opacity: 1; transform: translate(-50%, -50%); }
}

@media (max-width: 400px) {
  .square {
    width: 40px;
    height: 40px;
    font-size: 16px;
  }

  .tile {
    width: 45px;
    height: 45px;
    font-size: 18px;
  }

  #score, #round {
    font-size: 20px;
  }
  
    .popup {
    display: none;
    position: fixed;
    z-index: 1;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    overflow: auto;
    background-color: rgba(0,0,0,0.4);
  }

  .popup-content {
    background-color: #fefefe;
    margin: 15% auto;
    padding: 20px;
    border: 1px solid #888;
    width: 80%;
    max-width: 600px;
  }

  button {
    padding: 6px 12px;
    font-size: 14px;
  }
}
  </style>
</head>
<body>
  <div id="round">Round: 1</div>
  <div id="score">Score: 0</div>
  <div id="game-board"></div>
  <div id="tile-container"></div>
  <div id="controls">
    <button onclick="startOver()">Start Over</button>
  </div>
  <div class="popup" id="roundPopup">
    <p id="roundPopupText"></p>
    <button onclick="closePopup()">OK</button>
  </div>
  
  <button onclick="openInstructionsPopup()">How to Play</button>
<div class="popup" id="instructionsPopup">
  <div class="popup-content">
    <h2>How to Play</h2>
    <p>Here are the instructions on how to play the game:</p>
    <ul>
      <li>Instruction 1</li>
      <li>Instruction 2</li>
      <li>Instruction 3</li>
    </ul>
    <button onclick="closeInstructionsPopup()">Close</button>
  </div>
</div>

<script>
const board = document.getElementById('game-board');
const tileContainer = document.getElementById('tile-container');
const scoreDisplay = document.getElementById('score');
const roundDisplay = document.getElementById('round');
const roundPopup = document.getElementById('roundPopup');
const roundPopupText = document.getElementById('roundPopupText');
const boardSize = 6;
const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
let draggingTile = null;
let score = 0;
let round = 1;
let userTurn = true;
let wordList = [];
let placedLetters = {}; // Track placed letters for word checking

// Load word list from JSON file
fetch('words.json')
  .then(response => response.json())
  .then(data => {
    wordList = data.words;
  });

// Example point values for letters
const letterPoints = {
  'A': 1, 'B': 3, 'C': 3, 'D': 2, 'E': 1,
  'F': 4, 'G': 2, 'H': 4, 'I': 1, 'J': 8,
  'K': 5, 'L': 1, 'M': 3, 'N': 1, 'O': 1,
  'P': 3, 'Q': 10, 'R': 1, 'S': 1, 'T': 1,
  'U': 1, 'V': 4, 'W': 4, 'X': 8, 'Y': 4, 'Z': 10
};

// Special squares setup (manually assigned)
const specialSquares = [
  { x: 1, y: 1, type: 'double-letter' },
  { x: 4, y: 1, type: 'triple-letter' },
  { x: 2, y: 3, type: 'double-word' },
  { x: 5, y: 4, type: 'triple-word' }
  // Add more as needed
];

// Function to create a square element
function createSquare(x, y) {
  const square = document.createElement('div');
  square.className = 'square';
  square.dataset.x = x;
  square.dataset.y = y;

  // Check if this square is a special square
  const specialSquare = specialSquares.find(square => square.x === x && square.y === y);
  if (specialSquare) {
    square.classList.add(specialSquare.type);
  }

  square.addEventListener('dragover', (e) => {
    e.preventDefault();
  });

  square.addEventListener('drop', () => {
    if (draggingTile && !square.classList.contains('blocked') && square.textContent === '' && userTurn) {
      square.textContent = draggingTile.textContent;
      placedLetters[`${x},${y}`] = draggingTile.textContent;
      calculateScore(draggingTile.textContent, square);
      draggingTile.remove();
      draggingTile = null;
      userTurn = false;
      checkGameOver();
      initializeTiles();
      computerTurn();
    }
  });

  square.addEventListener('touchstart', (e) => {
    if (userTurn && !square.classList.contains('blocked') && square.textContent === '') {
      e.preventDefault();
      square.textContent = draggingTile.textContent;
      placedLetters[`${x},${y}`] = draggingTile.textContent;
      calculateScore(draggingTile.textContent, square);
      draggingTile.remove();
      draggingTile = null;
      userTurn = false;
      checkGameOver();
      initializeTiles();
      computerTurn();
    }
  });

  return square;
}

// Initialize the game board
for (let y = 0; y < boardSize; y++) {
  for (let x = 0; x < boardSize; x++) {
    board.appendChild(createSquare(x, y));
  }
}

// Function to create a tile element
function createTile(letter) {
  const tile = document.createElement('div');
  tile.className = 'tile';
  tile.draggable = true;
  tile.textContent = letter;

  tile.addEventListener('dragstart', () => {
    draggingTile = tile;
    tile.classList.add('dragging');
  });

  tile.addEventListener('dragend', () => {
    tile.classList.remove('dragging');
    draggingTile = null;
  });

  tile.addEventListener('touchstart', (e) => {
    e.preventDefault();
    draggingTile = tile;
    tile.classList.add('dragging');
  });

  tile.addEventListener('touchmove', (e) => {
    e.preventDefault();
    const touch = e.touches[0];
    const offsetX = touch.clientX - tile.offsetWidth / 2;
    const offsetY = touch.clientY - tile.offsetHeight / 2;
    tile.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
  });

  tile.addEventListener('touchend', () => {
    tile.classList.remove('dragging');
    draggingTile = null;

    // Find the square where the tile is dropped
    const rect = board.getBoundingClientRect();
    const touchX = event.changedTouches[0].clientX - rect.left;
    const touchY = event.changedTouches[0].clientY - rect.top;
    const squareSize = rect.width / boardSize;

    const x = Math.floor(touchX / squareSize);
    const y = Math.floor(touchY / squareSize);

    const square = board.querySelector(`.square[data-x="${x}"][data-y="${y}"]`);
    if (square && !square.classList.contains('blocked') && square.textContent === '' && userTurn) {
      square.textContent = tile.textContent;
      placedLetters[`${x},${y}`] = tile.textContent;
      calculateScore(tile.textContent, square);
      tile.remove();
      draggingTile = null;
      userTurn = false;
      checkGameOver();
      initializeTiles();
      computerTurn();
    } else {
      tile.style.transform = ''; // Reset tile position if not dropped on valid square
    }
  });

  return tile;
}

// Initialize tiles for the user
function initializeTiles() {
  tileContainer.innerHTML = '';
  const letter = letters[Math.floor(Math.random() * letters.length)];
  tileContainer.appendChild(createTile(letter));
}

// Function to block a random square for the computer's turn
function computerTurn() {
  const emptySquares = Array.from(board.children).filter(square => !square.classList.contains('blocked') && square.textContent === '');
  if (emptySquares.length > 0) {
    const randomSquare = emptySquares[Math.floor(Math.random() * emptySquares.length)];
    randomSquare.classList.add('blocked');
    userTurn = true;
  }
  checkGameOver();
}

// Calculate score based on letter and square type
function calculateScore(letter, square) {
  let points = letterPoints[letter];
  if (square.classList.contains('double-letter')) {
    points *= 2;
  } else if (square.classList.contains('triple-letter')) {
    points *= 3;
  } else if (square.classList.contains('double-word')) {
    points *= 2; // Assuming double points for the word, simplifying here
  } else if (square.classList.contains('triple-word')) {
    points *= 3; // Assuming triple points for the word, simplifying here
  }
  score += points;
  scoreDisplay.textContent = `Score: ${score}`;
}

// Check if the board is full
function checkGameOver() {
  const allSquares = Array.from(board.children);
  const isFull = allSquares.every(square => square.textContent !== '' || square.classList.contains('blocked'));
  if (isFull) {
    calculateFinalScore();
    if (score >= getRequiredPoints()) {
      round++;
      roundDisplay.textContent = `Round: ${round}`;
      removeRandomLetter();
      showPopup();
    } else {
      alert(`Game Over! You scored ${score} points. You needed at least ${getRequiredPoints()} points to continue.`);
      resetGame();
    }
  }
}

// Calculate the final score based on the words formed
function calculateFinalScore() {
  const words = extractWords();
  let extraPoints = 0;
  words.forEach(word => {
    if (isValidWord(word)) {
      switch (word.length) {
        case 1: extraPoints += 0; break;
        case 2: extraPoints += 2; break;
        case 3: extraPoints += 3; break;
        case 4: extraPoints += 4; break;
        case 5: extraPoints += 10; break;
        case 6: extraPoints += 20; break;
      }
      word.split('').forEach((letter, index) => {
        const [x, y] = Object.keys(placedLetters).find(key => placedLetters[key] === letter).split(',').map(Number);
        const square = board.children[y * boardSize + x];
        if (square.classList.contains('double-word')) {
          extraPoints += letterPoints[letter];
        } else if (square.classList.contains('triple-word')) {
          extraPoints += letterPoints[letter] * 2;
        }
      });
    }
  });
  score += extraPoints;
  scoreDisplay.textContent = `Score: ${score}`;
}

// Extract all words formed on the board
function extractWords() {
  const words = [];
  const visited = new Set();
  // Extract words horizontally
  for (let y = 0; y < boardSize; y++) {
    let word = '';
    for (let x = 0; x < boardSize; x++) {
      const square = board.children[y * boardSize + x];
      if (square.textContent && !visited.has(`${x},${y}`)) {
        word += square.textContent;
        visited.add(`${x},${y}`);
      } else {
        if (word) words.push(word);
        word = '';
        visited.clear();
      }
    }
    if (word) words.push(word);
  }
  visited.clear();
  // Extract words vertically
  for (let x = 0; x < boardSize; x++) {
    let word = '';
    for (let y = 0; y < boardSize; y++) {
      const square = board.children[y * boardSize + x];
      if (square.textContent && !visited.has(`${x},${y}`)) {
        word += square.textContent;
        visited.add(`${x},${y}`);
      } else {
        if (word) words.push(word);
        word = '';
        visited.clear();
      }
    }
    if (word) words.push(word);
  }
  return words.filter(word => word.length > 1);
}

// Check if a word is valid
function isValidWord(word) {
  return wordList.includes(word.toLowerCase());
}

// Function to remove a random letter from the board
function removeRandomLetter() {
  const emptySquares = Array.from(board.children).filter(square => square.textContent !== '');
  if (emptySquares.length > 0) {
    const randomSquare = emptySquares[Math.floor(Math.random() * emptySquares.length)];
    randomSquare.textContent = '';
  }
}

// Function to show round completion popup
function showPopup() {
  roundPopup.style.display = 'block';
  roundPopupText.textContent = `Congratulations! You scored ${score} points. You need to score at least ${getRequiredPoints()} points in the next round to continue.`;
}

// Function to hide round completion popup
function hidePopup() {
  roundPopup.style.display = 'none';
}

// Function to reset the game
function resetGame() {
  score = 0;
  round = 1;
  userTurn = true;
  placedLetters = {};
  scoreDisplay.textContent = `Score: ${score}`;
  roundDisplay.textContent = `Round: ${round}`;
  hidePopup();
  const allSquares = Array.from(board.children);
  allSquares.forEach(square => {
    square.textContent = '';
    square.classList.remove('blocked');
  });
  initializeTiles();
}


// Function to get required points for the next round
function getRequiredPoints() {
  return 50 + (round - 1) * 25;
}

// Add these functions near the end of the script

function closePopup() {
  hidePopup();
  resetGame();
}

function startOver() {
  if (confirm("Are you sure you want to start over? This will reset your progress.")) {
    resetGame();
  }
}

// Modify the resetGame function to be more comprehensive
function resetGame() {
  score = 0;
  round = 1;
  userTurn = true;
  placedLetters = {};
  scoreDisplay.textContent = `Score: ${score}`;
  roundDisplay.textContent = `Round: ${round}`;
  hidePopup();
  
  const allSquares = Array.from(board.children);
  allSquares.forEach(square => {
    square.textContent = '';
    square.classList.remove('blocked', 'word-highlight');
  });
  
  tileContainer.innerHTML = '';
  initializeTiles();
}

// Modify the showPopup function to use the "OK" button correctly
function showPopup() {
  roundPopup.style.display = 'block';
  roundPopupText.textContent = `Congratulations! You scored ${score} points. You need to score at least ${getRequiredPoints()} points in the next round to continue.`;
  document.querySelector('#roundPopup button').onclick = () => {
    hidePopup();
    startNextRound();
  };
}

// Add a new function to start the next round
function startNextRound() {
  round++;
  roundDisplay.textContent = `Round: ${round}`;
  removeRandomLetter();
  resetBoardForNextRound();
  initializeTiles();
  userTurn = true;
}

  function openInstructionsPopup() {
    document.getElementById("instructionsPopup").style.display = "block";
  }

  function closeInstructionsPopup() {
    document.getElementById("instructionsPopup").style.display = "none";
  }

// Add a new function to reset the board for the next round
function resetBoardForNextRound() {
  const allSquares = Array.from(board.children);
  allSquares.forEach(square => {
    if (!square.classList.contains('blocked')) {
      square.textContent = '';
    }
    square.classList.remove('word-highlight');
  });
  placedLetters = {};
}

// Initialize the game
initializeTiles();

</script>

</body>
</html>
