<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Scrabble-Bingo Hybrid Game</title>
  <link rel="shortcut icon" type="image/x-icon" href="minthen.png">
  <link rel="stylesheet" href="game.css">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
      
  <style>
  
    .exit-btn {
  position: absolute;
  bottom: 10px;
  right: 10px;
  width: 40px;
  height: 40px;
  background-color: #f72585;
  border: none;
  border-radius: 50%;
  color: #fff;
  font-size: 30px;
  cursor: pointer;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
  transition: transform 0.3s ease;

  display: flex;
  justify-content: center;
  align-items: center;
}

.exit-btn:hover {
  transform: scale(1.1);
}

.exit-btn .material-icons {
  font-size: 25px; /* Adjust the icon size */
}


.exit-popup {
  display: none;
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: #fff;
  padding: 20px;
  box-shadow: 0 0 10px rgba(0,0,0,0.1);
  border-radius: 8px;
  text-align: center;
}

.exit-popup p {
  margin: 0 0 20px;
}

.confirm-btn, .cancel-btn {
  background-color: #ff5722;
  color: #fff;
  border: none;
  padding: 10px 20px;
  font-size: 16px;
  margin: 0 10px;
  border-radius: 4px;
  cursor: pointer;
  /* Centering the buttons */
  width: 100%; /* Make buttons the same width */
  box-sizing: border-box; /* Ensure padding is included in width */
}

/* Centering the buttons within the exit popup */
.exit-popup .confirm-btn,
.exit-popup .cancel-btn {
  margin-top: 10px; /* Adjust spacing if needed */
}

.confirm-btn, .cancel-btn {
  background-color: #ff5722;
  color: #fff;
  border: none;
  padding: 10px 20px;
  font-size: 16px;
  margin: 0 10px;
  border-radius: 4px;
  cursor: pointer;
}

  #round, #score {
  font-size: 20px;
  font-weight: bold;
  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.05);
}
  
  .info-button {
  position: absolute;
  bottom: 10px;
  left: 10px;
  width: 40px;
  height: 40px;
  background-color: #f72585;
  border: none;
  border-radius: 50%;
  color: #fff;
  font-size: 24px;
  cursor: pointer;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
  transition: transform 0.3s ease;

  display: flex;
  justify-content: center;
  align-items: center;
}

.info-button:hover {
  transform: scale(1.1);
}

.info-button .material-icons {
  font-size: 38px; /* Adjust the icon size */
}
  
  
.popup-content {
  text-align: left;
  padding: 20px;
  border-radius: var(--border-radius);
  background-color: var(--board-color); /* Assuming the board color is appropriate */
  color: #000;
}

.popup-content h2 {
  margin-top: 0;
  text-align: center;
}

.popup-content p {
  margin: 5px 0;
}

.button-container {
  display: flex;
  justify-content: center; /* Center the buttons */
  margin-top: 10px;
  gap: 10px; /* Add space between buttons */
}

.popup-content button {
  margin-top: 10px;
  padding: 8px 16px;
  font-size: 16px;
  font-weight: bold;
  background-color: var(--secondary-color);
  color: var(--text-color);
  border: none;
  border-radius: var(--border-radius);
  cursor: pointer;
  transition: all 0.3s ease;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

#game-board {
  display: grid;
  grid-template-columns: repeat(6, 1fr);
  grid-template-rows: repeat(6, 1fr);
  gap: 3px;
  margin-bottom: 10px;
  border: 2px solid var(--primary-color);
  padding: 5px;
  background-color: var(--board-color);
  border-radius: var(--border-radius);
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
}

#tile-container {
  display: flex;
  gap: 5px;
  margin-bottom: 10px;
  justify-content: center;
}

 .tile {
  width: 50px;
  height: 50px;
  background-color: var(--tile-color);
  border: 2px solid #000; /* Scrabble tiles have a black border */
  border-radius: 8px; /* Slightly rounded corners like real Scrabble tiles */
  display: flex;
  justify-content: center;
  align-items: center;
  font-size: 25px; /* Larger font size for better readability */
  font-weight: bold;
  cursor: pointer;
  box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.2); /* Subtle shadow for depth */
  transition: all 0.3s ease;
  color: #000; /* Text color is black for contrast */
  position: relative;
  overflow: hidden;
  background-image: linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent); /* Adds a subtle texture */
  background-size: 10px 10px; /* Size of the texture pattern */
}

.tile::before {
  content: '';
  position: absolute;
  top: -50%;
  left: -50%;
  width: 200%;
  height: 200%;
  background: radial-gradient(circle, rgba(255,255,255,0.3) 0%, rgba(255,255,255,0) 70%);
  transform: scale(0);
  transition: transform 0.3s ease-out;
}

.tile:hover::before {
  transform: scale(1);
}

.tile.dragging {
  opacity: 0.7;
  transform: scale(1.1);
}

@media (max-width: 768px) {
  button {
    padding: 12px 24px; /* Increase padding for bigger buttons */
    font-size: 18px; /* Increase font size for bigger buttons */
  }
}

  </style>
</head>
<body>
    
    
<div id="scoreboard">
  <div id="round">Round: 1</div>
  <div id="score">Score: 0</div>
</div>
<div id="game-board"></div>

  <div id="tile-container"></div>

  <div class="popup" id="roundPopup">
    <p id="roundPopupText"></p>
    <button onclick="closePopup()">OK</button>
  </div>
  
<!-- Info button using material icon -->
<button id="infoButton" class="info-button" onclick="toggleInstructionsPopup()">
  <span class="material-icons">info_outline</span>
</button>

  <!-- Exit Button -->
  <button id="exit-btn" class="exit-btn"><span class="material-icons">exit_to_app</span></button>

  <!-- Exit Confirmation Popup -->
  <div id="exit-popup" class="popup">
          <div class="popup-content">
    <h2>Would you like to exit?</h2>
    <p style="text-align: center">Your progress may not be saved.</p>
<div class="button-container">
  <button button id="confirm-exit-btn" class="confirm-btn">Confirm</button>
  <button id="cancel-exit-btn" class="cancel-btn">Cancel</button>
</div>
  </div>
    </div>
 
 
  <div class="popup" id="instructionsPopup">
    <div class="popup-content">
      <h2>How to Play</h2>
      <p>Here are the instructions on how to play the game:</p>
      <ul>
        <li>Instruction 1</li>
        <li>Instruction 2</li>
        <li>Instruction 3</li>
      </ul>
      <div class="button-container">
      <button onclick="closeInstructionsPopup()">Close</button>
    </div>
  </div>
      </div>

<div id="gameOverPopup" class="popup">
  <div class="popup-content">
    <h2>Game Over</h2>
    <p id="gameOverMessage"></p>
    <div class="button-container">
      <button onclick="playAgain()">Play Again</button>
      <button onclick="exitGame()">Exit</button>
    </div>
  </div>
</div>

  <script>
    const board = document.getElementById('game-board');
    const tileContainer = document.getElementById('tile-container');
    const scoreDisplay = document.getElementById('score');
    const roundDisplay = document.getElementById('round');
    const roundPopup = document.getElementById('roundPopup');
    const roundPopupText = document.getElementById('roundPopupText');
    const boardSize = 6;
    const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
    let draggingTile = null;
    let score = 0;
    let round = 1;
    let userTurn = true;
    let wordList = [];
    let placedLetters = {}; // Track placed letters for word checking

    // Load word list from JSON file
    fetch('words.json')
      .then(response => response.json())
      .then(data => {
        wordList = data.words;
      });

    // Example point values for letters
    const letterPoints = {
      'A': 1, 'B': 3, 'C': 3, 'D': 2, 'E': 1,
      'F': 4, 'G': 2, 'H': 4, 'I': 1, 'J': 8,
      'K': 5, 'L': 1, 'M': 3, 'N': 1, 'O': 1,
      'P': 3, 'Q': 10, 'R': 1, 'S': 1, 'T': 1,
      'U': 1, 'V': 4, 'W': 4, 'X': 8, 'Y': 4, 'Z': 10
    };

    // Special squares setup (manually assigned)
    const specialSquares = [
      { x: 1, y: 1, type: 'double-letter' },
      { x: 4, y: 1, type: 'triple-letter' },
      { x: 2, y: 3, type: 'double-word' },
      { x: 5, y: 4, type: 'triple-word' },
      { x: 0, y: 0, type: 'double-word' },
      { x: 3, y: 3, type: 'triple-letter' },
      { x: 3, y: 6, type: 'double-letter' },
      // Add more as needed
    ];

    // Function to create a square element
    function createSquare(x, y) {
      const square = document.createElement('div');
      square.className = 'square';
      square.dataset.x = x;
      square.dataset.y = y;

      // Check if this square is a special square
      const specialSquare = specialSquares.find(square => square.x === x && square.y === y);
      if (specialSquare) {
        square.classList.add(specialSquare.type);
      }

      square.addEventListener('dragover', (e) => {
        e.preventDefault();
      });

      square.addEventListener('drop', () => {
        if (draggingTile && !square.classList.contains('blocked') && square.textContent === '' && userTurn) {
          square.textContent = draggingTile.textContent;
          placedLetters[`${x},${y}`] = draggingTile.textContent;
          calculateScore(draggingTile.textContent, square);
          draggingTile.remove();
          draggingTile = null;
          userTurn = false;
          checkGameOver();
          initializeTiles();
          computerTurn();
        }
      });

      square.addEventListener('touchstart', (e) => {
        if (userTurn && !square.classList.contains('blocked') && square.textContent === '') {
          e.preventDefault();
          square.textContent = draggingTile.textContent;
          placedLetters[`${x},${y}`] = draggingTile.textContent;
          calculateScore(draggingTile.textContent, square);
          draggingTile.remove();
          draggingTile = null;
          userTurn = false;
          checkGameOver();
          initializeTiles();
          computerTurn();
        }
      });

      return square;
    }

    // Initialize the game board
    for (let y = 0; y < boardSize; y++) {
      for (let x = 0; x < boardSize; x++) {
        board.appendChild(createSquare(x, y));
      }
    }

    // Function to create a tile element
    function createTile(letter) {
      const tile = document.createElement('div');
      tile.className = 'tile';
      tile.draggable = true;
      tile.textContent = letter;

      tile.addEventListener('dragstart', () => {
        draggingTile = tile;
        tile.classList.add('dragging');
      });

      tile.addEventListener('dragend', () => {
        tile.classList.remove('dragging');
        draggingTile = null;
      });

      tile.addEventListener('touchstart', (e) => {
        e.preventDefault();
        draggingTile = tile;
        tile.classList.add('dragging');
      });

      tile.addEventListener('touchmove', (e) => {
        e.preventDefault();
        const touch = e.touches[0];
        const offsetX = touch.clientX - tile.offsetWidth / 2;
        const offsetY = touch.clientY - tile.offsetHeight / 2;
        tile.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
      });

      tile.addEventListener('touchend', () => {
        tile.classList.remove('dragging');
        draggingTile = null;

        // Find the square where the tile is dropped
        const rect = board.getBoundingClientRect();
        const touchX = event.changedTouches[0].clientX - rect.left;
        const touchY = event.changedTouches[0].clientY - rect.top;
        const squareSize = rect.width / boardSize;

        const x = Math.floor(touchX / squareSize);
        const y = Math.floor(touchY / squareSize);

        const square = board.querySelector(`.square[data-x="${x}"][data-y="${y}"]`);
        if (square && !square.classList.contains('blocked') && square.textContent === '' && userTurn) {
          square.textContent = tile.textContent;
          placedLetters[`${x},${y}`] = tile.textContent;
          calculateScore(tile.textContent, square);
          tile.remove();
          draggingTile = null;
          userTurn = false;
          checkGameOver();
          initializeTiles();
          computerTurn();
        } else {
          tile.style.transform = ''; // Reset tile position if not dropped on valid square
        }
      });

      return tile;
    }

    // Initialize tiles for the user
    function initializeTiles() {
      tileContainer.innerHTML = '';
      const letter = letters[Math.floor(Math.random() * letters.length)];
      tileContainer.appendChild(createTile(letter));
    }

    // Function to block a random square for the computer's turn
    function computerTurn() {
      const emptySquares = Array.from(board.children).filter(square => !square.classList.contains('blocked') && square.textContent === '');
      if (emptySquares.length > 0) {
        const randomSquare = emptySquares[Math.floor(Math.random() * emptySquares.length)];
        randomSquare.classList.add('blocked');
        userTurn = true;
      }
      checkGameOver();
    }
    
    function toggleInstructionsPopup() {
  const instructionsPopup = document.getElementById("instructionsPopup");
  instructionsPopup.style.display = instructionsPopup.style.display === "block" ? "none" : "block";
}

function closeInstructionsPopup() {
  const instructionsPopup = document.getElementById("instructionsPopup");
  instructionsPopup.style.display = "none";
}


    // Calculate score based on letter and square type
    function calculateScore(letter, square) {
      let points = letterPoints[letter];
      if (square.classList.contains('double-letter')) {
        points *= 2;
      } else if (square.classList.contains('triple-letter')) {
        points *= 3;
      } else if (square.classList.contains('double-word')) {
        points *= 2; // Assuming double points for the word, simplifying here
      } else if (square.classList.contains('triple-word')) {
        points *= 3; // Assuming triple points for the word, simplifying here
      }
      score += points;
      scoreDisplay.textContent = `Score: ${score}`;
    }

    // Check if the board is full
function checkGameOver() {
  const allSquares = Array.from(board.children);
  const isFull = allSquares.every(square => square.textContent !== '' || square.classList.contains('blocked'));
  if (isFull) {
    calculateFinalScore();
    if (score >= getRequiredPoints()) {
      showPopup();
    } else {
      showGameOverPopup();
    }
  }
}

function showGameOverPopup() {
  const gameOverPopup = document.getElementById('gameOverPopup');
  const gameOverMessage = document.getElementById('gameOverMessage');
  gameOverMessage.textContent = `Game Over! You scored ${score} points. You needed at least ${getRequiredPoints()} points to continue.`;
  gameOverPopup.style.display = 'block';
}

function playAgain() {
  document.getElementById('gameOverPopup').style.display = 'none';
  resetGame();
}

function exitGame() {
  // Check if current score is a high score
  let highScore = localStorage.getItem('highScore') || 0;
  if (score > highScore) {
    localStorage.setItem('highScore', score);
    alert(`Congratulations! New high score: ${score}`);
  }
  document.getElementById('gameOverPopup').style.display = 'none';
  // You might want to redirect to a different page or perform some other action here
}

    // Calculate the final score based on the words formed
    function calculateFinalScore() {
      const words = extractWords();
      let extraPoints = 0;
      words.forEach(word => {
        if (isValidWord(word)) {
          switch (word.length) {
            case 1: extraPoints += 0; break;
            case 2: extraPoints += 2; break;
            case 3: extraPoints += 3; break;
            case 4: extraPoints += 4; break;
            case 5: extraPoints += 10; break;
            case 6: extraPoints += 20; break;
          }
          word.split('').forEach((letter, index) => {
            const [x, y] = Object.keys(placedLetters).find(key => placedLetters[key] === letter).split(',').map(Number);
            const square = board.children[y * boardSize + x];
            if (square.classList.contains('double-word')) {
              extraPoints += letterPoints[letter];
            } else if (square.classList.contains('triple-word')) {
              extraPoints += letterPoints[letter] * 2;
            }
          });
        }
      });
      score += extraPoints;
      scoreDisplay.textContent = `Score: ${score}`;
    }

    // Extract all words formed on the board
    function extractWords() {
      const words = [];
      const visited = new Set();
      // Extract words horizontally
      for (let y = 0; y < boardSize; y++) {
        let word = '';
        for (let x = 0; x < boardSize; x++) {
          const square = board.children[y * boardSize + x];
          if (square.textContent && !visited.has(`${x},${y}`)) {
            word += square.textContent;
            visited.add(`${x},${y}`);
          } else {
            if (word) words.push(word);
            word = '';
            visited.clear();
          }
        }
        if (word) words.push(word);
      }
      visited.clear();
      // Extract words vertically
      for (let x = 0; x < boardSize; x++) {
        let word = '';
        for (let y = 0; y < boardSize; y++) {
          const square = board.children[y * boardSize + x];
          if (square.textContent && !visited.has(`${x},${y}`)) {
            word += square.textContent;
            visited.add(`${x},${y}`);
          } else {
            if (word) words.push(word);
            word = '';
            visited.clear();
          }
        }
        if (word) words.push(word);
      }
      return words.filter(word => word.length > 1);
    }

    // Check if a word is valid
    function isValidWord(word) {
      return wordList.includes(word.toLowerCase());
    }

    // Function to remove a random letter from the board
    function removeRandomLetter() {
      const emptySquares = Array.from(board.children).filter(square => square.textContent !== '');
      if (emptySquares.length > 0) {
        const randomSquare = emptySquares[Math.floor(Math.random() * emptySquares.length)];
        randomSquare.textContent = '';
      }
    }

    // Function to show round completion popup
    function showPopup() {
      roundPopup.style.display = 'block';
      roundPopupText.textContent = `Congratulations! You scored ${score} points in Round ${round}. You need to score at least ${getRequiredPoints()} points in the next round to continue.`;
      document.querySelector('#roundPopup button').onclick = () => {
        hidePopup();
        startNextRound();
      };
    }

    // Function to hide round completion popup
    function hidePopup() {
      roundPopup.style.display = 'none';
    }

    // Function to reset the game
function resetGame() {
  score = 0;
  round = 1;
  userTurn = true;
  placedLetters = {};
  scoreDisplay.textContent = `Score: ${score}`;
  roundDisplay.textContent = `Round: ${round}`;
  hidePopup();

  const allSquares = Array.from(board.children);
  allSquares.forEach(square => {
    square.textContent = '';
    square.classList.remove('blocked', 'word-highlight');
  });

  tileContainer.innerHTML = '';
  initializeTiles();

  // Update high score display
  let highScore = localStorage.getItem('highScore') || 0;
  document.getElementById('highScore').textContent = `High Score: ${highScore}`;
}

    // Function to get required points for the next round
    function getRequiredPoints() {
      return 100 + (round - 1) * 50;
    }

    // Add these functions near the end of the script

    function closePopup() {
      hidePopup();
      resetGame();
    }

    function startOver() {
      if (confirm("Are you sure you want to start over? This will reset your progress.")) {
        resetGame();
      }
    }

    // Modify the resetGame function to be more comprehensive
    function resetGame() {
      score = 0;
      round = 1;
      userTurn = true;
      placedLetters = {};
      scoreDisplay.textContent = `Score: ${score}`;
      roundDisplay.textContent = `Round: ${round}`;
      hidePopup();

      const allSquares = Array.from(board.children);
      allSquares.forEach(square => {
        square.textContent = '';
        square.classList.remove('blocked', 'word-highlight');
      });

      tileContainer.innerHTML = '';
      initializeTiles();
    }

    // Modify the showPopup function to use the "OK" button correctly
    function showPopup() {
      roundPopup.style.display = 'block';
      roundPopupText.textContent = `Congratulations! You scored ${score} points. You need to score at least ${getRequiredPoints()} points in the next round to continue.`;
      document.querySelector('#roundPopup button').onclick = () => {
        hidePopup();
        startNextRound();
      };
    }

    // Add a new function to start the next round
    function startNextRound() {
      round++;
      roundDisplay.textContent = `Round: ${round}`;
      resetBoardForNextRound();
      initializeTiles();
      userTurn = true;
    }

function openInstructionsPopup() {
  const instructionsPopup = document.getElementById("instructionsPopup");
  instructionsPopup.style.display = "block";
  instructionsPopup.innerHTML = `
    <div class="popup-content">
      <h2>How to Play</h2>
      <p>1. Drag and drop the letter tile onto the board.</p>
      <p>2. Form words horizontally or vertically.</p>
      <p>3. Score points based on letter values and special squares.</p>
      <p>4. Reach the required score to advance to the next round.</p>
      <p>5. The game ends when you can't reach the required score.</p>
      <div class="button-container">
        <button onclick="closeInstructionsPopup()">Close</button>
      </div>
    </div>
  `;
}

    function closeInstructionsPopup() {
      document.getElementById("instructionsPopup").style.display = "none";
    }

    // Add a new function to reset the board for the next round
    function resetBoardForNextRound() {
      const allSquares = Array.from(board.children);
      allSquares.forEach(square => {
        square.textContent = '';
        square.classList.remove('blocked', 'word-highlight');
      });
      placedLetters = {};

      // Reinitialize special squares
      specialSquares.forEach(specialSquare => {
        const square = board.children[specialSquare.y * boardSize + specialSquare.x];
        square.classList.add(specialSquare.type);
      });
    }

    // Initialize the game
    initializeTiles();
/*
    let menuVisible = false;

    function toggleMenu() {
      const gearIcon = document.querySelector('.gear-icon');
      const menuIcons = document.querySelectorAll('.menu-icon');
      menuVisible = !menuVisible;

      if (menuVisible) {
        gearIcon.classList.add('active');
        menuIcons.forEach((icon, index) => {
          icon.style.display = 'flex';
          setTimeout(() => {
            icon.style.opacity = '1';
            icon.style.transform = 'translateY(0)';
          }, (menuIcons.length - index - 1) * 100);
        });
      } else {
        gearIcon.classList.remove('active');
        menuIcons.forEach((icon, index) => {
          setTimeout(() => {
            icon.style.opacity = '0';
            icon.style.transform = 'translateY(20px)';
          }, index * 100);
          setTimeout(() => {
            icon.style.display = 'none';
          }, menuIcons.length * 100);
        });
      }
    }

    document.addEventListener('DOMContentLoaded', () => {
      const gearIcon = document.querySelector('.gear-icon');
      gearIcon.addEventListener('click', toggleMenu);

      const menuIcons = document.querySelectorAll('.menu-icon');
      menuIcons.forEach(icon => {
        icon.addEventListener('click', (e) => {
          e.stopPropagation();
          const iconClass = icon.classList[1];
          switch (iconClass) {
            case 'high-score':
              showHighScore();
              break;
            case 'info':
              showInfo();
              break;
            case 'start-over':
              startOver();
              break;
            case 'end-game':
              endGame();
              break;
          }
        });
      });
    });

    document.addEventListener('click', (e) => {
      if (menuVisible && !e.target.closest('.gear-icon') && !e.target.closest('.menu-icon')) {
        toggleMenu();
      }
    });
*/

document.addEventListener('DOMContentLoaded', function() {
  const infoBtn = document.getElementById('info-btn');
  const exitBtn = document.getElementById('exit-btn');
  const exitPopup = document.getElementById('exit-popup');
  const confirmExitBtn = document.getElementById('confirm-exit-btn');
  const cancelExitBtn = document.getElementById('cancel-exit-btn');

  // Show exit popup when exit button is clicked
  exitBtn.addEventListener('click', function() {
    exitPopup.style.display = 'block';
  });

  // Close exit popup and return to game when 'Return to Game' button is clicked
  cancelExitBtn.addEventListener('click', function() {
    exitPopup.style.display = 'none';
  });

  // Handle exit game when 'Exit' button is clicked
  confirmExitBtn.addEventListener('click', function() {
    // Here you can add code to exit the game, for example:
    // window.close(); // Close the window/tab
    console.log('Exiting the game...');
  });

  // Close exit popup if user clicks outside of it
  document.addEventListener('click', function(event) {
    if (event.target === exitPopup) {
      exitPopup.style.display = 'none';
    }
  });
});

function showHighScore() {
  // Implement high score functionality
  let highScore = localStorage.getItem('highScore') || 0;
  alert(`Your high score is: ${highScore}`);
}

function showInfo() {
  alert('Welcome to Scrabble-Bingo Hybrid Game!\n\nThis game combines elements of Scrabble and Bingo. Place letters on the board to form words and score points. Complete each round by reaching the required score.');
}

function startOver() {
  if (confirm("Are you sure you want to start over? This will reset your progress.")) {
    resetGame();
  }
}

function endGame() {
  if (confirm("Are you sure you want to end the game? Your score will be recorded if it's a high score.")) {
    // Check if current score is a high score
    let highScore = localStorage.getItem('highScore') || 0;
    if (score > highScore) {
      localStorage.setItem('highScore', score);
      alert(`Congratulations! New high score: ${score}`);
    }
    resetGame();
  }
}
  </script>
</body>
</html>
