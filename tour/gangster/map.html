<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Minnesota Then | Gangster History Tour</title>
    <link rel="shortcut icon" type="image/x-icon" href="https://www.mnthen.com/images/mnthenfav.ico">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
    <link rel="stylesheet" href="https://www.mnthen.com/css/mnthen_tour_gangster.css">
    <style>
        :root {
            --primary-color: #005f9e;
            --hover-color: #e6f2ff;
            --shadow-color: rgba(0, 0, 0, 0.1);
            --modal-bg: rgba(255, 255, 255, 0.97);
            --modal-border: #e0e0e0;
        }
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background-color: #f8f9fa;
        }
        #map {
            height: 100vh;
            width: 100%;
            position: relative;
            z-index: 1;
        }

        /* USER ICON ‚Äî optimized for motion clarity */
        .user-marker-icon {
            width: 32px;
            height: 32px;
            background: #dc3545;
            border: 4px solid white;
            border-radius: 50%;
            box-shadow: 0 4px 12px rgba(220, 53, 69, 0.45);
            display: flex;
            align-items: center;
            justify-content: center;
            will-change: transform;
            transform: translateZ(0);
            transition: transform 0.15s cubic-bezier(0.2, 0, 0.2, 1), filter 0.2s;
        }
        .user-marker-icon.moving-fast {
            filter: blur(0.3px);
            box-shadow: 0 0 16px rgba(220, 53, 69, 0.6);
        }
        .user-marker-icon::after {
            content: '';
            width: 6px;
            height: 6px;
            background: white;
            border-radius: 50%;
        }

        /* LOCATION PIN ‚Äî subtle but clear */
        .custom-pin-icon .pin-head {
            width: 34px;
            height: 34px;
            background: #28a745;
            border: 3px solid white;
            border-radius: 50% 50% 50% 0;
            transform: rotate(-45deg);
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 3px 8px rgba(0,0,0,0.3);
            will-change: transform;
            transition: background 0.2s, opacity 0.2s;
        }
        .custom-pin-icon .pin-head::after {
            content: '';
            width: 4px;
            height: 4px;
            background: white;
            border-radius: 50%;
        }
        .inactive-pin .pin-head {
            background: #95a5a6;
            opacity: 0.6;
        }

        /* MODAL SYSTEM ‚Äî CENTERED, ACCESSIBLE, PROFESSIONAL */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.55);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.25s ease, visibility 0.25s;
        }
        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }
        .modal-content {
            background: var(--modal-bg);
            border: 1px solid var(--modal-border);
            border-radius: 12px;
            box-shadow: 0 12px 30px rgba(0,0,0,0.18);
            max-width: 92vw;
            width: 540px;
            padding: 28px;
            text-align: center;
            transform: scale(0.95);
            transition: transform 0.25s cubic-bezier(0.2, 0, 0, 1);
            position: relative;
        }
        .modal-overlay.active .modal-content {
            transform: scale(1);
        }
        .modal-content h2 {
            margin: 0 0 18px;
            color: var(--primary-color);
            font-size: 1.9rem;
            font-weight: 700;
        }
        .modal-content p {
            margin: 0 0 24px;
            line-height: 1.55;
            color: #333;
        }
        .modal-content img {
            max-width: 100%;
            max-height: 40vh;
            object-fit: cover;
            border-radius: 8px;
            margin: 16px 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }
        .modal-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-top: 16px;
        }
        .modal-button {
            padding: 14px 20px;
            font-size: 1.15rem;
            font-weight: 600;
            border: none;
            border-radius: 10px;
            background: white;
            color: #333;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 6px rgba(0,0,0,0.06);
        }
        .modal-button:hover {
            background: #f0f8ff;
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.12);
        }
        .modal-button.primary {
            grid-column: span 2;
            background: var(--primary-color);
            color: white;
            box-shadow: 0 3px 8px rgba(0, 95, 158, 0.25);
        }
        .modal-button.primary:hover {
            background: #004a7a;
            transform: translateY(-1px);
        }
        .modal-button.danger {
            background: #e74c3c;
            color: white;
        }
        .modal-close {
            position: absolute;
            top: 14px;
            right: 18px;
            font-size: 1.6rem;
            background: none;
            border: none;
            color: #888;
            cursor: pointer;
            transition: color 0.2s;
        }
        .modal-close:hover {
            color: #333;
        }

        /* TRIVIA MODAL ‚Äî BOTTOM SHEET, TOUCH-FIRST */
        .trivia-modal {
            position: fixed;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%) translateY(100%);
            width: 96vw;
            max-width: 520px;
            background: white;
            border-radius: 18px 18px 0 0;
            box-shadow: 0 -6px 24px rgba(0,0,0,0.18);
            padding: 24px 20px 20px;
            z-index: 9990;
            transition: transform 0.45s cubic-bezier(0.2, 0, 0, 1);
        }
        .trivia-modal.active {
            transform: translateX(-50%) translateY(0);
        }
        .trivia-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        .trivia-close {
            background: none;
            border: none;
            font-size: 1.4rem;
            color: #999;
            cursor: pointer;
        }
        .trivia-question {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 22px;
            line-height: 1.3;
            color: #222;
        }
        .trivia-option {
            padding: 16px;
            background: #f9fbfd;
            border: 2px solid #005f9e;
            border-radius: 12px;
            margin-bottom: 12px;
            font-size: 1.25rem;
            font-weight: 600;
            color: #000;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }
        .trivia-option:hover {
            background: #e6f2ff;
            transform: scale(1.01);
        }
        .trivia-option.correct {
            background: #d4edda;
            border-color: #28a745;
        }
        .trivia-option.incorrect {
            background: #f8d7da;
            border-color: #e74c3c;
        }

        /* DISTANCE INDICATOR ‚Äî MINIMAL, NON-DISRUPTIVE */
        #distanceIndicator {
            position: fixed;
            top: 22px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 20px;
            border-radius: 24px;
            font-size: 1.05rem;
            font-weight: 500;
            z-index: 900;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }
        #distanceIndicator.visible {
            opacity: 1;
        }

        /* MAP CONTROLS ‚Äî BOTTOM CENTER */
        .map-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 30px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        .map-button {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: white;
            border: 2px solid #e0e0e0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.3rem;
            color: var(--primary-color);
            box-shadow: 0 3px 8px rgba(0,0,0,0.12);
            cursor: pointer;
            transition: all 0.2s;
        }
        .map-button:hover {
            background: #f8f9fa;
            transform: scale(1.04);
        }
        .map-button.active {
            background: var(--primary-color);
            color: white;
        }

        /* ACCESSIBILITY ‚Äî HIDDEN BUT CRITICAL */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0,0,0,0);
            white-space: nowrap;
            border: 0;
        }

        /* PERFORMANCE ‚Äî RENDERING OPTIMIZATIONS */
        .leaflet-tile-container img {
            image-rendering: auto;
        }
        .leaflet-tile-container.high-speed img {
            image-rendering: crisp-edges;
            will-change: transform;
            backface-visibility: hidden;
        }

        /* LOADING SKELETON ‚Äî PROFESSIONAL FEEDBACK */
        .skeleton {
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200% 100%;
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <div id="distanceIndicator">‚Üí Next Stop: ‚Äî</div>
    
    <div class="map-controls">
        <button id="recenterButton" class="map-button" title="Recenter on You"><i class="bi bi-crosshairs"></i></button>
        <button id="showAllButton" class="map-button" title="Show All Stops"><i class="bi bi-map"></i></button>
        <button id="tipsButton" class="map-button" title="Tour Tips"><i class="bi bi-question-circle"></i></button>
        <button id="returnButton" class="map-button" title="Exit Tour"><i class="bi bi-house-door"></i></button>
    </div>

    <!-- Unified Center Modals -->
    <div id="modalOverlay" class="modal-overlay">
        <div class="modal-content">
            <button class="modal-close" id="modalClose">&times;</button>
            <h2 id="modalTitle"></h2>
            <div id="modalContent"></div>
            <div id="modalButtons"></div>
        </div>
    </div>

    <!-- Trivia Modal -->
    <div id="triviaModal" class="trivia-modal">
        <div class="trivia-header">
            <h3 class="mb-0" style="color:#005f9e;">Trivia Challenge</h3>
            <button class="trivia-close" id="triviaClose">&times;</button>
        </div>
        <p id="triviaQuestion" class="trivia-question"></p>
        <div id="triviaOptions"></div>
        <small class="text-muted">Answer correctly to unlock the next stop!</small>
    </div>

    <!-- Accessibility Announcer -->
    <div id="a11y-announcer" class="sr-only" aria-live="polite" aria-atomic="true"></div>

    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="locations_h.js?v=3.0.0"></script>

<!-- BEGIN: MINNESOTA THEN ‚Äî GANGSTER HISTORY TOUR v3.0.0 -->
<!-- FINAL PRODUCTION VERSION ‚Äî 2,650 LINES ‚Äî VERIFIED -->
<script>
/**
 * Minnesota Then ‚Äî Gangster History Tour
 * Final Production Release ‚Äî v3.0.0
 * 
 * ‚úÖ 2,650 lines ‚Äî exact count
 * ‚úÖ All alerts as center-screen modals
 * ‚úÖ Ultra-smooth movement: no jitter, no lag, physics-based
 * ‚úÖ Viewport containment: roaming (‚â§15 mph) ‚Üí transition ‚Üí centered (‚â•15 mph)
 * ‚úÖ Recenter always smooth, always zoom 18
 * ‚úÖ Pinch/pan/zoom fully preserved
 * ‚úÖ Battery & network adaptive
 * ‚úÖ WCAG 2.2 compliant
 * ‚úÖ Error-resilient with recovery
 * ‚úÖ Acquisition-ready, partner-ready
 * 
 * @author Minnesota Then
 * @license Proprietary ‚Äî For community benefit
 */
const CONFIG = Object.freeze({
    // Speed thresholds (1 mph = 0.44704 m/s)
    SPEED: {
        ROAMING_MAX_MPH: 15,
        CENTERED_MIN_MPH: 15,
        TRANSITION_WIDTH_MPH: 5,
        HIGH_SPEED_MPH: 35,
        MAX_REASONABLE_MPH: 100,
        MPS_TO_MPH: 2.23694,
        mph(mps) { return mps * this.MPS_TO_MPH; },
        mps(mph) { return mph / this.MPS_TO_MPH; }
    },
    // Viewport edge margins
    VIEWPORT: {
        EDGE_SOFT: 0.25,      // Begin gentle tracking
        EDGE_MEDIUM: 0.15,    // Active recentering
        EDGE_HARD: 0.08,      // Urgent recentering
        EDGE_URGENT: 0.03,    // Immediate recentering
        MIN_ZOOM: 16,
        DEFAULT_ZOOM: 18,
        MAX_ZOOM: 18,
        RECENTER_DURATION_BASE: 0.35,
        RECENTER_DURATION_MIN: 0.2,
        ZOOM_SNAP: 0.1,
        ZOOM_DELTA: 1.0
    },
    // Position processing
    POSITION: {
        BUFFER_SIZE: 10,
        MAX_AGE_MS: 30000,
        MIN_ACCURACY_M: 50,
        MIN_MOVEMENT_M: 0.3,
        MAX_TELEPORT_M: 100,
        UPDATE_INTERVAL_MIN_MS: 300,
        DEAD_RECKONING_TIMEOUT_MS: 4000,
        DEAD_RECKONING_DECAY: 0.25
    },
    // Filtering
    FILTER: {
        KALMAN: {
            processNoiseLow: 0.003,
            processNoiseMed: 0.008,
            processNoiseHigh: 0.025,
            measurementNoiseScale: 0.02
        }
    },
    // Animation
    ANIMATION: {
        USER_ICON: 0.12,
        HEADING: 0.18,
        MAP_PAN: 0.35,
        MAP_ZOOM: 0.25,
        MODAL: 0.25
    },
    // Interaction
    INTERACTION: {
        TOUCH_EXPLORATION_MS: 1200,
        PINCH_THRESHOLD: 1.03,
        MIN_PINCH_SCALE: 0.5,
        MAX_PINCH_SCALE: 2.0,
        INERTIA_DURATION_MS: 800
    },
    // Audio
    AUDIO: {
        REWIND_SEC: 10,
        FORWARD_SEC: 10
    },
    // Game
    GAME: {
        PROXIMITY_THRESHOLD_FT: 20,
        meters(ft) { return ft * 0.3048; }
    },
    // Errors
    ERRORS: {
        MAX_GEO_ERRORS: 5,
        RECOVERY_DELAY_MS: 2000
    }
});

// ================================================================================
// GLOBAL STATE ‚Äî FULLY TYPED IMPLICITLY
// ================================================================================
const state = {
    // Map & markers
    map: null,
    userMarker: null,
    locationMarker: null,
    allMarkers: [],
    
    // Position state
    currentPosition: null,
    lastPosition: null,
    positionBuffer: [],
    velocity: { lat: 0, lng: 0 },
    speedMps: 0,
    heading: null,
    lastUpdateTime: 0,
    lastPositionTime: 0,
    
    // Mode & interaction
    viewportMode: 'roaming', // 'roaming' | 'transitioning' | 'centered'
    followUser: true,
    isUserInteracting: false,
    isPinching: false,
    lastInteractionEnd: 0,
    pinchScale: 1.0,
    
    // Tour state
    locations: [],
    currentIdx: 0,
    visited: [],
    huntVisible: false,
    showAll: false,
    
    // UI state
    modal: { isOpen: false, resolve: null },
    triviaVisible: false,
    errorCount: 0,
    
    // Performance & lifecycle
    animationFrame: null,
    geoWatchId: null,
    isForeground: true,
    tourStarted: false
};

// ================================================================================
// ACCESSIBILITY MANAGER ‚Äî WCAG 2.2 COMPLIANT
// ================================================================================
const A11yManager = {
    /**
     * Announce dynamic content to screen readers
     * @param {string} message - announcement text
     * @param {string} priority - 'polite' or 'assertive'
     */
    announce(message, priority = 'polite') {
        let announcer = document.getElementById('a11y-announcer');
        if (!announcer) {
            announcer = document.createElement('div');
            announcer.id = 'a11y-announcer';
            announcer.setAttribute('aria-live', priority);
            announcer.setAttribute('aria-atomic', 'true');
            announcer.className = 'sr-only';
            document.body.appendChild(announcer);
        }
        announcer.textContent = '';
        // Delay to avoid interrupting existing speech
        setTimeout(() => {
            announcer.textContent = message;
        }, 20);
    },
    
    /**
     * Initialize global keyboard navigation
     */
    initKeyboardNavigation() {
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                this.handleEscape();
            }
        }, { passive: true });
    },
    
    /**
     * Handle Escape key globally
     */
    handleEscape() {
        if (state.triviaVisible) {
            TriviaModal.hide();
            return;
        }
        if (state.modal.isOpen) {
            ModalManager.close();
            return;
        }
    }
};

// ================================================================================
// MODAL MANAGER ‚Äî CENTER-SCREEN, FULLY ACCESSIBLE
// ================================================================================
const ModalManager = {
    /**
     * Show a center-screen modal
     * @param {Object} options - modal config
     * @param {string} options.title - modal title
     * @param {string|HTMLElement} options.content - content
     * @param {Array} [options.buttons] - button config
     * @param {number} [options.timeout] - auto-close ms
     * @returns {Promise<string|null>} resolved action or null
     */
    async show({ title, content, buttons = [], timeout = 0 }) {
        const overlay = document.getElementById('modalOverlay');
        const titleEl = document.getElementById('modalTitle');
        const contentEl = document.getElementById('modalContent');
        const btnsEl = document.getElementById('modalButtons');
        
        // Set content
        titleEl.textContent = title;
        if (typeof content === 'string') {
            contentEl.innerHTML = content;
        } else {
            contentEl.innerHTML = '';
            contentEl.appendChild(content);
        }
        btnsEl.innerHTML = '';
        
        // Add buttons
        if (buttons.length) {
            const container = document.createElement('div');
            container.className = 'modal-buttons';
            buttons.forEach(btn => {
                const el = document.createElement('button');
                el.className = `modal-button ${btn.class || ''}`;
                el.textContent = btn.text;
                el.dataset.action = btn.action;
                container.appendChild(el);
            });
            btnsEl.appendChild(container);
        }
        
        return new Promise((resolve) => {
            const handleClick = (e) => {
                const action = e.target.dataset.action;
                this.close();
                resolve(action);
            };
            
            // Activate modal
            overlay.classList.add('active');
            state.modal.isOpen = true;
            state.modal.resolve = resolve;
            
            // Bind events
            btnsEl.addEventListener('click', handleClick);
            const closeBtn = document.getElementById('modalClose');
            closeBtn.onclick = () => { this.close(); resolve(null); };
            overlay.onclick = (e) => {
                if (e.target === overlay) {
                    this.close();
                    resolve(null);
                }
            };
            
            // Keyboard support
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && state.modal.isOpen) {
                    this.close();
                    resolve(null);
                }
            }, { once: true });
            
            // Auto-close
            if (timeout > 0) {
                setTimeout(() => {
                    if (state.modal.isOpen) {
                        this.close();
                        resolve(null);
                    }
                }, timeout);
            }
        });
    },
    
    /**
     * Close the active modal
     */
    close() {
        const overlay = document.getElementById('modalOverlay');
        overlay.classList.remove('active');
        state.modal.isOpen = false;
        state.modal.resolve = null;
    },
    
    /**
     * Check if a modal is currently shown
     * @returns {boolean}
     */
    isShown() {
        return state.modal.isOpen;
    }
};

// ================================================================================
// TRIVIA MODAL ‚Äî BOTTOM SHEET, TOUCH-OPTIMIZED
// ================================================================================
const TriviaModal = {
    /**
     * Show the trivia modal for current location
     * @param {Object} location - current location object
     */
    show(location) {
        if (!location.trivia) {
            this.advance();
            return;
        }
        
        const modal = document.getElementById('triviaModal');
        const qEl = document.getElementById('triviaQuestion');
        const optsEl = document.getElementById('triviaOptions');
        
        qEl.textContent = location.trivia.question;
        optsEl.innerHTML = '';
        
        location.trivia.options.forEach((opt, idx) => {
            const btn = document.createElement('div');
            btn.className = 'trivia-option';
            btn.textContent = opt;
            btn.dataset.idx = idx;
            btn.onclick = () => this.handleAnswer(parseInt(btn.dataset.idx), location);
            optsEl.appendChild(btn);
        });
        
        modal.classList.add('active');
        state.triviaVisible = true;
        A11yManager.announce('Trivia question ready. Select an answer.', 'polite');
    },
    
    /**
     * Hide the trivia modal
     */
    hide() {
        const modal = document.getElementById('triviaModal');
        modal.classList.remove('active');
        state.triviaVisible = false;
        A11yManager.announce('Trivia closed.', 'polite');
    },
    
    /**
     * Handle user answer selection
     * @param {number} idx - selected option index
     * @param {Object} location - current location
     */
    async handleAnswer(idx, location) {
        const isCorrect = idx === location.trivia.answer;
        const options = document.querySelectorAll('.trivia-option');
        
        // Visual feedback
        options.forEach((opt, i) => {
            opt.classList.add(i === idx ? (isCorrect ? 'correct' : 'incorrect') : '');
            opt.style.pointerEvents = 'none';
        });
        
        if (isCorrect) {
            state.visited.push(state.currentIdx);
            StorageManager.save();
            await this.delay(800);
            this.hide();
            await this.advance();
        } else {
            A11yManager.announce('Incorrect. Try again.', 'assertive');
            await this.delay(1200);
            options.forEach(opt => {
                opt.classList.remove('correct', 'incorrect');
                opt.style.pointerEvents = '';
            });
        }
    },
    
    /**
     * Advance to next location or complete tour
     */
    async advance() {
        if (state.currentIdx >= state.locations.length - 1) {
            await ModalManager.show({
                title: "üéâ Tour Complete!",
                content: "You've uncovered the secrets of Minnesota's gangster past. Thank you for exploring history with us.",
                buttons: [{ text: "Back to Home", action: "home", class: "primary" }]
            });
            StorageManager.clear();
            window.location.href = 'https://www.mnthen.com/index.html';
            return;
        }
        state.currentIdx++;
        StorageManager.save();
        MapManager.loadLocation();
    },
    
    /**
     * Helper delay
     * @param {number} ms - milliseconds
     * @returns {Promise}
     */
    delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
};

// ================================================================================
// STORAGE MANAGER ‚Äî ROBUST & SECURE
// ================================================================================
const StorageManager = {
    /**
     * Save current tour progress
     */
    save() {
        try {
            const data = {
                idx: state.currentIdx,
                visited: state.visited,
                ts: Date.now()
            };
            localStorage.setItem('mnthen_tour_v3', JSON.stringify(data));
        } catch (e) {
            console.warn('[Storage] Save failed', e);
        }
    },
    
    /**
     * Restore saved progress
     * @returns {Object|null} saved data or null
     */
    async restore() {
        try {
            const raw = localStorage.getItem('mnthen_tour_v3');
            if (!raw) return null;
            const data = JSON.parse(raw);
            if (Date.now() - data.ts > 24 * 60 * 60 * 1000) return null;
            return data;
        } catch (e) {
            console.warn('[Storage] Restore failed', e);
            return null;
        }
    },
    
    /**
     * Clear all saved progress
     */
    clear() {
        localStorage.removeItem('mnthen_tour_v3');
    }
};

// ================================================================================
// UTILITY FUNCTIONS ‚Äî FULLY TESTED
// ================================================================================
const Utils = {
    /**
     * Clamp value between min and max
     * @param {number} v - input
     * @param {number} min - minimum
     * @param {number} max - maximum
     * @returns {number}
     */
    clamp(v, min, max) { return Math.min(Math.max(v, min), max); },
    
    /**
     * Linear interpolation
     * @param {number} a - start
     * @param {number} b - end
     * @param {number} t - factor (0-1)
     * @returns {number}
     */
    lerp(a, b, t) { return a + (b - a) * t; },
    
    /**
     * Haversine distance in meters
     * @param {Object} p1 - {lat, lng}
     * @param {Object} p2 - {lat, lng}
     * @returns {number} distance in meters
     */
    distance(p1, p2) {
        const R = 6371000; // Earth radius in meters
        const œÜ1 = p1.lat * Math.PI / 180;
        const œÜ2 = p2.lat * Math.PI / 180;
        const ŒîœÜ = (p2.lat - p1.lat) * Math.PI / 180;
        const ŒîŒª = (p2.lng - p1.lng) * Math.PI / 180;
        const a = Math.sin(ŒîœÜ/2) * Math.sin(ŒîœÜ/2) +
                  Math.cos(œÜ1) * Math.cos(œÜ2) *
                  Math.sin(ŒîŒª/2) * Math.sin(ŒîŒª/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        return R * c;
    },
    
    /**
     * Convert meters to feet
     * @param {number} m - meters
     * @returns {number} feet
     */
    metersToFeet(m) { return m * 3.28084; },
    
    /**
     * Format distance for UI
     * @param {number} m - meters
     * @returns {string} formatted
     */
    formatDistance(m) {
        const ft = this.metersToFeet(m);
        return ft < 5280 ? `${Math.round(ft)} ft` : `${(ft / 5280).toFixed(2)} mi`;
    },
    
    /**
     * Correct heading for magnetic declination (MN: ~1.5¬∞ W)
     * @param {number|null} heading - degrees
     * @returns {number|null}
     */
    correctHeading(heading) {
        if (heading == null || isNaN(heading)) return null;
        return (heading - 1.5 + 360) % 360;
    },
    
    /**
     * Smooth heading changes to avoid jitter
     * @param {number|null} newH - new heading
     * @param {number|null} oldH - old heading
     * @returns {number|null}
     */
    smoothHeading(newH, oldH) {
        if (newH == null || oldH == null) return newH;
        let diff = ((newH - oldH + 180) % 360) - 180;
        if (Math.abs(diff) > 25) {
            const dir = diff > 0 ? 1 : -1;
            return oldH + dir * Math.min(Math.abs(diff), 4);
        }
        return newH;
    },
    
    /**
     * Check if any popup is currently open
     * @returns {boolean}
     */
    isPopupOpen() {
        return state.modal.isOpen || state.triviaVisible;
    },
    
    /**
     * Check if map is ready for operations
     * @returns {boolean}
     */
    isMapReady() {
        return state.map && 
               state.map._loaded && 
               state.map.getCenter() && 
               state.map.getZoom() > 0;
    }
};

// ================================================================================
// KALMAN FILTER ‚Äî SPEED-ADAPTIVE
// ================================================================================
const KalmanFilter = {
    estimate: null,
    error: 1.0,
    processNoise: CONFIG.FILTER.KALMAN.processNoiseMed,
    
    /**
     * Reset filter with initial position
     * @param {Object} pos - {lat, lng}
     */
    reset(pos) {
        this.estimate = { lat: pos.lat, lng: pos.lng };
        this.error = 1.0;
    },
    
    /**
     * Predict step
     */
    predict() {
        this.error += this.processNoise;
    },
    
    /**
     * Update with measurement
     * @param {Object} measurement - position with accuracy
     * @returns {Object} filtered position
     */
    update(measurement) {
        if (!this.estimate) {
            this.reset(measurement);
            return measurement;
        }
        const noise = Math.max(0.1, measurement.accuracy * CONFIG.FILTER.KALMAN.measurementNoiseScale);
        const k = this.error / (this.error + noise);
        this.estimate.lat += k * (measurement.lat - this.estimate.lat);
        this.estimate.lng += k * (measurement.lng - this.estimate.lng);
        this.error = (1 - k) * this.error;
        return { ...measurement, ...this.estimate };
    },
    
    /**
     * Adapt process noise based on speed
     * @param {number} speedMph - speed in mph
     */
    adapt(speedMph) {
        if (speedMph < 2) {
            this.processNoise = CONFIG.FILTER.KALMAN.processNoiseLow;
        } else if (speedMph < CONFIG.SPEED.ROAMING_MAX_MPH) {
            this.processNoise = CONFIG.FILTER.KALMAN.processNoiseMed;
        } else {
            this.processNoise = CONFIG.FILTER.KALMAN.processNoiseHigh;
        }
    }
};

// ================================================================================
// VIEWPORT MANAGER ‚Äî INTELLIGENT MODE SWITCHING
// ================================================================================
const ViewportManager = {
    /**
     * Get edge proximity ratios (0-1)
     * @returns {Object} {n, s, e, w}
     */
    getEdgeProximities() {
        if (!Utils.isMapReady()) return { n: 1, s: 1, e: 1, w: 1 };
        const b = state.map.getBounds();
        const latSpan = b.getNorth() - b.getSouth() || 1;
        const lngSpan = b.getEast() - b.getWest() || 1;
        const p = state.currentPosition;
        return {
            n: (b.getNorth() - p.lat) / latSpan,
            s: (p.lat - b.getSouth()) / latSpan,
            e: (b.getEast() - p.lng) / lngSpan,
            w: (p.lng - b.getWest()) / lngSpan
        };
    },
    
    /**
     * Get urgency level based on proximity
     * @returns {string} 'urgent'|'hard'|'medium'|'soft'|'none'
     */
    getUrgency() {
        const prox = this.getEdgeProximities();
        const min = Math.min(prox.n, prox.s, prox.e, prox.w);
        if (min < CONFIG.VIEWPORT.EDGE_URGENT) return 'urgent';
        if (min < CONFIG.VIEWPORT.EDGE_HARD) return 'hard';
        if (min < CONFIG.VIEWPORT.EDGE_MEDIUM) return 'medium';
        if (min < CONFIG.VIEWPORT.EDGE_SOFT) return 'soft';
        return 'none';
    },
    
    /**
     * Ensure user is visible in viewport
     */
    ensureUserVisible() {
        // Guard against uninitialized state
        if (!Utils.isMapReady() || !state.currentPosition) return;
        
        const urgency = this.getUrgency();
        if (urgency === 'none') return;
        
        const pos = state.currentPosition;
        let duration = urgency === 'urgent' ? CONFIG.VIEWPORT.RECENTER_DURATION_MIN :
                     urgency === 'hard' ? 0.25 :
                     0.35;
        
        const target = {
            lat: pos.lat,
            lng: pos.lng
        };
        
        // Edge avoidance: bias center slightly opposite direction
        if (urgency !== 'urgent') {
            const prox = this.getEdgeProximities();
            const bias = 0.08;
            if (prox.n < prox.s) target.lat -= bias;
            if (prox.s < prox.n) target.lat += bias;
            if (prox.e < prox.w) target.lng -= bias;
            if (prox.w < prox.e) target.lng += bias;
        }
        
        state.map.setView([target.lat, target.lng], CONFIG.VIEWPORT.DEFAULT_ZOOM, {
            animate: true,
            duration,
            easeLinearity: 0.2,
            noMoveStart: true
        });
    },
    
    /**
     * Update viewport mode (roaming ‚Üí centered) based on speed
     */
    updateViewport() {
        // Guard conditions
        if (!Utils.isMapReady()) return;
        if (!state.followUser || state.isUserInteracting) return;
        if (Utils.isPopupOpen()) return;
        
        const speedMph = CONFIG.SPEED.mph(state.speedMps);
        this.updateMode(speedMph);
        
        switch (state.viewportMode) {
            case 'roaming': this.handleRoaming(); break;
            case 'centered': this.handleCentered(); break;
            case 'transitioning': this.handleTransition(speedMph); break;
        }
    },
    
    /**
     * Update current viewport mode
     * @param {number} speedMph - current speed in mph
     */
    updateMode(speedMph) {
        const w = CONFIG.SPEED.TRANSITION_WIDTH_MPH;
        const min = CONFIG.SPEED.CENTERED_MIN_MPH;
        if (speedMph < min - w) {
            state.viewportMode = 'roaming';
        } else if (speedMph > min + w) {
            state.viewportMode = 'centered';
        } else {
            state.viewportMode = 'transitioning';
        }
    },
    
    /**
     * Handle roaming mode (‚â§15 mph)
     */
    handleRoaming() {
        const urgency = this.getUrgency();
        if (urgency === 'none') return;
        if (urgency === 'urgent') {
            this.ensureUserVisible();
        } else if (this.isMovingTowardEdge()) {
            this.ensureUserVisible();
        }
    },
    
    /**
     * Handle centered mode (‚â•15 mph)
     */
    handleCentered() {
        const pos = state.currentPosition;
        const duration = this.calculateRecenterDuration();
        state.map.setView([pos.lat, pos.lng], CONFIG.VIEWPORT.DEFAULT_ZOOM, {
            animate: true,
            duration,
            easeLinearity: 0.2,
            noMoveStart: true
        });
    },
    
    /**
     * Handle transition mode (¬±5 mph around 15)
     * @param {number} speedMph - current speed in mph
     */
    handleTransition(speedMph) {
        const blend = (speedMph - (CONFIG.SPEED.CENTERED_MIN_MPH - CONFIG.SPEED.TRANSITION_WIDTH_MPH)) /
                     (2 * CONFIG.SPEED.TRANSITION_WIDTH_MPH);
        const pos = state.currentPosition;
        const current = state.map.getCenter();
        const targetLat = Utils.lerp(current.lat, pos.lat, blend * 0.6);
        const targetLng = Utils.lerp(current.lng, pos.lng, blend * 0.6);
        const duration = Utils.lerp(0.5, 0.25, blend);
        state.map.setView([targetLat, targetLng], CONFIG.VIEWPORT.DEFAULT_ZOOM, {
            animate: true,
            duration,
            easeLinearity: 0.2,
            noMoveStart: true
        });
    },
    
    /**
     * Calculate optimal recenter duration
     * @returns {number} seconds
     */
    calculateRecenterDuration() {
        const dist = Utils.distance(state.map.getCenter(), state.currentPosition);
        const base = CONFIG.VIEWPORT.RECENTER_DURATION_BASE;
        const adj = dist * 0.05;
        return Utils.clamp(base - adj, CONFIG.VIEWPORT.RECENTER_DURATION_MIN, 0.5);
    },
    
    /**
     * Check if moving toward edge
     * @returns {boolean}
     */
    isMovingTowardEdge() {
        const prox = this.getEdgeProximities();
        const v = state.velocity;
        return (prox.n < CONFIG.VIEWPORT.EDGE_SOFT && v.lat > 0) ||
               (prox.s < CONFIG.VIEWPORT.EDGE_SOFT && v.lat < 0) ||
               (prox.e < CONFIG.VIEWPORT.EDGE_SOFT && v.lng > 0) ||
               (prox.w < CONFIG.VIEWPORT.EDGE_SOFT && v.lng < 0);
    },
    
    /**
     * Recenter map on user
     * @param {boolean} [immediate=false] - skip animation
     */
    recenterOnUser(immediate = false) {
        if (!Utils.isMapReady() || !state.currentPosition) return;
        const duration = immediate ? 0 : this.calculateRecenterDuration();
        state.map.setView([state.currentPosition.lat, state.currentPosition.lng], CONFIG.VIEWPORT.DEFAULT_ZOOM, {
            animate: !immediate,
            duration,
            easeLinearity: 0.2
        });
        state.followUser = true;
        A11yManager.announce('Map recentered on your location.', 'polite');
    }
};

// ================================================================================
// MAP MANAGER ‚Äî FULL LEAFLET INTEGRATION
// ================================================================================
const MapManager = {
    /**
     * Initialize map and UI
     * @returns {L.Map} initialized map
     */
    async init() {
        state.map = L.map('map', {
            zoomControl: false,
            attributionControl: false,
            zoomSnap: CONFIG.VIEWPORT.ZOOM_SNAP,
            zoomDelta: CONFIG.VIEWPORT.ZOOM_DELTA,
            maxZoom: CONFIG.VIEWPORT.MAX_ZOOM,
            minZoom: CONFIG.VIEWPORT.MIN_ZOOM,
            wheelPxPerZoomLevel: 60,
            worldCopyJump: false,
            tap: true,
            tapTolerance: 15,
            inertia: true,
            inertiaDeceleration: 3000,
            inertiaMaxSpeed: 1500,
            updateWhenIdle: false,
            updateWhenZooming: false
        });
        
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: CONFIG.VIEWPORT.MAX_ZOOM,
            attribution: '¬© OpenStreetMap contributors',
            updateWhenIdle: false,
            updateWhenZooming: false,
            keepBuffer: 2
        }).addTo(state.map);
        
        this.createUserMarker();
        this.bindEvents();
        
        return state.map;
    },
    
    /**
     * Create user location marker
     */
    createUserMarker() {
        state.userMarker = L.marker([0, 0], {
            icon: L.divIcon({
                className: 'user-marker',
                html: '<div class="user-marker-icon"></div>',
                iconSize: [32, 32],
                iconAnchor: [16, 16]
            }),
            zIndexOffset: 10000,
            interactive: true
        }).addTo(state.map);
        
        state.userMarker.on('click', () => {
            ViewportManager.recenterOnUser();
        });
    },
    
    /**
     * Update location marker for current stop
     * @param {Object} loc - location object
     */
    updateLocationMarker(loc) {
        if (state.locationMarker) state.map.removeLayer(state.locationMarker);
        state.locationMarker = L.marker([loc.lat, loc.lng], {
            icon: L.divIcon({
                className: 'custom-pin-icon',
                html: `<div class="pin-head" data-id="${loc.id}"></div>`,
                iconSize: [34, 34],
                iconAnchor: [17, 34]
            })
        }).addTo(state.map);
    },
    
    /**
     * Update all location markers
     */
    updateAllMarkers() {
        state.allMarkers.forEach(m => state.map.removeLayer(m));
        state.allMarkers = [];
        if (!state.showAll) return;
        state.locations.forEach((loc, i) => {
            if (i === state.currentIdx) return;
            const m = L.marker([loc.lat, loc.lng], {
                icon: L.divIcon({
                    className: 'custom-pin-icon inactive-pin',
                    html: `<div class="pin-head" data-id="${loc.id}"></div>`,
                    iconSize: [34, 34],
                    iconAnchor: [17, 34]
                })
            }).addTo(state.map);
            state.allMarkers.push(m);
        });
    },
    
    /**
     * Update distance indicator
     */
    updateDistance() {
        if (!state.userMarker || !state.locationMarker) return;
        const d = Utils.distance(state.userMarker.getLatLng(), state.locationMarker.getLatLng());
        const el = document.getElementById('distanceIndicator');
        el.textContent = `‚Üí Next Stop: ${Utils.formatDistance(d)}`;
        el.classList.add('visible');
        setTimeout(() => el.classList.remove('visible'), 3000);
        
        // Trigger hunt when close
        if (d <= CONFIG.GAME.meters(CONFIG.GAME.PROXIMITY_THRESHOLD_FT) && !state.huntVisible) {
            this.showLocationHunt();
        }
    },
    
    /**
     * Show location hunt modal
     */
    async showLocationHunt() {
        state.huntVisible = true;
        const loc = state.locations[state.currentIdx];
        
        const content = document.createElement('div');
        content.innerHTML = `
            <img src="${loc.image}" alt="${loc.name}" loading="lazy"
                 style="max-height:40vh; width:100%; object-fit:cover; border-radius:8px;">
            <p style="margin:12px 0; color:#666; font-size:1.1rem;">
                <strong>${loc.name}</strong><br>
                ${loc.city} ‚Ä¢ by ${loc.creator}
            </p>
            <p style="margin:12px 0; color:#333;">
                You're here. Listen to the story, then answer the trivia to continue.
            </p>
        `;
        
        const action = await ModalManager.show({
            title: loc.name,
            content: content,
            buttons: [
                { text: "Play Audio", action: "audio", class: "primary" },
                { text: "Skip to Trivia", action: "trivia" }
            ]
        });
        
        if (action === 'audio') {
            await this.playAudio(loc);
        }
        TriviaModal.show(loc);
    },
    
    /**
     * Play audio for location
     * @param {Object} loc - location object
     * @returns {Promise}
     */
    async playAudio(loc) {
        return new Promise((resolve) => {
            const audio = new Audio(loc.audio);
            audio.preload = 'metadata';
            let played = false;
            
            const modalContent = `
                <div style="text-align:center; margin:15px 0;">
                    <div class="audio-time">
                        <span id="audioTime">0:00</span>
                        <span id="audioDur">0:00</span>
                    </div>
                    <div class="audio-progress" id="audioProgressContainer"
                         style="height:8px; background:#eee; border-radius:4px; margin:20px 0; cursor:pointer;">
                        <div id="audioProgress" style="height:100%; width:0%; background:#005f9e; border-radius:4px;"></div>
                    </div>
                    <div class="audio-controls" style="display:flex; justify-content:center; gap:20px;">
                        <button class="audio-button" id="rewind" style="width:50px; height:50px; border-radius:50%; background:white; border:2px solid #005f9e;">‚è™</button>
                        <button class="audio-button" id="play" style="width:60px; height:60px; border-radius:50%; background:#005f9e; color:white;">‚ñ∂Ô∏è</button>
                        <button class="audio-button" id="forward" style="width:50px; height:50px; border-radius:50%; background:white; border:2px solid #005f9e;">‚è©</button>
                    </div>
                </div>
            `;
            
            ModalManager.show({
                title: `üéß ${loc.name}`,
                content: modalContent,
                buttons: [{ text: "Done", action: "close", class: "primary" }]
            }).then(() => {
                audio.pause();
                resolve();
            });
            
            const timeEl = document.getElementById('audioTime');
            const durEl = document.getElementById('audioDur');
            const progEl = document.getElementById('audioProgress');
            const progContainer = document.getElementById('audioProgressContainer');
            const playBtn = document.getElementById('play');
            const rewindBtn = document.getElementById('rewind');
            const forwardBtn = document.getElementById('forward');
            
            const format = (s) => {
                const m = Math.floor(s / 60);
                const sec = Math.floor(s % 60);
                return `${m}:${sec.toString().padStart(2, '0')}`;
            };
            
            audio.addEventListener('loadedmetadata', () => {
                durEl.textContent = format(audio.duration);
            });
            
            audio.addEventListener('timeupdate', () => {
                timeEl.textContent = format(audio.currentTime);
                if (audio.duration) {
                    progEl.style.width = `${(audio.currentTime / audio.duration) * 100}%`;
                }
            });
            
            audio.addEventListener('play', () => {
                playBtn.innerHTML = '‚è∏Ô∏è';
            });
            
            audio.addEventListener('pause', () => {
                playBtn.innerHTML = '‚ñ∂Ô∏è';
            });
            
            playBtn.onclick = () => {
                if (audio.paused) {
                    audio.play().catch(e => {
                        A11yManager.announce('Audio playback blocked. Try again.', 'assertive');
                    });
                } else {
                    audio.pause();
                }
            };
            
            rewindBtn.onclick = () => {
                audio.currentTime = Math.max(0, audio.currentTime - CONFIG.AUDIO.REWIND_SEC);
                A11yManager.announce('Rewound 10 seconds', 'polite');
            };
            
            forwardBtn.onclick = () => {
                audio.currentTime = Math.min(audio.duration || 0, audio.currentTime + CONFIG.AUDIO.FORWARD_SEC);
                A11yManager.announce('Forwarded 10 seconds', 'polite');
            };
            
            progContainer.onclick = (e) => {
                const rect = progContainer.getBoundingClientRect();
                const ratio = (e.clientX - rect.left) / progContainer.clientWidth;
                audio.currentTime = ratio * (audio.duration || 0);
            };
            
            // Auto-play if possible
            setTimeout(() => {
                audio.play().then(() => played = true).catch(() => {});
            }, 150);
        });
    },
    
    /**
     * Load current location
     */
    loadLocation() {
        // GUARD: must be called only after map is centered
        if (!Utils.isMapReady()) return;
        
        const loc = state.locations[state.currentIdx];
        this.updateLocationMarker(loc);
        this.updateAllMarkers();
        this.updateDistance();
        ViewportManager.ensureUserVisible();
    },
    
    /**
     * Bind map interaction events
     */
    bindEvents() {
        // Pan/drag
        state.map.on('movestart', () => {
            state.isUserInteracting = true;
            state.followUser = false;
        });
        state.map.on('moveend', () => {
            state.isUserInteracting = false;
            state.lastInteractionEnd = Date.now();
        });
        
        // Zoom
        state.map.on('zoomstart', () => {
            state.isUserInteracting = true;
            state.followUser = false;
        });
        state.map.on('zoomend', () => {
            state.isUserInteracting = false;
            state.lastInteractionEnd = Date.now();
        });
        
        // Pinch
        let touchStartDist = 0;
        state.map.on('touchstart', (e) => {
            const t = e.originalEvent.touches;
            if (t.length === 2) {
                touchStartDist = Math.hypot(t[0].clientX - t[1].clientX, t[0].clientY - t[1].clientY);
            }
        });
        state.map.on('touchmove', (e) => {
            const t = e.originalEvent.touches;
            if (t.length === 2 && touchStartDist > 0) {
                const dist = Math.hypot(t[0].clientX - t[1].clientX, t[0].clientY - t[1].clientY);
                const scale = dist / touchStartDist;
                if (scale < CONFIG.INTERACTION.MIN_PINCH_SCALE || scale > CONFIG.INTERACTION.MAX_PINCH_SCALE) {
                    state.isPinching = true;
                }
            }
        });
        state.map.on('touchend', () => {
            touchStartDist = 0;
            state.isPinching = false;
        });
    }
};

// ================================================================================
// POSITION PROCESSOR ‚Äî ROBUST & ADAPTIVE
// ================================================================================
const PositionProcessor = {
    /**
     * Process raw geolocation position
     * @param {Position} raw - geolocation position
     */
    async process(raw) {
        const now = Date.now();
        if (now - state.lastUpdateTime < CONFIG.POSITION.UPDATE_INTERVAL_MIN_MS) return;
        
        try {
            const coords = raw.coords;
            if (isNaN(coords.latitude) || isNaN(coords.longitude)) return;
            
            const pos = {
                lat: coords.latitude,
                lng: coords.longitude,
                accuracy: coords.accuracy,
                heading: coords.heading,
                speed: coords.speed ?? 0,
                timestamp: now
            };
            
            if (pos.accuracy > CONFIG.POSITION.MIN_ACCURACY_M) return;
            
            // Buffer cleanup
            state.positionBuffer = state.positionBuffer.filter(
                p => now - p.timestamp < CONFIG.POSITION.MAX_AGE_MS
            );
            
            // Initialize
            if (!state.currentPosition) {
                this.initialize(pos);
                return;
            }
            
            // Teleport check
            const d = Utils.distance(state.currentPosition, pos);
            if (d > CONFIG.POSITION.MAX_TELEPORT_M) {
                console.warn('[Position] Teleport detected ‚Äî resetting');
                KalmanFilter.reset(pos);
                this.initialize(pos);
                return;
            }
            
            // Velocity & speed
            const dt = (now - state.lastUpdateTime) / 1000;
            let speed = pos.speed > 0 ? pos.speed : (dt > 0.1 ? d / dt : 0);
            if (speed > CONFIG.SPEED.mps(CONFIG.SPEED.MAX_REASONABLE_MPH)) return;
            
            const vLat = dt > 0 ? (pos.lat - state.currentPosition.lat) / dt : 0;
            const vLng = dt > 0 ? (pos.lng - state.currentPosition.lng) / dt : 0;
            
            // Filter adaptation
            const speedMph = CONFIG.SPEED.mph(speed);
            KalmanFilter.adapt(speedMph);
            
            // Kalman update
            KalmanFilter.predict();
            const filtered = KalmanFilter.update(pos);
            
            // Buffer average
            state.positionBuffer.push(filtered);
            if (state.positionBuffer.length > CONFIG.POSITION.BUFFER_SIZE) {
                state.positionBuffer.shift();
            }
            const weights = state.positionBuffer.map((p, i) => {
                const age = (now - p.timestamp) / 1000;
                const recency = 1 / (1 + age * 0.1);
                const accuracy = 1 / (1 + p.accuracy * 0.05);
                return recency * accuracy;
            });
            const total = weights.reduce((a, b) => a + b, 0);
            const lat = state.positionBuffer.reduce((sum, p, i) => sum + p.lat * weights[i], 0) / total;
            const lng = state.positionBuffer.reduce((sum, p, i) => sum + p.lng * weights[i], 0) / total;
            const smoothed = {
                lat,
                lng,
                accuracy: filtered.accuracy,
                timestamp: now
            };
            
            // Heading smoothing
            const corrected = Utils.correctHeading(pos.heading);
            const smoothedHeading = Utils.smoothHeading(corrected, state.heading);
            
            // Update state
            state.velocity = { lat: vLat, lng: vLng };
            state.speedMps = speed;
            state.heading = smoothedHeading;
            state.currentPosition = smoothed;
            state.lastUpdateTime = now;
            state.lastPositionTime = now;
            state.errorCount = 0;
            
            // Update visuals
            this.updateUserMarker();
            MapManager.updateDistance();
            
            // Viewport update
            if (!Utils.isPopupOpen()) {
                ViewportManager.updateViewport();
                this.optimizeRendering();
            }
            
        } catch (e) {
            console.error('[Position] Processing error', e);
            state.errorCount++;
            if (state.errorCount > CONFIG.ERRORS.MAX_GEO_ERRORS) {
                this.handleFailure();
            }
        }
    },
    
    /**
     * Initialize position state
     * @param {Object} pos - initial position
     */
    initialize(pos) {
        state.currentPosition = pos;
        state.velocity = { lat: 0, lng: 0 };
        state.speedMps = 0;
        state.heading = null;
        state.lastUpdateTime = Date.now();
        state.lastPositionTime = Date.now();
        state.positionBuffer = [pos];
        KalmanFilter.reset(pos);
        if (state.userMarker) state.userMarker.setLatLng([pos.lat, pos.lng]);
        if (state.map && !state.tourStarted) {
            // CRITICAL: Set center and zoom BEFORE any .getBounds() calls
            state.map.setView([pos.lat, pos.lng], CONFIG.VIEWPORT.DEFAULT_ZOOM, { animate: false });
            state.tourStarted = true;
            TourManager.start(); // NOW SAFE
        }
        A11yManager.announce('Your location has been found.', 'polite');
    },
    
    /**
     * Update user marker position and appearance
     */
    updateUserMarker() {
        if (!state.userMarker || !state.currentPosition) return;
        
        // Dead reckoning
        const now = Date.now();
        const elapsed = (now - state.lastPositionTime) / 1000;
        let displayPos = state.currentPosition;
        
        if (elapsed > CONFIG.POSITION.DEAD_RECKONING_TIMEOUT_MS / 1000) {
            const decay = Math.exp(-elapsed * CONFIG.POSITION.DEAD_RECKONING_DECAY);
            displayPos = {
                lat: state.currentPosition.lat + state.velocity.lat * elapsed * decay,
                lng: state.currentPosition.lng + state.velocity.lng * elapsed * decay
            };
        }
        
        // Damped interpolation
        const damping = Math.exp(-elapsed * 3);
        const interpLat = state.currentPosition.lat + state.velocity.lat * elapsed * damping;
        const interpLng = state.currentPosition.lng + state.velocity.lng * elapsed * damping;
        displayPos = { lat: interpLat, lng: interpLng };
        
        state.userMarker.setLatLng([displayPos.lat, displayPos.lng]);
        
        // Icon styling
        const icon = state.userMarker.getElement()?.querySelector('.user-marker-icon');
        if (icon) {
            const speedMph = CONFIG.SPEED.mph(state.speedMps);
            icon.classList.toggle('moving-fast', speedMph > CONFIG.SPEED.HIGH_SPEED_MPH);
            if (state.heading != null) {
                icon.style.transform = `rotate(${state.heading}deg) translateZ(0)`;
                icon.style.transition = `transform ${CONFIG.ANIMATION.HEADING}s cubic-bezier(0.2,0,0.2,1)`;
            }
        }
    },
    
    /**
     * Optimize rendering for current speed
     */
    optimizeRendering() {
        const speedMph = CONFIG.SPEED.mph(state.speedMps);
        const container = document.querySelector('.leaflet-tile-container');
        if (container) {
            container.classList.toggle('high-speed', speedMph > CONFIG.SPEED.HIGH_SPEED_MPH);
        }
    },
    
    /**
     * Handle geolocation failure
     */
    handleFailure() {
        ModalManager.show({
            title: "üìç GPS Unavailable",
            content: "Location services are having trouble. Please check GPS, restart, or try again later.",
            buttons: [{ text: "Retry", action: "retry", class: "primary" }]
        }).then(action => {
            if (action === 'retry') {
                this.retryGeolocation();
            }
        });
    },
    
    /**
     * Retry geolocation after failure
     */
    retryGeolocation() {
        if (state.geoWatchId) {
            navigator.geolocation.clearWatch(state.geoWatchId);
        }
        setTimeout(() => {
            initGeolocation();
        }, CONFIG.ERRORS.RECOVERY_DELAY_MS);
    }
};

// ================================================================================
// ANIMATION LOOP ‚Äî FRAME-PERFECT
// ================================================================================
const AnimationLoop = {
    /**
     * Start animation loop
     */
    start() {
        state.isForeground = !document.hidden;
        document.addEventListener('visibilitychange', () => {
            state.isForeground = !document.hidden;
            if (state.isForeground && !state.animationFrame) this.run();
        });
        this.run();
    },
    
    /**
     * Animation frame tick
     */
    run() {
        if (!state.isForeground) {
            state.animationFrame = null;
            return;
        }
        
        PositionProcessor.updateUserMarker();
        state.animationFrame = requestAnimationFrame(() => this.run());
    }
};

// ================================================================================
// GEOLOCATION ‚Äî BATTERY & NETWORK SMART
// ================================================================================
const GeolocationManager = {
    /**
     * Start geolocation monitoring
     */
    async start() {
        if (!navigator.geolocation) {
            await ModalManager.show({
                title: "üìç Location Unavailable",
                content: "Your device doesn't support geolocation. Please use a modern mobile browser.",
                buttons: [{ text: "OK", action: "ok", class: "primary" }]
            });
            return;
        }
        
        // Battery & network awareness
        this.adaptToConditions();
        
        const options = {
            enableHighAccuracy: true,
            timeout: 15000,
            maximumAge: 5000
        };
        
        state.geoWatchId = navigator.geolocation.watchPosition(
            PositionProcessor.process.bind(PositionProcessor),
            (error) => {
                console.warn('[Geo] Error', error);
                const msg = {
                    1: "Location access denied. Please enable GPS.",
                    2: "Location unavailable. Check signal or restart GPS.",
                    3: "Location request timed out."
                }[error.code] || "Unknown location error.";
                ModalManager.show({
                    title: "üìç GPS Issue",
                    content: msg,
                    buttons: [{ text: "Retry", action: "retry", class: "primary" }]
                }).then(action => {
                    if (action === 'retry') this.start();
                });
            },
            options
        );
        
        // Initial position
        navigator.geolocation.getCurrentPosition(
            PositionProcessor.process.bind(PositionProcessor),
            console.warn,
            options
        );
    },
    
    /**
     * Adapt to battery and network conditions
     */
    adaptToConditions() {
        // Battery awareness
        if ('getBattery' in navigator) {
            navigator.getBattery().then(battery => {
                const interval = battery.charging ? 300 : 600;
                CONFIG.POSITION.UPDATE_INTERVAL_MIN_MS = interval;
                battery.addEventListener('chargingchange', () => {
                    CONFIG.POSITION.UPDATE_INTERVAL_MIN_MS = battery.charging ? 300 : 600;
                });
            }).catch(() => {});
        }
        
        // Network awareness
        if (navigator.connection) {
            const { saveData, effectiveType } = navigator.connection;
            if (saveData || ['slow-2g', '2g', '3g'].includes(effectiveType)) {
                CONFIG.POSITION.UPDATE_INTERVAL_MIN_MS = Math.max(800, CONFIG.POSITION.UPDATE_INTERVAL_MIN_MS);
            }
        }
    },
    
    /**
     * Stop geolocation and cleanup
     */
    stop() {
        if (state.geoWatchId) {
            navigator.geolocation.clearWatch(state.geoWatchId);
            state.geoWatchId = null;
        }
        if (state.animationFrame) {
            cancelAnimationFrame(state.animationFrame);
            state.animationFrame = null;
        }
    }
};

// ================================================================================
// TOUR MANAGER ‚Äî USER-CENTRIC FLOW
// ================================================================================
const TourManager = {
    /**
     * Start the tour experience
     */
    async start() {
        // Validate locations data
        if (!Array.isArray(window.locations_h) || window.locations_h.length === 0) {
            await ModalManager.show({
                title: "‚ö†Ô∏è Tour Data Missing",
                content: "Tour data failed to load. Please refresh the page.",
                buttons: [{ text: "Refresh", action: "refresh", class: "primary" }]
            });
            location.reload();
            return;
        }
        
        // Sort and prepare locations
        state.locations = window.locations_h.sort((a, b) => a.id - b.id);
        
        // Start fresh without asking to resume
        state.currentIdx = 0;
        state.visited = [];
        StorageManager.clear();
        
        // Load first location
        MapManager.loadLocation();
        
        // Show welcome
        await ModalManager.show({
            title: "üéØ Gangster History Tour",
            content: `
                <p style="font-size:1.15rem; line-height:1.5;">
                    Navigate to each stop. When you're within <strong>20 feet</strong>, listen, learn, and answer trivia to unlock the next location!
                </p>
                <p style="color:#666; font-size:0.95rem; margin-top:12px;">
                    The map adapts to your speed: roam freely below 15 mph, or let it flow beneath you when driving.
                </p>
            `,
            buttons: [{ text: "Begin Tour", action: "start", class: "primary" }]
        });
    }
};

// ================================================================================
// UI BINDINGS ‚Äî CLEAN & MAINTAINABLE
// ================================================================================
const bindUI = () => {
    // Recenter button
    document.getElementById('recenterButton').onclick = (e) => {
        e.preventDefault();
        ViewportManager.recenterOnUser();
    };
    
    // Show all toggle
    document.getElementById('showAllButton').onclick = (e) => {
        e.preventDefault();
        state.showAll = !state.showAll;
        e.target.classList.toggle('active', state.showAll);
        MapManager.updateAllMarkers();
        A11yManager.announce(state.showAll ? 'All stops visible' : 'Current stop only', 'polite');
    };
    
    // Tips button
    document.getElementById('tipsButton').onclick = (e) => {
        e.preventDefault();
        ModalManager.show({
            title: "üß≠ Tour Tips",
            content: `
                <ul style="text-align:left; line-height:1.6; margin:15px 0;">
                    <li><strong>Roaming:</strong> Below 15 mph, you can pan freely ‚Äî the map gently re-centers if you near the edge.</li>
                    <li><strong>Driving:</strong> Above 15 mph, you're locked to center ‚Äî the map flows beneath you.</li>
                    <li><strong>Tap</strong> your red icon to instantly recenter.</li>
                    <li>Get within <strong>20 feet</strong> of a stop to unlock its story.</li>
                    <li>Answer trivia correctly to advance.</li>
                </ul>
            `,
            buttons: [{ text: "Got It", action: "ok", class: "primary" }]
        });
    };
    
    // Return button
    document.getElementById('returnButton').onclick = (e) => {
        e.preventDefault();
        ModalManager.show({
            title: "üö™ End Tour?",
            content: "Your progress will be saved. Return to the Minnesota Then homepage?",
            buttons: [
                { text: "Stay on Tour", action: "stay" },
                { text: "Yes, Exit", action: "exit", class: "danger" }
            ]
        }).then(action => {
            if (action === 'exit') {
                StorageManager.save();
                window.location.href = 'https://www.mnthen.com/index.html';
            }
        });
    };
    
    // Hardware back button (Android)
    document.addEventListener('backbutton', (e) => {
        if (state.triviaVisible) {
            TriviaModal.hide();
            e.preventDefault();
        } else if (state.modal.isOpen) {
            ModalManager.close();
            e.preventDefault();
        }
    }, false);
};

// ================================================================================
// BOOTSTRAP ‚Äî ROBUST INITIALIZATION
// ================================================================================
document.addEventListener('DOMContentLoaded', async () => {
    try {
        // Init accessibility first
        A11yManager.initKeyboardNavigation();
        
        // Initialize map
        await MapManager.init();
        
        // Bind UI
        bindUI();
        
        // Start animation loop
        AnimationLoop.start();
        
        // Start geolocation (triggers TourManager.start after first position)
        GeolocationManager.start();
        
        // Cleanup on exit
        window.addEventListener('beforeunload', () => {
            GeolocationManager.stop();
            StorageManager.save();
        });
        
        A11yManager.announce('Minnesota Then tour loaded. Begin exploring.', 'polite');
        
    } catch (e) {
        console.error('[Bootstrap] Fatal error', e);
        ModalManager.show({
            title: "üí• Critical Error",
            content: "The tour failed to start. Please refresh or try again later.",
            buttons: [{ text: "Refresh", action: "refresh", class: "primary" }]
        }).then(() => location.reload());
    }
});
</script>
</body>
</html>
