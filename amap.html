<!doctype html> 
<html lang="en-US">
<head>
    <!-- Primary Meta Tags -->
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, minimum-scale=1.0, user-scalable=yes">
    <title>Minnesota Then | Museum Without Walls</title>
    <meta name="description" content="Free GPS-driven history across Minnesota. Walk past landmarks — virtual exhibits appear with archival photos and stories. No app, no signups, no ads.">
    <meta name="keywords" content="Minnesota living history, Museum Without Walls, location-based stories, GPS-triggered archives, onsite museum experience, interactive Minnesota heritage, historical photos, place-based audio history">
    
    <!-- Favicon & PWA -->
    <link rel="icon" href="https://www.mnthen.com/images/mnthenfav.ico" sizes="48x48">
    <link rel="icon" href="https://www.mnthen.com/images/icon-192.png" type="image/png" sizes="192x192">
    <link rel="apple-touch-icon" href="https://www.mnthen.com/images/icon-192.png">
    <link rel="manifest" href="/manifest.json">
    
    <!-- Theme color (for address bar & splash screen) -->
    <meta name="theme-color" content="#2c5282">
    
    <!-- Android PWA install support -->
    <meta name="mobile-web-app-capable" content="yes">
    
    <!-- iOS PWA support -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default"> 
    <meta name="apple-mobile-web-app-title" content="Minnesota Then">
    
    <!-- Security Headers (HTML meta fallback -->
    <meta http-equiv="X-Content-Type-Options" content="nosniff">
    <meta http-equiv="X-XSS-Protection" content="1; mode=block">
    <meta http-equiv="Referrer-Policy" content="strict-origin-when-cross-origin">
    <meta http-equiv="Permissions-Policy" content="geolocation=(self), camera=(), microphone=(), payment=(), usb=(), interest-cohort=()">
    <meta http-equiv="Cross-Origin-Opener-Policy" content="same-origin">
    <meta name="referrer" content="strict-origin-when-cross-origin">
    <meta name="color-scheme" content="light">
        
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://www.mnthen.com/">
    <meta property="og:title" content="Minnesota Then | Museum Without Walls">
    <meta property="og:description" content="Free GPS-driven history across Minnesota. Walk past landmarks — virtual exhibits appear with archival photos and stories. No app, no signups, no ads.">
    <meta property="og:image" content="https://www.mnthen.com/images/index/index_1.jpg">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:image:alt" content="A view of the historic retail along West Seventh Street, near what is now the Xcel Energy Center, taken by photographer Jerry Mathiason in 1978">
    <meta property="og:locale" content="en_US">
    <meta property="og:site_name" content="Minnesota Then">
    
    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@MinnesotaThen">
    <meta name="twitter:creator" content="@MinnesotaThen">
    <meta name="twitter:title" content="Minnesota Then | Museum Without Walls">
    <meta name="twitter:description" content="Free GPS-driven history across Minnesota. Walk past landmarks — virtual exhibits appear with archival photos and stories. No app, no signups, no ads.">
    <meta name="twitter:image" content="https://www.mnthen.com/images/index/index_1.jpg">
    <meta name="twitter:image:alt" content="A view of the historic retail along West Seventh Street, near what is now the Xcel Energy Center, taken by photographer Jerry Mathiason in 1978">
        
    <!-- Canonical URL -->
    <link rel="canonical" href="https://www.mnthen.com/">

    <!-- Only preconnect to origins you *actually use on this page* -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="preconnect" href="https://tile.openstreetmap.org">
    
    <!-- DNS prefetch for *additional* likely origins (lightweight, no connection) -->
    <link rel="dns-prefetch" href="//cdn.mnthen.com">
    <link rel="dns-prefetch" href="//api.mnthen.com">
    
    <!-- Critical CSS (render-blocking) -->
    <link rel="stylesheet" href="https://www.mnthen.com/css/mainmap.css">
    <link rel="stylesheet" href="https://www.mnthen.com/css/mnthen_main_map2.css">
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" crossorigin>
    
    <!-- Non-critical CSS (deferred — using media="print" for max compatibility) -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css" media="print" onload="this.media='all'">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css" media="print" onload="this.media='all'">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" media="print" onload="this.media='all'">
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" media="print" onload="this.media='all'">
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" media="print" onload="this.media='all'">

    <!-- Fallback for JS-disabled users -->
    <noscript>
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css">
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css">
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
      <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css">
      <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css">
    </noscript>

    <!-- JSON-LD Structured Data -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@graph": [
        {
          "@type": "WebApplication",
          "name": "Minnesota Then",
          "alternateName": "Minnesota Then Enterprise GIS",
          "url": "https://www.mnthen.com",
          "description": "Enterprise-grade historical GIS platform for Minnesota with advanced spatial analysis and offline capabilities.",
          "applicationCategory": ["ProductivityApplication", "EducationApplication"],
          "operatingSystem": "Web",
          "browserRequirements": "Requires JavaScript. Compatible with modern browsers.",
          "softwareVersion": "2.0",
          "datePublished": "2024-01-01",
          "dateModified": "2025-07-05",
          "inLanguage": "en-US",
          "isAccessibleForFree": true,
          "offers": {
            "@type": "Offer",
            "price": "0",
            "priceCurrency": "USD",
            "availability": "https://schema.org/InStock"
          },
          "creator": {
            "@type": "Organization",
            "name": "Minnesota Then",
            "url": "https://www.mnthen.com"
          },
          "featureList": [
            "Interactive historical maps",
            "Location-based tours",
            "Offline map capabilities",
            "Spatial analysis tools",
            "Historical content exploration"
          ],
          "screenshot": "https://www.mnthen.com/images/social-share.jpg",
          "aggregateRating": {
            "@type": "AggregateRating",
            "ratingValue": "4.8",
            "ratingCount": "150"
          }
        },
        {
          "@type": "TouristDestination",
          "name": "Minnesota Historical Sites",
          "description": "Explore historical locations across Minnesota with enterprise GIS capabilities",
          "geo": {
            "@type": "GeoCoordinates",
            "latitude": "46.7296",
            "longitude": "-94.6859"
          },
          "containedInPlace": {
            "@type": "State",
            "name": "Minnesota",
            "addressCountry": "US"
          },
          "touristType": [
            "History enthusiasts",
            "Educational groups",
            "Cultural tourists"
          ],
          "availableLanguage": "en-US"
        },
        {
          "@type": "Organization",
          "name": "Minnesota Then",
          "url": "https://www.mnthen.com",
          "logo": "https://www.mnthen.com/images/mnthenfav.ico",
          "sameAs": [
            "https://twitter.com/MinnesotaThen"
          ],
          "foundingDate": "2024",
          "description": "Digital platform preserving and sharing Minnesota's historical heritage through interactive mapping technology.",
          "knowsAbout": [
            "Minnesota History",
            "Historical GIS",
            "Digital Heritage",
            "Interactive Maps"
          ]
        }
      ]
    }
    </script>
            <style>
            /* Hide the entire document until every stylesheet & font is ready. */
            html {
              visibility: hidden !important;
            }
            html.unlock {
              visibility: visible !important;
            }
            
            /* DESIGN TOKENS */
            :root {
              --primary-color: #0066cc;
              --hover-color: #e6f0ff;
              --dark-blue: #1a3a8a;
              --dark-blue-hover: #0d2c6e;
              --success-color: #28a745;
              --warning-color: #ffc107;
              --error-color: #dc3545;
            }
            
            /* RESET & GLOBAL HELPERS */
            *,
            *::before,
            *::after {
              box-sizing: border-box;
            }
            
            body {
              margin: 0;
              padding: 0;
              font-family: Inter, system-ui, Avenir, Helvetica, Arial, sans-serif;
              background-color: #f8f9fa;
            }
            
            /* MAP CANVAS */
            #map {
              position: fixed;
              top: 0;
              left: 0;
              z-index: 1;
              width: 100vw;
              height: 100vh;
              height: 100dvh;
              touch-action: none;
              -webkit-user-select: none;
              user-select: none;
              will-change: transform;
            }
            
            /* iOS 100vh fix & dvh fallback combined */
            @supports (-webkit-touch-callout: none) {
              #map,
              .lochunt-container {
                height: -webkit-fill-available;
              }
            }
            
            @supports not (height: 100dvh) {
              #map {
                height: 100vh;
              }
            }
            
            /* COMPONENTS */
            
            /* Distance indicator */
            #distanceBox {
              position: fixed;
              top: 20px;
              right: 20px;
              z-index: 1003;
              background: white;
              padding: 12px 24px;
              border-radius: 50px;
              font-weight: 600;
              font-size: 20px;
              text-align: center;
              min-width: 200px;
              box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
              border: 3px solid var(--dark-blue);
              transition: all 0.3s ease;
              opacity: 0;
              visibility: hidden;
            }
            
            #distanceBox.show {
              opacity: 1;
              visibility: visible;
            }
            
            #distanceBox.proximity-close {
              background: linear-gradient(135deg, #28a745, #20c997);
              color: white;
              animation: pulse 1.5s infinite;
            }
            
            #distanceBox.proximity-medium {
              background: linear-gradient(135deg, #ffc107, #fd7e14);
              color: white;
            }
            
            #distanceBox.proximity-far {
              background: white;
              color: var(--dark-blue);
              border-color: var(--dark-blue);
            }
            
            /* Map action buttons */
            .map-buttons {
              position: absolute;
              bottom: 0;
              left: 0;
              right: 0;
              display: flex;
              justify-content: space-evenly;
              align-items: center;
              gap: 0.5rem;
              margin-bottom: 30px;
            }
            
            /* PWA Install Banner */
            #pwaInstallBanner {
              position: fixed;
              bottom: 20px;
              right: 20px;
              left: 20px;
              background: white;
              border-radius: 12px;
              box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15), 0 0 0 1px rgba(0, 0, 0, 0.05);
              padding: 20px;
              z-index: 2000;
              display: none;
              animation: slideUp 0.4s cubic-bezier(0.16, 1, 0.3, 1) forwards;
              font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
              border: 1px solid #e2e8f0;
            }
            
            #pwaInstallBanner.show {
              display: block;
            }
            
            #pwaInstallBanner .banner-header {
              display: flex;
              justify-content: space-between;
              align-items: flex-start;
              margin-bottom: 15px;
            }
            
            #pwaInstallBanner .banner-title {
              display: flex;
              align-items: center;
              gap: 12px;
            }
            
            #pwaInstallBanner .app-icon {
              width: 40px;
              height: 40px;
              border-radius: 10px;
              background-color: #2c5282;
              display: flex;
              align-items: center;
              justify-content: center;
              color: white;
              font-size: 20px;
              flex-shrink: 0;
            }
            
            #pwaInstallBanner h3 {
              margin: 0;
              color: #2d3748;
              font-size: 18px;
              font-weight: 600;
            }
            
            #pwaInstallBanner .close-btn {
              background: #f7fafc;
              border: none;
              width: 32px;
              height: 32px;
              border-radius: 50%;
              display: flex;
              align-items: center;
              justify-content: center;
              cursor: pointer;
              color: #718096;
              font-size: 20px;
              transition: all 0.2s ease;
              flex-shrink: 0;
            }
            
            #pwaInstallBanner .close-btn:hover {
              background: #edf2f7;
              color: #4a5568;
            }
            
            #pwaInstallBanner .banner-content {
              margin-bottom: 20px;
            }
            
            #pwaInstallBanner .banner-content p {
              margin: 0;
              color: #4a5568;
              line-height: 1.5;
              font-size: 15px;
            }
            
            #pwaInstallBanner .banner-actions {
              display: flex;
              justify-content: flex-end;
              gap: 12px;
            }
            
            #pwaInstallBanner .cancel-btn {
              background: transparent;
              border: 1px solid #e2e8f0;
              border-radius: 8px;
              padding: 10px 18px;
              font-size: 14px;
              font-weight: 500;
              cursor: pointer;
              color: #718096;
              transition: all 0.2s ease;
            }
            
            #pwaInstallBanner .cancel-btn:hover {
              background: #f7fafc;
              border-color: #cbd5e0;
            }
            
            #pwaInstallBanner .install-btn {
              background: #2c5282;
              color: white;
              border: none;
              border-radius: 8px;
              padding: 10px 22px;
              font-size: 14px;
              font-weight: 600;
              cursor: pointer;
              transition: all 0.2s ease;
              box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
              position: relative;
              overflow: hidden;
            }
            
            #pwaInstallBanner .install-btn::before {
              content: '';
              position: absolute;
              top: 0;
              left: -100%;
              width: 100%;
              height: 100%;
              background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
              transition: left 0.7s ease;
            }
            
            #pwaInstallBanner .install-btn:hover {
              background: #1a3a8a;
              box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
              transform: translateY(-1px);
            }
            
            #pwaInstallBanner .install-btn:hover::before {
              left: 100%;
            }
            
            #pwaInstallBanner .install-btn:active {
              transform: translateY(0);
              box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            }

            .pwa-post-install-notice {
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%) translateY(100%);
  background: #1a1a1a;
  color: #f8f9fa;
  border-radius: 14px;
  padding: 16px;
  width: 90%;
  max-width: 360px;
  box-shadow: 0 6px 20px rgba(0, 0, 0, 0.35);
  z-index: 10001;
  opacity: 0;
  visibility: hidden;
  transition: 
    transform 0.3s ease-out,
    opacity 0.3s ease-out,
    visibility 0.3s;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  font-size: 15px;
  line-height: 1.4;
}

.pwa-post-install-notice.show {
  transform: translateX(-50%) translateY(0);
  opacity: 1;
  visibility: visible;
  /* Prevent scroll bounce on iOS */
  -webkit-overflow-scrolling: touch;
}

.pwa-notice-content p:first-of-type {
  margin-top: 0;
  font-weight: 600;
  color: #66d9ef;
}

.pwa-notice-content ol {
  margin: 10px 0 14px 18px;
  padding-left: 4px;
}

.pwa-notice-content li {
  margin-bottom: 6px;
}

.pwa-notice-button {
  background: #007bff;
  color: white;
  border: none;
  border-radius: 8px;
  padding: 8px 16px;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  width: 100%;
  transition: background 0.2s;
}

.pwa-notice-button:hover,
.pwa-notice-button:focus {
  background: #0056b3;
  outline: 2px solid #66d9ef;
  outline-offset: 2px;
}

/* Responsive spacing */
@media (max-width: 480px) {
  .pwa-post-install-notice {
    bottom: 16px;
    width: calc(100% - 32px);
  }
}
            
            /* Markers */
            .user-marker-icon {
              width: 22px;
              height: 22px;
              background: radial-gradient(circle, #dc3545 0%, #a71e2a 70%);
              border: 3px solid white;
              border-radius: 50%;
              box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
              transition: all 0.3s ease;
            }
            
            .user-marker-icon.moving {
              animation: pulse 2s infinite;
            }
            
            .marker-cluster-custom {
              background: rgba(44, 82, 130, 0.9);
              border-radius: 50%;
              color: white;
              display: flex;
              align-items: center;
              justify-content: center;
              font-weight: 600;
            }
            
            .marker-cluster-custom div {
              width: 40px;
              height: 40px;
              border-radius: 50%;
              display: flex;
              align-items: center;
              justify-content: center;
            }
            
            #accuracyIndicator {
              position: absolute;
              top: 10px;
              left: 10px;
              width: 20px;
              height: 20px;
              border-radius: 50%;
              border: 2px solid rgba(255, 255, 255, 0.8);
              box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
              z-index: 1000;
              transition: background-color 0.3s ease;
            }
            
            /* ANIMATIONS */
            @keyframes pulse {
              0%, 100% {
                opacity: 0.8;
              }
              50% {
                opacity: 1;
              }
            }
            
            @keyframes slideUp {
              from {
                transform: translateY(100px);
                opacity: 0;
              }
              to {
                transform: translateY(0);
                opacity: 1;
              }
            }
            
            @keyframes gradientShift {
              0%, 100% {
                background-position: 0% 50%;
              }
              50% {
                background-position: 100% 50%;
              }
            }
            
            @keyframes fadeIn {
              from {
                opacity: 0;
              }
              to {
                opacity: 1;
              }
            }
            
            @keyframes fadeOut {
              from {
                opacity: 1;
              }
              to {
                opacity: 0;
              }
            }
            
            .fade-in {
              animation: fadeIn 0.3s ease forwards;
            }
            
            .fade-out {
              animation: fadeOut 0.3s ease forwards;
            }
            
            /* UTILITIES */
            .sr-only {
              position: absolute;
              width: 1px;
              height: 1px;
              padding: 0;
              margin: -1px;
              overflow: hidden;
              clip: rect(0, 0, 0, 0);
              white-space: nowrap;
              border: 0;
            }
            
            /* ACCESSIBILITY & RESPONSIVE */
            @media (prefers-reduced-motion: reduce) {
              .user-marker-icon,
              .map-button,
              #distanceBox,
              #pwaInstallBanner,
              .fade-in,
              .fade-out {
                transition: none !important;
                animation: none !important;
              }
            }
            
            @media (max-width: 640px) {
              #pwaInstallBanner {
                right: 15px;
                left: 15px;
                bottom: 15px;
                padding: 18px;
              }
              
              #pwaInstallBanner h3 {
                font-size: 16px;
              }
              
              #pwaInstallBanner .banner-content p {
                font-size: 14px;
              }
              
              #pwaInstallBanner .banner-actions {
                flex-direction: column-reverse;
                gap: 10px;
              }
              
              #pwaInstallBanner .cancel-btn,
              #pwaInstallBanner .install-btn {
                width: 100%;
                text-align: center;
                padding: 12px;
              }
            }
            
            @media (max-width: 500px) {
              #loadingMessage > div {
                width: 85% !important;
                height: auto !important;
                min-height: 480px !important;
                padding: 25px 20px !important;
              }
            }
            
            @media (max-width: 360px) {
              #accuracyIndicator {
                display: none;
              }
            }
            </style>
        <script>
        (function () {
          if (window.foucBusterActive) return;
          window.foucBusterActive = true;
          
          let unlocked = false;
          
          function unlock() {
            if (unlocked) return;
            unlocked = true;
            document.documentElement.classList.add('unlock');
            
            const ann = document.createElement('div');
            ann.setAttribute('aria-live', 'polite');
            ann.setAttribute('aria-atomic', 'true');
            ann.style.cssText = 'position:absolute;left:-10000px;width:1px;height:1px;overflow:hidden';
            ann.textContent = 'Application loaded';
            document.body.appendChild(ann);
            setTimeout(() => ann.remove(), 3000);
            
            window.dispatchEvent(new CustomEvent('foucUnlocked', { detail: { ts: Date.now() } }));
          }
          
          // CSS variable check (cached promise, single execution)
          const cssReady = (() => {
            let promise;
            return () => promise ?? (promise = new Promise(resolve => {
              if (!document.body) return resolve(false); // Guard against missing body
              
              const d = document.createElement('div');
              d.style.cssText = 'color:var(--primary-color);position:absolute;visibility:hidden';
              document.body.appendChild(d);
              const ok = getComputedStyle(d).color !== 'var(--primary-color)';
              d.remove();
              resolve(ok);
            }));
          })();
          
          // Fonts ready (treat failures as non-blocking)
          const fontsReady = () => 
            document.fonts ? document.fonts.ready.catch(() => {}) : Promise.resolve();
          
          // Main check
          function performChecks() {
            Promise.all([cssReady(), fontsReady()]).then(unlock);
          }
          
          // Initial trigger
          if (document.readyState === 'complete' || 
              (document.readyState === 'interactive' && document.body)) {
            performChecks();
          } else {
            document.addEventListener('DOMContentLoaded', performChecks, { once: true });
          }
          
          // Safety nets
          window.addEventListener('load', () => setTimeout(unlock, 16), { once: true });
          
          ['click', 'touchstart', 'keydown'].forEach(e =>
            document.addEventListener(e, unlock, { once: true, passive: true })
          );
          
          // Early bailout if body appears before styles
          if (!document.body) {
            new MutationObserver((_, ob) => {
              if (document.body?.children.length) {
                ob.disconnect();
                unlock(); // Immediate bailout, not re-check
              }
            }).observe(document.documentElement, { childList: true, subtree: true });
          }
        })();
        </script>
</head>
    
<body>
     <noscript>
          <div style="padding:2rem;text-align:center;font-family:sans-serif">
            <h2>JavaScript Required</h2>
            <p>This map requires JavaScript to function. Please enable it in your browser.</p>
          </div>
    </noscript>
    
    <!-- Map container -->
    <div id="map"></div>

    <!-- GPS accuracy indicator, red, yellow, green -->
    <div id="accuracyIndicator"></div>
    
    <!-- Enhanced Distance Box with Dark Blue Border -->
    <div id="distanceBox">Initializing...</div>

    <!-- Location Hunt Container -->
    <div class="lochunt-container">
        <img id="locationImage" src="" alt="Location Image">
        <div class="lochunt-content">
            <div class="lochunt-info">
                <h2 id="locationTitle" class="mb-2 text-primary"></h2>
                <p id="locationCity" class="text-muted mb-1"></p>
                <p id="locationCreator" class="text-muted mb-3"></p>
            </div>
            <div class="audio-player">
                <div class="audio-progress">
                    <div class="progress">
                        <div id="progressBar" class="progress-bar" role="progressbar" style="width: 0%"></div>
                    </div>
                </div>
                <div class="audio-time">
                    <span id="currentTime">0:00</span>
                    <span id="duration">0:00</span>
                </div>
                <div class="audio-controls">
                    <button id="rewindBtn" class="audio-button" aria-label="Rewind 10 seconds"><i class="fas fa-backward"></i></button>
                    <button id="playPauseBtn" class="audio-button" aria-label="Play"><i class="fas fa-play"></i></button>
                    <button id="forwardBtn" class="audio-button" aria-label="Forward 10 seconds"><i class="fas fa-forward"></i></button>
                </div>
                <audio id="locationAudio" preload="auto" crossorigin="anonymous"></audio>
            </div>
        </div>
    </div>

    <!-- Additional Info Container -->
    <div class="additional-info-container">
        <h3 class="mb-3 text-primary text-center">Did You Know?</h3>
        <p id="additionalInfo" class="mb-3 fs-6"></p>
        <div class="d-flex justify-content-center">
            <button id="continueButton" class="btn btn-primary">Continue</button>
        </div>
    </div>
    
    <!-- Map Buttons -->
    <div class="map-buttons">
        <button id="recenterButton" class="map-button" aria-label="Recenter map"><i class="fas fa-crosshairs"></i></button>
        <button id="returnButton" class="map-button" aria-label="Return to main page"><i class="fas fa-sign-out-alt"></i></button>
        <button id="tipsButton" class="map-button" aria-label="Show navigation tips"><i class="fas fa-question-circle"></i></button>
    </div>

    <!-- Summary Modal -->
    <div id="summaryModal" class="modal" style="display: none;">
        <div class="modal-content">
            <p id="summaryContent"></p>
        </div>
    </div>

    <!-- PWA Post-Install Notice -->
<div id="pwaPostInstallNotice" class="pwa-post-install-notice" role="alert" aria-hidden="true">
  <div class="pwa-notice-content">
    <p>Minnesota Then is installed!</p>
    <p>To use the app:</p>
    <ol>
      <li>Close this browser tab</li>
      <li>Open the app from your home screen</li>
    </ol>
    <button id="dismissPostInstall" class="pwa-notice-button">Got it</button>
  </div>
</div>

    <!-- PWA Install Banner -->
<div id="pwaInstallBanner">
    <div class="banner-header">
        <div class="banner-title">
            <div class="app-icon">
                <i class="fas fa-map-marked-alt"></i>
            </div>
            <h3>Install Minnesota Then</h3>
        </div>
        <button class="close-btn" id="closePwaBanner">&times;</button>
    </div>
    <div class="banner-content">
        <p>Add our app to your home screen for instant loading and full immersion, right where it happened.</p>
    </div>
    <div class="banner-actions">
        <button class="cancel-btn" id="cancelPwaBanner">Not Now</button>
        <button class="install-btn" id="installPwaButton">Install App</button>
    </div>
</div> 

    <!-- Load scripts with defer to improve page load performance -->
    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js" defer></script>
    <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js" defer></script>
    <script src="/locations_main.js?v=1.0.4" defer></script>

    <script>
/* Enterprise Service‑Worker */
(function setupEnterpriseSW() {
  /** Set to true to see verbose logs in production (e.g., add "?sw_debug" to the URL). */
  const DEBUG = location.search.includes('sw_debug');

  /** Interval ID for the periodic update check */
  let updateInterval = null;

  /* Message handler – receives messages posted from the SW. */
  const msgHandler = e => {
    if (e?.data?.type === 'SW_ACTIVATED') {
      if (DEBUG) console.log('Enterprise Service Worker activated, version:', e.data.version);
    }
    // Optional: handle a user‑visible update prompt
    if (e?.data?.type === 'UPDATE_READY') {
      if (confirm('A new version of the app is available. Reload now?')) {
        window.location.reload();
      }
    }
  };

  /* When a new worker is installing or waiting, ask it to skip waiting. */
  const handleUpdate = registration => {
    const newWorker = registration.installing || registration.waiting;
    if (!newWorker) return;

    const askToSkip = () => {
      try {
        newWorker.postMessage({ type: 'SKIP_WAITING' });
        if (DEBUG) console.log('Sent SKIP_WAITING to Service Worker');
      } catch (err) {
        console.warn('Failed to post SKIP_WAITING to SW:', err);
      }
    };

    // If already in a final state, act immediately.
    if (newWorker.state === 'installed' || newWorker.state === 'waiting') {
      askToSkip();
      return;
    }

    // Otherwise listen for the state change.
    const onStateChange = () => {
      if (newWorker.state === 'installed' || newWorker.state === 'waiting') {
        askToSkip();
        newWorker.removeEventListener('statechange', onStateChange);
      }
    };
    newWorker.addEventListener('statechange', onStateChange);
  };

  /* Register the Service Worker and set up periodic updates. */
  const onLoad = () => {
    if (!('serviceWorker' in navigator)) return;

    navigator.serviceWorker
      .register('/sw.js')
      .then(registration => {
        if (DEBUG) console.log('Enterprise SW registered:', registration);

        // Listen for messages from the SW.
        navigator.serviceWorker.addEventListener('message', msgHandler);

        // Deal with any worker that is already installing or waiting.
        if (registration.installing) {
          handleUpdate(registration);
        } else if (registration.waiting) {
          try {
            registration.waiting.postMessage({ type: 'SKIP_WAITING' });
          } catch (err) {
            console.warn('Failed to post SKIP_WAITING to waiting SW:', err);
          }
        }

        // When a new update is found, run the same handler.
        registration.addEventListener('updatefound', () => handleUpdate(registration));

        // Periodic update check – default every hour.
        updateInterval = setInterval(() => {
          // Skip the check if the user is offline (optional optimization).
          if (!navigator.onLine) return;

          navigator.serviceWorker
            .getRegistration('/sw.js')
            .then(reg => {
              if (reg) reg.update().catch(err => console.warn('SW update check failed:', err));
            })
            .catch(err => console.warn('Failed to get SW registration for update:', err));
        }, 60 * 60 * 1000); // 1 hour (change to 24 h if you prefer)
      })
      .catch(err => console.error('SW registration failed:', err));
  };

  /* Cleanup when the page is about to be unloaded. */
  const onUnload = () => {
    if (updateInterval) {
      clearInterval(updateInterval);
      updateInterval = null;
    }
    if (navigator.serviceWorker) {
      navigator.serviceWorker.removeEventListener('message', msgHandler);
    }
  };

  // Hook into the page lifecycle.
  window.addEventListener('load', onLoad, { once: true });
  window.addEventListener('beforeunload', onUnload);
  // For SPAs that use pagehide instead of beforeunload:
  window.addEventListener('pagehide', onUnload);

  // Expose a manual teardown function (useful for frameworks that mount/unmount the map).
  window.teardownEnterpriseSW = onUnload;
})();

// CACHE MANAGER 
class EnterpriseCacheManager {
  constructor() {
    this.cachePrefix = 'mnthen-enterprise-';
    this.maxCacheSize = 50 * 1024 * 1024;
    this.maxCacheAge = 7 * 24 * 60 * 60 * 1000;
    this.proximityThresholdMeters = 1000;
    this.keyName = `${this.cachePrefix}crypto-key`;
    this.CLEANUP_INTERVAL_MS = 60 * 60 * 1000;
    this.encryptionKey = null;
  }

  async init() {
    try {
      await this.cleanupExpiredCache();
      this.startPeriodicCleanup();
    } catch (error) {
      console.error('Cache manager initialization failed:', error);
    }
  }

  async cacheLocationData(location, userPosition) {
    if (!userPosition || !location?.id) return;
    
    const distanceMeters = this._calculateDistance(userPosition, location);
    
    if (distanceMeters <= this.proximityThresholdMeters) {
      try {
        const data = JSON.stringify({ 
          location, 
          timestamp: Date.now(), 
          distanceMeters 
        });
        const key = `${this.cachePrefix}location_${location.id}`;
        const encryptedData = await this.encryptData(data);
        
        try {
          localStorage.setItem(key, encryptedData);
          console.log(`Cached location ${location.name || location.id} (${(distanceMeters * 3.28084).toFixed(0)} feet away)`);
        } catch (storageError) {
          if (storageError.name === 'QuotaExceededError') {
            await this.cleanupOldestEntries();
            localStorage.setItem(key, encryptedData);
          } else {
            throw storageError;
          }
        }
      } catch (e) { 
        console.warn('Failed to cache location data:', e); 
      }
    }
  }

  async encryptData(data) {
    if (!window.crypto?.subtle) return btoa(data);
    
    try {
      const encoder = new TextEncoder();
      const dataBuffer = encoder.encode(data);
      const iv = crypto.getRandomValues(new Uint8Array(12));
      
      const key = await this.getEncryptionKey();
      const encrypted = await crypto.subtle.encrypt(
        { name: 'AES-GCM', iv }, 
        key, 
        dataBuffer
      );
      
      const result = new Uint8Array(iv.length + encrypted.byteLength);
      result.set(iv, 0);
      result.set(new Uint8Array(encrypted), iv.length);
      
      // More efficient conversion for large arrays
      const chunkSize = 8192;
      let binaryString = '';
      for (let i = 0; i < result.length; i += chunkSize) {
        const chunk = result.subarray(i, Math.min(i + chunkSize, result.length));
        binaryString += String.fromCharCode(...chunk);
      }
      return btoa(binaryString);
    } catch (error) { 
      console.error("Encryption failed:", error);
      return btoa(data);
    }
  }

  async getEncryptionKey() {
    if (!this.encryptionKey) {
      const keyData = await this.getOrCreateKeyData();
      this.encryptionKey = await crypto.subtle.importKey(
        'raw',
        keyData,
        { name: 'AES-GCM', length: 256 },
        true,
        ['encrypt', 'decrypt']
      );
    }
    return this.encryptionKey;
  }

  async getOrCreateKeyData() {
    const storedKey = localStorage.getItem(this.keyName);
    
    if (storedKey) {
      const binaryString = atob(storedKey);
      const bytes = new Uint8Array(binaryString.length);
      for (let i = 0; i < binaryString.length; i++) {
        bytes[i] = binaryString.charCodeAt(i);
      }
      return bytes;
    }
    
    const newKey = crypto.getRandomValues(new Uint8Array(32));
    const binaryString = String.fromCharCode(...newKey);
    localStorage.setItem(this.keyName, btoa(binaryString));
    return newKey;
  }

  async cleanupExpiredCache() {
    const now = Date.now();
    const toRemove = [];
    
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (!key?.startsWith(this.cachePrefix) || key === this.keyName) continue;
      
      try {
        const item = localStorage.getItem(key);
        if (!item) {
          toRemove.push(key);
          continue;
        }
        
        const decrypted = await this.decryptData(item);
        const parsed = JSON.parse(decrypted);
        
        if (now - parsed.timestamp > this.maxCacheAge) {
          toRemove.push(key);
        }
      } catch (error) {
        toRemove.push(key);
      }
    }
    
    toRemove.forEach(key => localStorage.removeItem(key));
    if (toRemove.length) {
      console.log(`Cleaned up ${toRemove.length} expired cache entries`);
    }
  }

  async decryptData(encryptedData) {
    if (!encryptedData || !window.crypto?.subtle) {
      return encryptedData ? atob(encryptedData) : '';
    }
    
    try {
      const binaryString = atob(encryptedData);
      const data = new Uint8Array(binaryString.length);
      for (let i = 0; i < binaryString.length; i++) {
        data[i] = binaryString.charCodeAt(i);
      }
      
      const iv = data.slice(0, 12);
      const encrypted = data.slice(12);
      
      const key = await this.getEncryptionKey();
      const decrypted = await crypto.subtle.decrypt(
        { name: 'AES-GCM', iv },
        key,
        encrypted
      );
      
      return new TextDecoder().decode(decrypted);
    } catch (error) {
      console.error("Decryption failed:", error);
      return atob(encryptedData);
    }
  }

  async cleanupOldestEntries() {
    const entries = [];
    
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (!key?.startsWith(this.cachePrefix) || key === this.keyName) continue;
      
      try {
        const item = localStorage.getItem(key);
        if (!item) {
          entries.push({ key, timestamp: 0 });
          continue;
        }
        
        const decrypted = await this.decryptData(item);
        const parsed = JSON.parse(decrypted);
        entries.push({ key, timestamp: parsed.timestamp || 0 });
      } catch (error) {
        entries.push({ key, timestamp: 0 });
      }
    }
    
    entries.sort((a, b) => a.timestamp - b.timestamp);
    const removeCount = Math.ceil(entries.length * 0.2);
    
    for (let i = 0; i < removeCount; i++) {
      localStorage.removeItem(entries[i].key);
    }
  }

  startPeriodicCleanup() {
    this.cleanupIntervalId = setInterval(async () => {
      try {
        await this.cleanupExpiredCache();
      } catch (error) {
        console.error("Periodic cache cleanup failed:", error);
      }
    }, this.CLEANUP_INTERVAL_MS);
  }

  stopPeriodicCleanup() {
    if (this.cleanupIntervalId) {
      clearInterval(this.cleanupIntervalId);
      this.cleanupIntervalId = null;
    }
  }

 _calculateDistance(pos1, pos2) {
  // Delegate to the main, validated distance function
  return calculateDistance(pos1, pos2);
    }
  }

// SECURITY MANAGER
class EnterpriseSecurityManager {
  constructor(options = {}) {
    const {
      inMemoryLogLimit = 100,
      persistedLogKey = 'securityAuditLog',
      enablePersistence = false
    } = options;

    this.config = { inMemoryLogLimit, persistedLogKey, enablePersistence };
    this.sessionToken = this.generateSecureToken();
    this.auditLog = [];
    this.cspViolations = [];
    this.persistedLogKey = persistedLogKey;
  }

  generateSecureToken() {
    return Array.from(crypto.getRandomValues(new Uint8Array(16)), b =>
      b.toString(16).padStart(2, '0')
    ).join('');
  }

  logSecurityEvent(event, details) {
    const entry = {
      timestamp: new Date().toISOString(),
      event,
      details,
      sessionToken: this.sessionToken, 
      url: location.href 
    };

    this.auditLog.push(entry);
    console.log('Security Event:', entry);

    if (this.auditLog.length > this.config.inMemoryLogLimit) {
      this.auditLog.shift();
    }

    if (this.config.enablePersistence) {
      this._persistLogEntry(entry);
    }
  }

  monitorCSPViolations() {
    document.addEventListener('securitypolicyviolation', e => {
      try {
        const violationData = {
          timestamp: new Date().toISOString(),
          violatedDirective: e.violatedDirective, 
          blockedURI: e.blockedURI, 
          documentURI: e.documentURI, 
          effectiveDirective: e.effectiveDirective,
          sourceFile: e.sourceFile,
          lineNumber: e.lineNumber,
          columnNumber: e.columnNumber
        };

        this.cspViolations.push(violationData);
        
        this.logSecurityEvent('CSP_VIOLATION', {
          directive: e.violatedDirective,
          uri: e.blockedURI
        });
      } catch (error) {
        console.error('Failed to process CSP violation:', error);
      }
    });
  }

  init() {
    this.monitorCSPViolations();
    this.logSecurityEvent('SESSION_START', { timestamp: Date.now() });
  }

  getAuditLog() {
    return [...this.auditLog];
  }

  clearAuditLog() {
    this.auditLog = [];
    this.cspViolations = [];
    if (this.config.enablePersistence) {
      localStorage.removeItem(this.persistedLogKey);
    }
    console.log('Security audit log cleared.');
  }

  getCSPViolations() {
    return [...this.cspViolations];
  }

  clearCSPViolations() {
    this.cspViolations = [];
    console.log('CSP violations log cleared.');
  }

  forgetUser() {
    this.clearAuditLog();
    this.clearCSPViolations();
  }

  _persistLogEntry(entry) {
    try {
      const logString = localStorage.getItem(this.persistedLogKey);
      let log = logString ? JSON.parse(logString) : [];

      log.push(entry);

      if (log.length > 500) {
        log = log.slice(-500);
      }

      localStorage.setItem(this.persistedLogKey, JSON.stringify(log));
    } catch (error) {
      console.error('Failed to persist security log:', error);
    }
  }
}

// PERFORMANCE MONITOR 
class EnterprisePerformanceMonitor {
  constructor(options = {}) {
    const {
      updateInterval = 1000,
      memoryCheckInterval = 5000,
      fpsThreshold = 30,
      memoryThreshold = 100
    } = options;

    this.metrics = {
      fps: 0,
      memory: 0,
      loadedLocations: 0,
      cacheHits: 0,
      networkRequests: 0
    };

    this.frameCount = 0;
    this.lastTime = performance.now();
    this.lastFps = 0;
    this.lastMem = 0;
    this.isMonitoring = false;
    this.intervals = [];
    this.rafId = null;

    this._config = {
      updateInterval,
      memoryCheckInterval,
      fpsThreshold,
      memoryThreshold
    };

    this.customMetrics = {};
    this.dataSource = () => (window.gameLocations ? window.gameLocations.length : 0);
  }

  startMonitoring() {
    if (this.isMonitoring) {
      console.warn('Performance monitoring is already active.');
      return;
    }
    this.isMonitoring = true;
    this._startFPSMonitor();
    this._startMemoryMonitor();
    this.intervals.push(setInterval(() => this._updateMetrics(), this._config.updateInterval));
  }

  getMetrics() {
    return { ...this.metrics, ...this.customMetrics };
  }

  stopMonitoring() {
    if (!this.isMonitoring) return;
    
    this.isMonitoring = false;
    
    this.raf?.cancelAnimationFrame(this.rafId);
    this.rafId = null;
    
    this.intervals.forEach(clearInterval);
    this.intervals = [];
    
    console.log('Performance monitoring stopped.');
  }

  setDataSource(sourceFn) {
    if (typeof sourceFn === 'function') {
      this.dataSource = sourceFn;
    } else {
      console.warn('Data source must be a function.');
    }
  }

  trackMetric(key, value) {
    this.customMetrics[key] = value;
  }

  _startFPSMonitor() {
    const calculateFPS = (now) => {
      if (!this.isMonitoring) return;
      
      this.frameCount++;
      if (now - this.lastTime >= 1000) {
        this.metrics.fps = Math.round((this.frameCount * 1000) / (now - this.lastTime));
        this.frameCount = 0;
        this.lastTime = now;
      }
      this.rafId = requestAnimationFrame(calculateFPS);
    };
    this.rafId = requestAnimationFrame(calculateFPS);
  }

  _startMemoryMonitor() {
    if (!performance.memory) {
      console.warn('performance.memory API not available. Memory monitoring disabled.');
      return;
    }
    
    const memoryInterval = setInterval(() => {
      if (!this.isMonitoring) return;
      this.metrics.memory = Math.round(performance.memory.usedJSHeapSize / 1024 / 1024);
    }, this._config.memoryCheckInterval);
    
    this.intervals.push(memoryInterval);
  }

  _updateMetrics() {
    this.metrics.loadedLocations = this.dataSource();

    const { fps, memory } = this.metrics;
    const { fpsThreshold, memoryThreshold } = this._config;

    if (fps < fpsThreshold && this.lastFps >= fpsThreshold) {
      console.warn(`Performance Alert: FPS dropped to ${fps}`);
    }
    if (memory > memoryThreshold && this.lastMem <= memoryThreshold) {
      console.warn(`Performance Alert: Memory usage ${memory}MB`);
    }

    this.lastFps = fps;
    this.lastMem = memory;
  }
}

// BACKGROUND SYNC 
class EnterpriseBackgroundSync {
  constructor(options = {}) {
    const {
      maxRetries = 3,
      baseDelay = 100,
      backoffFactor = 2,
      maxQueueSize = 100
    } = options;

    this._config = {
      maxRetries,
      baseDelay,
      backoffFactor,
      maxQueueSize
    };

    this.syncQueue = [];
    this.isOnline = navigator.onLine;
    this.processing = false;
    
    this._onlineHandler = () => {
      this.isOnline = true;
      this.process();
    };
    this._offlineHandler = () => {
      this.isOnline = false;
    };

    window.addEventListener('online', this._onlineHandler);
    window.addEventListener('offline', this._offlineHandler);
  }

  addToSyncQueue(data) {
    if (this.syncQueue.length >= this._config.maxQueueSize) {
      console.warn('Sync queue is full. Dropping oldest item.');
      this.syncQueue.shift();
    }

    const queueItem = {
      data,
      retries: 0,
      timestamp: Date.now()
    };
    this.syncQueue.push(queueItem);

    if (this.isOnline) {
      queueMicrotask(() => this.process());
    }
  }

  async process() {
    if (this.processing || !this.isOnline || this.syncQueue.length === 0) {
      return;
    }

    this.processing = true;

    while (this.syncQueue.length > 0 && this.isOnline) {
      const item = this.syncQueue.shift();

      try {
        // Require a handler — no fallback simulation
        if (typeof item.data?.handler !== 'function') {
          console.error('Sync item missing required handler function:', item.data);
          continue;
        }

        await item.data.handler(item.data);
        console.log('Background sync completed for:', item.data.type || 'unknown');
      } catch (error) {
        console.error('Background sync failed for item:', item.data, error);
        item.retries++;

        if (item.retries < this._config.maxRetries) {
          const delay = this._config.baseDelay * Math.pow(this._config.backoffFactor, item.retries);
          console.log(`Retrying in ${delay}ms... (attempt ${item.retries + 1})`);
          await new Promise(resolve => setTimeout(resolve, delay));
          this.syncQueue.unshift(item);
        } else {
          console.error('Background sync permanently failed after', this._config.maxRetries, 'attempts for item:', item.data);
        }
      }
    }

    this.processing = false;
  }

  stop() {
    window.removeEventListener('online', this._onlineHandler);
    window.removeEventListener('offline', this._offlineHandler);
    this.processing = false;
    console.log('Background sync stopped.');
  }
}

// ZOOM CONTROLLER - Drop-in replacement with full proximity zoom support
(function() {
  'use strict';

  const DEFAULT_ZOOM             = 17;
  const DEFAULT_LOCK_DURATION_MS = 2000;
  const QUEUE_CLEANUP_AGE_MS     = 5000;

  const PROXIMITY_SOURCE         = 'proximity';
  const PROXIMITY_ZOOM_OUT_LEVEL = 17;

  class ZoomController {
    constructor(options = {}) {
      const {
        defaultZoom      = DEFAULT_ZOOM,
        lockDurationMs   = DEFAULT_LOCK_DURATION_MS,
        animationOptions = {}
      } = options;

      this.state = {
        source:      null,
        priority:    0,
        level:       defaultZoom,
        lockedUntil: 0
      };

      this.config = {
        defaultZoom,
        lockDurationMs,
        animationOptions
      };

      this.requestQueue      = [];
      this.isProcessingQueue = false;

      console.debug('[ZoomController] Initialized with defaults:', {
        defaultZoom:    this.config.defaultZoom,
        lockDurationMs: this.config.lockDurationMs
      });
    }

    /**
     * Request zoom control.
     *
     * Returns true only when THIS source has active control after the call.
     *
     * PROXIMITY SPECIAL CASE: proximity locks are held indefinitely (lockedUntil
     * = Infinity) because proximity zoom has no fixed duration — it stays active
     * until the user walks away and release() is called explicitly. Using a
     * 2-second lock caused the controller to auto-expire and zoom back out while
     * the user was still standing at the POI.
     *
     * @param {string} source   - Identifier ('proximity', 'speed', etc.)
     * @param {number} level    - Desired zoom level
     * @param {number} priority - Higher = more important (default: 1)
     * @returns {boolean} True only if this source now has active control
     */
    request(source, level, priority = 1) {
      if (!source || typeof source !== 'string') {
        console.error('[ZoomController] Invalid source:', source);
        return false;
      }
      if (!Number.isFinite(level) || level < 0) {
        console.error('[ZoomController] Invalid zoom level:', level);
        return false;
      }
      if (!Number.isFinite(priority) || priority < 0) {
        console.error('[ZoomController] Invalid priority:', priority);
        return false;
      }

      this.requestQueue.push({ source, level, priority, timestamp: Date.now() });
      console.debug(`[ZoomController] Request queued: ${source} (level: ${level}, priority: ${priority})`);

      this._processQueue();

      return this.state.source === source;
    }

    /**
     * Release zoom control.
     *
     * NOTE: This no longer calls _animateProximityZoomOut() internally.
     * The proximity module's _handleProximityZoom is responsible for triggering
     * its own zoom-out animation BEFORE calling release(). Having the controller
     * also animate caused two competing flyTo() calls that fought each other.
     *
     * The split of responsibilities is now:
     *   - Proximity module: decides WHEN to zoom in/out, triggers the animation
     *   - ZoomController: manages the lock so other zoom sources are blocked/unblocked
     */
    release(source) {
      if (!source) {
        console.warn('[ZoomController] Release called without source');
        return;
      }

      if (this.state.source === source) {
        console.debug(`[ZoomController] Authority released by ${source}`);
        this._setState({ source: null, priority: 0, lockedUntil: 0 });
        this._processQueue();
      } else {
        console.debug(
          `[ZoomController] Release ignored - ${source} does not have control ` +
          `(current: ${this.state.source || 'none'})`
        );
      }
    }

    /** Apply any pending zoom operation. */
    applyPendingZoom() {
      if (this.state.source && Number.isFinite(this.state.level)) {
        console.debug(`[ZoomController] Applying pending zoom for ${this.state.source}`);
        this._applyZoom(this.state.level);
      }
    }

    /** Get current state (returns a copy). */
    getState() {
      return { ...this.state };
    }

    /** Stop all zoom operations and clear queue. */
    stop() {
      this.requestQueue      = [];
      this.isProcessingQueue = false;
      this._setState({ source: null, priority: 0, lockedUntil: 0 });
      console.log('[ZoomController] Stopped and reset');
    }

    // ── PRIVATE ───────────────────────────────────────────────────────────────

    _processQueue() {
      if (this.isProcessingQueue || this.requestQueue.length === 0) return;
      this.isProcessingQueue = true;

      try {
        const now = Date.now();

        // Expire active lock if time has passed.
        // Proximity locks use Infinity so they never auto-expire here.
        const hasActiveLock = this.state.lockedUntil === Infinity
          ? true
          : now < this.state.lockedUntil;

        if (!hasActiveLock && this.state.source) {
          console.debug('[ZoomController] Active lock expired, releasing');
          this._setState({ source: null, priority: 0, lockedUntil: 0 });
        }

        if (!this.state.source) {
          // No current holder — grant to highest priority queued request
          const next = this.requestQueue.reduce((best, cur) =>
            cur.priority > best.priority ? cur : best
          , this.requestQueue[0]);

          if (next) {
            console.debug(`[ZoomController] Granting control to ${next.source} (priority: ${next.priority})`);

            // Proximity holds indefinitely; all other sources use lockDurationMs.
            const lockUntil = next.source === PROXIMITY_SOURCE
              ? Infinity
              : now + this.config.lockDurationMs;

            this._setState({
              source:      next.source,
              priority:    next.priority,
              level:       next.level,
              lockedUntil: lockUntil
            });

            // Remove the granted entry from the queue so it can't re-fire.
            this.requestQueue = this.requestQueue.filter(r => r !== next);

            // Only _applyZoom for non-proximity sources. Proximity module
            // calls map.flyTo() directly with its own pan-toward-POI logic,
            // so letting the controller also call flyTo would cause a conflict.
            if (next.source !== PROXIMITY_SOURCE) {
              this._applyZoom(next.level);
            }
          }
        } else if (hasActiveLock) {
          // Active lock — only a strictly higher priority can override
          const best = this.requestQueue.reduce((b, cur) =>
            cur.priority > b.priority ? cur : b
          , { priority: 0 });

          if (best.priority > this.state.priority) {
            console.debug(
              `[ZoomController] ${best.source} (priority ${best.priority}) ` +
              `overriding ${this.state.source} (priority ${this.state.priority})`
            );

            const lockUntil = best.source === PROXIMITY_SOURCE
              ? Infinity
              : now + this.config.lockDurationMs;

            this._setState({
              source:      best.source,
              priority:    best.priority,
              level:       best.level,
              lockedUntil: lockUntil
            });

            // Remove the granted entry from the queue.
            this.requestQueue = this.requestQueue.filter(r => r !== best);

            if (best.source !== PROXIMITY_SOURCE) {
              this._applyZoom(best.level);
            }
          }
        }

        // Clean stale queue entries (non-proximity only; proximity entries are
        // one-shot and removed when granted, so this is mostly for speed/other).
        const before = this.requestQueue.length;
        this.requestQueue = this.requestQueue.filter(
          req => req.timestamp > now - QUEUE_CLEANUP_AGE_MS
        );
        if (before !== this.requestQueue.length) {
          console.debug(`[ZoomController] Cleaned ${before - this.requestQueue.length} stale requests`);
        }
      } catch (error) {
        console.error('[ZoomController] Error processing queue:', error);
      } finally {
        this.isProcessingQueue = false;
      }
    }

    _setState(newState) {
      this.state = { ...this.state, ...newState };
    }

    /**
     * Apply zoom to the map (used for non-proximity sources).
     * Proximity module handles its own flyTo with pan-toward-POI logic.
     */
    _applyZoom(level, options = {}) {
      if (!window.map) {
        console.error('[ZoomController] Cannot apply zoom - map not found');
        return;
      }
      if (!Number.isFinite(level)) {
        console.error('[ZoomController] Cannot apply zoom - invalid level:', level);
        return;
      }

      try {
        const center = window.map.getCenter?.();
        if (!center || !isFinite(center.lat) || !isFinite(center.lng)) {
          console.warn('[ZoomController] Cannot apply zoom - invalid map center');
          return;
        }

        window.map.flyTo(center, level, {
          duration:      1.2,
          easeLinearity: 0.15,
          noMoveStart:   true,
          ...this.config.animationOptions,
          ...options
        });

        console.debug(`[ZoomController] Applied zoom ${level} for ${this.state.source}`);
      } catch (error) {
        console.error('[ZoomController] Failed to apply zoom:', error);
      }
    }

    /**
     * Kept for backwards compatibility — external code may call this directly.
     * The proximity module no longer triggers this internally (release() no
     * longer calls it either) to avoid double-animation races.
     */
    _animateProximityZoomOut() {
      if (!window.map?.flyTo || window.isMapInteracting) return;
      try {
        const currentZoom = window.map.getZoom?.();
        if (!isFinite(currentZoom)) return;
        if (Math.abs(currentZoom - PROXIMITY_ZOOM_OUT_LEVEL) < 0.5) return;

        const center = window.map.getCenter?.();
        if (!center || !isFinite(center.lat) || !isFinite(center.lng)) return;

        window.map.flyTo(center, PROXIMITY_ZOOM_OUT_LEVEL, {
          duration:      1.4,
          easeLinearity: 0.15,
          noMoveStart:   true,
          ...this.config.animationOptions
        });

        console.debug('[ZoomController] Proximity zoom-out animation triggered');
      } catch (err) {
        console.warn('[ZoomController] Proximity zoom-out animation failed:', err);
      }
    }
  }

  // ── INIT & EXPORT ──────────────────────────────────────────────────────────
  if (typeof window !== 'undefined') {
    window.ZoomController = ZoomController;
    window.zoomController = new ZoomController();
    console.log('[ZoomController] Ready - Instance available at window.zoomController');
  } else {
    console.warn('[ZoomController] Window object not available');
  }
})();

// INITIALIZE 
const enterpriseCacheManager = new EnterpriseCacheManager();
const enterpriseSecurityManager = new EnterpriseSecurityManager();
const enterprisePerformanceMonitor = new EnterprisePerformanceMonitor();
const enterpriseBackgroundSync = new EnterpriseBackgroundSync();

document.addEventListener('DOMContentLoaded', () => {
  enterpriseCacheManager.init();
  enterpriseSecurityManager.init();
  enterprisePerformanceMonitor.startMonitoring();
});

const CONFIG = {
    // --- PROXIMITY & AUTO-OPEN SETTINGS ---
    DISTANCE_THRESHOLD: 20, // (feet) How close (in feet) you need to be to a location for the 'Arrived.' status or auto-open trigger.
    PROXIMITY_THRESHOLD: 50, // (feet) Another threshold value, used for triggering proximity checks or UI elements related to nearby locations.
    
    // --- GPS NOISE & MOVEMENT FILTERING ---
    JITTER_THRESHOLD: 5, // (meters) Distance threshold to filter out small GPS jumps that might be noise rather than real movement.
    MICRO_MOVEMENT_THRESHOLD: 0.3, // (meters) Very small distance threshold, used for very slow movement detection or fine-grained smoothing at low speeds.
    
    // --- BACKGROUND & INACTIVITY HANDLING ---
    BACKGROUND_THRESHOLD: 25000, // (milliseconds) Time limit for how long background GPS updates might be considered valid or how long a background state persists.
    DEBOUNCE_TIME: 300, // (milliseconds) Minimum time to wait between processing new GPS fixes, preventing overwhelming the system with rapid updates.
    INACTIVITY_TIMEOUT: 29000, // (milliseconds) Time after which the system considers the GPS session inactive if no new fixes arrive, potentially triggering a timeout state.
    
    // --- TIMING & INTERVALS ---
    STATIONARY_CHECK_INTERVAL: 2500, // (milliseconds) How often to check if the user has stopped moving (become stationary).
    SIGNIFICANT_MOVEMENT_COOLDOWN: 2000, // (milliseconds) Cool-down period after a significant movement before certain actions can repeat.
    RETRY_DELAY: 1000, // (milliseconds) Time to wait before retrying an operation that failed (e.g., fetching data, connecting to GPS).
    
    // --- DATA BUFFERING & LIMITS ---
    MAX_BUFFER_SIZE: 8, // Number of recent GPS positions or calculated values to keep in a buffer for smoothing or prediction.
    MAX_RETRIES: 3, // Maximum number of times to retry an operation before giving up.
        
    // --- HEADING/BEARING ACCURACY ---
    BEARING_TOLERANCE: 30, // (degrees) Allowable difference (in degrees) between the reported compass bearing and the calculated movement direction before correcting or ignoring the bearing.

      DEBOUNCE_MS: 50,
      GPS_TIMEOUT_MS: 30000,
      BATTERY_CACHE_TTL_MS: 60000,
      STATIONARY_THRESHOLD: 0.8,
      STATIONARY_LOCK_THRESHOLD: 0.3,
      STATIONARY_CONFIRMATION_MS: 2000,
      LARGE_DISTANCE_THRESHOLD: 50,
      MICRO_MOVEMENT_SEARCH_THRESHOLD: 8,
      ACCURACY_IMPROVEMENT_RATIO: 0.6,
      DEBUG: false
};

let map, userMarker, markerClusterGroup;
let currentLocationIndex = 0;
let visitedLocations = [];
let gameLocations = [];
let cachedElements = {};
let isLocationHuntVisible = false;
let lastFunctionCall = 0; 
let lastVisitedLocationId = null;
let lastKnownPosition = null;
let stationaryBuffer = [];
let stationaryCount = 0;
let lastSmoothedPosition = null;
let lastHiddenTime = 0;
let retryCount = 0;
let inactivityTimer;
let loadingMessageMinDisplayTime = 0;
let lastCenteringTime = 0;
let isNearLocation = false;
let lastMapUpdateTime = 0;
let lastSignificantMovement = Date.now();
let lastPositionForJitter = null;

// GLOBAL STATE (used in updateUserLocation)
window.followUser = true;
window.isMapInteracting = false;
window.lastPosition = null;
window.positionBuffer = [];
window._isPanningViewport = false;
window.lastVelocity = { lat: 0, lng: 0 };
window.isStationary = false;
window.stationaryStartTime = null;
window.stationaryCheckTimeout = null;
window.lastUpdateTime = null;
window.animationFrameId = null;
window._didPrefetch19 = false; 
window._rafPending = false;
window._driftHysteresisCounter = window._driftHysteresisCounter || 0;
window.mapFatalError = window.mapFatalError || false;

let zoomState = {
    currentTier: 'exploration',
    lastTierChange: 0,
    hysteresisBuffer: [],
    proximityOverride: false
};

let locationTriggerState = {
    cooldowns: new Map(),
    dwellTimers: new Map(),
    lastBearing: null,
    approachingLocations: new Set(),
    lastVibrations: new Map()
};

let accessibilityState = {
    highContrast: localStorage.getItem('highContrast') === 'true',
    lastAnnouncement: '',
    proximityAlerts: new Set()
};

function cacheElements() {
    cachedElements = {
        distanceBox: document.getElementById('distanceBox'),
        recenterButton: document.getElementById('recenterButton'),
        returnButton: document.getElementById('returnButton'),
        tipsButton: document.getElementById('tipsButton'),
        lochuntContainer: document.querySelector('.lochunt-container'),
        additionalInfoContainer: document.querySelector('.additional-info-container'),
        accessibilityAnnouncements: document.getElementById('accessibility-announcements'),
        proximityAnnouncements: document.getElementById('proximity-announcements'),
        contrastToggle: document.getElementById('contrastToggle')
    };
}

function announceToScreenReader(message, priority = 'polite') {
    const element = priority === 'polite' ? 
        cachedElements.proximityAnnouncements : 
        cachedElements.accessibilityAnnouncements;
    
    if (element && message !== accessibilityState.lastAnnouncement) {
        element.textContent = message;
        accessibilityState.lastAnnouncement = message;
        
        setTimeout(() => {
            if (element.textContent === message) {
                element.textContent = '';
            }
        }, 1000);
    }
}

function toggleHighContrast() {
    accessibilityState.highContrast = !accessibilityState.highContrast;
    localStorage.setItem('highContrast', accessibilityState.highContrast);
    
    if (accessibilityState.highContrast) {
        document.body.classList.add('high-contrast');
        announceToScreenReader('High contrast mode enabled');
    } else {
        document.body.classList.remove('high-contrast');
        announceToScreenReader('High contrast mode disabled');
    }
}

function calculateBearing(from, to) {
    const lat1 = from.lat * Math.PI / 180;
    const lat2 = to.lat * Math.PI / 180;
    const deltaLng = (to.lng - from.lng) * Math.PI / 180;
    
    const y = Math.sin(deltaLng) * Math.cos(lat2);
    const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(deltaLng);
    
    const bearing = Math.atan2(y, x) * 180 / Math.PI;
    return (bearing + 360) % 360;
}

function isApproachingLocation(userPos, userBearing, locationPos) {
    // Always trigger within the distance threshold - you're at the location
    const distanceInFeet = calculateDistance(userPos, locationPos) * 3.28084; // Convert to feet
    if (distanceInFeet <= CONFIG.DISTANCE_THRESHOLD) return true;
    
    // If we don't have bearing data, be permissive
    if (!userBearing) return true;
    
    const bearingToLocation = calculateBearing(userPos, locationPos);
    const bearingDiff = Math.abs(userBearing - bearingToLocation);
    const normalizedDiff = Math.min(bearingDiff, 360 - bearingDiff);
    
    return normalizedDiff <= CONFIG.BEARING_TOLERANCE;
}

const trackedTimeouts = new Set();

function createTrackedTimeout(callback, delay) {
    let id;
    const wrappedCallback = () => {
        trackedTimeouts.delete(id);
        callback();
    };
    id = setTimeout(wrappedCallback, delay);
    trackedTimeouts.add(id);
    return id;
}

// Add a cleanup utility
function clearAllTrackedTimeouts() {
    trackedTimeouts.forEach(clearTimeout);
    trackedTimeouts.clear();
}

function isValidPosition(pos) {
    return pos && 
           typeof pos.lat === 'number' && 
           typeof pos.lng === 'number' && 
           !isNaN(pos.lat) && 
           !isNaN(pos.lng);
}

function setupMemoryManagement({
    markerClusterGroup      = window.markerClusterGroup,
    animationFrameId        = window.animationFrameId,
    stationaryCheckTimeout  = window.stationaryCheckTimeout,
    inactivityTimer         = window.inactivityTimer,
    positionWatchId         = window.positionWatchId,
    gameLocations           = window.gameLocations,
    positionBuffer          = window.positionBuffer,
    stationaryBuffer        = window.stationaryBuffer,
    visitedLocations        = window.visitedLocations,
    locationTriggerState    = window.locationTriggerState,
    accessibilityState      = window.accessibilityState,
    activePopups            = window.activePopups,
    lastVelocity            = window.lastVelocity,
    lastSmoothedPosition    = window.lastSmoothedPosition,
    stationaryCount         = window.stationaryCount,
} = {}) {

    const cleanupTasks  = [];
    const trackedTimers = new Set();
    const eventListeners = [];

    /* safe timer helpers  */
    const createTrackedTimeout = (cb, delay, ...args) => {
        const id = setTimeout(() => {
            trackedTimers.delete(id);
            cb(...args);
        }, delay);
        trackedTimers.add(id);
        return id;
    };
    const createTrackedInterval = (cb, interval) => {
        const id = setInterval(cb, interval);
        trackedTimers.add(id);
        return id;
    };

    /* safe event helper */
    const trackEventListener = (el, ev, h, opts) => {
        el.addEventListener(ev, h, opts);
        eventListeners.push({ element: el, event: ev, handler: h, options: opts });
    };

    /* core cleanup routines */
    const cleanupAudioResources = () => {
        try {
            document.querySelectorAll('audio').forEach(audio => {
                audio.pause();
                audio.src = '';
                audio.load();
                audio.remove();
            });
        } catch (e) {
            console.warn('Audio cleanup failed:', e);
        }
    };

    const cleanupMapResources = () => {
        try {
            if (markerClusterGroup) markerClusterGroup.clearLayers();
            if (window.animationFrameId !== null && window.animationFrameId !== undefined) {
                cancelAnimationFrame(window.animationFrameId);
                window.animationFrameId = null;
            }
            if (window.stationaryCheckTimeout) {
                clearTimeout(window.stationaryCheckTimeout);
                window.stationaryCheckTimeout = null;
            }
            if (window.inactivityTimer) {
                clearTimeout(window.inactivityTimer);
                window.inactivityTimer = null;
            }
            trackedTimers.forEach(id => { 
                clearTimeout(id); 
                clearInterval(id); 
            });
            trackedTimers.clear();
            if (window.positionWatchId !== undefined && window.positionWatchId !== null) {
                navigator.geolocation.clearWatch(window.positionWatchId);
                window.positionWatchId = null;
            }
        } catch (e) {
            console.warn('Map resource cleanup failed:', e);
        }
    };

    const cleanupDOMAndData = () => {
        try {
            // DOM cleanup
            document.querySelectorAll('.popup-overlay, .modal, .navigation-tips-overlay, .source-info-content')
                    .forEach(el => el.remove());

            // Event listeners cleanup
            eventListeners.forEach(({ element, event, handler, options }) => {
                try {
                    element.removeEventListener(event, handler, options);
                } catch (e) {
                    console.warn('Failed to remove event listener:', e);
                }
            });
            eventListeners.length = 0;

            // Array cleanup - check if they exist and are arrays
            if (Array.isArray(window.gameLocations)) {
                window.gameLocations.length = 0;
            }
            if (Array.isArray(window.positionBuffer)) {
                window.positionBuffer.length = 0;
            }
            if (Array.isArray(window.stationaryBuffer)) {
                window.stationaryBuffer.length = 0;
            }
            if (Array.isArray(window.visitedLocations)) {
                window.visitedLocations.length = 0;
            }

            // Map/Set cleanup - check if they exist and have the clear method
            if (window.locationTriggerState) {
                if (window.locationTriggerState.cooldowns?.clear) {
                    window.locationTriggerState.cooldowns.clear();
                }
                if (window.locationTriggerState.dwellTimers?.clear) {
                    window.locationTriggerState.dwellTimers.clear();
                }
                if (window.locationTriggerState.approachingLocations?.clear) {
                    window.locationTriggerState.approachingLocations.clear();
                }
                if (window.locationTriggerState.lastVibrations?.clear) {
                    window.locationTriggerState.lastVibrations.clear();
                }
            }
            
            if (window.accessibilityState?.proximityAlerts?.clear) {
                window.accessibilityState.proximityAlerts.clear();
            }
            
            if (window.activePopups?.clear) {
                window.activePopups.clear();
            }

            // Scalar cleanup
            if (window.lastVelocity && typeof window.lastVelocity === 'object') {
                Object.keys(window.lastVelocity).forEach(k => window.lastVelocity[k] = 0);
            }
            window.lastSmoothedPosition = null;
            window.stationaryCount = 0;
            
        } catch (e) {
            console.warn('DOM and data cleanup failed:', e);
        }
    };

    /* register built-in tasks */
    const registerCleanupTask = (t) => { cleanupTasks.push(t); };
    registerCleanupTask(disposeMapLoop); 
    registerCleanupTask(cleanupAudioResources);
    registerCleanupTask(cleanupMapResources);
    registerCleanupTask(cleanupDOMAndData);

    /* execute */
    const executeCleanup = () => cleanupTasks.forEach(t => {
        try { 
            t(); 
        } catch (e) { 
            console.error('Cleanup task failed:', e); 
        }
    });

    const onVisibility = () => { 
        if (document.hidden) cleanupAudioResources(); 
    };
    const onBeforeUnload = () => executeCleanup();

    trackEventListener(document, 'visibilitychange', onVisibility);
    trackEventListener(window, 'beforeunload', onBeforeUnload);

    /* expose */
    window.performCleanup = executeCleanup;

    /* optional full shutdown */
    const shutdown = () => {
        executeCleanup();
        document.removeEventListener('visibilitychange', onVisibility);
        window.removeEventListener('beforeunload', onBeforeUnload);
        cleanupTasks.length = 0;
        trackedTimers.clear();
        eventListeners.length = 0;
        delete window.performCleanup;
    };

    return {
        registerCleanupTask,
        executeCleanup,
        createTrackedTimeout,
        createTrackedInterval,
        trackEventListener,
        shutdown,
    };
}

/* usage */
const memoryManager = setupMemoryManagement({});

function initMap() {
    // Clean up any existing timers/RAF before reinitializing
    disposeMapLoop();

    // Clear stale session storage keys that could cause position drift
    ['lastKnownPos', 'routeHistory', 'userPrefs'].forEach(k => {
        try {
            localStorage.removeItem(k);
            sessionStorage.removeItem(k);
        } catch (_) {}
    });

    // Clear any stale service worker caches (non-blocking)
    if ('caches' in window) {
        caches.keys()
            .then(keys => Promise.all(keys.map(k => caches.delete(k))))
            .catch(() => {});
    }

    // Create map instance
    map = L.map('map', {
        zoomControl: false,
        attributionControl: false,
        zoomSnap: 0.1,
        zoomDelta: 0.5,
        wheelDebounceTime: 100,
        tapTolerance: 15,
        bounceAtZoomLimits: false,
        preferCanvas: true,
        renderer: L.canvas(),
        fadeAnimation: false,
        zoomAnimationThreshold: 4,
        markerZoomAnimation: false
    }).setView([46.392410, -94.636230], 9);

    // Tile layer
    window.currentTileLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        minZoom: 7,
        maxZoom: 19,
        attribution: '',
        updateWhenIdle: true,
        updateWhenZooming: false,
        keepBuffer: 2,
        className: 'map-tiles'
    }).addTo(map);

    // Marker cluster group
    markerClusterGroup = L.markerClusterGroup({
        showCoverageOnHover: false,
        zoomToBoundsOnClick: true,
        spiderfyOnMaxZoom: true,
        animate: false,
        chunkedLoading: true,
        chunkProgress: updateLoadingStatus,
        maxClusterRadius: z => z > 16 ? 40 : 80,
        iconCreateFunction: c => L.divIcon({
            html: `<div><span>${c.getChildCount()}</span></div>`,
            className: 'marker-cluster-custom',
            iconSize: [40, 40]
        })
    }).addTo(map);

    // User position marker
    userMarker = L.marker([0, 0], {
        icon: L.divIcon({
            className: 'user-marker',
            html: '<div class="user-marker-icon"></div>',
            iconSize: [20, 20],
            iconAnchor: [10, 10]
        }),
        zIndexOffset: 1000
    }).addTo(map);

    // Pre-apply GPU compositing hints so they're ready before first GPS fix
    requestAnimationFrame(() => {
        const el = userMarker.getElement?.();
        if (el) {
            el.style.willChange = 'transform';
            el.style.backfaceVisibility = 'hidden';
            el.style.transform = 'translateZ(0)';
            window._markerStylesOptimized = true;
        }
    });

    // Show loading screen and begin GPS acquisition
    showLoadingMessage();

    if ('geolocation' in navigator) {
        const opts = { enableHighAccuracy: true, timeout: 45000, maximumAge: 0 };

        navigator.geolocation.getCurrentPosition(
            initializeUserLocation,
            // On first failure, retry once with the same options before handing
            // off to the full error handler
            () => navigator.geolocation.getCurrentPosition(
                initializeUserLocation,
                handleLocationError,
                opts
            ),
            opts
        );
    } else {
        showPopup('Geolocation Error', 'Geolocation is not supported by this browser.');
        map.flyTo([44.9778, -93.2650], 17);
        hideLoadingMessage();
    }
}

function showGPSSearchingState() {
    // Add CSS class to show searching state
    document.body.classList.add('gps-searching');
    
    // Show loading overlay if it exists
    const loadingOverlay = document.querySelector('.gps-loading-overlay');
    if (loadingOverlay) {
        loadingOverlay.style.display = 'block';
    }
    
    const searchingIndicator = document.getElementById('gps-searching-indicator');
    if (searchingIndicator) {
        searchingIndicator.style.display = 'block';
    }
    
    // Disable UI elements during search
    const disabledElements = document.querySelectorAll('[data-disabled-during-gps-search]');
    disabledElements.forEach(el => {
        el.disabled = true;
        el.classList.add('disabled');
    });
}

function hideGPSSearchingState() {
    // Remove any CSS classes that show searching state
    document.body.classList.remove('gps-searching');
    
    // Hide any loading spinners or overlays
    const loadingOverlay = document.querySelector('.gps-loading-overlay');
    if (loadingOverlay) {
        loadingOverlay.style.display = 'none';
    }
    
    const searchingIndicator = document.getElementById('gps-searching-indicator');
    if (searchingIndicator) {
        searchingIndicator.style.display = 'none';
    }
    
    // Re-enable any UI elements that were disabled during search
    const disabledElements = document.querySelectorAll('[data-disabled-during-gps-search]');
    disabledElements.forEach(el => {
        el.disabled = false;
        el.classList.remove('disabled');
    });
}

let _idleProximityCheckInterval;

function startIdleProximityCheck() {
  if (_idleProximityCheckInterval) {
    console.log("Idle proximity check is already running.");
    return; // Already running
  }

  _idleProximityCheckInterval = setInterval(() => {
    try {
      // Only run if map and data are ready
      if (!window.map || !window.gameLocations?.length || !window.userMarker) {
          return; // Not ready yet, skip this iteration
      }
      // Trigger the existing proximity logic in updateDistanceBox
      updateDistanceBox();
    } catch (err) {
      console.warn('Idle proximity check error:', err);
    }
  }, 10000); // Run every 10 seconds
  console.log("Idle proximity check started (every 10 seconds).");
}

function stopIdleProximityCheck() {
  if (_idleProximityCheckInterval) {
    clearInterval(_idleProximityCheckInterval);
    _idleProximityCheckInterval = null;
    console.log("Idle proximity check stopped.");
  }
}
        
function updateLoadingStatus(processed, total, elapsed) {
    if (processed === total) {
        console.log(`Loaded ${processed} markers in ${elapsed.toFixed(2)}ms`);
    }
}

// PWA Install Banner functionality
let deferredPrompt;
let pwaInstallBanner, closePwaBanner, cancelPwaBanner, installPwaButton;

// Detect device type
function getDeviceType() {
    const userAgent = navigator.userAgent || navigator.vendor || window.opera;
    
    if (/iPad|iPhone|iPod/.test(userAgent) && !window.MSStream) {
        return 'ios';
    } else if (/android/i.test(userAgent)) {
        return 'android';
    } else if (/Windows Phone/i.test(userAgent)) {
        return 'windows';
    }
    return 'desktop';
}

// Check if the app is running as a PWA
function isRunningAsPWA() {
    // Standard PWA detection
    if (window.matchMedia('(display-mode: standalone)').matches) {
        return true;
    }
    
    // iOS Safari standalone mode
    if (window.navigator.standalone === true) {
        return true;
    }
    
    // Android TWA (Trusted Web Activity)
    if (document.referrer.includes('android-app://')) {
        return true;
    }
    
    // Check for PWA-specific URL parameters
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.get('utm_source') === 'pwa' || urlParams.get('source') === 'pwa') {
        return true;
    }
    
    return false;
}

// Check if the app can be installed
function canInstallPWA() {
    const deviceType = getDeviceType();
    
    // Android: Check for beforeinstallprompt support or Chrome
    if (deviceType === 'android') {
        return 'beforeinstallprompt' in window || /Chrome/.test(navigator.userAgent);
    }
    
    // iOS: Check for Safari and iOS version
    if (deviceType === 'ios') {
        const isIOS13OrLater = /OS 1[3-9]_|OS [2-9][0-9]_/.test(navigator.userAgent);
        const isSafari = /Safari/.test(navigator.userAgent) && !/CriOS|FxiOS|EdgiOS/.test(navigator.userAgent);
        return isIOS13OrLater && isSafari;
    }
    
    // Desktop: Check for supported browsers
    if (deviceType === 'desktop') {
        return 'beforeinstallprompt' in window;
    }
    
    return false;
}

// Check if the app is already installed
async function isAppInstalled() {
    if (isRunningAsPWA()) {
        return true;
    }
    
    const deviceType = getDeviceType();
    
    // For newer browsers that support getInstalledRelatedApps
    if ('getInstalledRelatedApps' in navigator) {
        try {
            const relatedApps = await navigator.getInstalledRelatedApps();
            return relatedApps.length > 0;
        } catch (error) {
            console.log('getInstalledRelatedApps not supported:', error);
        }
    }
    
    // iOS-specific checks
    if (deviceType === 'ios') {
        // Check if added to home screen previously
        if (window.navigator.standalone !== undefined) {
            // If standalone is false but was previously true, might be installed
            const wasInstalled = localStorage.getItem('pwa-ios-installed');
            if (wasInstalled === 'true') {
                return true;
            }
        }
    }
    
    // Check for service worker that indicates installation
    if ('serviceWorker' in navigator) {
        try {
            const registrations = await navigator.serviceWorker.getRegistrations();
            const hasAppScope = registrations.some(registration => 
                registration.scope.includes('/app/') || registration.scope === `${window.location.origin}/`
            );
            if (hasAppScope) return true;
        } catch (error) {
            console.log('Service worker check failed:', error);
        }
    }
    
    return false;
}

// Get device-specific install instructions
function getInstallInstructions() {
    const deviceType = getDeviceType();
    
    switch (deviceType) {
        case 'ios':
            return {
                title: 'Install App',
                instructions: 'Tap the Share button <span class="share-icon">⬆️</span> then "Add to Home Screen"',
                showNativeButton: false
            };
        case 'android':
            return {
                title: 'Install App',
                instructions: deferredPrompt ? 'Tap "Install" to add this app to your home screen' : 'Use your browser menu to "Add to Home Screen"',
                showNativeButton: !!deferredPrompt
            };
        default:
            return {
                title: 'Install App',
                instructions: deferredPrompt ? 'Click "Install" to add this app to your desktop' : 'Use your browser menu to install this app',
                showNativeButton: !!deferredPrompt
            };
    }
}

// Update banner content based on device
function updateBannerContent() {
    if (!pwaInstallBanner) return;
    
    const instructions = getInstallInstructions();
    const deviceType = getDeviceType();
    
    // Update title
    const titleElement = pwaInstallBanner.querySelector('.pwa-banner-title');
    if (titleElement) {
        titleElement.textContent = instructions.title;
    }
    
    // Update instructions
    const instructionsElement = pwaInstallBanner.querySelector('.pwa-banner-instructions');
    if (instructionsElement) {
        instructionsElement.innerHTML = instructions.instructions;
    }
    
    // Show/hide install button based on device capabilities
    if (installPwaButton) {
        if (instructions.showNativeButton) {
            installPwaButton.style.display = 'block';
            installPwaButton.textContent = deviceType === 'desktop' ? 'Install' : 'Install App';
        } else {
            installPwaButton.style.display = 'none';
        }
    }
    
    // Add device-specific styling
    pwaInstallBanner.className = `pwa-install-banner ${deviceType}`;
}

// Initialize PWA elements after DOM is loaded
async function initPWABanner() {
    // Don't show banner if app is already installed
    if (await isAppInstalled()) {
        console.log('App is already installed, not showing install banner');
        return;
    }

    // Don't show banner if device fundamentally can't install PWAs
    if (!canInstallPWA()) {
        console.log('Device cannot install PWAs, not showing banner');
        return;
    }

    const deviceType = getDeviceType();

    // For Android/Desktop: only show if browser has signaled installability
    if ((deviceType === 'android' || deviceType === 'desktop') && !deferredPrompt) {
        console.log('No deferred install prompt available; skipping banner');
        return;
    }

    // For iOS: require at least 2 visits to reduce premature prompts
    if (deviceType === 'ios') {
        const visits = parseInt(localStorage.getItem('pwaVisitCount') || '0', 10);
        localStorage.setItem('pwaVisitCount', String(visits + 1));
        if (visits < 1) {
            console.log('iOS: First visit—delaying install prompt');
            return;
        }
    }

    // Get banner elements
    pwaInstallBanner = document.getElementById('pwaInstallBanner');
    closePwaBanner = document.getElementById('closePwaBanner');
    cancelPwaBanner = document.getElementById('cancelPwaBanner');
    installPwaButton = document.getElementById('installPwaButton');

    if (!pwaInstallBanner) {
        console.warn('PWA install banner element not found');
        return;
    }

    // Ensure banner can be closed manually
    const hideBanner = () => {
        pwaInstallBanner.classList.remove('show');
    };

    // Close button handler
    const dismissBanner = () => {
        pwaInstallBanner.classList.remove('show');
        // Store dismissal in sessionStorage (only for this session)
        try {
            sessionStorage.setItem('pwaBannerDismissed', 'true');
            console.log('PWA banner dismissed for this session');
        } catch (e) {
            console.warn('Could not store PWA banner dismissal');
        }
    };

    if (closePwaBanner) {
        closePwaBanner.addEventListener('click', dismissBanner);
    }
    
    if (cancelPwaBanner) {
        cancelPwaBanner.addEventListener('click', dismissBanner);
    }

    updateBannerContent();

    // Show banner after short delay
    createTrackedTimeout(() => {
        pwaInstallBanner.classList.add('show');
        console.log('PWA install banner shown');
    }, 2000);

    // Handle install button click
    if (installPwaButton) {
        installPwaButton.addEventListener('click', async () => {
            if (deviceType === 'android' || deviceType === 'desktop') {
                if (!deferredPrompt) {
                    alert('Please use your browser menu to "Add to Home Screen" or "Install App"');
                    hideBanner();
                    return;
                }

                deferredPrompt.prompt();
                const { outcome } = await deferredPrompt.userChoice;

                if (outcome === 'accepted') {
                    console.log('User accepted the install prompt');
                    try {
                        sessionStorage.setItem('appJustInstalled', 'true');
                        localStorage.setItem('pwa-installed', 'true');
                    } catch (e) {
                        console.warn('Could not set installation flag');
                    }

                    // Show post-install notice (Android/Desktop only)
                    const notice = document.getElementById('pwaPostInstallNotice');
                    if (notice) {
                        notice.setAttribute('aria-hidden', 'false');
                        notice.classList.add('show');

                        const dismissBtn = document.getElementById('dismissPostInstall');
                        const hideNotice = () => {
                            notice.classList.remove('show');
                            notice.setAttribute('aria-hidden', 'true');
                        };

                        if (dismissBtn) {
                            dismissBtn.onclick = hideNotice;
                        }

                        // Auto-dismiss after 12 seconds
                        createTrackedTimeout(hideNotice, 12000);
                    }
                } else {
                    console.log('User dismissed the install prompt');
                }

                deferredPrompt = null;
                hideBanner();
            } else if (deviceType === 'ios') {
                // Switch to iOS instructions and hide install button
                installPwaButton.style.display = 'none';
                const instructionsElement = pwaInstallBanner.querySelector('.pwa-banner-instructions');
                if (instructionsElement) {
                    instructionsElement.innerHTML = 'Tap the Share button <span class="share-icon">⬆️</span> at the bottom of your screen, then select "Add to Home Screen"';
                    instructionsElement.style.fontSize = '14px';
                    instructionsElement.style.marginTop = '10px';
                }

                // Auto-hide after 6 seconds OR let user close manually
                createTrackedTimeout(hideBanner, 6000);
            }
        });
    }
}

// Listen for beforeinstallprompt event (mainly for Android)
window.addEventListener('beforeinstallprompt', (e) => {
    console.log('beforeinstallprompt event fired');
    // Prevent the mini-infobar from appearing on mobile
    e.preventDefault();
    // Stash the event so it can be triggered later
    deferredPrompt = e;
    
    // Update banner content now that we have the prompt
    if (pwaInstallBanner) {
        updateBannerContent();
    }
});

// Listen for app installation (mainly for Android)
window.addEventListener('appinstalled', () => {
    console.log('PWA was installed');
    try {
        localStorage.setItem('pwa-installed', 'true');
        sessionStorage.setItem('appJustInstalled', 'true');
    } catch (e) {
        console.warn('Could not set installation flag');
    }
    
    // Hide banner if it's still showing
    if (pwaInstallBanner && pwaInstallBanner.classList.contains('show')) {
        pwaInstallBanner.classList.remove('show');
    }
});

// For iOS: Listen for standalone mode changes
if (getDeviceType() === 'ios') {
    // Check if we're now in standalone mode (installed)
    if (window.navigator.standalone) {
        try {
            localStorage.setItem('pwa-ios-installed', 'true');
        } catch (e) {
            console.warn('Could not set iOS installation flag');
        }
    }
    
    // Listen for visibility changes that might indicate installation
    document.addEventListener('visibilitychange', () => {
        if (window.navigator.standalone) {
            try {
                localStorage.setItem('pwa-ios-installed', 'true');
            } catch (e) {
                console.warn('Could not set iOS installation flag');
            }
        }
    });
}

// Initialize when DOM is loaded
document.addEventListener('DOMContentLoaded', async function() {
    console.log('DOM loaded, checking PWA banner conditions');
    
    const deviceType = getDeviceType();
    console.log('Detected device type:', deviceType);
    
    try {
        if (sessionStorage.getItem('appJustInstalled') === 'true') {
            console.log('App was just installed in this session, not showing banner');
            return;
        }
    } catch (e) {
        console.warn('Could not check installation status');
    }
    
    try {
        if (sessionStorage.getItem('pwaBannerDismissed') === 'true') {
            console.log('User dismissed banner in this session');
            return;
        }
    } catch (e) {
        console.warn('Could not check banner dismissal status');
    }
    
    if (await isAppInstalled()) {
        console.log('App is already installed, not showing banner');
        return;
    }
    
    // Initialize banner
    await initPWABanner();
});
        
function showLoadingMessage() {
    const existingMessage = document.getElementById('loadingMessage');
    if (existingMessage) return;
    
    loadingMessageMinDisplayTime = Date.now() + 8000;
    
    const loadingMessage = document.createElement('div');
    loadingMessage.id = 'loadingMessage';
    loadingMessage.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        background-image: url('https://raw.githubusercontent.com/mreicher/MNThen/refs/heads/main/images/splash_screen.webp');
        background-size: cover;
        background-position: center;
        z-index: 1000;
        font-family: 'Montserrat', 'Segoe UI', 'Roboto', sans-serif;
        transition: opacity 0.5s ease;
    `;
    
    const contentContainer = document.createElement('div');
    contentContainer.style.cssText = `
        display: grid;
        grid-template-rows: auto auto 1fr auto auto;
        background-color: white;
        padding: 35px 30px;
        border-radius: 20px;
        box-shadow: 0 20px 50px rgba(0, 0, 0, 0.35), 0 2px 10px rgba(0, 0, 0, 0.2);
        width: 450px;
        height: 500px;
        text-align: center;
        backdrop-filter: blur(5px);
        border: 1px solid rgba(255, 255, 255, 0.18);
    `;
    
    const logoImage = document.createElement('img');
    logoImage.src = 'https://mnthen.com/images/logo.webp';
    logoImage.alt = 'Minnesota Then Logo';
    logoImage.style.cssText = `
        width: 180px;
        height: auto;
        margin: 0 auto 25px;
        border-radius: 12px;
        object-fit: contain;
        filter: drop-shadow(0 4px 8px rgba(0, 40, 85, 0.2));
    `;
    
    const mainTitle = document.createElement('h1');
    mainTitle.style.cssText = `
        margin: 0 0 8px 0;
        font-size: 22px;
        font-weight: 700;
        color: #002855;
        text-align: center;
        line-height: 1.2;
        letter-spacing: -0.02em;
        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
    `;
    mainTitle.textContent = 'The Museum Without Walls';
    
    const welcomeMessage = document.createElement('h2');
    welcomeMessage.style.cssText = `
        margin: 0 0 40px 0;
        font-size: 18px;
        font-weight: 500;
        color: #0066cc;
        text-align: center;
        line-height: 1.3;
        letter-spacing: 0.02em;
        opacity: 0.9;
    `;
    welcomeMessage.textContent = 'Where Every Step Tells a Story';
    
    const statusTextContainer = document.createElement('div');
    statusTextContainer.style.cssText = `
        min-height: 60px;
        display: flex;
        align-items: center;
        justify-content: center;
        margin-bottom: 20px;
    `;
    
    const statusText = document.createElement('p');
    statusText.id = 'loadingStatusText';
    statusText.style.cssText = `
        margin: 0;
        font-size: 18px;
        font-weight: 500;
        text-align: center;
        color: #0077dd;
        line-height: 1.4;
        animation: pulse 2s infinite;
        letter-spacing: 0.01em;
    `;
    statusText.textContent = 'Location found, proceeding to stabilization...';
    statusTextContainer.appendChild(statusText);
    
    const progressContainer = document.createElement('div');
    progressContainer.style.cssText = `
        width: 100%;
        height: 10px;
        background-color: rgba(0, 51, 102, 0.08);
        border-radius: 10px;
        overflow: hidden;
        margin-bottom: 12px;
        box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.12);
    `;
    
    const progressBar = document.createElement('div');
    progressBar.id = 'loadingProgressBar';
    progressBar.style.cssText = `
        height: 100%;
        width: 0%;
        background: linear-gradient(90deg, #0066cc, #0099ff, #00aaff, #0099ff, #0066cc);
        background-size: 200% auto;
        border-radius: 10px;
        transition: width 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
        box-shadow: 0 0 10px rgba(0, 120, 255, 0.6);
        animation: gradientShift 3s ease infinite;
    `;
    
    progressContainer.appendChild(progressBar);
    
    const noteContainer = document.createElement('div');
    noteContainer.style.cssText = `
        min-height: 50px;
        display: flex;
        align-items: center;
        justify-content: center;
    `;
    
    const loadingNote = document.createElement('p');
    loadingNote.style.cssText = `
        margin: 0;
        font-size: 16px;
        color: #555;
        font-weight: 500;
        opacity: 0.8;
    `;
    loadingNote.textContent = 'Preparing your experience.';
    noteContainer.appendChild(loadingNote);
    
    contentContainer.appendChild(logoImage);
    contentContainer.appendChild(mainTitle);
    contentContainer.appendChild(welcomeMessage);
    contentContainer.appendChild(statusTextContainer);
    contentContainer.appendChild(progressContainer);
    contentContainer.appendChild(noteContainer);
    
    loadingMessage.appendChild(contentContainer);
    document.body.appendChild(loadingMessage);
    
    const totalDuration = 10000;
    const updateInterval = 100;
    const steps = totalDuration / updateInterval;
    let progress = 0;
    
    const animations = [
        "Initializing map data...",
        "Processing location coordinates...",
        "Preparing exhibit data...",
        "Calibrating view perspective...",
        "Loading nearby points of interest...",
        "Optimizing content for your location...",
        "Finalizing your experience..."
    ];
    
    const progressInterval = setInterval(() => {
        progress += (100 / steps);
        
        if (progressBar) {
            progressBar.style.width = `${Math.min(progress, 100)}%`;
        }
        
        if (statusText) {
            const animationIndex = Math.min(
                Math.floor(progress / (100 / animations.length)),
                animations.length - 1
            );
            statusText.textContent = animations[animationIndex];
        }
        
        if (progress >= 100) {
            clearInterval(progressInterval);
            tryHideLoadingMessage();
        }
    }, updateInterval);
    
    loadingMessage.dataset.progressInterval = progressInterval;
}

function tryHideLoadingMessage() {
    if (Date.now() >= loadingMessageMinDisplayTime) {
        fadeOutLoadingMessage();
    } else {
        const timeRemaining = loadingMessageMinDisplayTime - Date.now();
        setTimeout(fadeOutLoadingMessage, timeRemaining + 100);
    }
}

function fadeOutLoadingMessage() {
    const loadingMessage = document.getElementById('loadingMessage');
    if (!loadingMessage) return;
    
    if (loadingMessage.dataset.progressInterval) {
        clearInterval(parseInt(loadingMessage.dataset.progressInterval));
    }
    
    const progressBar = document.getElementById('loadingProgressBar');
    if (progressBar) {
        progressBar.style.width = '100%';
    }
    
    const distanceBox = cachedElements.distanceBox || document.getElementById('distanceBox');
    if (distanceBox) {
        distanceBox.classList.add('show');
    }
    
    loadingMessage.style.opacity = '0';
    setTimeout(() => {
        if (loadingMessage && loadingMessage.parentNode) {
            loadingMessage.parentNode.removeChild(loadingMessage);
        }
    }, 500);
}

function hideLoadingMessage() {
    tryHideLoadingMessage();
}

function updateAccuracyIndicator(accuracy) {
    const indicator = document.getElementById('accuracyIndicator');
    indicator.style.backgroundColor = accuracy < 20 ? '#4CAF50' : 
                                     accuracy < 50 ? '#FF9800' : 
                                     '#F44336';
}

function initializeUserLocation(position) {
    console.log('Initializing user location:', {
        lat: position?.coords?.latitude,
        lng: position?.coords?.longitude,
        accuracy: position?.coords?.accuracy
    });
    
    // Validate position object
    if (!position?.coords) {
        console.error('Invalid initial position - missing coords');
        handleLocationError(new Error('Invalid initial position'));
        return;
    }
    
    const { latitude: lat, longitude: lng, accuracy, heading, speed } = position.coords;
    
    // Validate coordinates
    if (isNaN(lat) || isNaN(lng)) {
        console.error('Invalid coordinates (NaN):', { lat, lng });
        handleLocationError(new Error('Invalid initial coordinates'));
        return;
    }
    
    // Validate coordinate ranges
    if (Math.abs(lat) > 90 || Math.abs(lng) > 180) {
        console.error('Out-of-range coordinates:', { lat, lng });
        handleLocationError(new Error('Coordinates out of valid range'));
        return;
    }
    
    // Warn if accuracy is poor but continue
    if (accuracy > 100) {
        console.warn(`Initial position has poor accuracy: ${accuracy.toFixed(0)}m`);
        announceToScreenReader?.(`Location acquired with ${accuracy.toFixed(0)} meter accuracy. Map loading.`);
    } else {
        announceToScreenReader?.('Location acquired. Map ready for navigation.');
    }
    
    try {
        // Set marker position
        if (userMarker) {
            userMarker.setLatLng([lat, lng]);
            console.debug('User marker positioned');
        } else {
            console.warn('User marker not initialized');
        }
        
        // Set initial map view
        if (map) {
            const initialZoom = 17;
            map.setView([lat, lng], initialZoom, { animate: false });
            console.debug(`Map view set to [${lat.toFixed(6)}, ${lng.toFixed(6)}] at zoom ${initialZoom}`);
        } else {
            throw new Error('Map not initialized');
        }
        
        // Initialize position buffer with seed position
        if (typeof seedPositionBuffer === 'function') {
            const seedPos = {
                lat,
                lng,
                accuracy,
                timestamp: position.timestamp || Date.now(),
                heading: heading ?? null,
                speedMPS: speed || 0
            };
            seedPositionBuffer(seedPos);
            console.debug('Position buffer seeded');
        }
        
        // Hide loading UI
        hideLoadingMessage?.();
        
        // Start hunt/game logic
        if (typeof startHunt === 'function') {
            startHunt();
            console.debug('Hunt started');
        } else {
            console.warn('startHunt function not available');
        }
        
        // Start proximity monitoring
        if (typeof startIdleProximityCheck === 'function') {
            startIdleProximityCheck();
            console.debug('Idle proximity check started');
        }
        
        // Animate distance box
        const distBox = cachedElements?.distanceBox ?? document.getElementById('distanceBox');
        if (distBox) {
            distBox.classList.add('pulse');
            setTimeout(() => distBox.classList.remove('pulse'), 3000);
        }
        
        console.log('User location initialization complete');
        
        // START WATCH AFTER ALL INITIALIZATION
        setTimeout(() => {
            const watchId = startPositionUpdates();
            if (watchId === null) {
                console.warn('Failed to start position updates');
            }
        }, 0); // Ensures all state is ready before watch begins
        
    } catch (err) {
        console.error('Error during location initialization:', err);
        handleLocationError(err);
        
        // Attempt recovery
        setTimeout(() => {
            console.debug('Attempting to recover from initialization error');
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    initializeUserLocation,
                    handleLocationError,
                    { enableHighAccuracy: true, timeout: 15000, maximumAge: 0 }
                );
            }
        }, 2000);
    }
}

let onlineListenerAdded = false;
let onlineRestartTimeout = null;

function startPositionUpdates() {
    try {
        const startWatch = () => navigator.geolocation.watchPosition(
            handlePositionUpdate,
            handleLocationError,
            { enableHighAccuracy: true, maximumAge: 1000, timeout: 10000 }
        );
        
        // Clear any existing watch
        if (window.positionWatchId !== undefined && window.positionWatchId !== null) {
            navigator.geolocation.clearWatch(window.positionWatchId);
        }
        
        window.positionWatchId = startWatch();
        
        // Register listeners only once per page load
        if (!onlineListenerAdded) {
            // Restart geolocation when network returns
            window.addEventListener('online', () => {
                console.debug('Online event detected - scheduling position watch restart');
                
                if (onlineRestartTimeout) {
                    clearTimeout(onlineRestartTimeout);
                }
                
                onlineRestartTimeout = setTimeout(() => {
                    if (window.positionWatchId !== null) {
                        navigator.geolocation.clearWatch(window.positionWatchId);
                    }
                    window.positionWatchId = startWatch();
                    console.debug('Position watch restarted after online event');
                    onlineRestartTimeout = null;
                }, 500); // Allow network to stabilize
            });
            
            // Clean up on offline: clear watch + cancel pending restart
            window.addEventListener('offline', () => {
                if (onlineRestartTimeout) {
                    clearTimeout(onlineRestartTimeout);
                    onlineRestartTimeout = null;
                    console.debug('Cancelled pending position watch restart (offline)');
                }
                
                if (window.positionWatchId !== null) {
                    navigator.geolocation.clearWatch(window.positionWatchId);
                    window.positionWatchId = null;
                    console.debug('Cleared position watch on offline event');
                }
            });
            
            // Prevent background battery drain
            window.addEventListener('beforeunload', () => {
                if (window.positionWatchId !== null) {
                    navigator.geolocation.clearWatch(window.positionWatchId);
                }
                if (onlineRestartTimeout) {
                    clearTimeout(onlineRestartTimeout);
                }
                console.debug('Geolocation cleanup on page unload');
            });
            
            onlineListenerAdded = true;
            console.debug('Online/offline/beforeunload listeners registered');
        }
        
        return window.positionWatchId;
    } catch (err) {
        console.error('Geolocation unavailable:', err);
        handleLocationError({ code: 0, message: 'Geolocation unavailable' });
        return null;
    }
}

function handlePositionUpdate(position) {
    if (!position || !position.coords || 
        isNaN(position.coords.latitude) || 
        isNaN(position.coords.longitude)) {
        console.warn("Invalid position data received");
        return;
    }
    
    const positionTimestamp = position.timestamp || Date.now();
    const currentTime = Date.now();
    const maxAgeMs = 30_000;
    
    if (currentTime - positionTimestamp > maxAgeMs) {
        console.warn("Position data too old, ignoring");
        return;
    }
    
    // Throttle background updates to once every 30 seconds
    if (document.hidden) {
        if (!window._lastBackgroundUpdate || currentTime - window._lastBackgroundUpdate > 30_000) {
            window._lastBackgroundUpdate = currentTime;
        } else {
            return; // Skip to save battery
        }
    }
    
    const accuracy = position.coords.accuracy || 0;
    window.lastPositionAccuracy = accuracy;
    
    // STORE RAW SPEED FOR BACKWARDS COMPATIBILITY (do not use for mode logic)
    const rawSpeedMPS = position.coords.speed || 0;
    window.lastRawSpeedMPS = rawSpeedMPS; // Renamed to clarify purpose
    
    // DO NOT set window.lastSpeedMPS here — let updateUserLocation compute reliable speed
    // (This prevents raw GPS noise from breaking 16mph transition)
    window.lastValidPosition = {
        lat: position.coords.latitude,
        lng: position.coords.longitude,
        timestamp: positionTimestamp,
        accuracy: accuracy,
        speedMPS: rawSpeedMPS, // raw value only — smoothing happens downstream
        heading: position.coords.heading || null
    };
    
    // Calculate time since last update
    if (window.lastUpdateTime) {
        window.timeSinceLastUpdate = currentTime - window.lastUpdateTime;
    }
    window.lastUpdateTime = currentTime;
    
    // Force update more frequently at high speeds
    // Use raw speed here (safe for this purpose — worst case: extra update)
    const forceUpdate = rawSpeedMPS > 10; // >22 mph
    
    updateUserLocation(position, forceUpdate);
}
        
function handleVisibilityChange() {
    if (typeof lastHiddenTime === 'undefined') {
        lastHiddenTime = Date.now();
    }
    
    if (document.hidden) {
        // Tab/app going to background
        lastHiddenTime = Date.now();
        lastKnownPosition = userMarker?.getLatLng() ?? null;
        resetInactivityTimer(false);
        
        disposeMapLoop();
        window.isReWaking = false;
        if (window.visibilityDebounceTimer) {
            clearTimeout(window.visibilityDebounceTimer);
            window.visibilityDebounceTimer = null;
        }
        
        console.debug("App went to background - timers disposed");
    } else {
        // Tab/app returning to foreground
        const awayMs = Date.now() - lastHiddenTime;
        const threshold = CONFIG?.BACKGROUND_THRESHOLD ?? 30_000;
        
        console.debug(`App returned to foreground after ${(awayMs / 1000).toFixed(1)}s`);
        
        // Cancel any pending debounce
        if (window.visibilityDebounceTimer) {
            clearTimeout(window.visibilityDebounceTimer);
            window.visibilityDebounceTimer = null;
        }
        
        if (awayMs > threshold) {
            // Debounce to handle rapid tab switches
            window.visibilityDebounceTimer = setTimeout(() => {
                window.visibilityDebounceTimer = null;
                
                // Recalculate time away to ensure freshness
                const currentAwayMs = Date.now() - lastHiddenTime;
                if (currentAwayMs <= threshold) {
                    console.debug("Debounced return: now below threshold, skipping refresh");
                    return;
                }
                
                if (window.isReWaking) {
                    console.debug("Location refresh already in progress, skipping");
                    return;
                }
                
                console.log(`Away for ${(currentAwayMs / 1000).toFixed(1)}s — refreshing location`);
                window.isReWaking = true;
                
                Promise.resolve(updateLocationAfterBackground())
                    .catch((error) => {
                        console.error("Background location update failed:", error);
                    })
                    .finally(() => {
                        setTimeout(() => {
                            window.isReWaking = false;
                        }, 2000);
                    });
            }, 500);
        } else {
            // Short absence → immediate refresh
            if (map && lastKnownPosition) {
                map.invalidateSize({ pan: false });
                userMarker?.setLatLng(lastKnownPosition);
                console.debug("Map and marker refreshed (short absence)");
            }
        }
        resetInactivityTimer(true);
    }
}
        
let geolocationRequestPending = false;
let warmupWatchId = null;

function updateLocationAfterBackground() {
    // Prevent concurrent execution (critical for reliability)
    if (window._isLocationUpdateInProgress) {
        console.debug("Location update already in progress — ignoring");
        return;
    }
    window._isLocationUpdateInProgress = true;

    if (!("geolocation" in navigator)) {
        console.warn("Geolocation is not available");
        window._isLocationUpdateInProgress = false;
        return;
    }

    // Clean up any existing map loop
    disposeMapLoop();

    // Cancel any previous watch
    if (warmupWatchId !== null) {
        navigator.geolocation.clearWatch(warmupWatchId);
        warmupWatchId = null;
    }

    geolocationRequestPending = true;
    const startTime = Date.now();
    const MAX_DURATION = 45000;

    const cleanup = () => {
        geolocationRequestPending = false;
        if (warmupWatchId !== null) {
            navigator.geolocation.clearWatch(warmupWatchId);
            warmupWatchId = null;
        }
        window._isLocationUpdateInProgress = false; // Release lock
    };

    const showRetryModal = () => {
        if (document.getElementById('geolocation-retry-modal')) return;

        const modal = document.createElement('div');
        modal.id = 'geolocation-retry-modal';
        modal.style.cssText = `
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100000;
        `;
        modal.innerHTML = `
            <div style="
                background: white; 
                border-radius: 12px; 
                padding: 28px 24px; 
                width: 90%; 
                max-width: 420px;
                box-shadow: 0 8px 30px rgba(0,0,0,0.3);
                text-align: center;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            ">
                <div style="font-size: 26px; margin-bottom: 6px;">Location Needed</div>
                <p style="margin: 16px 0; color: #4a5568; line-height: 1.5; font-size: 15px;">
                    We’re still locating your device.<br>
                    Please ensure location services are enabled, and try again.
                </p>
                <button id="retry-location-btn" style="
                    background: #2c5282; 
                    color: white; 
                    border: none; 
                    padding: 14px 28px; 
                    border-radius: 8px; 
                    font-size: 17px; 
                    font-weight: 600;
                    margin-top: 12px;
                    cursor: pointer;
                    width: 100%;
                ">↻ Try Again</button>
                <button id="close-retry-modal" style="
                    margin-top: 20px;
                    background: none; 
                    border: none; 
                    color: #718096; 
                    font-size: 14px; 
                    cursor: pointer;
                ">Cancel</button>
            </div>
        `;
        document.body.appendChild(modal);

        document.getElementById('retry-location-btn').onclick = () => {
            modal.remove();
            updateLocationAfterBackground();
        };

        document.getElementById('close-retry-modal').onclick = () => {
            modal.remove();
        };

        modal.onclick = (e) => {
            if (e.target === modal) modal.remove();
        };
    };

    warmupWatchId = navigator.geolocation.watchPosition(
        (position) => {
            const coords = position?.coords;
            if (!coords || 
                isNaN(coords.latitude) || 
                isNaN(coords.longitude) || 
                coords.accuracy == null || 
                coords.accuracy <= 0) {
                return;
            }

            // Ignore stale positions
            if (Date.now() - position.timestamp > 30000) return;

            cleanup();

            const { latitude, longitude, accuracy } = coords;
            console.log(`Location acquired after ${((Date.now() - startTime)/1000).toFixed(1)}s`);

            const currentCenter = map.getCenter();
            const distanceMoved = currentCenter.distanceTo([latitude, longitude]);

            if (distanceMoved < 5) {
                updateUserLocation(position, true);
                updateDistanceBox?.();
                if (typeof isSignificantMovement === 'function' && 
                    isSignificantMovement({ lat: latitude, lng: longitude })) {
                    resetInactivityTimer?.(false);
                }
                return;
            }

            requestAnimationFrame(() => {
                try {
                    const currentZoom = map.getZoom();
                    
                    // Reset motion state
                    lastPosition = null;
                    positionBuffer.length = 0;
                    lastVelocity = { lat: 0, lng: 0 };
                    isStationary = false;
                    stationaryStartTime = null;
                    stationaryCount = 0;
                    lastUpdateTime = Date.now();
                    lastUpdateTimestamp = Date.now();

                    updateUserLocation(position, true);
                    map.setView([latitude, longitude], currentZoom, { 
                        animate: false,
                        duration: 0,
                        noMoveStart: true
                    });

                    if (typeof isSignificantMovement === 'function' && 
                        isSignificantMovement({ lat: latitude, lng: longitude })) {
                        resetInactivityTimer?.(false);
                    }
                    updateDistanceBox?.();
                } catch (error) {
                    console.error("Error applying location:", error);
                    window._isLocationUpdateInProgress = false;
                }
            });
        },
        (error) => {
            // Log all errors but let timeout handle UX
            console.warn("Geolocation error:", error.message, "Code:", error.code);
            // Do NOT show modal here — keep UX consistent via timeout
        },
        {
            enableHighAccuracy: true,
            timeout: 25000,
            maximumAge: 10000
        }
    );

    // Final timeout fallback
    setTimeout(() => {
        if (geolocationRequestPending) {
            console.warn("Geolocation timed out after 45s — showing retry modal");
            cleanup();
            showRetryModal();
        }
    }, MAX_DURATION);
}

function updatePositionBuffer(position) {
    // Validate input
    if (!position || typeof position.lat !== 'number' || typeof position.lng !== 'number') {
        console.warn('updatePositionBuffer: invalid position, skipping');
        return;
    }
    
    // Validate lat/lng ranges
    if (Math.abs(position.lat) > 90 || Math.abs(position.lng) > 180) {
        console.warn('updatePositionBuffer: out-of-range coordinates, skipping');
        return;
    }
    
    // Add new position
    positionBuffer.push({
        lat: position.lat,
        lng: position.lng,
        accuracy: position.accuracy,
        timestamp: position.timestamp,
        heading: position.heading,
        speedMPS: position.speedMPS
    });
    
    // Remove oldest position if buffer exceeds max size (more efficient)
    if (positionBuffer.length > CONFIG.MAX_BUFFER_SIZE) {
        positionBuffer.shift();
    }
}

function validatePositionBuffer() {
    // Initialize if missing
    if (!window.positionBuffer || !Array.isArray(window.positionBuffer)) {
        window.positionBuffer = [];
        return;
    }
    
    // Skip if buffer is empty
    if (window.positionBuffer.length === 0) return;
    
    const before = window.positionBuffer.length;
    const validEntries = [];
    
    for (let i = 0; i < window.positionBuffer.length; i++) {
        const p = window.positionBuffer[i];
        
        // Check if entry is valid
        const isValid = p && 
            typeof p.lat === 'number' && 
            typeof p.lng === 'number' &&
            isFinite(p.lat) && 
            isFinite(p.lng) &&
            Math.abs(p.lat) <= 90 && 
            Math.abs(p.lng) <= 180;
            
        if (isValid) {
            validEntries.push(p);
        } else {
            console.warn(`[Buffer] Removed corrupted entry at index ${i}:`, p);
        }
    }
    
    window.positionBuffer = validEntries;
    
    // Log if corruption was found
    if (before !== window.positionBuffer.length) {
        console.warn(`[Buffer] Cleaned ${before - window.positionBuffer.length} corrupted entries`);
    }
    
    // Ensure buffer has at least one entry for smoothing
    if (window.positionBuffer.length === 0 && window.lastPosition) {
        window.positionBuffer.push({
            lat: window.lastPosition.lat,
            lng: window.lastPosition.lng,
            accuracy: window.lastPosition.accuracy || 20,
            timestamp: Date.now(),
            heading: window.lastPosition.heading ?? null,
            speedMPS: window.lastPosition.speedMPS || 0
        });
        console.debug('[Buffer] Re-seeded from lastPosition');
    }
}

function seedPositionBuffer(seedPosition, count = CONFIG.MAX_BUFFER_SIZE || 5) {
    // Validate input
    if (!seedPosition || typeof seedPosition.lat !== 'number' || typeof seedPosition.lng !== 'number') {
        console.warn('seedPositionBuffer: invalid seed position, skipping');
        return;
    }
    
    // Validate count
    const safeCount = Math.max(1, Math.min(count, CONFIG.MAX_BUFFER_SIZE || 10));
    
    // Clear buffer
    positionBuffer.length = 0;
    
    // Create template position (clone once)
    const template = {
        lat: seedPosition.lat,
        lng: seedPosition.lng,
        accuracy: seedPosition.accuracy,
        timestamp: seedPosition.timestamp,
        heading: seedPosition.heading,
        speedMPS: seedPosition.speedMPS
    };
    
    // Fill buffer with clones to prevent shared reference issues
    for (let i = 0; i < safeCount; i++) {
        positionBuffer.push({ ...template });
    }
    
    console.debug(`Position buffer seeded with ${safeCount} positions`);
}

function calculateWeightedPosition(positions) {
    if (!Array.isArray(positions) || positions.length === 0) {
        return null;
    }
    
    const validPositions = positions.filter(pos => 
        pos && 
        typeof pos.lat === 'number' && 
        typeof pos.lng === 'number' && 
        !isNaN(pos.lat) && 
        !isNaN(pos.lng) &&
        Math.abs(pos.lat) <= 90 &&
        Math.abs(pos.lng) <= 180
    );
    
    if (validPositions.length === 0) {
        return null;
    }
    
    // Single position — no weighting needed
    if (validPositions.length === 1) {
        return {
            lat: validPositions[0].lat,
            lng: validPositions[0].lng,
            accuracy: validPositions[0].accuracy || 20,
            timestamp: validPositions[0].timestamp,
            heading: validPositions[0].heading,
            speedMPS: validPositions[0].speedMPS
        };
    }
    
    /* Recency-based weighting: heavily favors recent positions */
    const len = validPositions.length;
    let sumLat = 0, sumLng = 0, totalWeight = 0;
    
    for (let i = 0; i < len; i++) {
        const position = validPositions[i];
        
        // Linear recency: index 0 = oldest, index len-1 = newest
        const recencyFactor = (i + 1) / len;
        
        // Aggressive recency bias: newer positions weighted much more heavily
        const weight = Math.pow(recencyFactor, 2.5);
        
        sumLat += position.lat * weight;
        sumLng += position.lng * weight;
        totalWeight += weight;
    }
    
    // Find best (lowest) accuracy among valid positions
    let bestAccuracy = Infinity;
    for (const pos of validPositions) {
        const acc = pos.accuracy;
        if (typeof acc === 'number' && !isNaN(acc) && acc < bestAccuracy) {
            bestAccuracy = acc;
        }
    }
    
    const mostRecent = validPositions[len - 1];
    
    return {
        lat: sumLat / totalWeight,
        lng: sumLng / totalWeight,
        accuracy: bestAccuracy !== Infinity ? bestAccuracy : 20,
        timestamp: mostRecent.timestamp,
        heading: mostRecent.heading,
        speedMPS: mostRecent.speedMPS
    };
}

function checkStationaryState(newPosition) {
    if (!lastPosition) return;
    
    const distance = calculateDistance(lastPosition, newPosition);
    
    // Movement detected — exit stationary mode immediately
    if (distance >= CONFIG.MICRO_MOVEMENT_THRESHOLD) {
        const wasStationary = isStationary;
        isStationary = false;
        stationaryStartTime = null;
        
        if (stationaryCheckTimeout) {
            clearTimeout(stationaryCheckTimeout);
            stationaryCheckTimeout = null;
        }
        
        if (wasStationary) {
            console.debug("Movement detected, resuming normal updates");
        }
        return;
    }
    
    // Still not moving — manage stationary timing
    const now = Date.now();
    
    if (stationaryStartTime === null) {
        stationaryStartTime = now;
    } else if (!isStationary) {
        const duration = now - stationaryStartTime;
        if (duration >= CONFIG.STATIONARY_THRESHOLD) {
            isStationary = true;
            console.debug(`Entered stationary state after ${(duration / 1000).toFixed(1)}s`);
        }
    }
    
    // Set a ONE-TIME timeout to detect abandoned stationary state
    if (stationaryCheckTimeout) {
        clearTimeout(stationaryCheckTimeout);
    }
    
    stationaryCheckTimeout = setTimeout(() => {
        if (isStationary && window.lastUpdateTime) {
            const timeSinceLastUpdate = Date.now() - window.lastUpdateTime;
            // Only expire if no GPS updates for significantly longer than expected
            if (timeSinceLastUpdate > CONFIG.STATIONARY_CHECK_INTERVAL * 3) {
                console.debug("Stationary state expired due to no GPS updates");
                isStationary = false;
                stationaryStartTime = null;
            }
        }
        stationaryCheckTimeout = null;
    }, CONFIG.STATIONARY_CHECK_INTERVAL);
}

function calculateFinalPosition() {
    const len = positionBuffer.length;
    if (len === 0) return null;
    if (len === 1) return { ...positionBuffer[0] };
    
    const weighted = calculateWeightedPosition(positionBuffer);
    return weighted ? { ...weighted } : null;
}

function throttle(func, limit) {
    let timeoutId = null;
    let lastRan = 0;
    let pendingArgs = null;
    let pendingThis = null;
    
    return function throttled(...args) {
        const now = Date.now();
        const context = this;
        
        if (now - lastRan >= limit) {
            func.apply(context, args);
            lastRan = now;
            pendingArgs = null;
            pendingThis = null; // Added for completeness
        } else {
            pendingArgs = args;
            pendingThis = context;
            
            if (timeoutId) clearTimeout(timeoutId);
            
            timeoutId = setTimeout(() => {
                if (pendingArgs) {
                    func.apply(pendingThis, pendingArgs);
                    lastRan = Date.now();
                    pendingArgs = null;
                    pendingThis = null; // Added for completeness
                }
                timeoutId = null;
            }, limit - (now - lastRan));
        } 
    };
}
        
// CONFIGURATION CONSTANTS
const SPEED_THRESHOLDS = {
    WALKING: 3,
    JOGGING: 5, 
    TRANSITION_START: 10,
    HIGH_SPEED: 16,        // Enter centered mode at or above this
    HYSTERESIS_RETURN: 13.5, // Exit centered mode at or below this
    PROXIMITY_BLOCK: 13.5   // NEW: Block proximity zoom when exiting centered mode
};

// Single Source Mode Manager 
const ModeManager = {
    current: 'roaming',
    
    update(speedMPH) {
        const THRESHOLDS = window.SPEED_THRESHOLDS || { HIGH_SPEED: 45, HYSTERESIS_RETURN: 35 };
        const wasCentered = this.current === 'centered';
        const shouldEnter = speedMPH >= THRESHOLDS.HIGH_SPEED;
        const shouldExit = speedMPH <= THRESHOLDS.HYSTERESIS_RETURN;
        
        if (shouldEnter && !wasCentered) {
            this.current = 'centered';
            console.log(`🎯 MODE CHANGE: roaming → centered at ${speedMPH.toFixed(1)} mph`);
            return true;
        } else if (shouldExit && wasCentered) {
            this.current = 'roaming';
            console.log(`🎯 MODE CHANGE: centered → roaming at ${speedMPH.toFixed(1)} mph`);
            return true;
        }
        return false;
    },
    
    isCentered() { return this.current === 'centered'; },
    isRoaming() { return this.current === 'roaming'; }
};
window.ModeManager = ModeManager;

// Expose threshold if other modules need it
const HIGH_SPEED_THRESHOLD_MPH = SPEED_THRESHOLDS.HIGH_SPEED;

/** Returns 0-1 scale of update *aggressiveness* Low speed (≤2 MPH): returns ~0.0 */
function speedAggressiveness(speedMPH, loSpeed = 2, hiSpeed = 15, exponent = 0.6) {
    if (speedMPH <= loSpeed) return 0;
    if (speedMPH >= hiSpeed) return 1;
    const t = (speedMPH - loSpeed) / (hiSpeed - loSpeed);
    return Math.pow(t, exponent);
}

/** Returns aggressiveness for high-speed scenarios */
function highSpeedAggressiveness(speedMPH) {
    // Scale from 15 (start of centered mode) to 65 (typical highway max)
    return speedAggressiveness(speedMPH, 15, 65, 0.7);
}

/* Returns zoom based on speed:
 * Returns -1 if proximity or external control should handle zoom. */
function getSpeedBasedZoom(speedMPS, closestDistance = Infinity) {
    const proximityThreshold = CONFIG.PROXIMITY_THRESHOLD || 50;
    if (window.blockSpeedZoom || closestDistance < proximityThreshold) {
        return -1;
    }
    const speedMPH = speedMPS * 2.23694;
    if (speedMPH >= 60) return 15;
    if (speedMPH >= 25) return 16;
    return 17;
}

// INTERACTION & INACTIVITY HANDLERS
function setupMapInteractionHandlers() {
    // Guard – only attach once
    if (!map || window._interactionHandlersSetup) return;
    window._interactionHandlersSetup = true;

    // Initialise flag (if another script touched it first, we keep that value)
    if (typeof window.isMapInteracting === 'undefined') {
        window.isMapInteracting = false;
    }

    // Interaction start – lock map & cancel 30 s timer
    const onInteractionStart = () => {
        window.isMapInteracting = true;
        _clearInactivityTimer();               // cancel any pending snap‑back
    };
    map.on('movestart', onInteractionStart);
    map.on('zoomstart', onInteractionStart);

    // Interaction end – unlock instantly, then decide about timer
    const STATIONARY_SPEED_MPH = 1.0;           // threshold for “parked”

    const onInteractionEnd = () => {
        // Immediate unlock – eliminates the 500 ms lag
        window.isMapInteracting = false;

        // Determine current speed (fallback to 0 if we have no fix yet)
        const speedMPH = window.lastPosition?.speedMPS
            ? window.lastPosition.speedMPS * 2.23694
            : 0;

        if (speedMPH < STATIONARY_SPEED_MPH) {
            // User is effectively stopped → start the 30 s snap‑back timer
            _startInactivityTimer();
        } else {
            // Driving – keep following GPS, do **not** start the timer
            // (the timer remains cleared)
        }
    };

    // Remove any stale listeners that might have been added earlier
    map.off('moveend', onInteractionEnd);
    map.off('zoomend', onInteractionEnd);

    // Attach the fresh handlers
    map.on('moveend', onInteractionEnd);
    map.on('zoomend', onInteractionEnd);
}

function _clearInactivityTimer() {
    if (window.inactivityTimer) {
        clearTimeout(window.inactivityTimer);
        window.inactivityTimer = null;
    }
}

function _startInactivityTimer() {
    // Only start if not already running
    if (window.inactivityTimer) return;
    
    // 30 Seconds = 30000ms
    window.inactivityTimer = setTimeout(() => {
        _handleInactivityReset();
    }, 30000);
}

function _handleInactivityReset() {
    console.log("[Inactivity] 30s reached. Re-centering map on user.");
    
    const pos = window.lastPosition;
    const speed = pos ? (pos.speedMPS * 2.23694) : 0;
    
    // Safety: Only reset if user is actually stationary
    if (pos && speed < 0.5 && map && userMarker) {
        // Set view without animation (snap back)
        map.setView([pos.lat, pos.lng], map.getZoom(), {
            animate: false,
            noMoveStart: true,
            noMoveEnd: true
        });
        
        // Ensure marker is absolutely correct
        userMarker.setLatLng([pos.lat, pos.lng]);
    }
    
    // Clear timer so it doesn't loop
    window.inactivityTimer = null;
}

(function() {
  'use strict';

  // CONFIGURATION
  const CONFIG = {
    PREFETCH_DISTANCE: 80,        // Start prefetch at this distance (feet)
    TRIGGER_DISTANCE: 20,         // Auto-open at this distance (feet)
    TRIGGER_DEBOUNCE_MS: 800,     // Default debounce for auto-open
    TRIGGER_DEBOUNCE_RUN_MS: 2000, // Debounce when running/cycling
    RUN_SPEED_FPS: 8,             // Threshold between walking and running
    CACHE_CLEAR_DIST: 120,        // Clear cache when this far (feet)
    CACHE_RESTORE_DIST: 100,      // Re-enable cache when this close (feet)
    TILE_PREFETCH_ZOOM: 19,       // Zoom level for tile prefetch
    TILE_GRID_SIZE: 3,            // 3x3 grid of tiles
    TILE_STAGGER_MS: 50,          // Delay between tile requests
    DEBUG: false
  };

  // STATE
  const state = {
    prefetchState: {},            // Per-location prefetch tracking
    lastTriggerByLocation: {},    // Per-location debounce timestamps
    markerUpdatePending: null,
    markerRAFId: null,
    markerFallbackId: null
  };


  // PRIVATE UTILITIES
  function _debug(...args) {
    if (CONFIG.DEBUG) {
      console.log('[Proximity]', ...args);
    }
  }

  function _meters2Feet(meters) {
    return meters * 3.28084;
  }

  function _isValidLocation(location) {
    return location && typeof location.id !== 'undefined' && 
           isFinite(location.lat) && isFinite(location.lng);
  }

  function _isValidDistance(distance) {
    return isFinite(distance) && distance !== Infinity;
  }

  function _isLocationHuntOpen() {
    try {
      const container = document.querySelector('.lochunt-container');
      return container && container.style.display !== 'none';
    } catch (error) {
      return false;
    }
  }

  // CACHE MANAGEMENT
  function _handleCacheManagement(distanceFeet) {
    const CACHE_CLEAR_DIST = CONFIG.CACHE_CLEAR_DIST;
    const CACHE_RESTORE_DIST = CONFIG.CACHE_RESTORE_DIST;

    if (distanceFeet > CACHE_CLEAR_DIST) {
      if (window.preloadedLocation) {
        _debug('Clearing preload cache');
        window.preloadedLocation = null;
      }
      state.prefetchState = {};
    } else if (distanceFeet < CACHE_RESTORE_DIST && !window.preloadedLocation) {
      state.markerUpdatePending = { needsPreload: true };
    }
  }

  // COOLDOWN MANAGEMENT
  function _checkCooldown(locationId) {
    if (!window.cooldownManager?.checkCooldown) {
      return false;
    }

    try {
      const status = window.cooldownManager.checkCooldown(locationId);
      return status?.isOnCooldown || false;
    } catch (error) {
      console.warn('[Proximity] Cooldown check failed:', error);
      return false;
    }
  }

  // PREFETCH ZONE
  function _prefetchLocationData(location) {
    if (typeof window.preloadLocationData !== 'function') {
      _debug('preloadLocationData not available');
      return;
    }

    try {
      window.preloadLocationData(location);
    } catch (error) {
      console.warn('[Prefetch] Data preload failed:', error);
    }
  }

 function _prefetchMapTiles(location) {
  if (!window.map?.getCenter || !window.map?.getZoom) {
    _debug('Map not ready for tile prefetch');
    return;
  }

  try {
    // Validate location
    if (!location || typeof location.lat !== 'number' || typeof location.lng !== 'number') {
      _debug('Invalid location object');
      return;
    }

    const currentZoom = window.map.getZoom();
    if (currentZoom >= CONFIG.TILE_PREFETCH_ZOOM) {
      _debug('Zoom already high, skipping tile prefetch');
      return;
    }

    const targetZoom = CONFIG.TILE_PREFETCH_ZOOM;
    const tileUrl = window.currentTileLayer?._url || 
      'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png';

    // Calculate tile coordinates
    const lat = location.lat;
    const lng = location.lng;
    const latRad = lat * Math.PI / 180;
    const n = Math.pow(2, targetZoom);
    const x = Math.floor((lng + 180) / 360 * n);
    const y = Math.floor((1 - Math.log(Math.tan(latRad) + 1 / Math.cos(latRad)) / Math.PI) / 2 * n);

    const subdomains = ['a', 'b', 'c'];
    const urls = [];

    // Build 3x3 grid
    for (let dx = -1; dx <= 1; dx++) {
      for (let dy = -1; dy <= 1; dy++) {
        const tx = x + dx;
        const ty = y + dy;
        if (tx < 0 || tx >= n || ty < 0 || ty >= n) continue;
        const s = subdomains[(tx + ty) % 3];
        urls.push(tileUrl
          .replace('{z}', targetZoom)
          .replace('{x}', tx)
          .replace('{y}', ty)
          .replace('{s}', s));
      }
    }

    // Staggered load with error handling
    urls.forEach((url, i) => {
      setTimeout(() => {
        const img = new Image();
        img.onerror = () => {
          _debug('Failed to load tile', { url });
        };
        img.src = url;
      }, i * CONFIG.TILE_STAGGER_MS);
    });

    _debug(`Prefetched ${urls.length} tiles for ${location.name || location.id}`);
  } catch (error) {
    _debug('Tile prefetch error', { error: error.message });
  }
}
    
  function _handlePrefetchZone(location, distanceFeet, currentTime) {
    const locationId = location.id;

    // Initialize state for this location
    if (!state.prefetchState[locationId]) {
      state.prefetchState[locationId] = {
        startTime: currentTime,
        startDistance: distanceFeet,
        dataDone: false,
        tilesDone: false,
        completed: false
      };

      _debug(`Entering prefetch zone: ${distanceFeet.toFixed(1)}ft from ${location.name || locationId}`);
    }

    const ps = state.prefetchState[locationId];

    // Data preload (once per approach)
    if (!ps.dataDone) {
      if (!window.preloadedLocation || window.preloadedLocation.id !== locationId) {
        window.preloadedLocation = location;
        _prefetchLocationData(location);
      }
      ps.dataDone = true;
    }

    // Tile prefetch at 50ft or closer
    if (distanceFeet <= 50 && !ps.tilesDone) {
      _prefetchMapTiles(location);
      ps.tilesDone = true;
    }

    // Mark complete when both done
    if (ps.dataDone && ps.tilesDone) {
      ps.completed = true;
      _debug(`Prefetch completed for ${locationId}`);
    }
  }

  // DEBOUNCE CALCULATION
  function _calculateDebounceMs(locationId, distanceFeet) {
    const approach = state.prefetchState[locationId];

    // No movement data, use default
    if (!approach || !approach.startTime || approach.startDistance === distanceFeet) {
      return CONFIG.TRIGGER_DEBOUNCE_MS;
    }

    const traveled = approach.startDistance - distanceFeet;
    const elapsed = performance.now() - (approach.startTime || 0);

    if (elapsed <= 0 || traveled <= 0) {
      return CONFIG.TRIGGER_DEBOUNCE_MS;
    }

    // Speed in feet per second
    const speedFps = traveled / (elapsed / 1000);

    // Running/cycling detection
    if (speedFps > CONFIG.RUN_SPEED_FPS) {
      return CONFIG.TRIGGER_DEBOUNCE_RUN_MS;
    }

    return CONFIG.TRIGGER_DEBOUNCE_MS;
  }

  // TRIGGER ZONE
  function _handleTriggerZone(location, distanceFeet, currentTime, isOnCooldown) {
    const locationId = location.id;

    _debug(`Within trigger zone: ${distanceFeet.toFixed(1)}ft from ${location.name || locationId}`);

    // Guard: Location hunt already open
    if (_isLocationHuntOpen()) {
      _debug('Location page already open, skipping trigger');
      return;
    }

    // Guard: On cooldown
    if (isOnCooldown) {
      _debug('Location on cooldown, skipping trigger');
      return;
    }

    // Debounce check
    const now = performance.now();
    const lastTrigger = state.lastTriggerByLocation[locationId] || 0;
    const debounceMs = _calculateDebounceMs(locationId, distanceFeet);
    const timeSince = now - lastTrigger;

    if (timeSince < debounceMs) {
      _debug(`Debounced: ${(timeSince / 1000).toFixed(1)}s ago, need ${(debounceMs / 1000).toFixed(1)}s`);
      return;
    }

    // Stamp trigger BEFORE calling showLocationHunt to prevent re-entrant calls
    state.lastTriggerByLocation[locationId] = now;

    // Ensure data is preloaded
    if (!window.preloadedLocation || window.preloadedLocation.id !== locationId) {
      _debug('Emergency preload (skipped prefetch zone)');
      window.preloadedLocation = location;
      _prefetchLocationData(location);
    }

    // Haptic feedback
    try {
      navigator.vibrate?.([80, 40, 80]);
    } catch (_) {
      // Ignore
    }

    const target = window.preloadedLocation || location;

    if (typeof window.showLocationHunt !== 'function') {
      console.error('[Proximity] showLocationHunt is not defined');
      state.lastTriggerByLocation[locationId] = 0; // Reset on error
      return;
    }

    try {
      _debug('🎯 Opening location');
      window.showLocationHunt(target);

      // Cleanup
      window.preloadedLocation = null;
      delete state.prefetchState[locationId];

      _debug('✅ Opened successfully');
    } catch (error) {
      console.error('[Proximity] showLocationHunt threw error:', error);
      // Reset on error so user can retry
      delete state.lastTriggerByLocation[locationId];
    }
  }

// MARKER UPDATE SCHEDULING

function _cancelMarkerUpdate() {
  if (state.markerRAFId !== null) {
    cancelAnimationFrame(state.markerRAFId);
    state.markerRAFId = null;
  }
  if (state.markerFallbackId !== null) {
    clearTimeout(state.markerFallbackId);
    state.markerFallbackId = null;
  }
  state.markerUpdatePending = null;
}

function _applyMarkerUpdate(lat, lng) {
  // NOTE: Leaflet's setLatLng() does not accept animation options.
  if (typeof window.userMarker?.setLatLng !== 'function') return;
  try {
    window.userMarker.setLatLng([lat, lng]);
  } catch (error) {
    console.warn('[Marker] Update failed:', error);
  }
}

function _scheduleMarkerUpdate(lat, lng, options = {}) {
  if (!Number.isFinite(lat) || !Number.isFinite(lng)) {
    console.warn('[Marker] Invalid coordinates:', { lat, lng });
    return;
  }

  // Throttle to ~60fps on high-frequency GPS devices
  const now = performance.now();
  if (now - (state.markerLastUpdateTime ?? 0) < 16 && !options.force) {
    _cancelMarkerUpdate();
    state.markerUpdatePending = { lat, lng };
    state.markerRAFId = requestAnimationFrame(() => {
      const pending = state.markerUpdatePending;
      state.markerRAFId = null;
      state.markerUpdatePending = null;
      if (pending) _applyMarkerUpdate(pending.lat, pending.lng);
    });
    return;
  }
  state.markerLastUpdateTime = now;

  _cancelMarkerUpdate();
  state.markerUpdatePending = { lat, lng };

  // Atomic guard: ensures exactly one of RAF or fallback executes
  let hasExecuted = false;
  const executeUpdate = (source) => {
    if (hasExecuted) return;
    hasExecuted = true;

    if (source === 'raf') {
      clearTimeout(state.markerFallbackId);
      state.markerFallbackId = null;
    } else {
      cancelAnimationFrame(state.markerRAFId);
      state.markerRAFId = null;
    }

    const pending = state.markerUpdatePending;
    state.markerUpdatePending = null;

    if (pending) _applyMarkerUpdate(pending.lat, pending.lng);
  };

  state.markerRAFId = requestAnimationFrame(() => {
    state.markerRAFId = null;
    executeUpdate('raf');
  });

  state.markerFallbackId = setTimeout(() => {
    state.markerFallbackId = null;
    executeUpdate('fallback');
  }, 100);
}

function _cleanupMarkerStyles() {
  try {
    const el = window.userMarker?.getElement?.();
    if (el?.style) {
      el.style.willChange = 'auto';
    }
  } catch (_) {}
}
        
  // CLEANUP
  function _cleanup() {
    _cancelMarkerUpdate();
    _cleanupMarkerStyles();
    state.prefetchState = {};
    state.lastTriggerByLocation = {};
    state.markerUpdatePending = null;
  }


// MAIN HANDLER
  function handleProximityAndAutoOpen(newPosition, currentTime, closestLocation, closestDistance) {
    // Guard: Invalid data
    if (!_isValidLocation(closestLocation) || !_isValidDistance(closestDistance)) {
      window.proximityState = {
        closestLocation: null,
        distanceMeters: Infinity,
        isOnCooldown: false,
        lastUpdateTime: currentTime
      };
      const invalidId = closestLocation?.id;
      if (invalidId && state.prefetchState[invalidId]) {
        delete state.prefetchState[invalidId];
      }
      return;
    }

    // Cache tracking
    window.lastClosestDistance = closestDistance;
    window.lastClosestLocation = closestLocation;

    const distanceFeet = _meters2Feet(closestDistance);
    const isOnCooldown = _checkCooldown(closestLocation.id);

    // Cache management
    _handleCacheManagement(distanceFeet);

    // Update global proximity state
    window.proximityState = {
      closestLocation: closestLocation,
      distanceMeters: closestDistance,
      isOnCooldown: isOnCooldown,
      lastUpdateTime: currentTime
    };

    // Zone logic
    const PREFETCH_DISTANCE = CONFIG.PREFETCH_DISTANCE;
    const TRIGGER_DISTANCE  = CONFIG.TRIGGER_DISTANCE;

    // (Ghost Prefetch): 
    if (distanceFeet > PREFETCH_DISTANCE * 2) {
      const departedId = closestLocation?.id;
      if (departedId && state.prefetchState[departedId]) {
        delete state.prefetchState[departedId];
        _debug(`Prefetch cache cleared for departed location: ${departedId}`);
      }
      _debug(`Outside all zones: ${distanceFeet.toFixed(1)}ft`);
      return;
    }

    // Zone 1: Prefetch (outside trigger zone, inside prefetch zone)
    if (distanceFeet <= PREFETCH_DISTANCE && distanceFeet > TRIGGER_DISTANCE) {
      _handlePrefetchZone(closestLocation, distanceFeet, currentTime);
      return;
    }

    // Zone 2: Trigger (≤ trigger distance)
    if (distanceFeet <= TRIGGER_DISTANCE) {
      _handleTriggerZone(closestLocation, distanceFeet, currentTime, isOnCooldown);
      return;
    }

    // Between PREFETCH_DISTANCE and PREFETCH_DISTANCE*2 — approaching but not
    // yet in prefetch zone. No action; fall through for debug logging only.
    _debug(`Approaching: ${distanceFeet.toFixed(1)}ft`);
  }

  // INITIALIZATION & EXPORTS
  if (typeof window !== 'undefined') {
    window.handleProximityAndAutoOpen = handleProximityAndAutoOpen;
    window.scheduleMarkerUpdate = _scheduleMarkerUpdate;
    // Backwards compatibility aliases
    window._handlePrefetchZone    = _handlePrefetchZone;
    window._handleTriggerZone     = _handleTriggerZone;
    window._prefetchMapTiles      = _prefetchMapTiles;
    window._cleanupMarkerStyles   = _cleanupMarkerStyles;
    // Cleanup on unload
    window.addEventListener('beforeunload', _cleanup);
  }
})();

// ─── BATTERY POLLER ──────────────────────────────────────────────────────────
// Moved off the hot path. The main loop reads window._batteryCache
// synchronously — same globals as the original, same 60s schedule, zero await.
// Guard prevents double-registration if the file is re-evaluated.
if (!window._batteryPollerStarted) {
    window._batteryPollerStarted = true;
    (async function pollBattery() {
        if (typeof navigator.getBattery !== 'function') return;
        async function run() {
            try {
                window._batteryCache     = await navigator.getBattery();
                window._batteryCacheTime = Date.now();
            } catch (_) {}
        }
        await run();
        setInterval(run, 60000);
    })();
}


// ─── BATTERY POLLER ──────────────────────────────────────────────────────────
// Moved off the hot path. The main loop reads window._batteryCache
// synchronously — same globals as the original, same 60s schedule, zero await.
// Guard prevents double-registration if the file is re-evaluated.
if (!window._batteryPollerStarted) {
    window._batteryPollerStarted = true;
    (async function pollBattery() {
        if (typeof navigator.getBattery !== 'function') return;
        async function run() {
            try {
                window._batteryCache     = await navigator.getBattery();
                window._batteryCacheTime = Date.now();
            } catch (_) {}
        }
        await run();
        setInterval(run, 60000);
    })();
}


// ─── MAIN UPDATE LOOP ─────────────────────────────────────────────────────────
function updateUserLocation(position, forceUpdate = false) {
    const now = performance.now();

    validatePositionBuffer();

    // ── CRITICAL GUARDS ───────────────────────────────────────────────────────
    if (window.mapFatalError) {
        console.warn("updateUserLocation: Map fatal error, aborting");
        return;
    }

    // Reset the visual error counter on every successful entry into the function 
    window._visualErrorCount = 0;

    if (window._blockAutoMapUpdates && !forceUpdate) return;

    if (!map || !userMarker) {
        console.debug("updateUserLocation: Map not ready, deferring");

        window.pendingPosition    = position;
        window.pendingForceUpdate = forceUpdate;
        if (!window._mapReadyRetryId) {
            window._mapReadyRetryId = setTimeout(() => {
                window._mapReadyRetryId = null;
                if (window.pendingPosition) {
                    const p = window.pendingPosition;
                    const f = window.pendingForceUpdate;
                    window.pendingPosition    = null;
                    window.pendingForceUpdate = false;
                    updateUserLocation(p, f);
                }
            }, 100);
        }
        return;
    }

    if (!window._interactionHandlersSetup) {
        setupMapInteractionHandlers?.();
        window._interactionHandlersSetup = true;
    }

    // ── ENTRY THROTTLE (RAF COALESCING) ───────────────────────────
    if (!forceUpdate && (now - (window._lastUpdateLoopTime || 0)) < 20) {
        if (window._updateLoopTimeoutId) clearTimeout(window._updateLoopTimeoutId);
        window._updateLoopTimeoutId = setTimeout(() => {
            window._updateLoopTimeoutId = null;
            updateUserLocation(position, false);
        }, 20 - (now - (window._lastUpdateLoopTime || 0)));
        return;
    }
    window._lastUpdateLoopTime = now;
    if (window._updateLoopTimeoutId) {
        clearTimeout(window._updateLoopTimeoutId);
        window._updateLoopTimeoutId = null;
    }

    // ── INPUT VALIDATION ──────────────────────────────────────────────────────
    const { coords } = position || {};
    if (!Number.isFinite(coords?.latitude) || !Number.isFinite(coords?.longitude)) {
        console.warn("Invalid position data", coords);
        return;
    }

    const {
        latitude:  lat,
        longitude: lng,
        accuracy   = 20,
        heading    = null,
        speed:     speedMPS = 0
    } = coords;

    // Note: isFinite check here is now redundant given the Number.isFinite guard
    // above, but retained for safety and to preserve original structure exactly.
    if (!isFinite(lat) || !isFinite(lng)) {
        console.warn("Invalid coordinates", { lat, lng });
        return;
    }

    // ── POSITION-DELTA PRE-FILTER ─────────────────────────────────────────────
    if (!forceUpdate && window.lastPosition) {
        const jitterM = calculateDistance(window.lastPosition, { lat, lng });
        if (jitterM < 0.10) return;
    }

    // ── TIME GATE (PRIMARY THROUGHPUT CAP) ────────────────────────────────────
    if (!forceUpdate && (now - (window.lastDebounceTime || 0)) < 33) {
        if (window.debounceTimeoutId) clearTimeout(window.debounceTimeoutId);
        window.pendingPosition    = position;
        window.pendingForceUpdate = forceUpdate;
        window.debounceTimeoutId  = setTimeout(() => {
            if (window.pendingPosition) {
                updateUserLocation(window.pendingPosition, window.pendingForceUpdate);
                window.pendingPosition    = null;
                window.pendingForceUpdate = false;
                window.debounceTimeoutId  = null;
            }
        }, 33 - (now - (window.lastDebounceTime || 0)));
        return;
    }

    window.lastDebounceTime = now;
    if (window.debounceTimeoutId) {
        clearTimeout(window.debounceTimeoutId);
        window.debounceTimeoutId = null;
    }

    // ── GPS TIMEOUT ───────────────────────────────────────────────────────────
    if (window.gpsTimeoutTimer) clearTimeout(window.gpsTimeoutTimer);
    window.gpsTimeoutTimer = setTimeout(() => {
        if (!window.isGPSSearching) {
            window.isGPSSearching = true;
            if (typeof showGPSSearchingState === 'function') showGPSSearchingState();
        }
    }, 30000);

    // ── TIME & POSITION SETUP ─────────────────────────────────────────────────
    // Two time domains, each used for the right purpose:
    const physicsTime   = performance.now();
    const wallClockTime = Date.now();
    const lastPos       = window.lastPosition;
    const timeDelta     = lastPos ? (physicsTime - window.lastUpdateTime) / 1000 : 0;

    // currentTime aliases physicsTime for all internal calculations below,
    // keeping the rest of the function readable without a find/replace churn.
    const currentTime = physicsTime;

    const newPosition = {
        lat,
        lng,
        accuracy,
        heading,
        timestamp: wallClockTime,   // epoch ms — safe for all external consumers
        speedMPS:  Math.max(0, speedMPS)
    };

    // ── SPEED EMAs ────────────────────────────────────────────────────────────
    window._emaSpeedMode = window._emaSpeedMode ?? newPosition.speedMPS;
    window._emaSpeedMode = 0.50 * newPosition.speedMPS + 0.50 * window._emaSpeedMode;

    window._emaSpeedFast = window._emaSpeedFast ?? newPosition.speedMPS;
    window._emaSpeedFast = 0.60 * newPosition.speedMPS + 0.40 * window._emaSpeedFast;

    window._emaSpeedSlow = window._emaSpeedSlow ?? newPosition.speedMPS;
    window._emaSpeedSlow = 0.25 * newPosition.speedMPS + 0.75 * window._emaSpeedSlow;

    const modeSpeedMPH = Math.min(window._emaSpeedMode * 2.23694, 90);
    const speedMPH     = Math.min(window._emaSpeedFast * 2.23694, 90);

    // ── MODE MANAGER ──────────────────────────────────────────────────────────
    const modeChanged      = ModeManager?.update?.(modeSpeedMPH) || false;
    const isInCenteredMode = ModeManager?.isCentered?.()         || false;

    // ── FORCED UPDATE FLAG ────────────────────────────────────────
    if (modeChanged) window._forceMapUpdateTime = currentTime;  // physicsTime ← enforce on all write sites
    const forceMapThisFrame = !!(window._forceMapUpdateTime &&
        (currentTime - window._forceMapUpdateTime) < 500);      // physicsTime - physicsTime ✓

    // ── INACTIVITY TIMER ──────────────────────────────────────────────────────
    if (speedMPH >= 1.0) {
        if (typeof _clearInactivityTimer === 'function') _clearInactivityTimer();
    } else {
        if (typeof _startInactivityTimer === 'function') _startInactivityTimer();
    }

    // ── LOW POWER MODE ────────────────────────────────────────────────────────
    let isLowPowerMode = false;
    if (!forceUpdate && !document.hidden) {
        const battery = window._batteryCache;
        if (battery && battery.level < 0.2 && !battery.charging) {
            isLowPowerMode = true;
        }
    }

    if (isLowPowerMode) {
        if (typeof scheduleMarkerUpdate === 'function') scheduleMarkerUpdate(lat, lng);
        window.lastPosition   = newPosition;
        window.lastUpdateTime = currentTime;
        if (typeof updateDistanceBox === 'function') updateDistanceBox(forceUpdate);
        return;
    }

    // ── GPS RECOVERY ──────────────────────────────────────────────────────────
    if (window.isGPSSearching) {
        window.isGPSSearching         = false;
        window.positionBuffer         = [newPosition];
        window.lastVelocity           = { lat: 0, lng: 0 };
        window.smoothedVelocity       = { lat: 0, lng: 0 };
        window.isStationary           = false;
        window.stationaryStartTime    = null;
        window.stationaryLockPosition = null;
        if (typeof hideGPSSearchingState === 'function') hideGPSSearchingState();
    }

    // ── VELOCITY SMOOTHING MOVED EARLIER ──────────────────────────
    // Computed before E/W detection and all downstream logic so every consumer
    // in this frame uses the current velocity, not the previous frame's value.
    window.lastVelocity     = window.lastVelocity     || { lat: 0, lng: 0 };
    window.smoothedVelocity = window.smoothedVelocity || { lat: 0, lng: 0 };

    if (lastPos && timeDelta > 0) {
        const instantVelLat = (lat - lastPos.lat) / timeDelta;
        const instantVelLng = (lng - lastPos.lng) / timeDelta;
        const velSmooth     = Math.max(0.25, Math.min(0.5, 0.4 - (speedMPH * 0.003)));
        window.smoothedVelocity = {
            lat: window.smoothedVelocity.lat * velSmooth + instantVelLat * (1 - velSmooth),
            lng: window.smoothedVelocity.lng * velSmooth + instantVelLng * (1 - velSmooth)
        };
    }

    // ── MOVEMENT DIRECTION ────────────────────────────────────────────────────
    let eastWestMovement = false;
    if (window.smoothedVelocity) {
        const absLat = Math.abs(window.smoothedVelocity.lat);
        const absLng = Math.abs(window.smoothedVelocity.lng);
        if (absLat + absLng > 1e-9) {
            eastWestMovement = absLng > absLat * 1.2;
        }
    }

    // ── INITIALIZATION ────────────────────────────────────────────────────────
    if (!lastPos) {
        if (Array.isArray(window.gameLocations) && window.gameLocations.length > 0) {
            let firstClosestDist = Infinity;
            let firstClosestLoc  = null;
            for (const loc of window.gameLocations) {
                if (!loc?.lat || !loc?.lng) continue;
                const dist = calculateDistance(newPosition, loc);
                if (dist < firstClosestDist) { firstClosestDist = dist; firstClosestLoc = loc; }
            }
            window.lastClosestDistance = firstClosestDist;
            window.lastClosestLocation = firstClosestLoc;
            if (typeof handleProximityAndAutoOpen === 'function') {
                handleProximityAndAutoOpen(newPosition, wallClockTime, firstClosestLoc, firstClosestDist);
            }
        }
        if (typeof _initializeUserLocationState === 'function') {
            // wallClockTime: downstream state may persist this as a real timestamp.
            _initializeUserLocationState(newPosition, wallClockTime, forceUpdate);
        }
        return;
    }

    // ── PROXIMITY CALCULATION (SYNCHRONOUS, RAW GPS) ──────────────────────────
    // Intentionally uses newPosition (raw GPS), not smoothed position.
    // This preserves the original proximity trigger timing exactly.
    // Runs after the !lastPos guard — never wasted on the first GPS tick.
    let closestDistance = Infinity;
    let closestLocation = null;
    const locationsWithDistance = [];
    const posChanged = (lat !== window.lastRawLat) || (lng !== window.lastRawLng);

    if (!posChanged && window.lastClosestDistance !== undefined && window.lastClosestLocation) {
        closestDistance = window.lastClosestDistance;
        closestLocation = window.lastClosestLocation;
    } else if (Array.isArray(window.gameLocations) && window.gameLocations.length > 0) {
        for (const loc of window.gameLocations) {
            if (!loc?.lat || !loc?.lng) continue;
            const dist = calculateDistance(newPosition, loc);
            locationsWithDistance.push({ location: loc, distance: dist });
            if (dist < closestDistance) {
                closestDistance = dist;
                closestLocation = loc;
            }
        }
        window.lastClosestDistance = closestDistance;
        window.lastClosestLocation = closestLocation;
    }

    // Track raw GPS so posChanged works correctly on the next tick.
    // Must use the raw coords (lat/lng), never the smoothed position.
    window.lastRawLat = lat;
    window.lastRawLng = lng;

    // ── PROXIMITY STATE UPDATE (SYNCHRONOUS) ──────────────────────────────────
    if (typeof handleProximityAndAutoOpen === 'function') {
        // wallClockTime: external consumer expects a Unix epoch value here.
        handleProximityAndAutoOpen(newPosition, wallClockTime, closestLocation, closestDistance);
    }

    // ── ENTERPRISE CACHE (ASYNC, NON-BLOCKING) ────────────────────────────────
    if (locationsWithDistance.length > 0) {
        const cacheNow = performance.now();
        if (!window.lastCacheUpdate || (cacheNow - window.lastCacheUpdate) > 5000) {
            const cacheFn = window.enterpriseCacheManager?.cacheLocationData;
            if (typeof cacheFn === 'function') {
                for (const { location, distance } of locationsWithDistance) {
                    if (distance <= 100) {

                        try { cacheFn(location, newPosition); } catch (e) { /* non-fatal */ }
                    }
                }
            }
            window.lastCacheUpdate = cacheNow;
        }
    }

    // ── DISTANCE & JUMP HANDLING ──────────────────────────────────────────────
    const distance = calculateDistance(lastPos, newPosition);

    if (distance > 50 || forceUpdate) {
        if (typeof _handleLargeDistanceJump === 'function') {
            _handleLargeDistanceJump(newPosition, wallClockTime);
        }
        return;
    }

    // ── STATIONARY DETECTION ──────────────────────────────────────────────────
    const STATIONARY_THRESHOLD         = 0.5;
    const STATIONARY_LOCK_THRESHOLD    = 0.3;
    const STATIONARY_CONFIRMATION_TIME = 2000;

    if (distance < STATIONARY_THRESHOLD) {
        if (!window.stationaryStartTime) window.stationaryStartTime = currentTime;

        const stationaryDuration = currentTime - window.stationaryStartTime;

        if (!window.isStationary && stationaryDuration >= STATIONARY_CONFIRMATION_TIME) {
            if (typeof _confirmStationary === 'function') _confirmStationary(newPosition, wallClockTime);
            return;
        }

        if (window.isStationary) {
            const distFromLock = calculateDistance(window.stationaryLockPosition || newPosition, newPosition);
            if (distFromLock < STATIONARY_LOCK_THRESHOLD && newPosition.accuracy < lastPos.accuracy * 0.85) {
                if (typeof scheduleMarkerUpdate === 'function') scheduleMarkerUpdate(lat, lng);
                window.lastPosition           = newPosition;
                window.stationaryLockPosition = { lat, lng };
                if (typeof updateDistanceBox === 'function') updateDistanceBox(forceUpdate);
            }
            return;
        }

        if (distance > 0.15) {
            const cur = userMarker.getLatLng();
            const tgt = L.latLng(lat, lng);
            if (cur.distanceTo(tgt) > 0.3) {
                if (typeof scheduleMarkerUpdate === 'function') {
                    scheduleMarkerUpdate(lat, lng, { animate: true, duration: 1.2, easeLinearity: 0.05 });
                }
                window.lastPosition   = newPosition;
                window.lastUpdateTime = currentTime;
                if (typeof updateDistanceBox === 'function') updateDistanceBox(forceUpdate);
            }
        }
        return;
    }

    // Clear stationary state
    window.stationaryStartTime    = null;
    window.isStationary           = false;
    window.stationaryLockPosition = null;
    if (window.stationaryCheckTimeout) {
        clearTimeout(window.stationaryCheckTimeout);
        window.stationaryCheckTimeout = null;
    }

    // ── MOTION VALIDATION ─────────────────────────────────────────────────────
    if (timeDelta > 0 && timeDelta < 5) {
        const lastSpeedMPH = (lastPos.speedMPS || 0) * 2.23694;
        const accel = Math.abs(speedMPH - lastSpeedMPH) / timeDelta;
        if      (speedMPH < 3  && accel > 25) { console.warn(`Rejecting acceleration ${accel.toFixed(1)} mph/s at very low speed`);  return; }
        else if (speedMPH < 8  && accel > 22) { console.warn(`Rejecting acceleration ${accel.toFixed(1)} mph/s at low speed`);       return; }
        else if (speedMPH < 15 && accel > 18) { console.warn(`Rejecting acceleration ${accel.toFixed(1)} mph/s at medium speed`);    return; }
    }

    // ── HEADING VALIDATION ────────────────────────────────────────────────────
    let validatedHeading = heading;
    if (lastPos.heading != null && heading != null) {
        let diff = Math.abs(heading - lastPos.heading);
        if (diff > 180) diff = 360 - diff;
        if (newPosition.speedMPS < 2 && diff > 90) validatedHeading = lastPos.heading;
    }

    validatedHeading = validatedHeading ?? lastPos.heading ?? 0;

    let headingDiff           = 0;
    let directionChangeFactor = 1.0;
    if (lastPos.heading != null && validatedHeading != null) {
        headingDiff = Math.abs(validatedHeading - lastPos.heading);
        if (headingDiff > 180) headingDiff = 360 - headingDiff;
        if (headingDiff > 12) directionChangeFactor = Math.max(0.5, 1 - (headingDiff / 240));
    }

    // ── SPEED TIER ────────────────────────────────────────────────────────────
    const speedFactor = Math.min(1, Math.max(0.01, newPosition.speedMPS / 15));

    const tierIndex =
        modeSpeedMPH <  1 ? 0 :
        modeSpeedMPH <  5 ? 1 :
        modeSpeedMPH < 12 ? 2 :
        modeSpeedMPH < 16 ? 3 :
        modeSpeedMPH < 24 ? 4 :
        modeSpeedMPH < 34 ? 5 :
        modeSpeedMPH < 48 ? 6 :
        modeSpeedMPH < 65 ? 7 :
        modeSpeedMPH < 85 ? 8 : 9;

    const TIER_CONFIGS = [
        { micro: 0.08, minDist: 0.25, maxAcc: 32,   maxSpd: 3,  mapInt: 1000, mapDist: 2.0,  panDur: 2.2,  easeLin: 0.05, zoomThresh: 2.5, zoomDur: 4.0 },
        { micro: 0.16, minDist: 0.35, maxAcc: 28,   maxSpd: 5,  mapInt: 800,  mapDist: 3.0,  panDur: 1.8,  easeLin: 0.07, zoomThresh: 2.0, zoomDur: 3.5 },
        { micro: 0.24, minDist: 0.48, maxAcc: 26,   maxSpd: 10, mapInt: 600,  mapDist: 4.5,  panDur: 1.4,  easeLin: 0.09, zoomThresh: 1.7, zoomDur: 3.0 },
        { micro: 0.38, minDist: 0.65, maxAcc: 23,   maxSpd: 16, mapInt: 200,  mapDist: 6.5,  panDur: 0.5,  easeLin: 0.16, zoomThresh: 1.0, zoomDur: 1.2 },
        { micro: 0.52, minDist: 0.85, maxAcc: 21.5, maxSpd: 24, mapInt: 150,  mapDist: 9.0,  panDur: 0.12, easeLin: 0.13, zoomThresh: 0.8, zoomDur: 0.6 },
        { micro: 0.68, minDist: 1.15, maxAcc: 20.5, maxSpd: 34, mapInt: 120,  mapDist: 16.5, panDur: 0.06, easeLin: 0.11, zoomThresh: 0.7, zoomDur: 0.5 },
        { micro: 0.88, minDist: 1.45, maxAcc: 20,   maxSpd: 48, mapInt: 100,  mapDist: 21.0, panDur: 0.05, easeLin: 0.09, zoomThresh: 0.6, zoomDur: 0.4 },
        { micro: 1.12, minDist: 1.85, maxAcc: 20,   maxSpd: 65, mapInt: 80,   mapDist: 26.0, panDur: 0.04, easeLin: 0.07, zoomThresh: 0.5, zoomDur: 0.3 },
        { micro: 1.42, minDist: 2.35, maxAcc: 20,   maxSpd: 85, mapInt: 60,   mapDist: 32.0, panDur: 0.03, easeLin: 0.06, zoomThresh: 0.4, zoomDur: 0.2 },
        { micro: 1.78, minDist: 2.95, maxAcc: 20,   maxSpd: 90, mapInt: 50,   mapDist: 32.0, panDur: 0.03, easeLin: 0.05, zoomThresh: 0.4, zoomDur: 0.2 }
    ];

    const tier  = TIER_CONFIGS[tierIndex];
    const ewAdj = eastWestMovement ? 0.88 : 1.0;

    const speedTier = {
        microMovementThreshold: tier.micro,
        minDistanceThreshold:   tier.minDist * ewAdj,
        maxAccuracy:            tier.maxAcc,
        maxSpeedThreshold:      tier.maxSpd,
        mapUpdateInterval:      Math.max(33, tier.mapInt * ewAdj),
        mapUpdateDistance:      tier.mapDist,
        panDuration:            tier.panDur * ewAdj,
        easeLinearity:          tier.easeLin * (eastWestMovement ? 0.92 : 1.0),
        zoomThreshold:          tier.zoomThresh,
        zoomDuration:           tier.zoomDur
    };

    // ── QUALITY GATES ─────────────────────────────────────────────────────────
    let accuracyPenalty = 0;
    if (!forceUpdate) {
        if (newPosition.accuracy > speedTier.maxAccuracy) {
            const ratio = newPosition.accuracy / speedTier.maxAccuracy;
            accuracyPenalty = Math.min(0.35, (ratio - 1) * 0.20);
            if (!window._lastAccuracyWarnTime || (currentTime - window._lastAccuracyWarnTime) > 5000) {
                console.warn(`Low GPS accuracy (${newPosition.accuracy.toFixed(0)}m > ${speedTier.maxAccuracy}m), boosting smoothing lag by ${accuracyPenalty.toFixed(2)}`);
                window._lastAccuracyWarnTime = currentTime;
            }
        }
        if (distance < speedTier.minDistanceThreshold)                           return;
        if (timeDelta > 0 && distance / timeDelta > speedTier.maxSpeedThreshold) return;
    }

    if (window.isStationary || (speedMPH < 0.5 && distance < 0.1)) {
        const accuracyImproved = newPosition.accuracy < lastPos.accuracy * 0.6;
        if (accuracyImproved) {
            if (typeof scheduleMarkerUpdate === 'function') scheduleMarkerUpdate(lat, lng);
            window.lastPosition   = newPosition;
            window.positionBuffer = [newPosition];
            window.lastUpdateTime = currentTime;
            if (typeof updateDistanceBox === 'function') updateDistanceBox(forceUpdate);
        }
        return;
    }

    const accuracyImproved = newPosition.accuracy < lastPos.accuracy * 0.6;
    if (distance > 8 || accuracyImproved) {
        if (typeof scheduleMarkerUpdate === 'function') scheduleMarkerUpdate(lat, lng);
        window.lastPosition   = newPosition;
        window.positionBuffer = [newPosition];
        window.lastUpdateTime = currentTime;
        if (typeof updateDistanceBox === 'function') updateDistanceBox(forceUpdate);
        return;
    }

    // ── MARKER GPU HINT (ONE-TIME) ────────────────────────────────────────────
    if (!window._markerStylesOptimized) {
        const el = userMarker.getElement?.();
        if (el) {
            el.style.willChange         = 'transform';
            el.style.backfaceVisibility = 'hidden';
            el.style.transform          = 'translateZ(0)';
            window._markerStylesOptimized = true;
        }
    }

    // ── DEAD RECKONING ────────────────────────────────────────────────────────
    let effectiveHeading = validatedHeading;
    if (effectiveHeading == null && window.smoothedVelocity) {
        const vLat = window.smoothedVelocity.lat;
        const vLng = window.smoothedVelocity.lng;
        if (Math.abs(vLat) > 1e-9 || Math.abs(vLng) > 1e-9) {
            effectiveHeading = Math.atan2(vLng, vLat) * (180 / Math.PI);
            if (effectiveHeading < 0) effectiveHeading += 360;
        }
    }
    const headingRad = (effectiveHeading ?? 0) * Math.PI / 180;
    const R          = 111111;
    const predWindow = Math.min(0.8, 0.3 + (speedFactor * 0.5));
    // Guard against division by zero at geographic poles (lat ±90°).
    const cosLat     = Math.max(1e-10, Math.abs(Math.cos(lat * Math.PI / 180)));

    // ── DEAD RECKONING STARTUP ────────────────────────────────────
    let effSpeed;
    if (window._emaSpeedFast != null && window._emaSpeedSlow != null &&
        (window._emaSpeedFast >= 0.05 || window._emaSpeedSlow >= 0.05)) {
        effSpeed = (window._emaSpeedFast * 0.70) + (window._emaSpeedSlow * 0.30);
    } else if (timeDelta > 0) {
        effSpeed = distance / timeDelta * 0.1;   // reuses distance, no redundant calculateDistance call
    } else {
        effSpeed = 0;
    }

    const predLat = lat + (effSpeed * Math.cos(headingRad) / R)            * predWindow;
    const predLng = lng + (effSpeed * Math.sin(headingRad) / (R * cosLat)) * predWindow;

    // ── POSITION BUFFER ───────────────────────────────────────────────────────
    if (!window.positionBuffer) window.positionBuffer = [];
    window.positionBuffer.push({
        lat:       predLat,
        lng:       predLng,
        accuracy:  newPosition.accuracy,
        heading:   validatedHeading,
        timestamp: currentTime,
        speedMPS:  effSpeed
    });
    if (window.positionBuffer.length > 5) window.positionBuffer.shift();

    const decay = 0.45 + (speedFactor * 0.45);
    let totalW = 0, wLat = 0, wLng = 0;
    for (const p of window.positionBuffer) {
        const age = (currentTime - p.timestamp) / 1000;
        const w   = Math.exp(-age * decay);
        wLat   += p.lat * w;
        wLng   += p.lng * w;
        totalW += w;
    }

    const bufferedPos = {
        lat:       wLat / totalW,
        lng:       wLng / totalW,
        accuracy:  newPosition.accuracy,
        heading:   validatedHeading,
        timestamp: currentTime,
        speedMPS:  effSpeed
    };

    // ── SMOOTHING FACTOR ──────────────────────────────────────────────────────
    const BRACKETS = [
        { base: 0.15, mult: 0.10, max: 0.28, min: 0.11 },
        { base: 0.23, mult: 0.12, max: 0.38, min: 0.18 },
        { base: 0.33, mult: 0.14, max: 0.46, min: 0.28 },
        { base: 0.38, mult: 0.10, max: 0.48, min: 0.32 },
        { base: 0.40, mult: 0.08, max: 0.48, min: 0.34 },
        { base: 0.38, mult: 0.07, max: 0.45, min: 0.33 },
        { base: 0.35, mult: 0.06, max: 0.41, min: 0.31 },
        { base: 0.31, mult: 0.05, max: 0.37, min: 0.27 },
        { base: 0.27, mult: 0.04, max: 0.37, min: 0.23 },
        { base: 0.23, mult: 0.03, max: 0.33, min: 0.19 }
    ];

    const br = BRACKETS[tierIndex];
    let smoothFactor = Math.min(br.max, Math.max(br.min, br.base + (speedFactor * br.mult)));
    smoothFactor += Math.min(0.05, distance * 0.0035);
    if (timeDelta > 0) smoothFactor += Math.min(0.03, Math.max(-0.015, (timeDelta - 0.35) * 0.045));
    if (headingDiff > 20 && speedMPH < 45) smoothFactor -= Math.max(0, 0.04 - (headingDiff / 200) * 0.06);
    if (eastWestMovement) smoothFactor += 0.018;
    smoothFactor = Math.max(0.05, smoothFactor - accuracyPenalty);
    smoothFactor = Math.min(0.52, Math.max(0.11, smoothFactor)) * directionChangeFactor;

    // ── SMOOTHED POSITION ─────────────────────────────────────────────────────
    const smoothedPos = {
        lat:       lastPos.lat * (1 - smoothFactor) + bufferedPos.lat * smoothFactor,
        lng:       lastPos.lng * (1 - smoothFactor) + bufferedPos.lng * smoothFactor,
        accuracy:  bufferedPos.accuracy,
        heading:   bufferedPos.heading,
        timestamp: currentTime,
        speedMPS:  bufferedPos.speedMPS
    };

    // ── ANIMATION PARAMS ──────────────────────────────────────────────────────
    let animDur = speedTier.panDuration;
    animDur -= Math.min(0.02, distance * 0.001);
    animDur += timeDelta > 0 ? Math.max(-0.01, Math.min(0.02, (0.25 - timeDelta) * 0.04)) : 0;
    animDur += headingDiff > 20 ? Math.min(0.04, headingDiff / 300 * 0.08) : 0;
    animDur += eastWestMovement  ? Math.min(0.025, distance * 0.0005) : 0;
    animDur  = Math.max(0.03, animDur) * directionChangeFactor;
    if (speedMPH < 3) animDur = Math.min(animDur, 0.4);

    const easeLin = eastWestMovement
        ? Math.max(0.07, Math.min(0.19, (0.13 - (speedMPH * 0.0006)) * directionChangeFactor))
        : Math.max(0.08, Math.min(0.23, (0.15 - (speedMPH * 0.0011)) * directionChangeFactor));

    // ── LOOK-AHEAD ────────────────────────────────────────────────────────────
    const LA_BRACKETS = [
        { base: 0,     mult: 0.020, max: 0.028 },
        { base: 0,     mult: 0.038, max: 0.060 },
        { base: 0.028, mult: 0.090, max: 0.160 },
        { base: 0.060, mult: 0.120, max: 0.180 },
        { base: 0.045, mult: 0.090, max: 0.135 },
        { base: 0.030, mult: 0.060, max: 0.090 },
        { base: 0.020, mult: 0.040, max: 0.060 },
        { base: 0.012, mult: 0.022, max: 0.034 },
        { base: 0.008, mult: 0.015, max: 0.023 },
        { base: 0.004, mult: 0.008, max: 0.020 }
    ];

    const lab     = LA_BRACKETS[tierIndex];
    let lookAhead = Math.min(lab.max, lab.base + (speedFactor * lab.mult));
    lookAhead += (speedMPH < 15) ? Math.min(0.08, distance * 0.0055) : 0;
    lookAhead -= headingDiff > 25 ? Math.min(0.14, headingDiff / 200 * 0.22) : 0;
    lookAhead += (speedMPH < 15 && eastWestMovement) ? Math.min(0.055, distance * 0.0013) : 0;
    lookAhead  = Math.max(0.01, lookAhead);

    // ── SYNCHRONOUS STATE COMMIT ──────────────────────────────────
    window.lastPosition   = smoothedPos;
    window.lastVelocity   = {
        lat: timeDelta > 0 ? (lat - lastPos.lat) / timeDelta : 0,
        lng: timeDelta > 0 ? (lng - lastPos.lng) / timeDelta : 0
    };
    window.lastUpdateTime = currentTime;

    // ── VISUAL UPDATE (RAF) ───────────────────────────────────────────────────
    if (window._nextLocationUpdateRAF) {
        cancelAnimationFrame(window._nextLocationUpdateRAF);
        window._nextLocationUpdateRAF = null;
    }
    if (window._visualUpdateFallbackTimer) {
        clearTimeout(window._visualUpdateFallbackTimer);
        window._visualUpdateFallbackTimer = null;
    }

    // ── RAF CLOSURE STALE CAPTURE ─────────────────────────────────
    const snap = {
        smoothedPos,
        lastPos,
        speedTier,
        forceMapThisFrame,
        directionChangeFactor,
        eastWestMovement,
        speedMPH,
        modeSpeedMPH,
        animDur,
        easeLin,
        lookAhead,
        effSpeed,
        currentTime,
        isInCenteredMode,
        tierIndex,
        smoothFactor,
        closestDistance,
        distance
    };

    // ── ATOMIC EXECUTION GUARD ────────────────────────
    let visualHasExecuted = false;

    const doVisualUpdate = (source) => {
        if (visualHasExecuted) return;
        visualHasExecuted = true;

        if (source === 'raf') {
            clearTimeout(window._visualUpdateFallbackTimer);
            window._visualUpdateFallbackTimer = null;
        } else {
            cancelAnimationFrame(window._nextLocationUpdateRAF);
            window._nextLocationUpdateRAF = null;
            console.warn('[Performance] RAF blocked - executing fallback');
        }

        // ── consume forced-update timestamp ───────────
        if (snap.forceMapThisFrame) window._forceMapUpdateTime = null;

        // Circuit breaker on repeated visual update errors.
        if ((window._visualErrorCount || 0) >= 5) {
            if (!window.mapFatalError) {
                window.mapFatalError = true;
                console.error("updateUserLocation: Too many consecutive visual errors — rendering suspended. Reload to recover.");
            }
            return;
        }

        try {
            // ── MARKER ───────────────────────────────────────────────────────
            if (typeof scheduleMarkerUpdate === 'function') {
                scheduleMarkerUpdate(snap.smoothedPos.lat, snap.smoothedPos.lng, {
                    animate:       true,
                    duration:      snap.animDur,
                    easeLinearity: snap.easeLin
                });
            }

            // ── MAP UPDATE DECISION ───────────────────────────────────────────
            const highSpeedThresh = (window.SPEED_THRESHOLDS?.HIGH_SPEED) || 45;
            const isDrift = snap.distance > 8.0 && snap.modeSpeedMPH >= highSpeedThresh;
            window._driftHysteresisCounter = isDrift
                ? (window._driftHysteresisCounter || 0) + 1
                : 0;

            const aggressiveness = typeof window.highSpeedAggressiveness === 'function'
                ? window.highSpeedAggressiveness(snap.speedMPH)
                : 0.5;

            const shouldUpdateMap =
                snap.forceMapThisFrame ||
                (snap.currentTime - (window.lastMapUpdateTime || 0) > snap.speedTier.mapUpdateInterval) ||
                (snap.distance > snap.speedTier.mapUpdateDistance * (1 - 0.4 * Math.max(0.1, aggressiveness))) ||
                (window._driftHysteresisCounter >= 2);

            // ── PAN ───────────────────────────────────────────────────────────
            if (shouldUpdateMap && !window.isMapInteracting && window.followUser && map && !window.isPanning) {
                const bounds = map.getBounds();
                if (bounds) {
                    if (snap.isInCenteredMode) {
                        if (typeof _panMapToLookAhead === 'function') {
                            const lookAheadPosition = {
                                lat: snap.smoothedPos.lat + (snap.smoothedPos.lat - snap.lastPos.lat) * snap.lookAhead,
                                lng: snap.smoothedPos.lng + (snap.smoothedPos.lng - snap.lastPos.lng) * snap.lookAhead,
                            };
                            _panMapToLookAhead(lookAheadPosition, snap.speedTier, snap.directionChangeFactor, snap.eastWestMovement, snap.speedMPH, bounds);
                        } else if (typeof _panMapToCenter === 'function') {
                            _panMapToCenter(snap.smoothedPos, snap.speedTier, snap.directionChangeFactor, snap.eastWestMovement, snap.speedMPH, snap.lookAhead);
                        }
                    } else {
                        if (typeof _isNearViewportEdge === 'function' && _isNearViewportEdge(snap.smoothedPos, bounds, snap.speedMPH)) {
                            if (typeof _panMapIfNearEdge === 'function') {
                                _panMapIfNearEdge(snap.smoothedPos, snap.speedTier, snap.directionChangeFactor, snap.eastWestMovement, bounds, snap.speedMPH);
                            }
                        } else if (snap.forceMapThisFrame && typeof _panMapToCenter === 'function') {
                            _panMapToCenter(snap.smoothedPos, snap.speedTier, snap.directionChangeFactor, snap.eastWestMovement, snap.speedMPH, snap.lookAhead);
                        }
                    }
                }
                window.lastMapUpdateTime = snap.currentTime;
            }

            // ── PROXIMITY ZOOM ────────────────────────────────────────────────
            if (!window.isMapInteracting && typeof _handleProximityZoom === 'function' && window.proximityState) {
                _handleProximityZoom(snap.modeSpeedMPH, snap.eastWestMovement);
            }

            // ── SPEED ZOOM ────────────────────────────────────────────────────
            if (shouldUpdateMap && !window.isMapInteracting && window.followUser && map) {
                if (typeof _applyIntelligentZoom === 'function') {
                    _applyIntelligentZoom(snap.effSpeed, snap.speedTier, snap.directionChangeFactor, snap.speedMPH);
                }
            }

            // ── VIEWPORT SAFETY ───────────────────────────────────────────────
            if (typeof _enforceViewportSafety === 'function' && userMarker) {
                const markerPos = userMarker.getLatLng();
                if (markerPos) _enforceViewportSafety(snap.speedMPH, markerPos);
            }

            if (typeof updateDistanceBox === 'function') updateDistanceBox(forceUpdate);

            // Reset circuit breaker on clean frame
            window._visualErrorCount = 0;

            // ── DEBUG TELEMETRY ───────────────────────────────────────────────
            if (window.__debugLocation) {
                console.table({
                    speedMPH:      snap.speedMPH.toFixed(1),
                    modeSpeed:     snap.modeSpeedMPH.toFixed(1),
                    tier:          snap.tierIndex,
                    smoothing:     snap.smoothFactor.toFixed(3),
                    duration:      snap.animDur.toFixed(2),
                    mode:          snap.isInCenteredMode ? 'centered' : 'edge',
                    proximity:     snap.closestDistance !== Infinity ? snap.closestDistance.toFixed(0) + 'm' : 'N/A',
                    forceMapFrame: snap.forceMapThisFrame,
                    eastWest:      snap.eastWestMovement,
                    source
                });
            }
        } catch (error) {
            window._visualErrorCount = (window._visualErrorCount || 0) + 1;
            console.error(`Visual update error (${window._visualErrorCount}/5):`, error);
        }
    };

    window._nextLocationUpdateRAF = requestAnimationFrame(() => {
        window._nextLocationUpdateRAF = null;
        doVisualUpdate('raf');
    });

    window._visualUpdateFallbackTimer = setTimeout(() => {
        window._visualUpdateFallbackTimer = null;
        doVisualUpdate('fallback');
    }, 50);
}
        
/* Calculates a new map center in roaming mode when user approaches viewport edge. */
function _calculateRoamingTarget(userPos, bounds, speedMPH) {
    const currentCenter = map.getCenter();

    if (!_isNearViewportEdge(userPos, bounds, speedMPH)) {
        return currentCenter;
    }

    const viewportWidth = bounds.getEast() - bounds.getWest();
    const viewportHeight = bounds.getNorth() - bounds.getSouth();

    const marginLat = viewportHeight * 0.20;
    const marginLng = viewportWidth * 0.20;

    let adjustedLat = currentCenter.lat;
    let adjustedLng = currentCenter.lng;

    const distFromNorth = bounds.getNorth() - userPos.lat;
    const distFromSouth = userPos.lat - bounds.getSouth();
    const distFromEast = bounds.getEast() - userPos.lng;
    const distFromWest = userPos.lng - bounds.getWest();

    if (distFromNorth < marginLat) {
        adjustedLat = userPos.lat + (viewportHeight * 0.30);
    } else if (distFromSouth < marginLat) {
        adjustedLat = userPos.lat - (viewportHeight * 0.30);
    }

    if (distFromEast < marginLng) {
        adjustedLng = userPos.lng + (viewportWidth * 0.30);
    } else if (distFromWest < marginLng) {
        adjustedLng = userPos.lng - (viewportWidth * 0.30);
    }

    return { lat: adjustedLat, lng: adjustedLng };
}

/* Pans the map in roaming mode when the user approaches a viewport edge. */
function panMapInRoaming(
    target,
    speedTier,
    directionChangeFactor,
    eastWestMovement,
    speedMPH
) {
    /* Throttle – limit calls to roughly 20 fps. */
    const PAN_THROTTLE_MS = 50;                     // ~20 fps
    const now = Date.now();

    if (window._lastPanTime && now - window._lastPanTime < PAN_THROTTLE_MS) {
        return;                                     // Too soon; skip this frame
    }

    /*  Core dependency validation (unchanged semantics). */
    if (!map || typeof map.getBounds !== 'function') {
        console.warn('[PanRoaming] Map instance unavailable');
        return;
    }

    const bounds = map.getBounds();
    if (!bounds) {
        return;
    }

    /*  Input validation – mirrors original early‑returns. */
    if (!target || typeof target.lat !== 'number' || typeof target.lng !== 'number') {
        console.warn('[PanRoaming] Invalid target coordinates:', target);
        return;
    }

    if (!speedTier || typeof speedTier !== 'object') {
        console.warn('[PanRoaming] Invalid speed tier:', speedTier);
        return;
    }

    /* Mode enforcement – only run in roaming mode. */
    if (typeof ModeManager?.isCentered !== 'function') {
        console.warn('[PanRoaming] ModeManager unavailable');
        return;
    }

    if (ModeManager.isCentered()) {
        // Preserve original warning (only once per session to avoid spam)
        if (!window._centeredModeWarningShown) {
            console.warn('[PanRoaming] Called in centered mode — ignored');
            window._centeredModeWarningShown = true;
        }
        return;
    }
    // Reset warning flag when we are in the correct mode
    window._centeredModeWarningShown = false;

    /*  Global state initialisation – keep shape identical. */
    if (!window.centeringState || typeof window.centeringState !== 'object') {
        window.centeringState = {
            isCentered: false,
            lastPanPosition: null,
            panVelocity: { x: 0, y: 0 }
        };
    } else {
        // Force the flag to false (original behaviour)
        window.centeringState.isCentered = false;
    }

    /* edge detection with speed-scaled margins and critical zone */
    const mapSize = map.getSize();
    if (!mapSize || !mapSize.x || !mapSize.y) return;
    
    const targetPixel = map.latLngToContainerPoint(target);
    if (!targetPixel || typeof targetPixel.x !== 'number' || typeof targetPixel.y !== 'number') {
        return;
    }

    // Dynamic margin calculation (matches _isNearViewportEdge)
    const MIN_MARGIN = 150;
    const SPEED_FACTOR = 2.0;
    const CRITICAL_MARGIN = 40;
    
    const safeSpeed = isFinite(speedMPH) && speedMPH > 0 ? speedMPH : 0;
    const dynamicMargin = MIN_MARGIN + (safeSpeed * SPEED_FACTOR);
    const maxSafeMargin = Math.min(mapSize.x, mapSize.y) * 0.45;
    const marginPx = Math.max(Math.min(dynamicMargin, maxSafeMargin), CRITICAL_MARGIN);

    // Check if near edge
    const nearLeft   = targetPixel.x < marginPx;
    const nearRight  = targetPixel.x > (mapSize.x - marginPx);
    const nearTop    = targetPixel.y < marginPx;
    const nearBottom = targetPixel.y > (mapSize.y - marginPx);
    
    const isNearEdge = nearLeft || nearRight || nearTop || nearBottom;
    
    // Check if in CRITICAL zone (emergency territory)
    const criticalLeft   = targetPixel.x < CRITICAL_MARGIN;
    const criticalRight  = targetPixel.x > (mapSize.x - CRITICAL_MARGIN);
    const criticalTop    = targetPixel.y < CRITICAL_MARGIN;
    const criticalBottom = targetPixel.y > (mapSize.y - CRITICAL_MARGIN);
    
    const isInCriticalZone = criticalLeft || criticalRight || criticalTop || criticalBottom;
    
    // Check if completely off screen (absolute emergency)
    const isOffScreen = (
        targetPixel.x < 0 ||
        targetPixel.x > mapSize.x ||
        targetPixel.y < 0 ||
        targetPixel.y > mapSize.y
    );

    if (!isNearEdge && !isInCriticalZone && !isOffScreen) {
        // Target comfortably inside the view – nothing to do.
        window.centeringState.lastPanPosition = null;
        return;
    }

    /* Velocity‑based intensity (optional smoothing). */
    let panIntensity = 1.0;                                 // default multiplier

    if (window.centeringState.lastPanPosition && speedMPH > 0) {
        const elapsedMs = now - window._lastPanTime;
        if (elapsedMs > 0) {
            const deltaPx = targetPixel.subtract(window.centeringState.lastPanPosition);
            const velocity = deltaPx.divideBy(elapsedMs / 1000); // px/s

            // Exponential smoothing (70 % old, 30 % new)
            window.centeringState.panVelocity = {
                x: velocity.x * 0.3 + window.centeringState.panVelocity.x * 0.7,
                y: velocity.y * 0.3 + window.centeringState.panVelocity.y * 0.7
            };

            // Faster vehicle → stronger pan, capped to a reasonable range
            panIntensity = Math.min(1.5, Math.max(0.5, speedMPH / 30));
        }
    }

    /*  Execute the actual roaming‑mode pan with robust error handling. */
    try {
        const start = performance.now();

        // EMERGENCY: If off screen or in critical zone, bypass normal pan and force immediate correction
        if (isOffScreen || isInCriticalZone) {
            console.warn('[PanRoaming] ' + (isOffScreen ? 'OFF SCREEN' : 'CRITICAL ZONE') + ' - forcing immediate pan');
            
            // Force instant pan to recenter
            map.panTo(target, { 
                animate: false, 
                noMoveStart: true 
            });
            
            // Skip throttle for emergency
            window._lastPanTime = 0;
        } else {
            // Normal roaming mode pan
            _executeRoamingModePan(
                target,
                speedTier,
                directionChangeFactor * panIntensity, // apply intensity boost
                eastWestMovement,
                speedMPH,
                bounds
            );
            
            window._lastPanTime = now;
        }

        // Telemetry (debug only) 
        if (window.DEBUG_PANNING) {
            const dur = performance.now() - start;
            console.debug(`[PanRoaming] Executed in ${dur.toFixed(1)} ms`);
        }

        // Update state for the next frame
        window.centeringState.lastPanPosition = targetPixel;
    } catch (err) {
        console.error('[PanRoaming] Pan execution failed:', err);

        // Graceful degradation – reset our tracking state
        window.centeringState.lastPanPosition = null;
        window.centeringState.panVelocity = { x: 0, y: 0 };

        // Fallback to a simple built‑in pan (best‑effort)
        try {
            map.panTo(target, { animate: true, duration: 0.5 });
        } catch (fallbackErr) {
            console.warn('[PanRoaming] Fallback pan also failed');
        }
    }
}

/*  Pans the map to keep the user centered — **centered mode only**. */
function _panMapToCenter(target, speedTier, directionChangeFactor, eastWestMovement, speedMPH, lookAheadFactor = 0) {
    if (!map) {
        console.warn('[PanCenter] Map not available');
        return;
    }
    
    const bounds = map.getBounds?.();
    if (!bounds) {
        console.warn('[PanCenter] Bounds not available');
        return;
    }
    
    if (
        !target ||
        typeof target.lat !== 'number' ||
        typeof target.lng !== 'number' ||
        !isFinite(target.lat) ||
        !isFinite(target.lng)
    ) {
        console.warn('[PanCenter] Invalid target coordinates:', target);
        return;
    }
    
    // Enforce mode contract: this function is ONLY for centered mode
    if (!ModeManager.isCentered()) {
        console.warn('[PanCenter] Called outside centered mode — ignored');
        return;
    }
    
    // Initialize centering state if needed
    if (!window.centeringState) {
        window.centeringState = { isCentered: true };
    }
    window.centeringState.isCentered = true;
    
    // Execute centered-mode panning
    _executeCenteredModePan(target, speedTier, directionChangeFactor, eastWestMovement, speedMPH, lookAheadFactor);
}

/* Optional cleanup that can be called when the UI switches out of roaming mode. It resets all globals that this module touches, ensuring a clean slate. */
function cleanupRoamingState() {
    if (window.centeringState) {
        window.centeringState.lastPanPosition = null;
        window.centeringState.panVelocity = { x: 0, y: 0 };
    }
    window._lastPanTime = 0;
    window._centeredModeWarningShown = false;
}

/*ROAMING MODE (< HIGH_SPEED MPH): Only pan when near viewport edges */
function _executeRoamingModePan(target, speedTier, directionChangeFactor, eastWestMovement, speedMPH, bounds) {
    // Validate inputs
    if (!map || !target || !isFinite(target.lat) || !isFinite(target.lng)) return;
    
    const mapSize = map.getSize();
    if (!mapSize || !mapSize.x || !mapSize.y) return;
    
    // Convert target to screen pixels (VIEWPORT check, not geographical)
    const targetPixel = map.latLngToContainerPoint(target);
    if (!targetPixel || typeof targetPixel.x !== 'number' || typeof targetPixel.y !== 'number') {
        return;
    }
    
    // Speed-scaled margin calculation (matches other functions)
    const MIN_MARGIN = 150;
    const SPEED_FACTOR = 2.0;
    const CRITICAL_MARGIN = 40;
    
    const safeSpeed = isFinite(speedMPH) && speedMPH > 0 ? speedMPH : 0;
    const dynamicMargin = MIN_MARGIN + (safeSpeed * SPEED_FACTOR);
    const maxSafeMargin = Math.min(mapSize.x, mapSize.y) * 0.45;
    const marginPx = Math.max(Math.min(dynamicMargin, maxSafeMargin), CRITICAL_MARGIN);
    
    // Check if near any edge (VIEWPORT-based)
    const nearLeft   = targetPixel.x < marginPx;
    const nearRight  = targetPixel.x > (mapSize.x - marginPx);
    const nearTop    = targetPixel.y < marginPx;
    const nearBottom = targetPixel.y > (mapSize.y - marginPx);
    
    const isNearEdge = nearLeft || nearRight || nearTop || nearBottom;
    
    // Check if in CRITICAL zone
    const criticalLeft   = targetPixel.x < CRITICAL_MARGIN;
    const criticalRight  = targetPixel.x > (mapSize.x - CRITICAL_MARGIN);
    const criticalTop    = targetPixel.y < CRITICAL_MARGIN;
    const criticalBottom = targetPixel.y > (mapSize.y - CRITICAL_MARGIN);
    
    const isInCriticalZone = criticalLeft || criticalRight || criticalTop || criticalBottom;
    
    // Check if completely off screen
    const isOffScreen = (
        targetPixel.x < 0 ||
        targetPixel.x > mapSize.x ||
        targetPixel.y < 0 ||
        targetPixel.y > mapSize.y
    );
    
    // Early return if not near edge and not in danger
    if (!isNearEdge && !isInCriticalZone && !isOffScreen) {
        return;
    }
    
    // Calculate distance from center for duration adjustment
    const currentCenter = map.getCenter();
    const centerPixel = map.latLngToContainerPoint(currentCenter);
    
    const pixelDistance = Math.sqrt(
        Math.pow(targetPixel.x - centerPixel.x, 2) + 
        Math.pow(targetPixel.y - centerPixel.y, 2)
    );
    
    // Normalize distance (0 to 1, where 1 = half screen width/height)
    const maxDistance = Math.sqrt(
        Math.pow(mapSize.x / 2, 2) + 
        Math.pow(mapSize.y / 2, 2)
    );
    const normalizedDist = Math.min(1.0, pixelDistance / maxDistance);
    
    // EMERGENCY: If off screen or critical, force instant pan
    if (isOffScreen || isInCriticalZone) {
        console.warn('[Roaming] ' + (isOffScreen ? 'OFF SCREEN' : 'CRITICAL') + ' - instant pan');
        
        map.panTo([target.lat, target.lng], {
            animate: false,
            noMoveStart: true
        });
        return;
    }
    
    // Calculate animation duration
    let panDuration = (speedTier?.panDuration ?? 0.3) * (directionChangeFactor ?? 1.0);
    
    if (eastWestMovement) {
        panDuration *= 0.90;
    }
    
    // Adjust duration based on distance - closer to edge = faster response
    if (normalizedDist < 0.20) {
        panDuration *= 0.75;
    }
    
    panDuration = Math.max(0.1, Math.min(1.0, panDuration));
    
    // Calculate easing
    let easeLinearity = speedTier?.easeLinearity ?? 0.2;
    easeLinearity = Math.max(0.1, Math.min(0.4, easeLinearity));
    
    // Execute pan
    const centerTarget = [target.lat, target.lng];
    
    map.panTo(centerTarget, {
        animate: true,
        duration: panDuration,
        easeLinearity: easeLinearity,
        noMoveStart: true
    });
    
    if (window.DEBUG_PANNING) {
        console.debug(`[Roaming] Pan near edge: speed=${safeSpeed.toFixed(1)}mph, dist=${normalizedDist.toFixed(2)}, duration=${(panDuration*1000).toFixed(0)}ms`);
    }
}

/* CENTERED MODE (≥ HIGH_SPEED MPH): Always keep marker at exact center with look-ahead */
function _executeCenteredModePan(target, speedTier, directionChangeFactor, eastWestMovement, speedMPH, lookAheadFactor) {
    let centerLat = target.lat;
    let centerLng = target.lng;
    
    // Safe look-ahead using smoothed velocity
    if (
        lookAheadFactor > 0 &&
        window.smoothedVelocity?.lat != null &&
        window.smoothedVelocity?.lng != null
    ) {
        const biasScale = 0.00002;
        const biasLat = window.smoothedVelocity.lat * lookAheadFactor * biasScale;
        centerLat += biasLat;
        
        const lngMultiplier = eastWestMovement ? 0.85 : 1.0;
        const biasLng = window.smoothedVelocity.lng * lookAheadFactor * biasScale * lngMultiplier;
        centerLng += biasLng;
    }
    
    let panDuration = (speedTier?.panDuration ?? 0.2) * (directionChangeFactor ?? 1.0);
    
    // EXCLUSIVE RANGES: Only one multiplier applies based on speed
    if (speedMPH >= 30) {
        panDuration *= 0.70;
    } else if (speedMPH >= 20) {
        panDuration *= 0.80;
    } else if (speedMPH >= SPEED_THRESHOLDS.HIGH_SPEED) { 
        panDuration *= 0.90;
    }
    
    if (eastWestMovement) {
        panDuration *= 0.90;
    }
    
    panDuration = Math.max(0.05, Math.min(0.5, panDuration));
    
    let easeLinearity = speedTier?.easeLinearity ?? 0.15;
    
    if (speedMPH >= 20) {
        easeLinearity = Math.min(0.25, easeLinearity * 1.4);
    } else if (speedMPH >= SPEED_THRESHOLDS.HIGH_SPEED) { 
        easeLinearity = Math.min(0.20, easeLinearity * 1.2);
    }
    
    easeLinearity = Math.max(0.1, Math.min(0.5, easeLinearity));
    
    const centerTarget = [centerLat, centerLng];
    
    map.panTo(centerTarget, {
        animate: true,
        duration: panDuration,
        easeLinearity: easeLinearity,
        noMoveStart: true
    });
    
    console.debug(`[Centered] Pan to center: speed=${speedMPH.toFixed(1)}mph, duration=${(panDuration*1000).toFixed(0)}ms`);
}

// --- CLEANUP FUNCTION ---
function disposeMapLoop() {
    if (window._nextLocationUpdateRAF) {
        cancelAnimationFrame(window._nextLocationUpdateRAF);
        window._nextLocationUpdateRAF = null;
    }
    if (window.animationFrameId) {
        cancelAnimationFrame(window.animationFrameId);
        window.animationFrameId = null;
    }
    if (window.gpsTimeoutTimer) {
        clearTimeout(window.gpsTimeoutTimer);
        window.gpsTimeoutTimer = null;
    }
    if (window.debounceTimeoutId) {
        clearTimeout(window.debounceTimeoutId);
        window.debounceTimeoutId = null;
    }
    if (window._visualUpdateFallbackTimer) {
        clearTimeout(window._visualUpdateFallbackTimer);
        window._visualUpdateFallbackTimer = null;
    }
    if (window._markerFallbackTimer) {
        clearTimeout(window._markerFallbackTimer);
        window._markerFallbackTimer = null;
    }
    if (window.inactivityTimer) {
        clearTimeout(window.inactivityTimer);
        window.inactivityTimer = null;
    }
    console.log("Map loop timers/RAF disposed. State preserved.");
}
        
/* Core function that resets the map to a new position. Shared logic between initialization and jump handling. */
function _resetMapToPosition(newPosition, options = {}) {
    // Basic validation
    if (!map || !userMarker || !newPosition) return;
    
    // Options with defaults
    const currentTime = options.currentTime || Date.now();
    const resetType = options.resetType || 'jump';
    const forceUpdate = options.forceUpdate || false;
    const clearStationary = options.clearStationary !== false;
    
    // State reset (type-specific)
    if (resetType === 'init') {
        // Initialization-specific setup
        setupMapInteractionHandlers();
        
        // Initialize position buffer
        window.positionBuffer = window.positionBuffer || [];
        window.positionBuffer.length = 0;
        updatePositionBuffer(newPosition);
        
        // Set initialization-specific state
        window.stationaryStartTime = currentTime;
        window.isMapInteracting = false;
        window.lastInteractionTime = currentTime;
        window.blockSpeedZoom = false;
        window.zoomedInState = false;
        window._lastCenteredMode = false;
        window._viewportSafetyEnforced = false;
    } else {
        // Jump handling-specific setup
        if (clearStationary && window.stationaryCheckTimeout) {
            clearTimeout(window.stationaryCheckTimeout);
            window.stationaryCheckTimeout = null;
        }
        
        // Reset buffer with current position only
        window.positionBuffer = [newPosition];
        window.stationaryStartTime = null;
    }
    
    // Shared state updates
    window.lastPosition = newPosition;
    window.lastUpdateTime = currentTime;
    window.lastVelocity = { lat: 0, lng: 0 };
    window.smoothedVelocity = { lat: 0, lng: 0 };
    window.isStationary = false;
    window.stationaryLockPosition = null;
    window.followUser = true;
    
    // Shared map operations
    const mapContainer = map.getContainer();
    const originalTransition = mapContainer.style.transition;
    mapContainer.style.transition = 'none';
    
    // Calculate target zoom
    const currentZoom = map.getZoom();
    const intelligentZoom = getSpeedBasedZoom(newPosition.speedMPS);
    
    let targetZoom;
    if (resetType === 'init') {
        targetZoom = (typeof intelligentZoom === 'number' && intelligentZoom > 0)
            ? intelligentZoom
            : 17;
    } else {
        targetZoom = (typeof intelligentZoom === 'number' && intelligentZoom > 0)
            ? intelligentZoom
            : currentZoom;
    }
    
    // Center map and position marker
    try {
        userMarker.setLatLng([newPosition.lat, newPosition.lng]);
        map.setView([newPosition.lat, newPosition.lng], targetZoom, {
            animate: false,
            noMoveStart: true,
            noMoveEnd: true
        });
    } catch (error) {
        console.error(`${resetType} centering failed:`, error);
        
        const fallbackZoom = (resetType === 'init') ? 17 : currentZoom;
        map.setView([newPosition.lat, newPosition.lng], fallbackZoom, { animate: false });
        userMarker.setLatLng([newPosition.lat, newPosition.lng]);
    }
    
    // Restore transition after delay
    const restoreDelay = (resetType === 'init') ? 50 : 16;
    setTimeout(() => {
        if (mapContainer.isConnected) {
            mapContainer.style.transition = originalTransition;
        }
    }, restoreDelay);
    
    // Post-reset actions
    if (resetType === 'init') {
        // Initialization-specific UI updates
        if (typeof updateDistanceBox === 'function') {
            updateDistanceBox(forceUpdate);
        }
        
        if (typeof updateAccuracyIndicator === 'function') {
            updateAccuracyIndicator(newPosition.accuracy);
        }
    } else {
        // Jump handling-specific actions
        if (typeof isSignificantMovement === 'function' && 
            isSignificantMovement(newPosition) &&
            typeof resetInactivityTimer === 'function') {
            resetInactivityTimer(false);
        }
    }
    
    // Always enforce viewport safety
    _enforceViewportSafety(newPosition.speedMPS * 2.23694, userMarker.getLatLng());
}

/* Initializes user location state */
function _initializeUserLocationState(newPosition, currentTime, forceUpdate = false) {
    _resetMapToPosition(newPosition, {
        currentTime: currentTime,
        resetType: 'init',
        forceUpdate: forceUpdate,
        clearStationary: true
    });
}

/* Handles large distance jumps */
function _handleLargeDistanceJump(newPosition, currentTime) {
        // Clear buffer explicitly
    window.positionBuffer = [];
    
    // Add validation to re-seed properly
    validatePositionBuffer();
    
    _resetMapToPosition(newPosition, {
        currentTime: currentTime,
        resetType: 'jump',
        forceUpdate: false,
        clearStationary: true
    });
}

function _confirmStationary(newPosition, currentTime) {
    if (typeof handleProximityAndAutoOpen === 'function' && 
        window.lastClosestLocation && 
        window.lastClosestDistance !== undefined) {
        handleProximityAndAutoOpen(
            { lat: newPosition.lat, lng: newPosition.lng },
            Date.now(),
            window.lastClosestLocation,
            window.lastClosestDistance
        );
    }

    window.isStationary = true;
    window.stationaryLockPosition = { lat: newPosition.lat, lng: newPosition.lng };
    
    // Cancel any pending RAF marker updates before setting final position
    if (window._markerRAFPending) {
        cancelAnimationFrame(window._markerRAFPending);
        window._markerRAFPending = null;
    }
    if (window._markerFallbackTimer) {
        clearTimeout(window._markerFallbackTimer);
        window._markerFallbackTimer = null;
    }
    window._pendingMarkerUpdate = null;
    
    const currentLatLng = userMarker.getLatLng();
    const targetLatLng = L.latLng(newPosition.lat, newPosition.lng);
    const finalDistance = currentLatLng.distanceTo(targetLatLng);
    
    if (finalDistance > 0.5) {
        userMarker.setLatLng([newPosition.lat, newPosition.lng], {
            animate: true,
            duration: 0.8,
            easeLinearity: 0.06
        });
    } else {
        userMarker.setLatLng([newPosition.lat, newPosition.lng]);
    }
    
    window.lastPosition = newPosition;
    window.positionBuffer = [newPosition];
    window.lastUpdateTime = currentTime;
    if (typeof updateDistanceBox === 'function') updateDistanceBox();
}

function _clearStationaryState() {
    if (window.isStationary || window.stationaryStartTime) {
        window.isStationary = false;
        window.stationaryStartTime = null;
        window.stationaryLockPosition = null;
        if (window.stationaryCheckTimeout) {
            clearTimeout(window.stationaryCheckTimeout);
            window.stationaryCheckTimeout = null;
        }
    }
}

(function () {
    'use strict';

    // ── CONFIG ────────────────────────────────────────────────────────────────
    const PZ_CONFIG = {
        SPEED_GATE_MPH:          14,
        ZOOM_IN_THRESHOLD_FEET:  45,
        ZOOM_OUT_THRESHOLD_FEET: 70,
        ZOOM_IN_LEVEL:           19,
        ZOOM_OUT_LEVEL:          17,
        // DEBOUNCE_MS prevents re-triggering the same transition repeatedly.
        // Only guards zoom-in and zoom-out actions, not approach evaluation.
        DEBOUNCE_MS:             1500,
        // POST_ZOOM_IN_HYSTERESIS_MS: short window after zoom-in fires to prevent
        // an immediate double-fire if the RAF delivers two rapid calls. This is
        // intentionally small — it is NOT a dead zone on approach or exit.
        // The old HYSTERESIS_MS (2000ms) was applied after zoom-out and location
        // changes too, creating a mandatory 2s blind spot. That is gone.
        POST_ZOOM_IN_HYSTERESIS_MS: 600,
        // RATE_LIMIT_MS throttles RAF-driven calls to ~6/sec.
        RATE_LIMIT_MS:           150,
        DEBUG:                   false,
    };

    // ── CLOSURE STATE ─────────────────────────────────────────────────────────
    const state = {
        locationId:       null,
        isZoomedIn:       false,
        lastZoomIn:       0,   // timestamp of last zoom-in — used for debounce + hysteresis
        lastZoomOut:      0,   // timestamp of last zoom-out — used for debounce only
        lastCheck:        0,
    };

    // ── ZOOM IN ───────────────────────────────────────────────────────────────
    function _performProximityZoomIn(location, eastWestMovement, zoomLevel) {
        if (!window.map?.flyTo || window.isMapInteracting) return;
        try {
            const userPos = window.userMarker?.getLatLng?.();
            if (!userPos || !isFinite(userPos.lat) || !isFinite(userPos.lng)) return;

            // Pan slightly toward the POI so both user dot and destination
            // are visible at the zoomed-in level.
            const target = {
                lat: userPos.lat + (location.lat - userPos.lat) * 0.2,
                lng: userPos.lng + (location.lng - userPos.lng) * 0.2,
            };
            if (!isFinite(target.lat) || !isFinite(target.lng)) return;

            window.map.flyTo(target, zoomLevel, {
                duration:      2.0,
                easeLinearity: eastWestMovement ? 0.10 : 0.12,
                noMoveStart:   true,
            });
        } catch (err) {
            console.warn('[PZ] Zoom in failed:', err);
        }
    }

    // ── ZOOM OUT ──────────────────────────────────────────────────────────────
    function _performProximityZoomOut(eastWestMovement, zoomLevel) {
        if (!window.map?.flyTo || window.isMapInteracting) return;
        try {
            const currentZoom = window.map.getZoom?.();
            if (!isFinite(currentZoom)) return;
            // Don't animate if already at or near the target zoom.
            if (Math.abs(currentZoom - zoomLevel) < 0.5) return;

            const center = window.map.getCenter?.();
            if (!center || !isFinite(center.lat) || !isFinite(center.lng)) return;

            window.map.flyTo(center, zoomLevel, {
                duration:      1.4,
                easeLinearity: eastWestMovement ? 0.13 : 0.15,
                noMoveStart:   true,
            });
        } catch (err) {
            console.warn('[PZ] Zoom out failed:', err);
        }
    }

    // ── RESET ─────────────────────────────────────────────────────────────────
    // Clears zoom lock and global flags. Does NOT touch lastZoomIn / lastZoomOut
    // — callers read those independently for debounce/hysteresis decisions.
    function _resetProximityZoom(reason = 'unknown') {
        try {
            if (state.isZoomedIn && window.zoomController) {
                try {
                    const zoomState = window.zoomController.getState();
                    if (zoomState?.source === 'proximity') {
                        window.zoomController.release('proximity');
                    }
                } catch (_) {}
            }

            state.isZoomedIn = false;
            window.zoomedInState  = false;
            window.isNearLocation = false;
            window.blockSpeedZoom = false;

            if (PZ_CONFIG.DEBUG) console.log(`[PZ] Reset: ${reason}`);
        } catch (err) {
            console.error('[PZ] Reset error:', err);
            window.zoomedInState  = false;
            window.isNearLocation = false;
            window.blockSpeedZoom = false;
        }
    }

    // ── MAIN HANDLER ──────────────────────────────────────────────────────────
    function _handleProximityZoom(speedMPH, eastWestMovement) {
        // Guard: dependencies
        if (!window.map || !window.zoomController) return;

        // Guard: location hunt UI is open — release zoom and do nothing
        if (
            document.querySelector('.lochunt-container')?.style.display === 'flex' ||
            window.isLocationHuntVisible
        ) {
            if (state.isZoomedIn) {
                _resetProximityZoom('location_hunt_active');
                state.locationId = null;
            }
            return;
        }

        // Guard: rate limit
        const now = performance.now();
        if (now - state.lastCheck < PZ_CONFIG.RATE_LIMIT_MS) return;
        state.lastCheck = now;

        // Guard: speed gate
        if (speedMPH >= PZ_CONFIG.SPEED_GATE_MPH) {
            if (state.isZoomedIn) {
                _performProximityZoomOut(eastWestMovement, PZ_CONFIG.ZOOM_OUT_LEVEL);
                _resetProximityZoom('speed_gate');
                state.locationId = null;
            }
            return;
        }

        // Guard: valid proximity data
        const proximity = window.proximityState;
        if (!proximity?.closestLocation || proximity.distanceMeters === Infinity) {
            if (state.isZoomedIn || state.locationId) {
                _performProximityZoomOut(eastWestMovement, PZ_CONFIG.ZOOM_OUT_LEVEL);
                _resetProximityZoom('no_proximity_data');
                state.locationId = null;
            }
            return;
        }

        const location     = proximity.closestLocation;
        const distanceFeet = proximity.distanceMeters * 3.28084;
        const locationId   = String(
            location.id ?? `${location.lat.toFixed(6)},${location.lng.toFixed(6)}`
        );

        // ── LOCATION CHANGE ───────────────────────────────────────────────────
        // Set the new locationId immediately (not next call) so we don't hit an
        // extra round-trip. If we were zoomed in on the old POI, zoom out first.
        if (state.locationId && state.locationId !== locationId) {
            if (PZ_CONFIG.DEBUG) console.log(`[PZ] Location changed: ${state.locationId} → ${locationId}`);
            if (state.isZoomedIn) {
                _performProximityZoomOut(eastWestMovement, PZ_CONFIG.ZOOM_OUT_LEVEL);
            }
            _resetProximityZoom('location_change');
            state.locationId = locationId;
            // No lastZoomIn reset here — we don't want hysteresis to block
            // zoom-in on the new POI if the user is already inside the threshold.
            return;
        }

        if (!state.locationId) state.locationId = locationId;

        // ── ZOOM IN ───────────────────────────────────────────────────────────
        if (!state.isZoomedIn && distanceFeet <= PZ_CONFIG.ZOOM_IN_THRESHOLD_FEET) {
            // Debounce: prevent double-fire from rapid calls
            if (now - state.lastZoomIn < PZ_CONFIG.DEBOUNCE_MS) return;

            // POST_ZOOM_IN_HYSTERESIS: short guard immediately after a zoom-in
            // to prevent the zoom-out branch from firing before the flyTo settles.
            // Only blocks zoom-out evaluation, not zoom-in (handled by isZoomedIn).
            const zoomState = window.zoomController.getState();
            if (zoomState?.source && zoomState.source !== 'proximity' && zoomState.source !== 'speed') return;

            const granted = window.zoomController.request('proximity', PZ_CONFIG.ZOOM_IN_LEVEL, 3);
            if (!granted) return;

            state.isZoomedIn  = true;
            state.lastZoomIn  = now;
            window.zoomedInState  = true;
            window.isNearLocation = true;
            window.blockSpeedZoom = true;

            if (PZ_CONFIG.DEBUG) console.log(`[PZ] Zoom IN: ${locationId} (${Math.round(distanceFeet)}ft)`);
            _performProximityZoomIn(location, eastWestMovement, PZ_CONFIG.ZOOM_IN_LEVEL);
            return;
        }

        // ── ZOOM OUT ──────────────────────────────────────────────────────────
        if (state.isZoomedIn && distanceFeet >= PZ_CONFIG.ZOOM_OUT_THRESHOLD_FEET) {
            // Debounce: prevent double-fire
            if (now - state.lastZoomOut < PZ_CONFIG.DEBOUNCE_MS) return;

            // Short hysteresis after zoom-in: don't zoom back out immediately
            // if the user momentarily drifted past the exit threshold right
            // after arriving. The flyTo animation itself takes ~2s, so 2500ms
            // ensures the animation finishes before we consider zooming out.
            if (now - state.lastZoomIn < PZ_CONFIG.POST_ZOOM_IN_HYSTERESIS_MS + 2000) return;

            if (PZ_CONFIG.DEBUG) console.log(`[PZ] Zoom OUT: ${locationId} (${Math.round(distanceFeet)}ft)`);

            // Animate out BEFORE releasing the controller lock, so the animation
            // fires while we still own the lock. release() no longer triggers its
            // own animation, so there is exactly one flyTo call here.
            _performProximityZoomOut(eastWestMovement, PZ_CONFIG.ZOOM_OUT_LEVEL);

            // Now release the lock and clean state.
            const zoomState = window.zoomController.getState();
            if (zoomState?.source === 'proximity') {
                window.zoomController.release('proximity');
            }

            state.isZoomedIn  = false;
            state.locationId  = null; // ready for next approach
            state.lastZoomOut = now;
            window.zoomedInState  = false;
            window.isNearLocation = false;
            window.blockSpeedZoom = false;
        }
    }

    // ── EXPORTS ───────────────────────────────────────────────────────────────
    if (typeof window !== 'undefined') {
        window._handleProximityZoom      = _handleProximityZoom;
        window._resetProximityZoom       = _resetProximityZoom;
        window._performProximityZoomIn   = _performProximityZoomIn;
        window._performProximityZoomOut  = _performProximityZoomOut;

        window.addEventListener('beforeunload', () => _resetProximityZoom('unload'));
    }
})();
        
/* Returns true when the target position (usually the user) is within a speed-scaled margin of any viewport edge. */
function _isNearViewportEdge(targetPos, bounds, speedMPH) {
    // Safety Checks - ensure Leaflet map is fully initialized
    if (!window.map || !window.map._loaded || typeof window.map.getSize !== 'function') {
        return false;
    }
    if (!targetPos) return false;
    
    // Configuration - More aggressive to catch edge approaches earlier
    const MIN_MARGIN   = 150;  // Increased from 80 - catch it earlier
    const SPEED_FACTOR = 2.0;  // Increased from 1.5 - more buffer at speed
    const CRITICAL_ZONE = 60;  // Absolute minimum distance from edge
    
    // Calculate Dynamic Margin
    const mapSize = window.map.getSize();
    
    // If map is not ready, fail safely
    if (!mapSize || !mapSize.x || !mapSize.y) return false;
    
    const safeSpeed = isFinite(speedMPH) && speedMPH > 0 ? speedMPH : 0;
    
    // Calculate margin with speed scaling, clamp to 45% of smaller dimension
    const dynamicMargin = MIN_MARGIN + (safeSpeed * SPEED_FACTOR);
    const maxSafeMargin = Math.min(mapSize.x, mapSize.y) * 0.45;
    const marginPx = Math.min(dynamicMargin, maxSafeMargin);
    
    // Always enforce minimum critical zone
    const effectiveMargin = Math.max(marginPx, CRITICAL_ZONE);
    
    // Convert Lat/Lng to Screen Pixels
    const pixel = window.map.latLngToContainerPoint(targetPos);
    
    // Handle edge case where conversion fails (e.g. off-world coords)
    if (!pixel || typeof pixel.x !== 'number' || typeof pixel.y !== 'number') {
        return false;
    }
    
    // Check Boundaries - use effective margin
    const nearLeft   = pixel.x < effectiveMargin;
    const nearRight  = pixel.x > (mapSize.x - effectiveMargin);
    const nearTop    = pixel.y < effectiveMargin;
    const nearBottom = pixel.y > (mapSize.y - effectiveMargin);
    
    return nearLeft || nearRight || nearTop || nearBottom;
}

/* Returns true if position is in CRITICAL danger zone (very close to edge) */

        
function _emergencyCenterMap(position, speedTier, directionChangeFactor, eastWestMovement, speedMPH) {
    if (!window.map || !window.map.getContainer || !position) return;
    
    // Validate position coordinates
    if (!isFinite(position.lat) || !isFinite(position.lng)) {
        console.warn('[Emergency Center] Invalid position coordinates');
        return;
    }
    
    const mapContainer = window.map.getContainer();
    if (!mapContainer) return;
    
    // Add distance check FIRST (prevents unnecessary animations)
    const currentCenter = window.map.getCenter();
    if (!currentCenter) return;
    
    const targetCenter = L.latLng(position.lat, position.lng);
    const distanceMoved = currentCenter.distanceTo(targetCenter);
    
    if (distanceMoved < 0.5) {
        return; // Too small to animate
    }
    
    // Add hardware acceleration
    mapContainer.style.willChange = 'transform';
    mapContainer.style.transform = 'translateZ(0)';
    
    // Speed-based timing with safe defaults
    const safeSpeed = isFinite(speedMPH) && speedMPH > 0 ? speedMPH : 0;
    const HIGH_SPEED = (window.SPEED_THRESHOLDS && window.SPEED_THRESHOLDS.HIGH_SPEED) || 25;
    
    // Declare cleanup variables BEFORE defining cleanup function
    let cleanupExecuted = false;
    let fallbackTimeout = null;
    let moveEndHandler = null;
    let zoomEndHandler = null;
    
    const cleanup = () => {
        if (cleanupExecuted) return;
        cleanupExecuted = true;
        
        // Clear timeout
        if (fallbackTimeout) {
            clearTimeout(fallbackTimeout);
            fallbackTimeout = null;
        }
        
        // Remove event listeners
        if (moveEndHandler) {
            window.map.off('moveend', moveEndHandler);
            moveEndHandler = null;
        }
        if (zoomEndHandler) {
            window.map.off('zoomend', zoomEndHandler);
            zoomEndHandler = null;
        }
        
        // Reset styles safely
        if (mapContainer && mapContainer.isConnected) {
            mapContainer.style.willChange = 'auto';
            mapContainer.style.transform = '';
        }
    };
    
    // Execute pan with speed-appropriate settings
    try {
        if (safeSpeed > 30) {
            window.map.panTo(position, { animate: false, noMoveStart: true });
            cleanup(); // Immediate cleanup for instant pan
        } else if (safeSpeed > 15) {
            window.map.panTo(position, { 
                animate: true, 
                duration: 0.12, 
                easeLinearity: 0.5, 
                noMoveStart: true 
            });
            
            fallbackTimeout = setTimeout(cleanup, 250);
            moveEndHandler = () => {
                clearTimeout(fallbackTimeout);
                cleanup();
            };
            window.map.once('moveend', moveEndHandler);
            zoomEndHandler = cleanup;
            window.map.once('zoomend', zoomEndHandler);
        } else {
            window.map.panTo(position, { 
                animate: true, 
                duration: 0.30, 
                easeLinearity: 0.3, 
                noMoveStart: true 
            });
            
            fallbackTimeout = setTimeout(cleanup, 450);
            moveEndHandler = () => {
                clearTimeout(fallbackTimeout);
                cleanup();
            };
            window.map.once('moveend', moveEndHandler);
            zoomEndHandler = cleanup;
            window.map.once('zoomend', zoomEndHandler);
        }
    } catch (error) {
        console.error('[Emergency Center] Pan failed:', error);
        cleanup();
    }
}

/* Pans the map to a predicted future position (look-ahead) to keep the user centered during high-speed travel. */
function _panMapToLookAhead(lookAheadPosition, speedTier, directionChangeFactor, eastWestMovement, speedMPH, bounds) {
    // Safety & Interaction Guards
    if (!lookAheadPosition || !speedTier || !window.map) return;
    
    // Validate coordinates
    if (!isFinite(lookAheadPosition.lat) || !isFinite(lookAheadPosition.lng)) {
        console.warn('[Pan LookAhead] Invalid coordinates');
        return;
    }

    // Do not pan if the user is currently touching/interacting with the map.
    if (window.isMapInteracting) return;

    // Do not pan if tracking has been disabled
    if (!window.followUser) return;

    // Prevent overlapping animations - CRITICAL for pinch/zoom
    if (window.isPanning) return;

    // Calculate Animation Dynamics
    const basePanDuration = speedTier.panDuration || 0.2;
    const rawDuration = basePanDuration * (directionChangeFactor || 1) * (eastWestMovement ? 0.9 : 1);
    const panDuration = Math.max(0.05, Math.min(1.0, rawDuration));

    const baseEase = speedTier.easeLinearity || 0.25;
    const easeLinearity = Math.max(0.1, Math.min(0.9, baseEase * (eastWestMovement ? 0.8 : 1)));

    // GPU Optimization
    const mapContainer = window.map.getContainer();
    if (!mapContainer) {
        return;
    }
    
    // Set flag BEFORE any async operations
    window.isPanning = true;
    mapContainer.style.willChange = 'transform';

    // Declare cleanup variables BEFORE defining cleanup
    let timeoutId = null;
    let isCleaned = false;
    let moveEndHandler = null;

    const cleanup = () => {
        if (isCleaned) return;
        isCleaned = true;

        window.isPanning = false;
        
        if (mapContainer && mapContainer.isConnected) {
            mapContainer.style.willChange = 'auto';
        }
        
        if (timeoutId) {
            clearTimeout(timeoutId);
            timeoutId = null;
        }
        
        if (moveEndHandler) {
            window.map.off('moveend', moveEndHandler);
            moveEndHandler = null;
        }
    };

    // Execute Pan
    try {
        window.map.panTo(lookAheadPosition, {
            animate: true,
            duration: panDuration,
            easeLinearity: easeLinearity,
            noMoveStart: true
        });

        // Safety net: Ensure cleanup happens even if 'moveend' never fires
        timeoutId = setTimeout(cleanup, (panDuration * 1000) + 150);
        
        moveEndHandler = cleanup;
        window.map.once('moveend', moveEndHandler);
    } catch (error) {
        console.error('[Pan LookAhead] Failed:', error);
        cleanup();
    }
}
/*
function calculateDistance(pos1, pos2) {
    if (!pos1 || !pos2) return Infinity;
    
    // Extract coordinates, handling both naming conventions
    const lat1 = pos1.lat ?? pos1.latitude;
    const lng1 = pos1.lng ?? pos1.longitude;
    const lat2 = pos2.lat ?? pos2.latitude;
    const lng2 = pos2.lng ?? pos2.longitude;
    
    // Validate coordinates
    if (!isFinite(lat1) || !isFinite(lng1) || 
        !isFinite(lat2) || !isFinite(lng2)) {
        return Infinity;
    }
    
    // Haversine formula
    const R = 6371000; // Earth's radius in meters
    const toRad = Math.PI / 180;
    
    const dLat = (lat2 - lat1) * toRad;
    const dLng = (lng2 - lng1) * toRad;
    
    const a = Math.sin(dLat / 2) ** 2 +
              Math.cos(lat1 * toRad) * Math.cos(lat2 * toRad) *
              Math.sin(dLng / 2) ** 2;
    
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    
    return R * c;
}
*/
function _isValidCoords(lat, lng) {
  return Number.isFinite(lat) && Number.isFinite(lng) &&
    lat >= -90 && lat <= 90 && lng >= -180 && lng <= 180;
}

function _isMapReady() {
  return typeof map !== 'undefined' && map &&
    typeof userMarker !== 'undefined' && userMarker;
}

function _calculateEMA(currentValue, previousEMA, alpha) {
  return (previousEMA === undefined) ? currentValue : alpha * currentValue + (1 - alpha) * previousEMA;
}

function _getSpeedTierIndex(modeSpeedMPH) {
  if (modeSpeedMPH < 1) return 0;
  if (modeSpeedMPH < 5) return 1;
  if (modeSpeedMPH < 12) return 2;
  if (modeSpeedMPH < 16) return 3;
  if (modeSpeedMPH < 24) return 4;
  if (modeSpeedMPH < 34) return 5;
  if (modeSpeedMPH < 48) return 6;
  if (modeSpeedMPH < 65) return 7;
  if (modeSpeedMPH < 85) return 8;
  return 9;
}

function _detectEastWestMovement(lat1, lng1, lat2, lng2) {
  const latDelta = Math.abs(lat2 - lat1);
  const lngDelta = Math.abs(lng2 - lng1);
  return lngDelta > latDelta * 1.2;
}

function _validateAcceleration(speedMPH, lastSpeedMPH, timeDelta) {
  if (timeDelta <= 0 || timeDelta >= 5) return true;

  const accel = Math.abs(speedMPH - lastSpeedMPH) / timeDelta;

  if (speedMPH < 3 && accel > 25) {
    console.warn(`Rejecting acceleration ${accel.toFixed(1)} mph/s at very low speed`);
    return false;
  }
  if (speedMPH < 8 && accel > 22) {
    console.warn(`Rejecting acceleration ${accel.toFixed(1)} mph/s at low speed`);
    return false;
  }
  if (speedMPH < 15 && accel > 18) {
    console.warn(`Rejecting acceleration ${accel.toFixed(1)} mph/s at medium speed`);
    return false;
  }

  return true;
}

function _validateHeading(heading, lastHeading, speedMPS) {
  if (lastHeading == null || heading == null) return heading;

  let diff = Math.abs(heading - lastHeading);
  if (diff > 180) diff = 360 - diff;

  if (speedMPS < 2 && diff > 90) {
    return lastHeading;
  }

  return heading;
}

function _calculateHeadingDiff(heading1, heading2) {
  if (heading1 == null || heading2 == null) return 0;
  let diff = Math.abs(heading2 - heading1);
  if (diff > 180) diff = 360 - diff;
  return diff;
}

function _getDirectionChangeFactor(headingDiff) {
  if (headingDiff <= 12) return 1.0;
  return Math.max(0.5, 1 - (headingDiff / 240));
}

function _buildSpeedTier(tierIndex, eastWestMovement) {
  const tier = TIER_CONFIGS[tierIndex];
  const ewAdj = eastWestMovement ? 0.88 : 1.0;

  return {
    microMovementThreshold: tier.micro,
    minDistanceThreshold: tier.minDist * ewAdj,
    maxAccuracy: tier.maxAcc,
    maxSpeedThreshold: tier.maxSpd,
    mapUpdateInterval: Math.max(33, tier.mapInt * ewAdj),
    mapUpdateDistance: tier.mapDist,
    panDuration: tier.panDur * ewAdj,
    easeLinearity: tier.easeLin * (eastWestMovement ? 0.92 : 1.0),
    zoomThreshold: tier.zoomThresh,
    zoomDuration: tier.zoomDur
  };
}

function _calculateSmoothingFactor(
  tierIndex, speedFactor, distance, timeDelta, headingDiff, speedMPH, eastWestMovement, directionChangeFactor
) {
  const br = SMOOTHING_BRACKETS[tierIndex];
  let smoothFactor = Math.min(br.max, Math.max(br.min, br.base + (speedFactor * br.mult)));

  smoothFactor += Math.min(0.05, distance * 0.0035);

  if (timeDelta > 0) {
    smoothFactor += Math.min(0.03, Math.max(-0.015, (timeDelta - 0.35) * 0.045));
  }

  if (headingDiff > 20 && speedMPH < 45) {
    smoothFactor -= Math.max(0, 0.04 - (headingDiff / 200) * 0.06);
  }

  if (eastWestMovement) {
    smoothFactor += 0.018;
  }

  smoothFactor = Math.min(0.52, Math.max(0.11, smoothFactor)) * directionChangeFactor;

  return smoothFactor;
}

function _calculateLookAhead(tierIndex, speedFactor, headingDiff, speedMPH, distance, eastWestMovement) {
  const lab = LOOKAHEAD_BRACKETS[tierIndex];
  let lookAhead = Math.min(lab.max, lab.base + (speedFactor * lab.mult));

  lookAhead += (speedMPH < 15) ? Math.min(0.08, distance * 0.0055) : 0;
  lookAhead -= headingDiff > 25 ? Math.min(0.14, headingDiff / 200 * 0.22) : 0;
  lookAhead += (speedMPH < 15 && eastWestMovement) ? Math.min(0.055, distance * 0.0013) : 0;

  return Math.max(0.01, lookAhead);
}

function _calculateAnimationDuration(
  baseDuration, distance, timeDelta, headingDiff, speedMPH, eastWestMovement, directionChangeFactor
) {
  let dur = baseDuration;

  dur -= Math.min(0.02, distance * 0.001);
  dur += timeDelta > 0 ? Math.max(-0.01, Math.min(0.02, (0.25 - timeDelta) * 0.04)) : 0;
  dur += headingDiff > 20 ? Math.min(0.04, headingDiff / 300 * 0.08) : 0;
  dur += eastWestMovement ? Math.min(0.025, distance * 0.0005) : 0;
  dur = Math.max(0.03, dur) * directionChangeFactor;

  if (speedMPH < 3) dur = Math.min(dur, 0.4);

  return dur;
}

function _calculateEaseLinearity(speedMPH, eastWestMovement, directionChangeFactor) {
  if (eastWestMovement) {
    return Math.max(0.07, Math.min(0.19, (0.13 - (speedMPH * 0.0006)) * directionChangeFactor));
  }
  return Math.max(0.08, Math.min(0.23, (0.15 - (speedMPH * 0.0011)) * directionChangeFactor));
}

function _buildPositionBuffer(positionBuffer, currentTime, decayFactor) {
  let totalW = 0, wLat = 0, wLng = 0;

  for (const p of positionBuffer) {
    const age = (currentTime - p.timestamp) / 1000;
    const w = Math.exp(-age * decayFactor);
    wLat += p.lat * w;
    wLng += p.lng * w;
    totalW += w;
  }

  return {
    lat: wLat / totalW,
    lng: wLng / totalW
  };
}

function _predictPosition(lat, lng, heading, effSpeed, timeFraction) {
  const headingRad = (heading || 0) * Math.PI / 180;
  const R = 111111;
  const cosLat = Math.cos(lat * Math.PI / 180);

  const predLat = lat + (effSpeed * Math.cos(headingRad) / R) * timeFraction;
  const predLng = lng + (effSpeed * Math.sin(headingRad) / (R * cosLat)) * timeFraction;

  return { lat: predLat, lng: predLng };
}

function _cancelPendingUpdates() {
  if (window.debounceTimeoutId) {
    clearTimeout(window.debounceTimeoutId);
    window.debounceTimeoutId = null;
  }
  if (window._nextLocationUpdateRAF) {
    cancelAnimationFrame(window._nextLocationUpdateRAF);
    window._nextLocationUpdateRAF = null;
  }
  if (window._visualUpdateFallbackTimer) {
    clearTimeout(window._visualUpdateFallbackTimer);
    window._visualUpdateFallbackTimer = null;
  }
}

/* Smoothly pan the map when the user marker gets too close to the viewport edge. */
function _panMapIfNearEdge(
  userPos,
  speedTier,
  directionChangeFactor,
  eastWestMovement,
  bounds,
  speedMPH
) {
  // Safety & Interaction Guards
  if (!window.map || !userPos || !bounds) return;
  
  // Validate coordinates
  if (!isFinite(userPos.lat) || !isFinite(userPos.lng)) {
      console.warn('[Pan Near Edge] Invalid coordinates');
      return;
  }
  
  // If the user is touching the map (pan/zoom), do NOT interfere - CRITICAL
  if (window.isMapInteracting) return;
  
  // Only auto-pan if tracking is enabled
  if (!window.followUser) return;
  
  // CRITICAL: Check if in danger zone FIRST, bypass all throttling if so
  const isInCriticalZone = _isAtCriticalEdge(userPos);
  
  // Edge Detection - check if near edge at all
  const isNearEdge = _isNearViewportEdge(userPos, bounds, speedMPH || 0);
  
  if (!isNearEdge && !isInCriticalZone) return;
  
  // State Management - Prevent overlapping animations
  if (window.isPanning) {
    // EXCEPTION: If in critical zone, we MUST pan even if already panning
    // Cancel current pan and force new one
    if (isInCriticalZone) {
      window.isPanning = false; // Force reset
    } else {
      return; // Normal case: wait for current pan to finish
    }
  }
  
  // Throttle repeated pans - BUT reduce interval and skip throttle in critical zone
  const now = performance.now();
  const MIN_PAN_INTERVAL = isInCriticalZone ? 0 : 80; // Reduced from 120ms, bypass in critical
  
  if (now - (window.lastCenteringTime || 0) < MIN_PAN_INTERVAL) {
    return;
  }
  
  // Animation Dynamics - faster response for critical zone
  const urgencyMultiplier = isInCriticalZone ? 0.6 : 0.8;
  const basePanDuration = (speedTier?.panDuration ?? 0.2) * urgencyMultiplier;
  const rawDuration = basePanDuration * (directionChangeFactor || 1) * (eastWestMovement ? 0.9 : 1);
  const panDuration = Math.max(0.05, Math.min(0.8, rawDuration)); // seconds
  
  const baseEase = speedTier?.easeLinearity ?? 0.25;
  const easeLinearity = Math.max(
    0.1,
    Math.min(0.9, baseEase * (eastWestMovement ? 0.8 : 1))
  );
  
  // Prepare the map container for GPU-accelerated transforms
  const mapContainer = window.map?.getContainer?.();
  if (!mapContainer) {
      return;
  }
  
  // Set flag BEFORE animation starts - CRITICAL
  window.isPanning = true;
  mapContainer.style.willChange = 'transform';
  
  // Declare variables BEFORE cleanup function
  let timeoutId = null;
  let moveEndHandler = null;
  let cleanupExecuted = false;
  
  // Robust Cleanup Logic
  const cleanup = () => {
    if (cleanupExecuted) return;
    cleanupExecuted = true;
    
    // Reset the panning flag
    window.isPanning = false;
    
    // Remove the GPU hint
    if (mapContainer && mapContainer.isConnected) {
      mapContainer.style.willChange = 'auto';
    }
    
    window.lastCenteringTime = performance.now();
    
    // Remove the temporary `moveend` listener
    if (moveEndHandler) {
      window.map.off('moveend', moveEndHandler);
      moveEndHandler = null;
    }
    
    // Clear the safety timeout
    if (timeoutId !== null) {
      clearTimeout(timeoutId);
      timeoutId = null;
    }
  };
  
  // Execute Pan
  try {
    // In critical zone, use instant pan to guarantee safety
    if (isInCriticalZone) {
      window.map.panTo(userPos, {
        animate: false,
        noMoveStart: true
      });
      cleanup(); // Immediate cleanup
    } else {
      // Normal animated pan
      window.map.panTo(userPos, {
        animate: true,
        duration: panDuration,
        easeLinearity: easeLinearity,
        noMoveStart: true
      });
      
      // Safety timeout in case map never fires `moveend`
      timeoutId = setTimeout(cleanup, panDuration * 1000 + 100);
      
      // Clean up when map finishes moving
      moveEndHandler = cleanup;
      window.map.once('moveend', moveEndHandler);
    }
  } catch (err) {
    console.warn('[Pan Near Edge] Unexpected error during panTo():', err);
    cleanup(); // Ensure we never leave the flag stuck
  }
}
        
function _applyIntelligentZoom(speedMPS, speedTier, directionChangeFactor, speedMPH) {
    // Guard: Required parameters and state
    if (speedMPS == null || !speedTier) return;
    if (!window.map || typeof window.map.getZoom !== 'function') return;
    if (window.blockSpeedZoom || window.isZooming) return;
    
    // Get target zoom level
    if (typeof window.getSpeedBasedZoom !== 'function') {
        console.warn('[Intelligent Zoom] getSpeedBasedZoom not defined');
        return;
    }
    
    const targetZoom = window.getSpeedBasedZoom(speedMPS);
    if (targetZoom == null || targetZoom < 0) return;
    
    // Get current zoom
    let currentZoom;
    try {
        currentZoom = window.map.getZoom();
    } catch (error) {
        console.warn('[Intelligent Zoom] getZoom() failed:', error);
        return;
    }
    
    if (!isFinite(currentZoom)) return;
    
    // Check if zoom change is significant enough
    const zoomThreshold = speedTier.zoomThreshold ?? 0.5;
    if (Math.abs(currentZoom - targetZoom) < zoomThreshold) return;
    
    // Calculate animation duration
    const baseDuration = speedTier.zoomDuration ?? 0.2;
    const adjustedDuration = Math.max(0.05, Math.min(1.0, baseDuration * (directionChangeFactor || 1)));
    
    // Get map container
    let mapContainer;
    try {
        mapContainer = window.map.getContainer?.();
    } catch (error) {
        console.warn('[Intelligent Zoom] getContainer() failed:', error);
        return;
    }
    
    if (!mapContainer) return;
    
    // Get current center
    let center;
    try {
        center = window.map.getCenter?.();
    } catch (error) {
        console.warn('[Intelligent Zoom] getCenter() failed:', error);
        return;
    }
    
    if (!center) return;
    
    // Set zoom flag BEFORE animation starts
    window.isZooming = true;
    const originalOverflow = mapContainer.style.overflow;
    mapContainer.style.overflow = 'hidden';
    
    let cleanupExecuted = false;
    let zoomEndHandler = null;
    let timeoutId = null;
    
    const cleanup = () => {
        if (cleanupExecuted) return;
        cleanupExecuted = true;
        
        // Restore styles
        try {
            if (mapContainer && mapContainer.isConnected) {
                mapContainer.style.overflow = originalOverflow;
            }
        } catch (_) {
            // Ignore if element disconnected
        }
        
        // Clear flag
        window.isZooming = false;
        
        // Clear timeout
        if (timeoutId) {
            clearTimeout(timeoutId);
            timeoutId = null;
        }
        
        // Remove event listener
        if (zoomEndHandler && window.map) {
            try {
                window.map.off('zoomend', zoomEndHandler);
            } catch (_) {
                // Ignore if map method unavailable
            }
            zoomEndHandler = null;
        }
    };
    
    // Cancel any previous timeout
    if (window.intelligentZoomTimeout) {
        clearTimeout(window.intelligentZoomTimeout);
        window.intelligentZoomTimeout = null;
    }
    
    // Execute zoom animation
    try {
        window.map.flyTo(center, targetZoom, {
            duration: adjustedDuration,
            easeLinearity: 0.25,
            noMoveStart: true
        });
        
        // Safety timeout
        timeoutId = setTimeout(cleanup, adjustedDuration * 1000 + 150);
        window.intelligentZoomTimeout = timeoutId;
        
        // Listen for native completion
        zoomEndHandler = cleanup;
        window.map.once('zoomend', zoomEndHandler);
    } catch (error) {
        console.error('[Intelligent Zoom] Animation failed:', error);
        cleanup();
    }
}

/* Returns true if position is in CRITICAL danger zone (very close to edge) */
function _isAtCriticalEdge(targetPos) {
    if (!window.map || !window.map._loaded || typeof window.map.getSize !== 'function') return false;
    if (!targetPos) return false;

    const mapSize = window.map.getSize();
    if (!mapSize || !mapSize.x || !mapSize.y) return false;

    const pixel = window.map.latLngToContainerPoint(targetPos);
    if (!pixel || typeof pixel.x !== 'number' || typeof pixel.y !== 'number') return false;

    const CRITICAL_PX = 40;
    return (
        pixel.x < CRITICAL_PX ||
        pixel.x > (mapSize.x - CRITICAL_PX) ||
        pixel.y < CRITICAL_PX ||
        pixel.y > (mapSize.y - CRITICAL_PX)
    );
}


/* Viewport Safety */
function _enforceViewportSafety(speedMPH, currentMarkerPos) {
    const map    = window.map;
    const marker = window.userMarker;

    if (!map || !marker) return;
    if (window.isMapInteracting) return;
    if (window.followUser === false) return;

    const pos = currentMarkerPos || marker.getLatLng?.();
    if (!pos || !isFinite(pos.lat) || !isFinite(pos.lng)) return;

    const isCentered = (
        typeof window.ModeManager !== 'undefined' &&
        typeof window.ModeManager.isCentered === 'function'
    ) ? window.ModeManager.isCentered() : window.followUser;

    if (isCentered) {
        _enforceCenteredMode(pos, map, marker);
    } else {
        _enforceRoamingMode(pos, map, marker, speedMPH);
    }
}


function _enforceCenteredMode(markerPos, map, marker) {
    if (!map || !marker) return;

    const mapSize = map.getSize?.();
    if (!mapSize || mapSize.x <= 0 || mapSize.y <= 0) return;
    if (!isFinite(markerPos.lat) || !isFinite(markerPos.lng)) return;

    const markerPixel = map.latLngToContainerPoint?.(markerPos);
    if (!markerPixel || typeof markerPixel.x !== 'number') return;

    // Fast path: critical edge takes priority over all other logic.
    // 40px hard boundary — bypass percentage margins and distance checks,
    // snap instantly. isPanning is intentionally ignored here; if we're
    // at the critical edge, whatever animation is running has already failed.
    if (_isAtCriticalEdge(markerPos)) {
        try {
            map.setView?.([markerPos.lat, markerPos.lng], map.getZoom(), {
                animate:     false,
                noMoveStart: true,
            });
            marker.setLatLng?.([markerPos.lat, markerPos.lng]);
        } catch (error) {
            console.error('[Centered] Critical edge recovery failed:', error);
        }
        return;
    }

    const centerPixel = { x: mapSize.x / 2, y: mapSize.y / 2 };
    const distanceFromCenter = Math.hypot(
        markerPixel.x - centerPixel.x,
        markerPixel.y - centerPixel.y
    );

    // Already centered — just sync marker
    if (distanceFromCenter <= 5) {
        marker.setLatLng?.([markerPos.lat, markerPos.lng]);
        return;
    }

    // Percentage-based emergency check (10% margin or >20px from center)
    const edgeMargin  = mapSize.x * 0.10;
    const nearEdge    = (
        markerPixel.x < edgeMargin ||
        markerPixel.x > mapSize.x - edgeMargin ||
        markerPixel.y < edgeMargin ||
        markerPixel.y > mapSize.y - edgeMargin
    );
    const isEmergency = nearEdge || distanceFromCenter > 20;

    try {
        if (isEmergency) {
            map.setView?.([markerPos.lat, markerPos.lng], map.getZoom(), {
                animate:     false,
                noMoveStart: true,
            });
        } else {
            map.setView?.([markerPos.lat, markerPos.lng], map.getZoom(), {
                animate:      true,
                duration:     0.08,
                easeLinearity: 0.5,
                noMoveStart:  true,
            });
        }
        marker.setLatLng?.([markerPos.lat, markerPos.lng]);
    } catch (error) {
        console.error('[Centered] Recenter failed:', error);
    }
}


function _enforceRoamingMode(markerPos, map, marker, speedMPH) {
    if (!map || !marker) return;

    const mapSize = map.getSize?.();
    if (!mapSize || mapSize.x <= 0 || mapSize.y <= 0) return;
    if (!isFinite(markerPos.lat) || !isFinite(markerPos.lng)) return;

    const markerPixel = map.latLngToContainerPoint?.(markerPos);
    if (!markerPixel || typeof markerPixel.x !== 'number') return;

    // Always sync marker position in roaming mode
    try {
        marker.setLatLng?.([markerPos.lat, markerPos.lng]);
    } catch (error) {
        console.error('[Roaming] Marker update failed:', error);
        return;
    }

    // Fast path: critical edge — emergency snap before checking off-screen.
    // In roaming mode this fires when the normal edge-pan in the main loop
    // didn't trigger (shouldUpdateMap was false, isPanning blocked it, etc.).
    if (_isAtCriticalEdge(markerPos)) {
        try {
            map.setView?.([markerPos.lat, markerPos.lng], map.getZoom(), {
                animate:     false,
                noMoveStart: true,
            });
        } catch (error) {
            console.error('[Roaming] Critical edge recovery failed:', error);
        }
        return;
    }

    // Fully off-screen — emergency recovery
    const isOffScreen = (
        markerPixel.x < 0 ||
        markerPixel.x > mapSize.x ||
        markerPixel.y < 0 ||
        markerPixel.y > mapSize.y
    );

    if (isOffScreen) {
        console.error('[Roaming] Marker escaped viewport, emergency recovery');
        try {
            map.setView?.([markerPos.lat, markerPos.lng], map.getZoom(), {
                animate:     false,
                noMoveStart: true,
            });
        } catch (error) {
            console.error('[Roaming] Emergency recovery failed:', error);
        }
        return;
    }

    // Soft near-edge: smooth pan
    const margin    = mapSize.x * 0.15;
    const isNearEdge = (
        markerPixel.x < margin ||
        markerPixel.x > mapSize.x - margin ||
        markerPixel.y < margin ||
        markerPixel.y > mapSize.y - margin
    );

    if (isNearEdge) {
        const duration = speedMPH > 10 ? 0.15 : 0.25;
        try {
            map.panTo?.([markerPos.lat, markerPos.lng], {
                animate:      true,
                duration:     duration,
                easeLinearity: 0.25,
                noMoveStart:  true,
            });
        } catch (error) {
            console.error('[Roaming] Pan failed:', error);
        }
    }
}
        
function updateDistanceBox(forceUpdate = false) {
    const distanceBox = cachedElements.distanceBox || document.getElementById('distanceBox');
    if (!distanceBox) {
        console.warn('Distance box element not found');
        return;
    }
    if (document.hidden && !forceUpdate) return;

    if (!userMarker || !gameLocations || gameLocations.length === 0) {
        distanceBox.textContent = 'Initializing...';
        resetDistanceBoxStyling(distanceBox);
        return;
    }

    const userLatLng = userMarker.getLatLng();
    let userLat = userLatLng.lat;
    let userLng = userLatLng.lng;

    if (!isFinite(userLat) || !isFinite(userLng)) {
        console.warn('Invalid user coordinates:', userLat, userLng);
        distanceBox.textContent = 'Initializing...';
        resetDistanceBoxStyling(distanceBox);
        return;
    }

    if (userLat === 0 && userLng === 0) {
        const center = map.getCenter();
        userLat = center.lat;
        userLng = center.lng;
    }

    let closestDistance = Infinity;
    let closestLocation = null;
    const userPos = { lat: userLat, lng: userLng };

    for (const location of gameLocations) {
        if (!location || typeof location.lat !== 'number' || typeof location.lng !== 'number') {
            console.warn('Invalid location data:', location);
            continue;
        }
        const locationPos = { lat: location.lat, lng: location.lng };
        const distance = calculateDistance(userPos, locationPos);
        if (isFinite(distance) && distance < closestDistance) {
            closestDistance = distance;
            closestLocation = location;
        }
    }

    // Handle case where no valid distances were found
    if (!isFinite(closestDistance) || closestDistance === Infinity || !closestLocation) {
        console.warn('No valid distances calculated - locations may not be ready');
        distanceBox.textContent = 'Initializing...';
        resetDistanceBoxStyling(distanceBox);
        return;
    }

    // Store distance and location globally for other functions to use
    window.lastClosestDistance = closestDistance;
    window.lastClosestLocation = closestLocation;

    const distanceFeet = Math.round(closestDistance * 3.28084);

    // Determine arrival state
    const PROXIMITY_THRESHOLD = (typeof CONFIG !== 'undefined' && CONFIG.DISTANCE_THRESHOLD) ? CONFIG.DISTANCE_THRESHOLD : 20;
    const isArrived = distanceFeet <= PROXIMITY_THRESHOLD;

    // Check cooldown status *only if* we have arrived and the manager exists
    let cooldownStatus = null;
    let isOnCooldown = false;
    if (isArrived && closestLocation?.id && window.cooldownManager) {
        cooldownStatus = window.cooldownManager.checkCooldown(closestLocation.id);
        isOnCooldown = !!cooldownStatus?.isOnCooldown;
    }

    // Clear any existing countdown interval when state changes
    if (window.distanceBoxCountdownInterval) {
        clearInterval(window.distanceBoxCountdownInterval);
        window.distanceBoxCountdownInterval = null;
    }

    // Update display based on arrival and cooldown state
    if (isArrived) {
        if (isOnCooldown && cooldownStatus?.remainingSeconds !== undefined) {
            // Initial update
            const updateCountdown = () => {
                if (!closestLocation?.id || !window.cooldownManager) {
                    if (window.distanceBoxCountdownInterval) {
                        clearInterval(window.distanceBoxCountdownInterval);
                        window.distanceBoxCountdownInterval = null;
                    }
                    return;
                }
                
                const status = window.cooldownManager.checkCooldown(closestLocation.id);
                if (!status?.isOnCooldown) {
                    // Cooldown expired - show "Arrived" and clear interval
                    distanceBox.textContent = 'Arrived.';
                    applyArrivedStyling(distanceBox);
                    window.currentlyArrived = true;
                    if (window.distanceBoxCountdownInterval) {
                        clearInterval(window.distanceBoxCountdownInterval);
                        window.distanceBoxCountdownInterval = null;
                    }
                } else {
                    // Update countdown display
                    const mins = Math.floor(status.remainingSeconds / 60);
                    const secs = status.remainingSeconds % 60;
                    const timeStr = `${mins}:${secs.toString().padStart(2, '0')}`;
                    distanceBox.textContent = `Open in ${timeStr}`;
                    applyArrivedStyling(distanceBox);
                }
            };
            
            // Update immediately
            updateCountdown();
            
            // Then update every second
            window.distanceBoxCountdownInterval = setInterval(updateCountdown, 1000);
        } else {
            distanceBox.textContent = 'Arrived.';
            applyArrivedStyling(distanceBox);
        }
    } else {
        // Default state: showing distance
        const distanceText = distanceFeet < 5280
            ? `${distanceFeet.toLocaleString()} feet`
            : `${(distanceFeet / 5280).toFixed(2)} miles`;
        distanceBox.textContent = `Closest Stop: ${distanceText}`;
        applyDefaultStyling(distanceBox);
    }

    // Apply border styling 
    applyBorderStyling(distanceBox, closestLocation, distanceFeet, isArrived);

    // Update the global arrival state *only* if arrived AND not on cooldown
    window.currentlyArrived = isArrived && !isOnCooldown;
}
        
function resetDistanceBoxStyling(element) {
    element.style.background = 'white';
    element.style.color = 'var(--dark-blue)';
    element.style.fontWeight = 'normal';
    element.style.border = '3px solid var(--dark-blue)';
}

function applyArrivedStyling(element) {
    element.style.background = 'white';
    element.style.color = 'var(--dark-blue)';
    element.style.fontWeight = 'bold';
}

function applyDefaultStyling(element) {
    element.style.background = 'white';
    element.style.color = 'var(--dark-blue)';
    element.style.fontWeight = 'normal';
}

function applyBorderStyling(element, closestLocation, distanceFeet, isArrived) {
    if (isArrived) {
        // When arrived, use dark red border
        element.style.border = '3px solid darkred';
    } else if (closestLocation && closestLocation.markerColor) {
        // When not arrived, use location-based border
        let borderStyle = '';
        if (distanceFeet <= 100) {
            borderStyle = `3px solid ${closestLocation.markerColor}`;
        } else if (distanceFeet <= 500) {
            borderStyle = `2px solid ${closestLocation.markerColor}`;
        } else {
            borderStyle = `1px solid ${closestLocation.markerColor}`;
        }
        element.style.border = borderStyle;
    } else {
        element.style.border = '3px solid var(--dark-blue)';
    }
}
        
// ─── DISTANCE CALCULATION ─────────────────────────────────────────────────────
function _calculateDistance(a, b) {
    if (!a || !b) return 0;

    const lat1 = a.lat;
    const lng1 = a.lng;
    const lat2 = b.lat;
    const lng2 = b.lng;

    if (!Number.isFinite(lat1) || !Number.isFinite(lng1) ||
        !Number.isFinite(lat2) || !Number.isFinite(lng2)) {
        return 0;
    }

    // Short-circuit identical points (also avoids float rounding in sqrt)
    if (lat1 === lat2 && lng1 === lng2) return 0;

    const R  = 6371000; // Earth radius in metres
    const φ1 = lat1 * Math.PI / 180;
    const φ2 = lat2 * Math.PI / 180;
    const Δφ = (lat2 - lat1) * Math.PI / 180;
    const Δλ = (lng2 - lng1) * Math.PI / 180;

    const sinΔφ = Math.sin(Δφ / 2);
    const sinΔλ = Math.sin(Δλ / 2);

    const a_ = sinΔφ * sinΔφ + Math.cos(φ1) * Math.cos(φ2) * sinΔλ * sinΔλ;

    // Clamp to [0, 1] to guard against floating-point values like 1.0000000002
    const c = 2 * Math.atan2(Math.sqrt(Math.min(1, a_)), Math.sqrt(Math.min(1, 1 - a_)));

    return R * c; // metres
}

function calculateDistance(a, b) {
    if (!a || !b) return 0;

    // Normalise: accept objects that carry lat/lng at the top level.
    // Game location objects in window.gameLocations use {lat, lng} directly.
    const pa = { lat: a.lat ?? a.latitude,  lng: a.lng ?? a.longitude };
    const pb = { lat: b.lat ?? b.latitude,  lng: b.lng ?? b.longitude };

    return _calculateDistance(pa, pb);
}

function getGeolocationOptions(speedMPS = 0) {
    const isStationary = speedMPS < 0.5;    // < 1 mph
    const isMoving = speedMPS >= 2;         // > 4.5 mph
    
    return {
        enableHighAccuracy: !isStationary,
        timeout: isMoving ? 15000 : isStationary ? 10000 : 12000,
        maximumAge: isStationary ? 60000 : isMoving ? 5000 : 15000
    };
}

function handleLocationError(error) {
    console.warn("Error getting user location:", error);

    // Retry on ANY error (including iOS 17's code 0), up to MAX_RETRIES
    if (retryCount < CONFIG.MAX_RETRIES) {
        retryCount++;
        console.log(`Retrying to get location (Attempt ${retryCount} of ${CONFIG.MAX_RETRIES})`);

        const currentRetryDelay = CONFIG.RETRY_DELAY * retryCount;

        setTimeout(() => {
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    console.log("Location retrieved successfully after retry");
                    hideLoadingMessage();
                    updateUserLocation(position, true);
                    retryCount = 0;
                },
                handleLocationError,
                getGeolocationOptions(retryCount) 
            );
        }, currentRetryDelay);
        return;
    }

    // Max retries reached
    retryCount = 0;
    hideLoadingMessage();

    let errorMessage = "An error occurred while getting your location.";
    if (error?.code !== undefined) {
        switch (error.code) {
            case 1:
                errorMessage = "Please allow access to your location to use this feature.";
                break;
            case 2:
                errorMessage = "Your location is currently unavailable. Please try again later.";
                break;
            case 3:
                errorMessage = "Getting your location took too long. Please try again.";
                break;
            case 0:
                // iOS 17 Safari sometimes returns non-standard code 0
                errorMessage = "Unable to determine your location. Please check your device settings and try again.";
                break;
        }
    }

    showPopup("Location Error", errorMessage);
    if (typeof onLocationFailure === 'function') {
        onLocationFailure(error);
    }
}

function showPopup(title, message, type = "info", callback = null) {
    console.log("showPopup called with:", title, message);
    
    const existingPopups = document.querySelectorAll(".popup-overlay");
    existingPopups.forEach(popup => {
        document.body.removeChild(popup);
    });
    
    const overlay = document.createElement("div");
    overlay.className = "popup-overlay";
    overlay.style.position = "fixed";
    overlay.style.left = "0";
    overlay.style.top = "0";
    overlay.style.width = "100%";
    overlay.style.height = "100%";
    overlay.style.backgroundColor = "rgba(0, 0, 0, 0.7)";
    overlay.style.zIndex = "9999";
    
    const popupContainer = document.createElement("div");
    popupContainer.className = "popup-container";
    popupContainer.style.position = "absolute";
    popupContainer.style.left = "50%";
    popupContainer.style.top = "50%";
    popupContainer.style.transform = "translate(-50%, -50%)";
    popupContainer.style.backgroundColor = "white";
    popupContainer.style.borderRadius = "8px";
    popupContainer.style.padding = "20px";
    popupContainer.style.width = "300px";
    popupContainer.style.maxWidth = "90%";
    popupContainer.style.boxShadow = "0 4px 15px rgba(0, 0, 0, 0.2)";
    
    const titleElement = document.createElement("h3");
    titleElement.textContent = title;
    titleElement.style.margin = "0 0 15px 0";
    titleElement.style.textAlign = "center";
    titleElement.style.color = "#333";
    
    const messageElement = document.createElement("p");
    messageElement.textContent = message;
    messageElement.style.margin = "0 0 20px 0";
    messageElement.style.textAlign = "center";
    messageElement.style.color = "#555";
    
    const button = document.createElement("button");
    button.textContent = "OK";
    button.style.display = "block";
    button.style.margin = "0 auto";
    button.style.padding = "8px 20px";
    button.style.backgroundColor = "#2c5282";
    button.style.color = "white";
    button.style.border = "none";
    button.style.borderRadius = "4px";
    button.style.cursor = "pointer";
    
    button.addEventListener("click", function() {
        document.body.removeChild(overlay);
        if (callback && typeof callback === 'function') {
            callback();
        }
    });
    
    overlay.addEventListener("click", function(e) {
        if (e.target === overlay) {
            document.body.removeChild(overlay);
        }
    });
    
    popupContainer.appendChild(titleElement);
    popupContainer.appendChild(messageElement);
    popupContainer.appendChild(button);
    overlay.appendChild(popupContainer);
    document.body.appendChild(overlay);
    
    button.focus();
}

function onLocationFailure(error) {
    const code = error?.code;

    // ── 1. CLEAN UP ACTIVE GPS STATE ──────────────────────────────────────────
    // Stop the watch so we're not burning battery on a dead connection
    if (window.positionWatchId !== null && window.positionWatchId !== undefined) {
        try {
            navigator.geolocation.clearWatch(window.positionWatchId);
        } catch (_) {}
        window.positionWatchId = null;
    }

    // Cancel any pending GPS timeout
    if (window.gpsTimeoutTimer) {
        clearTimeout(window.gpsTimeoutTimer);
        window.gpsTimeoutTimer = null;
    }

    // Show GPS searching state if not already shown
    if (!window.isGPSSearching) {
        window.isGPSSearching = true;
        if (typeof showGPSSearchingState === 'function') {
            showGPSSearchingState();
        }
    }

    // ── 2. LOG FOR DIAGNOSTICS ────────────────────────────────────────────────
    console.error('[Location Failure]', {
        code,
        message: error?.message || 'Unknown error',
        timestamp: new Date().toISOString()
    });

    if (window.enterpriseSecurityManager?.logSecurityEvent) {
        window.enterpriseSecurityManager.logSecurityEvent('LOCATION_FAILURE', {
            code,
            message: error?.message
        });
    }

    // ── 3. FALL BACK TO A SAFE MAP STATE ──────────────────────────────────────
    // If the map has never been positioned, center on Minnesota so it's not
    // stuck on the default [0,0] view
    if (!window.lastPosition && map) {
        try {
            map.setView([44.9778, -93.2650], 12, { animate: false });
        } catch (_) {}
    }

    // Ensure the distance box shows a useful message instead of "Initializing…"
    const distanceBox = cachedElements?.distanceBox ?? document.getElementById('distanceBox');
    if (distanceBox) {
        distanceBox.textContent = 'Location unavailable';
        distanceBox.classList.add('show');
    }

    // ── 4. OFFER RECOVERY PATH BASED ON ERROR TYPE ────────────────────────────
    // PERMISSION_DENIED (1) — user has blocked location; nothing we can do
    // automatically, but show a persistent, actionable prompt
    if (code === 1) {
        _showLocationPermissionGuidance();
        return;
    }

    // POSITION_UNAVAILABLE (2) or TIMEOUT (3) or unknown (0) —
    // schedule a background retry so the app self-heals when signal returns
    const RETRY_DELAY_MS = code === 3 ? 8000 : 15000; // timeout = faster retry

    console.log(`[Location Failure] Scheduling recovery attempt in ${RETRY_DELAY_MS / 1000}s`);

    window._locationFailureRetryTimer = setTimeout(() => {
        window._locationFailureRetryTimer = null;

        // Only attempt recovery if the watch hasn't been restarted by something else
        if (window.positionWatchId !== null && window.positionWatchId !== undefined) {
            console.log('[Location Failure] Watch already running, skipping recovery');
            return;
        }

        console.log('[Location Failure] Attempting background recovery…');

        navigator.geolocation.getCurrentPosition(
            (position) => {
                console.log('[Location Failure] Recovery successful');
                window.isGPSSearching = false;

                if (typeof hideGPSSearchingState === 'function') {
                    hideGPSSearchingState();
                }

                initializeUserLocation(position);
            },
            (retryError) => {
                console.warn('[Location Failure] Recovery attempt failed:', retryError.message);
                // Re-enter the full error handler so retry logic continues
                handleLocationError(retryError);
            },
            { enableHighAccuracy: true, timeout: 20000, maximumAge: 0 }
        );
    }, RETRY_DELAY_MS);
}

// ── PERMISSION GUIDANCE OVERLAY ───────────────────────────────────────────────
// Shown only for PERMISSION_DENIED (code 1) — all other failures use the
// existing popup and automatic retry logic above
function _showLocationPermissionGuidance() {
    // Don't stack multiple overlays
    if (document.getElementById('location-permission-guidance')) return;

    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
    const isAndroid = /Android/.test(navigator.userAgent);

    const instructions = isIOS
        ? 'Go to <strong>Settings → Privacy & Security → Location Services</strong>, find your browser, and set it to <strong>While Using</strong>.'
        : isAndroid
        ? 'Go to <strong>Settings → Apps → [your browser] → Permissions → Location</strong> and allow access.'
        : 'Click the lock icon in your browser\'s address bar and allow location access, then reload the page.';

    const overlay = document.createElement('div');
    overlay.id = 'location-permission-guidance';
    overlay.style.cssText = `
        position: fixed;
        inset: 0;
        background: rgba(0,0,0,0.65);
        backdrop-filter: blur(4px);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 9999;
        padding: 20px;
    `;

    overlay.innerHTML = `
        <div style="
            background: white;
            border-radius: 16px;
            padding: 28px 24px;
            width: 100%;
            max-width: 400px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.3);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            text-align: center;
        ">
            <div style="font-size: 40px; margin-bottom: 12px;">📍</div>
            <h3 style="
                margin: 0 0 12px;
                font-size: 1.25rem;
                font-weight: 700;
                color: #1a202c;
            ">Location Access Blocked</h3>
            <p style="
                margin: 0 0 20px;
                font-size: 0.95rem;
                color: #4a5568;
                line-height: 1.6;
            ">
                This app needs your location to show nearby historical sites.
                It looks like location access has been denied.
            </p>
            <p style="
                margin: 0 0 24px;
                font-size: 0.9rem;
                color: #4a5568;
                line-height: 1.6;
                background: #f7fafc;
                border-radius: 10px;
                padding: 14px;
                text-align: left;
            ">${instructions}</p>
            <button id="location-guidance-reload" style="
                width: 100%;
                padding: 14px;
                background: #1a3a8a;
                color: white;
                border: none;
                border-radius: 10px;
                font-size: 1rem;
                font-weight: 600;
                cursor: pointer;
                margin-bottom: 10px;
            ">Try Again</button>
            <button id="location-guidance-dismiss" style="
                width: 100%;
                padding: 12px;
                background: transparent;
                color: #718096;
                border: 1px solid #e2e8f0;
                border-radius: 10px;
                font-size: 0.9rem;
                cursor: pointer;
            ">Continue Without Location</button>
        </div>
    `;

    document.body.appendChild(overlay);

    document.getElementById('location-guidance-reload').onclick = () => {
        overlay.remove();
        window.location.reload();
    };

    document.getElementById('location-guidance-dismiss').onclick = () => {
        overlay.remove();
        // Center on Minnesota and let the user browse the map manually
        if (map) {
            try {
                map.setView([44.9778, -93.2650], 10, { animate: true, duration: 0.8 });
            } catch (_) {}
        }
        if (typeof hideGPSSearchingState === 'function') {
            hideGPSSearchingState();
        }
        const distanceBox = cachedElements?.distanceBox ?? document.getElementById('distanceBox');
        if (distanceBox) {
            distanceBox.textContent = 'Location disabled';
        }
    };
}

let recenterTimer;            

function recenterMap() {
    const btn = cachedElements?.recenterButton ?? document.getElementById('recenterButton');
    if (!btn || !userMarker?.getLatLng()) return;

    btn.disabled = true;                 // block spam
    btn.style.backgroundColor = 'var(--primary-color)';
    btn.style.color = 'white';

    map.closePopup();
    map.panTo(userMarker.getLatLng(), {
        animate: true,
        duration: 0.5,
        easeLinearity: 0.25,
        noZoom: true
    });

    followUser = true;
    announceToScreenReader('Map re-centred on your location');

    clearTimeout(recenterTimer);
    recenterTimer = setTimeout(() => {
        btn.style.backgroundColor = 'white';
        btn.style.color = 'var(--primary-color)';
        btn.disabled = false;
    }, 500);
}

/* ---------- 2-MINUTE LOCATION COOLDOWN ---------- */
const COOLDOWN_PERIOD_MS = 2 * 60 * 1000; // 2 minutes
const STORAGE_KEY = 'locationCooldowns';
const DEBOUNCE_TIME_MS = ('ontouchstart' in window || navigator.maxTouchPoints > 0) ? 500 : 300;
const CLEANUP_INTERVAL_MS = 60 * 1000; // Cleanup expired cooldowns every minute
const TOAST_UPDATE_INTERVAL_MS = 500; // Update countdown toast every 500ms (more responsive)
const MAP_RESET_CHECK_INTERVAL_MS = 1000; // Check for reset conditions every second

class LocationCooldownManager {
  constructor() {
    // State
    this.cooldowns = this.loadFromStorage(); // { id: startTime_ms }
    this.hiddenMsPerLoc = {}; // { id: accumulated_hidden_time_ms }
    this.currentLocationId = null; // ID of the location the user is currently in
    this.lastActionTime = 0; // Timestamp of the last enter/leave action (for debouncing)
    this.hiddenAt = null; // Timestamp when the app was hidden
    this.resetCooldownIds = new Set(); // Track IDs that triggered a map reset due to expiry
    this.wasOverSpeedThreshold = false; // Track speed threshold state

    // Intervals/Timers
    this.cleanupInterval = null;
    this.mapResetInterval = null;
    this.toastInterval = null;

    // UI Elements/Handlers
    this.visibilityHandler = null;
    this.activeToast = null;

    // Initialize
    this.initVisibilityTracking();
    this.cleanupExpiredCooldowns(); // Clean up any old data on start
    this.startPeriodicCleanup();
    this.startMapResetMonitoring();
    this.patchGameFunctions();
  }

  /* Checks if a location is currently on cooldown. */
  checkCooldown(locationId) {
    if (!locationId) {
      return { isOnCooldown: false, remainingMs: 0, remainingSeconds: 0 };
    }

    const id = String(locationId);
    const startTime = this.cooldowns[id];
    if (!startTime) {
      return { isOnCooldown: false, remainingMs: 0, remainingSeconds: 0 };
    }

    const hiddenTime = this.hiddenMsPerLoc[id] || 0;
    const elapsed = Date.now() - startTime - hiddenTime;

    // If elapsed time is negative (shouldn't happen) or exceeds the period, the cooldown is over.
    if (elapsed < 0 || elapsed >= COOLDOWN_PERIOD_MS || !isFinite(elapsed)) {
      // Cleanup expired cooldown
      delete this.cooldowns[id];
      delete this.hiddenMsPerLoc[id];
      this.resetCooldownIds.delete(id); // Clean up reset tracking
      this.saveToStorage();
      return { isOnCooldown: false, remainingMs: 0, remainingSeconds: 0 };
    }

    const remainingMs = COOLDOWN_PERIOD_MS - elapsed;
    return {
      isOnCooldown: true,
      remainingMs: Math.max(0, remainingMs),
      remainingSeconds: Math.max(0, Math.ceil(remainingMs / 1000)),
    };
  }

 /* Attempts to enter a location. Checks cooldown and current state. */
enterLocation(locationId) {
  if (!locationId) {
    return { success: false, reason: 'invalid_id', message: 'Invalid location ID' };
  }
  const id = String(locationId);
  const now = Date.now();
  if (now - this.lastActionTime < DEBOUNCE_TIME_MS) {
    return { success: false, reason: 'debounced', message: 'Action too rapid' };
  }
  this.lastActionTime = now;
  if (this.currentLocationId === id) {
    return { success: false, reason: 'already_inside', message: 'Already in this location' };
  }
  const status = this.checkCooldown(id);
  if (status.isOnCooldown) {
    return {
      success: false,
      reason: 'on_cooldown',
      message: 'This location cannot be revisited for two minutes',
      remainingMs: status.remainingMs,
      remainingSeconds: status.remainingSeconds,
      locationId: id,
    };
  }
  // Successfully entering a new location
  this.currentLocationId = id;
  this.resetCooldownIds.delete(id); // Clear reset tracking - allows proximity zoom to work again
  return { success: true, reason: 'allowed', message: 'Location entry allowed' };
}

/* Leaves the current location, starting its cooldown period. */
leaveLocation(locationId = null) {
  const id = locationId ? String(locationId) : this.currentLocationId;
  if (!id || id === 'null' || id === 'undefined') return;
  // Start cooldown for the location
  this.cooldowns[id] = Date.now();
  this.hiddenMsPerLoc[id] = 0; // Reset hidden time for this location's cooldown
  this.saveToStorage();
  // Update current location state
  if (this.currentLocationId === id) {
    this.currentLocationId = null;
  }
}

  // --- Map Reset Logic ---
  startMapResetMonitoring() {
    this.mapResetInterval = setInterval(() => {
      this.checkAndResetMap();
    }, MAP_RESET_CHECK_INTERVAL_MS);
  }

  checkAndResetMap() {
    const now = Date.now();
    let shouldReset = false;
    let resetReason = null;

    // Reset if moving fast (>6 mph -> likely driving away)
    if (typeof window.currentSpeed === 'number' && window.currentSpeed > 6) {
      if (!this.wasOverSpeedThreshold) {
        shouldReset = true;
        resetReason = 'speed_threshold';
        this.wasOverSpeedThreshold = true;
      }
    } else {
      this.wasOverSpeedThreshold = false; // Reset flag if speed is low
    }

    // Reset if any NEARBY active cooldown has just expired (one-time trigger per expiry)
    if (!shouldReset && Object.keys(this.cooldowns).length > 0) {
      for (const id of Object.keys(this.cooldowns)) {
        if (this.resetCooldownIds.has(id)) continue; // Already triggered a reset

        const status = this.checkCooldown(id);
        // Only reset if cooldown expired AND user is near that location
        if (!status.isOnCooldown && this.isWithinThreshold(id)) {
          shouldReset = true;
          resetReason = 'cooldown_expired';
          this.resetCooldownIds.add(id); // Mark this ID as having triggered a reset
          break;
        }
      }
    }

    if (shouldReset) {
      console.log(`Map reset triggered: ${resetReason}`);
      this.resetMapToUser();
    }
  }

  resetMapToUser() {
    // Delegate to the existing motion system for intelligent, smooth reset
    if (typeof window.updateUserLocation === 'function' && window.lastPosition) {
      // Reconstruct a GeolocationPosition-like object
      const fakePosition = {
        coords: {
          latitude: window.lastPosition.lat,
          longitude: window.lastPosition.lng,
          accuracy: window.lastPosition.accuracy || 20,
          speed: (window.currentSpeed || 0) / 2.23694, // convert mph -> m/s
          heading: window.lastPosition.heading || null
        },
        timestamp: Date.now()
      };

      updateUserLocation(fakePosition, false); // Use normal smoothing

      // Ensure auto-follow is re-enabled after reset
      window.followUser = true;
      window.isMapInteracting = false;

      // Prevent both speed and proximity zoom from immediately fighting the reset
      window.blockSpeedZoom = true;
      if (typeof window.blockProximityZoom !== 'undefined') {
        window.blockProximityZoom = true;
      }
      
      setTimeout(() => {
        window.blockSpeedZoom = false;
        if (typeof window.blockProximityZoom !== 'undefined') {
          window.blockProximityZoom = false;
        }
      }, 2000);

    } else {
      // Fallback: only used if motion system isn't ready
      try {
        if (typeof window.recenterMap === 'function') {
          window.recenterMap();
        } else if (window.map && window.userMarker) {
          const userPos = window.userMarker.getLatLng();
          if (userPos && window.map.setView) {
            // Use flyTo for smooth centering instead of setView
            window.map.flyTo(userPos, window.map.getZoom?.() || 16, {
              animate: true,
              duration: 1.0,
              easeLinearity: 0.25
            });
          }
        }

        window.isMapInteracting = false;
        window.followUser = true;
      } catch (e) {
        console.error('Fallback map reset failed:', e);
      }
    }
  }

  // --- UI & Notifications ---
  formatTime(seconds) {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  }

  isWithinThreshold(locationId) {
    try {
      // Directly access potential location sources
      let location = null;
      const sources = [window.gameLocations, window.locations];
      for (const source of sources) {
        if (Array.isArray(source)) {
          location = source.find(loc => loc?.id === locationId);
          if (location) break;
        }
      }
      // Check locationsMap if not found in arrays
      if (!location && window.locationsMap && typeof window.locationsMap === 'object') {
        location = Object.values(window.locationsMap).find(loc => loc?.id === locationId);
      }

      if (!location) return false;

      const lat = parseFloat(location.lat);
      const lng = parseFloat(location.lng);
      if (!isFinite(lat) || !isFinite(lng)) return false;

      if (typeof calculateDistance !== 'function' || !window.userMarker) return false;

      const userPos = window.userMarker.getLatLng();
      if (!userPos || !isFinite(userPos.lat) || !isFinite(userPos.lng)) return false;

      const distanceFeet = calculateDistance(
    { lat: userPos.lat, lng: userPos.lng }, 
    { lat: lat, lng: lng }
);
        
      if (!isFinite(distanceFeet) || distanceFeet < 0) return false;

      const threshold = (typeof CONFIG?.DISTANCE_THRESHOLD === 'number')
        ? CONFIG.DISTANCE_THRESHOLD
        : 20;
      return distanceFeet <= threshold;
    } catch (e) {
      console.error('Error in isWithinThreshold:', e);
      return false;
    }
  }

  notifyUserWithCountdown(locationId, remainingSeconds) {
    if (!this.isWithinThreshold(locationId)) return; // Only show if user is near the location

    this.clearToast(); // Clear any existing toast

    // Try external notification functions first
    if (window.showToast) {
      window.showToast(`This location can't be revisited for ${this.formatTime(remainingSeconds)}`, 'warning');
      return;
    }
    if (window.showNotification) {
      window.showNotification(`This location can't be revisited for ${this.formatTime(remainingSeconds)}`);
      return;
    }

    // Fallback: Create a simple toast element
    const toast = document.createElement('div');
    toast.style.cssText = `
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: #333;
      color: white;
      padding: 12px 20px;
      border-radius: 6px;
      font-size: 15px;
      z-index: 10000;
      opacity: 0.95;
      max-width: 80%;
      text-align: center;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
    `;
    document.body.appendChild(toast);
    this.activeToast = toast;

    // Function to update the toast text and handle its lifecycle
    const updateToast = () => {
      if (!this.activeToast?.parentNode) { // Check if toast was removed
        this.clearToastInterval();
        return;
      }

      if (!this.isWithinThreshold(locationId)) { // User moved away
        this.clearToast();
        return;
      }

      const status = this.checkCooldown(locationId); // Get current status
      if (!status.isOnCooldown) { // Cooldown expired
        this.clearToast();
        // Optionally trigger the original location hunt if it's available
        const location = window.gameLocations?.find(loc => loc?.id === locationId) ||
                         window.locations?.find(loc => loc?.id === locationId) ||
                         Object.values(window.locationsMap || {}).find(loc => loc?.id === locationId);
        if (location && window.showLocationHunt) {
          const originalFunc = window.showLocationHunt.__original || window.showLocationHunt;
          originalFunc.call(window, location);
        }
        return;
      }

      // Update the toast text with the new remaining time
      this.activeToast.textContent = `This location can't be revisited for ${this.formatTime(status.remainingSeconds)}`;
    };

    updateToast(); // Initial update
    this.toastInterval = setInterval(updateToast, TOAST_UPDATE_INTERVAL_MS); // Start periodic updates
  }

  clearToast() {
    this.clearToastInterval();
    if (this.activeToast?.parentNode) {
      this.activeToast.parentNode.removeChild(this.activeToast);
    }
    this.activeToast = null;
  }

  clearToastInterval() {
    if (this.toastInterval) clearInterval(this.toastInterval);
    this.toastInterval = null;
  }

  // --- Storage & Cleanup ---
  loadFromStorage() {
    try {
      const data = localStorage.getItem(STORAGE_KEY);
      if (!data) return {};
      const parsed = JSON.parse(data);
      return typeof parsed === 'object' && parsed !== null ? parsed : {};
    } catch (e) {
      console.warn('Failed to load cooldowns:', e);
      return {};
    }
  }

  saveToStorage() {
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(this.cooldowns));
    } catch (e) {
      console.error('Failed to save cooldowns:', e);
    }
  }

  cleanupExpiredCooldowns() {
    const now = Date.now();
    let modified = false;
    const activeIds = new Set(); // Track IDs that are still active

    for (const [id, startTime] of Object.entries(this.cooldowns)) {
      const hiddenTime = this.hiddenMsPerLoc[id] || 0;
      const elapsed = now - startTime - hiddenTime;

      if (elapsed >= COOLDOWN_PERIOD_MS || elapsed < 0 || !isFinite(elapsed)) {
        // Cooldown expired, remove it
        delete this.cooldowns[id];
        delete this.hiddenMsPerLoc[id];
        this.resetCooldownIds.delete(id); // Clean up reset tracking
        modified = true;
      } else {
        // Cooldown still active
        activeIds.add(id);
      }
    }

    // Clean up hiddenMsPerLoc entries for IDs that no longer have an active cooldown
    for (const id of Object.keys(this.hiddenMsPerLoc)) {
      if (!activeIds.has(id)) {
        delete this.hiddenMsPerLoc[id];
      }
    }

    if (modified) this.saveToStorage();
  }

  startPeriodicCleanup() {
    this.cleanupInterval = setInterval(() => {
      this.cleanupExpiredCooldowns();
    }, CLEANUP_INTERVAL_MS);
  }

  initVisibilityTracking() {
    this.visibilityHandler = () => {
      if (document.hidden) {
        this.hiddenAt = Date.now(); // Mark when app was hidden
      } else if (this.hiddenAt !== null) {
        const hiddenDuration = Date.now() - this.hiddenAt;
        // Add the hidden duration to the accumulated time for all *currently active* cooldowns
        for (const id of Object.keys(this.cooldowns)) {
          if (!this.hiddenMsPerLoc[id]) this.hiddenMsPerLoc[id] = 0;
          this.hiddenMsPerLoc[id] += hiddenDuration;
        }
        this.hiddenAt = null; // Reset hidden timestamp
      }
    };
    document.addEventListener('visibilitychange', this.visibilityHandler);
  }

  // --- Game Function Patching ---
  patchGameFunctions() {
    this.patchShowLocationHunt();
    this.patchCheckProximityAutoOpen();
    this.patchCloseFunctions();
    this.patchCreateBottomActionBar();
  }

  patchShowLocationHunt() {
    if (!window.showLocationHunt || window.showLocationHunt.__patched) return;
    const original = window.showLocationHunt;
    const manager = this;
    window.showLocationHunt = function(loc) {
      if (!loc?.id) return original.call(this, loc); // Allow if no ID
      const result = manager.enterLocation(loc.id);
      if (result.success) return original.call(this, loc); // Allow if no cooldown/already inside
      if (result.reason === 'on_cooldown') {
        // Show countdown if on cooldown
        manager.notifyUserWithCountdown(result.locationId, result.remainingSeconds);
        console.log(`Location ${loc.id} blocked - ${result.reason}`);
        return; // Block the original call
      }
      // Log other failures (e.g., already inside, debounced)
      if (result.reason !== 'already_inside') {
        console.warn('Location entry failed:', result);
      }
      return; // Block the original call
    };
    window.showLocationHunt.__patched = true;
    window.showLocationHunt.__original = original;
  }

  patchCheckProximityAutoOpen() {
    if (!window.checkProximityAutoOpen || window.checkProximityAutoOpen.__patched) return;
    const original = window.checkProximityAutoOpen;
    const manager = this;
    window.checkProximityAutoOpen = function(loc, ft) {
      if (!loc?.id) return original.call(this, loc, ft); // Allow if no ID
      const result = manager.enterLocation(loc.id);
      if (result.success) return original.call(this, loc, ft); // Allow if no cooldown
      if (result.reason === 'on_cooldown') {
        // Show countdown if on cooldown
        manager.notifyUserWithCountdown(result.locationId, result.remainingSeconds);
      }
      return false; // Block auto-open
    };
    window.checkProximityAutoOpen.__patched = true;
    window.checkProximityAutoOpen.__original = original;
  }

  patchCloseFunctions() {
    const names = ['closeLocationHunt', 'closeLocation', 'hideLocationHunt', 'exitLocation'];
    for (const name of names) {
      if (window[name] && !window[name].__patched) this.patchCloseFunction(name);
    }
  }

  patchCloseFunction(funcName) {
    const original = window[funcName];
    const manager = this;
    window[funcName] = function(locationId) {
      // Always call leaveLocation when a close function is triggered
      if (manager.currentLocationId) manager.leaveLocation(manager.currentLocationId);
      else if (locationId) manager.leaveLocation(locationId);
      // Then call the original function
      return original.call(this, locationId);
    };
    window[funcName].__patched = true;
    window[funcName].__original = original;
  }

  patchCreateBottomActionBar() {
    if (!window.createBottomActionBar || window.createBottomActionBar.__patched) return;
    const original = window.createBottomActionBar;
    const manager = this;
    window.createBottomActionBar = function(location) {
      const bar = original.call(this, location);
      if (bar && location?.id) {
        const originalOnClick = bar.onclick;
        bar.onclick = function(e) {
          // Call leaveLocation when the action bar button is clicked
          manager.leaveLocation(location.id);
          return originalOnClick?.call(this, e); // Then call the original click handler
        };
      }
      return bar;
    };
    window.createBottomActionBar.__patched = true;
    window.createBottomActionBar.__original = original;
  }

  // --- Destruction ---
  destroy() {
    if (this.cleanupInterval) clearInterval(this.cleanupInterval);
    if (this.mapResetInterval) clearInterval(this.mapResetInterval);
    this.clearToast();
    if (this.visibilityHandler) {
      document.removeEventListener('visibilitychange', this.visibilityHandler);
    }
    // Restore original functions
    const patchedNames = ['showLocationHunt', 'checkProximityAutoOpen', 'closeLocationHunt', 'closeLocation', 'hideLocationHunt', 'exitLocation', 'createBottomActionBar'];
    for (const name of patchedNames) {
      if (window[name] && window[name].__original) {
        window[name] = window[name].__original;
      }
    }

    // Clear state
    this.currentLocationId = null;
    this.resetCooldownIds.clear();
  }

// --- Utility Methods (for external API if needed) ---
  getRemainingTime(locationId) { return this.checkCooldown(locationId).remainingSeconds; }
  getAllCooldowns() {
    const out = {};
    for (const id of Object.keys(this.cooldowns)) {
      const rem = this.getRemainingTime(id);
      if (rem > 0) out[id] = rem;
    }
    return out;
  }
  clearCooldown(locationId) {
    if (!locationId) return;
    const id = String(locationId);
    delete this.cooldowns[id];
    delete this.hiddenMsPerLoc[id];
    this.resetCooldownIds.delete(id);
    this.saveToStorage();
  }
  clearAllCooldowns() {
    this.cooldowns = {};
    this.hiddenMsPerLoc = {};
    this.resetCooldownIds.clear();
    this.saveToStorage();
  }
  getCurrentLocation() { return this.currentLocationId; }
}

// Export for module systems if needed
if (typeof module !== 'undefined' && module.exports) {
  module.exports = LocationCooldownManager;
}

// Initialize the manager after DOM is ready so showLocationHunt is defined
document.addEventListener('DOMContentLoaded', () => {
  if (typeof window !== 'undefined') {
    if (window.cooldownManager) window.cooldownManager.destroy();
    window.cooldownManager = new LocationCooldownManager();
  }
});
        
function showLocationHunt(location) {
    // Guard against re-entry before any async or DOM work begins.
    if (window.isLocationHuntVisible) return;

    const now = Date.now();
    const DEBOUNCE_TIME = (typeof CONFIG !== 'undefined' && CONFIG.DEBOUNCE_TIME) ? CONFIG.DEBOUNCE_TIME : 300;

    if (typeof window.lastFunctionCall === 'undefined') {
        window.lastFunctionCall = 0;
    }

    if (now - window.lastFunctionCall < DEBOUNCE_TIME) {
        return;
    }
    window.lastFunctionCall = now;

    // Set ALL gate flags synchronously before any DOM changes so every
    // subsequent GPS tick sees the closed state immediately.
    window.isLocationHuntVisible = true;
    window.lastVisitedLocationId = location.id;
    lastVisitedLocationId        = location.id;
    window.isMapInteracting      = true;
    
    // Get or create container
    const lochuntContainer = cachedElements.lochuntContainer || document.querySelector('.lochunt-container');
    if (!lochuntContainer) {
        return;
    }
    
    lochuntContainer.innerHTML = '';
    lochuntContainer.style.display = 'flex';
    lochuntContainer.classList.add('fade-in');

    // Announce to screen readers
    if (typeof announceToScreenReader === 'function') {
        announceToScreenReader(`Opened location: ${location.name}`);
    }

    // Create scrollable content container
    const scrollableContent = document.createElement('div');
    scrollableContent.style.cssText = `
        flex: 1;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
        scroll-behavior: smooth;
        will-change: scroll-position;
    `;

    // Create and append location image
    const locationImage = document.createElement('img');
    locationImage.src = location.image;
    locationImage.alt = location.name;
    locationImage.style.cssText = `
        width: 100%;
        height: 45vh;
        object-fit: cover;
        object-position: center;
    `;
    locationImage.loading = 'eager';
    scrollableContent.appendChild(locationImage);

    // Create content container
    const contentContainer = document.createElement('div');
    contentContainer.classList.add('lochunt-content');
    contentContainer.style.cssText = `
        padding: 24px;
        display: flex;
        flex-direction: column;
        align-items: center;
        max-width: 800px;
        margin: 0 auto;
    `;

    // Create location info section
    const locationInfo = document.createElement('div');
    locationInfo.classList.add('lochunt-info');
    locationInfo.style.cssText = `
        text-align: center;
        width: 100%;
        margin-bottom: 15px;
    `;

    // Location name
    const locationName = document.createElement('h1');
    locationName.textContent = location.name;
    locationName.style.cssText = `
        font-size: clamp(1.8rem, 4vw, 2.5rem);
        font-weight: 700;
        color: #1a1a1a;
        margin-bottom: 8px;
        line-height: 1.2;
    `;

    // Location city
    const locationCity = document.createElement('p');
    locationCity.textContent = location.city;
    locationCity.style.cssText = `
        font-size: clamp(1.1rem, 2vw, 1.3rem);
        color: #2c5282;
        font-weight: 600;
        margin-bottom: 4px;
    `;

    // Location creator
    const locationCreator = document.createElement('p');
    locationCreator.textContent = `Created by: ${location.creator}`;
    locationCreator.style.cssText = `
        font-size: calc(0.9rem + 0.4vw);
        color: #666666;
        font-weight: 500;
    `;

    // Append location info elements
    locationInfo.appendChild(locationName);
    locationInfo.appendChild(locationCity);
    locationInfo.appendChild(locationCreator);
    contentContainer.appendChild(locationInfo);

    // Create and append audio player
    if (typeof createAudioPlayer === 'function') {
        const audioPlayerContainer = createAudioPlayer(location.audio);
        const audioElement = audioPlayerContainer.querySelector('#locationAudio');
        if (audioElement) {
            audioElement.currentTime = 0;
        }
        contentContainer.appendChild(audioPlayerContainer);
    }
    
    scrollableContent.appendChild(contentContainer);
    lochuntContainer.appendChild(scrollableContent);

    // Create and append bottom action bar
    if (typeof createBottomActionBar === 'function') {
        const bottomActionBar = createBottomActionBar(location);
        bottomActionBar.style.cssText += `
            position: sticky;
            bottom: 0;
            width: 100%;
        `;
        lochuntContainer.appendChild(bottomActionBar);
    }

    // Initialize audio player after a short delay
    setTimeout(() => {
        if (typeof initAudioPlayer === 'function') {
            window.audioPlayerCleanup = initAudioPlayer();
        }
    }, 100);

    // Prefetch nearby audio if service worker is available
    if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
        const userPos = userMarker ? userMarker.getLatLng() : null;
        if (userPos && gameLocations) {
            navigator.serviceWorker.controller.postMessage({
                type: 'PREFETCH_AUDIO',
                data: {
                    userLocation: { lat: userPos.lat, lng: userPos.lng },
                    locations: gameLocations
                }
            });
        }
    }
}
        
function createAudioPlayer(audioSrc) {
    const audioPlayerContainer = document.createElement('div');
    audioPlayerContainer.classList.add('audio-player');
    audioPlayerContainer.style.cssText = `
        width: 100%;
        max-width: 400px;
        margin-bottom: 15px;
    `;
    const audio = document.createElement('audio');
    audio.id = 'locationAudio';
    audio.src = audioSrc;
    audio.preload = "auto";
    const audioProgress = document.createElement('div');
    audioProgress.classList.add('audio-progress');
    audioProgress.style.cssText = `
        width: 100%;
        margin-bottom: 15px;
    `;
    const progressContainer = document.createElement('div');
    progressContainer.classList.add('progress');
    progressContainer.style.cssText = `
        height: 8px;
        background-color: #e2e8f0;
        border-radius: 4px;
        cursor: pointer;
        margin-bottom: 12px;
        overflow: hidden;
    `;
    const progressBar = document.createElement('div');
    progressBar.id = 'progressBar';
    progressBar.classList.add('progress-bar');
    progressBar.style.cssText = `
        height: 100%;
        background-color: #2c5282;
        width: 0%;
        transition: width 0.1s linear;
    `;
    progressContainer.appendChild(progressBar);
    audioProgress.appendChild(progressContainer);
    const timeInfo = document.createElement('div');
    timeInfo.classList.add('audio-time');
    timeInfo.style.cssText = `
        display: flex;
        justify-content: space-between;
        color: #4a5568;
        font-size: 0.875rem;
        margin-bottom: 16px;
        font-weight: 500;
    `;
    const currentTimeSpan = document.createElement('span');
    currentTimeSpan.id = 'currentTime';
    currentTimeSpan.textContent = '0:00';
    const durationSpan = document.createElement('span');
    durationSpan.id = 'duration';
    durationSpan.textContent = '0:00';
    timeInfo.appendChild(currentTimeSpan);
    timeInfo.appendChild(durationSpan);
    const audioControls = document.createElement('div');
    audioControls.classList.add('audio-controls');
    audioControls.style.cssText = `
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 24px;
    `;
    const rewindBtn = createAudioButton('skip-backward', 'rewindBtn', 'Rewind 10 seconds');
    const playPauseBtn = createAudioButton('play', 'playPauseBtn', 'Play');
    const forwardBtn = createAudioButton('skip-forward', 'forwardBtn', 'Forward 10 seconds');
    audioControls.appendChild(rewindBtn);
    audioControls.appendChild(playPauseBtn);
    audioControls.appendChild(forwardBtn);
    audioPlayerContainer.appendChild(audio);
    audioPlayerContainer.appendChild(audioProgress);
    audioPlayerContainer.appendChild(timeInfo);
    audioPlayerContainer.appendChild(audioControls);
    return audioPlayerContainer;
}

function createAudioButton(iconName, id, ariaLabel) {
    const button = document.createElement('button');
    button.id = id;
    button.classList.add('audio-button');
    button.setAttribute('aria-label', ariaLabel);
    button.innerHTML = `<i class="bi bi-${iconName}"></i>`;
    button.style.cssText = `
        background-color: white;
        color: var(--primary-color);
        border: 2px solid var(--primary-color);
        border-radius: 50%;
        width: 55px;
        height: 55px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.3s ease;
    `;
    button.addEventListener('mouseover', () => {
        button.style.backgroundColor = 'var(--hover-color)';
    });
    button.addEventListener('mouseout', () => {
        button.style.backgroundColor = 'white';
    });
    button.addEventListener('click', () => {
        button.style.backgroundColor = 'var(--primary-color)';
        button.style.color = 'white';
        button.style.transform = 'scale(0.95)';
        
        setTimeout(() => {
            button.style.backgroundColor = 'white';
            button.style.color = 'var(--primary-color)';
            button.style.transform = 'scale(1)';
        }, 200);
    });
    return button;
}

function createBottomActionBar(location) {
    const actionBar = document.createElement('div');
    actionBar.classList.add('location-action-bar');
    actionBar.style.cssText = `
        width: 100%;
        height: 60px;
        background: linear-gradient(to right, #2c5282, #2b6cb0);
        margin-top: auto;
        box-shadow: 0 -2px 10px rgba(0,0,0,0.025);
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0 24px;
        position: sticky;
        bottom: 0;
    `;
    
    const imgSourceBtn = document.createElement('button');
    imgSourceBtn.classList.add('source-info-button', 'btn', 'btn-sm', 'me-2');
    imgSourceBtn.innerHTML = '<i class="bi bi-info-circle-fill text-white" style="font-size: 1.5rem;"></i>';
    imgSourceBtn.setAttribute('aria-label', 'Image source information');
    imgSourceBtn.onclick = () => {
        if (location && location.imageSource) {
            showSourcePopup('Image Source', location.imageSource);
        } else {
            showSourcePopup('Image Source', 'Image source information is not available');
        }
    };
    const feedbackButton = document.createElement('a');
    feedbackButton.href = 'mailto:mattreicher@protonmail.com?subject=Feedback';
    feedbackButton.target = '_blank';
    feedbackButton.rel = 'noopener noreferrer';
    feedbackButton.setAttribute('aria-label', 'Send feedback email');
    feedbackButton.innerHTML = '<i class="bi bi-envelope-fill text-white" style="font-size: 1.5rem;"></i>';
    feedbackButton.classList.add('feedback-email-button', 'btn', 'btn-sm');
    actionBar.appendChild(imgSourceBtn);
    actionBar.appendChild(feedbackButton);
    return actionBar;
}

function showSourcePopup(title, content) {
    const existingPopup = document.getElementById('sourceInfoPopup');
    if (existingPopup) {
        document.body.removeChild(existingPopup);
    }
    
    const overlay = document.createElement('div');
    overlay.id = 'sourceInfoPopup';
    overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 9999;
        backdrop-filter: blur(3px);
    `;
    
    const popup = document.createElement('div');
    popup.classList.add('source-info-content');
    popup.style.cssText = `
        background-color: white;
        border-radius: 8px;
        padding: 24px;
        width: 90%;
        max-width: 500px;
        max-height: 80vh;
        overflow-y: auto;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
        display: flex;
        flex-direction: column;
    `;
    
    const popupTitle = document.createElement('h3');
    popupTitle.textContent = title;
    popupTitle.style.cssText = `
        font-size: 1.5rem;
        font-weight: 600;
        color: #2c5282;
        margin-bottom: 16px;
        border-bottom: 1px solid #e2e8f0;
        padding-bottom: 12px;
    `;
    
    const popupContent = document.createElement('div');
    popupContent.style.cssText = `
        margin-bottom: 20px;
        line-height: 1.6;
        font-size: 1rem;
    `;
    popupContent.textContent = content;
    
    const closeButton = document.createElement('button');
    closeButton.textContent = 'Close';
    closeButton.classList.add('source-close-button', 'btn');
    closeButton.style.cssText = `
        background: linear-gradient(to right, #2c5282, #2b6cb0);
        border: none;
        color: white;
        padding: 8px 24px;
        border-radius: 4px;
        font-weight: 500;
        cursor: pointer;
        align-self: flex-end;
        transition: all 0.2s ease;
    `;
    
    closeButton.addEventListener('mouseover', () => {
        closeButton.style.opacity = '0.9';
    });
    
    closeButton.addEventListener('mouseout', () => {
        closeButton.style.opacity = '1';
    });
    
    closeButton.addEventListener('click', () => {
        document.body.removeChild(overlay);
    });
    
    overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
            document.body.removeChild(overlay);
        }
    });
    
    popup.appendChild(popupTitle);
    popup.appendChild(popupContent);
    popup.appendChild(closeButton);
    overlay.appendChild(popup);
    document.body.appendChild(overlay);
    
    overlay.style.opacity = '0';
    popup.style.transform = 'translateY(20px)';
    popup.style.transition = 'transform 0.3s ease, opacity 0.3s ease';
    overlay.style.transition = 'opacity 0.3s ease';
    
    setTimeout(() => {
        overlay.style.opacity = '1';
        popup.style.transform = 'translateY(0)';
    }, 10);
}

function initAudioPlayer() {
    const audio = document.getElementById('locationAudio');
    const playPauseBtn = document.getElementById('playPauseBtn');
    const rewindBtn = document.getElementById('rewindBtn');
    const forwardBtn = document.getElementById('forwardBtn');
    const progressBar = document.getElementById('progressBar');
    const progressContainer = document.querySelector('.progress');
    const currentTimeSpan = document.getElementById('currentTime');
    const durationSpan = document.getElementById('duration');
    if (!audio || !playPauseBtn || !progressBar) {
        console.error("Audio player elements not found");
        return;
    }
    
    if (audio.src && !audio.dataset.originalSrc) {
        audio.dataset.originalSrc = audio.src;
    }
    
    let wakeLock = null;
    let audioContext = null;
    let isPlayerActive = true;
    
    let retryCount = 0;
    const maxRetries = 3;
    let lastPlaybackPosition = 0;
    let recoveryInProgress = false;
    
    let wasPlayingWhenHidden = false;
    let screenWentAway = false;
    let wasPlaying = false;
    
    function initAudioContext() {
        if (!audioContext && isPlayerActive) {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const source = audioContext.createMediaElementSource(audio);
                source.connect(audioContext.destination);
            } catch (e) {
                console.log('AudioContext not available:', e);
            }
        }
        return audioContext;
    }
    
    async function requestWakeLock() {
        try {
            if ('wakeLock' in navigator && !wakeLock && isPlayerActive) {
                wakeLock = await navigator.wakeLock.request('screen');
                console.log('Wake lock acquired');
                
                wakeLock.addEventListener('release', () => {
                    console.log('Wake lock released');
                    wakeLock = null;
                    if (!audio.paused) {
                        screenWentAway = true;
                        wasPlayingWhenHidden = true;
                    }
                });
            }
        } catch (err) {
            console.warn('Wake lock failed:', err);
        }
    }
    
    async function releaseWakeLock() {
        if (wakeLock) {
            try {
                await wakeLock.release();
                wakeLock = null;
                console.log('Wake lock manually released');
            } catch (err) {
                console.warn('Wake lock release failed:', err);
            }
        }
    }
    
    document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
            if (!audio.paused) {
                wasPlayingWhenHidden = true;
                screenWentAway = true;
            }
        } else {
            if (wasPlayingWhenHidden && audio.paused) {
                setTimeout(() => {
                    if (screenWentAway) {
                        showSourcePopup("Audio Restarted", "Audio was interrupted when this tab became inactive and has restarted from the beginning. Keep this tab active to prevent interruptions.");
                        screenWentAway = false;
                        wasPlayingWhenHidden = false;
                    }
                }, 100);
            }
        }
    });
    
    audio.addEventListener('play', () => {
        wasPlaying = true;
        announceToScreenReader('Audio playback started');
    });
    
    audio.addEventListener('pause', () => {
        wasPlaying = false;
        announceToScreenReader('Audio playback paused');
    });
    
    function recoverAudioSource() {
        if (recoveryInProgress || !isPlayerActive) return;
        
        recoveryInProgress = true;
        console.log('Attempting audio recovery...');
        
        if (!isNaN(audio.currentTime)) {
            lastPlaybackPosition = audio.currentTime;
        }
        
        if (audio.dataset.originalSrc) {
            audio.src = audio.dataset.originalSrc;
        } else if (audio.getAttribute('data-src')) {
            audio.src = audio.getAttribute('data-src');
        }
        
        audio.load();
        
        const setPositionAfterNetworkRecovery = () => {
            if (lastPlaybackPosition > 0 && !screenWentAway) {
                audio.currentTime = lastPlaybackPosition;
            } else if (screenWentAway) {
                audio.currentTime = 0;
            }
            recoveryInProgress = false;
            retryCount = 0;
            audio.removeEventListener('loadedmetadata', setPositionAfterNetworkRecovery);
            audio.removeEventListener('canplay', setPositionAfterNetworkRecovery);
        };
        
        audio.addEventListener('loadedmetadata', setPositionAfterNetworkRecovery);
        audio.addEventListener('canplay', setPositionAfterNetworkRecovery);
    }
    
    function handleAudioError(error) {
       console.log('handleAudioError called, isPlayerActive:', isPlayerActive, 'audio exists:', !!audio);
       
       const actualError = audio ? audio.error : null;
       if (actualError) {
           console.error("Actual audio error details:", {
               code: actualError.code,
               message: actualError.message,
               MEDIA_ERR_ABORTED: actualError.code === 1,
               MEDIA_ERR_NETWORK: actualError.code === 2,
               MEDIA_ERR_DECODE: actualError.code === 3,
               MEDIA_ERR_SRC_NOT_SUPPORTED: actualError.code === 4
           });
       }
       
       if (!isPlayerActive && (!audio || audio.readyState === 0)) {
           console.log('Audio error ignored - player cleaned up');
           return;
       }
       
       console.error("Audio play error event:", error);
       releaseWakeLock();
       
       if (screenWentAway || wasPlayingWhenHidden) {
           const resumePosition = lastPlaybackPosition || 0;
           console.log('Screen interruption detected, stored position:', resumePosition);
           
           showSourcePopup("Audio Interrupted", `Audio was paused when you left the screen. Click play to resume from ${Math.floor(resumePosition / 60)}:${String(Math.floor(resumePosition % 60)).padStart(2, '0')}.`);
           
           if (audio) {
               audio.dataset.resumePosition = resumePosition.toString();
               
               const prepareForResume = () => {
                   console.log('Audio prepared for manual resume');
                   audio.removeEventListener('loadedmetadata', prepareForResume);
                   audio.removeEventListener('canplay', prepareForResume);
               };
               
               audio.addEventListener('loadedmetadata', prepareForResume);
               audio.addEventListener('canplay', prepareForResume);
               
               recoverAudioSource();
           }
           
           screenWentAway = false;
           wasPlayingWhenHidden = false;
       } else if (retryCount < maxRetries && isPlayerActive) {
           retryCount++;
           console.log(`Recovery attempt ${retryCount}/${maxRetries}`);
           
           setTimeout(() => {
               const currentPos = lastPlaybackPosition || 0;
               const setPositionAfterNetworkRecovery = () => {
                   if (currentPos > 0) {
                       console.log('Setting position after network recovery:', currentPos);
                       audio.currentTime = currentPos;
                   }
                   audio.removeEventListener('loadedmetadata', setPositionAfterNetworkRecovery);
                   audio.removeEventListener('canplay', setPositionAfterNetworkRecovery);
               };
               
               audio.addEventListener('loadedmetadata', setPositionAfterNetworkRecovery);
               audio.addEventListener('canplay', setPositionAfterNetworkRecovery);
               
               recoverAudioSource();
           }, 1000 * retryCount);
       } else if (retryCount >= maxRetries) {
           console.error('Audio recovery failed after maximum retries');
           playPauseBtn.innerHTML = '<i class="bi bi-exclamation-triangle"></i>';
           playPauseBtn.setAttribute('aria-label', 'Audio Error');
           showSourcePopup("Audio Error", "Unable to recover audio after multiple attempts. Please refresh the page or try again later.");
       } else {
           if (audio) {
               const currentPos = lastPlaybackPosition || 0;
               const setPositionAfterGenericRecovery = () => {
                   if (currentPos > 0) {
                       console.log('Setting position after generic recovery:', currentPos);
                       audio.currentTime = currentPos;
                   }
                   audio.removeEventListener('loadedmetadata', setPositionAfterGenericRecovery);
                   audio.removeEventListener('canplay', setPositionAfterGenericRecovery);
               };
               
               audio.addEventListener('loadedmetadata', setPositionAfterGenericRecovery);
               audio.addEventListener('canplay', setPositionAfterGenericRecovery);
               
               recoverAudioSource();
           }
           showSourcePopup("Audio Error", "An audio error occurred. Attempting to resume from last position.");
       }
       
       playPauseBtn.innerHTML = '<i class="bi bi-play"></i>';
       playPauseBtn.setAttribute('aria-label', 'Play');
    }
    
   function togglePlay() {
       if (audio.paused) {
           const resumePosition = audio.dataset.resumePosition;
           if (resumePosition && parseFloat(resumePosition) > 0) {
               console.log('Resuming from stored position:', resumePosition);
               audio.currentTime = parseFloat(resumePosition);
               delete audio.dataset.resumePosition;
           }
           
           audio.play().then(() => {
               playPauseBtn.innerHTML = '<i class="bi bi-pause"></i>';
               playPauseBtn.setAttribute('aria-label', 'Pause');
               requestWakeLock();
           }).catch(error => {
               handleAudioError(error);
           });
       } else {
           audio.pause();
           playPauseBtn.innerHTML = '<i class="bi bi-play"></i>';
           playPauseBtn.setAttribute('aria-label', 'Play');
       }
    }
    
    audio.addEventListener('timeupdate', () => {
       if (!isNaN(audio.currentTime) && isPlayerActive && audio.currentTime > 0) {
           lastPlaybackPosition = audio.currentTime;
           try {
               localStorage.setItem('audioPosition', audio.currentTime.toString());
           } catch (e) {}
       }
    });
    
    document.addEventListener('visibilitychange', () => {
       if (document.hidden) {
           if (audio && !audio.paused) {
               if (!isNaN(audio.currentTime)) {
                   lastPlaybackPosition = audio.currentTime;
                   try {
                       localStorage.setItem('audioPosition', audio.currentTime.toString());
                   } catch (e) {}
               }
               
               wasPlayingWhenHidden = true;
               screenWentAway = true;
               
               audio.pause();
               
               playPauseBtn.innerHTML = '<i class="bi bi-play"></i>';
               playPauseBtn.setAttribute('aria-label', 'Play');
           }
       }
    });
    
    window.addEventListener('blur', () => {
       if (audio && !audio.paused) {
           lastPlaybackPosition = audio.currentTime;
           wasPlayingWhenHidden = true;
           screenWentAway = true;
           console.log('Window blur, storing position:', lastPlaybackPosition);
       }
    });
    
    window.addEventListener('online', () => {
       if (audio.error && isPlayerActive) {
           console.log('Network recovered, attempting to reload audio');
           const savedPos = lastPlaybackPosition || 0;
           const setPositionAfterOnline = () => {
               if (savedPos > 0) {
                   audio.currentTime = savedPos;
               }
               audio.removeEventListener('loadedmetadata', setPositionAfterOnline);
               audio.removeEventListener('canplay', setPositionAfterOnline);
           };
           
           audio.addEventListener('loadedmetadata', setPositionAfterOnline);
           audio.addEventListener('canplay', setPositionAfterOnline);
           
           recoverAudioSource();
       }
    });
    
    playPauseBtn.addEventListener('click', togglePlay);
    rewindBtn.addEventListener('click', () => seek(-10));
    forwardBtn.addEventListener('click', () => seek(10));
    audio.addEventListener('timeupdate', updateProgress);
    audio.addEventListener('loadedmetadata', setDuration);
    audio.addEventListener('ended', async () => {
       playPauseBtn.innerHTML = '<i class="bi bi-play"></i>';
       playPauseBtn.setAttribute('aria-label', 'Play');
       await releaseWakeLock();
       
       try {
           localStorage.removeItem('audioPosition');
       } catch (e) {}
       
       audio.currentTime = 0;
       if (progressBar) {
           progressBar.style.width = '0%';
       }
       
       announceToScreenReader('Audio playback completed');
       showAdditionalInfo();
    });
    audio.addEventListener('pause', releaseWakeLock);
    audio.addEventListener('error', (e) => {
       handleAudioError(e);
    });
    
    if (progressContainer) {
       progressContainer.addEventListener('click', setProgress);
    }
    
    audio.addEventListener('loadedmetadata', () => {
       try {
           const savedPosition = localStorage.getItem('audioPosition');
           if (savedPosition && !isNaN(savedPosition) && parseFloat(savedPosition) > 0 && !screenWentAway && !wasPlayingWhenHidden) {
               audio.currentTime = parseFloat(savedPosition);
           }
       } catch (e) {}
    });
    
    audio.load();
    
async function togglePlay() {
    if (!isPlayerActive) return;
    
    // check to prevent empty src errors
    if (!audio.src || audio.src.trim() === '' || audio.src === window.location.href) {
        return;
    }
    
    try {
        if (audio.paused) {
            const ctx = initAudioContext();
            if (ctx && ctx.state === 'suspended') {
                await ctx.resume();
            }
            
            const playPromise = audio.play();
            if (playPromise !== undefined) {
                playPromise.then(async () => {
                    playPauseBtn.innerHTML = '<i class="bi bi-pause"></i>';
                    playPauseBtn.setAttribute('aria-label', 'Pause');
                    await requestWakeLock();
                    retryCount = 0;
                }).catch(error => {
                    handleAudioError(error);
                });
            }
        } else {
            audio.pause();
            playPauseBtn.innerHTML = '<i class="bi bi-play"></i>';
            playPauseBtn.setAttribute('aria-label', 'Play');
            await releaseWakeLock();
        }
    } catch (error) {
        handleAudioError(error);
    }
}
    
    function seek(seconds) {
        if (!isPlayerActive) return;
        audio.currentTime = Math.max(0, Math.min(audio.currentTime + seconds, audio.duration));
        
        const direction = seconds > 0 ? 'forward' : 'backward';
        announceToScreenReader(`Skipped ${Math.abs(seconds)} seconds ${direction}`);
    }
    
    function updateProgress() {
        if (!isPlayerActive || !isFinite(audio.duration)) return;
        
        const percent = (audio.currentTime / audio.duration) * 100;
        progressBar.style.width = `${percent}%`;
        currentTimeSpan.textContent = formatTime(audio.currentTime);
    }
    
    function setProgress(e) {
        if (!isPlayerActive) return;
        
        const width = this.clientWidth;
        const clickX = e.offsetX;
        const duration = audio.duration;
        
        if (isFinite(duration) && width > 0) {
            audio.currentTime = (clickX / width) * duration;
            
            const newTime = formatTime(audio.currentTime);
            announceToScreenReader(`Jumped to ${newTime}`);
        }
    }
    
    function setDuration() {
        if (!isPlayerActive || !isFinite(audio.duration)) return;
        durationSpan.textContent = formatTime(audio.duration);
    }
    
    function formatTime(time) {
        if (!isFinite(time)) return "0:00";
        
        const minutes = Math.floor(time / 60);
        const seconds = Math.floor(time % 60);
        return `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }
    
    return function cleanup() {
        console.log('Audio player cleanup starting');
        releaseWakeLock();
        isPlayerActive = false;
        if (audioContext) {
            audioContext.close();
        }
        console.log('Audio player cleaned up');
    };
}

function showAdditionalInfo() {
    const locationId = window.lastVisitedLocationId || lastVisitedLocationId;
    
    if (!locationId) {
        console.error('No location ID available');
        return;
    }
    
    const location = gameLocations.find(loc => loc.id === locationId);
    
    if (!location) {
        console.error('Location not found for ID:', locationId);
        return;
    }

    const additionalInfoContainer = cachedElements.additionalInfoContainer || 
        document.querySelector('.additional-info-container');
    
    if (!additionalInfoContainer) {
        console.error('Additional info container not found in DOM');
        return;
    }
    
    additionalInfoContainer.style.display = 'block';
    additionalInfoContainer.classList.add('fade-in');
    
    const additionalInfoElement = document.getElementById('additionalInfo');
    if (additionalInfoElement) {
        additionalInfoElement.textContent = 
            location.additionalInfo || "No additional information available for this location.";
    }
    
    if (typeof announceToScreenReader === 'function') {
        announceToScreenReader('Additional information is now available');
    }

    const continueButton = document.getElementById('continueButton');
    if (continueButton) {
        continueButton.onclick = () => handleContinueClick();
    }
}

function handleContinueClick() { 
    const FADE_DURATION_MS = 300;

    if (window._continueClickInProgress) return;
    window._continueClickInProgress = true;

    // leaveLocation() must fire first so cooldownManager's currentLocationId
    // is cleared before anything else reads or writes proximity state.
    const departingId = window.lastVisitedLocationId ?? lastVisitedLocationId ?? null;
    if (window.cooldownManager && departingId != null) {
        window.cooldownManager.leaveLocation(departingId);
    }

    // Set this synchronously so _handleTriggerZone's re-entry guard fires
    // immediately on the next GPS update, before the fade animation completes.
    window.isLocationHuntVisible = false;
    isLocationHuntVisible = false;

    if (window.zoomController) {
        const activeSource = window.zoomController.getState()?.source;
        if (activeSource) window.zoomController.release(activeSource);
    }

    // ===== UPDATED SECTION =====
    // Use the proper cleanup function instead of direct null assignment
    if (typeof _resetProximityZoom === 'function') {
        _resetProximityZoom('location_closed');
    } else {
        // Fallback to direct cleanup if function not available
        window._pzState = null;
    }
    // ===========================

    window._prefetchState                    = null;
    window._lastProximityTriggerByLocation   = {};
    window.preloadedLocation                 = null;
    //window.proximityState                    = null;
    window.lastClosestDistance               = undefined;
    window.lastClosestLocation               = null;

    window.zoomedInState                     = false;
    window.isNearLocation                    = false;
    window.blockSpeedZoom                    = false;
    window.currentProximityLocationId        = null;
    window._didPrefetch19                    = false;

    // Do this after zoom flags so any pending stationary proximity check
    // doesn't fire against the wiped state.
    clearStationaryState();

    window.isMapInteracting = false;
    window.followUser       = true;

    if (map && window.lastPosition) {
        // Brief block prevents the restored GPS feed from fighting the
        // return-to-user pan during the animation window.
        window._blockAutoMapUpdates = true;

        map.setView(
            [window.lastPosition.lat, window.lastPosition.lng],
            map.getZoom(),
            { animate: true, duration: 0.6, easeLinearity: 0.18 }
        );

        setTimeout(() => {
            window._blockAutoMapUpdates = false;
        }, 800);
    }

    ensureGPSActive();

    // Release the re-entry guard after the full animation cycle so a rapid
    // double-tap can't queue a second close while the first is still fading.
    closeModalWithAnimation(FADE_DURATION_MS, () => {
        window._continueClickInProgress = false;
    });
}

function clearStationaryState() {
    // Clear stationary detection
    window.isStationary = false;
    window.stationaryLockPosition = null;
    window.stationaryStartTime = null;

    if (window.stationaryCheckTimeout) {
        clearTimeout(window.stationaryCheckTimeout);
        window.stationaryCheckTimeout = null;
    }

    if (window.positionBuffer?.length > 0) {
        const lastPos = window.positionBuffer[window.positionBuffer.length - 1];
        // If last position is stale (older than 10 seconds), clear entire buffer
        if (Date.now() - lastPos.timestamp > 10000) { // 10 seconds
            console.debug("clearStationaryState: Clearing buffer due to stale last position (>10s old)");
            window.positionBuffer = [];
        }
        // Otherwise, keep the buffer intact for smooth transitions using recent history
    } else if (!window.positionBuffer) {
        // Initialize if it doesn't exist
        window.positionBuffer = [];
    }

    // Reset update time to allow immediate next update
    window.lastUpdateTime = null;
    // The next GPS update will naturally refresh the position through the smoothing pipeline
}
        
function ensureGPSActive() {
    // Ensure GPS watch is running
    if (window.positionWatchId === undefined || window.positionWatchId === null) {
        console.log("GPS watch inactive - restarting");
        startPositionUpdates();
    } else {
        console.log("GPS watch active - awaiting fresh updates");
    }
}

function closeModalWithAnimation(fadeDuration, onComplete) {
    const additionalInfoContainer =
        cachedElements.additionalInfoContainer ??
        document.querySelector('.additional-info-container');
    const lochuntContainer =
        cachedElements.lochuntContainer ??
        document.querySelector('.lochunt-container');

    additionalInfoContainer.classList.add('fade-out');

    setTimeout(() => {
        additionalInfoContainer.style.display = 'none';
        additionalInfoContainer.classList.remove('fade-out', 'fade-in');

        lochuntContainer.classList.add('fade-out');

        setTimeout(() => {
            lochuntContainer.style.display = 'none';
            lochuntContainer.classList.remove('fade-out');

            finalizeModalClose();

            // Fire the completion callback (releases re-entry guard, etc.)
            if (typeof onComplete === 'function') onComplete();

        }, fadeDuration);
    }, fadeDuration);
}

function finalizeModalClose() {
    announceToScreenReader('Returned to map view');
    
    // Clean up audio player
    if (window.audioPlayerCleanup) {
        try {
            window.audioPlayerCleanup();
        } catch (e) {
            console.error('Audio cleanup failed:', e);
        }
        window.audioPlayerCleanup = null;
    }

    // Restore full tracking - now that UI is fully cleared
    if (typeof _restoreFullTracking === 'function') {
        _restoreFullTracking();
    } else {
        // Fallback: restore tracking manually
        followUser = true;
        window.followUser = true;
        window.isMapInteracting = false;
        
        // Force immediate map update if position available
        if (window.lastPosition && userMarker) {
            const pos = {
                coords: {
                    latitude: window.lastPosition.lat,
                    longitude: window.lastPosition.lng,
                    accuracy: window.lastPosition.accuracy || 20,
                    heading: window.lastPosition.heading ?? null,
                    speed: window.lastPosition.speedMPS || 0
                },
                timestamp: Date.now()
            };
            updateUserLocation(pos, true);
        }
    }

    updateDistanceBox();
}

// Simple tracking restoration (no cooldown dependency)
function _restoreFullTracking() {
    window.followUser = true;
    window.isMapInteracting = false;
    window.isLocationHuntVisible = false;

    // Trigger a position update to restore full tracking behavior
    if (window.lastPosition?.lat !== undefined && window.lastPosition?.lng !== undefined) {

        // Create a seed position based on the last known good position
        const seedPosition = {
            lat: window.lastPosition.lat,
            lng: window.lastPosition.lng,
            accuracy: window.lastPosition.accuracy || 20,
            heading: window.lastPosition.heading ?? null,
            timestamp: Date.now(), // Use current time for the seed
            speedMPS: window.lastPosition.speedMPS || 0
        };

        // Fill the buffer with copies of the seed position for immediate smoothing context
        seedPositionBuffer(seedPosition, 5); // Use the controlled helper function

        // Prepare the restoration position object in the format expected by updateUserLocation
        const restorationPosition = {
            coords: {
                latitude: seedPosition.lat,
                longitude: seedPosition.lng,
                accuracy: seedPosition.accuracy,
                heading: seedPosition.heading,
                speed: seedPosition.speedMPS // Ensure speed is in m/s as expected by updateUserLocation
            },
            timestamp: seedPosition.timestamp
        };

        // This prevents jumps that can occur with forceUpdate=true when buffers are empty
        updateUserLocation(restorationPosition, false);
    }
}
        
function showLocationSummary(locationId) {
  const location = locations.find(loc => String(loc.id) === String(locationId));
  if (!location || !location.summary) {
    console.log("Location or summary not found. Location ID:", locationId);
    showPopup("Error", "Summary not available for this location.");
    return;
  }
  // Hide the distance box
  const distanceBox = document.querySelector('#distanceBox');
  if (distanceBox) distanceBox.style.display = 'none';
  
  // Difficulty system - cleaner accessibility focus
  const level = Math.max(1, Math.min(5, location.difficulty || 1));
  const difficultyInfo = {
    1: { color: '#059669', bg: '#d1fae5', text: 'Very Easy', desc: 'Wheelchair accessible, paved paths' },
    2: { color: '#65a30d', bg: '#ecfccb', text: 'Easy', desc: 'Short walk, maintained trails' },
    3: { color: '#d97706', bg: '#fed7aa', text: 'Moderate', desc: 'Some walking, uneven terrain possible' },
    4: { color: '#dc2626', bg: '#fecaca', text: 'Challenging', desc: 'Longer hike, steep sections' },
    5: { color: '#991b1b', bg: '#fee2e2', text: 'Difficult', desc: 'Strenuous hike, excellent fitness required' }
  };
  const difficulty = difficultyInfo[level];
  
  // Build modal
  const popupDiv = document.createElement('div');
  popupDiv.id = 'summaryModal';
  popupDiv.style.cssText = `
      position:fixed; inset:0;
      background:rgba(0,0,0,.6); backdrop-filter:blur(4px);
      display:flex; align-items:center; justify-content:center;
      z-index:1000; opacity:0; transition:opacity .3s ease;
      padding:16px;
  `;
  const darkBlue = '#1a3a8a';
  const darkBlueHover = '#0d2c6e';
  popupDiv.innerHTML = `
    <div style="
        background:#fff; border-radius:16px; width:100%; max-width:420px; max-height:85vh;
        box-shadow:0 15px 40px rgba(0,0,0,.2); overflow:hidden;
        transform:translateY(20px); transition:transform .4s cubic-bezier(.175,.885,.32,1.275);
        display:flex; flex-direction:column;
    ">
      <div style="background:${darkBlue}; color:#fff; text-align:center; padding:20px 24px;">
        <h3 style="margin:0; font-size:1.4rem; font-weight:600; line-height:1.2;">${location.name}</h3>
      </div>
      <div style="flex:1; overflow-y:auto; padding:24px; -webkit-overflow-scrolling:touch;">
        <p style="color:#5c6c7c; line-height:1.6; font-size:1rem; margin:0 0 20px">
          ${location.summary}
        </p>
        
        <div style="
            background:${difficulty.bg}; border:1px solid ${difficulty.color}60; border-radius:12px; 
            padding:18px; margin-bottom:18px; position:relative;
        ">
          <div style="
              position:absolute; top:12px; right:12px; 
              background:${difficulty.color}; color:#fff; 
              padding:8px 16px; border-radius:20px; 
              font-size:1rem; font-weight:700; 
              box-shadow:0 4px 12px rgba(0,0,0,.15);
              border:3px solid #fff;
          ">${level}/5</div>
          <div style="
              font-weight:600; color:#374151; font-size:0.95rem; 
              margin-bottom:10px; padding-right:80px;
          ">
            Access
          </div>
          <div style="display:flex; align-items:center; gap:12px; margin-bottom:6px;">
            <div style="width:10px; height:10px; border-radius:50%; background:${difficulty.color}; flex-shrink:0;"></div>
            <span style="color:${difficulty.color}; font-weight:600; font-size:1rem;">${difficulty.text}</span>
          </div>
          <div style="color:#6b7280; font-size:0.9rem; padding-left:22px; line-height:1.4;">
            ${difficulty.desc}
          </div>
        </div>
        
        ${location.today ? `
        <div style="
            border:2px solid ${darkBlue}; border-radius:12px; padding:16px;
            background:rgba(26,58,138,.05); margin-bottom:20px;
            display:flex; align-items:center;
        ">
          <div style="font-weight:600; color:#2c3e50; padding-right:15px; min-width:80px">Location:</div>
          <div style="flex:1; color:#2c3e50; border-left:1px solid rgba(26,58,138,.2); padding-left:15px; font-size:0.95rem;">
            ${location.today}
          </div>
        </div>
        ` : ''}
        
        <div style="display:flex; justify-content:center; margin-top:12px;">
          <button class="continue-btn" style="
              padding:16px 32px; background:${darkBlue}; color:#fff; border:none;
              border-radius:12px; cursor:pointer; font-size:1.05rem; font-weight:600;
              min-width:140px; transition:.2s; -webkit-tap-highlight-color:transparent;
              box-shadow:0 4px 14px rgba(26,58,138,.3);
          ">Continue</button>
        </div>
      </div>
    </div>
  `;
  document.body.appendChild(popupDiv);
  
  // Animate in
  requestAnimationFrame(() => {
    popupDiv.style.opacity = '1';
    popupDiv.querySelector('div').style.transform = 'translateY(0)';
  });

  // Close helpers
  function close() {
    popupDiv.style.opacity = '0';
    popupDiv.querySelector('div').style.transform = 'translateY(20px)';
    setTimeout(() => {
      document.body.removeChild(popupDiv);
      // Restore distance box
      if (distanceBox) distanceBox.style.display = 'block';
    }, 300);
  }

  const btn = popupDiv.querySelector('.continue-btn');
  btn.addEventListener('mouseover', () => btn.style.backgroundColor = darkBlueHover);
  btn.addEventListener('mouseout',  () => btn.style.backgroundColor = darkBlue);
  btn.addEventListener('click', close);
  popupDiv.addEventListener('click', e => { if (e.target === popupDiv) close(); });
}

function showNavigationTips() {
   const distanceBox = document.querySelector('#distanceBox'); 
   if (distanceBox) {
       distanceBox.style.display = 'none';
   }
   
   const modalOverlay = document.createElement("div");
   modalOverlay.className = "navigation-tips-overlay";
   modalOverlay.style.cssText = `
       position: fixed;
       top: 0;
       left: 0;
       width: 100%;
       height: 100%;
       background-color: rgba(0, 0, 0, 0.6);
       backdrop-filter: blur(4px);
       display: flex;
       justify-content: center;
       align-items: center;
       z-index: 1000;
       opacity: 0;
       transition: opacity 0.3s ease;
   `;
   
   const darkBlue = "var(--dark-blue)";
   const darkBlueHover = "var(--dark-blue-hover)";
   
   const modalContent = document.createElement("div");
   modalContent.className = "navigation-tips-content";
   modalContent.style.cssText = `
       background-color: white;
       border-radius: 16px;
       width: 92%;
       max-width: 520px;
       max-height: 95vh;
       box-shadow: 0 15px 40px rgba(0, 0, 0, 0.25);
       transform: translateY(20px);
       transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
       overflow: hidden;
       display: flex !important;
       flex-direction: column !important;
       position: relative;
   `;
   
   const header = document.createElement("div");
   header.style.cssText = `
       text-align: center;
       padding: 24px 32px 0;
   `;
   
   header.innerHTML = `
       <h3 style="
           margin: 0 0 12px 0;
           color: ${darkBlue};
           font-size: 1.65rem;
           font-weight: 600;
       ">Navigation Tips</h3>
   `;
   
   const contentArea = document.createElement("div");
   contentArea.style.cssText = `
       padding: 0 32px;
       color: #4a5a6a;
       line-height: 1.6;
       font-size: 1.05rem;
       overflow-y: auto;
       max-height: calc(95vh - 180px);
   `;
   
   contentArea.innerHTML = `
       <ul style="
           list-style-type: none;
           padding: 0;
           margin: 0 0 12px 0;
       ">
           <li style="margin-bottom: 12px; display: flex; align-items: flex-start;">
               <span style="color: ${darkBlue}; margin-right: 12px; font-size: 1.2rem; margin-top: 2px;">•</span>
               <span>Use the map to navigate to the marked locations.</span>
           </li>
           <li style="margin-bottom: 12px; display: flex; align-items: flex-start;">
               <span style="color: ${darkBlue}; margin-right: 12px; font-size: 1.2rem; margin-top: 2px;">•</span>
               <span>Tap the recenter button to focus on your current position.</span>
           </li>
           <li style="margin-bottom: 12px; display: flex; align-items: flex-start;">
               <span style="color: ${darkBlue}; margin-right: 12px; font-size: 1.2rem; margin-top: 2px;">•</span>
               <span>The distance box shows how far you are from the closest location.</span>
           </li>
           <li style="margin-bottom: 12px; display: flex; align-items: flex-start;">
               <span style="color: ${darkBlue}; margin-right: 12px; font-size: 1.2rem; margin-top: 2px;">•</span>
               <span>When you're within 20 feet of a location, you'll be able to interact with it.</span>
           </li>
           <li style="margin-bottom: 12px; display: flex; align-items: flex-start;">
               <span style="color: ${darkBlue}; margin-right: 12px; font-size: 1.2rem; margin-top: 2px;">•</span>
               <span>Listen to the audio information for each location.</span>
           </li>
           <li style="margin-bottom: 0; display: flex; align-items: flex-start;">
               <span style="color: ${darkBlue}; margin-right: 12px; font-size: 1.2rem; margin-top: 2px;">•</span>
               <span>Your location stays on your device; nothing is uploaded.</span>
           </li>
       </ul>
   `;
   
   const footer = document.createElement("div");
   footer.style.cssText = `
       padding: 18px 32px 24px !important;
       text-align: center !important;
       border-top: 1px solid rgba(0, 0, 0, 0.05);
       margin-top: 12px !important;
       display: flex !important;
       justify-content: center !important;
       align-items: center !important;
       position: relative !important;
       bottom: 0 !important;
       width: 100% !important;
       box-sizing: border-box !important;
   `;
   
   const closeButton = document.createElement("button");
   closeButton.className = "close-button";
   closeButton.textContent = "Close";
   closeButton.style.cssText = `
       padding: 12px 28px !important;
       background-color: ${darkBlue};
       color: white;
       border: none;
       border-radius: 10px;
       cursor: pointer;
       font-size: 1.05rem;
       font-weight: 600;
       width: 100% !important;
       max-width: 220px !important;
       transition: all 0.2s ease;
       margin: 0 auto !important;
       display: block !important;
       position: relative !important;
       left: 0 !important;
       right: 0 !important;
   `;
   
   footer.appendChild(closeButton);
   
   modalContent.appendChild(header);
   modalContent.appendChild(contentArea);
   modalContent.appendChild(footer);
   modalOverlay.appendChild(modalContent);
   
   // Prevent clicks on modal content from passing through
   modalContent.addEventListener("click", function(e) {
       e.stopPropagation();
   });
   
   document.body.appendChild(modalOverlay);
   
   setTimeout(() => {
       modalOverlay.style.opacity = "1";
       modalContent.style.transform = "translateY(0)";
   }, 10);
   
   closeButton.addEventListener("mouseover", function() {
       this.style.backgroundColor = darkBlueHover;
   });
   
   closeButton.addEventListener("mouseout", function() {
       this.style.backgroundColor = darkBlue;
   });
   
   closeButton.addEventListener("click", function(e) {
       e.preventDefault();
       e.stopPropagation();
       modalOverlay.style.opacity = "0";
       modalContent.style.transform = "translateY(20px)";
       setTimeout(() => {
           document.body.removeChild(modalOverlay);
           if (distanceBox) {
               distanceBox.style.display = 'block';
           }
       }, 300);
   });
   
   modalOverlay.addEventListener("click", function(e) {
       if (e.target === modalOverlay) {
           e.preventDefault();
           e.stopPropagation();
           modalOverlay.style.opacity = "0";
           modalContent.style.transform = "translateY(20px)";
           setTimeout(() => {
               document.body.removeChild(modalOverlay);
               if (distanceBox) {
                   distanceBox.style.display = 'block';
               }
           }, 300);
       }
   });
}

function startHunt() {
    gameLocations = locations.sort((a, b) => a.id - b.id);
    currentLocationIndex = 0;
    locationTriggerState.cooldowns.clear();
    lastVisitedLocationId = null;
    loadAllLocations();
    startIdleProximityCheck(); 
}

function getMarkerColor(tours) {
    if (!tours) return '#0f2bab';
    
    switch (tours.toLowerCase()) {
        case 'person':
            return '#FFA500';
        case 'gangster':
            return '#3f9b0b';
        case 'event':
            return '#8B0000';
        case 'place':
            return '#800080';
        default:
            return '#0f2bab';
    }
}

function showAppMessage(appName, redirectUrl) {
    const messageEl = document.createElement('div');
    messageEl.style.cssText = `
        position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
        background: #333; color: white; padding: 35px; border-radius: 12px;
        z-index: 5000; text-align: center; line-height: 1.4;
        max-width: 85vw; box-sizing: border-box;
    `;
    messageEl.innerHTML = `
        <div style="font-size: clamp(22px, 5vw, 30px); font-weight: 500;">
            Opening ${appName}...
        </div>
        <div style="font-size: clamp(18px, 4vw, 24px); margin-top: 15px; opacity: 0.9;">
            To return: Switch back to your browser app
        </div>
    `;
    
    document.body.appendChild(messageEl);
    
    setTimeout(() => {
        messageEl.remove();
        window.location.href = redirectUrl;
    }, 3000);
}

let markersCreated = false;
let activePopups = new Set();

function recenterOnUser() {
    if (userMarker && map) {
        map.setView(userMarker.getLatLng(), map.getZoom(), {
            animate: true,
            duration: 0.5
        });
    }
}

function createMarkersOnly() {
    if (!gameLocations || !Array.isArray(gameLocations) || gameLocations.length === 0) {
        console.warn("No game locations available");
        return;
    }
    
    if (markerClusterGroup) {
        markerClusterGroup.clearLayers();
    }
    
    activePopups.clear();
    
    gameLocations.forEach((location) => {
        if (!location || typeof location.lat !== 'number' || typeof location.lng !== 'number') {
            console.warn("Invalid location data:", location);
            return;
        }
        const markerColor = getMarkerColor(location.tours);
        
        location.markerColor = markerColor;
        
        const locationMarker = L.marker([location.lat, location.lng], {
            icon: L.divIcon({
            className: 'custom-pin-icon',
            html: `<div class="pin-head" style="background-color: ${markerColor};"></div>`,
            iconSize: [30, 30],
            iconAnchor: [15, 30],
        }),
            riseOnHover: false,
            bubblingMouseEvents: false
    });
        
        const popupContent = `
            <div class="popup-content">
                <img loading="lazy" src="${location.image}" alt="${location.name}" class="location-image">
                <h4 class="location-name">
                    <a href="${location.link}" target="_blank" rel="noopener noreferrer" style="text-decoration: none; color: inherit;">${location.name}</a>
                </h4>
                <div class="popup-buttons">
                    <button class="button route-button" data-lat="${location.lat}" data-lng="${location.lng}" data-location-id="${location.id}">Directions</button>
                    <button class="button summary-button" data-location-id="${location.id}">Summary</button>
                </div>
            </div>
        `;
        locationMarker.bindPopup(popupContent, {
            offset: L.point(0, -25),
            className: 'custom-popup',
            maxWidth: 300,
            closeButton: true,
            autoClose: true,
            closeOnClick: true
        });
        
        locationMarker.on('popupopen', function(e) {
            activePopups.add(locationMarker);
            attachPopupEventListeners(e.popup._contentNode, location);
        });
        locationMarker.on('popupclose', function(e) {
            activePopups.delete(locationMarker);
        });
        markerClusterGroup.addLayer(locationMarker);
    });
    
    if (!map.hasLayer(markerClusterGroup)) {
        map.addLayer(markerClusterGroup);
    }
    
    markersCreated = true;
}

function attachPopupEventListeners(popupElement, location) {
    const routeButton = popupElement.querySelector('.route-button');
    const summaryButton = popupElement.querySelector('.summary-button');
    if (routeButton && !routeButton.hasAttribute('data-listener-attached')) {
        routeButton.setAttribute('data-listener-attached', 'true');
        routeButton.addEventListener('click', function(event) {
            event.preventDefault();
            event.stopPropagation();
            showNavigationModal(location.lat, location.lng);
        });
    }
    if (summaryButton && !summaryButton.hasAttribute('data-listener-attached')) {
        summaryButton.setAttribute('data-listener-attached', 'true');
        summaryButton.addEventListener('click', function(event) {
            event.preventDefault();
            event.stopPropagation();
            showLocationSummary(location.id);
        });
    }
}

function closeAllPopups() {
    activePopups.forEach(marker => {
        if (marker.isPopupOpen()) {
            marker.closePopup();
        }
    });
    activePopups.clear();
}

function showNavigationModal(destinationLat, destinationLng) {
    closeAllPopups();
    
    const existingModals = document.querySelectorAll('.modal');
    existingModals.forEach(modal => modal.remove());
    
    const modal = document.createElement("div");
    modal.className = "modal";
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
        opacity: 0;
        transition: opacity 0.3s ease;
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    `;
    
    modal.innerHTML = `
       <div class="modal-content" style="
           background-color: white;
           border-radius: 12px;
           padding: 20px;
           width: 90%;
           max-width: 400px;
           min-width: 280px;
           box-shadow: 0 10px 30px rgba(0,0,0,0.3);
           position: relative;
           transform: scale(0.9);
           transition: transform 0.3s ease;
           margin: 0;
           box-sizing: border-box;
       ">
           <h3 style="
               margin: 0 0 20px 0;
               text-align: center;
               color: #333;
               font-size: 1.2rem;
               font-weight: 600;
           ">Choose your preferred navigation app:</h3>
           <div class="modal-buttons" style="
               display: flex;
               flex-direction: column;
               align-items: center;
               gap: 12px;
               width: 100%;
               text-align: center;
           ">
               <button class="modal-button google-maps" style="
                   padding: 14px 20px;
                   margin: 0;
                   border: none;
                   border-radius: 8px;
                   cursor: pointer;
                   font-size: 1rem;
                   font-weight: 600;
                   transition: all 0.2s ease;
                   background-color: #4285F4;
                   color: white;
                   width: 100%;
                   display: flex;
                   align-items: center;
                   justify-content: center;
                   gap: 8px;
                   box-sizing: border-box;
               ">
                   <i class="fab fa-google" style="font-size: 1.1rem;"></i>
                   <span class="btn-text">Google Maps</span>
                   <i class="fas fa-spinner fa-spin location-spinner" style="font-size: 1rem; display: none; margin-left: 8px;"></i>
               </button>
               <button class="modal-button waze" style="
                   padding: 14px 20px;
                   margin: 0;
                   border: none;
                   border-radius: 8px;
                   cursor: pointer;
                   font-size: 1rem;
                   font-weight: 600;
                   transition: all 0.2s ease;
                   background-color: #00D4FF;
                   color: white;
                   width: 100%;
                   display: flex;
                   align-items: center;
                   justify-content: center;
                   gap: 8px;
                   box-sizing: border-box;
               ">
                   <i class="fas fa-route" style="font-size: 1rem;"></i>
                   <span class="btn-text">Waze</span>
                   <i class="fas fa-spinner fa-spin location-spinner" style="font-size: 1rem; display: none; margin-left: 8px;"></i>
               </button>
               <button class="modal-button apple-maps" style="
                   padding: 14px 20px;
                   margin: 0;
                   border: none;
                   border-radius: 8px;
                   cursor: pointer;
                   font-size: 1rem;
                   font-weight: 600;
                   transition: all 0.2s ease;
                   background-color: #007AFF;
                   color: white;
                   width: 100%;
                   display: flex;
                   align-items: center;
                   justify-content: center;
                   gap: 8px;
                   box-sizing: border-box;
               ">
                   <i class="fab fa-apple" style="font-size: 1.1rem;"></i>
                   <span class="btn-text">Apple Maps</span>
                   <i class="fas fa-spinner fa-spin location-spinner" style="font-size: 1rem; display: none; margin-left: 8px;"></i>
               </button>
               <button class="modal-button cancel" style="
                   padding: 14px 20px;
                   margin: 8px 0 0 0;
                   border: 2px solid #ddd;
                   border-radius: 8px;
                   cursor: pointer;
                   font-size: 1rem;
                   font-weight: 600;
                   transition: all 0.2s ease;
                   background-color: white;
                   color: #666;
                   width: 100%;
                   box-sizing: border-box;
               ">Cancel</button>
           </div>
       </div>
   `;
   
   document.body.appendChild(modal);
   
   setTimeout(() => {
       modal.style.opacity = "1";
       modal.querySelector(".modal-content").style.transform = "scale(1)";
   }, 10);
   
   let userLat = null;
   let userLng = null;
   let locationAttempted = false;
   
   const getUserLocation = () => {
       if (locationAttempted) return Promise.resolve();
       locationAttempted = true;
       
       return new Promise((resolve) => {
           if (navigator.geolocation) {
               navigator.geolocation.getCurrentPosition(
                   (position) => {
                       userLat = position.coords.latitude;
                       userLng = position.coords.longitude;
                       resolve();
                   },
                   (error) => {
                       console.log("Location access denied or failed");
                       resolve();
                   },
                   {
                       timeout: 5000,
                       enableHighAccuracy: false
                   }
               );
           } else {
               resolve();
           }
       });
   };
   
   const closeModal = () => {
       modal.style.opacity = "0";
       modal.querySelector(".modal-content").style.transform = "scale(0.9)";
       setTimeout(() => {
           if (modal.parentNode) {
               modal.remove();
           }
       }, 300);
   };
   
   const showReminderModal = (navigationUrl) => {
       const reminderModal = document.createElement("div");
       reminderModal.className = "reminder-modal";
       reminderModal.style.cssText = `
           position: fixed;
           top: 0;
           left: 0;
           width: 100%;
           height: 100%;
           background-color: rgba(0, 0, 0, 0.7);
           backdrop-filter: blur(4px);
           display: flex;
           justify-content: center;
           align-items: center;
           z-index: 10001;
           opacity: 0;
           transition: opacity 0.3s ease;
       `;
       
       reminderModal.innerHTML = `
           <div class="reminder-content" style="
               background-color: white;
               border-radius: 16px;
               padding: 24px;
               width: 90%;
               max-width: 400px;
               min-width: 280px;
               box-shadow: 0 15px 40px rgba(0,0,0,0.2);
               text-align: center;
               transform: translateY(20px);
               transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
           ">
               <div style="
                   width: 60px;
                   height: 60px;
                   background-color: #2c5282;
                   border-radius: 50%;
                   display: flex;
                   align-items: center;
                   justify-content: center;
                   margin: 0 auto 20px;
               ">
                   <i class="fas fa-map-marker-alt" style="color: white; font-size: 24px;"></i>
               </div>
               <h3 style="
                   margin: 0 0 15px 0;
                   color: #2c3e50;
                   font-size: 1.3rem;
                   font-weight: 600;
               ">Navigation Reminder</h3>
               <p style="
                   margin: 0 0 25px 0;
                   color: #5c6c7c;
                   line-height: 1.5;
                   font-size: 1rem;
               ">Remember to return to this map when you arrive at your destination to continue exploring!</p>
               <button class="reminder-ok-btn" style="
                   padding: 12px 30px;
                   background-color: #2c5282;
                   color: white;
                   border: none;
                   border-radius: 10px;
                   cursor: pointer;
                   font-size: 1rem;
                   font-weight: 600;
                   transition: all 0.2s ease;
                   min-width: 120px;
               ">Got it!</button>
           </div>
       `;
       
       document.body.appendChild(reminderModal);
       
       setTimeout(() => {
           reminderModal.style.opacity = "1";
           reminderModal.querySelector(".reminder-content").style.transform = "translateY(0)";
       }, 10);
       
       const okBtn = reminderModal.querySelector(".reminder-ok-btn");
       okBtn.addEventListener("mouseover", function() {
           this.style.backgroundColor = "#0d2c6e";
       });
       okBtn.addEventListener("mouseout", function() {
           this.style.backgroundColor = "#2c5282";
       });
       
       const closeReminderAndNavigate = () => {
           reminderModal.style.opacity = "0";
           reminderModal.querySelector(".reminder-content").style.transform = "translateY(20px)";
           setTimeout(() => {
               if (reminderModal.parentNode) {
                   reminderModal.remove();
               }
               window.open(navigationUrl, '_blank');
           }, 300);
       };
       
       okBtn.addEventListener("click", closeReminderAndNavigate);
   };
   
   const handleNavigation = async (button, appType) => {
       const spinner = button.querySelector('.location-spinner');
       const btnText = button.querySelector('.btn-text');
       
       spinner.style.display = 'inline-block';
       button.style.opacity = '0.8';
       button.style.cursor = 'wait';
       btnText.textContent = 'Getting location...';
       
       await getUserLocation();
       
       let navigationUrl;
       if (appType === 'google') {
           if (userLat && userLng) {
               navigationUrl = `https://www.google.com/maps/dir/${userLat},${userLng}/${destinationLat},${destinationLng}`;
           } else {
               navigationUrl = `https://www.google.com/maps/dir/?api=1&destination=${destinationLat},${destinationLng}`;
           }
       } else if (appType === 'waze') {
           if (userLat && userLng) {
               navigationUrl = `https://www.waze.com/ul?ll=${destinationLat}%2C${destinationLng}&navigate=yes&from=${userLat}%2C${userLng}`;
           } else {
               navigationUrl = `https://www.waze.com/ul?ll=${destinationLat}%2C${destinationLng}&navigate=yes`;
           }
       } else if (appType === 'apple') {
           const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
           if (!isIOS) {
               closeModal();
               showPopup('Info', 'Apple Maps is only available on iOS devices');
               return;
           }
           if (userLat && userLng) {
               navigationUrl = `maps://maps.apple.com/?saddr=${userLat},${userLng}&daddr=${destinationLat},${destinationLng}`;
           } else {
               navigationUrl = `maps://maps.apple.com/?daddr=${destinationLat},${destinationLng}`;
           }
       }
       
       closeModal();
       showReminderModal(navigationUrl);
   };
   
   const googleMapsBtn = modal.querySelector('.google-maps');
   const wazeBtn = modal.querySelector('.waze');
   const appleMapsBtn = modal.querySelector('.apple-maps');
   const cancelBtn = modal.querySelector('.cancel');
   
   getUserLocation();
   
   googleMapsBtn.addEventListener('mouseover', function() {
       if (this.style.cursor !== 'wait') {
           this.style.backgroundColor = '#3367D6';
           this.style.transform = 'translateY(-1px)';
       }
   });
   googleMapsBtn.addEventListener('mouseout', function() {
       if (this.style.cursor !== 'wait') {
           this.style.backgroundColor = '#4285F4';
           this.style.transform = 'translateY(0)';
       }
   });
   googleMapsBtn.addEventListener('click', () => handleNavigation(googleMapsBtn, 'google'));
   
   wazeBtn.addEventListener('mouseover', function() {
       if (this.style.cursor !== 'wait') {
           this.style.backgroundColor = '#00B8E6';
           this.style.transform = 'translateY(-1px)';
       }
   });
   wazeBtn.addEventListener('mouseout', function() {
       if (this.style.cursor !== 'wait') {
           this.style.backgroundColor = '#00D4FF';
           this.style.transform = 'translateY(0)';
       }
   });
   wazeBtn.addEventListener('click', () => handleNavigation(wazeBtn, 'waze'));
   
   appleMapsBtn.addEventListener('mouseover', function() {
       if (this.style.cursor !== 'wait') {
           this.style.backgroundColor = '#0056CC';
           this.style.transform = 'translateY(-1px)';
       }
   });
   appleMapsBtn.addEventListener('mouseout', function() {
       if (this.style.cursor !== 'wait') {
           this.style.backgroundColor = '#007AFF';
           this.style.transform = 'translateY(0)';
       }
   });
   appleMapsBtn.addEventListener('click', () => handleNavigation(appleMapsBtn, 'apple'));
   
   cancelBtn.addEventListener('mouseover', function() {
       this.style.backgroundColor = '#f5f5f5';
       this.style.borderColor = '#bbb';
   });
   cancelBtn.addEventListener('mouseout', function() {
       this.style.backgroundColor = 'white';
       this.style.borderColor = '#ddd';
   });
   cancelBtn.addEventListener('click', closeModal);
   
   modal.addEventListener('click', (e) => {
       if (e.target === modal) {
           closeModal();
       }
   });
}

function loadAllLocations() {
    if (!gameLocations || !Array.isArray(gameLocations) || gameLocations.length === 0) {
        console.error("No locations available to load");
        showPopup("Error", "No locations available. Please try reloading the page.");
        return;
    }
    
    createMarkersOnly();
    updateDistanceBox();
    resetInactivityTimer();
}

let visibilityTimeout;
document.addEventListener('visibilitychange', function() {
    if (!document.hidden) {
        if (visibilityTimeout) {
            clearTimeout(visibilityTimeout);
        }
        
        visibilityTimeout = setTimeout(() => {
            recenterOnUser();
            if (markerClusterGroup && markerClusterGroup.getLayers().length === 0) {
                createMarkersOnly();
            }
        }, 300);
    }
});

window.addEventListener('focus', function() {
    recenterOnUser();
});

function recenterMapAndClosePopups() {
    closeAllPopups();
    recenterOnUser();
}
 
function returnToIndex() {
   const distanceBox = document.querySelector('#distanceBox'); 
   if (distanceBox) {
       distanceBox.style.display = 'none';
   }
   
   // Function to detect if running as PWA
   function isPWA() {
       if (window.matchMedia('(display-mode: standalone)').matches) {
           return true;
       }
       if (window.navigator.standalone === true) {
           return true;
       }
       if (document.referrer.includes('android-app://')) {
           return true;
       }
       return false;
   }
   
   // Detect iOS
   function isIOS() {
       return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
   }
   
// PWA close function that handles iOS and Android properly
// PWA close function that handles iOS and Android properly
function closePWAApp() {
    // Navigate to the main website instead of showing a goodbye screen
    window.location.href = "https://www.mnthen.com";
}

const popupDiv = document.createElement("div");
popupDiv.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,0.6);
    backdrop-filter: blur(4px);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
    opacity: 0;
    transition: opacity 0.3s ease;
`;

const darkBlue = "var(--dark-blue)";
const darkBlueHover = "var(--dark-blue-hover)";

// Determine button text and modal content based on PWA status
const isRunningAsPWA = isPWA();
const exitButtonText = isRunningAsPWA ? "Yes, Exit" : "Yes, Exit";
const modalTitle = isRunningAsPWA ? "Close App?" : "Ready to Leave?";
const modalMessage = isRunningAsPWA ? 
    "Are you sure you want to close the app?" : 
    "Are you sure you want to return to the main page?";

popupDiv.innerHTML = `
    <div class="modal-container" style="
    background-color: white;
    border-radius: 16px;
    padding: 28px;
    width: 90%;
    max-width: 420px;
    max-height: 90vh;
    box-shadow: 0 15px 40px rgba(0,0,0,0.2);
    margin: auto;
    transform: translateY(20px);
    transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    overflow: hidden;
    display: flex;
    flex-direction: column;
    ">
    <div style="
        text-align: center;
        margin-bottom: 25px;
    ">
        <svg width="50" height="50" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <circle cx="12" cy="12" r="10" stroke="${darkBlue}" stroke-width="1.5"/>
        <path d="M12 8V13" stroke="${darkBlue}" stroke-width="2" stroke-linecap="round"/>
        <circle cx="12" cy="16" r="1" fill="${darkBlue}"/>
        </svg>
    </div>
    <h3 style="
        text-align: center;
        margin: 0 0 15px 0;
        color: #2c3e50;
        font-size: 1.5rem;
        font-weight: 600;
    ">${modalTitle}</h3>
    <div style="flex-grow: 1; overflow-y: auto; padding: 0 10px;">
        <p style="
        text-align: center;
        margin: 0 0 30px 0;
        color: #5c6c7c;
        line-height: 1.5;
        font-size: 1rem;
        ">${modalMessage}</p>
    </div>
    <div style="
        display: flex;
        justify-content: center;
        gap: 15px;
        margin-bottom: 15px;
    ">
        <button class="confirm-btn" style="
        padding: 14px 24px;
        background-color: ${darkBlue};
        color: white;
        border: none;
        border-radius: 10px;
        cursor: pointer;
        font-size: 1rem;
        font-weight: 600;
        min-width: 130px;
        transition: all 0.2s ease;
        ">${exitButtonText}</button>
        <button class="cancel-btn" style="
        padding: 14px 24px;
        background-color: transparent;
        color: ${darkBlue};
        border: 1.5px solid ${darkBlue};
        border-radius: 10px;
        cursor: pointer;
        font-size: 1rem;
        font-weight: 600;
        min-width: 130px;
        transition: all 0.2s ease;
        ">Stay Here</button>
    </div>
    <div style="text-align: center; margin-top: 15px;">
        <a href="#" class="credits-link" style="
        display: inline-block;
        text-align: center;
        color: #64748b;
        text-decoration: none;
        font-size: 0.9rem;
        padding: 8px 20px;
        border-radius: 100px;
        border: 1px solid rgba(100, 116, 139, 0.2);
        background-color: rgba(100, 116, 139, 0.05);
        transition: all 0.2s ease;
        ">View Acknowledgements</a>
    </div>
    </div>
`;

document.body.appendChild(popupDiv);

setTimeout(() => {
    popupDiv.style.opacity = "1";
    popupDiv.querySelector(".modal-container").style.transform = "translateY(0)";
}, 10);

const confirmBtn = popupDiv.querySelector(".confirm-btn");
confirmBtn.addEventListener("mouseover", function() {
    this.style.backgroundColor = darkBlueHover;
});
confirmBtn.addEventListener("mouseout", function() {
    this.style.backgroundColor = darkBlue;
});

const cancelBtn = popupDiv.querySelector(".cancel-btn");
cancelBtn.addEventListener("mouseover", function() {
    this.style.backgroundColor = "rgba(26, 58, 138, 0.05)";
});
cancelBtn.addEventListener("mouseout", function() {
    this.style.backgroundColor = "transparent";
});

const creditsLink = popupDiv.querySelector(".credits-link");
creditsLink.addEventListener("mouseover", function() {
    this.style.backgroundColor = "rgba(100, 116, 139, 0.1)";
    this.style.borderColor = "rgba(100, 116, 139, 0.3)";
});
creditsLink.addEventListener("mouseout", function() {
    this.style.backgroundColor = "rgba(100, 116, 139, 0.05)";
    this.style.borderColor = "rgba(100, 116, 139, 0.2)";
});

confirmBtn.addEventListener("click", function() {
    popupDiv.style.opacity = "0";
    popupDiv.querySelector(".modal-container").style.transform = "translateY(20px)";
    setTimeout(() => {
        document.body.removeChild(popupDiv);
        
        // Handle exit based on whether it's PWA or web browser
        if (isRunningAsPWA) {
            closePWAApp();
        } else {
            window.location.href = "/index.html";
        }
    }, 300);
});

cancelBtn.addEventListener("click", function() {
    popupDiv.style.opacity = "0";
    popupDiv.querySelector(".modal-container").style.transform = "translateY(20px)";
    setTimeout(() => {
        document.body.removeChild(popupDiv);
        if (typeof distanceBox !== 'undefined' && distanceBox) {
            distanceBox.style.display = 'block';
        }
    }, 300);
});

creditsLink.addEventListener("click", function(e) {
    e.preventDefault();
    
    const creditsPopup = document.createElement("div");
    creditsPopup.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0,0,0,0.7);
        backdrop-filter: blur(6px);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1001;
        opacity: 0;
        transition: opacity 0.3s ease;
    `;
    
    creditsPopup.innerHTML = `
        <div class="credits-container" style="
            background-color: white;
            border-radius: 16px;
            width: 92%;
            max-width: 450px;
            max-height: 80vh;
            box-shadow: 0 20px 50px rgba(0,0,0,0.25);
            margin: auto;
            transform: translateY(20px);
            transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        ">
            <div style="
                background-color: ${darkBlue};
                padding: 20px;
                color: white;
                text-align: center;
            ">
                <h3 style="margin: 0; font-size: 1.5rem; font-weight: 600;">Acknowledgements</h3>
            </div>
            <div style="
                padding: 20px;
                flex-grow: 1;
                overflow-y: auto;
            ">
                <ul style="list-style-type: none; padding: 0; margin: 0;">
                    <li style="margin-bottom: 20px;">
                        <strong style="color: #1e293b; font-size: 1.05rem;">OpenStreetMap</strong>
                        <p style="color: #64748b; margin: 5px 0 0 0; font-size: 0.9rem; line-height: 1.5;">
                            Providing the map data and tiles for this interactive experience.
                        </p>
                    </li>
                    <li style="margin-bottom: 20px;">
                        <strong style="color: #1e293b; font-size: 1.05rem;">Minnesota Historical Society</strong>
                        <p style="color: #64748b; margin: 5px 0 0 0; font-size: 0.9rem; line-height: 1.5;">
                            For their invaluable historical data, photographs, and archive materials.
                        </p>
                    </li>
                    <li style="margin-bottom: 20px;">
                        <strong style="color: #1e293b; font-size: 1.05rem;">Metropolitan State University</strong>
                        <p style="color: #64748b; margin: 5px 0 0 0; font-size: 0.9rem; line-height: 1.5;">
                            For fostering a passion for history and research methodology.
                        </p>
                    </li>
                    <li style="margin-bottom: 20px;">
                        <strong style="color: #1e293b; font-size: 1.05rem;">Leaflet.js</strong>
                        <p style="color: #64748b; margin: 5px 0 0 0; font-size: 0.9rem; line-height: 1.5;">
                            The open-source JavaScript library that powers the mapping features.
                        </p>
                    </li>
                    <li>
                        <strong style="color: #1e293b; font-size: 1.05rem;">All Contributors</strong>
                        <p style="color: #64748b; margin: 5px 0 0 0; font-size: 0.9rem; line-height: 1.5;">
                            Researchers, testers, and developers who made this project possible.
                        </p>
                    </li>
                </ul>
            </div>
            <div style="padding: 15px; text-align: center; border-top: 1px solid #eee;">
                <button class="close-credits-btn" style="
                    padding: 12px 30px;
                    background-color: ${darkBlue};
                    color: white;
                    border: none;
                    border-radius: 10px;
                    cursor: pointer;
                    font-size: 0.95rem;
                    font-weight: 600;
                    transition: background-color 0.2s ease;
                ">Close</button>
            </div>
        </div>
    `;
    
    document.body.appendChild(creditsPopup);
    
    setTimeout(() => {
        creditsPopup.style.opacity = "1";
        creditsPopup.querySelector(".credits-container").style.transform = "translateY(0)";
    }, 10);
    
    const closeBtn = creditsPopup.querySelector(".close-credits-btn");
    closeBtn.addEventListener("mouseover", function() {
        this.style.backgroundColor = darkBlueHover;
    });
    closeBtn.addEventListener("mouseout", function() {
        this.style.backgroundColor = darkBlue;
    });
    closeBtn.addEventListener("click", function() {
        creditsPopup.style.opacity = "0";
        creditsPopup.querySelector(".credits-container").style.transform = "translateY(20px)";
        setTimeout(() => {
            document.body.removeChild(creditsPopup);
        }, 300);
    });
    
    creditsPopup.addEventListener("click", function(e) {
        if (e.target === creditsPopup) {
            creditsPopup.style.opacity = "0";
            creditsPopup.querySelector(".credits-container").style.transform = "translateY(20px)";
            setTimeout(() => {
                document.body.removeChild(creditsPopup);
            }, 300);
        }
    });
});

popupDiv.addEventListener("click", function(e) {
    if (e.target === popupDiv) {
        popupDiv.style.opacity = "0";
        popupDiv.querySelector(".modal-container").style.transform = "translateY(20px)";
        setTimeout(() => {
            document.body.removeChild(popupDiv);
            if (typeof distanceBox !== 'undefined' && distanceBox) {
                distanceBox.style.display = 'block';
            }
        }, 300);
    }
});
    }
    
function isSignificantMovement(newPosition) {
    if (!lastPositionForJitter) {          // first fix
        lastPositionForJitter = newPosition;
        lastSignificantMovement = Date.now();
        return true;
    }

    const distance = calculateDistance(lastPositionForJitter, newPosition);
    const now = Date.now();
    const timeSince = now - lastSignificantMovement;

    if (
        (distance >= CONFIG.JITTER_THRESHOLD && timeSince >= CONFIG.SIGNIFICANT_MOVEMENT_COOLDOWN) ||
        distance >= CONFIG.JITTER_THRESHOLD * 5
    ) {
        lastPositionForJitter = newPosition;
        lastSignificantMovement = now;
        return true;
    }
    return false;
}

function resetInactivityTimer(isExplicitInteraction = true) {
    if (inactivityTimer) {
        clearTimeout(inactivityTimer);
        inactivityTimer = null;
    }
    
    inactivityTimer = setTimeout(() => {
        map.closePopup();
        if (!window.isMapInteracting && userMarker) {  
            window.followUser = true;                  
            
            const userPos = userMarker.getLatLng();
            if (userPos && userPos.lat && userPos.lng) {
                map.flyTo(userPos, map.getZoom(), {
                    animate: true,
                    duration: 1.0,
                    easeLinearity: 0.25
                });
            }
        }
    }, CONFIG.INACTIVITY_TIMEOUT);
    
    if (isExplicitInteraction) {
        window.isMapInteracting = false;  
    }
}

/* Optimize images */
function optimizeImages(root = document) {
  // Skip if root is invalid
  if (!root || !root.querySelectorAll) {
    console.warn('optimizeImages: Invalid root element provided');
    return;
  }

  try {
    const images = root.querySelectorAll('img:not([data-optimized])');
    
    images.forEach(img => {
      try {
        // Skip if already processed or in a template/shadow DOM
        if (img.hasAttribute('data-optimized') || 
            img.closest('template') || 
            img.getRootNode() instanceof ShadowRoot) {
          return;
        }

        const src = img.currentSrc || img.src;
        
        // Validate source
        if (!src || src.startsWith('data:') || src === 'about:blank') {
          img.setAttribute('data-optimized', 'no-valid-src');
          return;
        }

        // Check if already has proper dimensions
        const hasExplicitDimensions = img.hasAttribute('width') || img.hasAttribute('height');
        const hasNaturalDimensions = img.naturalWidth > 0 && img.naturalHeight > 0;
        
        if (hasExplicitDimensions || hasNaturalDimensions) {
          img.setAttribute('data-optimized', 'dimensions-exist');
          
          // Still apply lazy loading if not already set
          if (!img.hasAttribute('loading')) {
            img.loading = 'lazy';
          }
          return;
        }

        // Determine image type and optimization strategy
        const isSVG = src.includes('.svg') || img.src.includes('.svg') || img.type === 'image/svg+xml';
        const isCritical = img.hasAttribute('data-critical') || 
                          img.closest('[data-critical]') ||
                          img.classList.contains('critical-image');
        
        if (isSVG) {
          // SVGs don't need dimensions but should be lazy loaded if non-critical
          img.setAttribute('data-optimized', 'svg');
          if (!isCritical && !img.hasAttribute('loading')) {
            img.loading = 'lazy';
          }
          return;
        }

        // Mark as processing
        img.setAttribute('data-optimized', 'processing');

        // Apply lazy loading for non-critical images
        if (!isCritical && !img.hasAttribute('loading')) {
          img.loading = 'lazy';
        }

        // Function to set dimensions once image loads
        const setDimensions = () => {
          try {
            // Wait for natural dimensions to be available
            if (img.naturalWidth > 0 && img.naturalHeight > 0) {
              // Only set dimensions if they're not already set by CSS or attributes
              if (!img.hasAttribute('width') && !img.style.width) {
                img.setAttribute('width', img.naturalWidth);
              }
              if (!img.hasAttribute('height') && !img.style.height) {
                img.setAttribute('height', img.naturalHeight);
              }
              img.setAttribute('data-optimized', 'dimensions-set');
              
              // Add CSS to preserve aspect ratio
              if (!img.style.aspectRatio) {
                img.style.aspectRatio = `${img.naturalWidth} / ${img.naturalHeight}`;
              }
            } else {
              img.setAttribute('data-optimized', 'no-dimensions');
            }
          } catch (error) {
            img.setAttribute('data-optimized', 'dimension-error');
            console.warn('Error setting image dimensions:', error, img.src);
          }
        };

        // Check if image is already loaded
        if (img.complete) {
          if (img.naturalWidth > 0) {
            setDimensions();
          } else {
            // Broken image
            img.setAttribute('data-optimized', 'error-broken');
            img.setAttribute('width', '1');
            img.setAttribute('height', '1');
            img.style.visibility = 'hidden';
          }
          return;
        }

        // Set up load listeners
        const onLoad = () => {
          // Use decode() for better performance if available
          if (img.decode) {
            img.decode()
              .then(setDimensions)
              .catch(() => {
                // decode() failed, but image might still be loaded
                setDimensions();
              });
          } else {
            // Fallback for browsers without decode()
            requestAnimationFrame(() => {
              setTimeout(setDimensions, 0);
            });
          }
        };

        const onError = () => {
          img.setAttribute('data-optimized', 'error-load');
          // Set placeholder dimensions for broken images
          img.setAttribute('width', '1');
          img.setAttribute('height', '1');
          img.style.opacity = '0.5';
          
          // Clean up listeners
          img.removeEventListener('load', onLoad);
          img.removeEventListener('error', onError);
        };

        // Add event listeners (once)
        img.addEventListener('load', onLoad, { once: true });
        img.addEventListener('error', onError, { once: true });

        if (!img.complete && img.src && !img.src.startsWith('data:')) {
          const checkInterval = setInterval(() => {
            if (img.complete) {
              clearInterval(checkInterval);
              if (img.naturalWidth > 0) {
                setDimensions();
              }
            }
          }, 100);
          
          // Clean up after 5 seconds
          setTimeout(() => clearInterval(checkInterval), 5000);
        }

      } catch (imgError) {
        console.warn('Error optimizing image:', imgError, img?.src || 'unknown image');
        img?.setAttribute('data-optimized', 'processing-error');
      }
    });
    
  } catch (error) {
    console.error('Error in optimizeImages:', error);
  }
}

// MutationObserver to handle dynamically added images
function setupImageOptimizationObserver() {
  if (typeof MutationObserver === 'undefined') return;
  
  const observer = new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
        mutation.addedNodes.forEach(node => {
          if (node.nodeType === Node.ELEMENT_NODE) {
            if (node.tagName === 'IMG') {
              optimizeImages(node.parentElement);
            } else if (node.querySelectorAll) {
              optimizeImages(node);
            }
          }
        });
      }
    }
  });
  
  observer.observe(document.body, {
    childList: true,
    subtree: true
  });
  
  return observer;
}

// Initialize on DOM ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => {
    optimizeImages();
    setupImageOptimizationObserver();
  });
} else {
  optimizeImages();
  setupImageOptimizationObserver();
}

/* EVENT LISTENER SETUP */
function setupEventListeners() {
    // Enhanced state management with anti-jumping controls
    const interactionState = {
        followUser: true,
        isMapInteracting: false,
        inactivityTimer: null,
        touch: {
            startTime: 0,
            startPos: null,
            isMoving: false,
            isPinching: false,
            initialPinchDistance: 0,
            initialZoom: 0,
            // Anti-jumping additions
            lastUpdateTime: 0,
            velocityBuffer: [],
            smoothedPosition: null,
            jumpThreshold: 50 // pixels - sudden movement detection
        }
    };

    // Anti-jumping configuration
    const ANTI_JUMP_CONFIG = {
        MIN_DRAG_DISTANCE: 12,
        MAX_VELOCITY: 2000,        // pixels/second - filters impossible speeds
        VELOCITY_SAMPLES: 3,       // Number of velocity readings to average
        UPDATE_THROTTLE: 16,       // ~60fps max updates
        COORDINATE_SMOOTHING: 0.7, // Smoothing factor (0.5-0.9)
        PINCH_DEADZONE: 5,         // Minimum pinch distance change
        MOMENTUM_DECAY: 0.8        // iOS momentum scrolling decay
    };

    // Anti-jumping marker management
    const markerAntiJumpSystem = {
        // Store original marker positions during interaction
        originalMarkerPositions: new Map(),
        isInteractionActive: false,
        
        // Preserve marker positions before interaction
        preserveMarkerPositions: () => {
            if (userMarker) {
                const currentPos = userMarker.getLatLng();
                markerAntiJumpSystem.originalMarkerPositions.set('userMarker', {
                    lat: currentPos.lat,
                    lng: currentPos.lng
                });
            }
            
            // Add other markers if needed
            if (window.gameMarkers) {
                for (const [key, marker] of Object.entries(window.gameMarkers)) {
                    if (marker && marker.getLatLng) {
                        const pos = marker.getLatLng();
                        markerAntiJumpSystem.originalMarkerPositions.set(key, {
                            lat: pos.lat,
                            lng: pos.lng
                        });
                    }
                }
            }
        },
        
        // Restore marker positions after interaction
        restoreMarkerPositions: () => {
            // If GPS has moved the marker, don't snap it back.
            if (userMarker && markerAntiJumpSystem.originalMarkerPositions.has('userMarker')) {
                const originalPos = markerAntiJumpSystem.originalMarkerPositions.get('userMarker');
                const currentPos = userMarker.getLatLng();
                // Check if the current position matches the saved one (with a tiny tolerance)
                if (Math.abs(currentPos.lat - originalPos.lat) < 1e-6 && Math.abs(currentPos.lng - originalPos.lng) < 1e-6) {
                    userMarker.setLatLng([originalPos.lat, originalPos.lng], { animate: false });
                    console.debug("User marker restored to original position after interaction.");
                } else {
                    console.debug("User marker position changed during interaction, skipping restore.");
                }
            }

            // Apply same logic to other markers if needed
            if (window.gameMarkers) {
                for (const [key, marker] of Object.entries(window.gameMarkers)) {
                    if (marker && marker.getLatLng && markerAntiJumpSystem.originalMarkerPositions.has(key)) {
                        const originalPos = markerAntiJumpSystem.originalMarkerPositions.get(key);
                        const currentPos = marker.getLatLng();
                        if (Math.abs(currentPos.lat - originalPos.lat) < 1e-6 && Math.abs(currentPos.lng - originalPos.lng) < 1e-6) {
                            marker.setLatLng([originalPos.lat, originalPos.lng], { animate: false });
                        }
                    }
                }
            }

            markerAntiJumpSystem.originalMarkerPositions.clear();
        },
        
        // Handle interaction start
        startInteraction: () => {
            markerAntiJumpSystem.isInteractionActive = true;
            markerAntiJumpSystem.preserveMarkerPositions();
        },
        
        // Handle interaction end
        endInteraction: () => {
            markerAntiJumpSystem.isInteractionActive = false;
            markerAntiJumpSystem.restoreMarkerPositions(); 
        }
    };

    // Enhanced velocity and position tracking
    const trackTouchVelocity = (currentPos, timestamp) => {
        const state = interactionState.touch;
        
        if (state.smoothedPosition && timestamp > state.lastUpdateTime) {
            const deltaTime = timestamp - state.lastUpdateTime;
            const deltaX = currentPos.x - state.smoothedPosition.x;
            const deltaY = currentPos.y - state.smoothedPosition.y;
            const velocity = Math.sqrt(deltaX * deltaX + deltaY * deltaY) / deltaTime * 1000;
            
            // Add to velocity buffer
            state.velocityBuffer.push(velocity);
            if (state.velocityBuffer.length > ANTI_JUMP_CONFIG.VELOCITY_SAMPLES) {
                state.velocityBuffer.shift();
            }
            
            // Calculate average velocity
            const avgVelocity = state.velocityBuffer.reduce((a, b) => a + b, 0) / state.velocityBuffer.length;
            
            // Reject impossible velocities (likely GPS jumps)
            if (avgVelocity > ANTI_JUMP_CONFIG.MAX_VELOCITY) {
                console.debug('High velocity detected, smoothing movement:', avgVelocity);
                return false; 
            }
        }
        
        // Apply coordinate smoothing
        if (state.smoothedPosition) {
            const smoothing = ANTI_JUMP_CONFIG.COORDINATE_SMOOTHING;
            state.smoothedPosition = {
                x: state.smoothedPosition.x * smoothing + currentPos.x * (1 - smoothing),
                y: state.smoothedPosition.y * smoothing + currentPos.y * (1 - smoothing)
            };
        } else {
            state.smoothedPosition = { ...currentPos };
        }
        
        state.lastUpdateTime = timestamp;
        return true;
    };

const handleInteractionStart = (source) => {
    // Update GLOBAL state (what your tracking code actually uses)
    window.followUser = false;
    window.isMapInteracting = true;
    
    // Keep your existing logic if needed
    interactionState.followUser = false;
    interactionState.isMapInteracting = true;
    
    if (interactionState.inactivityTimer) {
        clearTimeout(interactionState.inactivityTimer);
        interactionState.inactivityTimer = null;
    }
    
    // Start marker protection
    markerAntiJumpSystem.startInteraction();
    
    console.debug(`Interaction started: ${source}`);
};

const handleInteractionEnd = (source) => {
    // Update GLOBAL state
    window.isMapInteracting = false;
    
    // Keep your existing logic if needed  
    interactionState.isMapInteracting = false;
    
    // End marker protection and restore positions
    markerAntiJumpSystem.endInteraction();
    
    // Reset anti-jumping state
    interactionState.touch.velocityBuffer = [];
    interactionState.touch.smoothedPosition = null;
    
    resetInactivityTimer();
    console.debug(`Interaction ended: ${source}`);
};

    // Enhanced map events with marker protection
    const setupMapEvents = () => {
        if (!map) {
            console.error('Map not available for event setup');
            return;
        }

        try {
            // Store original marker positions before interaction
            map.on('movestart', () => {
                if (!markerAntiJumpSystem.isInteractionActive) {
                    markerAntiJumpSystem.startInteraction();
                }
            });
            
            map.on('dragstart', () => handleInteractionStart('drag'));
            map.on('dragend', () => handleInteractionEnd('drag'));
            map.on('zoomstart', () => handleInteractionStart('zoom'));
            map.on('zoomend', () => handleInteractionEnd('zoom'));
            
            // Restore marker positions after interaction ends
            map.on('moveend', () => {
                if (!interactionState.isMapInteracting && markerAntiJumpSystem.isInteractionActive) {
                    markerAntiJumpSystem.endInteraction();
                }
            });
            
        } catch (error) {
            console.error('Error setting up map events:', error);
        }
    };

    // Enhanced touch events with maximum anti-jumping
    const setupTouchEvents = () => {
        let updateThrottle = null;

        const touchHandlers = {
            start: (e) => {
                try {
                    if (!e.touches || e.touches.length === 0) return;

                    const now = Date.now();
                    const touch = e.touches[0];
                    
                    if (e.touches.length === 1) {
                        // Single touch - reset anti-jumping state
                        interactionState.touch.startTime = now;
                        interactionState.touch.startPos = {
                            x: touch.clientX,
                            y: touch.clientY
                        };
                        interactionState.touch.isMoving = false;
                        interactionState.touch.velocityBuffer = [];
                        interactionState.touch.smoothedPosition = {
                            x: touch.clientX,
                            y: touch.clientY
                        };
                        interactionState.touch.lastUpdateTime = now;
                    } else if (e.touches.length === 2) {
                        // Pinch start
                        interactionState.touch.isPinching = true;
                        handleInteractionStart('pinch');
                        
                        const touch1 = e.touches[0];
                        const touch2 = e.touches[1];
                        
                        interactionState.touch.initialPinchDistance = Math.hypot(
                            touch2.clientX - touch1.clientX,
                            touch2.clientY - touch1.clientY
                        );
                        
                        if (map) {
                            interactionState.touch.initialZoom = map.getZoom();
                        }
                        
                        e.preventDefault();
                    }
                } catch (error) {
                    console.error('Touch start error:', error);
                }
            },

            move: (e) => {
                try {
                    if (!e.touches || e.touches.length === 0) return;

                    const now = Date.now();
                    
                    // Throttle updates to prevent overwhelming the system
                    if (updateThrottle && now - updateThrottle < ANTI_JUMP_CONFIG.UPDATE_THROTTLE) {
                        return;
                    }
                    updateThrottle = now;

                    if (e.touches.length === 1 && interactionState.touch.startPos) {
                        // Single touch move with anti-jumping
                        const touch = e.touches[0];
                        const currentPos = {
                            x: touch.clientX,
                            y: touch.clientY
                        };
                        
                        // Track velocity and smooth position
                        const validMovement = trackTouchVelocity(currentPos, now);
                        if (!validMovement) return;

                        // Use smoothed position for distance calculation
                        const smoothedPos = interactionState.touch.smoothedPosition;
                        const dx = smoothedPos.x - interactionState.touch.startPos.x;
                        const dy = smoothedPos.y - interactionState.touch.startPos.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        // Check for sudden jumps
                        const rawDx = currentPos.x - interactionState.touch.startPos.x;
                        const rawDy = currentPos.y - interactionState.touch.startPos.y;
                        const rawDistance = Math.sqrt(rawDx * rawDx + rawDy * rawDy);
                        
                        if (rawDistance > interactionState.touch.jumpThreshold && distance < ANTI_JUMP_CONFIG.MIN_DRAG_DISTANCE) {
                            console.debug('Touch jump detected and filtered');
                            return;
                        }
                        
                        if (distance > ANTI_JUMP_CONFIG.MIN_DRAG_DISTANCE && !interactionState.touch.isMoving) {
                            interactionState.touch.isMoving = true;
                            handleInteractionStart('touch-drag');
                        }
                    } else if (e.touches.length === 2 && interactionState.touch.isPinching) {
                        // Enhanced pinch zoom with deadzone
                        const touch1 = e.touches[0];
                        const touch2 = e.touches[1];
                        
                        const currentPinchDistance = Math.hypot(
                            touch2.clientX - touch1.clientX,
                            touch2.clientY - touch1.clientY
                        );
                        
                        // Apply deadzone to prevent micro-adjustments
                        const distanceChange = Math.abs(currentPinchDistance - interactionState.touch.initialPinchDistance);
                        if (distanceChange < ANTI_JUMP_CONFIG.PINCH_DEADZONE) {
                            return;
                        }
                        
                        if (map && interactionState.touch.initialPinchDistance > 0) {
                            const pinchRatio = currentPinchDistance / interactionState.touch.initialPinchDistance;
                            
                            // Limit pinch sensitivity to prevent jumping
                            const cappedRatio = Math.max(0.5, Math.min(2.0, pinchRatio));
                            const zoomDelta = Math.log2(cappedRatio) * 1.5; 
                            const newZoom = Math.max(7, Math.min(18, interactionState.touch.initialZoom + zoomDelta));
                            
                            try {
                                // Check if userMarker exists and has a valid position
                                if (window.userMarker && window.userMarker.getLatLng) { 
                                    const userMarkerLatLng = window.userMarker.getLatLng(); 
                                    // Use setView with the user's position as the center
                                    map.setView(userMarkerLatLng, newZoom, {
                                        animate: false // Keep animate false for direct pinch control
                                    });
                                } else {
                                    // If user marker isn't ready, zoom around current map center
                                    console.debug("User marker not available during pinch, zooming around map center");
                                    const currentCenter = map.getCenter();
                                    map.setView(currentCenter, newZoom, { animate: false });
                                }
                            } catch (mapError) {
                                console.debug('Map view update during pinch failed:', mapError);
                            }
                        }
                        
                        e.preventDefault();
                    }
                } catch (error) {
                    console.error('Touch move error:', error);
                }
            },

            end: (e) => {
                try {
                    const touchEndTime = Date.now();
                    const touchDuration = touchEndTime - interactionState.touch.startTime;
                    
                    if (interactionState.touch.isPinching) {
                        interactionState.touch.isPinching = false;
                        handleInteractionEnd('pinch');
                        
                        if (e.touches.length < 2) {
                            e.preventDefault();
                        }
                    } else if (interactionState.touch.startPos) {
                        // Apply momentum decay for iOS
                        if (ANTI_JUMP_CONFIG.MOMENTUM_DECAY < 1 && interactionState.touch.isMoving) {
                            setTimeout(() => {
                                if (interactionState.isMapInteracting) {
                                    handleInteractionEnd('touch-momentum');
                                }
                            }, 100);
                        }
                        
                        if (touchDuration >= 300 || interactionState.touch.isMoving) {
                            handleInteractionEnd('touch-drag');
                        }
                    }
                    
                    // Complete state reset
                    interactionState.touch.startPos = null;
                    interactionState.touch.isMoving = false;
                    interactionState.touch.velocityBuffer = [];
                    interactionState.touch.smoothedPosition = null;
                    updateThrottle = null;
                } catch (error) {
                    console.error('Touch end error:', error);
                }
            }
        };

        // Listeners with enhanced error handling
        try {
            document.addEventListener('touchstart', touchHandlers.start, { passive: false });
            document.addEventListener('touchmove', touchHandlers.move, { passive: false });
            document.addEventListener('touchend', touchHandlers.end, { passive: false });
            
            // Additional jump prevention for problematic devices
            document.addEventListener('touchcancel', touchHandlers.end, { passive: false });
        } catch (error) {
            console.error('Error setting up touch events:', error);
        }
    };

    const setupButtonEvents = () => {
        const buttonConfigs = [
            { id: 'recenterButton', handler: recenterMap, required: true },
            { id: 'returnButton', handler: returnToIndex, required: true },
            { id: 'tipsButton', handler: showNavigationTips, required: false }
        ];

        buttonConfigs.forEach(config => {
            try {
                const element = document.getElementById(config.id);
                if (element) {
                    element.addEventListener('click', config.handler);
                    console.debug(`${config.id} event listener attached`);
                } else if (config.required) {
                    console.error(`Required button element not found: ${config.id}`);
                } else {
                    console.warn(`Optional button element not found: ${config.id}`);
                }
            } catch (error) {
                console.error(`Error setting up ${config.id} event:`, error);
            }
        });
    };

    const setupAccessibilityEvents = () => {
        try {
            const contrastToggle = cachedElements?.contrastToggle;
            if (contrastToggle && typeof toggleHighContrast === 'function') {
                contrastToggle.addEventListener('click', toggleHighContrast);
                
                if (typeof accessibilityState !== 'undefined' && accessibilityState.highContrast) {
                    document.body.classList.add('high-contrast');
                }
                
                console.debug('Accessibility events setup complete');
            } else {
                console.warn('Contrast toggle or handler not available');
            }
        } catch (error) {
            console.error('Error setting up accessibility events:', error);
        }
    };

    const setupSystemEvents = () => {
        try {
            document.addEventListener('visibilitychange', () => {
                try {
                    if (typeof handleVisibilityChange === 'function') {
                        handleVisibilityChange();
                    }
                } catch (error) {
                    console.error('Visibility change handler error:', error);
                }
            });

            let resizeTimeout;
            window.addEventListener('resize', () => {
                try {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => {
                        if (map) {
                            map.invalidateSize();
                        }
                        if (typeof updateDistanceBox === 'function') {
                            updateDistanceBox();
                        }
                    }, 250);
                } catch (error) {
                    console.error('Resize handler error:', error);
                }
            });

            console.debug('System events setup complete');
        } catch (error) {
            console.error('Error setting up system events:', error);
        }
    };

    try {
        setupMapEvents();
        setupTouchEvents(); 
        setupButtonEvents();
        setupAccessibilityEvents();
        setupSystemEvents();
        
        console.log('All event listeners setup complete with anti-jumping protection (marker restore conditional, pinch center fixed)');
    } catch (error) {
        console.error('Critical error in setupEventListeners:', error);
    }
}

document.addEventListener('DOMContentLoaded', () => {
    console.log('DOM loaded, initializing application...');
    
    const initSteps = [
        { name: 'Cache Elements', fn: () => cacheElements() },
        { name: 'Initialize Map', fn: () => initMap() },
        { name: 'Setup Event Listeners', fn: () => setupEventListeners() },
        { name: 'Optimize Images', fn: () => optimizeImages() },
        { name: 'Initialize UI', fn: () => initializeUI() }
    ];

    let successCount = 0;
    
    initSteps.forEach((step, index) => {
        try {
            if (typeof step.fn === 'function') {
                step.fn();
                successCount++;
                console.debug(`✓ ${step.name} completed`);
            } else {
                console.warn(`⚠ ${step.name} function not available`);
            }
        } catch (error) {
            console.error(`✗ ${step.name} failed:`, error);
        }
    });

    console.log(`Application initialization: ${successCount}/${initSteps.length} steps completed`);
});

/* Initialize UI elements that should start hidden. */
function initializeUI() {
  try {
    const additionalInfoContainer = cachedElements?.additionalInfoContainer;
    if (additionalInfoContainer) {
      additionalInfoContainer.style.display = 'none';
    }
    
    // ----- Lochunt Container -----
    const lochuntContainer = cachedElements?.lochuntContainer;
    if (lochuntContainer) {
      lochuntContainer.style.display = 'none';
    }
    
    console.debug('UI initialization complete');
  } catch (error) {
    console.error('UI initialization error:', error);
  }
}
    </script>
</body>
</html>
