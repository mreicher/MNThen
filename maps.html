<!doctype html>
<html lang="en-US">
<head>
    <!-- Primary Meta Tags -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, minimum-scale=1.0, user-scalable=yes">
    <title>Minnesota Then | Museum Without Walls</title>
    <meta name="description" content="Visit an interactive museum without walls where history lights up around you with GPS-triggered archival photos and audio. Every step tells a story.">
    <meta name="keywords" content="Minnesota living history, Museum Without Walls, location-based stories, GPS-triggered archives, onsite museum experience, interactive Minnesota heritage, historical photos, place-based audio history">
    
    <!-- Favicon & PWA -->
    <link rel="icon" type="image/x-icon" href="https://www.mnthen.com/images/mnthenfav.ico">
    <link rel="manifest" href="/manifest.json">
    <meta name="theme-color" content="#2c5282">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Minnesota Then">

    <!-- Security Headers -->
    <meta http-equiv="X-Content-Type-Options" content="nosniff">
    <meta http-equiv="X-XSS-Protection" content="1; mode=block">
    <meta http-equiv="Referrer-Policy" content="strict-origin-when-cross-origin">
    <meta http-equiv="Permissions-Policy" content="geolocation=(self), camera=(), microphone=(), payment=(), usb=()">
    <meta http-equiv="Cross-Origin-Embedder-Policy" content="unsafe-none">
    <meta http-equiv="Cross-Origin-Opener-Policy" content="same-origin">
    <meta name="referrer" content="strict-origin-when-cross-origin">
    <meta name="color-scheme" content="light">
    
      <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://www.mnthen.com/">
    <meta property="og:title" content="Minnesota Then | Museum Without Walls">
    <meta property="og:description" content="Visit an interactive museum without walls where history lights up around you with GPS-triggered archival photos and audio. Every step tells a story.">
    <meta property="og:image" content="https://mnthen.com/images/index/index_1.jpg">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    
    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@MinnesotaThen">
    <meta name="twitter:title" content="Minnesota Then | Museum Without Walls">
    <meta name="twitter:description" content="Visit an interactive museum without walls where history lights up around you with GPS-triggered archival photos and audio. Every step tells a story.">
    <meta name="twitter:image" content="https://mnthen.com/images/index/index_1.jpg">
    
    <!-- Canonical URL -->
    <link rel="canonical" href="https://www.mnthen.com/">

    <!-- Performance Optimization -->
    <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
    <link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
    <link rel="preconnect" href="https://unpkg.com" crossorigin>
    <link rel="preconnect" href="https://www.mnthen.com" crossorigin>
    <link rel="dns-prefetch" href="//tile.openstreetmap.org">
    <link rel="dns-prefetch" href="//fonts.googleapis.com">
    <link rel="dns-prefetch" href="//fonts.gstatic.com">

    <!-- Critical CSS (render-blocking) -->
    <link rel="stylesheet" href="https://www.mnthen.com/css/mainmap.css">
    <link rel="stylesheet" href="https://www.mnthen.com/css/mnthen_main_map2.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" crossorigin>

    <!-- Non-critical CSS (deferred) -->
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css" as="style" onload="this.rel='stylesheet'">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.css" as="style" onload="this.rel='stylesheet'">
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" as="style" onload="this.rel='stylesheet'">
    <link rel="preload" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css" as="style" onload="this.rel='stylesheet'">
    <link rel="preload" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css" as="style" onload="this.rel='stylesheet'">
    
    <noscript>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.css">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css">
        <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css">
        <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css">
    </noscript>

    <!-- JSON-LD Structured Data -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@graph": [
        {
          "@type": "WebApplication",
          "name": "Minnesota Then",
          "alternateName": "Minnesota Then Enterprise GIS",
          "url": "https://www.mnthen.com",
          "description": "Enterprise-grade historical GIS platform for Minnesota with advanced spatial analysis and offline capabilities.",
          "applicationCategory": ["ProductivityApplication", "EducationApplication"],
          "operatingSystem": "Web",
          "browserRequirements": "Requires JavaScript. Compatible with modern browsers.",
          "softwareVersion": "2.0",
          "datePublished": "2024-01-01",
          "dateModified": "2025-07-05",
          "inLanguage": "en-US",
          "isAccessibleForFree": true,
          "offers": {
            "@type": "Offer",
            "price": "0",
            "priceCurrency": "USD",
            "availability": "https://schema.org/InStock"
          },
          "creator": {
            "@type": "Organization",
            "name": "Minnesota Then",
            "url": "https://www.mnthen.com"
          },
          "featureList": [
            "Interactive historical maps",
            "Location-based tours",
            "Offline map capabilities",
            "Spatial analysis tools",
            "Historical content exploration"
          ],
          "screenshot": "https://www.mnthen.com/images/social-share.jpg",
          "aggregateRating": {
            "@type": "AggregateRating",
            "ratingValue": "4.8",
            "ratingCount": "150"
          }
        },
        {
          "@type": "TouristDestination",
          "name": "Minnesota Historical Sites",
          "description": "Explore historical locations across Minnesota with enterprise GIS capabilities",
          "geo": {
            "@type": "GeoCoordinates",
            "latitude": "46.7296",
            "longitude": "-94.6859"
          },
          "containedInPlace": {
            "@type": "State",
            "name": "Minnesota",
            "addressCountry": "US"
          },
          "touristType": [
            "History enthusiasts",
            "Educational groups",
            "Cultural tourists"
          ],
          "availableLanguage": "en-US"
        },
        {
          "@type": "Organization",
          "name": "Minnesota Then",
          "url": "https://www.mnthen.com",
          "logo": "https://www.mnthen.com/images/mnthenfav.ico",
          "sameAs": [
            "https://twitter.com/MinnesotaThen"
          ],
          "foundingDate": "2024",
          "description": "Digital platform preserving and sharing Minnesota's historical heritage through interactive mapping technology.",
          "knowsAbout": [
            "Minnesota History",
            "Historical GIS",
            "Digital Heritage",
            "Interactive Maps"
          ]
        }
      ]
    }
    </script>

<style>
/* Hide the entire document until every stylesheet & font is ready. */
html {
  visibility: hidden !important;
}
html.unlock {
  visibility: visible !important;
}

/*  DESIGN TOKENS*/
:root {
  --primary-color:       #0066cc;
  --hover-color:         #e6f0ff;
  --dark-blue:           #1a3a8a;
  --dark-blue-hover:     #0d2c6e;
  --success-color:       #28a745;
  --warning-color:       #ffc107;
  --error-color:         #dc3545;
}

/* RESET & GLOBAL HELPERS*/
*,
*::before,
*::after { box-sizing: border-box; }

body {
  margin: 0;
  padding: 0;
  font-family: Inter, system-ui, Avenir, Helvetica, Arial, sans-serif;
  background-color: #f8f9fa;
}

/* MAP CANVAS*/
#map {
  position: fixed;
  top: 0;
  left: 0;
  z-index: 1;
  width: 100vw;
  height: 100vh;       /* fallback */
  height: 100dvh;      /* modern dynamic viewport */
  touch-action: none;
  -webkit-user-select: none;
  user-select: none;
  will-change: transform;
}

/* iOS 100vh fix */
@supports (-webkit-touch-callout: none) {
  #map,
  .lochunt-container {
    height: -webkit-fill-available;
  }
}

/* dvh fallback */
@supports not (height: 100dvh) {
  #map { height: 100vh; }
}

/* COMPONENTS*/

/* 4.1 Distance indicator */
#distanceBox {
  position: fixed;
  top: 20px;
  right: 20px;
  z-index: 1003;
  background: white;
  padding: 12px 24px;
  border-radius: 50px;
  font-weight: 600;
  font-size: 20px;
  text-align: center;
  min-width: 200px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
  border: 3px solid var(--dark-blue);
  transition: all 0.3s ease;
  opacity: 0;           /* hidden until hydrated */
  visibility: hidden;
}

#distanceBox.show {
  opacity: 1;
  visibility: visible;
}

#distanceBox.proximity-close {
  background: linear-gradient(135deg, #28a745, #20c997);
  color: white;
  animation: pulse 1.5s infinite;
}

#distanceBox.proximity-medium {
  background: linear-gradient(135deg, #ffc107, #fd7e14);
  color: white;
}

#distanceBox.proximity-far {
  background: white;
  color: var(--dark-blue);
  border-color: var(--dark-blue);
}

/* 4.2 Map action buttons */
.map-buttons {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  display: flex;
  justify-content: space-evenly;
  align-items: center;
  gap: 0.5rem;
  margin-bottom: 30px;
}

/* PWA Install Banner */
#pwaInstallBanner {
    position: fixed;
    bottom: 20px;
    right: 20px;
    left: 20px;
    background: white;
    border-radius: 12px;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15), 0 0 0 1px rgba(0, 0, 0, 0.05);
    padding: 20px;
    z-index: 2000;
    display: none;
    animation: slideUp 0.4s cubic-bezier(0.16, 1, 0.3, 1) forwards;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
    border: 1px solid #e2e8f0;
}

@keyframes slideUp {
    from {
        transform: translateY(100px);
        opacity: 0;
    }
    to {
        transform: translateY(0);
        opacity: 1;
    }
}

#pwaInstallBanner.show {
    display: block;
}

#pwaInstallBanner .banner-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: 15px;
}

#pwaInstallBanner .banner-title {
    display: flex;
    align-items: center;
    gap: 12px;
}

#pwaInstallBanner .app-icon {
    width: 40px;
    height: 40px;
    border-radius: 10px;
    background-color: #2c5282;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-size: 20px;
    flex-shrink: 0;
}

#pwaInstallBanner h3 {
    margin: 0;
    color: #2d3748;
    font-size: 18px;
    font-weight: 600;
}

#pwaInstallBanner .close-btn {
    background: #f7fafc;
    border: none;
    width: 32px;
    height: 32px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    color: #718096;
    font-size: 20px;
    transition: all 0.2s ease;
    flex-shrink: 0;
}

#pwaInstallBanner .close-btn:hover {
    background: #edf2f7;
    color: #4a5568;
}

#pwaInstallBanner .banner-content {
    margin-bottom: 20px;
}

#pwaInstallBanner .banner-content p {
    margin: 0;
    color: #4a5568;
    line-height: 1.5;
    font-size: 15px;
}

#pwaInstallBanner .banner-actions {
    display: flex;
    justify-content: flex-end;
    gap: 12px;
}

#pwaInstallBanner .cancel-btn {
    background: transparent;
    border: 1px solid #e2e8f0;
    border-radius: 8px;
    padding: 10px 18px;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    color: #718096;
    transition: all 0.2s ease;
}

#pwaInstallBanner .cancel-btn:hover {
    background: #f7fafc;
    border-color: #cbd5e0;
}

#pwaInstallBanner .install-btn {
    background: #2c5282;
    color: white;
    border: none;
    border-radius: 8px;
    padding: 10px 22px;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    position: relative;
    overflow: hidden;
}

#pwaInstallBanner .install-btn::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
    transition: left 0.7s ease;
}

#pwaInstallBanner .install-btn:hover {
    background: #1a3a8a;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
    transform: translateY(-1px);
}

#pwaInstallBanner .install-btn:hover::before {
    left: 100%;
}

#pwaInstallBanner .install-btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

/* Responsive adjustments */
@media (max-width: 640px) {
    #pwaInstallBanner {
        right: 15px;
        left: 15px;
        bottom: 15px;
        padding: 18px;
    }
    
    #pwaInstallBanner h3 {
        font-size: 16px;
    }
    
    #pwaInstallBanner .banner-content p {
        font-size: 14px;
    }
    
    #pwaInstallBanner .banner-actions {
        flex-direction: column-reverse;
        gap: 10px;
    }
    
    #pwaInstallBanner .cancel-btn,
    #pwaInstallBanner .install-btn {
        width: 100%;
        text-align: center;
        padding: 12px;
    }
}

/* 4.3 Markers */
.user-marker-icon {
  width: 22px;
  height: 22px;
  background: radial-gradient(circle, #dc3545 0%, #a71e2a 70%);
  border: 3px solid white;
  border-radius: 50%;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
  transition: all 0.3s ease;
}

.user-marker-icon.moving {
  animation: pulse 2s infinite;
}

.marker-cluster-custom {
  background: rgba(44, 82, 130, 0.9);
  border-radius: 50%;
  color: white;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 600;
}

.marker-cluster-custom div {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
}

#accuracyIndicator {
    position: absolute;
    top: 10px;
    left: 10px;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    border: 2px solid rgba(255, 255, 255, 0.8);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    z-index: 1000;
    transition: background-color 0.3s ease;
}

/* hide the accuracy indicator on narrow screens */
@media (max-width: 360px) {
  #accuracyIndicator {
    display: none;
  }
}
    
/* ANIMATIONS */
@keyframes pulse {
  0%, 100% { opacity: 0.8; }
  50% { opacity: 1; }
}

@keyframes gradientShift {
  0% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes fadeOut {
  from { opacity: 1; }
  to { opacity: 0; }
}

.fade-in { animation: fadeIn 0.3s ease forwards; }
.fade-out { animation: fadeOut 0.3s ease forwards; }

/* UTILITIES */
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border: 0;
}

@media (prefers-reduced-motion: reduce) {
    .user-marker-icon, .map-button {
        transition: none !important;
        animation: none !important;
    }
}

/* RESPONSIVE LOADING MESSAGE */
@media (max-width: 500px) {
  #loadingMessage > div {
    width: 85% !important;
    height: auto !important;
    min-height: 480px !important;
    padding: 25px 20px !important;
  }
}
</style>

<script>
/* FOUC-buster 60-fps safe + MutationObserver bailout */
(function () {
  if (window.foucBusterActive) return; // only run once
  window.foucBusterActive = true;

  let unlocked = false;

  /* unlock once and only once */
  function unlock () {
    if (unlocked) return;
    unlocked = true;

    document.documentElement.classList.add('unlock');

    /* screen-reader â€œreadyâ€ ping */
    const ann = document.createElement('div');
    ann.setAttribute('aria-live', 'polite');
    ann.style.cssText = 'position:absolute;left:-10000px;width:1px;height:1px;overflow:hidden;';
    ann.textContent = 'Application loaded';
    document.body?.appendChild(ann);
    setTimeout(() => ann.remove(), 1000);

    /* custom event for other scripts */
    try {
      window.dispatchEvent(new CustomEvent('foucUnlocked', { detail: { ts: Date.now() } }));
    } catch (_) {
      const e = document.createEvent('CustomEvent');
      e.initCustomEvent('foucUnlocked', false, false, { ts: Date.now() });
      window.dispatchEvent(e);
    }
  }

  /* lightweight CSS-variable check */
  function cssReady () {
    const d = document.createElement('div');
    d.style.cssText = 'color:var(--primary-color);position:absolute;visibility:hidden';
    document.body.appendChild(d);
    const ok = window.getComputedStyle(d).color !== 'var(--primary-color)';
    d.remove();
    return ok;
  }

  /* wait for fonts if API exists, else resolve immediately */
  function fontsReady () {
    return document.fonts ? document.fonts.ready.catch(() => {}) : Promise.resolve();
  }

  /* single async path */
  function check () {
    Promise.all([cssReady(), fontsReady()])
      .then(() => requestAnimationFrame(unlock));
  }

  /* fast path when DOM is already ready */
  if (document.readyState === 'complete' || (document.readyState === 'interactive' && document.body)) {
    check();
  } else {
    document.addEventListener('DOMContentLoaded', check, { once: true });
  }

  /* ultimate safety net */
  window.addEventListener('load', () => setTimeout(unlock, 16), { once: true });

  /* user-interaction bailout */
  ['click', 'touchstart', 'keydown'].forEach(evt =>
    document.addEventListener(evt, () => unlock(), { once: true, passive: true })
  );

  /* ðŸ”¥ One-shot MutationObserver: unlock if body appears and has content before styles load */
  if (!document.body) {
    const observer = new MutationObserver(() => {
      // Stop observing immediately after first mutation
      observer.disconnect();

      // Only unlock if body exists and has visible/significant content
      if (document.body && document.body.children.length > 0) {
        // Don't wait for CSS/fonts if user is already seeing content
        requestAnimationFrame(unlock);
      }
    });

    observer.observe(document.documentElement, {
      childList: true,
      subtree: true
    });
  }
})();
</script>
</head>
    
<body>
     <noscript>
          <div style="padding:2rem;text-align:center;font-family:sans-serif">
            <h2>JavaScript Required</h2>
            <p>This map requires JavaScript to function. Please enable it in your browser.</p>
          </div>
    </noscript>
    
    <!-- Map container -->
    <div id="map"></div>

    <!-- GPS accuracy indicator, red, yellow, green -->
    <div id="accuracyIndicator"></div>
    
    <!-- Enhanced Distance Box with Dark Blue Border -->
    <div id="distanceBox">Initializing...</div>

    <!-- Location Hunt Container -->
    <div class="lochunt-container">
        <img id="locationImage" src="" alt="Location Image">
        <div class="lochunt-content">
            <div class="lochunt-info">
                <h2 id="locationTitle" class="mb-2 text-primary"></h2>
                <p id="locationCity" class="text-muted mb-1"></p>
                <p id="locationCreator" class="text-muted mb-3"></p>
            </div>
            <div class="audio-player">
                <div class="audio-progress">
                    <div class="progress">
                        <div id="progressBar" class="progress-bar" role="progressbar" style="width: 0%"></div>
                    </div>
                </div>
                <div class="audio-time">
                    <span id="currentTime">0:00</span>
                    <span id="duration">0:00</span>
                </div>
                <div class="audio-controls">
                    <button id="rewindBtn" class="audio-button" aria-label="Rewind 10 seconds"><i class="fas fa-backward"></i></button>
                    <button id="playPauseBtn" class="audio-button" aria-label="Play"><i class="fas fa-play"></i></button>
                    <button id="forwardBtn" class="audio-button" aria-label="Forward 10 seconds"><i class="fas fa-forward"></i></button>
                </div>
                <audio id="locationAudio" preload="auto" crossorigin="anonymous"></audio>
            </div>
        </div>
    </div>

    <!-- Additional Info Container -->
    <div class="additional-info-container">
        <h3 class="mb-3 text-primary text-center">Did You Know?</h3>
        <p id="additionalInfo" class="mb-3 fs-6"></p>
        <div class="d-flex justify-content-center">
            <button id="continueButton" class="btn btn-primary">Continue</button>
        </div>
    </div>
    
    <!-- Map Buttons -->
    <div class="map-buttons">
        <button id="recenterButton" class="map-button" aria-label="Recenter map"><i class="fas fa-crosshairs"></i></button>
        <button id="returnButton" class="map-button" aria-label="Return to main page"><i class="fas fa-sign-out-alt"></i></button>
        <button id="tipsButton" class="map-button" aria-label="Show navigation tips"><i class="fas fa-question-circle"></i></button>
    </div>

    <!-- Summary Modal -->
    <div id="summaryModal" class="modal" style="display: none;">
        <div class="modal-content">
            <p id="summaryContent"></p>
        </div>
    </div>

    <!-- PWA Install Banner -->
 <div id="pwaInstallBanner">
    <div class="banner-header">
        <div class="banner-title">
            <div class="app-icon">
                <i class="fas fa-map-marked-alt"></i>
            </div>
            <h3>Install Minnesota Then</h3>
        </div>
        <button class="close-btn" id="closePwaBanner">&times;</button>
    </div>
    <div class="banner-content">
        <p>Add our app to your home screen for instant loading and full immersion, right where it happened.</p>
    </div>
    <div class="banner-actions">
        <button class="cancel-btn" id="cancelPwaBanner">Not Now</button>
        <button class="install-btn" id="installPwaButton">Install App</button>
    </div>
</div> 

    <!-- Load scripts with defer to improve page load performance -->
    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js" defer></script>
    <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js" defer></script>
    <script src="/locations_main.js?v=1.0.4" defer></script>

    <script>
/* Service-worker registration */
(function setupEnterpriseSW() {
  let updateInterval;
  const msgHandler = e => {
    if (e.data?.type === 'SW_ACTIVATED')
      console.log('Enterprise Service Worker activated, version:', e.data.version);
  };

const onLoad = () => {
  if (!navigator.serviceWorker) return;

  navigator.serviceWorker.register('/sw.js')
    .then(reg => {
      console.log('Enterprise SW registered:', reg);
      navigator.serviceWorker.addEventListener('message', msgHandler);

      // Handle initial updatefound (e.g., on page load)
      if (reg.installing || reg.waiting) {
        // If there's already a new SW installing/waiting, tell it to skip waiting
        const newWorker = reg.installing || reg.waiting;
        newWorker.postMessage({ type: 'SKIP_WAITING' });
      }

      // Listen for future updates
      reg.addEventListener('updatefound', () => {
        const newWorker = reg.installing;
        if (!newWorker) return;

        console.log('New SW installing...');

        // Optional: listen for state changes
        newWorker.addEventListener('statechange', () => {
          if (newWorker.state === 'installed') {
            // It's now waiting â€” but we already told it to skip waiting!
            // If for some reason we didn't, you could send it here too:
            // newWorker.postMessage({ type: 'SKIP_WAITING' });
          }
        });

        // ðŸ‘‰ Tell the NEW worker to skip waiting
        newWorker.postMessage({ type: 'SKIP_WAITING' });
      });

      // Poll for updates hourly
      updateInterval = setInterval(() => {
        reg.update().catch(err => {
          console.warn('SW update check failed:', err);
        });
      }, 60 * 60 * 1000);
    })
    .catch(err => console.log('SW registration failed:', err));
};

  const onUnload = () => {
    if (updateInterval) clearInterval(updateInterval);
    navigator.serviceWorker?.removeEventListener('message', msgHandler);
  };

  window.addEventListener('load', onLoad, { once: true });
  window.addEventListener('beforeunload', onUnload);

  window.teardownEnterpriseSW = onUnload;
})();

// EnterpriseCacheManager â€“ optimized
class EnterpriseCacheManager {
  constructor() {
    this.cachePrefix = 'mnthen-enterprise-';
    this.maxCacheSize = 50 * 1024 * 1024;
    this.maxCacheAge = 7 * 24 * 60 * 60 * 1000;
    this.proximityThreshold = 1000;
  }

  async init() {
    await this.cleanupExpiredCache();
    this.startPeriodicCleanup();
  }

  async cacheLocationData(location, userPosition) {
    if (!userPosition || !location || !location.id) return;
    
    const distanceFeet = calculateDistance(userPosition, location) * 3.28084;
    if (distanceFeet <= this.proximityThreshold) {
      try {
        const data = JSON.stringify({ 
          location, 
          timestamp: Date.now(), 
          userPosition, 
          distance: distanceFeet 
        });
        const key = `${this.cachePrefix}location_${location.id}`;
        const encryptedData = await this.encryptData(data);
        
        // Check storage quota before saving
        try {
          localStorage.setItem(key, encryptedData);
          console.log(`Cached location ${location.name || location.id} (${distanceFeet.toFixed(0)} feet away)`);
        } catch (storageError) {
          if (storageError.name === 'QuotaExceededError') {
            await this.cleanupOldestEntries();
            localStorage.setItem(key, encryptedData);
          } else {
            throw storageError;
          }
        }
      } catch (e) { 
        console.warn('Failed to cache location data:', e); 
      }
    }
  }

  async encryptData(data) {
    if (!window.crypto?.subtle) return btoa(data);
    
    try {
      const encoder = new TextEncoder();
      const dataBuffer = encoder.encode(data);
      const iv = crypto.getRandomValues(new Uint8Array(12));
      
      // Use a fixed key instead of generating new ones each time
      const key = await this.getEncryptionKey();
      const encrypted = await crypto.subtle.encrypt(
        { name: 'AES-GCM', iv }, 
        key, 
        dataBuffer
      );
      
      // Combine IV and encrypted data
      const result = new Uint8Array(iv.length + encrypted.byteLength);
      result.set(iv, 0);
      result.set(new Uint8Array(encrypted), iv.length);
      
      return btoa(String.fromCharCode(...result));
    } catch { 
      return btoa(data); // fallback
    }
  }

  async getEncryptionKey() {
    // Create or retrieve a persistent key
    if (!this.encryptionKey) {
      const keyData = await this.getOrCreateKeyData();
      this.encryptionKey = await crypto.subtle.importKey(
        'raw',
        keyData,
        { name: 'AES-GCM' },
        false,
        ['encrypt', 'decrypt']
      );
    }
    return this.encryptionKey;
  }

  async getOrCreateKeyData() {
    const keyKey = `${this.cachePrefix}crypto-key`;
    const storedKey = localStorage.getItem(keyKey);
    
    if (storedKey) {
      return new Uint8Array(atob(storedKey).split('').map(c => c.charCodeAt(0)));
    }
    
    // Generate new key and store it
    const newKey = crypto.getRandomValues(new Uint8Array(32)); // 256-bit key
    localStorage.setItem(keyKey, btoa(String.fromCharCode(...newKey)));
    return newKey;
  }

  async cleanupExpiredCache() {
    const now = Date.now();
    const toRemove = [];
    
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key?.startsWith(this.cachePrefix) && !key.includes('crypto-key')) {
        try {
          const item = localStorage.getItem(key);
          const decrypted = await this.decryptData(item);
          const parsed = JSON.parse(decrypted);
          
          if (now - parsed.timestamp > this.maxCacheAge) {
            toRemove.push(key);
          }
        } catch {
          toRemove.push(key); // Remove malformed entries
        }
      }
    }
    
    toRemove.forEach(key => localStorage.removeItem(key));
    if (toRemove.length) {
      console.log(`Cleaned up ${toRemove.length} expired cache entries`);
    }
  }

  async decryptData(encryptedData) {
    if (!window.crypto?.subtle) return atob(encryptedData);
    
    try {
      const data = new Uint8Array(atob(encryptedData).split('').map(c => c.charCodeAt(0)));
      const iv = data.slice(0, 12);
      const encrypted = data.slice(12);
      
      const key = await this.getEncryptionKey();
      const decrypted = await crypto.subtle.decrypt(
        { name: 'AES-GCM', iv },
        key,
        encrypted
      );
      
      return new TextDecoder().decode(decrypted);
    } catch {
      return atob(encryptedData); // fallback
    }
  }

  async cleanupOldestEntries() {
    const entries = [];
    
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key?.startsWith(this.cachePrefix) && !key.includes('crypto-key')) {
        try {
          const item = localStorage.getItem(key);
          const decrypted = await this.decryptData(item);
          const parsed = JSON.parse(decrypted);
          entries.push({ key, timestamp: parsed.timestamp });
        } catch {
          entries.push({ key, timestamp: 0 }); // Remove malformed
        }
      }
    }
    
    // Sort by timestamp and remove oldest 20%
    entries.sort((a, b) => a.timestamp - b.timestamp);
    const removeCount = Math.ceil(entries.length * 0.2);
    
    for (let i = 0; i < removeCount; i++) {
      localStorage.removeItem(entries[i].key);
    }
  }

  startPeriodicCleanup() {
    setInterval(() => this.cleanupExpiredCache(), 60 * 60 * 1000);
  }
}

// EnterpriseSecurityManager - simplified but effective
class EnterpriseSecurityManager {
  constructor() {
    this.sessionToken = this.generateSecureToken();
    this.auditLog = []; // In-memory log, limited size
    this.cspViolations = []; // In-memory log, limited size
    this.persistedLogKey = 'securityAuditLog'; // Example key if persisting
  }

  generateSecureToken() {
    return Array.from(crypto.getRandomValues(new Uint8Array(16)), b =>
      b.toString(16).padStart(2, '0')
    ).join('');
  }

  // Modified to remove userAgent
  logSecurityEvent(event, details) {
    const entry = {
      timestamp: new Date().toISOString(),
      event,
      details,
      sessionToken: this.sessionToken, // Local to session, less PII concern
      // userAgent: navigator.userAgent, // Removed: Potential PII under GDPR
      url: location.href // Consider if this is necessary or could contain user data
    };

    this.auditLog.push(entry);
    console.log('Security Event:', entry);

    // Optional: Persist the log if needed for later analysis/download
    // if (typeof localStorage !== 'undefined') {
    //   try {
    //     let persistedLog = JSON.parse(localStorage.getItem(this.persistedLogKey)) || [];
    //     persistedLog.push(entry);
    //     if (persistedLog.length > 100) persistedLog.shift(); // Maintain limit
    //     localStorage.setItem(this.persistedLogKey, JSON.stringify(persistedLog));
    //   } catch (e) {
    //     console.warn('Failed to persist security log:', e);
    //   }
    // }

    if (this.auditLog.length > 100) this.auditLog.shift(); // Maintain in-memory limit
  }

  monitorCSPViolations() {
    document.addEventListener('securitypolicyviolation', e => {
      this.cspViolations.push({
        timestamp: new Date().toISOString(),
        violatedDirective: e.violatedDirective,
        blockedURI: e.blockedURI,
        documentURI: e.documentURI
      });
      this.logSecurityEvent('CSP_VIOLATION', {
        directive: e.violatedDirective,
        uri: e.blockedURI
      });
    });
  }

  init() {
    this.monitorCSPViolations();
    this.logSecurityEvent('SESSION_START', { timestamp: Date.now() });
  }

  // Get the current in-memory log for download (or combine with persisted log if applicable)
  getAuditLog() {
    // If persisting, combine in-memory and persisted logs
    // const persistedLog = JSON.parse(localStorage.getItem(this.persistedLogKey)) || [];
    // return [...persistedLog, ...this.auditLog];
    return [...this.auditLog]; // Return a copy of the in-memory log
  }

  // Clear the in-memory log (and persisted log if applicable) for "Forget me"
  clearAuditLog() {
    this.auditLog = [];
    this.cspViolations = [];
    // If persisting:
    // localStorage.removeItem(this.persistedLogKey);
    console.log('Security audit log cleared.');
  }

  // Get CSP violations for download
  getCSPViolations() {
    return [...this.cspViolations]; // Return a copy
  }

  // Clear CSP violations log for "Forget me"
  clearCSPViolations() {
    this.cspViolations = [];
    console.log('CSP violations log cleared.');
  }

  // Combined "Forget me" for security logs
  forgetUser() {
    this.clearAuditLog();
    this.clearCSPViolations();
    // Note: sessionToken is per-session anyway, so it naturally expires.
  }
}

// EnterprisePerformanceMonitor - more efficient
class EnterprisePerformanceMonitor {
  constructor() {
    this.metrics = {
      fps: 0,
      memory: 0,
      loadedLocations: 0,
      cacheHits: 0,
      networkRequests: 0
    };
    this.frameCount = 0;
    this.lastTime = performance.now();
    this.lastFps = 0;
    this.lastMem = 0;
  }

  startMonitoring() {
    this.monitorFPS();
    this.monitorMemory();
    setInterval(() => this.updateMetrics(), 1000);
  }

  monitorFPS() {
    const calculateFPS = (now) => {
      this.frameCount++;
      if (now - this.lastTime >= 1000) {
        this.metrics.fps = Math.round(this.frameCount * 1000 / (now - this.lastTime));
        this.frameCount = 0;
        this.lastTime = now;
      }
      requestAnimationFrame(calculateFPS);
    };
    requestAnimationFrame(calculateFPS);
  }

  monitorMemory() {
    if (performance.memory) {
      setInterval(() => {
        this.metrics.memory = Math.round(
          performance.memory.usedJSHeapSize / 1024 / 1024
        );
      }, 5000);
    }
  }

  updateMetrics() {
    if (window.gameLocations) {
      this.metrics.loadedLocations = window.gameLocations.length;
    }

    const { fps, memory } = this.metrics;

    // Only log warnings when performance degrades significantly
    if (fps < 30 && this.lastFps >= 30) {
      console.warn(`Performance Alert: FPS dropped to ${fps}`);
    }
    if (memory > 100 && this.lastMem <= 100) {
      console.warn(`Performance Alert: Memory usage ${memory}MB`);
    }

    this.lastFps = fps;
    this.lastMem = memory;
  }

  getMetrics() {
    return { ...this.metrics }; // Return copy to prevent external modification
  }
}

// EnterpriseBackgroundSync - simplified but robust
class EnterpriseBackgroundSync {
  constructor() {
    this.syncQueue = [];
    this.isOnline = navigator.onLine;
    this.processing = false;

    window.addEventListener('online', () => {
      this.isOnline = true;
      this.process();
    });
    window.addEventListener('offline', () => this.isOnline = false);
  }

  addToSyncQueue(data) {
    this.syncQueue.push({
      data,
      retries: 0,
      timestamp: Date.now()
    });
    if (this.isOnline) {
      queueMicrotask(() => this.process());
    }
  }

  async process() {
    if (this.processing || !this.isOnline) return;

    this.processing = true;

    while (this.syncQueue.length && this.isOnline) {
      const item = this.syncQueue.shift();

      try {
        // Simulate network request
        await new Promise(resolve => setTimeout(resolve, 100));
        console.log('Background sync completed for:', item.data.type);
      } catch (e) {
        item.retries++;
        if (item.retries < 3) {
          // Add back to queue with exponential backoff
          this.syncQueue.push(item);
        } else {
          console.warn('Background sync permanently failed:', e);
        }
      }
    }

    this.processing = false;
  }
}

const enterpriseCacheManager = new EnterpriseCacheManager();
const enterpriseSecurityManager = new EnterpriseSecurityManager();
const enterprisePerformanceMonitor = new EnterprisePerformanceMonitor();
const enterpriseBackgroundSync = new EnterpriseBackgroundSync();

document.addEventListener('DOMContentLoaded', () => {
    enterpriseCacheManager.init();
    enterpriseSecurityManager.init();
    enterprisePerformanceMonitor.startMonitoring();
});

const CONFIG = {
    DISTANCE_THRESHOLD: 25000, //feet
    EXTENDED_DISTANCE_THRESHOLD: 50, //meters
    MIN_DISTANCE_THRESHOLD: 2,
    PROXIMITY_THRESHOLD: 50,
    JITTER_THRESHOLD: 5,
    MICRO_MOVEMENT_THRESHOLD: 0.3,
    BACKGROUND_THRESHOLD: 25000,
    INACTIVITY_TIMEOUT: 29000,
    STATIONARY_TIME_THRESHOLD: 5000,
    STATIONARY_CHECK_INTERVAL: 2500,
    SIGNIFICANT_MOVEMENT_COOLDOWN: 2000,
    RETRY_DELAY: 1000,
    ZOOM_COOLDOWN: 5000,
    MAX_BUFFER_SIZE: 5,
    MAX_ACCEPTABLE_ACCURACY: 39,
    MAX_SPEED: 80,
    VELOCITY_DECAY: 0.85,
    STATIONARY_THRESHOLD: 2,
    MAX_ALPHA: 0.25,
    MIN_ALPHA: 0.02,
    MAX_RETRIES: 3,
    SPEED_ZOOM_THRESHOLDS: [
        { speed: 65, zoom: 14 },
        { speed: 50, zoom: 15 },
        { speed: 35, zoom: 16 },
        { speed: 0, zoom: 17 }
    ],
    BEARING_TOLERANCE: 30,
    DWELL_TIME: 100,
};

let map, userMarker, markerClusterGroup;
let tracking;
let currentLocationIndex = 0;
let visitedLocations = [];
let gameLocations = [];
let isLocationHuntVisible = false;
let lastFunctionCall = 0; 
let filteredPosition = null;
let lastVisitedLocationId = null;
let lastKnownPosition = null;
let isTransitioning = false;
let stationaryBuffer = [];
let stationaryPosition = null;
let stationaryCount = 0;
let lastSmoothedPosition = null;
let lastHiddenTime = 0;
let retryCount = 0;
let inactivityTimer;
let loadingMessageMinDisplayTime = 0;
let lastCenteringTime = 0;
let lastZoomChangeTime = 0;
let isNearLocation = false;
let lastMapUpdateTime = 0;
let lastVisitTime = 0;
let lastSignificantMovement = Date.now();
let lastPositionForJitter = null;

// GLOBAL STATE (used in updateUserLocation)
window.followUser = true;
window.isMapInteracting = false;
window.lastPosition = null;
window.positionBuffer = [];
window.lastVelocity = { lat: 0, lng: 0 };
window.isStationary = false;
window.stationaryStartTime = null;
window.stationaryCheckTimeout = null;
window.lastUpdateTime = null;
window.animationFrameId = null;
window._didPrefetch18 = false; 

let enhancedTrackingState = {
    velocity: { lat: 0, lng: 0 },
    acceleration: { lat: 0, lng: 0 },
    lastVelocityUpdate: 0,
    speedMPS: 0,
    heading: null,
    isMoving: false,
    stationaryStartTime: null
};

let zoomState = {
    currentTier: 'exploration',
    lastTierChange: 0,
    hysteresisBuffer: [],
    proximityOverride: false
};

let locationTriggerState = {
    cooldowns: new Map(),
    dwellTimers: new Map(),
    lastBearing: null,
    approachingLocations: new Set(),
    lastVibrations: new Map()
};

let accessibilityState = {
    highContrast: localStorage.getItem('highContrast') === 'true',
    lastAnnouncement: '',
    proximityAlerts: new Set()
};

let cachedElements = {};

function cacheElements() {
    cachedElements = {
        distanceBox: document.getElementById('distanceBox'),
        recenterButton: document.getElementById('recenterButton'),
        returnButton: document.getElementById('returnButton'),
        tipsButton: document.getElementById('tipsButton'),
        lochuntContainer: document.querySelector('.lochunt-container'),
        additionalInfoContainer: document.querySelector('.additional-info-container'),
        accessibilityAnnouncements: document.getElementById('accessibility-announcements'),
        proximityAnnouncements: document.getElementById('proximity-announcements'),
        contrastToggle: document.getElementById('contrastToggle')
    };
}

function announceToScreenReader(message, priority = 'polite') {
    const element = priority === 'assertive' ? 
        cachedElements.proximityAnnouncements : 
        cachedElements.accessibilityAnnouncements;
    
    if (element && message !== accessibilityState.lastAnnouncement) {
        element.textContent = message;
        accessibilityState.lastAnnouncement = message;
        
        setTimeout(() => {
            if (element.textContent === message) {
                element.textContent = '';
            }
        }, 1000);
    }
}

function toggleHighContrast() {
    accessibilityState.highContrast = !accessibilityState.highContrast;
    localStorage.setItem('highContrast', accessibilityState.highContrast);
    
    if (accessibilityState.highContrast) {
        document.body.classList.add('high-contrast');
        announceToScreenReader('High contrast mode enabled');
    } else {
        document.body.classList.remove('high-contrast');
        announceToScreenReader('High contrast mode disabled');
    }
}

function triggerHapticFeedback(pattern = [100]) {
    if ('vibrate' in navigator) {
        navigator.vibrate(pattern);
    }
}

function calculateBearing(from, to) {
    const lat1 = from.lat * Math.PI / 180;
    const lat2 = to.lat * Math.PI / 180;
    const deltaLng = (to.lng - from.lng) * Math.PI / 180;
    
    const y = Math.sin(deltaLng) * Math.cos(lat2);
    const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(deltaLng);
    
    const bearing = Math.atan2(y, x) * 180 / Math.PI;
    return (bearing + 360) % 360;
}

function isApproachingLocation(userPos, userBearing, locationPos) {
    // Always trigger within the distance threshold - you're at the location
    const distanceInFeet = calculateDistance(userPos, locationPos) * 3.28084; // Convert to feet
    if (distanceInFeet <= CONFIG.DISTANCE_THRESHOLD) return true;
    
    // If we don't have bearing data, be permissive
    if (!userBearing) return true;
    
    const bearingToLocation = calculateBearing(userPos, locationPos);
    const bearingDiff = Math.abs(userBearing - bearingToLocation);
    const normalizedDiff = Math.min(bearingDiff, 360 - bearingDiff);
    
    return normalizedDiff <= CONFIG.BEARING_TOLERANCE;
}

const trackedTimeouts = new Set();

function createTrackedTimeout(callback, delay) {
    const id = setTimeout(() => {
        trackedTimeouts.delete(id);
        callback();
    }, delay);
    trackedTimeouts.add(id);
    return id;
}

function isValidPosition(pos) {
    return pos && 
           typeof pos.lat === 'number' && 
           typeof pos.lng === 'number' && 
           !isNaN(pos.lat) && 
           !isNaN(pos.lng);
}

function setupMemoryManagement({
    markerClusterGroup      = window.markerClusterGroup,
    animationFrameId        = window.animationFrameId,
    stationaryCheckTimeout  = window.stationaryCheckTimeout,
    inactivityTimer         = window.inactivityTimer,
    positionWatchId         = window.positionWatchId,
    gameLocations           = window.gameLocations,
    positionBuffer          = window.positionBuffer,
    stationaryBuffer        = window.stationaryBuffer,
    visitedLocations        = window.visitedLocations,
    locationTriggerState    = window.locationTriggerState,
    accessibilityState      = window.accessibilityState,
    activePopups            = window.activePopups,
    lastVelocity            = window.lastVelocity,
    lastSmoothedPosition    = window.lastSmoothedPosition,
    stationaryCount         = window.stationaryCount,
} = {}) {

    const cleanupTasks  = [];
    const trackedTimers = new Set();
    const eventListeners = [];

    /* safe timer helpers  */
    const createTrackedTimeout = (cb, delay, ...args) => {
        const id = setTimeout(() => {
            trackedTimers.delete(id);
            cb(...args);
        }, delay);
        trackedTimers.add(id);
        return id;
    };
    const createTrackedInterval = (cb, interval) => {
        const id = setInterval(cb, interval);
        trackedTimers.add(id);
        return id;
    };

    /* safe event helper */
    const trackEventListener = (el, ev, h, opts) => {
        el.addEventListener(ev, h, opts);
        eventListeners.push({ element: el, event: ev, handler: h, options: opts });
    };

    /* core cleanup routines */
    const cleanupAudioResources = () => {
        try {
            document.querySelectorAll('audio').forEach(audio => {
                audio.pause();
                audio.src = '';
                audio.load();
                audio.remove();
            });
        } catch (e) {
            console.warn('Audio cleanup failed:', e);
        }
    };

    const cleanupMapResources = () => {
        try {
            if (markerClusterGroup) markerClusterGroup.clearLayers();
            if (window.animationFrameId !== null && window.animationFrameId !== undefined) {
                cancelAnimationFrame(window.animationFrameId);
                window.animationFrameId = null;
            }
            if (window.stationaryCheckTimeout) {
                clearTimeout(window.stationaryCheckTimeout);
                window.stationaryCheckTimeout = null;
            }
            if (window.inactivityTimer) {
                clearTimeout(window.inactivityTimer);
                window.inactivityTimer = null;
            }
            trackedTimers.forEach(id => { 
                clearTimeout(id); 
                clearInterval(id); 
            });
            trackedTimers.clear();
            if (window.positionWatchId !== undefined && window.positionWatchId !== null) {
                navigator.geolocation.clearWatch(window.positionWatchId);
                window.positionWatchId = null;
            }
        } catch (e) {
            console.warn('Map resource cleanup failed:', e);
        }
    };

    const cleanupDOMAndData = () => {
        try {
            // DOM cleanup
            document.querySelectorAll('.popup-overlay, .modal, .navigation-tips-overlay, .source-info-content')
                    .forEach(el => el.remove());

            // Event listeners cleanup
            eventListeners.forEach(({ element, event, handler, options }) => {
                try {
                    element.removeEventListener(event, handler, options);
                } catch (e) {
                    console.warn('Failed to remove event listener:', e);
                }
            });
            eventListeners.length = 0;

            // Array cleanup - check if they exist and are arrays
            if (Array.isArray(window.gameLocations)) {
                window.gameLocations.length = 0;
            }
            if (Array.isArray(window.positionBuffer)) {
                window.positionBuffer.length = 0;
            }
            if (Array.isArray(window.stationaryBuffer)) {
                window.stationaryBuffer.length = 0;
            }
            if (Array.isArray(window.visitedLocations)) {
                window.visitedLocations.length = 0;
            }

            // Map/Set cleanup - check if they exist and have the clear method
            if (window.locationTriggerState) {
                if (window.locationTriggerState.cooldowns?.clear) {
                    window.locationTriggerState.cooldowns.clear();
                }
                if (window.locationTriggerState.dwellTimers?.clear) {
                    window.locationTriggerState.dwellTimers.clear();
                }
                if (window.locationTriggerState.approachingLocations?.clear) {
                    window.locationTriggerState.approachingLocations.clear();
                }
                if (window.locationTriggerState.lastVibrations?.clear) {
                    window.locationTriggerState.lastVibrations.clear();
                }
            }
            
            if (window.accessibilityState?.proximityAlerts?.clear) {
                window.accessibilityState.proximityAlerts.clear();
            }
            
            if (window.activePopups?.clear) {
                window.activePopups.clear();
            }

            // Scalar cleanup
            if (window.lastVelocity && typeof window.lastVelocity === 'object') {
                Object.keys(window.lastVelocity).forEach(k => window.lastVelocity[k] = 0);
            }
            window.lastSmoothedPosition = null;
            window.stationaryCount = 0;
            
        } catch (e) {
            console.warn('DOM and data cleanup failed:', e);
        }
    };

    /* register built-in tasks */
    const registerCleanupTask = (t) => { cleanupTasks.push(t); };
    registerCleanupTask(cleanupAudioResources);
    registerCleanupTask(cleanupMapResources);
    registerCleanupTask(cleanupDOMAndData);

    /* execute */
    const executeCleanup = () => cleanupTasks.forEach(t => {
        try { 
            t(); 
        } catch (e) { 
            console.error('Cleanup task failed:', e); 
        }
    });

    /* page-level listeners */
    const onVisibility = () => { 
        if (document.hidden) cleanupAudioResources(); 
    };
    const onBeforeUnload = () => executeCleanup();

    trackEventListener(document, 'visibilitychange', onVisibility);
    trackEventListener(window, 'beforeunload', onBeforeUnload);

    /* expose */
    window.performCleanup = executeCleanup;

    /* optional full shutdown */
    const shutdown = () => {
        executeCleanup();
        document.removeEventListener('visibilitychange', onVisibility);
        window.removeEventListener('beforeunload', onBeforeUnload);
        cleanupTasks.length = 0;
        trackedTimers.clear();
        eventListeners.length = 0;
        delete window.performCleanup;
    };

    return {
        registerCleanupTask,
        executeCleanup,
        createTrackedTimeout,
        createTrackedInterval,
        trackEventListener,
        shutdown,
    };
}

/* usage */
const memoryManager = setupMemoryManagement({});

function initMap() {
    ['lastKnownPos', 'routeHistory', 'userPrefs'].forEach(k => {
        try { localStorage.removeItem(k); sessionStorage.removeItem(k); } catch (_) {}
    });
    
    if ('caches' in window) {
        caches.keys()
            .then(keys => Promise.all(keys.map(k => caches.delete(k))))
            .catch(() => {});
    }
    
    map = L.map('map', {
        zoomControl: false,
        attributionControl: false,
        zoomSnap: 0.1,
        zoomDelta: 0.5,
        wheelDebounceTime: 100,
        tapTolerance: 15,
        bounceAtZoomLimits: false,
        preferCanvas: true,
        renderer: L.canvas(),
        fadeAnimation: false,
        zoomAnimationThreshold: 4,
        markerZoomAnimation: false
    }).setView([46.392410, -94.636230], 9);
    
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        minZoom: 7,
        maxZoom: 18,
        attribution: '',
        updateWhenIdle: true,
        updateWhenZooming: false,
        keepBuffer: 2,
        className: 'map-tiles'
    }).addTo(map);
    
    markerClusterGroup = L.markerClusterGroup({
        showCoverageOnHover: false,
        zoomToBoundsOnClick: true,
        spiderfyOnMaxZoom: true,
        animate: false,
        chunkedLoading: true,
        chunkProgress: updateLoadingStatus,
        maxClusterRadius: z => z > 16 ? 40 : 80,
        iconCreateFunction: c => L.divIcon({
            html: `<div><span>${c.getChildCount()}</span></div>`,
            className: 'marker-cluster-custom',
            iconSize: [40, 40]
        })
    }).addTo(map);
    
    userMarker = L.marker([0, 0], {
        icon: L.divIcon({
            className: 'user-marker',
            html: '<div class="user-marker-icon"></div>',
            iconSize: [20, 20],
            iconAnchor: [10, 10]
        }),
        zIndexOffset: 1000
    }).addTo(map);
    
    const keepMarkerSynced = () => {
        if (lastPosition) {
            userMarker.setLatLng([lastPosition.lat, lastPosition.lng], { animate: false });
        }
        requestAnimationFrame(keepMarkerSynced);
    };
    requestAnimationFrame(keepMarkerSynced);
    
    showLoadingMessage();
    if ('geolocation' in navigator) {
        const opts = { enableHighAccuracy: true, timeout: 45000, maximumAge: 0 };
        navigator.geolocation.getCurrentPosition(
            initializeUserLocation,
            () => navigator.geolocation.getCurrentPosition(initializeUserLocation, handleLocationError, opts),
            opts
        );
    } else {
        showPopup('Geolocation Error', 'Geolocation is not supported');
        map.flyTo([44.9778, -93.2650], 17);
        hideLoadingMessage();
    }
}

let _idleProximityCheckInterval;

function startIdleProximityCheck() {
  if (_idleProximityCheckInterval) {
    console.log("Idle proximity check is already running.");
    return; // Already running
  }

  _idleProximityCheckInterval = setInterval(() => {
    try {
      // Only run if map and data are ready
      if (!window.map || !window.gameLocations?.length || !window.userMarker) {
          // console.log("Skipping idle check - map/data not ready yet.");
          return; // Not ready yet, skip this iteration
      }
      // console.log("Idle proximity check running.");
      // Trigger the existing proximity logic in updateDistanceBox
      // This will now use window.cooldownManager.checkCooldown internally.
      updateDistanceBox();
    } catch (err) {
      console.warn('Idle proximity check error:', err);
    }
  }, 10000); // Run every 10 seconds
  console.log("Idle proximity check started (every 10 seconds).");
}

function stopIdleProximityCheck() {
  if (_idleProximityCheckInterval) {
    clearInterval(_idleProximityCheckInterval);
    _idleProximityCheckInterval = null;
    console.log("Idle proximity check stopped.");
  }
}
        
function updateLoadingStatus(processed, total, elapsed) {
    if (processed === total) {
        console.log(`Loaded ${processed} markers in ${elapsed.toFixed(2)}ms`);
    }
}

// PWA Install Banner functionality
let deferredPrompt;
let pwaInstallBanner, closePwaBanner, cancelPwaBanner, installPwaButton;

// Detect device type
function getDeviceType() {
    const userAgent = navigator.userAgent || navigator.vendor || window.opera;
    
    if (/iPad|iPhone|iPod/.test(userAgent) && !window.MSStream) {
        return 'ios';
    } else if (/android/i.test(userAgent)) {
        return 'android';
    } else if (/Windows Phone/i.test(userAgent)) {
        return 'windows';
    }
    return 'desktop';
}

// Check if the app is running as a PWA
function isRunningAsPWA() {
    // Standard PWA detection
    if (window.matchMedia('(display-mode: standalone)').matches) {
        return true;
    }
    
    // iOS Safari standalone mode
    if (window.navigator.standalone === true) {
        return true;
    }
    
    // Android TWA (Trusted Web Activity)
    if (document.referrer.includes('android-app://')) {
        return true;
    }
    
    // Check for PWA-specific URL parameters
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.get('utm_source') === 'pwa' || urlParams.get('source') === 'pwa') {
        return true;
    }
    
    return false;
}

// Check if the app can be installed
function canInstallPWA() {
    const deviceType = getDeviceType();
    
    // Android: Check for beforeinstallprompt support or Chrome
    if (deviceType === 'android') {
        return 'beforeinstallprompt' in window || /Chrome/.test(navigator.userAgent);
    }
    
    // iOS: Check for Safari and iOS version
    if (deviceType === 'ios') {
        const isIOS13OrLater = /OS 1[3-9]_|OS [2-9][0-9]_/.test(navigator.userAgent);
        const isSafari = /Safari/.test(navigator.userAgent) && !/CriOS|FxiOS|EdgiOS/.test(navigator.userAgent);
        return isIOS13OrLater && isSafari;
    }
    
    // Desktop: Check for supported browsers
    if (deviceType === 'desktop') {
        return 'beforeinstallprompt' in window;
    }
    
    return false;
}

// Check if the app is already installed
async function isAppInstalled() {
    if (isRunningAsPWA()) {
        return true;
    }
    
    const deviceType = getDeviceType();
    
    // For newer browsers that support getInstalledRelatedApps
    if ('getInstalledRelatedApps' in navigator) {
        try {
            const relatedApps = await navigator.getInstalledRelatedApps();
            return relatedApps.length > 0;
        } catch (error) {
            console.log('getInstalledRelatedApps not supported:', error);
        }
    }
    
    // iOS-specific checks
    if (deviceType === 'ios') {
        // Check if added to home screen previously
        if (window.navigator.standalone !== undefined) {
            // If standalone is false but was previously true, might be installed
            const wasInstalled = localStorage.getItem('pwa-ios-installed');
            if (wasInstalled === 'true') {
                return true;
            }
        }
    }
    
    // Check for service worker that indicates installation
    if ('serviceWorker' in navigator) {
        try {
            const registrations = await navigator.serviceWorker.getRegistrations();
            const hasAppScope = registrations.some(registration => 
                registration.scope.includes('/app/') || registration.scope === `${window.location.origin}/`
            );
            if (hasAppScope) return true;
        } catch (error) {
            console.log('Service worker check failed:', error);
        }
    }
    
    return false;
}

// Get device-specific install instructions
function getInstallInstructions() {
    const deviceType = getDeviceType();
    
    switch (deviceType) {
        case 'ios':
            return {
                title: 'Install App',
                instructions: 'Tap the Share button <span class="share-icon">â¬†ï¸</span> then "Add to Home Screen"',
                showNativeButton: false
            };
        case 'android':
            return {
                title: 'Install App',
                instructions: deferredPrompt ? 'Tap "Install" to add this app to your home screen' : 'Use your browser menu to "Add to Home Screen"',
                showNativeButton: !!deferredPrompt
            };
        default:
            return {
                title: 'Install App',
                instructions: deferredPrompt ? 'Click "Install" to add this app to your desktop' : 'Use your browser menu to install this app',
                showNativeButton: !!deferredPrompt
            };
    }
}

// Update banner content based on device
function updateBannerContent() {
    if (!pwaInstallBanner) return;
    
    const instructions = getInstallInstructions();
    const deviceType = getDeviceType();
    
    // Update title
    const titleElement = pwaInstallBanner.querySelector('.pwa-banner-title');
    if (titleElement) {
        titleElement.textContent = instructions.title;
    }
    
    // Update instructions
    const instructionsElement = pwaInstallBanner.querySelector('.pwa-banner-instructions');
    if (instructionsElement) {
        instructionsElement.innerHTML = instructions.instructions;
    }
    
    // Show/hide install button based on device capabilities
    if (installPwaButton) {
        if (instructions.showNativeButton) {
            installPwaButton.style.display = 'block';
            installPwaButton.textContent = deviceType === 'desktop' ? 'Install' : 'Install App';
        } else {
            installPwaButton.style.display = 'none';
        }
    }
    
    // Add device-specific styling
    pwaInstallBanner.className = `pwa-install-banner ${deviceType}`;
}

// Initialize PWA elements after DOM is loaded
async function initPWABanner() {
    // Don't show banner if app is already installed
    if (await isAppInstalled()) {
        console.log('App is already installed, not showing install banner');
        return;
    }
    
    // Don't show banner if device can't install PWAs
    if (!canInstallPWA()) {
        console.log('Device cannot install PWAs, not showing banner');
        return;
    }
    
    pwaInstallBanner = document.getElementById('pwaInstallBanner');
    closePwaBanner = document.getElementById('closePwaBanner');
    cancelPwaBanner = document.getElementById('cancelPwaBanner');
    installPwaButton = document.getElementById('installPwaButton');
    
    if (!pwaInstallBanner || !closePwaBanner || !cancelPwaBanner || !installPwaButton) {
        console.warn('PWA install banner elements not found');
        return;
    }
    
    // Update banner content for device type
    updateBannerContent();
    
    // Show the install banner when the page loads
    createTrackedTimeout(() => {
        pwaInstallBanner.classList.add('show');
        console.log('PWA install banner shown');
    }, 2000);

    // Handle install button click
    installPwaButton.addEventListener('click', async () => {
        const deviceType = getDeviceType();
        
        if (deviceType === 'android' || deviceType === 'desktop') {
            if (!deferredPrompt) {
                console.log('No deferred prompt available');
                // Fallback: show manual instructions
                alert('Please use your browser menu to "Add to Home Screen" or "Install App"');
                return;
            }
            
            // Show the install prompt
            deferredPrompt.prompt();
            
            // Wait for the user to respond to the prompt
            const { outcome } = await deferredPrompt.userChoice;
            
            if (outcome === 'accepted') {
                console.log('User accepted the install prompt');
                // Hide banner after successful installation
                pwaInstallBanner.classList.remove('show');
                
                // Set a flag that the app was just installed
                try {
                    sessionStorage.setItem('appJustInstalled', 'true');
                    localStorage.setItem('pwa-installed', 'true');
                } catch (e) {
                    console.warn('Could not set installation flag');
                }
            } else {
                console.log('User dismissed the install prompt');
            }
            
            // Clear the deferredPrompt variable
            deferredPrompt = null;
        } else if (deviceType === 'ios') {
            // For iOS, we can't trigger native install, so hide the button and show instructions
            installPwaButton.style.display = 'none';
            const instructionsElement = pwaInstallBanner.querySelector('.pwa-banner-instructions');
            if (instructionsElement) {
                instructionsElement.innerHTML = 'Tap the Share button <span class="share-icon">â¬†ï¸</span> at the bottom of your screen, then select "Add to Home Screen"';
                instructionsElement.style.fontSize = '14px';
                instructionsElement.style.marginTop = '10px';
            }
        }
    });

    // Close button handler
    const dismissBanner = () => {
        pwaInstallBanner.classList.remove('show');
        // Store dismissal in sessionStorage (only for this session)
        try {
            sessionStorage.setItem('pwaBannerDismissed', 'true');
            console.log('PWA banner dismissed for this session');
        } catch (e) {
            console.warn('Could not store PWA banner dismissal');
        }
    };

    closePwaBanner.addEventListener('click', dismissBanner);
    cancelPwaBanner.addEventListener('click', dismissBanner);
}

// Listen for beforeinstallprompt event (mainly for Android/Desktop)
window.addEventListener('beforeinstallprompt', (e) => {
    console.log('beforeinstallprompt event fired');
    // Prevent the mini-infobar from appearing on mobile
    e.preventDefault();
    // Stash the event so it can be triggered later
    deferredPrompt = e;
    
    // Update banner content now that we have the prompt
    if (pwaInstallBanner) {
        updateBannerContent();
    }
});

// Listen for app installation (mainly for Android/Desktop)
window.addEventListener('appinstalled', () => {
    console.log('PWA was installed');
    try {
        localStorage.setItem('pwa-installed', 'true');
        sessionStorage.setItem('appJustInstalled', 'true');
    } catch (e) {
        console.warn('Could not set installation flag');
    }
    
    // Hide banner if it's still showing
    if (pwaInstallBanner && pwaInstallBanner.classList.contains('show')) {
        pwaInstallBanner.classList.remove('show');
    }
});

// For iOS: Listen for standalone mode changes
if (getDeviceType() === 'ios') {
    // Check if we're now in standalone mode (installed)
    if (window.navigator.standalone) {
        try {
            localStorage.setItem('pwa-ios-installed', 'true');
        } catch (e) {
            console.warn('Could not set iOS installation flag');
        }
    }
    
    // Listen for visibility changes that might indicate installation
    document.addEventListener('visibilitychange', () => {
        if (window.navigator.standalone) {
            try {
                localStorage.setItem('pwa-ios-installed', 'true');
            } catch (e) {
                console.warn('Could not set iOS installation flag');
            }
        }
    });
}

// Initialize when DOM is loaded
document.addEventListener('DOMContentLoaded', async function() {
    console.log('DOM loaded, checking PWA banner conditions');
    
    const deviceType = getDeviceType();
    console.log('Detected device type:', deviceType);
    
    // Check if app was just installed in this session
    try {
        if (sessionStorage.getItem('appJustInstalled') === 'true') {
            console.log('App was just installed in this session, not showing banner');
            return;
        }
    } catch (e) {
        console.warn('Could not check installation status');
    }
    
    // Check if user dismissed the banner in this session
    try {
        if (sessionStorage.getItem('pwaBannerDismissed') === 'true') {
            console.log('User dismissed banner in this session');
            return;
        }
    } catch (e) {
        console.warn('Could not check banner dismissal status');
    }
    
    // Check if app is already installed
    if (await isAppInstalled()) {
        console.log('App is already installed, not showing banner');
        return;
    }
    
    // Initialize banner
    await initPWABanner();
});
        
function showLoadingMessage() {
    const existingMessage = document.getElementById('loadingMessage');
    if (existingMessage) return;
    
    loadingMessageMinDisplayTime = Date.now() + 8000;
    
    const loadingMessage = document.createElement('div');
    loadingMessage.id = 'loadingMessage';
    loadingMessage.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        background-image: url('https://raw.githubusercontent.com/mreicher/MNThen/refs/heads/main/images/splash_screen.webp');
        background-size: cover;
        background-position: center;
        z-index: 1000;
        font-family: 'Montserrat', 'Segoe UI', 'Roboto', sans-serif;
        transition: opacity 0.5s ease;
    `;
    
    const contentContainer = document.createElement('div');
    contentContainer.style.cssText = `
        display: grid;
        grid-template-rows: auto auto 1fr auto auto;
        background-color: white;
        padding: 35px 30px;
        border-radius: 20px;
        box-shadow: 0 20px 50px rgba(0, 0, 0, 0.35), 0 2px 10px rgba(0, 0, 0, 0.2);
        width: 450px;
        height: 500px;
        text-align: center;
        backdrop-filter: blur(5px);
        border: 1px solid rgba(255, 255, 255, 0.18);
    `;
    
    const logoImage = document.createElement('img');
    logoImage.src = 'https://mnthen.com/images/logo.webp';
    logoImage.alt = 'Minnesota Then Logo';
    logoImage.style.cssText = `
        width: 180px;
        height: auto;
        margin: 0 auto 25px;
        border-radius: 12px;
        object-fit: contain;
        filter: drop-shadow(0 4px 8px rgba(0, 40, 85, 0.2));
    `;
    
    const mainTitle = document.createElement('h1');
    mainTitle.style.cssText = `
        margin: 0 0 8px 0;
        font-size: 22px;
        font-weight: 700;
        color: #002855;
        text-align: center;
        line-height: 1.2;
        letter-spacing: -0.02em;
        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
    `;
    mainTitle.textContent = 'The Museum Without Walls';
    
    const welcomeMessage = document.createElement('h2');
    welcomeMessage.style.cssText = `
        margin: 0 0 40px 0;
        font-size: 18px;
        font-weight: 500;
        color: #0066cc;
        text-align: center;
        line-height: 1.3;
        letter-spacing: 0.02em;
        opacity: 0.9;
    `;
    welcomeMessage.textContent = 'Where Every Step Tells a Story';
    
    const statusTextContainer = document.createElement('div');
    statusTextContainer.style.cssText = `
        min-height: 60px;
        display: flex;
        align-items: center;
        justify-content: center;
        margin-bottom: 20px;
    `;
    
    const statusText = document.createElement('p');
    statusText.id = 'loadingStatusText';
    statusText.style.cssText = `
        margin: 0;
        font-size: 18px;
        font-weight: 500;
        text-align: center;
        color: #0077dd;
        line-height: 1.4;
        animation: pulse 2s infinite;
        letter-spacing: 0.01em;
    `;
    statusText.textContent = 'Location found, proceeding to stabilization...';
    statusTextContainer.appendChild(statusText);
    
    const progressContainer = document.createElement('div');
    progressContainer.style.cssText = `
        width: 100%;
        height: 10px;
        background-color: rgba(0, 51, 102, 0.08);
        border-radius: 10px;
        overflow: hidden;
        margin-bottom: 12px;
        box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.12);
    `;
    
    const progressBar = document.createElement('div');
    progressBar.id = 'loadingProgressBar';
    progressBar.style.cssText = `
        height: 100%;
        width: 0%;
        background: linear-gradient(90deg, #0066cc, #0099ff, #00aaff, #0099ff, #0066cc);
        background-size: 200% auto;
        border-radius: 10px;
        transition: width 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
        box-shadow: 0 0 10px rgba(0, 120, 255, 0.6);
        animation: gradientShift 3s ease infinite;
    `;
    
    progressContainer.appendChild(progressBar);
    
    const noteContainer = document.createElement('div');
    noteContainer.style.cssText = `
        min-height: 50px;
        display: flex;
        align-items: center;
        justify-content: center;
    `;
    
    const loadingNote = document.createElement('p');
    loadingNote.style.cssText = `
        margin: 0;
        font-size: 16px;
        color: #555;
        font-weight: 500;
        opacity: 0.8;
    `;
    loadingNote.textContent = 'Preparing your experience.';
    noteContainer.appendChild(loadingNote);
    
    contentContainer.appendChild(logoImage);
    contentContainer.appendChild(mainTitle);
    contentContainer.appendChild(welcomeMessage);
    contentContainer.appendChild(statusTextContainer);
    contentContainer.appendChild(progressContainer);
    contentContainer.appendChild(noteContainer);
    
    loadingMessage.appendChild(contentContainer);
    document.body.appendChild(loadingMessage);
    
    const totalDuration = 10000;
    const updateInterval = 100;
    const steps = totalDuration / updateInterval;
    let progress = 0;
    
    const animations = [
        "Initializing map data...",
        "Processing location coordinates...",
        "Preparing exhibit data...",
        "Calibrating view perspective...",
        "Loading nearby points of interest...",
        "Optimizing content for your location...",
        "Finalizing your experience..."
    ];
    
    const progressInterval = setInterval(() => {
        progress += (100 / steps);
        
        if (progressBar) {
            progressBar.style.width = `${Math.min(progress, 100)}%`;
        }
        
        if (statusText) {
            const animationIndex = Math.min(
                Math.floor(progress / (100 / animations.length)),
                animations.length - 1
            );
            statusText.textContent = animations[animationIndex];
        }
        
        if (progress >= 100) {
            clearInterval(progressInterval);
            tryHideLoadingMessage();
        }
    }, updateInterval);
    
    loadingMessage.dataset.progressInterval = progressInterval;
}

function tryHideLoadingMessage() {
    if (Date.now() >= loadingMessageMinDisplayTime) {
        fadeOutLoadingMessage();
    } else {
        const timeRemaining = loadingMessageMinDisplayTime - Date.now();
        setTimeout(fadeOutLoadingMessage, timeRemaining + 100);
    }
}

function fadeOutLoadingMessage() {
    const loadingMessage = document.getElementById('loadingMessage');
    if (!loadingMessage) return;
    
    if (loadingMessage.dataset.progressInterval) {
        clearInterval(parseInt(loadingMessage.dataset.progressInterval));
    }
    
    const progressBar = document.getElementById('loadingProgressBar');
    if (progressBar) {
        progressBar.style.width = '100%';
    }
    
    const distanceBox = cachedElements.distanceBox || document.getElementById('distanceBox');
    if (distanceBox) {
        distanceBox.classList.add('show');
    }
    
    loadingMessage.style.opacity = '0';
    setTimeout(() => {
        if (loadingMessage && loadingMessage.parentNode) {
            loadingMessage.parentNode.removeChild(loadingMessage);
        }
    }, 500);
}

function hideLoadingMessage() {
    tryHideLoadingMessage();
}

function updateAccuracyIndicator(accuracy) {
    const indicator = document.getElementById('accuracyIndicator');
    indicator.style.backgroundColor = accuracy < 20 ? '#4CAF50' : 
                                     accuracy < 50 ? '#FF9800' : 
                                     '#F44336';
}

let _isInitialized = false;

function initializeUserLocation(position) {
    if (_isInitialized) {
        console.log('Location already initialized');
        return;
    }

    console.log('Initial position:', position);

    if (!position?.coords) {
        console.error('Invalid initial position');
        handleLocationError(new Error('Invalid initial position'));
        return;
    }

    const { latitude: lat, longitude: lng, accuracy } = position.coords;

    if (isNaN(lat) || isNaN(lng)) {
        console.error('Invalid coordinates', { lat, lng });
        handleLocationError(new Error('Invalid initial coordinates'));
        return;
    }

    // Validate required globals
    if (!userMarker || !map) {
        console.error('Map not ready');
        handleLocationError(new Error('Map system not ready'));
        return;
    }

    try {
        // Core setup
        userMarker.setLatLng([lat, lng]);
        map.setView([lat, lng], 17);

        // UI updates
        announceToScreenReader('Location acquired. Map ready for navigation.');
        hideLoadingMessage();

        // Start systems in sequence
        startPositionUpdates();
        startHunt();
        startIdleProximityCheck(); // Called ONCE

        // Visual feedback
        const distBox = cachedElements?.distanceBox ?? document.getElementById('distanceBox');
        distBox?.classList.add('pulse');
        setTimeout(() => distBox?.classList.remove('pulse'), 3000);

        _isInitialized = true;
        
    } catch (err) {
        console.error('Error setting initial location:', err);
        handleLocationError(err);
    }
}

// Module-scoped state (private to this module/file)
let positionWatchId = null;
let onlineHandler = null;

/* Starts high-accuracy geolocation updates. */
function startPositionUpdates() {
    // Clean up any existing resources first (idempotent)
    stopPositionUpdates();

    try {
        const startWatch = () => {
            return navigator.geolocation.watchPosition(
                handlePositionUpdate,
                (error) => {
                    console.warn('Geolocation update error:', error);
                    handleLocationError(error);
                    // Optionally: auto-retry logic could go here
                },
                {
                    enableHighAccuracy: true,
                    maximumAge: 1000,    // Accept cached position up to 1s old
                    timeout: 10000       // Fail if no update in 10s
                }
            );
        };

        positionWatchId = startWatch();

        // Set up online recovery handler (only once)
        if (!onlineHandler) {
            onlineHandler = () => {
                console.log('Browser is back online â€” restarting geolocation watch');
                // Only restart if we were actively watching before
                if (positionWatchId !== null) {
                    stopPositionUpdates();
                    try {
                        positionWatchId = startWatch();
                    } catch (err) {
                        console.error('Failed to restart geolocation after coming online:', err);
                        handleLocationError({ code: 0, message: 'Geolocation unavailable after reconnect' });
                    }
                }
            };
            window.addEventListener('online', onlineHandler);
        }

        return positionWatchId;

    } catch (err) {
        console.error('Geolocation API unavailable or permission denied:', err);
        handleLocationError({ code: 0, message: 'Geolocation unavailable' });
        return null;
    }
}

/* Stops the active geolocation watch (if any). */
function stopPositionUpdates() {
    if (positionWatchId !== null) {
        navigator.geolocation.clearWatch(positionWatchId);
        positionWatchId = null;
    }
}

/* Fully cleans up geolocation resources and event listeners. */
function cleanupPositionUpdates() {
    stopPositionUpdates();

    if (onlineHandler) {
        window.removeEventListener('online', onlineHandler);
        onlineHandler = null;
    }
}

// Optional: Auto-cleanup on page unload (prevents battery drain)
if (typeof window !== 'undefined') {
    window.addEventListener('beforeunload', cleanupPositionUpdates);
}
        
// Constants 
const MAX_POSITION_AGE_MS = 30_000;      // 30 seconds
const MAX_ACCEPTABLE_ACCURACY = 50;      // meters â€” stricter = more precise
const HIGH_SPEED_THRESHOLD_MPS = 10;     // ~22 mph

/* Handles incoming geolocation position updates. */
function handlePositionUpdate(position) {
    // Validate input structure and coordinates
    if (!position?.coords || 
        isNaN(position.coords.latitude) || 
        isNaN(position.coords.longitude)) {
        console.warn('Invalid position data received:', position);
        return;
    }

    const receivedAt = Date.now();
    const positionTimestamp = position.timestamp || receivedAt;

    // Reject stale positions
    if (receivedAt - positionTimestamp > MAX_POSITION_AGE_MS) {
        console.warn('Position data too old, ignoring:', { ageMs: receivedAt - positionTimestamp });
        return;
    }

    // Reject low-accuracy positions (e.g., cell/WiFi estimates)
    const accuracy = position.coords.accuracy || Infinity;
    if (accuracy > MAX_ACCEPTABLE_ACCURACY) {
        console.warn('Position accuracy too low, ignoring:', { accuracy });
        return;
    }

    // Build a complete, immutable position record
    const positionData = {
        lat: position.coords.latitude,
        lng: position.coords.longitude,
        timestamp: positionTimestamp,
        receivedAt,
        accuracy,
        speedMPS: position.coords.speed || 0,
        heading: position.coords.heading ?? null
    };

    // Calculate time since last update (for prediction logic)
    const previousUpdateTime = window.lastPositionUpdateTime ?? receivedAt;
    const updateInterval = receivedAt - previousUpdateTime;

    // Atomically update global state
    window.lastValidPosition = positionData;
    window.lastPositionUpdateTime = receivedAt;
    window.lastPositionUpdateInterval = updateInterval;

    // Force immediate UI update if moving fast (to avoid skipping boundaries)
    const forceUpdate = positionData.speedMPS > HIGH_SPEED_THRESHOLD_MPS;

    // Pass clean data to UI/logic layer
    updateUserLocation(positionData, forceUpdate);
}

// Module-scoped state (private)
let _lastHiddenTime = 0;
let _lastKnownPosition = null;
let _isReWaking = false;

// Ensure CONFIG fallback
const BACKGROUND_THRESHOLD = CONFIG?.BACKGROUND_THRESHOLD ?? 30_000;

function handleVisibilityChange() {
    // Guard: only proceed if map system is ready
    if (!userMarker || !map) {
        console.warn('Visibility change ignored: map or marker not initialized');
        return;
    }

    if (document.hidden) {
        // App is going to background
        _lastHiddenTime = Date.now();
        _lastKnownPosition = userMarker.getLatLng?.() || null;
        console.log('App backgrounded â€” storing last known position');
    } else {
        // App is returning to foreground
        const hiddenDuration = Date.now() - _lastHiddenTime;
        
        if (hiddenDuration > BACKGROUND_THRESHOLD && !_isReWaking) {
            console.log(`App foregrounded after ${hiddenDuration}ms â€” refreshing location`);
            _reawakenApp();
        } else {
            console.log('App foregrounded â€” quick return, resizing map');
            map.invalidateSize({ pan: false });
        }
    }

    resetInactivityTimer();
}

async function _reawakenApp() {
    if (_isReWaking) return; // Prevent re-entrancy

    _isReWaking = true;

    try {
        await updateLocationAfterBackground();
        console.log('Location successfully refreshed after background');
    } catch (error) {
        console.error('Failed to refresh location after background:', error);
        
        // Fallback: restore last known good position
        if (_lastKnownPosition) {
            console.log('Falling back to last known position');
            userMarker.setLatLng(_lastKnownPosition);
            map.setView(_lastKnownPosition, map.getZoom?.() ?? 17);
        }
    } finally {
        _isReWaking = false;
        // Always ensure map layout is correct after visibility change
        map.invalidateSize?.({ pan: false });
    }
}

/*Recovers location after app returns from background.*/
async function updateLocationAfterBackground() {
    if (!("geolocation" in navigator)) {
        console.warn("Geolocation is not available");
        return false;
    }

    // Strategy configuration
    const strategies = {
        quick: { enableHighAccuracy: false, timeout: 5000, maximumAge: 60000 },
        accurate: { enableHighAccuracy: true, timeout: 15000, maximumAge: 30000 },
        fallback: { enableHighAccuracy: false, timeout: 25000, maximumAge: 120000 }
    };
    const strategyOrder = ['quick', 'accurate', 'fallback'];

    // Try strategies in sequence
    const getPosition = (index) => {
        return new Promise((resolve, reject) => {
            if (index >= strategyOrder.length) {
                return reject(new Error("All geolocation strategies failed"));
            }

            const name = strategyOrder[index];
            const options = strategies[name];

            console.log(`Attempting "${name}" location recovery...`);

            navigator.geolocation.getCurrentPosition(
                (position) => {
                    console.log(`"${name}" location acquired`, {
                        lat: position.coords.latitude,
                        lng: position.coords.longitude,
                        accuracy: position.coords.accuracy
                    });
                    resolve(position);
                },
                (error) => {
                    console.warn(`"${name}" failed:`, error.message || error);
                    getPosition(index + 1).then(resolve).catch(reject);
                },
                options
            );
        });
    };

    try {
        const position = await getPosition(0);

        // Validate position
        if (!position?.coords || 
            isNaN(position.coords.latitude) || 
            isNaN(position.coords.longitude)) {
            throw new Error("Invalid position data");
        }

        const { latitude, longitude } = position.coords;
        const currentZoom = typeof map?.getZoom === 'function' ? map.getZoom() : 17;

        updateUserLocation(position, true);

        // Trigger your existing global-state updates (if they exist)
        if (typeof lastUpdateTime !== 'undefined') window.lastUpdateTime = Date.now();
        if (typeof lastUpdateTimestamp !== 'undefined') window.lastUpdateTimestamp = Date.now();

        // Use your existing inactivity & UI logic
        if (typeof isSignificantMovement === 'function' && isSignificantMovement({ lat: latitude, lng: longitude })) {
            if (typeof resetInactivityTimer === 'function') resetInactivityTimer(false);
        }

        if (typeof updateDistanceBox === 'function') updateDistanceBox();

        // Safe, public map resize
        if (map && typeof map.invalidateSize === 'function') {
            map.setView([latitude, longitude], currentZoom, { animate: false, duration: 0 });
            map.invalidateSize({ pan: false });
        }

        console.log("Background location recovery completed");
        return true;

    } catch (error) {
        console.error("Background location recovery failed:", error);
        return false;
    }
}

function updatePositionBuffer(position) {
    positionBuffer.push({
        lat: position.lat,
        lng: position.lng,
        accuracy: position.accuracy,
        timestamp: position.timestamp,
        heading: position.heading,
        speedMPS: position.speedMPS
    });
    
    while (positionBuffer.length > CONFIG.MAX_BUFFER_SIZE) {
        positionBuffer.shift();
    }
}

const MAX_WEIGHTING_AGE_MS = 30_000; // 30 seconds

/* Calculates a recency-weighted average position from a list of positions. */
function calculateWeightedPosition(positions) {
    if (!Array.isArray(positions) || positions.length === 0) {
        return null;
    }

    // Filter and validate
    const validPositions = positions.filter(pos =>
        pos &&
        typeof pos.lat === 'number' && !isNaN(pos.lat) &&
        typeof pos.lng === 'number' && !isNaN(pos.lng) &&
        typeof pos.timestamp === 'number'
    );

    if (validPositions.length === 0) {
        return null;
    }

    // Sort chronologically (oldest â†’ newest)
    const sorted = [...validPositions].sort((a, b) => a.timestamp - b.timestamp);
    const now = Date.now();

    let sumLat = 0, sumLng = 0, totalWeight = 0;

    for (const pos of sorted) {
        const age = now - pos.timestamp;
        if (age > MAX_WEIGHTING_AGE_MS) continue;

        const recency = 1 - (age / MAX_WEIGHTING_AGE_MS); // 0 (old) â†’ 1 (fresh)
        const weight = Math.pow(recency, 2.5); // Strong bias toward recent

        sumLat += pos.lat * weight;
        sumLng += pos.lng * weight;
        totalWeight += weight;
    }

    // Fallback: if all positions are too old, use simple average
    if (totalWeight === 0) {
        return calculateSimpleAverage(sorted);
    }

    const latest = sorted[sorted.length - 1];
    const accuracies = sorted.map(p => p.accuracy || 20);
    
    return {
        lat: sumLat / totalWeight,
        lng: sumLng / totalWeight,
        accuracy: Math.min(...accuracies),
        timestamp: latest.timestamp,
        heading: latest.heading,
        speedMPS: latest.speedMPS
    };
}

function calculateSimpleAverage(positions) {
    const count = positions.length;
    const sumLat = positions.reduce((sum, p) => sum + p.lat, 0);
    const sumLng = positions.reduce((sum, p) => sum + p.lng, 0);
    const latest = positions[count - 1];
    const accuracies = positions.map(p => p.accuracy || 20);

    return {
        lat: sumLat / count,
        lng: sumLng / count,
        accuracy: Math.min(...accuracies),
        timestamp: latest.timestamp,
        heading: latest.heading,
        speedMPS: latest.speedMPS
    };
}

function getSpeedBasedZoom(speedMPS, closestDistance = Infinity) {
    // Check if we should block zoom changes or if near a location
    const proximityThreshold = CONFIG.PROXIMITY_THRESHOLD || 50; // meters
    const isNearLocation = closestDistance < proximityThreshold;
    
    if (window.blockSpeedZoom || isNearLocation) {
        return -1; // Return -1 to indicate no zoom change should occur
    }
    
    if (typeof window.speedTrackingState === 'undefined') {
        window.speedTrackingState = {
            lowSpeedStartTime: null,
            isInTransit: false,
            lastSignificantMove: Date.now(),
            destinationArrivalTime: null,
            previousZoom: null,
            speedBuffer: [],
            lastSpeedMPH: 0,
            stationaryConfidence: 0,
            lastZoomUpdate: Date.now(),
            suddenJumpDetected: false,
            currentInterpolatedZoom: 17
        };
    }
    
    const state = window.speedTrackingState;
    const speedMPH = speedMPS * 2.23694;
    
    const WALKING_THRESHOLD = 3.0;
    const SIGNIFICANT_TRAVEL_THRESHOLD = 10.0;
    const TEMPORARY_STOP_MAX = 90000;
    const ARRIVAL_DELAY = 20000;
    const SPEED_BUFFER_SIZE = 5;
    const MAX_SPEED_JUMP = 20;
    const STATIONARY_CONFIDENCE_MAX = 10;
    const MIN_ZOOM_UPDATE_INTERVAL = 2000;
    const ZOOM_INTERPOLATION_SPEED = 0.15;
    const DEAD_BAND_THRESHOLD = 1.0; // mph - prevents low-speed oscillation
    
    // DEAD-BAND: Only apply if we've been in dead-band for a while**
    const now = Date.now();
    if (speedMPH < DEAD_BAND_THRESHOLD && state.lastSpeedMPH < DEAD_BAND_THRESHOLD) {
        // Only use dead-band if we've had consistent low speeds
        if (state.speedBuffer.length >= SPEED_BUFFER_SIZE) {
            const avgLowSpeed = state.speedBuffer.reduce((a, b) => a + b, 0) / state.speedBuffer.length;
            if (avgLowSpeed < DEAD_BAND_THRESHOLD * 1.5) {
                return state.currentInterpolatedZoom;
            }
        }
    }
    
    state.speedBuffer.push(speedMPH);
    if (state.speedBuffer.length > SPEED_BUFFER_SIZE) {
        state.speedBuffer.shift();
    }
    
    const sortedSpeeds = [...state.speedBuffer].sort((a, b) => a - b);
    const medianSpeed = sortedSpeeds[Math.floor(sortedSpeeds.length / 2)];
    
    // Check if we should update based on time interval**
    if (now - state.lastZoomUpdate < MIN_ZOOM_UPDATE_INTERVAL && 
        Math.abs(medianSpeed - state.lastSpeedMPH) < 5) {
        return state.currentInterpolatedZoom;
    }
    
    const speedDelta = Math.abs(medianSpeed - state.lastSpeedMPH);
    if (speedDelta > MAX_SPEED_JUMP) {
        console.debug("Sudden speed jump detected, ignoring:", 
                     {current: medianSpeed, previous: state.lastSpeedMPH});
        state.suddenJumpDetected = true;
        return state.currentInterpolatedZoom;
    } else {
        state.suddenJumpDetected = false;
    }
    
    state.lastSpeedMPH = medianSpeed;
    
    // More nuanced stationary confidence**
    if (medianSpeed < 1.0) {
        state.stationaryConfidence = Math.min(STATIONARY_CONFIDENCE_MAX, 
                                           state.stationaryConfidence + 2); // Faster confidence build-up
    } else if (medianSpeed > WALKING_THRESHOLD) {
        state.stationaryConfidence = Math.max(0, state.stationaryConfidence - 2); // Faster confidence decay
    } else {
        state.stationaryConfidence = Math.max(0, state.stationaryConfidence - 1);
    }
    
    if (medianSpeed >= SIGNIFICANT_TRAVEL_THRESHOLD && !state.suddenJumpDetected) {
        state.isInTransit = true;
        state.lastSignificantMove = now;
        state.destinationArrivalTime = null;
    }
    
    let targetZoom;
    
    if (medianSpeed <= WALKING_THRESHOLD || state.stationaryConfidence > 3) {
        if (!state.lowSpeedStartTime) {
            state.lowSpeedStartTime = now;
        }
        
        const lowSpeedDuration = now - state.lowSpeedStartTime;
        
        if (state.isInTransit && lowSpeedDuration >= ARRIVAL_DELAY) {
            if (!state.destinationArrivalTime) {
                state.destinationArrivalTime = now;
            }
            
            if (now - state.destinationArrivalTime >= 5000) {
                state.isInTransit = false;
                targetZoom = 17;
            } else {
                targetZoom = state.previousZoom || 17;
            }
        } else if (state.isInTransit && now - state.lastSignificantMove < TEMPORARY_STOP_MAX) {
            targetZoom = state.previousZoom || 17;
        } else {
            targetZoom = 17;
        }
    } else {
        state.lowSpeedStartTime = null;
        state.destinationArrivalTime = null;
        
        for (const threshold of CONFIG.SPEED_ZOOM_THRESHOLDS) {
            if (medianSpeed >= threshold.speed) {
                targetZoom = threshold.zoom;
                break;
            }
        }
        
        if (typeof targetZoom === 'undefined') {
            targetZoom = 17;
        }
    }
    
    state.previousZoom = targetZoom;
    
    // Only interpolate if the change is significant**
    if (Math.abs(state.currentInterpolatedZoom - targetZoom) > 0.1) {
        state.currentInterpolatedZoom += (targetZoom - state.currentInterpolatedZoom) * ZOOM_INTERPOLATION_SPEED;
        
        if (Math.abs(state.currentInterpolatedZoom - targetZoom) < 0.05) {
            state.currentInterpolatedZoom = targetZoom;
        }
    }
    
    state.lastZoomUpdate = now;
    
    return state.currentInterpolatedZoom;
}

/* Applies adaptive exponential smoothing to reduce GPS jitter. */
function applyExponentialSmoothing(newPosition, lastPosition, baseAlpha = 0.25) {
    // Guard: validate inputs
    if (!isValidPosition(newPosition) || !isValidPosition(lastPosition)) {
        return newPosition;
    }

    // Initialize global if not set
    if (!window.lastSmoothedPosition) {
        window.lastSmoothedPosition = lastPosition;
    }

    // Ensure CONFIG exists with safe fallbacks
    const MIN_DISTANCE_THRESHOLD = CONFIG?.MIN_DISTANCE_THRESHOLD ?? 5;      // meters
    const STATIONARY_THRESHOLD  = CONFIG?.STATIONARY_THRESHOLD ?? 10;       // count
    const MIN_ALPHA             = CONFIG?.MIN_ALPHA ?? 0.05;
    const MAX_ALPHA             = CONFIG?.MAX_ALPHA ?? 0.4;
    const MAX_ACCEPTABLE_ACCURACY = CONFIG?.MAX_ACCEPTABLE_ACCURACY ?? 50;  // meters

    // Calculate distance from last smoothed position
    const distance = calculateDistance(newPosition, window.lastSmoothedPosition);

    // Update stationary counter
    if (distance < MIN_DISTANCE_THRESHOLD * 0.7) {
        window.stationaryCount = Math.min(
            (window.stationaryCount || 0) + 1,
            STATIONARY_THRESHOLD * 2
        );
    } else {
        window.stationaryCount = Math.max((window.stationaryCount || 0) - 1, 0);
    }

    // Base alpha: adaptive based on stationary state
    let alpha = baseAlpha;
    const count = window.stationaryCount || 0;
    if (count >= STATIONARY_THRESHOLD) {
        alpha = MIN_ALPHA * 0.5;
    } else {
        alpha = MAX_ALPHA - (count / (STATIONARY_THRESHOLD * 2)) * (MAX_ALPHA - MIN_ALPHA);
    }

    // Adjust by accuracy (higher accuracy â†’ less smoothing)
    const accuracyRatio = Math.max(0, Math.min(1, 1 - (newPosition.accuracy / MAX_ACCEPTABLE_ACCURACY)));
    alpha *= 0.4 + 0.6 * accuracyRatio;

    // Adjust by speed
    if (newPosition.speedMPS !== undefined) {
        if (newPosition.speedMPS < 0.3) {
            alpha *= 0.3; // Very slow â†’ smooth more
        } else if (newPosition.speedMPS > 10) {
            alpha = Math.min(0.6, alpha * 1.5); // Fast â†’ trust more, but cap
        }
    }

    // Adjust by time delta
    const timeDelta = newPosition.timestamp - lastPosition.timestamp;
    if (timeDelta > 0) {
        if (timeDelta < 1000) {
            alpha *= 0.6; // Very frequent updates â†’ smooth more
        } else if (timeDelta > 5000) {
            alpha = Math.min(0.8, alpha * 2); // Stale update â†’ trust more
        }
    }

    // Clamp alpha to [0, 1]
    alpha = Math.max(0, Math.min(1, alpha));

    // Apply smoothing
    const smoothedPosition = {
        lat: window.lastSmoothedPosition.lat + alpha * (newPosition.lat - window.lastSmoothedPosition.lat),
        lng: window.lastSmoothedPosition.lng + alpha * (newPosition.lng - window.lastSmoothedPosition.lng),
        accuracy: Math.min(newPosition.accuracy || Infinity, window.lastSmoothedPosition.accuracy || Infinity),
        heading: newPosition.heading ?? window.lastSmoothedPosition.heading,
        timestamp: newPosition.timestamp,
        speedMPS: (newPosition.speedMPS ?? window.lastSmoothedPosition.speedMPS) ?? 0
    };

    // Extra heading smoothing when stationary
    if (count >= STATIONARY_THRESHOLD && smoothedPosition.heading !== undefined) {
        const headingAlpha = alpha * 0.3;
        smoothedPosition.heading = headingAlpha * (newPosition.heading ?? smoothedPosition.heading) +
                                   (1 - headingAlpha) * (window.lastSmoothedPosition.heading ?? smoothedPosition.heading);
    }

    // Micro-stabilization for very small movements
    if (distance < MIN_DISTANCE_THRESHOLD * 0.3) {
        smoothedPosition.lat = window.lastSmoothedPosition.lat * 0.98 + smoothedPosition.lat * 0.02;
        smoothedPosition.lng = window.lastSmoothedPosition.lng * 0.98 + smoothedPosition.lng * 0.02;
    }

    // Update global state
    window.lastSmoothedPosition = smoothedPosition;
    return smoothedPosition;
}

/* Applies velocity + acceleration-based prediction to reduce tracking latency. */
function calculateEnhancedVelocityFilter(current, last, dt, speed) {
    // Guard: invalid time delta
    if (!dt || dt <= 0 || !current || !last) {
        return current;
    }

    // Validate position structure
    if (
        typeof current.lat !== 'number' || isNaN(current.lat) ||
        typeof current.lng !== 'number' || isNaN(current.lng) ||
        typeof last.lat !== 'number' || isNaN(last.lat) ||
        typeof last.lng !== 'number' || isNaN(last.lng)
    ) {
        return current;
    }

    const dtSafe = Math.max(dt, 0.02); // Avoid division by near-zero
    const MAX_PREDICTION_METERS = 15;
    const METERS_PER_DEGREE_LAT = 111320; // Approx at equator (good enough for short distances)
    const maxPredDegrees = MAX_PREDICTION_METERS / METERS_PER_DEGREE_LAT;

    // Compute current velocity (degrees per second)
    const vLat = (current.lat - last.lat) / dtSafe;
    const vLng = (current.lng - last.lng) / dtSafe;

    // Use last velocity or initialize
    const vLast = window.lastVelocity || { lat: vLat, lng: vLng };

    // Compute acceleration (degrees per secondÂ²)
    const aLat = (vLat - vLast.lat) / dtSafe;
    const aLng = (vLng - vLast.lng) / dtSafe;

    // Update global state
    window.lastVelocity = { lat: vLat, lng: vLng };

    // Damp acceleration based on speed (reduce overshoot at low speeds)
    const speedMPH = (speed || 0) * 2.23694; // m/s â†’ mph
    let accelWeight;
    if (speedMPH < 5) {
        accelWeight = 0.15;
    } else if (speedMPH < 15) {
        accelWeight = 0.25;
    } else {
        accelWeight = 0.35;
    }

    const damp = Math.min(1, Math.max(0.2, 1 - (speed || 0) / 20)) * accelWeight;

    // Prediction time window (0.1sâ€“0.5s)
    const predT = Math.min(0.5, Math.max(0.1, dtSafe));

    // Kinematic prediction: x = x0 + v*t + 0.5*a*tÂ²
    let lat = current.lat + vLat * predT + 0.5 * aLat * damp * predT * predT;
    let lng = current.lng + vLng * predT + 0.5 * aLng * damp * predT * predT;

    // Clamp prediction to max radius (15 meters)
    const dLat = lat - current.lat;
    const dLng = lng - current.lng;
    const distanceDegrees = Math.hypot(dLat, dLng);

    if (distanceDegrees > maxPredDegrees) {
        const scale = maxPredDegrees / distanceDegrees;
        lat = current.lat + dLat * scale;
        lng = current.lng + dLng * scale;
    }

    // Ensure no NaN slips through
    if (isNaN(lat) || isNaN(lng)) {
        return current;
    }

    return {
        lat,
        lng,
        accuracy: current.accuracy ?? 20,
        heading: current.heading ?? null,
        timestamp: current.timestamp ?? Date.now(),
        speedMPS: speed ?? 0
    };
}

/* Manages stationary state detection with hysteresis to avoid flickering. */
function checkStationaryState(newPosition) {
    // Guard: validate input
    if (!newPosition || typeof newPosition.lat !== 'number' || typeof newPosition.lng !== 'number') {
        return;
    }

    // Initialize global state if missing
    if (typeof window.isStationary === 'undefined') {
        window.isStationary = false;
        window.stationaryStartTime = null;
        window.stationaryCheckTimeout = null;
        window.lastPosition = null;
    }

    const MICRO_MOVEMENT_THRESHOLD = CONFIG?.MICRO_MOVEMENT_THRESHOLD ?? 2.0; // meters
    const STATIONARY_CONFIRMATION_TIME = CONFIG?.STATIONARY_CONFIRMATION_TIME ?? 5000; // ms
    const STATIONARY_CHECK_INTERVAL = CONFIG?.STATIONARY_CHECK_INTERVAL ?? 1000; // ms

    // Store current as last for next comparison
    const lastPos = window.lastPosition;
    window.lastPosition = newPosition;

    if (!lastPos) return;

    const distance = calculateDistance(lastPos, newPosition);

    // Movement detected â†’ exit stationary state
    if (distance >= MICRO_MOVEMENT_THRESHOLD) {
        if (window.stationaryCheckTimeout) {
            clearTimeout(window.stationaryCheckTimeout);
            window.stationaryCheckTimeout = null;
        }

        if (window.isStationary) {
            console.debug("Movement detected, exiting stationary state");
            window.isStationary = false;
            window.stationaryStartTime = null;
        }
        return;
    }

    // Still within micro-movement range â†’ evaluate stationary state
    const now = Date.now();

    if (!window.isStationary) {
        // Start or update stationary timer
        if (!window.stationaryStartTime) {
            window.stationaryStartTime = now;
        }

        const duration = now - window.stationaryStartTime;
        if (duration >= STATIONARY_CONFIRMATION_TIME) {
            console.debug("Stationary state confirmed after", duration, "ms");
            window.isStationary = true;
        }
    }

    // Schedule next check
    if (window.stationaryCheckTimeout) {
        clearTimeout(window.stationaryCheckTimeout);
    }
    window.stationaryCheckTimeout = setTimeout(() => {
        checkStationaryState(newPosition);
    }, STATIONARY_CHECK_INTERVAL);
}

function calculateFinalPosition() {
    const len = positionBuffer.length;
    if (len === 0) return null;          // never happens in your flow, but keep
    if (len === 1) return { ...positionBuffer[0] }; // cheap clone
    return calculateWeightedPosition(positionBuffer);
}

function throttle(func, limit) {
    let timeoutId = null;
    return function throttled(...args) {
        if (!timeoutId) {
            func.apply(this, args);
            timeoutId = setTimeout(() => {
                timeoutId = null;
            }, limit);
        }
    };
}

function speedAggressiveness(speedMPH, loSpeed = 2, hiSpeed = 15, exponent = 0.6) {
    if (speedMPH <= loSpeed) return 0;
    if (speedMPH >= hiSpeed) return 1;
    const t = (speedMPH - loSpeed) / (hiSpeed - loSpeed);
    return Math.pow(t, exponent);
}

// MODULE-SCOPED STATE (not global window.*)
let _ul_lastDebounceTime = 0;
let _ul_pendingPosition = null;
let _ul_pendingForceUpdate = false;
let _ul_debounceTimeoutId = null;

// HELPER FUNCTIONS 
function _ul_setGpsTimeout() {
    if (window.gpsTimeoutTimer) clearTimeout(window.gpsTimeoutTimer);
    window.gpsTimeoutTimer = setTimeout(() => {
        window.isGPSSearching = true;
        if (typeof showGPSSearchingState === 'function') showGPSSearchingState();
    }, 30000);
}

function _ul_handleBackgroundUpdate(newPosition, currentTime, forceUpdate) {
    if (document.hidden && !forceUpdate) {
        userMarker.setLatLng([newPosition.lat, newPosition.lng]);
        window.lastPosition = newPosition;
        window.lastUpdateTime = currentTime;
        if (typeof updateDistanceBox === 'function') updateDistanceBox();
        return true;
    }
    return false;
}

async function _ul_checkLowPowerMode() {
    if (document.hidden) return false;
    try {
        if (typeof navigator.getBattery === 'function') {
            const battery = await navigator.getBattery();
            return battery.level < 0.2 && !battery.charging;
        }
    } catch (e) { /* ignore */ }
    return false;
}

function _ul_handleLowPowerMode(newPosition, currentTime, isLowPower, forceUpdate) {
    if (isLowPower && !forceUpdate) {
        userMarker.setLatLng([newPosition.lat, newPosition.lng]);
        window.lastPosition = newPosition;
        window.lastUpdateTime = currentTime;
        if (typeof updateDistanceBox === 'function') updateDistanceBox();
        return true;
    }
    return false;
}

function _ul_handleGpsRecovery() {
    if (!window.isGPSSearching) return false;
    window.isGPSSearching = false;
    window.positionBuffer = [];
    window.lastVelocity = { lat: 0, lng: 0 };
    window.smoothedVelocity = { lat: 0, lng: 0 };
    window.isStationary = false;
    window.stationaryStartTime = null;
    window.stationaryLockPosition = null;
    if (typeof hideGPSSearchingState === 'function') hideGPSSearchingState();
    return true;
}

// PROXIMITY MODULE
function _ul_calculateProximity(newPosition, positionChangedSignificantly) {
    const { closestDistance, closestLocation, allLocationsWithDistance } = 
        _ul_findClosestLocationAndAll(newPosition, positionChangedSignificantly);
    
    if (closestDistance === Infinity) {
        if (typeof updateDistanceBox === 'function') updateDistanceBox();
        return;
    }

    _ul_updateProximityState(closestDistance, closestLocation);
    _ul_handleCaching(newPosition, allLocationsWithDistance);
    _ul_handlePreloading(closestLocation, closestDistance);
    _ul_handleProximityTrigger(closestLocation, closestDistance);
    
    if (typeof updateDistanceBox === 'function') updateDistanceBox();
}

function _ul_findClosestLocationAndAll(newPosition, positionChangedSignificantly) {
    // Reuse previous result if position hasn't changed significantly
    if (!positionChangedSignificantly && 
        window.lastClosestDistance !== undefined && 
        window.lastClosestLocation) {
        return {
            closestDistance: window.lastClosestDistance,
            closestLocation: window.lastClosestLocation,
            allLocationsWithDistance: [] // Not needed for caching in reuse case
        };
    }

    let closestDistance = Infinity;
    let closestLocation = null;
    const allLocationsWithDistance = [];

    if (typeof gameLocations !== 'undefined' && gameLocations?.length > 0) {
        for (let i = 0; i < gameLocations.length; i++) {
            const loc = gameLocations[i];
            if (!loc?.lat) continue;
            const dist = calculateDistance(newPosition, loc);
            allLocationsWithDistance.push({ location: loc, distance: dist });
            if (dist < closestDistance) {
                closestDistance = dist;
                closestLocation = loc;
            }
        }
    }

    return { closestDistance, closestLocation, allLocationsWithDistance };
}

function _ul_updateProximityState(closestDistance, closestLocation) {
    window.lastClosestDistance = closestDistance;
    window.lastClosestLocation = closestLocation;
}

function _ul_handleCaching(newPosition, allLocationsWithDistance) {
    // Only cache if we computed fresh distances (i.e., not reused)
    if (allLocationsWithDistance.length === 0) return;

    const CACHE_UPDATE_INTERVAL = 5000;
    const CACHE_DISTANCE_THRESHOLD = 100;
    const now = Date.now();
    
    if (!window.lastCacheUpdate || (now - window.lastCacheUpdate) > CACHE_UPDATE_INTERVAL) {
        for (const item of allLocationsWithDistance) {
            if (item.distance <= CACHE_DISTANCE_THRESHOLD && 
                typeof enterpriseCacheManager?.cacheLocationData === 'function') {
                enterpriseCacheManager.cacheLocationData(item.location, newPosition);
            }
        }
        window.lastCacheUpdate = now;
    }
}

function _ul_handlePreloading(closestLocation, closestDistance) {
    const distanceFeet = closestDistance * 3.28084;

    if (distanceFeet <= 100 && closestLocation) {
        const isNewLocation = !window.preloadedLocation || 
                              window.preloadedLocation.id !== closestLocation.id;
        if (isNewLocation) {
            window.preloadedLocation = closestLocation;
            _ul_prefetchMapTiles();
            if (typeof preloadLocationData === 'function') {
                preloadLocationData(closestLocation);
            }
        }
    } else if (distanceFeet > 120) {
        window.preloadedLocation = null;
    }
}

function _ul_prefetchMapTiles() {
    if (!window._didPrefetch18 && 
        typeof map !== 'undefined' && 
        map.getZoom && 
        map.getZoom() < 18) {
        const center = map.getCenter();
        const currentZoom = map.getZoom();
        map.setView(center, 18, { animate: false });
        map.setView(center, currentZoom, { animate: false });
        window._didPrefetch18 = true;
    }
}

function _ul_handleProximityTrigger(closestLocation, closestDistance) {
    const PROXIMITY_THRESHOLD = (typeof CONFIG?.DISTANCE_THRESHOLD !== 'undefined') 
        ? CONFIG.DISTANCE_THRESHOLD 
        : 150;
    const distanceFeet = closestDistance * 3.28084;

    if (distanceFeet > PROXIMITY_THRESHOLD || !closestLocation?.id) {
        return;
    }

    // Debounce
    const now = performance.now();
    if (now - (window._lastProximityTrigger || 0) < 100) {
        return;
    }
    window._lastProximityTrigger = now;

    // Cooldown
    if (typeof window.cooldownManager !== 'undefined') {
        const cooldownStatus = window.cooldownManager.checkCooldown(closestLocation.id);
        if (cooldownStatus.isOnCooldown) {
            return;
        }
    }

    // Don't trigger if location page is already open
    const lochuntContainer = document.querySelector('.lochunt-container');
    const locationPageOpen = lochuntContainer && lochuntContainer.style.display !== 'none';
    if (locationPageOpen) {
        return;
    }

    // Trigger
    _ul_triggerProximityEvent(closestLocation);
}

function _ul_triggerProximityEvent(location) {
    if (navigator.vibrate) {
        navigator.vibrate(100);
    }
    
    const locationToOpen = window.preloadedLocation || location;
    const openFns = [
        openLocationPage,
        showLocationDetails,
        displayPOI,
        showLocationHunt
    ];
    
    for (const fn of openFns) {
        if (typeof fn === 'function') {
            fn(locationToOpen);
            break;
        }
    }
    
    window.preloadedLocation = null;
}

function _ul_handleFirstFix(newPosition, currentTime) {
    if (typeof lastPosition !== 'undefined' && lastPosition) return false;

    window.lastPosition = newPosition;
    window.lastUpdateTime = currentTime;
    window.stationaryStartTime = currentTime;
    window.positionBuffer = [newPosition];
    window.lastVelocity = { lat: 0, lng: 0 };
    window.smoothedVelocity = { lat: 0, lng: 0 };
    window.isStationary = false;
    window.stationaryLockPosition = null;
    window.isMapInteracting = false;
    window.lastInteractionTime = currentTime;
    window.followUser = true;
    window.blockSpeedZoom = false;
    window.zoomedInState = false;

    const mapContainer = map.getContainer();
    const originalTransition = mapContainer.style.transition;
    mapContainer.style.transition = 'none';
    userMarker.setLatLng([newPosition.lat, newPosition.lng]);
    const currentZoom = map.getZoom();
    map.setView([newPosition.lat, newPosition.lng], currentZoom, { animate: false, noMoveStart: true });
    setTimeout(() => { mapContainer.style.transition = originalTransition; }, 50);

    const intelligentZoom = getSpeedBasedZoom(newPosition.speedMPS);
    if (intelligentZoom) map.setZoom(intelligentZoom, { animate: false, noMoveStart: true });

    if (typeof updateDistanceBox === 'function') updateDistanceBox();
    if (typeof updateAccuracyIndicator === 'function') updateAccuracyIndicator(newPosition.accuracy);
    return true;
}

function _ul_checkAcceleration(lastPosition, newPosition, timeDelta) {
    if (!lastPosition || timeDelta <= 0 || timeDelta >= 5) return false;
    const lastSpeedMPH = (lastPosition.speedMPS || 0) * 2.23694;
    const speedMPH = newPosition.speedMPS * 2.23694;
    const acceleration = Math.abs(speedMPH - lastSpeedMPH) / timeDelta;
    if (acceleration > 15) {
        console.warn(`Rejecting impossible acceleration: ${acceleration.toFixed(1)} mph/s`);
        return true;
    }
    return false;
}

function _ul_validateHeading(lastPosition, newPosition) {
    let validatedHeading = newPosition.heading;
    if (lastPosition.heading != null && newPosition.heading != null) {
        let headingDiff = Math.abs(newPosition.heading - lastPosition.heading);
        headingDiff = headingDiff > 180 ? 360 - headingDiff : headingDiff;
        if (newPosition.speedMPS < 2 && headingDiff > 90) {
            validatedHeading = lastPosition.heading;
        }
    }
    return validatedHeading;
}

function _ul_getSpeedTierIndex(speedMPH) {
    return (speedMPH < 1) ? 0 :
           (speedMPH < 4) ? 1 :
           (speedMPH < 8) ? 2 :
           (speedMPH < 16) ? 3 :
           (speedMPH < 24) ? 4 :
           (speedMPH < 34) ? 5 :
           (speedMPH < 46) ? 6 :
           (speedMPH < 58) ? 7 :
           (speedMPH < 70) ? 8 : 9;
}

function _ul_getSpeedTier(speedTierIndex) {
    const configs = [
        { microMovementThreshold: 0.08, minDistanceThreshold: 0.3, maxAccuracy: 30, maxSpeedThreshold: 15, mapUpdateInterval: 1000, mapUpdateDistance: 2.0, panDuration: 2.5, easeLinearity: 0.04, zoomThreshold: 2.5, zoomDuration: 4.0 },
        { microMovementThreshold: 0.16, minDistanceThreshold: 0.45, maxAccuracy: 26, maxSpeedThreshold: 24, mapUpdateInterval: 800, mapUpdateDistance: 3.0, panDuration: 2.0, easeLinearity: 0.06, zoomThreshold: 2.0, zoomDuration: 3.5 },
        { microMovementThreshold: 0.24, minDistanceThreshold: 0.6, maxAccuracy: 24, maxSpeedThreshold: 30, mapUpdateInterval: 600, mapUpdateDistance: 4.5, panDuration: 1.6, easeLinearity: 0.08, zoomThreshold: 1.7, zoomDuration: 3.0 },
        { microMovementThreshold: 0.405, minDistanceThreshold: 0.825, maxAccuracy: 22, maxSpeedThreshold: 39, mapUpdateInterval: 450, mapUpdateDistance: 6.5, panDuration: 1.3, easeLinearity: 0.10, zoomThreshold: 1.4, zoomDuration: 2.6 },
        { microMovementThreshold: 0.54, minDistanceThreshold: 1.05, maxAccuracy: 21, maxSpeedThreshold: 48, mapUpdateInterval: 350, mapUpdateDistance: 9.0, panDuration: 1.1, easeLinearity: 0.12, zoomThreshold: 1.2, zoomDuration: 2.2 },
        { microMovementThreshold: 0.72, minDistanceThreshold: 1.35, maxAccuracy: 20.4, maxSpeedThreshold: 60, mapUpdateInterval: 280, mapUpdateDistance: 12.5, panDuration: 0.9, easeLinearity: 0.14, zoomThreshold: 1.0, zoomDuration: 1.9 },
        { microMovementThreshold: 0.945, minDistanceThreshold: 1.725, maxAccuracy: 20, maxSpeedThreshold: 75, mapUpdateInterval: 230, mapUpdateDistance: 16.5, panDuration: 0.75, easeLinearity: 0.16, zoomThreshold: 0.85, zoomDuration: 1.6 },
        { microMovementThreshold: 1.215, minDistanceThreshold: 2.175, maxAccuracy: 20, maxSpeedThreshold: 93, mapUpdateInterval: 190, mapUpdateDistance: 21.0, panDuration: 0.62, easeLinearity: 0.18, zoomThreshold: 0.7, zoomDuration: 1.4 },
        { microMovementThreshold: 1.53, minDistanceThreshold: 2.7, maxAccuracy: 20, maxSpeedThreshold: 114, mapUpdateInterval: 160, mapUpdateDistance: 26.0, panDuration: 0.50, easeLinearity: 0.20, zoomThreshold: 0.6, zoomDuration: 1.2 },
        { microMovementThreshold: 1.89, minDistanceThreshold: 3.3, maxAccuracy: 20, maxSpeedThreshold: 135, mapUpdateInterval: 130, mapUpdateDistance: 32.0, panDuration: 0.40, easeLinearity: 0.22, zoomThreshold: 0.5, zoomDuration: 1.0 }
    ];
    return configs[speedTierIndex];
}

function _ul_handleLargeJump(newPosition, currentTime, distance, forceUpdate) {
    if (distance > 50 || forceUpdate) {
        if (window.stationaryCheckTimeout) {
            clearTimeout(window.stationaryCheckTimeout);
            window.stationaryCheckTimeout = null;
        }
        window.isStationary = false;
        window.stationaryStartTime = null;
        window.stationaryLockPosition = null;

        const mapContainer = map.getContainer();
        const originalTransition = mapContainer.style.transition;
        mapContainer.style.transition = 'none';
        userMarker.setLatLng([newPosition.lat, newPosition.lng]);
        map.setView([newPosition.lat, newPosition.lng], map.getZoom(), { animate: false, noMoveStart: true });
        setTimeout(() => { mapContainer.style.transition = originalTransition; }, 16);

        window.lastPosition = newPosition;
        window.positionBuffer = [newPosition];
        window.lastVelocity = { lat: 0, lng: 0 };
        window.smoothedVelocity = { lat: 0, lng: 0 };
        window.lastUpdateTime = currentTime;
        window.lastUpdateTimestamp = currentTime;

        const intelligentZoom = getSpeedBasedZoom(newPosition.speedMPS);
        if (intelligentZoom) map.setZoom(intelligentZoom, { animate: false, noMoveStart: true });

        if (typeof isSignificantMovement === 'function' && isSignificantMovement(newPosition) && typeof resetInactivityTimer === 'function') {
            resetInactivityTimer(false);
        }
        if (typeof updateDistanceBox === 'function') updateDistanceBox();
        return true;
    }
    return false;
}

/* Handles the logic for detecting and managing a stationary state. */
function _ul_handleStationaryLogic(newPosition, currentTime, distance) {
    const STATIONARY_CONFIG = {
        DETECTION_THRESHOLD: 0.5,      // meters - potential stationary detection
        LOCK_THRESHOLD: 0.3,           // meters - confirmed stationary bounds
        CONFIRMATION_TIME: 2000,       // ms - time required to confirm stationary
        MICRO_MOVEMENT_THRESHOLD: 0.15, // meters - small movements while potentially stationary
        SNAP_DISTANCE: 0.5             // meters - distance that requires animation vs instant
    };

    const isPotentiallyStationary = distance < STATIONARY_CONFIG.DETECTION_THRESHOLD;

    if (isPotentiallyStationary) {
        return _ul_handlePotentialStationary(newPosition, currentTime, distance, STATIONARY_CONFIG);
    } else {
        return _ul_handleMovementDetected();
    }
}

/* Handles the case where the user is potentially stationary. */
function _ul_handlePotentialStationary(newPosition, currentTime, distance, config) {
    // Start or update stationary timer
    if (!window.stationaryStartTime) {
        window.stationaryStartTime = currentTime;
    }

    const stationaryDuration = currentTime - window.stationaryStartTime;
    const isConfirmedStationary = !!window.isStationary; // Ensure boolean

    if (!isConfirmedStationary && stationaryDuration >= config.CONFIRMATION_TIME) {
        return _ul_confirmStationaryState(newPosition, currentTime, config);
    }

    if (isConfirmedStationary) {
        return _ul_maintainStationaryState(newPosition, config);
    }

    // Not yet confirmed stationary, but within threshold
    return _ul_handleMicroMovements(newPosition, currentTime, distance, config);
}

/* Confirms the stationary state and performs initial setup.*/
function _ul_confirmStationaryState(newPosition, currentTime, config) {
    window.isStationary = true;
    window.stationaryLockPosition = { lat: newPosition.lat, lng: newPosition.lng };

    const currentLatLng = userMarker.getLatLng();
    const targetLatLng = L.latLng(newPosition.lat, newPosition.lng);
    const finalDistance = currentLatLng.distanceTo(targetLatLng);

    // Animate only if significant correction needed
    if (finalDistance > config.SNAP_DISTANCE) {
        userMarker.setLatLng([newPosition.lat, newPosition.lng], {
            animate: true,
            duration: 0.8,
            easeLinearity: 0.06
        });
    } else {
        userMarker.setLatLng([newPosition.lat, newPosition.lng]);
    }

    window.lastPosition = newPosition;
    window.positionBuffer = [newPosition];
    window.lastUpdateTime = currentTime;

    if (typeof updateDistanceBox === 'function') updateDistanceBox();
    return true;
}

/* Maintains the confirmed stationary state. */
function _ul_maintainStationaryState(newPosition, config) {
    const distanceFromLock = calculateDistance(window.stationaryLockPosition, newPosition);
    const lastAccuracy = window.lastPosition?.accuracy ?? Infinity;
    const accuracyImproved = newPosition.accuracy < lastAccuracy * 0.85;

    // Only update if position is stable and accuracy improved
    if (distanceFromLock < config.LOCK_THRESHOLD && accuracyImproved) {
        userMarker.setLatLng([newPosition.lat, newPosition.lng]);
        window.lastPosition = newPosition;
        window.stationaryLockPosition = { lat: newPosition.lat, lng: newPosition.lng };
        if (typeof updateDistanceBox === 'function') updateDistanceBox();
    }
    return true;
}

/* Handles small movements while potentially stationary but not confirmed. */
function _ul_handleMicroMovements(newPosition, currentTime, distance, config) {
    // Handle small movements while potentially stationary but not confirmed
    if (distance > config.MICRO_MOVEMENT_THRESHOLD) {
        const currentLatLng = userMarker.getLatLng();
        const targetLatLng = L.latLng(newPosition.lat, newPosition.lng);
        const microDistance = currentLatLng.distanceTo(targetLatLng);

        if (microDistance > 0.3) { // Small snap threshold
            userMarker.setLatLng([newPosition.lat, newPosition.lng], {
                animate: true,
                duration: 1.2,
                easeLinearity: 0.04
            });
            window.lastPosition = newPosition;
            window.lastUpdateTime = currentTime;
            if (typeof updateDistanceBox === 'function') updateDistanceBox();
        }
    }
    return true;
}

/* Handles the case where movement is detected */
function _ul_handleMovementDetected() {
    // Clear stationary state when movement detected
    if (window.isStationary || window.stationaryStartTime) {
        window.isStationary = false;
        window.stationaryStartTime = null;
        window.stationaryLockPosition = null;
        
        // clear stationaryCheckTimeout here.
         if (window.stationaryCheckTimeout) {
             clearTimeout(window.stationaryCheckTimeout);
             window.stationaryCheckTimeout = null;
         }
    }
    return false;
}
        
function _ul_passesQualityGate(newPosition, distance, timeDelta, speedTier, eastWestMovement) {
    const dynamicMinDistance = speedTier.minDistanceThreshold * (eastWestMovement ? 0.9 : 1.0);
    const dynamicMaxAccuracy = speedTier.maxAccuracy;
    const dynamicMaxSpeed = speedTier.maxSpeedThreshold;
    return !(newPosition.accuracy > dynamicMaxAccuracy ||
             distance < dynamicMinDistance ||
             (timeDelta > 0 && distance / timeDelta > dynamicMaxSpeed));
}

/* Handles early return logic for stationary or nearly-stationary users. */
function _ul_handleEarlyReturnForStationary(newPosition, currentTime, speedMPH, distance) {
    // Validate required inputs
    if (!newPosition || typeof newPosition.lat !== 'number' || typeof newPosition.lng !== 'number') {
        console.warn('Invalid newPosition in _ul_handleEarlyReturnForStationary');
        return false;
    }

    const STATIONARY_CONFIG = {
        VERY_SLOW_SPEED: 0.5,          // mph - barely moving
        VERY_SMALL_DISTANCE: 0.1,      // meters - minimal movement
        LOCK_THRESHOLD: 0.3,           // meters - max deviation from lock position
        ACCURACY_JUMP_IMPROVEMENT: 0.6,     // 40% better = significant
        ACCURACY_INCREMENTAL_IMPROVEMENT: 0.85 // 15% better = acceptable
    };

    const isConfirmedStationary = Boolean(window.isStationary);
    const isBarelyMoving = speedMPH < STATIONARY_CONFIG.VERY_SLOW_SPEED && 
                          distance < STATIONARY_CONFIG.VERY_SMALL_DISTANCE;

    if (!isConfirmedStationary && !isBarelyMoving) {
        return false;
    }

    if (isConfirmedStationary) {
        return _ul_handleConfirmedStationaryUpdate(newPosition, currentTime, STATIONARY_CONFIG);
    } else {
        return _ul_handleBarelyMovingUpdate(newPosition, currentTime, STATIONARY_CONFIG);
    }
}

/* Handles updates when user is confirmed stationary. */
function _ul_handleConfirmedStationaryUpdate(newPosition, currentTime, config) {
    // Ensure stationaryLockPosition exists (defensive initialization)
    if (!window.stationaryLockPosition) {
        window.stationaryLockPosition = { lat: newPosition.lat, lng: newPosition.lng };
    }

    const distanceFromLock = calculateDistance(window.stationaryLockPosition, newPosition);
    const lastAccuracy = window.lastPosition?.accuracy ?? Infinity;
    const accuracyImproved = newPosition.accuracy < lastAccuracy * config.ACCURACY_INCREMENTAL_IMPROVEMENT;

    const shouldUpdate = distanceFromLock < config.LOCK_THRESHOLD && accuracyImproved;

    if (shouldUpdate) {
        // Safety check for required globals
        if (typeof userMarker?.setLatLng !== 'function') {
            console.warn('userMarker.setLatLng is not available');
            return true; // Still skip further processing (stationary state holds)
        }

        userMarker.setLatLng([newPosition.lat, newPosition.lng]);
        window.lastPosition = newPosition;
        window.stationaryLockPosition = { lat: newPosition.lat, lng: newPosition.lng };
        window.lastUpdateTime = currentTime;

        if (typeof updateDistanceBox === 'function') {
            updateDistanceBox();
        }
    }

    // Always return true for confirmed stationary to skip motion processing
    // (even if position wasn't updated, we remain in stationary mode)
    return true;
}

/* Handles updates when user is barely moving (not yet confirmed stationary).*/
function _ul_handleBarelyMovingUpdate(newPosition, currentTime, config) {
    if (!window.lastPosition) {
        // First position or reset state â€“ accept it
        if (typeof userMarker?.setLatLng !== 'function') {
            console.warn('userMarker.setLatLng is not available');
            return false;
        }

        userMarker.setLatLng([newPosition.lat, newPosition.lng]);
        window.lastPosition = newPosition;
        window.positionBuffer = [newPosition];
        window.lastUpdateTime = currentTime;

        if (typeof updateDistanceBox === 'function') {
            updateDistanceBox();
        }
        return true;
    }

    const accuracyImprovedSignificantly = 
        newPosition.accuracy < window.lastPosition.accuracy * config.ACCURACY_JUMP_IMPROVEMENT;

    if (accuracyImprovedSignificantly) {
        if (typeof userMarker?.setLatLng !== 'function') {
            console.warn('userMarker.setLatLng is not available');
            return false;
        }

        userMarker.setLatLng([newPosition.lat, newPosition.lng]);
        window.lastPosition = newPosition;
        window.positionBuffer = [newPosition];
        window.lastUpdateTime = currentTime;

        if (typeof updateDistanceBox === 'function') {
            updateDistanceBox();
        }
        return true;
    }

    return false; // Allow further processing (e.g., to detect actual movement)
}

function _ul_handleAccuracyJump(newPosition, distance, currentTime) {
    const accuracyImproved = window.lastPosition && (newPosition.accuracy < window.lastPosition.accuracy * 0.6);
    if (distance > 8 || accuracyImproved) {
        userMarker.setLatLng([newPosition.lat, newPosition.lng]);
        window.lastPosition = newPosition;
        window.positionBuffer = [newPosition];
        window.lastUpdateTime = currentTime;
        if (typeof updateDistanceBox === 'function') updateDistanceBox();
        return true;
    }
    return false;
}

// CONFIGURATION
const _ul_SPEED_FACTOR_BRACKETS = [
  { threshold: 0.5, base: 0.12, factorMult: 0.10, max: 0.24, min: 0.08 },
  { threshold: 2, base: 0.20, factorMult: 0.12, max: 0.34, min: 0.15 },
  { threshold: 5, base: 0.30, factorMult: 0.16, max: 0.42, min: 0.25 },
  { threshold: 10, base: 0.32, factorMult: 0.21, max: 0.42, min: 0.26 },
  { threshold: 20, base: 0.52, factorMult: 0.16, max: 0.42, min: 0.45 },
  { threshold: 35, base: 0.62, factorMult: 0.14, max: 0.42, min: 0.55 },
  { threshold: 50, base: 0.70, factorMult: 0.11, max: 0.42, min: 0.65 },
  { threshold: 65, base: 0.76, factorMult: 0.10, max: 0.42, min: 0.72 },
  { threshold: 80, base: 0.81, factorMult: 0.08, max: 0.42, min: 0.78 },
  { threshold: Infinity, base: 0.85, factorMult: 0.06, max: 0.42, min: 0.82 }
];

const _ul_DURATION_BRACKETS = [
  { threshold: 0.5, base: 1.2, factorMult: -0.09, max: 1.5, min: 0.9 },
  { threshold: 2, base: 0.95, factorMult: -0.11, max: 1.2, min: 0.70 },
  { threshold: 5, base: 0.75, factorMult: -0.09, max: 0.95, min: 0.55 },
  { threshold: 10, base: 0.55, factorMult: -0.08, max: 0.75, min: 0.40 },
  { threshold: 20, base: 0.45, factorMult: -0.06, max: 0.60, min: 0.33 },
  { threshold: 35, base: 0.41, factorMult: -0.04, max: 0.50, min: 0.32 },
  { threshold: 50, base: 0.36, factorMult: -0.03, max: 0.43, min: 0.26 },
  { threshold: 65, base: 0.28, factorMult: -0.025, max: 0.35, min: 0.20 },
  { threshold: 80, base: 0.23, factorMult: -0.02, max: 0.30, min: 0.16 },
  { threshold: Infinity, base: 0.18, factorMult: -0.015, max: 0.24, min: 0.12 }
];

const _ul_LOOK_AHEAD_BRACKETS = [
  { threshold: 0.5, base: 0, factorMult: 0.015, max: 0.020 },
  { threshold: 2, base: 0, factorMult: 0.030, max: 0.050 },
  { threshold: 5, base: 0, factorMult: 0.060, max: 0.090 },
  { threshold: 10, base: 0, factorMult: 0.095, max: 0.135 },
  { threshold: 20, base: 0, factorMult: 0.145, max: 0.200 },
  { threshold: 35, base: 0, factorMult: 0.210, max: 0.295 },
  { threshold: 50, base: 0, factorMult: 0.280, max: 0.395 },
  { threshold: 65, base: 0, factorMult: 0.360, max: 0.495 },
  { threshold: 80, base: 0, factorMult: 0.450, max: 0.595 },
  { threshold: Infinity, base: 0, factorMult: 0.560, max: 0.720 }
];

// PURE LOGIC HELPERS
function _ul_calculateInstantVelocity(newPos, lastPos, timeDelta) {
  if (!lastPos || timeDelta <= 0) return { lat: 0, lng: 0 };
  return {
    lat: (newPos.lat - lastPos.lat) / timeDelta,
    lng: (newPos.lng - lastPos.lng) / timeDelta
  };
}

function _ul_smoothVelocity(lastSmoothed, instant, factor = 0.7) {
  return {
    lat: lastSmoothed.lat * factor + instant.lat * (1 - factor),
    lng: lastSmoothed.lng * factor + instant.lng * (1 - factor)
  };
}

function _ul_predictPosition(position, headingDeg, speedMPS, predictionFactor = 0.5) {
  if (!position || speedMPS <= 0) return { ...position };
  const headingRad = (headingDeg || 0) * Math.PI / 180;
  const earthRadiusMeters = 111111; // Approx meters per degree latitude
  const latOffset = (speedMPS * Math.cos(headingRad) / earthRadiusMeters) * predictionFactor;
  const lngOffset = (speedMPS * Math.sin(headingRad) / (earthRadiusMeters * Math.cos(position.lat * Math.PI / 180))) * predictionFactor;
  return {
    lat: position.lat + latOffset,
    lng: position.lng + lngOffset,
    accuracy: position.accuracy,
    heading: headingDeg,
    timestamp: position.timestamp,
    speedMPS: speedMPS
  };
}

function _ul_applyExponentialSmoothing(buffer, currentTime, decayRate = 0.5) {
  if (buffer.length === 0) return null;
  let totalWeight = 0;
  let weightedLat = 0;
  let weightedLng = 0;
  for (const pos of buffer) {
    const ageSec = (currentTime - pos.timestamp) / 1000;
    const weight = Math.exp(-ageSec * decayRate);
    weightedLat += pos.lat * weight;
    weightedLng += pos.lng * weight;
    totalWeight += weight;
  }
  return totalWeight > 0 ? {
    lat: weightedLat / totalWeight,
    lng: weightedLng / totalWeight,
    accuracy: buffer[buffer.length - 1].accuracy,
    heading: buffer[buffer.length - 1].heading,
    timestamp: currentTime,
    speedMPS: buffer[buffer.length - 1].speedMPS
  } : null;
}

function _ul_computeSmoothingFactor(speedTierIndex, speedFactor, distance, timeDelta, directionChangeFactor, eastWestMovement) {
  const bracket = _ul_SPEED_FACTOR_BRACKETS[speedTierIndex] || _ul_SPEED_FACTOR_BRACKETS[_ul_SPEED_FACTOR_BRACKETS.length - 1];
  const base = Math.min(bracket.max, Math.max(bracket.min, bracket.base + speedFactor * bracket.factorMult));
  const distAdj = Math.min(0.06, distance * 0.004);
  const timeAdj = timeDelta > 0 ? Math.min(0.04, Math.max(-0.02, (timeDelta - 0.4) * 0.05)) : 0;
  const ewBonus = eastWestMovement ? 0.02 : 0;
  const raw = base + distAdj + timeAdj + ewBonus;
  const clamped = Math.min(0.42, Math.max(0.08, raw));
  return clamped * directionChangeFactor;
}

function _ul_computeAnimationDuration(speedTierIndex, speedFactor, distance, timeDelta, directionChangeFactor, eastWestMovement) {
  const bracket = _ul_DURATION_BRACKETS[speedTierIndex] || _ul_DURATION_BRACKETS[_ul_DURATION_BRACKETS.length - 1];
  const base = Math.min(bracket.max, Math.max(bracket.min, bracket.base + speedFactor * bracket.factorMult));
  const distMod = Math.min(0.04, distance * 0.0015);
  const timeMod = timeDelta > 0 ? Math.max(-0.015, Math.min(0.03, (0.25 - timeDelta) * 0.05)) : 0;
  const ewBonus = eastWestMovement ? Math.min(0.03, distance * 0.0006) : 0;
  const raw = base - distMod + timeMod + ewBonus;
  return Math.max(0.025, raw * directionChangeFactor);
}

function _ul_computeLookAheadFactor(speedTierIndex, speedFactor, distance, eastWestMovement) {
  const bracket = _ul_LOOK_AHEAD_BRACKETS[speedTierIndex] || _ul_LOOK_AHEAD_BRACKETS[_ul_LOOK_AHEAD_BRACKETS.length - 1];
  const base = Math.min(bracket.max, bracket.base + speedFactor * bracket.factorMult);
  const distBoost = Math.min(0.09, distance * 0.006);
  const ewBonus = eastWestMovement ? Math.min(0.06, distance * 0.0015) : 0;
  return Math.min(0.75, Math.max(0.01, base + distBoost + ewBonus));
}

function _ul_interpolatePosition(a, b, factor) {
  return {
    lat: a.lat * (1 - factor) + b.lat * factor,
    lng: a.lng * (1 - factor) + b.lng * factor,
    accuracy: b.accuracy,
    heading: b.heading,
    timestamp: b.timestamp,
    speedMPS: b.speedMPS
  };
}

function _ul_computeLookAheadPosition(current, last, buffered, factor) {
  return {
    lat: current.lat + (buffered.lat - last.lat) * factor,
    lng: current.lng + (buffered.lng - last.lng) * factor
  };
}

// SIDE EFFECTS & UI (COORDINATED)
let _ul_pendingVisualUpdate = null;

function _ul_scheduleVisualUpdate(fn) {
  if (_ul_pendingVisualUpdate) {
    cancelAnimationFrame(_ul_pendingVisualUpdate);
  }
  _ul_pendingVisualUpdate = requestAnimationFrame(() => {
    _ul_pendingVisualUpdate = null;
    try {
      fn();
    } catch (err) {
      console.error('Visual update failed:', err);
    }
  });
}

/* Performs smoothing, prediction, and schedules visual updates. */
function _ul_performSmoothingAndPrediction(
  newPosition,
  currentTime,
  timeDelta,
  validatedHeading,
  speedTierIndex,
  eastWestMovement,
  directionChangeFactor,
  speedFactor,
  lastPosition
) {
  // --- Input validation ---
  if (!newPosition || !lastPosition || typeof currentTime !== 'number') {
    console.warn('Invalid inputs to _ul_performSmoothingAndPrediction');
    return;
  }

  // --- Initialize state if missing ---
  if (!window.lastVelocity) window.lastVelocity = { lat: 0, lng: 0 };
  if (!window.smoothedVelocity) window.smoothedVelocity = { lat: 0, lng: 0 };
  if (!window.positionBuffer) window.positionBuffer = [];

  // Velocity smoothing ---
  const instantVelocity = _ul_calculateInstantVelocity(newPosition, lastPosition, timeDelta);
  window.smoothedVelocity = _ul_smoothVelocity(window.smoothedVelocity, instantVelocity, 0.7);

  // Dead reckoning ---
  const predicted = _ul_predictPosition(newPosition, validatedHeading, newPosition.speedMPS || 0, 0.5);
  window.positionBuffer.push({ ...predicted, timestamp: currentTime });
  if (window.positionBuffer.length > 5) window.positionBuffer.shift();

  // Temporal smoothing ---
  const bufferedPosition = _ul_applyExponentialSmoothing(window.positionBuffer, currentTime);
  if (!bufferedPosition) {
    console.warn('Failed to compute buffered position');
    return;
  }

  // Final smoothing ---
  const distance = calculateDistance?.(lastPosition, newPosition) || 0;
  const smoothingFactor = _ul_computeSmoothingFactor(
    speedTierIndex, speedFactor, distance, timeDelta, directionChangeFactor, eastWestMovement
  );
  const smoothedPosition = _ul_interpolatePosition(lastPosition, bufferedPosition, smoothingFactor);

  // Animation parameters ---
  const animationDuration = _ul_computeAnimationDuration(
    speedTierIndex, speedFactor, distance, timeDelta, directionChangeFactor, eastWestMovement
  );
  const speedMPH = (newPosition.speedMPS || 0) * 2.23694;
  const easeLinearity = eastWestMovement
    ? Math.max(0.03, Math.min(0.16, (0.10 - speedMPH * 0.0007) * directionChangeFactor))
    : Math.max(0.04, Math.min(0.20, (0.12 - speedMPH * 0.0013) * directionChangeFactor));

  // Schedule visual update (debounced) ---
  _ul_scheduleVisualUpdate(() => {
    _ul_applyMarkerUpdate(smoothedPosition, animationDuration, easeLinearity, speedMPH);
    _ul_updateMapIfNeeded(smoothedPosition, lastPosition, bufferedPosition, speedMPH, speedTierIndex, speedFactor, eastWestMovement, directionChangeFactor, distance, currentTime);
    _ul_enforceViewportBounds(smoothedPosition, speedMPH, currentTime);
  });

  // --- Update global state ---
  window.lastPosition = smoothedPosition;
  window.lastVelocity = instantVelocity;
  window.lastUpdateTime = currentTime;
  window.lastUpdateTimestamp = currentTime;
  if (typeof updateDistanceBox === 'function') updateDistanceBox();
}

// VISUAL SUB-ROUTINES
function _ul_applyMarkerUpdate(position, duration, easeLinearity, speedMPH) {
  if (!userMarker || typeof userMarker.setLatLng !== 'function') return;

  const markerEl = userMarker.getElement?.();
  if (markerEl) {
    markerEl.style.willChange = 'transform';
    markerEl.style.backfaceVisibility = 'hidden';
    markerEl.style.transform = 'translateZ(0)';
    if (speedMPH > 5) markerEl.style.imageRendering = 'crisp-edges';
  }

  const animate = speedMPH > 0.1;
  const opts = animate ? { animate: true, duration, easeLinearity } : {};

  if (speedMPH > 30) {
    requestAnimationFrame(() => {
      userMarker.setLatLng([position.lat, position.lng], opts);
      if (markerEl) markerEl.style.willChange = 'auto';
    });
  } else {
    userMarker.setLatLng([position.lat, position.lng], opts);
    if (markerEl) requestAnimationFrame(() => markerEl.style.willChange = 'auto');
  }
}

function _ul_updateMapIfNeeded(smoothedPos, lastPos, bufferedPos, speedMPH, speedTierIndex, speedFactor, eastWestMovement, directionChangeFactor, distance, currentTime) {
  if (!window.followUser || window.isMapInteracting || !map) return;

  const speedTier = _ul_getSpeedTier?.(speedTierIndex);
  if (!speedTier) return;

  const mapUpdateInterval = speedTier.mapUpdateInterval;
  const aggressiveness = typeof speedAggressiveness === 'function' ? speedAggressiveness(speedMPH) : 0;
  let mapUpdateDistanceThreshold = speedTier.mapUpdateDistance * (1 - 0.4 * aggressiveness);
  if (eastWestMovement) mapUpdateDistanceThreshold *= 0.9;

  const shouldUpdate = (currentTime - (window.lastMapUpdateTime || 0) > mapUpdateInterval) ||
                       (distance > mapUpdateDistanceThreshold);

  if (!shouldUpdate) return;

  // Proximity zoom logic
  _ul_handleProximityZoom(currentTime);

  // Pan/zoom logic
  const lookAheadFactor = _ul_computeLookAheadFactor(speedTierIndex, speedFactor, distance, eastWestMovement);
  const lookAheadPos = _ul_computeLookAheadPosition(smoothedPos, lastPos, bufferedPos, lookAheadFactor);

  if (speedMPH >= 10) {
    _ul_panMapTo(lookAheadPos, speedTier, directionChangeFactor, eastWestMovement);
  } else {
    const bounds = map.getBounds?.();
    if (!bounds) return;
    const isNearEdge = _ul_isMarkerNearMapEdge(smoothedPos, bounds, map);
    if (isNearEdge || !bounds.contains?.(smoothedPos)) {
      _ul_panMapTo(lookAheadPos, speedTier, directionChangeFactor, eastWestMovement);
    }
  }

  // Speed-based zoom
  const intelligentZoom = typeof getSpeedBasedZoom === 'function' ? getSpeedBasedZoom((smoothedPos.speedMPS || 0)) : null;
  if (intelligentZoom && !window.blockSpeedZoom) {
    const currentZoom = map.getZoom?.();
    if (currentZoom !== undefined && Math.abs(currentZoom - intelligentZoom) >= speedTier.zoomThreshold) {
      _ul_zoomMapTo(intelligentZoom, speedTier.zoomDuration * directionChangeFactor, speedMPH);
    }
  }

  window.lastMapUpdateTime = currentTime;
}

// Module-level constants
const PROXIMITY_ZOOM_IN_FEET = 60;
const PROXIMITY_ZOOM_OUT_FEET = 90; // 1.5x hysteresis
const PROXIMITY_ZOOM_IN_LEVEL = 19;
const PROXIMITY_ZOOM_OUT_LEVEL = 17;
const PROXIMITY_ZOOM_COOLDOWN_IN = 2000;
const PROXIMITY_ZOOM_COOLDOWN_OUT = 3000;
const SPEED_ZOOM_BLOCK_DURATION = 5000;

function _ul_handleProximityZoom(currentTime) {
  if (!window.lastClosestDistance || window.lastClosestDistance === Infinity) return;
  if (!map?.setZoom || typeof currentTime !== 'number') return;
  
  const distanceFeet = window.lastClosestDistance * 3.28084;
  
  // Validate distance is reasonable
  if (!isFinite(distanceFeet) || distanceFeet < 0) return;
  
  const now = currentTime;
  const lastZoomChange = window.lastZoomChangeTime || 0;
  
  // ZOOM IN when approaching
  if (!window.zoomedInState && distanceFeet <= PROXIMITY_ZOOM_IN_FEET) {
    if ((now - lastZoomChange) < PROXIMITY_ZOOM_COOLDOWN_IN) return;
    
    window.zoomedInState = true;
    window.isNearLocation = true;
    window.lastZoomChangeTime = now;
    
    // Clear existing timer before setting new one
    if (window.blockSpeedZoomTimer) {
      clearTimeout(window.blockSpeedZoomTimer);
    }
    window.blockSpeedZoom = true;
    window.blockSpeedZoomTimer = setTimeout(() => {
      window.blockSpeedZoom = false;
      window.blockSpeedZoomTimer = null;
    }, SPEED_ZOOM_BLOCK_DURATION);
    
    if (!window.isMapInteracting) {
      map.setZoom(PROXIMITY_ZOOM_IN_LEVEL, { 
        animate: true, 
        duration: 0.4, 
        easeLinearity: 0.15 
      });
    }
  }
  
  // ZOOM OUT when leaving
  else if (window.zoomedInState && distanceFeet >= PROXIMITY_ZOOM_OUT_FEET) {
    if ((now - lastZoomChange) < PROXIMITY_ZOOM_COOLDOWN_OUT) return;
    
    window.zoomedInState = false;
    window.isNearLocation = false;
    window.lastZoomChangeTime = now;
    
    // Clear existing timer before setting new one
    if (window.blockSpeedZoomTimer) {
      clearTimeout(window.blockSpeedZoomTimer);
    }
    window.blockSpeedZoom = true;
    window.blockSpeedZoomTimer = setTimeout(() => {
      window.blockSpeedZoom = false;
      window.blockSpeedZoomTimer = null;
    }, SPEED_ZOOM_BLOCK_DURATION);
    
    if (!window.isMapInteracting) {
      map.setZoom(PROXIMITY_ZOOM_OUT_LEVEL, { 
        animate: true, 
        duration: 0.6, 
        easeLinearity: 0.15 
      });
    }
  }
}

function _ul_panMapTo(target, speedTier, directionChangeFactor, eastWestMovement) {
  if (!map?.panTo || !map.getContainer) return;
  const duration = speedTier.panDuration * directionChangeFactor * (eastWestMovement ? 0.9 : 1);
  const easeLinearity = speedTier.easeLinearity * (eastWestMovement ? 0.8 : 1);
  const container = map.getContainer();
  container.style.willChange = 'transform';
  const cleanup = () => { container.style.willChange = 'auto'; };

  if (typeof target.lat !== 'number' || typeof target.lng !== 'number') return;

  if ((target.lat > 90 || target.lat < -90) || (target.lng > 180 || target.lng < -180)) return;

  if ((target.lat > 85 || target.lat < -85)) return; // Avoid polar distortion

  map.panTo(target, {
    animate: true,
    duration,
    easeLinearity,
    noMoveStart: true
  });

  requestAnimationFrame(cleanup);
}

function _ul_zoomMapTo(zoomLevel, duration, speedMPH) {
  if (!map?.setZoom || !map.getContainer) return;
  const container = map.getContainer();
  const originalOverflow = container.style.overflow;
  container.style.overflow = 'hidden';
  const resetOverflow = () => { container.style.overflow = originalOverflow; };

  map.setZoom(zoomLevel, {
    animate: true,
    duration,
    noMoveStart: true
  });

  setTimeout(resetOverflow, duration * 1000 + 50);
}

function _ul_isMarkerNearMapEdge(position, bounds, mapInstance) {
  try {
    const pixel = mapInstance.latLngToContainerPoint?.(position);
    const size = mapInstance.getSize?.();
    if (!pixel || !size) return false;
    const EDGE_MARGIN = 0.05;
    return (
      pixel.x < size.x * EDGE_MARGIN ||
      pixel.x > size.x * (1 - EDGE_MARGIN) ||
      pixel.y < size.y * EDGE_MARGIN ||
      pixel.y > size.y * (1 - EDGE_MARGIN)
    );
  } catch (e) {
    return false;
  }
}

function _ul_enforceViewportBounds(position, speedMPH, currentTime) {
  if (!window.followUser || window.isMapInteracting || !map || !userMarker) return;
  const HARD_EDGE_LIMIT = 0.02;
  const CHECK_INTERVAL = 200;
  if (currentTime - (window.lastViewportCheck || 0) <= CHECK_INTERVAL) return;
  window.lastViewportCheck = currentTime;

  try {
    const currentPos = userMarker.getLatLng?.();
    const bounds = map.getBounds?.();
    const size = map.getSize?.();
    if (!currentPos || !bounds || !size) return;

    const pixel = map.latLngToContainerPoint(currentPos);
    const xMargin = size.x * HARD_EDGE_LIMIT;
    const yMargin = size.y * HARD_EDGE_LIMIT;
    const violates = (
      pixel.x < xMargin ||
      pixel.x > size.x - xMargin ||
      pixel.y < yMargin ||
      pixel.y > size.y - yMargin ||
      !bounds.contains(currentPos)
    );

    if (violates) {
      const container = map.getContainer();
      container.style.willChange = 'transform';
      const cleanup = () => { container.style.willChange = 'auto'; };
      const target = currentPos;

      if (speedMPH > 50) {
        requestAnimationFrame(() => {
          map.panTo(target, { animate: false, noMoveStart: true });
          cleanup();
        });
      } else if (speedMPH > 20) {
        map.panTo(target, { animate: true, duration: 0.25, easeLinearity: 0.25, noMoveStart: true });
        requestAnimationFrame(cleanup);
      } else {
        map.panTo(target, { animate: true, duration: 0.4, easeLinearity: 0.18, noMoveStart: true });
        requestAnimationFrame(cleanup);
      }
      window.lastCenteringTime = currentTime;
    }
  } catch (e) {
    console.warn('Viewport enforcement failed:', e);
  }
}
        
/* Processes a normalized user position update. */
async function updateUserLocation(position, forceUpdate = false) {
    const now = performance.now();

    // DEBOUNCE LOGIC
    if (!forceUpdate && (now - (_ul_lastDebounceTime || 0)) < 100) {
        if (_ul_debounceTimeoutId) clearTimeout(_ul_debounceTimeoutId);
        _ul_pendingPosition = position;
        _ul_pendingForceUpdate = forceUpdate;
        _ul_debounceTimeoutId = setTimeout(() => {
            if (_ul_pendingPosition) {
                updateUserLocation(_ul_pendingPosition, _ul_pendingForceUpdate);
                _ul_pendingPosition = null;
                _ul_pendingForceUpdate = false;
            }
        }, 100 - (now - (_ul_lastDebounceTime || 0)));
        return;
    }

    _ul_lastDebounceTime = now;
    if (_ul_debounceTimeoutId) {
        clearTimeout(_ul_debounceTimeoutId);
        _ul_debounceTimeoutId = null;
    }

    // EARLY EXIT: CANCEL PENDING ANIMATIONS
    if (typeof window._nextLocationUpdateRAF !== 'undefined' && window._nextLocationUpdateRAF !== null) {
        cancelAnimationFrame(window._nextLocationUpdateRAF);
        window._nextLocationUpdateRAF = null;
    }

    // GPS TIMEOUT
    _ul_setGpsTimeout();

    // USE POSITION TIMESTAMP FOR CONSISTENCY
    const currentTime = position.timestamp || Date.now();
    const lastUpdateTime = window.lastUpdateTime || currentTime;
    const timeDelta = (currentTime - lastUpdateTime) / 1000; // seconds

    // HANDLE FIRST POSITION
    if (!window.lastPosition) {
        console.log("Initializing first user position");
        window.lastPosition = {
            lat: position.lat,
            lng: position.lng,
            accuracy: position.accuracy || 20,
            heading: position.heading ?? null,
            timestamp: currentTime,
            speedMPS: position.speedMPS || 0
        };
        window.positionBuffer = [{ ...window.lastPosition }];
        window.lastUpdateTime = currentTime;
        window.lastUpdateTimestamp = currentTime;
        
        // Immediate UI update with accuracy indicator
        if (userMarker?.setLatLng) {
            userMarker.setLatLng([position.lat, position.lng]);
        }
        if (typeof updateAccuracyIndicator === 'function') {
            updateAccuracyIndicator(position.accuracy || 20);
        }
        if (typeof updateDistanceBox === 'function') updateDistanceBox();
        return;
    }

    // BUILD NEW POSITION OBJECT
    const newPosition = {
        lat: position.lat,
        lng: position.lng,
        accuracy: position.accuracy || 20,
        heading: position.heading ?? null,
        timestamp: currentTime,
        speedMPS: position.speedMPS || 0
    };

    // EARLY RETURN HANDLERS
    if (_ul_handleBackgroundUpdate(newPosition, currentTime, forceUpdate)) return;
    
    const isLowPower = await _ul_checkLowPowerMode();
    if (_ul_handleLowPowerMode(newPosition, currentTime, isLowPower, forceUpdate)) return;
    
    _ul_handleGpsRecovery();
    
    const hasMoved = 
        Math.abs(newPosition.lat - window.lastPosition.lat) > 0.000001 ||
        Math.abs(newPosition.lng - window.lastPosition.lng) > 0.000001;
    _ul_calculateProximity(newPosition, hasMoved);
    
    if (_ul_handleFirstFix(newPosition, currentTime)) return;

    // DERIVED METRICS 
    const distance = calculateDistance(window.lastPosition, newPosition);
    const speedMPH = newPosition.speedMPS * 2.23694;
    const latDelta = Math.abs(newPosition.lat - window.lastPosition.lat);
    const lngDelta = Math.abs(newPosition.lng - window.lastPosition.lng);
    const eastWestMovement = lngDelta > latDelta * 1.2;

    if (_ul_checkAcceleration(window.lastPosition, newPosition, timeDelta)) return;

    const validatedHeading = _ul_validateHeading(window.lastPosition, newPosition);

    let headingDiff = 0;
    let directionChangeFactor = 1.0;
    if (window.lastPosition.heading != null && validatedHeading != null) {
        headingDiff = Math.abs(validatedHeading - window.lastPosition.heading);
        if (headingDiff > 180) headingDiff = 360 - headingDiff;
        if (headingDiff > 12) directionChangeFactor = Math.max(0.4, 1 - (headingDiff / 200));
    }

    const speedFactor = Math.min(1, Math.max(0.01, newPosition.speedMPS / 15));
    const speedTierIndex = _ul_getSpeedTierIndex(speedMPH);
    const speedTier = _ul_getSpeedTier(speedTierIndex);

    // Apply east-west adjustments
    speedTier.panDuration *= eastWestMovement ? 0.85 : 1.0;
    speedTier.easeLinearity *= eastWestMovement ? 0.9 : 1.0;
    speedTier.mapUpdateInterval = Math.max(33, speedTier.mapUpdateInterval * (eastWestMovement ? 0.85 : 1.0));

    // QUALITY GATES 
    if (_ul_handleLargeJump(newPosition, currentTime, distance, forceUpdate)) return;
    if (_ul_handleStationaryLogic(newPosition, currentTime, distance)) return;
    if (!_ul_passesQualityGate(newPosition, distance, timeDelta, speedTier, eastWestMovement) && !forceUpdate) return;
    if (_ul_handleEarlyReturnForStationary(newPosition, currentTime, speedMPH, distance)) return;
    if (_ul_handleAccuracyJump(newPosition, distance, currentTime)) return;

    // MAIN UPDATE
    try {
        _ul_performSmoothingAndPrediction(
            newPosition,
            currentTime,
            timeDelta,
            validatedHeading,
            speedTierIndex,
            eastWestMovement,
            directionChangeFactor,
            speedFactor,
            window.lastPosition
        );
    } catch (error) {
        console.error("Location update error:", error);
        
        // Clean up ALL animation frames to prevent freeze
        if (window.animationFrameId) {
            cancelAnimationFrame(window.animationFrameId);
            window.animationFrameId = null;
        }
        if (window._nextLocationUpdateRAF) {
            cancelAnimationFrame(window._nextLocationUpdateRAF);
            window._nextLocationUpdateRAF = null;
        }
        
        // Fallback: direct update
        if (userMarker?.setLatLng) {
            userMarker.setLatLng([newPosition.lat, newPosition.lng], {
                animate: true,
                duration: 0.6,
                easeLinearity: 0.10
            });
        }
        
        window.lastPosition = newPosition;
        window.positionBuffer = [newPosition];
        window.lastUpdateTime = currentTime;
        window.lastUpdateTimestamp = currentTime;
        
        // Update accuracy indicator on fallback
        if (typeof updateAccuracyIndicator === 'function') {
            updateAccuracyIndicator(newPosition.accuracy);
        }
        if (typeof updateDistanceBox === 'function') updateDistanceBox();
    }
}
        
function _udb_showInitializingState(distanceBox) {
    distanceBox.textContent = 'Initializing...';
    resetDistanceBoxStyling(distanceBox);
}
            
/* Updates the distance box UI with the closest location distance and handles auto-open logic. */
function updateDistanceBox() {
    const distanceBox = _udb_getDistanceBoxElement();
    if (!distanceBox) return;

    // Preserve original logging if needed (e.g., for debugging)
    // console.log("updateDistanceBox called at:", new Date().toISOString());

    if (!_udb_isSystemReady()) {
        _udb_showInitializingState(distanceBox);
        return;
    }

    const userPos = _udb_getValidUserPosition();
    if (!userPos) {
        _udb_showInitializingState(distanceBox);
        return;
    }

    const { closestDistance, closestLocation } = _udb_findClosestLocation(userPos);
    if (!isFinite(closestDistance) || closestDistance === Infinity) {
        _udb_showInitializingState(distanceBox);
        return;
    }

    // Compute derived values once
    const distanceFeet = Math.round(closestDistance * 3.28084);
    const isArrived = distanceFeet <= CONFIG.DISTANCE_THRESHOLD;

    // Update global state exactly as before
    window.lastClosestDistance = closestDistance;
    window.currentlyArrived = isArrived;

    // Update UI
    _udb_updateDistanceDisplay(distanceBox, distanceFeet, closestLocation, isArrived);
    _udb_handleAutoOpenLogic(distanceFeet, closestLocation, isArrived);
}

// PRIVATE HELPERS 
function _udb_getDistanceBoxElement() {
    const distanceBox = cachedElements?.distanceBox || document.getElementById('distanceBox');
    if (!distanceBox) {
        console.warn('Distance box element not found');
    }
    return distanceBox;
}

function _udb_isSystemReady() {
    return userMarker && gameLocations && Array.isArray(gameLocations) && gameLocations.length > 0;
}

function _udb_getValidUserPosition() {
    try {
        const userLatLng = userMarker.getLatLng();
        let userLat = userLatLng?.lat;
        let userLng = userLatLng?.lng;

        if (!isFinite(userLat) || !isFinite(userLng)) {
            console.warn('Invalid user coordinates:', userLat, userLng);
            return null;
        }

        // Handle (0,0) fallback exactly as original
        if (userLat === 0 && userLng === 0 && map?.getCenter) {
            const center = map.getCenter();
            userLat = center.lat;
            userLng = center.lng;
        }

        return { lat: userLat, lng: userLng };
    } catch (e) {
        console.warn('Failed to get user position:', e);
        return null;
    }
}

function _udb_findClosestLocation(userPos) {
    let closestDistance = Infinity;
    let closestLocation = null;

    for (const location of gameLocations) {
        if (!_udb_isValidLocation(location)) {
            console.warn('Invalid location data:', location);
            continue;
        }

        const distance = calculateDistance?.(userPos, { lat: location.lat, lng: location.lng });
        if (isFinite(distance) && distance < closestDistance) {
            closestDistance = distance;
            closestLocation = location;
        }
    }

    return { closestDistance, closestLocation };
}

function _udb_isValidLocation(location) {
    return location && typeof location.lat === 'number' && typeof location.lng === 'number';
}

function _udb_updateDistanceDisplay(distanceBox, distanceFeet, closestLocation, isArrived) {
    if (isArrived) {
        distanceBox.textContent = 'Arrived.';
        _udb_applyArrivedStyling(distanceBox);
    } else {
        const distanceText = distanceFeet < 5280
            ? `${distanceFeet.toLocaleString()} feet`
            : `${(distanceFeet / 5280).toFixed(2)} miles`;
        distanceBox.textContent = `Closest Stop: ${distanceText}`;
        _udb_applyDefaultStyling(distanceBox);
    }

    _udb_applyBorderStyling(distanceBox, closestLocation, distanceFeet, isArrived);
}

function _udb_handleAutoOpenLogic(distanceFeet, closestLocation, isArrived) {
    if (!isArrived || !closestLocation?.id) {
        return;
    }

    // Safely check if location hunt is visible (supports both boolean and function)
    let huntVisible = false;
    if (typeof isLocationHuntVisible === 'function') {
        huntVisible = isLocationHuntVisible();
    } else if (typeof isLocationHuntVisible === 'boolean') {
        huntVisible = isLocationHuntVisible;
    }
    if (huntVisible) return;

    // Use cooldown manager if available
    if (window.cooldownManager) {
        const cooldownStatus = window.cooldownManager.checkCooldown(closestLocation.id);
        if (!cooldownStatus?.isOnCooldown) {
            _udb_triggerAutoOpen(closestLocation);
        }
    } else {
        console.warn("LocationCooldownManager not available in updateDistanceBox");
        // Do NOT fall back to old dwell logic â€” matches original intent
    }
}

function _udb_triggerAutoOpen(location) {
    const now = performance.now();
    if (now - (window._lastAutoOpenTrigger || 0) > 1000) {
        window._lastAutoOpenTrigger = now;
        console.log(`Auto-opening location ${location.id} via updateDistanceBox (cooldown manager says OK).`);
        
        if (typeof showLocationHunt === 'function') {
            showLocationHunt(location);
        }
    }
}

// STYLING FUNCTIONS 
function resetDistanceBoxStyling(element) {
    element.style.background = 'white';
    element.style.color = 'var(--dark-blue)';
    element.style.fontWeight = 'normal';
    element.style.border = '3px solid var(--dark-blue)';
}

function _udb_applyArrivedStyling(element) {
    element.style.background = 'white';
    element.style.color = 'var(--dark-blue)';
    element.style.fontWeight = 'bold';
}

function _udb_applyDefaultStyling(element) {
    element.style.background = 'white';
    element.style.color = 'var(--dark-blue)';
    element.style.fontWeight = 'normal';
}

function _udb_applyBorderStyling(element, closestLocation, distanceFeet, isArrived) {
    if (isArrived) {
        element.style.border = '3px solid darkred';
    } else if (closestLocation && closestLocation.markerColor) {
        let borderWidth = '3px';
        if (distanceFeet > 500) borderWidth = '1px';
        else if (distanceFeet > 100) borderWidth = '2px';
        element.style.border = `${borderWidth} solid ${closestLocation.markerColor}`;
    } else {
        element.style.border = '3px solid var(--dark-blue)';
    }
}
        
function calculateDistance(pos1, pos2) {
    if (!pos1 || !pos2 || 
        typeof pos1.lat !== 'number' || typeof pos1.lng !== 'number' || 
        typeof pos2.lat !== 'number' || typeof pos2.lng !== 'number') {
        return Infinity;
    }
    
    const R = 6371000;
    const lat1 = pos1.lat * Math.PI / 180;
    const lat2 = pos2.lat * Math.PI / 180;
    const deltaLat = (pos2.lat - pos1.lat) * Math.PI / 180;
    const deltaLng = (pos2.lng - pos1.lng) * Math.PI / 180;
    const a = Math.sin(deltaLat/2) * Math.sin(deltaLat/2) +
            Math.cos(lat1) * Math.cos(lat2) *
            Math.sin(deltaLng/2) * Math.sin(deltaLng/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return R * c;
}

function getGeolocationOptions(speedMPS = 0) {
    const isStationary = speedMPS < 0.5;    // < 1 mph
    const isMoving = speedMPS >= 2;         // > 4.5 mph
    // Walking: 0.5 <= speedMPS < 2 (1-4.5 mph)
    
    return {
        enableHighAccuracy: !isStationary,
        timeout: isMoving ? 15000 : isStationary ? 10000 : 12000,
        maximumAge: isStationary ? 60000 : isMoving ? 5000 : 15000
    };
}

/* Handles geolocation errors with retry logic. */
function handleLocationError(error) {
    console.warn("Error getting user location:", error);

    // Use global retryCount (as expected by rest of app)
    const retryCount = window.retryCount || 0;
    const config = {
        MAX_RETRIES: CONFIG?.MAX_RETRIES ?? 3,
        RETRY_DELAY: CONFIG?.RETRY_DELAY ?? 2000
    };

    if (retryCount < config.MAX_RETRIES) {
        const newRetryCount = retryCount + 1;
        window.retryCount = newRetryCount; // update global state
        console.log(`Retrying to get location (Attempt ${newRetryCount} of ${config.MAX_RETRIES})`);

        const currentRetryDelay = config.RETRY_DELAY * newRetryCount;

        setTimeout(() => {
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    console.log("Location retrieved successfully after retry");
                    hideLoadingMessage();
                    updateUserLocation(position, true);
                    window.retryCount = 0; // reset global
                },
                handleLocationError,
                getGeolocationOptions(newRetryCount)
            );
        }, currentRetryDelay);
        return;
    }

    // Max retries reached â€” reset and show error
    window.retryCount = 0;
    hideLoadingMessage();

    const errorMessage = _hle_getUserFriendlyMessage(error);
    showPopup("Location Error", errorMessage);
    
    if (typeof onLocationFailure === 'function') {
        onLocationFailure(error);
    }
}

// Keep this helper for clarity (no state)
function _hle_getUserFriendlyMessage(error) {
    if (error?.code !== undefined) {
        switch (error.code) {
            case 1:
                return "Please allow access to your location to use this feature.";
            case 2:
                return "Your location is currently unavailable. Please try again later.";
            case 3:
                return "Getting your location took too long. Please try again.";
            case 0:
                return "Unable to determine your location. Please check your device settings and try again.";
            default:
                return "An error occurred while getting your location.";
        }
    }
    return "An error occurred while getting your location.";
}

function showPopup(title, message, type = "info", callback = null) {
    console.log("showPopup called with:", title, message);
    
    const existingPopups = document.querySelectorAll(".popup-overlay");
    existingPopups.forEach(popup => {
        document.body.removeChild(popup);
    });
    
    const overlay = document.createElement("div");
    overlay.className = "popup-overlay";
    overlay.style.position = "fixed";
    overlay.style.left = "0";
    overlay.style.top = "0";
    overlay.style.width = "100%";
    overlay.style.height = "100%";
    overlay.style.backgroundColor = "rgba(0, 0, 0, 0.7)";
    overlay.style.zIndex = "9999";
    
    const popupContainer = document.createElement("div");
    popupContainer.className = "popup-container";
    popupContainer.style.position = "absolute";
    popupContainer.style.left = "50%";
    popupContainer.style.top = "50%";
    popupContainer.style.transform = "translate(-50%, -50%)";
    popupContainer.style.backgroundColor = "white";
    popupContainer.style.borderRadius = "8px";
    popupContainer.style.padding = "20px";
    popupContainer.style.width = "300px";
    popupContainer.style.maxWidth = "90%";
    popupContainer.style.boxShadow = "0 4px 15px rgba(0, 0, 0, 0.2)";
    
    const titleElement = document.createElement("h3");
    titleElement.textContent = title;
    titleElement.style.margin = "0 0 15px 0";
    titleElement.style.textAlign = "center";
    titleElement.style.color = "#333";
    
    const messageElement = document.createElement("p");
    messageElement.textContent = message;
    messageElement.style.margin = "0 0 20px 0";
    messageElement.style.textAlign = "center";
    messageElement.style.color = "#555";
    
    const button = document.createElement("button");
    button.textContent = "OK";
    button.style.display = "block";
    button.style.margin = "0 auto";
    button.style.padding = "8px 20px";
    button.style.backgroundColor = "#2c5282";
    button.style.color = "white";
    button.style.border = "none";
    button.style.borderRadius = "4px";
    button.style.cursor = "pointer";
    
    button.addEventListener("click", function() {
        document.body.removeChild(overlay);
        if (callback && typeof callback === 'function') {
            callback();
        }
    });
    
    overlay.addEventListener("click", function(e) {
        if (e.target === overlay) {
            document.body.removeChild(overlay);
        }
    });
    
    popupContainer.appendChild(titleElement);
    popupContainer.appendChild(messageElement);
    popupContainer.appendChild(button);
    overlay.appendChild(popupContainer);
    document.body.appendChild(overlay);
    
    button.focus();
}

let recenterTimer;                       // single shared timer

function recenterMap() {
    const btn = cachedElements?.recenterButton ?? document.getElementById('recenterButton');
    if (!btn || !userMarker?.getLatLng()) return;

    btn.disabled = true;                 // block spam
    btn.style.backgroundColor = 'var(--primary-color)';
    btn.style.color = 'white';

    map.closePopup();
    map.panTo(userMarker.getLatLng(), {
        animate: true,
        duration: 0.5,
        easeLinearity: 0.25,
        noZoom: true
    });

    followUser = true;
    announceToScreenReader('Map re-centred on your location');

    clearTimeout(recenterTimer);
    recenterTimer = setTimeout(() => {
        btn.style.backgroundColor = 'white';
        btn.style.color = 'var(--primary-color)';
        btn.disabled = false;
    }, 500);
}

/* ---------- 2-MINUTE LOCATION COOLDOWN â€“ Exit-Based, with Live Timer ---------- */

const COOLDOWN_PERIOD = 2 * 60 * 1000; // 2 minutes
const STORAGE_KEY = 'locationCooldowns';
const DEBOUNCE_TIME = ('ontouchstart' in window || navigator.maxTouchPoints > 0) ? 500 : 300;
const CLEANUP_INTERVAL_MS = 60 * 1000;
const TOAST_UPDATE_INTERVAL_MS = 1000;

class LocationCooldownManager {
  constructor() {
    this.cooldowns = this.loadFromStorage();
    this.hiddenMsPerLoc = {};
    this.currentLocationId = null;
    this.lastActionTime = 0;
    this.hiddenAt = null;
    this.cleanupInterval = null;
    this.visibilityHandler = null;
    this.activeToast = null;
    this.toastInterval = null;
    this.locationCache = null;
    this.patchedFunctions = [];

    this.initVisibilityTracking();
    this.cleanupExpiredCooldowns();
    this.startPeriodicCleanup();
    this.patchGameFunctions();
  }

  /* ---------- VISIBILITY TRACKING ---------- */
  initVisibilityTracking() {
    this.visibilityHandler = () => {
      if (document.hidden) {
        this.hiddenAt = Date.now();
      } else if (this.hiddenAt !== null) {
        const hiddenDuration = Date.now() - this.hiddenAt;
        for (const id of Object.keys(this.cooldowns)) {
          if (!this.hiddenMsPerLoc[id]) this.hiddenMsPerLoc[id] = 0;
          this.hiddenMsPerLoc[id] += hiddenDuration;
        }
        this.hiddenAt = null;
      }
    };
    
    document.addEventListener('visibilitychange', this.visibilityHandler);
  }

  /* ---------- PERIODIC CLEANUP ---------- */
  startPeriodicCleanup() {
    this.cleanupInterval = setInterval(() => {
      this.cleanupExpiredCooldowns();
    }, CLEANUP_INTERVAL_MS);
  }

  /* ---------- STORAGE ---------- */
  loadFromStorage() {
    try {
      const data = localStorage.getItem(STORAGE_KEY);
      if (!data) return {};
      const parsed = JSON.parse(data);
      return typeof parsed === 'object' && parsed !== null ? parsed : {};
    } catch (e) {
      console.warn('Failed to load cooldowns, using empty state:', e);
      return {};
    }
  }

  saveToStorage() {
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(this.cooldowns));
    } catch (e) {
      console.error('Failed to save cooldowns to localStorage:', e);
    }
  }

  /* ---------- CLEANUP EXPIRED ENTRIES ---------- */
  cleanupExpiredCooldowns() {
    const now = Date.now();
    let modified = false;
    const activeIds = new Set();

    for (const [id, startTime] of Object.entries(this.cooldowns)) {
      const hiddenTime = this.hiddenMsPerLoc[id] || 0;
      const elapsed = now - startTime - hiddenTime;
      
      if (elapsed >= COOLDOWN_PERIOD || elapsed < 0 || !isFinite(elapsed)) {
        delete this.cooldowns[id];
        delete this.hiddenMsPerLoc[id];
        modified = true;
      } else {
        activeIds.add(id);
      }
    }

    for (const id of Object.keys(this.hiddenMsPerLoc)) {
      if (!activeIds.has(id)) {
        delete this.hiddenMsPerLoc[id];
      }
    }

    if (modified) {
      this.saveToStorage();
    }
  }

  /* ---------- CHECK COOLDOWN STATUS ---------- */
  checkCooldown(locationId) {
    if (!locationId) {
      return { isOnCooldown: false, remainingMs: 0, remainingSeconds: 0 };
    }

    const id = String(locationId);
    const startTime = this.cooldowns[id];
    
    if (!startTime) {
      return { isOnCooldown: false, remainingMs: 0, remainingSeconds: 0 };
    }

    const hiddenTime = this.hiddenMsPerLoc[id] || 0;
    const elapsed = Date.now() - startTime - hiddenTime;

    if (elapsed < 0 || elapsed >= COOLDOWN_PERIOD || !isFinite(elapsed)) {
      delete this.cooldowns[id];
      delete this.hiddenMsPerLoc[id];
      this.saveToStorage();
      return { isOnCooldown: false, remainingMs: 0, remainingSeconds: 0 };
    }

    const remainingMs = COOLDOWN_PERIOD - elapsed;
    return {
      isOnCooldown: true,
      remainingMs: Math.max(0, remainingMs),
      remainingSeconds: Math.max(0, Math.ceil(remainingMs / 1000)),
    };
  }

  /* ---------- ENTER LOCATION ---------- */
  enterLocation(locationId) {
    if (!locationId) {
      return {
        success: false,
        reason: 'invalid_id',
        message: 'Invalid location ID',
      };
    }

    const id = String(locationId);
    const now = Date.now();

    if (now - this.lastActionTime < DEBOUNCE_TIME) {
      return {
        success: false,
        reason: 'debounced',
        message: 'Action too rapid, please try again',
      };
    }
    this.lastActionTime = now;

    if (this.currentLocationId === id) {
      return {
        success: false,
        reason: 'already_inside',
        message: 'You are already in this location',
      };
    }

    const status = this.checkCooldown(id);
    if (status.isOnCooldown) {
      return {
        success: false,
        reason: 'on_cooldown',
        message: 'This location cannot be revisited for two minutes',
        remainingMs: status.remainingMs,
        remainingSeconds: status.remainingSeconds,
        locationId: id,
      };
    }

    this.currentLocationId = id;
    return {
      success: true,
      reason: 'allowed',
      message: 'Location entry allowed',
    };
  }

  /* ---------- LEAVE LOCATION ---------- */
  leaveLocation(locationId = null) {
    const id = locationId ? String(locationId) : this.currentLocationId;
    
    if (!id || id === 'null' || id === 'undefined') {
      return;
    }

    this.cooldowns[id] = Date.now();
    this.hiddenMsPerLoc[id] = 0;
    this.saveToStorage();

    if (this.currentLocationId === id) {
      this.currentLocationId = null;
    }
  }

  /* ---------- FORMAT TIME ---------- */
  formatTime(seconds) {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  }

  /* ---------- DISTANCE CHECK ---------- */
  isWithinThreshold(locationId) {
    try {
      const location = this.findLocationById(locationId);
      if (!location) return false;

      const lat = parseFloat(location.lat);
      const lng = parseFloat(location.lng);
      
      if (!isFinite(lat) || !isFinite(lng)) return false;
      if (typeof calculateDistance !== 'function') return false;
      if (!window.userMarker) return false;

      const userPos = window.userMarker.getLatLng();
      if (!userPos || !isFinite(userPos.lat) || !isFinite(userPos.lng)) return false;

      const distanceFeet = calculateDistance(userPos.lat, userPos.lng, lat, lng);
      if (!isFinite(distanceFeet) || distanceFeet < 0) return false;

      const threshold = (config && config.DISTANCE_THRESHOLD) || 150;
      return distanceFeet <= threshold;
    } catch (e) {
      console.error('Error in isWithinThreshold:', e);
      return false;
    }
  }

  /* ---------- COUNTDOWN NOTIFICATION ---------- */
  notifyUserWithCountdown(locationId, remainingSeconds) {
    if (!this.isWithinThreshold(locationId)) {
      return;
    }

    this.clearToast();

    if (window.showToast) {
      const message = `This location can't be revisited for ${this.formatTime(remainingSeconds)}`;
      window.showToast(message, 'warning');
      return;
    }

    if (window.showNotification) {
      const message = `This location can't be revisited for ${this.formatTime(remainingSeconds)}`;
      window.showNotification(message);
      return;
    }

    this.createCountdownToast(locationId);
  }

  /* ---------- CREATE COUNTDOWN TOAST ---------- */
  createCountdownToast(locationId) {
    const toast = document.createElement('div');
    toast.style.cssText = `
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: #333;
      color: white;
      padding: 12px 20px;
      border-radius: 6px;
      font-size: 15px;
      z-index: 10000;
      opacity: 0.95;
      max-width: 80%;
      text-align: center;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
    `;
    
    document.body.appendChild(toast);
    this.activeToast = toast;
    
    const updateToast = () => {
      if (!this.activeToast || !this.activeToast.parentNode) {
        this.clearToastInterval();
        return;
      }

      if (!this.isWithinThreshold(locationId)) {
        this.clearToast();
        return;
      }
      
      const status = this.checkCooldown(locationId);
      
      if (!status.isOnCooldown) {
        this.clearToast();
        this.attemptAutoOpen(locationId);
        return;
      }
      
      this.activeToast.textContent = `This location can't be revisited for ${this.formatTime(status.remainingSeconds)}`;
    };
    
    updateToast();
    this.toastInterval = setInterval(updateToast, TOAST_UPDATE_INTERVAL_MS);
  }

  /* ---------- ATTEMPT AUTO-OPEN ---------- */
  attemptAutoOpen(locationId) {
    if (!this.isWithinThreshold(locationId)) {
      return;
    }

    const location = this.findLocationById(locationId);
    if (!location) return;

    if (window.showLocationHunt) {
      const originalFunc = window.showLocationHunt.__original || window.showLocationHunt;
      try {
        originalFunc.call(window, location);
      } catch (e) {
        console.error('Error auto-opening location:', e);
      }
    }
  }

  /* ---------- CLEAR TOAST ---------- */
  clearToast() {
    this.clearToastInterval();
    
    if (this.activeToast && this.activeToast.parentNode) {
      this.activeToast.parentNode.removeChild(this.activeToast);
    }
    this.activeToast = null;
  }

  /* ---------- CLEAR TOAST INTERVAL ---------- */
  clearToastInterval() {
    if (this.toastInterval) {
      clearInterval(this.toastInterval);
      this.toastInterval = null;
    }
  }

  /* ---------- FIND LOCATION BY ID ---------- */
  findLocationById(locationId) {
    if (!locationId) return null;

    const id = String(locationId);

    if (!this.locationCache) {
      this.buildLocationCache();
    }

    return this.locationCache.get(id) || null;
  }

  /* ---------- BUILD LOCATION CACHE ---------- */
  buildLocationCache() {
    this.locationCache = new Map();

    const sources = [
      window.gameLocations,
      window.locations,
    ];

    for (const source of sources) {
      if (Array.isArray(source)) {
        for (const loc of source) {
          if (loc && loc.id) {
            this.locationCache.set(String(loc.id), loc);
          }
        }
      }
    }

    if (window.locationsMap && typeof window.locationsMap === 'object') {
      for (const [key, loc] of Object.entries(window.locationsMap)) {
        if (loc && loc.id) {
          this.locationCache.set(String(loc.id), loc);
        }
      }
    }
  }

  /* ---------- INVALIDATE LOCATION CACHE ---------- */
  invalidateLocationCache() {
    this.locationCache = null;
  }

  /* ---------- PATCH GAME FUNCTIONS ---------- */
  patchGameFunctions() {
    this.patchShowLocationHunt();
    this.patchCheckProximityAutoOpen();
    this.patchCloseFunctions();
    this.patchCreateBottomActionBar();
  }

  /* ---------- PATCH showLocationHunt ---------- */
  patchShowLocationHunt() {
    if (!window.showLocationHunt || window.showLocationHunt.__patched) {
      return;
    }

    const original = window.showLocationHunt;
    const manager = this;

    window.showLocationHunt = function(loc) {
      if (!loc || !loc.id) {
        return original.call(this, loc);
      }
      
      const result = manager.enterLocation(loc.id);
      
      if (result.success) {
        return original.call(this, loc);
      } else if (result.reason === 'on_cooldown') {
        manager.notifyUserWithCountdown(result.locationId, result.remainingSeconds);
      }
    };
    
    window.showLocationHunt.__patched = true;
    window.showLocationHunt.__original = original;
    this.patchedFunctions.push({ name: 'showLocationHunt', original });
  }

  /* ---------- PATCH checkProximityAutoOpen ---------- */
  patchCheckProximityAutoOpen() {
    if (!window.checkProximityAutoOpen || window.checkProximityAutoOpen.__patched) {
      return;
    }

    const original = window.checkProximityAutoOpen;
    const manager = this;

    window.checkProximityAutoOpen = function(loc, ft) {
      if (!loc || !loc.id) {
        return original.call(this, loc, ft);
      }
      
      const result = manager.enterLocation(loc.id);
      
      if (result.success) {
        return original.call(this, loc, ft);
      } else if (result.reason === 'on_cooldown') {
        manager.notifyUserWithCountdown(result.locationId, result.remainingSeconds);
      }
      
      return false;
    };
    
    window.checkProximityAutoOpen.__patched = true;
    window.checkProximityAutoOpen.__original = original;
    this.patchedFunctions.push({ name: 'checkProximityAutoOpen', original });
  }

  /* ---------- PATCH CLOSE FUNCTIONS ---------- */
  patchCloseFunctions() {
    const closeFunctionNames = [
      'closeLocationHunt',
      'closeLocation',
      'hideLocationHunt',
      'exitLocation'
    ];
    
    for (const funcName of closeFunctionNames) {
      if (window[funcName] && !window[funcName].__patched) {
        this.patchCloseFunction(funcName);
      }
    }
  }

  patchCloseFunction(funcName) {
    const original = window[funcName];
    const manager = this;

    window[funcName] = function(locationId) {
      if (manager.currentLocationId) {
        manager.leaveLocation(manager.currentLocationId);
      } else if (locationId) {
        manager.leaveLocation(locationId);
      }
      return original.call(this, locationId);
    };
    
    window[funcName].__patched = true;
    window[funcName].__original = original;
    manager.patchedFunctions.push({ name: funcName, original });
  }

  /* ---------- PATCH createBottomActionBar ---------- */
  patchCreateBottomActionBar() {
    if (!window.createBottomActionBar || window.createBottomActionBar.__patched) {
      return;
    }

    const original = window.createBottomActionBar;
    const manager = this;

    window.createBottomActionBar = function(location) {
      const bar = original.call(this, location);
      
      if (bar && location && location.id) {
        const originalOnClick = bar.onclick;
        bar.onclick = function(e) {
          manager.leaveLocation(location.id);
          if (originalOnClick) {
            return originalOnClick.call(this, e);
          }
        };
      }
      
      return bar;
    };
    
    window.createBottomActionBar.__patched = true;
    window.createBottomActionBar.__original = original;
    this.patchedFunctions.push({ name: 'createBottomActionBar', original });
  }

  /* ---------- UNPATCH ALL FUNCTIONS ---------- */
  unpatchAllFunctions() {
    for (const { name, original } of this.patchedFunctions) {
      if (window[name]) {
        window[name] = original;
      }
    }
    this.patchedFunctions = [];
  }

  /* ---------- UTILITY METHODS ---------- */
  getRemainingTime(locationId) {
    return this.checkCooldown(locationId).remainingSeconds;
  }

  getAllCooldowns() {
    const result = {};
    for (const id of Object.keys(this.cooldowns)) {
      const remaining = this.getRemainingTime(id);
      if (remaining > 0) {
        result[id] = remaining;
      }
    }
    return result;
  }

  clearCooldown(locationId) {
    if (!locationId) return;
    
    const id = String(locationId);
    delete this.cooldowns[id];
    delete this.hiddenMsPerLoc[id];
    this.saveToStorage();
  }

  clearAllCooldowns() {
    this.cooldowns = {};
    this.hiddenMsPerLoc = {};
    this.saveToStorage();
  }

  getCurrentLocation() {
    return this.currentLocationId;
  }

  /* ---------- CLEANUP ---------- */
  destroy() {
    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
      this.cleanupInterval = null;
    }
    
    this.clearToast();
    
    if (this.visibilityHandler) {
      document.removeEventListener('visibilitychange', this.visibilityHandler);
      this.visibilityHandler = null;
    }

    this.unpatchAllFunctions();
    
    this.locationCache = null;
    this.currentLocationId = null;
  }
}

/* ---------- SINGLETON INITIALIZATION ---------- */
if (typeof window !== 'undefined') {
  if (window.cooldownManager) {
    window.cooldownManager.destroy();
  }
  
  window.cooldownManager = new LocationCooldownManager();
}

if (typeof module !== 'undefined' && module.exports) {
  module.exports = LocationCooldownManager;
}
        
/* ---------- entry point ---------- */
function showLocationHunt(location) {
    const now = Date.now();
    const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    
    if (now - lastFunctionCall < DEBOUNCE_TIME) {
        console.log(`Function debounced (${now - lastFunctionCall}ms ago) on ${isTouchDevice ? 'touch' : 'desktop'} device`);
        return;
    }
    lastFunctionCall = now;

    console.log(`Processing location ${location.id} on ${isTouchDevice ? 'touch' : 'desktop'} device`);

    lastVisitedLocationId = location.id;
    isLocationHuntVisible = true;
    const lochuntContainer = cachedElements.lochuntContainer || document.querySelector('.lochunt-container');
    lochuntContainer.innerHTML = '';
    lochuntContainer.style.display = 'flex';
    lochuntContainer.classList.add('fade-in');

    announceToScreenReader(`Opened location: ${location.name}`);

    const scrollableContent = document.createElement('div');
    scrollableContent.style.cssText = `
        flex: 1;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
        scroll-behavior: smooth;
        will-change: scroll-position;
    `;

    const locationImage = document.createElement('img');
    locationImage.src = location.image;
    locationImage.alt = location.name;
    locationImage.style.cssText = `
        width: 100%;
        height: 45vh;
        object-fit: cover;
        object-position: center;
    `;
    locationImage.loading = 'eager';
    scrollableContent.appendChild(locationImage);

    const contentContainer = document.createElement('div');
    contentContainer.classList.add('lochunt-content');
    contentContainer.style.cssText = `
        padding: 24px;
        display: flex;
        flex-direction: column;
        align-items: center;
        max-width: 800px;
        margin: 0 auto;
    `;

    const locationInfo = document.createElement('div');
    locationInfo.classList.add('lochunt-info');
    locationInfo.style.cssText = `
        text-align: center;
        width: 100%;
        margin-bottom: 15px;
    `;

    const locationName = document.createElement('h1');
    locationName.textContent = location.name;
    locationName.style.cssText = `
        font-size: clamp(1.8rem, 4vw, 2.5rem);
        font-weight: 700;
        color: #1a1a1a;
        margin-bottom: 8px;
        line-height: 1.2;
    `;

    const locationCity = document.createElement('p');
    locationCity.textContent = `${location.city}`;
    locationCity.style.cssText = `
        font-size: clamp(1.1rem, 2vw, 1.3rem);
        color: #2c5282;
        font-weight: 600;
        margin-bottom: 4px;
    `;

    const locationCreator = document.createElement('p');
    locationCreator.textContent = `Created by: ${location.creator}`;
    locationCreator.style.cssText = `
        font-size: calc(0.9rem + 0.4vw);
        color: #666666;
        font-weight: 500;
    `;

    locationInfo.appendChild(locationName);
    locationInfo.appendChild(locationCity);
    locationInfo.appendChild(locationCreator);
    contentContainer.appendChild(locationInfo);

    const audioPlayerContainer = createAudioPlayer(location.audio);
    audioPlayerContainer.querySelector('#locationAudio').currentTime = 0;
    contentContainer.appendChild(audioPlayerContainer);
    scrollableContent.appendChild(contentContainer);
    lochuntContainer.appendChild(scrollableContent);

    const bottomActionBar = createBottomActionBar(location);
    bottomActionBar.style.cssText += `
        position: sticky;
        bottom: 0;
        width: 100%;
    `;
    lochuntContainer.appendChild(bottomActionBar);

    setTimeout(() => {
        window.audioPlayerCleanup = initAudioPlayer();
    }, 100);

    if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
        const userPos = userMarker ? userMarker.getLatLng() : null;
        if (userPos && gameLocations) {
            navigator.serviceWorker.controller.postMessage({
                type: 'PREFETCH_AUDIO',
                data: {
                    userLocation: { lat: userPos.lat, lng: userPos.lng },
                    locations: gameLocations
                }
            });
        }
    }
}
     
function createAudioPlayer(audioSrc) {
    const audioPlayerContainer = document.createElement('div');
    audioPlayerContainer.classList.add('audio-player');
    audioPlayerContainer.style.cssText = `
        width: 100%;
        max-width: 400px;
        margin-bottom: 15px;
    `;
    const audio = document.createElement('audio');
    audio.id = 'locationAudio';
    audio.src = audioSrc;
    audio.preload = "auto";
    const audioProgress = document.createElement('div');
    audioProgress.classList.add('audio-progress');
    audioProgress.style.cssText = `
        width: 100%;
        margin-bottom: 15px;
    `;
    const progressContainer = document.createElement('div');
    progressContainer.classList.add('progress');
    progressContainer.style.cssText = `
        height: 8px;
        background-color: #e2e8f0;
        border-radius: 4px;
        cursor: pointer;
        margin-bottom: 12px;
        overflow: hidden;
    `;
    const progressBar = document.createElement('div');
    progressBar.id = 'progressBar';
    progressBar.classList.add('progress-bar');
    progressBar.style.cssText = `
        height: 100%;
        background-color: #2c5282;
        width: 0%;
        transition: width 0.1s linear;
    `;
    progressContainer.appendChild(progressBar);
    audioProgress.appendChild(progressContainer);
    const timeInfo = document.createElement('div');
    timeInfo.classList.add('audio-time');
    timeInfo.style.cssText = `
        display: flex;
        justify-content: space-between;
        color: #4a5568;
        font-size: 0.875rem;
        margin-bottom: 16px;
        font-weight: 500;
    `;
    const currentTimeSpan = document.createElement('span');
    currentTimeSpan.id = 'currentTime';
    currentTimeSpan.textContent = '0:00';
    const durationSpan = document.createElement('span');
    durationSpan.id = 'duration';
    durationSpan.textContent = '0:00';
    timeInfo.appendChild(currentTimeSpan);
    timeInfo.appendChild(durationSpan);
    const audioControls = document.createElement('div');
    audioControls.classList.add('audio-controls');
    audioControls.style.cssText = `
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 24px;
    `;
    const rewindBtn = createAudioButton('skip-backward', 'rewindBtn', 'Rewind 10 seconds');
    const playPauseBtn = createAudioButton('play', 'playPauseBtn', 'Play');
    const forwardBtn = createAudioButton('skip-forward', 'forwardBtn', 'Forward 10 seconds');
    audioControls.appendChild(rewindBtn);
    audioControls.appendChild(playPauseBtn);
    audioControls.appendChild(forwardBtn);
    audioPlayerContainer.appendChild(audio);
    audioPlayerContainer.appendChild(audioProgress);
    audioPlayerContainer.appendChild(timeInfo);
    audioPlayerContainer.appendChild(audioControls);
    return audioPlayerContainer;
}

function createAudioButton(iconName, id, ariaLabel) {
    const button = document.createElement('button');
    button.id = id;
    button.classList.add('audio-button');
    button.setAttribute('aria-label', ariaLabel);
    button.innerHTML = `<i class="bi bi-${iconName}"></i>`;
    button.style.cssText = `
        background-color: white;
        color: var(--primary-color);
        border: 2px solid var(--primary-color);
        border-radius: 50%;
        width: 55px;
        height: 55px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.3s ease;
    `;
    button.addEventListener('mouseover', () => {
        button.style.backgroundColor = 'var(--hover-color)';
    });
    button.addEventListener('mouseout', () => {
        button.style.backgroundColor = 'white';
    });
    button.addEventListener('click', () => {
        button.style.backgroundColor = 'var(--primary-color)';
        button.style.color = 'white';
        button.style.transform = 'scale(0.95)';
        
        setTimeout(() => {
            button.style.backgroundColor = 'white';
            button.style.color = 'var(--primary-color)';
            button.style.transform = 'scale(1)';
        }, 200);
    });
    return button;
}

function createBottomActionBar(location) {
    const actionBar = document.createElement('div');
    actionBar.classList.add('location-action-bar');
    actionBar.style.cssText = `
        width: 100%;
        height: 60px;
        background: linear-gradient(to right, #2c5282, #2b6cb0);
        margin-top: auto;
        box-shadow: 0 -2px 10px rgba(0,0,0,0.025);
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0 24px;
        position: sticky;
        bottom: 0;
    `;
    
    const imgSourceBtn = document.createElement('button');
    imgSourceBtn.classList.add('source-info-button', 'btn', 'btn-sm', 'me-2');
    imgSourceBtn.innerHTML = '<i class="bi bi-info-circle-fill text-white" style="font-size: 1.5rem;"></i>';
    imgSourceBtn.setAttribute('aria-label', 'Image source information');
    imgSourceBtn.onclick = () => {
        if (location && location.imageSource) {
            showSourcePopup('Image Source', location.imageSource);
        } else {
            showSourcePopup('Image Source', 'Image source information is not available');
        }
    };
    const feedbackButton = document.createElement('a');
    feedbackButton.href = 'mailto:mattreicher@protonmail.com?subject=Feedback';
    feedbackButton.target = '_blank';
    feedbackButton.rel = 'noopener noreferrer';
    feedbackButton.setAttribute('aria-label', 'Send feedback email');
    feedbackButton.innerHTML = '<i class="bi bi-envelope-fill text-white" style="font-size: 1.5rem;"></i>';
    feedbackButton.classList.add('feedback-email-button', 'btn', 'btn-sm');
    actionBar.appendChild(imgSourceBtn);
    actionBar.appendChild(feedbackButton);
    return actionBar;
}

function showSourcePopup(title, content) {
    const existingPopup = document.getElementById('sourceInfoPopup');
    if (existingPopup) {
        document.body.removeChild(existingPopup);
    }
    
    const overlay = document.createElement('div');
    overlay.id = 'sourceInfoPopup';
    overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 9999;
        backdrop-filter: blur(3px);
    `;
    
    const popup = document.createElement('div');
    popup.classList.add('source-info-content');
    popup.style.cssText = `
        background-color: white;
        border-radius: 8px;
        padding: 24px;
        width: 90%;
        max-width: 500px;
        max-height: 80vh;
        overflow-y: auto;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
        display: flex;
        flex-direction: column;
    `;
    
    const popupTitle = document.createElement('h3');
    popupTitle.textContent = title;
    popupTitle.style.cssText = `
        font-size: 1.5rem;
        font-weight: 600;
        color: #2c5282;
        margin-bottom: 16px;
        border-bottom: 1px solid #e2e8f0;
        padding-bottom: 12px;
    `;
    
    const popupContent = document.createElement('div');
    popupContent.style.cssText = `
        margin-bottom: 20px;
        line-height: 1.6;
        font-size: 1rem;
    `;
    popupContent.textContent = content;
    
    const closeButton = document.createElement('button');
    closeButton.textContent = 'Close';
    closeButton.classList.add('source-close-button', 'btn');
    closeButton.style.cssText = `
        background: linear-gradient(to right, #2c5282, #2b6cb0);
        border: none;
        color: white;
        padding: 8px 24px;
        border-radius: 4px;
        font-weight: 500;
        cursor: pointer;
        align-self: flex-end;
        transition: all 0.2s ease;
    `;
    
    closeButton.addEventListener('mouseover', () => {
        closeButton.style.opacity = '0.9';
    });
    
    closeButton.addEventListener('mouseout', () => {
        closeButton.style.opacity = '1';
    });
    
    closeButton.addEventListener('click', () => {
        document.body.removeChild(overlay);
    });
    
    overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
            document.body.removeChild(overlay);
        }
    });
    
    popup.appendChild(popupTitle);
    popup.appendChild(popupContent);
    popup.appendChild(closeButton);
    overlay.appendChild(popup);
    document.body.appendChild(overlay);
    
    overlay.style.opacity = '0';
    popup.style.transform = 'translateY(20px)';
    popup.style.transition = 'transform 0.3s ease, opacity 0.3s ease';
    overlay.style.transition = 'opacity 0.3s ease';
    
    setTimeout(() => {
        overlay.style.opacity = '1';
        popup.style.transform = 'translateY(0)';
    }, 10);
}

function initAudioPlayer() {
    const audio = document.getElementById('locationAudio');
    const playPauseBtn = document.getElementById('playPauseBtn');
    const rewindBtn = document.getElementById('rewindBtn');
    const forwardBtn = document.getElementById('forwardBtn');
    const progressBar = document.getElementById('progressBar');
    const progressContainer = document.querySelector('.progress');
    const currentTimeSpan = document.getElementById('currentTime');
    const durationSpan = document.getElementById('duration');
    if (!audio || !playPauseBtn || !progressBar) {
        console.error("Audio player elements not found");
        return;
    }
    
    if (audio.src && !audio.dataset.originalSrc) {
        audio.dataset.originalSrc = audio.src;
    }
    
    let wakeLock = null;
    let audioContext = null;
    let isPlayerActive = true;
    
    let retryCount = 0;
    const maxRetries = 3;
    let lastPlaybackPosition = 0;
    let recoveryInProgress = false;
    
    let wasPlayingWhenHidden = false;
    let screenWentAway = false;
    let wasPlaying = false;
    
    function initAudioContext() {
        if (!audioContext && isPlayerActive) {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const source = audioContext.createMediaElementSource(audio);
                source.connect(audioContext.destination);
            } catch (e) {
                console.log('AudioContext not available:', e);
            }
        }
        return audioContext;
    }
    
    async function requestWakeLock() {
        try {
            if ('wakeLock' in navigator && !wakeLock && isPlayerActive) {
                wakeLock = await navigator.wakeLock.request('screen');
                console.log('Wake lock acquired');
                
                wakeLock.addEventListener('release', () => {
                    console.log('Wake lock released');
                    wakeLock = null;
                    if (!audio.paused) {
                        screenWentAway = true;
                        wasPlayingWhenHidden = true;
                    }
                });
            }
        } catch (err) {
            console.warn('Wake lock failed:', err);
        }
    }
    
    async function releaseWakeLock() {
        if (wakeLock) {
            try {
                await wakeLock.release();
                wakeLock = null;
                console.log('Wake lock manually released');
            } catch (err) {
                console.warn('Wake lock release failed:', err);
            }
        }
    }
    
    document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
            if (!audio.paused) {
                wasPlayingWhenHidden = true;
                screenWentAway = true;
            }
        } else {
            if (wasPlayingWhenHidden && audio.paused) {
                setTimeout(() => {
                    if (screenWentAway) {
                        showSourcePopup("Audio Restarted", "Audio was interrupted when this tab became inactive and has restarted from the beginning. Keep this tab active to prevent interruptions.");
                        screenWentAway = false;
                        wasPlayingWhenHidden = false;
                    }
                }, 100);
            }
        }
    });
    
    audio.addEventListener('play', () => {
        wasPlaying = true;
        announceToScreenReader('Audio playback started');
    });
    
    audio.addEventListener('pause', () => {
        wasPlaying = false;
        announceToScreenReader('Audio playback paused');
    });
    
    function recoverAudioSource() {
        if (recoveryInProgress || !isPlayerActive) return;
        
        recoveryInProgress = true;
        console.log('Attempting audio recovery...');
        
        if (!isNaN(audio.currentTime)) {
            lastPlaybackPosition = audio.currentTime;
        }
        
        if (audio.dataset.originalSrc) {
            audio.src = audio.dataset.originalSrc;
        } else if (audio.getAttribute('data-src')) {
            audio.src = audio.getAttribute('data-src');
        }
        
        audio.load();
        
        const setPositionAfterNetworkRecovery = () => {
            if (lastPlaybackPosition > 0 && !screenWentAway) {
                audio.currentTime = lastPlaybackPosition;
            } else if (screenWentAway) {
                audio.currentTime = 0;
            }
            recoveryInProgress = false;
            retryCount = 0;
            audio.removeEventListener('loadedmetadata', setPositionAfterNetworkRecovery);
            audio.removeEventListener('canplay', setPositionAfterNetworkRecovery);
        };
        
        audio.addEventListener('loadedmetadata', setPositionAfterNetworkRecovery);
        audio.addEventListener('canplay', setPositionAfterNetworkRecovery);
    }
    
    function handleAudioError(error) {
       console.log('handleAudioError called, isPlayerActive:', isPlayerActive, 'audio exists:', !!audio);
       console.log('Screen went away:', screenWentAway, 'Was playing when hidden:', wasPlayingWhenHidden);
       console.log('Current lastPlaybackPosition:', lastPlaybackPosition);
       
       const actualError = audio ? audio.error : null;
       if (actualError) {
           console.error("Actual audio error details:", {
               code: actualError.code,
               message: actualError.message,
               MEDIA_ERR_ABORTED: actualError.code === 1,
               MEDIA_ERR_NETWORK: actualError.code === 2,
               MEDIA_ERR_DECODE: actualError.code === 3,
               MEDIA_ERR_SRC_NOT_SUPPORTED: actualError.code === 4
           });
       }
       
       if (!isPlayerActive && (!audio || audio.readyState === 0)) {
           console.log('Audio error ignored - player cleaned up');
           return;
       }
       
       console.error("Audio play error event:", error);
       releaseWakeLock();
       
       if (screenWentAway || wasPlayingWhenHidden) {
           const resumePosition = lastPlaybackPosition || 0;
           console.log('Screen interruption detected, stored position:', resumePosition);
           
           showSourcePopup("Audio Interrupted", `Audio was paused when you left the screen. Click play to resume from ${Math.floor(resumePosition / 60)}:${String(Math.floor(resumePosition % 60)).padStart(2, '0')}.`);
           
           if (audio) {
               audio.dataset.resumePosition = resumePosition.toString();
               
               const prepareForResume = () => {
                   console.log('Audio prepared for manual resume');
                   audio.removeEventListener('loadedmetadata', prepareForResume);
                   audio.removeEventListener('canplay', prepareForResume);
               };
               
               audio.addEventListener('loadedmetadata', prepareForResume);
               audio.addEventListener('canplay', prepareForResume);
               
               recoverAudioSource();
           }
           
           screenWentAway = false;
           wasPlayingWhenHidden = false;
       } else if (retryCount < maxRetries && isPlayerActive) {
           retryCount++;
           console.log(`Recovery attempt ${retryCount}/${maxRetries}`);
           
           setTimeout(() => {
               const currentPos = lastPlaybackPosition || 0;
               const setPositionAfterNetworkRecovery = () => {
                   if (currentPos > 0) {
                       console.log('Setting position after network recovery:', currentPos);
                       audio.currentTime = currentPos;
                   }
                   audio.removeEventListener('loadedmetadata', setPositionAfterNetworkRecovery);
                   audio.removeEventListener('canplay', setPositionAfterNetworkRecovery);
               };
               
               audio.addEventListener('loadedmetadata', setPositionAfterNetworkRecovery);
               audio.addEventListener('canplay', setPositionAfterNetworkRecovery);
               
               recoverAudioSource();
           }, 1000 * retryCount);
       } else if (retryCount >= maxRetries) {
           console.error('Audio recovery failed after maximum retries');
           playPauseBtn.innerHTML = '<i class="bi bi-exclamation-triangle"></i>';
           playPauseBtn.setAttribute('aria-label', 'Audio Error');
           showSourcePopup("Audio Error", "Unable to recover audio after multiple attempts. Please refresh the page or try again later.");
       } else {
           if (audio) {
               const currentPos = lastPlaybackPosition || 0;
               const setPositionAfterGenericRecovery = () => {
                   if (currentPos > 0) {
                       console.log('Setting position after generic recovery:', currentPos);
                       audio.currentTime = currentPos;
                   }
                   audio.removeEventListener('loadedmetadata', setPositionAfterGenericRecovery);
                   audio.removeEventListener('canplay', setPositionAfterGenericRecovery);
               };
               
               audio.addEventListener('loadedmetadata', setPositionAfterGenericRecovery);
               audio.addEventListener('canplay', setPositionAfterGenericRecovery);
               
               recoverAudioSource();
           }
           showSourcePopup("Audio Error", "An audio error occurred. Attempting to resume from last position.");
       }
       
       playPauseBtn.innerHTML = '<i class="bi bi-play"></i>';
       playPauseBtn.setAttribute('aria-label', 'Play');
    }
    
   function togglePlay() {
       if (audio.paused) {
           const resumePosition = audio.dataset.resumePosition;
           if (resumePosition && parseFloat(resumePosition) > 0) {
               console.log('Resuming from stored position:', resumePosition);
               audio.currentTime = parseFloat(resumePosition);
               delete audio.dataset.resumePosition;
           }
           
           audio.play().then(() => {
               playPauseBtn.innerHTML = '<i class="bi bi-pause"></i>';
               playPauseBtn.setAttribute('aria-label', 'Pause');
               requestWakeLock();
           }).catch(error => {
               handleAudioError(error);
           });
       } else {
           audio.pause();
           playPauseBtn.innerHTML = '<i class="bi bi-play"></i>';
           playPauseBtn.setAttribute('aria-label', 'Play');
       }
    }
    
    audio.addEventListener('timeupdate', () => {
       if (!isNaN(audio.currentTime) && isPlayerActive && audio.currentTime > 0) {
           lastPlaybackPosition = audio.currentTime;
           try {
               localStorage.setItem('audioPosition', audio.currentTime.toString());
           } catch (e) {}
       }
    });
    
    document.addEventListener('visibilitychange', () => {
       if (document.hidden) {
           if (audio && !audio.paused) {
               if (!isNaN(audio.currentTime)) {
                   lastPlaybackPosition = audio.currentTime;
                   try {
                       localStorage.setItem('audioPosition', audio.currentTime.toString());
                   } catch (e) {}
               }
               
               wasPlayingWhenHidden = true;
               screenWentAway = true;
               
               audio.pause();
               
               playPauseBtn.innerHTML = '<i class="bi bi-play"></i>';
               playPauseBtn.setAttribute('aria-label', 'Play');
           }
       }
    });
    
    window.addEventListener('blur', () => {
       if (audio && !audio.paused) {
           lastPlaybackPosition = audio.currentTime;
           wasPlayingWhenHidden = true;
           screenWentAway = true;
           console.log('Window blur, storing position:', lastPlaybackPosition);
       }
    });
    
    window.addEventListener('online', () => {
       if (audio.error && isPlayerActive) {
           console.log('Network recovered, attempting to reload audio');
           const savedPos = lastPlaybackPosition || 0;
           const setPositionAfterOnline = () => {
               if (savedPos > 0) {
                   audio.currentTime = savedPos;
               }
               audio.removeEventListener('loadedmetadata', setPositionAfterOnline);
               audio.removeEventListener('canplay', setPositionAfterOnline);
           };
           
           audio.addEventListener('loadedmetadata', setPositionAfterOnline);
           audio.addEventListener('canplay', setPositionAfterOnline);
           
           recoverAudioSource();
       }
    });
    
    playPauseBtn.addEventListener('click', togglePlay);
    rewindBtn.addEventListener('click', () => seek(-10));
    forwardBtn.addEventListener('click', () => seek(10));
    audio.addEventListener('timeupdate', updateProgress);
    audio.addEventListener('loadedmetadata', setDuration);
    audio.addEventListener('ended', async () => {
       playPauseBtn.innerHTML = '<i class="bi bi-play"></i>';
       playPauseBtn.setAttribute('aria-label', 'Play');
       await releaseWakeLock();
       
       try {
           localStorage.removeItem('audioPosition');
       } catch (e) {}
       
       audio.currentTime = 0;
       if (progressBar) {
           progressBar.style.width = '0%';
       }
       
       announceToScreenReader('Audio playback completed');
       showAdditionalInfo();
    });
    audio.addEventListener('pause', releaseWakeLock);
    audio.addEventListener('error', (e) => {
       handleAudioError(e);
    });
    
    if (progressContainer) {
       progressContainer.addEventListener('click', setProgress);
    }
    
    audio.addEventListener('loadedmetadata', () => {
       try {
           const savedPosition = localStorage.getItem('audioPosition');
           if (savedPosition && !isNaN(savedPosition) && parseFloat(savedPosition) > 0 && !screenWentAway && !wasPlayingWhenHidden) {
               audio.currentTime = parseFloat(savedPosition);
           }
       } catch (e) {}
    });
    
    audio.load();
    
async function togglePlay() {
    if (!isPlayerActive) return;
    
    // check to prevent empty src errors
    if (!audio.src || audio.src.trim() === '' || audio.src === window.location.href) {
        return;
    }
    
    try {
        if (audio.paused) {
            const ctx = initAudioContext();
            if (ctx && ctx.state === 'suspended') {
                await ctx.resume();
            }
            
            const playPromise = audio.play();
            if (playPromise !== undefined) {
                playPromise.then(async () => {
                    playPauseBtn.innerHTML = '<i class="bi bi-pause"></i>';
                    playPauseBtn.setAttribute('aria-label', 'Pause');
                    await requestWakeLock();
                    retryCount = 0;
                }).catch(error => {
                    handleAudioError(error);
                });
            }
        } else {
            audio.pause();
            playPauseBtn.innerHTML = '<i class="bi bi-play"></i>';
            playPauseBtn.setAttribute('aria-label', 'Play');
            await releaseWakeLock();
        }
    } catch (error) {
        handleAudioError(error);
    }
}
    
    function seek(seconds) {
        if (!isPlayerActive) return;
        audio.currentTime = Math.max(0, Math.min(audio.currentTime + seconds, audio.duration));
        
        const direction = seconds > 0 ? 'forward' : 'backward';
        announceToScreenReader(`Skipped ${Math.abs(seconds)} seconds ${direction}`);
    }
    
    function updateProgress() {
        if (!isPlayerActive || !isFinite(audio.duration)) return;
        
        const percent = (audio.currentTime / audio.duration) * 100;
        progressBar.style.width = `${percent}%`;
        currentTimeSpan.textContent = formatTime(audio.currentTime);
    }
    
    function setProgress(e) {
        if (!isPlayerActive) return;
        
        const width = this.clientWidth;
        const clickX = e.offsetX;
        const duration = audio.duration;
        
        if (isFinite(duration) && width > 0) {
            audio.currentTime = (clickX / width) * duration;
            
            const newTime = formatTime(audio.currentTime);
            announceToScreenReader(`Jumped to ${newTime}`);
        }
    }
    
    function setDuration() {
        if (!isPlayerActive || !isFinite(audio.duration)) return;
        durationSpan.textContent = formatTime(audio.duration);
    }
    
    function formatTime(time) {
        if (!isFinite(time)) return "0:00";
        
        const minutes = Math.floor(time / 60);
        const seconds = Math.floor(time % 60);
        return `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }
    
    return function cleanup() {
        console.log('Audio player cleanup starting');
        releaseWakeLock();
        isPlayerActive = false;
        if (audioContext) {
            audioContext.close();
        }
        console.log('Audio player cleaned up');
    };
}

function showAdditionalInfo() {
    const location = gameLocations.find(loc => loc.id === lastVisitedLocationId);
    if (!location) {
        console.error('Location not found for ID:', lastVisitedLocationId);
        return;
    }
    
    const additionalInfoContainer = cachedElements.additionalInfoContainer || document.querySelector('.additional-info-container');
    additionalInfoContainer.style.display = 'block';
    additionalInfoContainer.classList.add('fade-in');
    
    document.getElementById('additionalInfo').textContent = location.additionalInfo || 
        "No additional information available for this location.";
    
    announceToScreenReader('Additional information is now available');
    
const continueButton = document.getElementById('continueButton');
continueButton.onclick = () => {
    additionalInfoContainer.classList.add('fade-out');
    setTimeout(() => {
        additionalInfoContainer.style.display = 'none';
        additionalInfoContainer.classList.remove('fade-out');
        
        const lochuntContainer = cachedElements.lochuntContainer || document.querySelector('.lochunt-container');
        lochuntContainer.classList.add('fade-out');
        setTimeout(() => {
            lochuntContainer.style.display = 'none';
            lochuntContainer.classList.remove('fade-out');
            isLocationHuntVisible = false;
            
            // âœ… CRITICAL: Trigger cooldown when leaving
            if (window.cooldownManager && lastVisitedLocationId != null) {
                window.cooldownManager.leaveLocation(lastVisitedLocationId);
            }
            
            announceToScreenReader('Returned to map view');
            updateDistanceBox();
            
            if (window.audioPlayerCleanup) {
                window.audioPlayerCleanup();
                window.audioPlayerCleanup = null;
            }
        }, 300);
    }, 300);
};
}

function showLocationSummary(locationId) {
  const location = locations.find(loc => String(loc.id) === String(locationId));
  if (!location || !location.summary) {
    console.log("Location or summary not found. Location ID:", locationId);
    showPopup("Error", "Summary not available for this location.");
    return;
  }
  // Hide the distance box
  const distanceBox = document.querySelector('#distanceBox');
  if (distanceBox) distanceBox.style.display = 'none';
  
  // Difficulty system - cleaner accessibility focus
  const level = Math.max(1, Math.min(5, location.difficulty || 1));
  const difficultyInfo = {
    1: { color: '#059669', bg: '#d1fae5', text: 'Very Easy', desc: 'Wheelchair accessible, paved paths' },
    2: { color: '#65a30d', bg: '#ecfccb', text: 'Easy', desc: 'Short walk, maintained trails' },
    3: { color: '#d97706', bg: '#fed7aa', text: 'Moderate', desc: 'Some walking, uneven terrain possible' },
    4: { color: '#dc2626', bg: '#fecaca', text: 'Challenging', desc: 'Longer hike, steep sections' },
    5: { color: '#991b1b', bg: '#fee2e2', text: 'Difficult', desc: 'Strenuous hike, excellent fitness required' }
  };
  const difficulty = difficultyInfo[level];
  
  // Build modal
  const popupDiv = document.createElement('div');
  popupDiv.id = 'summaryModal';
  popupDiv.style.cssText = `
      position:fixed; inset:0;
      background:rgba(0,0,0,.6); backdrop-filter:blur(4px);
      display:flex; align-items:center; justify-content:center;
      z-index:1000; opacity:0; transition:opacity .3s ease;
      padding:16px;
  `;
  const darkBlue = '#1a3a8a';
  const darkBlueHover = '#0d2c6e';
  popupDiv.innerHTML = `
    <div style="
        background:#fff; border-radius:16px; width:100%; max-width:420px; max-height:85vh;
        box-shadow:0 15px 40px rgba(0,0,0,.2); overflow:hidden;
        transform:translateY(20px); transition:transform .4s cubic-bezier(.175,.885,.32,1.275);
        display:flex; flex-direction:column;
    ">
      <div style="background:${darkBlue}; color:#fff; text-align:center; padding:20px 24px;">
        <h3 style="margin:0; font-size:1.4rem; font-weight:600; line-height:1.2;">${location.name}</h3>
      </div>
      <div style="flex:1; overflow-y:auto; padding:24px; -webkit-overflow-scrolling:touch;">
        <p style="color:#5c6c7c; line-height:1.6; font-size:1rem; margin:0 0 20px">
          ${location.summary}
        </p>
        
        <div style="
            background:${difficulty.bg}; border:1px solid ${difficulty.color}60; border-radius:12px; 
            padding:18px; margin-bottom:18px; position:relative;
        ">
          <div style="
              position:absolute; top:12px; right:12px; 
              background:${difficulty.color}; color:#fff; 
              padding:8px 16px; border-radius:20px; 
              font-size:1rem; font-weight:700; 
              box-shadow:0 4px 12px rgba(0,0,0,.15);
              border:3px solid #fff;
          ">${level}/5</div>
          <div style="
              font-weight:600; color:#374151; font-size:0.95rem; 
              margin-bottom:10px; padding-right:80px;
          ">
            Access
          </div>
          <div style="display:flex; align-items:center; gap:12px; margin-bottom:6px;">
            <div style="width:10px; height:10px; border-radius:50%; background:${difficulty.color}; flex-shrink:0;"></div>
            <span style="color:${difficulty.color}; font-weight:600; font-size:1rem;">${difficulty.text}</span>
          </div>
          <div style="color:#6b7280; font-size:0.9rem; padding-left:22px; line-height:1.4;">
            ${difficulty.desc}
          </div>
        </div>
        
        ${location.today ? `
        <div style="
            border:2px solid ${darkBlue}; border-radius:12px; padding:16px;
            background:rgba(26,58,138,.05); margin-bottom:20px;
            display:flex; align-items:center;
        ">
          <div style="font-weight:600; color:#2c3e50; padding-right:15px; min-width:80px">Location:</div>
          <div style="flex:1; color:#2c3e50; border-left:1px solid rgba(26,58,138,.2); padding-left:15px; font-size:0.95rem;">
            ${location.today}
          </div>
        </div>
        ` : ''}
        
        <div style="display:flex; justify-content:center; margin-top:12px;">
          <button class="continue-btn" style="
              padding:16px 32px; background:${darkBlue}; color:#fff; border:none;
              border-radius:12px; cursor:pointer; font-size:1.05rem; font-weight:600;
              min-width:140px; transition:.2s; -webkit-tap-highlight-color:transparent;
              box-shadow:0 4px 14px rgba(26,58,138,.3);
          ">Continue</button>
        </div>
      </div>
    </div>
  `;
  document.body.appendChild(popupDiv);
  
  // Animate in
  requestAnimationFrame(() => {
    popupDiv.style.opacity = '1';
    popupDiv.querySelector('div').style.transform = 'translateY(0)';
  });

  // Close helpers
  function close() {
    popupDiv.style.opacity = '0';
    popupDiv.querySelector('div').style.transform = 'translateY(20px)';
    setTimeout(() => {
      document.body.removeChild(popupDiv);
      // Restore distance box
      if (distanceBox) distanceBox.style.display = 'block';
    }, 300);
  }

  const btn = popupDiv.querySelector('.continue-btn');
  btn.addEventListener('mouseover', () => btn.style.backgroundColor = darkBlueHover);
  btn.addEventListener('mouseout',  () => btn.style.backgroundColor = darkBlue);
  btn.addEventListener('click', close);
  popupDiv.addEventListener('click', e => { if (e.target === popupDiv) close(); });
}

function showNavigationTips() {
   const distanceBox = document.querySelector('#distanceBox'); 
   if (distanceBox) {
       distanceBox.style.display = 'none';
   }
   
   const modalOverlay = document.createElement("div");
   modalOverlay.className = "navigation-tips-overlay";
   modalOverlay.style.cssText = `
       position: fixed;
       top: 0;
       left: 0;
       width: 100%;
       height: 100%;
       background-color: rgba(0, 0, 0, 0.6);
       backdrop-filter: blur(4px);
       display: flex;
       justify-content: center;
       align-items: center;
       z-index: 1000;
       opacity: 0;
       transition: opacity 0.3s ease;
   `;
   
   const darkBlue = "var(--dark-blue)";
   const darkBlueHover = "var(--dark-blue-hover)";
   
   const modalContent = document.createElement("div");
   modalContent.className = "navigation-tips-content";
   modalContent.style.cssText = `
       background-color: white;
       border-radius: 16px;
       width: 90%;
       max-width: 450px;
       max-height: 95vh;
       box-shadow: 0 15px 40px rgba(0, 0, 0, 0.25);
       transform: translateY(20px);
       transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
       overflow: hidden;
       display: flex !important;
       flex-direction: column !important;
       position: relative;
   `;
   
   const header = document.createElement("div");
   header.style.cssText = `
       text-align: center;
       padding: 20px 28px 0;
   `;
   
   header.innerHTML = `
       <h3 style="
           margin: 0 0 10px 0;
           color: ${darkBlue};
           font-size: 1.5rem;
           font-weight: 600;
       ">Navigation Tips</h3>
   `;
   
   const contentArea = document.createElement("div");
   contentArea.style.cssText = `
       padding: 0 28px;
       color: #5c6c7c;
       line-height: 1.4;
       font-size: 0.9rem;
   `;
   
   contentArea.innerHTML = `
       <ul style="
           list-style-type: none;
           padding: 0;
           margin: 0 0 10px 0;
       ">
           <li style="margin-bottom: 8px; display: flex; align-items: flex-start;">
               <span style="color: ${darkBlue}; margin-right: 10px; font-size: 1.1rem;">â€¢</span>
               <span>Use the map to navigate to the marked locations.</span>
           </li>
           <li style="margin-bottom: 8px; display: flex; align-items: flex-start;">
               <span style="color: ${darkBlue}; margin-right: 10px; font-size: 1.1rem;">â€¢</span>
               <span>Tap the recenter button to focus on your current position.</span>
           </li>
           <li style="margin-bottom: 8px; display: flex; align-items: flex-start;">
               <span style="color: ${darkBlue}; margin-right: 10px; font-size: 1.1rem;">â€¢</span>
               <span>The distance box shows how far you are from the closest location.</span>
           </li>
           <li style="margin-bottom: 8px; display: flex; align-items: flex-start;">
               <span style="color: ${darkBlue}; margin-right: 10px; font-size: 1.1rem;">â€¢</span>
               <span>When you're within 20 feet of a location, you'll be able to interact with it.</span>
           </li>
           <li style="margin-bottom: 8px; display: flex; align-items: flex-start;">
               <span style="color: ${darkBlue}; margin-right: 10px; font-size: 1.1rem;">â€¢</span>
               <span>Listen to the audio information for each location.</span>
           </li>
           <li style="margin-bottom: 0; display: flex; align-items: flex-start;">
               <span style="color: ${darkBlue}; margin-right: 10px; font-size: 1.1rem;">â€¢</span>
               <span>Your location stays on your device; nothing is uploaded.</span>
           </li>
       </ul>
   `;
   
   const footer = document.createElement("div");
   footer.style.cssText = `
       padding: 15px 28px 20px !important;
       text-align: center !important;
       border-top: 1px solid rgba(0, 0, 0, 0.05);
       margin-top: 10px !important;
       display: flex !important;
       justify-content: center !important;
       align-items: center !important;
       position: relative !important;
       bottom: 0 !important;
       width: 100% !important;
       box-sizing: border-box !important;
   `;
   
   const closeButton = document.createElement("button");
   closeButton.className = "close-button";
   closeButton.textContent = "Close";
   closeButton.style.cssText = `
       padding: 10px 24px !important;
       background-color: ${darkBlue};
       color: white;
       border: none;
       border-radius: 10px;
       cursor: pointer;
       font-size: 1rem;
       font-weight: 600;
       width: 100% !important;
       max-width: 200px !important;
       transition: all 0.2s ease;
       margin: 0 auto !important;
       display: block !important;
       position: relative !important;
       left: 0 !important;
       right: 0 !important;
   `;
   
   footer.appendChild(closeButton);
   
   modalContent.appendChild(header);
   modalContent.appendChild(contentArea);
   modalContent.appendChild(footer);
   modalOverlay.appendChild(modalContent);
   document.body.appendChild(modalOverlay);
   
   setTimeout(() => {
       modalOverlay.style.opacity = "1";
       modalContent.style.transform = "translateY(0)";
   }, 10);
   
   closeButton.addEventListener("mouseover", function() {
       this.style.backgroundColor = darkBlueHover;
   });
   
   closeButton.addEventListener("mouseout", function() {
       this.style.backgroundColor = darkBlue;
   });
   
   closeButton.addEventListener("click", function() {
       modalOverlay.style.opacity = "0";
       modalContent.style.transform = "translateY(20px)";
       setTimeout(() => {
           document.body.removeChild(modalOverlay);
           if (distanceBox) {
               distanceBox.style.display = 'block';
           }
       }, 300);
   });
   
   modalOverlay.addEventListener("click", function(e) {
       if (e.target === modalOverlay) {
           modalOverlay.style.opacity = "0";
           modalContent.style.transform = "translateY(20px)";
           setTimeout(() => {
               document.body.removeChild(modalOverlay);
               if (distanceBox) {
                   distanceBox.style.display = 'block';
               }
           }, 300);
       }
   });
}

function startHunt() {
    gameLocations = locations.sort((a, b) => a.id - b.id);
    currentLocationIndex = 0;
    locationTriggerState.cooldowns.clear();
    lastVisitedLocationId = null;
    loadAllLocations();
    startIdleProximityCheck(); 
}

function getMarkerColor(tours) {
    if (!tours) return '#0f2bab';
    
    switch (tours.toLowerCase()) {
        case 'person':
            return '#FFA500';
        case 'gangster':
            return '#3f9b0b';
        case 'event':
            return '#8B0000';
        case 'place':
            return '#800080';
        default:
            return '#0f2bab';
    }
}

function showAppMessage(appName, redirectUrl) {
    const messageEl = document.createElement('div');
    messageEl.style.cssText = `
        position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
        background: #333; color: white; padding: 35px; border-radius: 12px;
        z-index: 5000; text-align: center; line-height: 1.4;
        max-width: 85vw; box-sizing: border-box;
    `;
    messageEl.innerHTML = `
        <div style="font-size: clamp(22px, 5vw, 30px); font-weight: 500;">
            Opening ${appName}...
        </div>
        <div style="font-size: clamp(18px, 4vw, 24px); margin-top: 15px; opacity: 0.9;">
            To return: Switch back to your browser app
        </div>
    `;
    
    document.body.appendChild(messageEl);
    
    setTimeout(() => {
        messageEl.remove();
        window.location.href = redirectUrl;
    }, 3000);
}

let markersCreated = false;
let activePopups = new Set();

function recenterOnUser() {
    if (userMarker && map) {
        map.setView(userMarker.getLatLng(), map.getZoom(), {
            animate: true,
            duration: 0.5
        });
    }
}

function createMarkersOnly() {
    if (!gameLocations || !Array.isArray(gameLocations) || gameLocations.length === 0) {
        console.warn("No game locations available");
        return;
    }
    
    if (markerClusterGroup) {
        markerClusterGroup.clearLayers();
    }
    
    activePopups.clear();
    
    gameLocations.forEach((location) => {
        if (!location || typeof location.lat !== 'number' || typeof location.lng !== 'number') {
            console.warn("Invalid location data:", location);
            return;
        }
        const markerColor = getMarkerColor(location.tours);
        
        location.markerColor = markerColor;
        
        const locationMarker = L.marker([location.lat, location.lng], {
            icon: L.divIcon({
            className: 'custom-pin-icon',
            html: `<div class="pin-head" style="background-color: ${markerColor};"></div>`,
            iconSize: [30, 30],
            iconAnchor: [15, 30],
        }),
            riseOnHover: false,
            bubblingMouseEvents: false
    });
        
        const popupContent = `
            <div class="popup-content">
                <img loading="lazy" src="${location.image}" alt="${location.name}" class="location-image">
                <h4 class="location-name">
                    <a href="${location.link}" target="_blank" rel="noopener noreferrer" style="text-decoration: none; color: inherit;">${location.name}</a>
                </h4>
                <div class="popup-buttons">
                    <button class="button route-button" data-lat="${location.lat}" data-lng="${location.lng}" data-location-id="${location.id}">Directions</button>
                    <button class="button summary-button" data-location-id="${location.id}">Summary</button>
                </div>
            </div>
        `;
        locationMarker.bindPopup(popupContent, {
            offset: L.point(0, -25),
            className: 'custom-popup',
            maxWidth: 300,
            closeButton: true,
            autoClose: true,
            closeOnClick: true
        });
        
        locationMarker.on('popupopen', function(e) {
            activePopups.add(locationMarker);
            attachPopupEventListeners(e.popup._contentNode, location);
        });
        locationMarker.on('popupclose', function(e) {
            activePopups.delete(locationMarker);
        });
        markerClusterGroup.addLayer(locationMarker);
    });
    
    if (!map.hasLayer(markerClusterGroup)) {
        map.addLayer(markerClusterGroup);
    }
    
    markersCreated = true;
}

function attachPopupEventListeners(popupElement, location) {
    const routeButton = popupElement.querySelector('.route-button');
    const summaryButton = popupElement.querySelector('.summary-button');
    if (routeButton && !routeButton.hasAttribute('data-listener-attached')) {
        routeButton.setAttribute('data-listener-attached', 'true');
        routeButton.addEventListener('click', function(event) {
            event.preventDefault();
            event.stopPropagation();
            showNavigationModal(location.lat, location.lng);
        });
    }
    if (summaryButton && !summaryButton.hasAttribute('data-listener-attached')) {
        summaryButton.setAttribute('data-listener-attached', 'true');
        summaryButton.addEventListener('click', function(event) {
            event.preventDefault();
            event.stopPropagation();
            showLocationSummary(location.id);
        });
    }
}

function closeAllPopups() {
    activePopups.forEach(marker => {
        if (marker.isPopupOpen()) {
            marker.closePopup();
        }
    });
    activePopups.clear();
}

function showNavigationModal(destinationLat, destinationLng) {
    closeAllPopups();
    
    const existingModals = document.querySelectorAll('.modal');
    existingModals.forEach(modal => modal.remove());
    
    const modal = document.createElement("div");
    modal.className = "modal";
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
        opacity: 0;
        transition: opacity 0.3s ease;
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    `;
    
    modal.innerHTML = `
       <div class="modal-content" style="
           background-color: white;
           border-radius: 12px;
           padding: 20px;
           width: 90%;
           max-width: 400px;
           min-width: 280px;
           box-shadow: 0 10px 30px rgba(0,0,0,0.3);
           position: relative;
           transform: scale(0.9);
           transition: transform 0.3s ease;
           margin: 0;
           box-sizing: border-box;
       ">
           <h3 style="
               margin: 0 0 20px 0;
               text-align: center;
               color: #333;
               font-size: 1.2rem;
               font-weight: 600;
           ">Choose your preferred navigation app:</h3>
           <div class="modal-buttons" style="
               display: flex;
               flex-direction: column;
               align-items: center;
               gap: 12px;
               width: 100%;
               text-align: center;
           ">
               <button class="modal-button google-maps" style="
                   padding: 14px 20px;
                   margin: 0;
                   border: none;
                   border-radius: 8px;
                   cursor: pointer;
                   font-size: 1rem;
                   font-weight: 600;
                   transition: all 0.2s ease;
                   background-color: #4285F4;
                   color: white;
                   width: 100%;
                   display: flex;
                   align-items: center;
                   justify-content: center;
                   gap: 8px;
                   box-sizing: border-box;
               ">
                   <i class="fab fa-google" style="font-size: 1.1rem;"></i>
                   <span class="btn-text">Google Maps</span>
                   <i class="fas fa-spinner fa-spin location-spinner" style="font-size: 1rem; display: none; margin-left: 8px;"></i>
               </button>
               <button class="modal-button waze" style="
                   padding: 14px 20px;
                   margin: 0;
                   border: none;
                   border-radius: 8px;
                   cursor: pointer;
                   font-size: 1rem;
                   font-weight: 600;
                   transition: all 0.2s ease;
                   background-color: #00D4FF;
                   color: white;
                   width: 100%;
                   display: flex;
                   align-items: center;
                   justify-content: center;
                   gap: 8px;
                   box-sizing: border-box;
               ">
                   <i class="fas fa-route" style="font-size: 1rem;"></i>
                   <span class="btn-text">Waze</span>
                   <i class="fas fa-spinner fa-spin location-spinner" style="font-size: 1rem; display: none; margin-left: 8px;"></i>
               </button>
               <button class="modal-button apple-maps" style="
                   padding: 14px 20px;
                   margin: 0;
                   border: none;
                   border-radius: 8px;
                   cursor: pointer;
                   font-size: 1rem;
                   font-weight: 600;
                   transition: all 0.2s ease;
                   background-color: #007AFF;
                   color: white;
                   width: 100%;
                   display: flex;
                   align-items: center;
                   justify-content: center;
                   gap: 8px;
                   box-sizing: border-box;
               ">
                   <i class="fab fa-apple" style="font-size: 1.1rem;"></i>
                   <span class="btn-text">Apple Maps</span>
                   <i class="fas fa-spinner fa-spin location-spinner" style="font-size: 1rem; display: none; margin-left: 8px;"></i>
               </button>
               <button class="modal-button cancel" style="
                   padding: 14px 20px;
                   margin: 8px 0 0 0;
                   border: 2px solid #ddd;
                   border-radius: 8px;
                   cursor: pointer;
                   font-size: 1rem;
                   font-weight: 600;
                   transition: all 0.2s ease;
                   background-color: white;
                   color: #666;
                   width: 100%;
                   box-sizing: border-box;
               ">Cancel</button>
           </div>
       </div>
   `;
   
   document.body.appendChild(modal);
   
   setTimeout(() => {
       modal.style.opacity = "1";
       modal.querySelector(".modal-content").style.transform = "scale(1)";
   }, 10);
   
   let userLat = null;
   let userLng = null;
   let locationAttempted = false;
   
   const getUserLocation = () => {
       if (locationAttempted) return Promise.resolve();
       locationAttempted = true;
       
       return new Promise((resolve) => {
           if (navigator.geolocation) {
               navigator.geolocation.getCurrentPosition(
                   (position) => {
                       userLat = position.coords.latitude;
                       userLng = position.coords.longitude;
                       resolve();
                   },
                   (error) => {
                       console.log("Location access denied or failed");
                       resolve();
                   },
                   {
                       timeout: 5000,
                       enableHighAccuracy: false
                   }
               );
           } else {
               resolve();
           }
       });
   };
   
   const closeModal = () => {
       modal.style.opacity = "0";
       modal.querySelector(".modal-content").style.transform = "scale(0.9)";
       setTimeout(() => {
           if (modal.parentNode) {
               modal.remove();
           }
       }, 300);
   };
   
   const showReminderModal = (navigationUrl) => {
       const reminderModal = document.createElement("div");
       reminderModal.className = "reminder-modal";
       reminderModal.style.cssText = `
           position: fixed;
           top: 0;
           left: 0;
           width: 100%;
           height: 100%;
           background-color: rgba(0, 0, 0, 0.7);
           backdrop-filter: blur(4px);
           display: flex;
           justify-content: center;
           align-items: center;
           z-index: 10001;
           opacity: 0;
           transition: opacity 0.3s ease;
       `;
       
       reminderModal.innerHTML = `
           <div class="reminder-content" style="
               background-color: white;
               border-radius: 16px;
               padding: 24px;
               width: 90%;
               max-width: 400px;
               min-width: 280px;
               box-shadow: 0 15px 40px rgba(0,0,0,0.2);
               text-align: center;
               transform: translateY(20px);
               transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
           ">
               <div style="
                   width: 60px;
                   height: 60px;
                   background-color: #2c5282;
                   border-radius: 50%;
                   display: flex;
                   align-items: center;
                   justify-content: center;
                   margin: 0 auto 20px;
               ">
                   <i class="fas fa-map-marker-alt" style="color: white; font-size: 24px;"></i>
               </div>
               <h3 style="
                   margin: 0 0 15px 0;
                   color: #2c3e50;
                   font-size: 1.3rem;
                   font-weight: 600;
               ">Navigation Reminder</h3>
               <p style="
                   margin: 0 0 25px 0;
                   color: #5c6c7c;
                   line-height: 1.5;
                   font-size: 1rem;
               ">Remember to return to this map when you arrive at your destination to continue exploring!</p>
               <button class="reminder-ok-btn" style="
                   padding: 12px 30px;
                   background-color: #2c5282;
                   color: white;
                   border: none;
                   border-radius: 10px;
                   cursor: pointer;
                   font-size: 1rem;
                   font-weight: 600;
                   transition: all 0.2s ease;
                   min-width: 120px;
               ">Got it!</button>
           </div>
       `;
       
       document.body.appendChild(reminderModal);
       
       setTimeout(() => {
           reminderModal.style.opacity = "1";
           reminderModal.querySelector(".reminder-content").style.transform = "translateY(0)";
       }, 10);
       
       const okBtn = reminderModal.querySelector(".reminder-ok-btn");
       okBtn.addEventListener("mouseover", function() {
           this.style.backgroundColor = "#0d2c6e";
       });
       okBtn.addEventListener("mouseout", function() {
           this.style.backgroundColor = "#2c5282";
       });
       
       const closeReminderAndNavigate = () => {
           reminderModal.style.opacity = "0";
           reminderModal.querySelector(".reminder-content").style.transform = "translateY(20px)";
           setTimeout(() => {
               if (reminderModal.parentNode) {
                   reminderModal.remove();
               }
               window.open(navigationUrl, '_blank');
           }, 300);
       };
       
       okBtn.addEventListener("click", closeReminderAndNavigate);
   };
   
   const handleNavigation = async (button, appType) => {
       const spinner = button.querySelector('.location-spinner');
       const btnText = button.querySelector('.btn-text');
       
       spinner.style.display = 'inline-block';
       button.style.opacity = '0.8';
       button.style.cursor = 'wait';
       btnText.textContent = 'Getting location...';
       
       await getUserLocation();
       
       let navigationUrl;
       if (appType === 'google') {
           if (userLat && userLng) {
               navigationUrl = `https://www.google.com/maps/dir/${userLat},${userLng}/${destinationLat},${destinationLng}`;
           } else {
               navigationUrl = `https://www.google.com/maps/dir/?api=1&destination=${destinationLat},${destinationLng}`;
           }
       } else if (appType === 'waze') {
           if (userLat && userLng) {
               navigationUrl = `https://www.waze.com/ul?ll=${destinationLat}%2C${destinationLng}&navigate=yes&from=${userLat}%2C${userLng}`;
           } else {
               navigationUrl = `https://www.waze.com/ul?ll=${destinationLat}%2C${destinationLng}&navigate=yes`;
           }
       } else if (appType === 'apple') {
           const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
           if (!isIOS) {
               closeModal();
               showPopup('Info', 'Apple Maps is only available on iOS devices');
               return;
           }
           if (userLat && userLng) {
               navigationUrl = `maps://maps.apple.com/?saddr=${userLat},${userLng}&daddr=${destinationLat},${destinationLng}`;
           } else {
               navigationUrl = `maps://maps.apple.com/?daddr=${destinationLat},${destinationLng}`;
           }
       }
       
       closeModal();
       showReminderModal(navigationUrl);
   };
   
   const googleMapsBtn = modal.querySelector('.google-maps');
   const wazeBtn = modal.querySelector('.waze');
   const appleMapsBtn = modal.querySelector('.apple-maps');
   const cancelBtn = modal.querySelector('.cancel');
   
   getUserLocation();
   
   googleMapsBtn.addEventListener('mouseover', function() {
       if (this.style.cursor !== 'wait') {
           this.style.backgroundColor = '#3367D6';
           this.style.transform = 'translateY(-1px)';
       }
   });
   googleMapsBtn.addEventListener('mouseout', function() {
       if (this.style.cursor !== 'wait') {
           this.style.backgroundColor = '#4285F4';
           this.style.transform = 'translateY(0)';
       }
   });
   googleMapsBtn.addEventListener('click', () => handleNavigation(googleMapsBtn, 'google'));
   
   wazeBtn.addEventListener('mouseover', function() {
       if (this.style.cursor !== 'wait') {
           this.style.backgroundColor = '#00B8E6';
           this.style.transform = 'translateY(-1px)';
       }
   });
   wazeBtn.addEventListener('mouseout', function() {
       if (this.style.cursor !== 'wait') {
           this.style.backgroundColor = '#00D4FF';
           this.style.transform = 'translateY(0)';
       }
   });
   wazeBtn.addEventListener('click', () => handleNavigation(wazeBtn, 'waze'));
   
   appleMapsBtn.addEventListener('mouseover', function() {
       if (this.style.cursor !== 'wait') {
           this.style.backgroundColor = '#0056CC';
           this.style.transform = 'translateY(-1px)';
       }
   });
   appleMapsBtn.addEventListener('mouseout', function() {
       if (this.style.cursor !== 'wait') {
           this.style.backgroundColor = '#007AFF';
           this.style.transform = 'translateY(0)';
       }
   });
   appleMapsBtn.addEventListener('click', () => handleNavigation(appleMapsBtn, 'apple'));
   
   cancelBtn.addEventListener('mouseover', function() {
       this.style.backgroundColor = '#f5f5f5';
       this.style.borderColor = '#bbb';
   });
   cancelBtn.addEventListener('mouseout', function() {
       this.style.backgroundColor = 'white';
       this.style.borderColor = '#ddd';
   });
   cancelBtn.addEventListener('click', closeModal);
   
   modal.addEventListener('click', (e) => {
       if (e.target === modal) {
           closeModal();
       }
   });
}

function loadAllLocations() {
    if (!gameLocations || !Array.isArray(gameLocations) || gameLocations.length === 0) {
        console.error("No locations available to load");
        showPopup("Error", "No locations available. Please try reloading the page.");
        return;
    }
    
    createMarkersOnly();
    updateDistanceBox();
    resetInactivityTimer();
}

let visibilityTimeout;
document.addEventListener('visibilitychange', function() {
    if (!document.hidden) {
        if (visibilityTimeout) {
            clearTimeout(visibilityTimeout);
        }
        
        visibilityTimeout = setTimeout(() => {
            recenterOnUser();
            if (markerClusterGroup && markerClusterGroup.getLayers().length === 0) {
                createMarkersOnly();
            }
        }, 300);
    }
});

window.addEventListener('focus', function() {
    recenterOnUser();
});

function recenterMapAndClosePopups() {
    closeAllPopups();
    recenterOnUser();
}

function returnToIndex() {
   const distanceBox = document.querySelector('#distanceBox'); 
   if (distanceBox) {
       distanceBox.style.display = 'none';
   }
   
   // Function to detect if running as PWA
   function isPWA() {
       if (window.matchMedia('(display-mode: standalone)').matches) {
           return true;
       }
       if (window.navigator.standalone === true) {
           return true;
       }
       if (document.referrer.includes('android-app://')) {
           return true;
       }
       return false;
   }
   
   // Detect iOS
   function isIOS() {
       return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
   }
   
   // PWA close function that handles iOS properly
   function closePWAApp() {
       if (isIOS()) {
           // For iOS PWAs, we can't actually close the app
           // Show a goodbye screen instead
           document.body.innerHTML = `
               <div style="
                   display: flex;
                   flex-direction: column;
                   justify-content: center;
                   align-items: center;
                   height: 100vh;
                   background: linear-gradient(135deg, var(--dark-blue, #1a365d) 0%, #2d5a87 100%);
                   color: white;
                   font-family: -apple-system, BlinkMacSystemFont, sans-serif;
                   text-align: center;
                   padding: 20px;
                   box-sizing: border-box;
               ">
                   <div style="
                       background: rgba(255,255,255,0.1);
                       border-radius: 20px;
                       padding: 40px;
                       max-width: 350px;
                       backdrop-filter: blur(10px);
                       border: 1px solid rgba(255,255,255,0.2);
                   ">
                       <div style="font-size: 48px; margin-bottom: 20px;">âœ“</div>
                       <h2 style="margin: 0 0 15px 0; font-weight: 600;">Thanks for exploring!</h2>
                       <p style="margin: 0; opacity: 0.9; line-height: 1.4;">
                           Press the home button or swipe up to close the app.
                       </p>
                   </div>
               </div>
           `;
       } else {
           // For Android and desktop PWAs, try to close normally
           window.close();
       }
   }
   
   const popupDiv = document.createElement("div");
   popupDiv.style.cssText = `
       position: fixed;
       top: 0;
       left: 0;
       width: 100%;
       height: 100%;
       background-color: rgba(0,0,0,0.6);
       backdrop-filter: blur(4px);
       display: flex;
       justify-content: center;
       align-items: center;
       z-index: 1000;
       opacity: 0;
       transition: opacity 0.3s ease;
   `;
   
   const darkBlue = "var(--dark-blue)";
   const darkBlueHover = "var(--dark-blue-hover)";
   
   // Determine button text and modal content based on PWA status
   const isRunningAsPWA = isPWA();
   const exitButtonText = isRunningAsPWA ? "Yes, Close App" : "Yes, Exit";
   const modalTitle = isRunningAsPWA ? "Close App?" : "Ready to Leave?";
   const modalMessage = isRunningAsPWA ? 
       "Are you sure you want to close the app?" : 
       "Are you sure you want to return to the main page?";
   
   popupDiv.innerHTML = `
       <div class="modal-container" style="
       background-color: white;
       border-radius: 16px;
       padding: 28px;
       width: 90%;
       max-width: 420px;
       max-height: 90vh;
       box-shadow: 0 15px 40px rgba(0,0,0,0.2);
       margin: auto;
       transform: translateY(20px);
       transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
       overflow: hidden;
       display: flex;
       flex-direction: column;
       ">
       <div style="
           text-align: center;
           margin-bottom: 25px;
       ">
           <svg width="50" height="50" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
           <circle cx="12" cy="12" r="10" stroke="${darkBlue}" stroke-width="1.5"/>
           <path d="M12 8V13" stroke="${darkBlue}" stroke-width="2" stroke-linecap="round"/>
           <circle cx="12" cy="16" r="1" fill="${darkBlue}"/>
           </svg>
       </div>
       <h3 style="
           text-align: center;
           margin: 0 0 15px 0;
           color: #2c3e50;
           font-size: 1.5rem;
           font-weight: 600;
       ">${modalTitle}</h3>
       <div style="flex-grow: 1; overflow-y: auto; padding: 0 10px;">
           <p style="
           text-align: center;
           margin: 0 0 30px 0;
           color: #5c6c7c;
           line-height: 1.5;
           font-size: 1rem;
           ">${modalMessage}</p>
       </div>
       <div style="
           display: flex;
           justify-content: center;
           gap: 15px;
           margin-bottom: 15px;
       ">
           <button class="confirm-btn" style="
           padding: 14px 24px;
           background-color: ${darkBlue};
           color: white;
           border: none;
           border-radius: 10px;
           cursor: pointer;
           font-size: 1rem;
           font-weight: 600;
           min-width: 130px;
           transition: all 0.2s ease;
           ">${exitButtonText}</button>
           <button class="cancel-btn" style="
           padding: 14px 24px;
           background-color: transparent;
           color: ${darkBlue};
           border: 1.5px solid ${darkBlue};
           border-radius: 10px;
           cursor: pointer;
           font-size: 1rem;
           font-weight: 600;
           min-width: 130px;
           transition: all 0.2s ease;
           ">Stay Here</button>
       </div>
       <div style="text-align: center; margin-top: 15px;">
           <a href="#" class="credits-link" style="
           display: inline-block;
           text-align: center;
           color: #64748b;
           text-decoration: none;
           font-size: 0.9rem;
           padding: 8px 20px;
           border-radius: 100px;
           border: 1px solid rgba(100, 116, 139, 0.2);
           background-color: rgba(100, 116, 139, 0.05);
           transition: all 0.2s ease;
           ">View Acknowledgements</a>
       </div>
       </div>
   `;
   
   document.body.appendChild(popupDiv);
   
   setTimeout(() => {
       popupDiv.style.opacity = "1";
       popupDiv.querySelector(".modal-container").style.transform = "translateY(0)";
   }, 10);
   
   const confirmBtn = popupDiv.querySelector(".confirm-btn");
   confirmBtn.addEventListener("mouseover", function() {
       this.style.backgroundColor = darkBlueHover;
   });
   confirmBtn.addEventListener("mouseout", function() {
       this.style.backgroundColor = darkBlue;
   });
   
   const cancelBtn = popupDiv.querySelector(".cancel-btn");
   cancelBtn.addEventListener("mouseover", function() {
       this.style.backgroundColor = "rgba(26, 58, 138, 0.05)";
   });
   cancelBtn.addEventListener("mouseout", function() {
       this.style.backgroundColor = "transparent";
   });
   
   const creditsLink = popupDiv.querySelector(".credits-link");
   creditsLink.addEventListener("mouseover", function() {
       this.style.backgroundColor = "rgba(100, 116, 139, 0.1)";
       this.style.borderColor = "rgba(100, 116, 139, 0.3)";
   });
   creditsLink.addEventListener("mouseout", function() {
       this.style.backgroundColor = "rgba(100, 116, 139, 0.05)";
       this.style.borderColor = "rgba(100, 116, 139, 0.2)";
   });
   
   confirmBtn.addEventListener("click", function() {
       popupDiv.style.opacity = "0";
       popupDiv.querySelector(".modal-container").style.transform = "translateY(20px)";
       setTimeout(() => {
           document.body.removeChild(popupDiv);
           
           // Handle exit based on whether it's PWA or web browser
           if (isRunningAsPWA) {
               closePWAApp();
           } else {
               window.location.href = "/index.html";
           }
       }, 300);
   });
   
   cancelBtn.addEventListener("click", function() {
       popupDiv.style.opacity = "0";
       popupDiv.querySelector(".modal-container").style.transform = "translateY(20px)";
       setTimeout(() => {
           document.body.removeChild(popupDiv);
           if (distanceBox) {
               distanceBox.style.display = 'block';
           }
       }, 300);
   });
   
   creditsLink.addEventListener("click", function(e) {
       e.preventDefault();
       
       const creditsPopup = document.createElement("div");
       creditsPopup.style.cssText = `
           position: fixed;
           top: 0;
           left: 0;
           width: 100%;
           height: 100%;
           background-color: rgba(0,0,0,0.7);
           backdrop-filter: blur(6px);
           display: flex;
           justify-content: center;
           align-items: center;
           z-index: 1001;
           opacity: 0;
           transition: opacity 0.3s ease;
       `;
       
       creditsPopup.innerHTML = `
           <div class="credits-container" style="
               background-color: white;
               border-radius: 16px;
               width: 92%;
               max-width: 450px;
               max-height: 80vh;
               box-shadow: 0 20px 50px rgba(0,0,0,0.25);
               margin: auto;
               transform: translateY(20px);
               transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
               overflow: hidden;
               display: flex;
               flex-direction: column;
           ">
               <div style="
                   background-color: ${darkBlue};
                   padding: 20px;
                   color: white;
                   text-align: center;
               ">
                   <h3 style="margin: 0; font-size: 1.5rem; font-weight: 600;">Acknowledgements</h3>
               </div>
               <div style="
                   padding: 20px;
                   flex-grow: 1;
                   overflow-y: auto;
               ">
                   <ul style="list-style-type: none; padding: 0; margin: 0;">
                       <li style="margin-bottom: 20px;">
                           <strong style="color: #1e293b; font-size: 1.05rem;">OpenStreetMap</strong>
                           <p style="color: #64748b; margin: 5px 0 0 0; font-size: 0.9rem; line-height: 1.5;">
                               Providing the map data and tiles for this interactive experience.
                           </p>
                       </li>
                       <li style="margin-bottom: 20px;">
                           <strong style="color: #1e293b; font-size: 1.05rem;">Minnesota Historical Society</strong>
                           <p style="color: #64748b; margin: 5px 0 0 0; font-size: 0.9rem; line-height: 1.5;">
                               For their invaluable historical data, photographs, and archive materials.
                           </p>
                       </li>
                       <li style="margin-bottom: 20px;">
                           <strong style="color: #1e293b; font-size: 1.05rem;">Metropolitan State University</strong>
                           <p style="color: #64748b; margin: 5px 0 0 0; font-size: 0.9rem; line-height: 1.5;">
                               For fostering a passion for history and research methodology.
                           </p>
                       </li>
                       <li style="margin-bottom: 20px;">
                           <strong style="color: #1e293b; font-size: 1.05rem;">Leaflet.js</strong>
                           <p style="color: #64748b; margin: 5px 0 0 0; font-size: 0.9rem; line-height: 1.5;">
                               The open-source JavaScript library that powers the mapping features.
                           </p>
                       </li>
                       <li>
                           <strong style="color: #1e293b; font-size: 1.05rem;">All Contributors</strong>
                           <p style="color: #64748b; margin: 5px 0 0 0; font-size: 0.9rem; line-height: 1.5;">
                               Researchers, testers, and developers who made this project possible.
                           </p>
                       </li>
                   </ul>
               </div>
               <div style="padding: 15px; text-align: center; border-top: 1px solid #eee;">
                   <button class="close-credits-btn" style="
                       padding: 12px 30px;
                       background-color: ${darkBlue};
                       color: white;
                       border: none;
                       border-radius: 10px;
                       cursor: pointer;
                       font-size: 0.95rem;
                       font-weight: 600;
                       transition: background-color 0.2s ease;
                   ">Close</button>
               </div>
           </div>
       `;
       
       document.body.appendChild(creditsPopup);
       
       setTimeout(() => {
           creditsPopup.style.opacity = "1";
           creditsPopup.querySelector(".credits-container").style.transform = "translateY(0)";
       }, 10);
       
       const closeBtn = creditsPopup.querySelector(".close-credits-btn");
       closeBtn.addEventListener("mouseover", function() {
           this.style.backgroundColor = darkBlueHover;
       });
       closeBtn.addEventListener("mouseout", function() {
           this.style.backgroundColor = darkBlue;
       });
       closeBtn.addEventListener("click", function() {
           creditsPopup.style.opacity = "0";
           creditsPopup.querySelector(".credits-container").style.transform = "translateY(20px)";
           setTimeout(() => {
               document.body.removeChild(creditsPopup);
           }, 300);
       });
       
       creditsPopup.addEventListener("click", function(e) {
           if (e.target === creditsPopup) {
               creditsPopup.style.opacity = "0";
               creditsPopup.querySelector(".credits-container").style.transform = "translateY(20px)";
               setTimeout(() => {
                   document.body.removeChild(creditsPopup);
               }, 300);
           }
       });
   });
   
   popupDiv.addEventListener("click", function(e) {
       if (e.target === popupDiv) {
           popupDiv.style.opacity = "0";
           popupDiv.querySelector(".modal-container").style.transform = "translateY(20px)";
           setTimeout(() => {
               document.body.removeChild(popupDiv);
               if (distanceBox) {
                   distanceBox.style.display = 'block';
               }
           }, 300);
       }
   });
}
        
function isSignificantMovement(newPosition) {
    if (!lastPositionForJitter) {
        lastPositionForJitter = newPosition;
        lastSignificantMovement = Date.now();
        return true;
    }
    
    const distance = calculateDistance(lastPositionForJitter, newPosition);
    const timeSinceLastMovement = Date.now() - lastSignificantMovement;
    
    if (distance > CONFIG.JITTER_THRESHOLD && timeSinceLastMovement > CONFIG.SIGNIFICANT_MOVEMENT_COOLDOWN) {
        lastPositionForJitter = newPosition;
        lastSignificantMovement = Date.now();
        return true;
    }
    
    return false;
}

function resetInactivityTimer(isExplicitInteraction = true) {
    if (inactivityTimer) {
        clearTimeout(inactivityTimer);
        inactivityTimer = null;
    }
    
    inactivityTimer = setTimeout(() => {
        map.closePopup();
        if (!window.isMapInteracting && userMarker) {  
            window.followUser = true;                  
            
            const userPos = userMarker.getLatLng();
            if (userPos && userPos.lat && userPos.lng) {
                map.flyTo(userPos, map.getZoom(), {
                    animate: true,
                    duration: 1.0,
                    easeLinearity: 0.25
                });
            }
        }
    }, CONFIG.INACTIVITY_TIMEOUT);
    
    if (isExplicitInteraction) {
        window.isMapInteracting = false;  
    }
}

function optimizeImages() {
    const images = document.querySelectorAll('img:not([loading])');
    images.forEach(img => {
        img.loading = 'lazy';
        
        if (img.src && !img.width && !img.height) {
            img.onload = function() {
                img.setAttribute('width', img.naturalWidth);
                img.setAttribute('height', img.naturalHeight);
            };
        }
    });
}

 function setupEventListeners() {
    // Enhanced state management with anti-jumping controls
    const interactionState = {
        followUser: true,
        isMapInteracting: false,
        inactivityTimer: null,
        touch: {
            startTime: 0,
            startPos: null,
            isMoving: false,
            isPinching: false,
            initialPinchDistance: 0,
            initialZoom: 0,
            // Anti-jumping additions
            lastUpdateTime: 0,
            velocityBuffer: [],
            smoothedPosition: null,
            jumpThreshold: 50 // pixels - sudden movement detection
        }
    };

    // Anti-jumping configuration
    const ANTI_JUMP_CONFIG = {
        MIN_DRAG_DISTANCE: 12,
        MAX_VELOCITY: 2000,        // pixels/second - filters impossible speeds
        VELOCITY_SAMPLES: 3,       // Number of velocity readings to average
        UPDATE_THROTTLE: 16,       // ~60fps max updates
        COORDINATE_SMOOTHING: 0.7, // Smoothing factor (0.5-0.9)
        PINCH_DEADZONE: 5,         // Minimum pinch distance change
        MOMENTUM_DECAY: 0.8        // iOS momentum scrolling decay
    };

    // Anti-jumping marker management
    const markerAntiJumpSystem = {
        // Store original marker positions during interaction
        originalMarkerPositions: new Map(),
        isInteractionActive: false,
        
        // Preserve marker positions before interaction
        preserveMarkerPositions: () => {
            if (userMarker) {
                const currentPos = userMarker.getLatLng();
                markerAntiJumpSystem.originalMarkerPositions.set('userMarker', {
                    lat: currentPos.lat,
                    lng: currentPos.lng
                });
            }
            
            // Add other markers if needed
            if (window.gameMarkers) {
                for (const [key, marker] of Object.entries(window.gameMarkers)) {
                    if (marker && marker.getLatLng) {
                        const pos = marker.getLatLng();
                        markerAntiJumpSystem.originalMarkerPositions.set(key, {
                            lat: pos.lat,
                            lng: pos.lng
                        });
                    }
                }
            }
        },
        
        // Restore marker positions after interaction
        restoreMarkerPositions: () => {
            if (userMarker && markerAntiJumpSystem.originalMarkerPositions.has('userMarker')) {
                const originalPos = markerAntiJumpSystem.originalMarkerPositions.get('userMarker');
                userMarker.setLatLng([originalPos.lat, originalPos.lng], { animate: false });
            }
            
            // Restore other markers
            if (window.gameMarkers) {
                for (const [key, marker] of Object.entries(window.gameMarkers)) {
                    if (marker && marker.getLatLng && markerAntiJumpSystem.originalMarkerPositions.has(key)) {
                        const originalPos = markerAntiJumpSystem.originalMarkerPositions.get(key);
                        marker.setLatLng([originalPos.lat, originalPos.lng], { animate: false });
                    }
                }
            }
            
            markerAntiJumpSystem.originalMarkerPositions.clear();
        },
        
        // Handle interaction start
        startInteraction: () => {
            markerAntiJumpSystem.isInteractionActive = true;
            markerAntiJumpSystem.preserveMarkerPositions();
        },
        
        // Handle interaction end
        endInteraction: () => {
            markerAntiJumpSystem.isInteractionActive = false;
            markerAntiJumpSystem.restoreMarkerPositions();
        }
    };

    // Enhanced velocity and position tracking
    const trackTouchVelocity = (currentPos, timestamp) => {
        const state = interactionState.touch;
        
        if (state.smoothedPosition && timestamp > state.lastUpdateTime) {
            const deltaTime = timestamp - state.lastUpdateTime;
            const deltaX = currentPos.x - state.smoothedPosition.x;
            const deltaY = currentPos.y - state.smoothedPosition.y;
            const velocity = Math.sqrt(deltaX * deltaX + deltaY * deltaY) / deltaTime * 1000;
            
            // Add to velocity buffer
            state.velocityBuffer.push(velocity);
            if (state.velocityBuffer.length > ANTI_JUMP_CONFIG.VELOCITY_SAMPLES) {
                state.velocityBuffer.shift();
            }
            
            // Calculate average velocity
            const avgVelocity = state.velocityBuffer.reduce((a, b) => a + b, 0) / state.velocityBuffer.length;
            
            // Reject impossible velocities (likely GPS jumps)
            if (avgVelocity > ANTI_JUMP_CONFIG.MAX_VELOCITY) {
                console.debug('High velocity detected, smoothing movement:', avgVelocity);
                return false; // Don't update position
            }
        }
        
        // Apply coordinate smoothing
        if (state.smoothedPosition) {
            const smoothing = ANTI_JUMP_CONFIG.COORDINATE_SMOOTHING;
            state.smoothedPosition = {
                x: state.smoothedPosition.x * smoothing + currentPos.x * (1 - smoothing),
                y: state.smoothedPosition.y * smoothing + currentPos.y * (1 - smoothing)
            };
        } else {
            state.smoothedPosition = { ...currentPos };
        }
        
        state.lastUpdateTime = timestamp;
        return true;
    };

const handleInteractionStart = (source) => {
    // Update GLOBAL state (what your tracking code actually uses)
    window.followUser = false;
    window.isMapInteracting = true;
    
    // Keep your existing logic if needed
    interactionState.followUser = false;
    interactionState.isMapInteracting = true;
    
    if (interactionState.inactivityTimer) {
        clearTimeout(interactionState.inactivityTimer);
        interactionState.inactivityTimer = null;
    }
    
    // Start marker protection
    markerAntiJumpSystem.startInteraction();
    
    console.debug(`Interaction started: ${source}`);
};

const handleInteractionEnd = (source) => {
    // Update GLOBAL state
    window.isMapInteracting = false;
    
    // Keep your existing logic if needed  
    interactionState.isMapInteracting = false;
    
    // End marker protection and restore positions
    markerAntiJumpSystem.endInteraction();
    
    // Reset anti-jumping state
    interactionState.touch.velocityBuffer = [];
    interactionState.touch.smoothedPosition = null;
    
    resetInactivityTimer();
    console.debug(`Interaction ended: ${source}`);
};

    // Enhanced map events with marker protection
    const setupMapEvents = () => {
        if (!map) {
            console.error('Map not available for event setup');
            return;
        }

        try {
            // Store original marker positions before interaction
            map.on('movestart', () => {
                if (!markerAntiJumpSystem.isInteractionActive) {
                    markerAntiJumpSystem.startInteraction();
                }
            });
            
            map.on('dragstart', () => handleInteractionStart('drag'));
            map.on('dragend', () => handleInteractionEnd('drag'));
            map.on('zoomstart', () => handleInteractionStart('zoom'));
            map.on('zoomend', () => handleInteractionEnd('zoom'));
            
            // Restore marker positions after interaction ends
            map.on('moveend', () => {
                if (!interactionState.isMapInteracting && markerAntiJumpSystem.isInteractionActive) {
                    markerAntiJumpSystem.endInteraction();
                }
            });
            
        } catch (error) {
            console.error('Error setting up map events:', error);
        }
    };

    // Enhanced touch events with maximum anti-jumping
    const setupTouchEvents = () => {
        let updateThrottle = null;

        const touchHandlers = {
            start: (e) => {
                try {
                    if (!e.touches || e.touches.length === 0) return;

                    const now = Date.now();
                    const touch = e.touches[0];
                    
                    if (e.touches.length === 1) {
                        // Single touch - reset anti-jumping state
                        interactionState.touch.startTime = now;
                        interactionState.touch.startPos = {
                            x: touch.clientX,
                            y: touch.clientY
                        };
                        interactionState.touch.isMoving = false;
                        interactionState.touch.velocityBuffer = [];
                        interactionState.touch.smoothedPosition = {
                            x: touch.clientX,
                            y: touch.clientY
                        };
                        interactionState.touch.lastUpdateTime = now;
                    } else if (e.touches.length === 2) {
                        // Pinch start
                        interactionState.touch.isPinching = true;
                        handleInteractionStart('pinch');
                        
                        const touch1 = e.touches[0];
                        const touch2 = e.touches[1];
                        
                        interactionState.touch.initialPinchDistance = Math.hypot(
                            touch2.clientX - touch1.clientX,
                            touch2.clientY - touch1.clientY
                        );
                        
                        if (map) {
                            interactionState.touch.initialZoom = map.getZoom();
                        }
                        
                        e.preventDefault();
                    }
                } catch (error) {
                    console.error('Touch start error:', error);
                }
            },

            move: (e) => {
                try {
                    if (!e.touches || e.touches.length === 0) return;

                    const now = Date.now();
                    
                    // Throttle updates to prevent overwhelming the system
                    if (updateThrottle && now - updateThrottle < ANTI_JUMP_CONFIG.UPDATE_THROTTLE) {
                        return;
                    }
                    updateThrottle = now;

                    if (e.touches.length === 1 && interactionState.touch.startPos) {
                        // Single touch move with anti-jumping
                        const touch = e.touches[0];
                        const currentPos = {
                            x: touch.clientX,
                            y: touch.clientY
                        };
                        
                        // Track velocity and smooth position
                        const validMovement = trackTouchVelocity(currentPos, now);
                        if (!validMovement) return;

                        // Use smoothed position for distance calculation
                        const smoothedPos = interactionState.touch.smoothedPosition;
                        const dx = smoothedPos.x - interactionState.touch.startPos.x;
                        const dy = smoothedPos.y - interactionState.touch.startPos.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        // Check for sudden jumps
                        const rawDx = currentPos.x - interactionState.touch.startPos.x;
                        const rawDy = currentPos.y - interactionState.touch.startPos.y;
                        const rawDistance = Math.sqrt(rawDx * rawDx + rawDy * rawDy);
                        
                        if (rawDistance > interactionState.touch.jumpThreshold && distance < ANTI_JUMP_CONFIG.MIN_DRAG_DISTANCE) {
                            console.debug('Touch jump detected and filtered');
                            return;
                        }
                        
                        if (distance > ANTI_JUMP_CONFIG.MIN_DRAG_DISTANCE && !interactionState.touch.isMoving) {
                            interactionState.touch.isMoving = true;
                            handleInteractionStart('touch-drag');
                        }
                    } else if (e.touches.length === 2 && interactionState.touch.isPinching) {
                        // Enhanced pinch zoom with deadzone
                        const touch1 = e.touches[0];
                        const touch2 = e.touches[1];
                        
                        const currentPinchDistance = Math.hypot(
                            touch2.clientX - touch1.clientX,
                            touch2.clientY - touch1.clientY
                        );
                        
                        // Apply deadzone to prevent micro-adjustments
                        const distanceChange = Math.abs(currentPinchDistance - interactionState.touch.initialPinchDistance);
                        if (distanceChange < ANTI_JUMP_CONFIG.PINCH_DEADZONE) {
                            return;
                        }
                        
                        if (map && interactionState.touch.initialPinchDistance > 0) {
                            const pinchRatio = currentPinchDistance / interactionState.touch.initialPinchDistance;
                            
                            // Limit pinch sensitivity to prevent jumping
                            const cappedRatio = Math.max(0.5, Math.min(2.0, pinchRatio));
                            const zoomDelta = Math.log2(cappedRatio) * 1.5; // Reduced from 2 for smoother zoom
                            const newZoom = Math.max(7, Math.min(18, interactionState.touch.initialZoom + zoomDelta));
                            
                            // Calculate center with bounds checking
                            const centerX = Math.max(0, Math.min(window.innerWidth, (touch1.clientX + touch2.clientX) / 2));
                            const centerY = Math.max(0, Math.min(window.innerHeight, (touch1.clientY + touch2.clientY) / 2));
                            const centerPoint = L.point(centerX, centerY);
                            
                            try {
                                const centerLatLng = map.containerPointToLatLng(centerPoint);
                                map.setView(centerLatLng, newZoom, { animate: false });
                            } catch (mapError) {
                                console.debug('Map view update filtered due to invalid coordinates');
                            }
                        }
                        
                        e.preventDefault();
                    }
                } catch (error) {
                    console.error('Touch move error:', error);
                }
            },

            end: (e) => {
                try {
                    const touchEndTime = Date.now();
                    const touchDuration = touchEndTime - interactionState.touch.startTime;
                    
                    if (interactionState.touch.isPinching) {
                        interactionState.touch.isPinching = false;
                        handleInteractionEnd('pinch');
                        
                        if (e.touches.length < 2) {
                            e.preventDefault();
                        }
                    } else if (interactionState.touch.startPos) {
                        // Apply momentum decay for iOS
                        if (ANTI_JUMP_CONFIG.MOMENTUM_DECAY < 1 && interactionState.touch.isMoving) {
                            setTimeout(() => {
                                if (interactionState.isMapInteracting) {
                                    handleInteractionEnd('touch-momentum');
                                }
                            }, 100);
                        }
                        
                        if (touchDuration >= 300 || interactionState.touch.isMoving) {
                            handleInteractionEnd('touch-drag');
                        }
                    }
                    
                    // Complete state reset
                    interactionState.touch.startPos = null;
                    interactionState.touch.isMoving = false;
                    interactionState.touch.velocityBuffer = [];
                    interactionState.touch.smoothedPosition = null;
                    updateThrottle = null;
                } catch (error) {
                    console.error('Touch end error:', error);
                }
            }
        };

        // Add listeners with enhanced error handling
        try {
            document.addEventListener('touchstart', touchHandlers.start, { passive: false });
            document.addEventListener('touchmove', touchHandlers.move, { passive: false });
            document.addEventListener('touchend', touchHandlers.end, { passive: false });
            
            // Additional jump prevention for problematic devices
            document.addEventListener('touchcancel', touchHandlers.end, { passive: false });
        } catch (error) {
            console.error('Error setting up touch events:', error);
        }
    };

    const setupButtonEvents = () => {
        const buttonConfigs = [
            { id: 'recenterButton', handler: recenterMap, required: true },
            { id: 'returnButton', handler: returnToIndex, required: true },
            { id: 'tipsButton', handler: showNavigationTips, required: false }
        ];

        buttonConfigs.forEach(config => {
            try {
                const element = document.getElementById(config.id);
                if (element) {
                    element.addEventListener('click', config.handler);
                    console.debug(`${config.id} event listener attached`);
                } else if (config.required) {
                    console.error(`Required button element not found: ${config.id}`);
                } else {
                    console.warn(`Optional button element not found: ${config.id}`);
                }
            } catch (error) {
                console.error(`Error setting up ${config.id} event:`, error);
            }
        });
    };

    const setupAccessibilityEvents = () => {
        try {
            const contrastToggle = cachedElements?.contrastToggle;
            if (contrastToggle && typeof toggleHighContrast === 'function') {
                contrastToggle.addEventListener('click', toggleHighContrast);
                
                if (typeof accessibilityState !== 'undefined' && accessibilityState.highContrast) {
                    document.body.classList.add('high-contrast');
                }
                
                console.debug('Accessibility events setup complete');
            } else {
                console.warn('Contrast toggle or handler not available');
            }
        } catch (error) {
            console.error('Error setting up accessibility events:', error);
        }
    };

    const setupSystemEvents = () => {
        try {
            document.addEventListener('visibilitychange', () => {
                try {
                    if (typeof handleVisibilityChange === 'function') {
                        handleVisibilityChange();
                    }
                } catch (error) {
                    console.error('Visibility change handler error:', error);
                }
            });

            let resizeTimeout;
            window.addEventListener('resize', () => {
                try {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => {
                        if (map) {
                            map.invalidateSize();
                        }
                        if (typeof updateDistanceBox === 'function') {
                            updateDistanceBox();
                        }
                    }, 250);
                } catch (error) {
                    console.error('Resize handler error:', error);
                }
            });

            console.debug('System events setup complete');
        } catch (error) {
            console.error('Error setting up system events:', error);
        }
    };

    // Initialize all event listeners
    try {
        setupMapEvents();
        setupTouchEvents();
        setupButtonEvents();
        setupAccessibilityEvents();
        setupSystemEvents();
        
        console.log('All event listeners setup complete with anti-jumping protection');
    } catch (error) {
        console.error('Critical error in setupEventListeners:', error);
    }
}

document.addEventListener('DOMContentLoaded', () => {
    console.log('DOM loaded, initializing application...');
    
    const initSteps = [
        { name: 'Cache Elements', fn: () => cacheElements() },
        { name: 'Initialize Map', fn: () => initMap() },
        { name: 'Setup Event Listeners', fn: () => setupEventListeners() },
        { name: 'Optimize Images', fn: () => optimizeImages() },
        { name: 'Initialize UI', fn: () => initializeUI() }
    ];

    let successCount = 0;
    
    initSteps.forEach((step, index) => {
        try {
            if (typeof step.fn === 'function') {
                step.fn();
                successCount++;
                console.debug(`âœ“ ${step.name} completed`);
            } else {
                console.warn(`âš  ${step.name} function not available`);
            }
        } catch (error) {
            console.error(`âœ— ${step.name} failed:`, error);
        }
    });

    console.log(`Application initialization: ${successCount}/${initSteps.length} steps completed`);
});

function initializeUI() {
    try {
        const additionalInfoContainer = cachedElements?.additionalInfoContainer;
        if (additionalInfoContainer) {
            additionalInfoContainer.style.display = 'none';
        }
        
        const lochuntContainer = cachedElements?.lochuntContainer;
        if (lochuntContainer) {
            lochuntContainer.style.display = 'none';
        }

        console.debug('UI initialization complete');
    } catch (error) {
        console.error('UI initialization error:', error);
    }
}
    </script>
</body>
</html>
