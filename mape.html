<!doctype html>
<html lang="en">
<head> 
    <!-- Primary Meta Tags -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, minimum-scale=1.0, user-scalable=yes">
    <title>Minnesota Then | Museum Without Walls</title>
    <meta name="description"
      content="Explore Minnesota history on interactive maps—GPS-guided, offline-ready tours with historic photos, audio, and spatial analysis.">
    <meta name="keywords"
      content="Minnesota history tours, interactive map, location-based museum, offline GIS, historical audio tours, mobile history app">
    
    <!-- Favicon -->
   <link rel="shortcut icon" type="image/x-icon"
      href="https://www.mnthen.com/images/mnthenfav.ico">
    
    <!-- Enhanced PWA Manifest -->
    <link rel="manifest" href="/manifest.json">
    <meta name="theme-color" content="#2c5282">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Minnesota Then">

    <!-- Enterprise Security Headers -->
    <meta http-equiv="X-Content-Type-Options" content="nosniff">
    <meta http-equiv="X-XSS-Protection" content="1; mode=block">
    <meta http-equiv="Referrer-Policy" content="strict-origin-when-cross-origin">
    <meta http-equiv="Permissions-Policy" content="geolocation=(self), camera=(), microphone=(), payment=(), usb=()">
    <meta http-equiv="Cross-Origin-Embedder-Policy" content="unsafe-none">
    <meta http-equiv="Cross-Origin-Opener-Policy" content="same-origin">
    
    <meta name="referrer" content="strict-origin-when-cross-origin">
    <meta name="color-scheme" content="light">
    
    <!-- Open Graph / Facebook Meta Tags -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://www.mnthen.com/">
    <meta property="og:title" content="Minnesota Then | Museum Without Walls">
    <meta property="og:description" content="Enterprise-grade historical GIS platform with advanced spatial analysis and offline capabilities.">
    <meta property="og:image" content="https://mnthen.com/images/index/index_1.jpg">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    
    <!-- Twitter Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@MinnesotaThen">
    <meta name="twitter:title" content="Minnesota Then | Museum Without Walls">
    <meta name="twitter:description" content="Enterprise-grade historical GIS platform with advanced spatial analysis capabilities.">
    <meta name="twitter:image" content="https://mnthen.com/images/index/index_1.jpg">
    
    <!-- Canonical URL -->
    <link rel="canonical" href="https://www.mnthen.com/">

    <!-- Resource hints for faster connections -->
    <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
    <link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
    <link rel="preconnect" href="https://unpkg.com" crossorigin>
    <link rel="preconnect" href="https://www.mnthen.com" crossorigin>

    <!-- DNS Prefetch for additional domains -->
    <link rel="dns-prefetch" href="//tile.openstreetmap.org">
    <link rel="dns-prefetch" href="//a.tile.openstreetmap.org">
    <link rel="dns-prefetch" href="//b.tile.openstreetmap.org">
    <link rel="dns-prefetch" href="//c.tile.openstreetmap.org">
    <link rel="dns-prefetch" href="//fonts.googleapis.com">
    <link rel="dns-prefetch" href="//fonts.gstatic.com">

    <!-- Critical CSS - Load synchronously to prevent FOUC -->
    <link rel="stylesheet" href="https://www.mnthen.com/css/mainmap.css">
    <link rel="stylesheet" href="https://www.mnthen.com/css/mnthen_main_map2.css">

    <!-- Framework CSS - Load synchronously -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" crossorigin>

    <!-- Icon fonts - Load synchronously -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css" crossorigin>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.css" crossorigin>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" crossorigin>
    
    <!-- Standard CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css">
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css">
    
    <!-- Structured Data -->
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "WebApplication",
  "name": "Minnesota Then",
  "alternateName": "Minnesota Then Enterprise GIS",
  "url": "https://www.mnthen.com",
  "description": "Enterprise-grade historical GIS platform for Minnesota with advanced spatial analysis and offline capabilities.",
  "applicationCategory": ["ProductivityApplication", "EducationApplication"],
  "operatingSystem": "Web",
  "browserRequirements": "Requires JavaScript. Compatible with modern browsers.",
  "softwareVersion": "2.0",
  "datePublished": "2024-01-01",
  "dateModified": "2025-07-05",
  "inLanguage": "en-US",
  "isAccessibleForFree": true,
  "offers": {
    "@type": "Offer",
    "price": "0",
    "priceCurrency": "USD",
    "availability": "https://schema.org/InStock"
  },
  "creator": {
    "@type": "Organization",
    "name": "Minnesota Then",
    "url": "https://www.mnthen.com"
  },
  "featureList": [
    "Interactive historical maps",
    "Location-based tours",
    "Offline map capabilities",
    "Spatial analysis tools",
    "Historical content exploration"
  ],
  "screenshot": "https://www.mnthen.com/images/social-share.jpg",
  "aggregateRating": {
    "@type": "AggregateRating",
    "ratingValue": "4.8",
    "ratingCount": "150"
  }
}
</script>

<!-- Geolocation Schema -->
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "TouristDestination",
  "name": "Minnesota Historical Sites",
  "description": "Explore historical locations across Minnesota with enterprise GIS capabilities",
  "geo": {
    "@type": "GeoCoordinates",
    "latitude": "46.7296",
    "longitude": "-94.6859"
  },
  "containedInPlace": {
    "@type": "State",
    "name": "Minnesota",
    "addressCountry": "US"
  },
  "touristType": [
    "History enthusiasts",
    "Educational groups",
    "Cultural tourists"
  ],
  "availableLanguage": "en-US"
}
</script>

<!-- Organization Schema -->
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "Organization",
  "name": "Minnesota Then",
  "url": "https://www.mnthen.com",
  "logo": "https://www.mnthen.com/images/mnthenfav.ico",
  "sameAs": [
    "https://twitter.com/MinnesotaThen"
  ],
  "foundingDate": "2024",
  "description": "Digital platform preserving and sharing Minnesota's historical heritage through interactive mapping technology.",
  "knowsAbout": [
    "Minnesota History",
    "Historical GIS",
    "Digital Heritage",
    "Interactive Maps"
  ]
}
</script>

<style>
/* FOUC-PROOF RENDER LOCK - Hide the entire document until every stylesheet & font is ready.
   The .unlock class is added by inline JS once window.load fires. */
html {
  visibility: hidden !important;
}
html.unlock {
  visibility: visible !important;
}

/* DESIGN TOKENS */
:root {
  --primary-color:       #0066cc;
  --hover-color:         #e6f0ff;
  --dark-blue:           #1a3a8a;
  --dark-blue-hover:     #0d2c6e;
  --success-color:       #28a745;
  --warning-color:       #ffc107;
  --error-color:         #dc3545;
}

/* RESET & GLOBAL HELPERS */
*,
*::before,
*::after { box-sizing: border-box; }

body {
  margin: 0;
  padding: 0;
  font-family: Inter, system-ui, Avenir, Helvetica, Arial, sans-serif;
  background-color: #f8f9fa;
}

/* MAP CANVAS */
#map {
  position: fixed;
  top: 0;
  left: 0;
  z-index: 1;
  width: 100vw;
  height: 100vh;       /* fallback */
  height: 100dvh;      /* modern dynamic viewport */
  touch-action: none;
  -webkit-user-select: none;
  user-select: none;
  will-change: transform;
}

/* iOS 100vh fix */
@supports (-webkit-touch-callout: none) {
  #map,
  .lochunt-container {
    height: -webkit-fill-available;
  }
}

/* dvh fallback */
@supports not (height: 100dvh) {
  #map { height: 100vh; }
}

/* Distance indicator */
#distanceBox {
  position: fixed;
  top: 20px;
  right: 20px;
  z-index: 1003;
  background: white;
  padding: 12px 24px;
  border-radius: 50px;
  font-weight: 600;
  font-size: 20px;
  text-align: center;
  min-width: 200px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
  border: 3px solid var(--dark-blue);
  transition: all 0.3s ease;
  opacity: 0;           /* hidden until hydrated */
  visibility: hidden;
}

#distanceBox.show {
  opacity: 1;
  visibility: visible;
}

#distanceBox.proximity-close {
  background: linear-gradient(135deg, #28a745, #20c997);
  color: white;
  animation: pulse 1.5s infinite;
}

#distanceBox.proximity-medium {
  background: linear-gradient(135deg, #ffc107, #fd7e14);
  color: white;
}

#distanceBox.proximity-far {
  background: white;
  color: var(--dark-blue);
  border-color: var(--dark-blue);
}

/* Map action buttons */
.map-buttons {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  display: flex;
  justify-content: space-evenly;
  align-items: center;
  gap: 0.5rem;
  margin-bottom: 30px;
}

/* Markers */
.user-marker-icon {
  width: 22px;
  height: 22px;
  background: radial-gradient(circle, #dc3545 0%, #a71e2a 70%);
  border: 3px solid white;
  border-radius: 50%;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
  transition: all 0.3s ease;
}

.user-marker-icon.moving {
  /* Removing line: animation: pulse 2s infinite; */
}

.marker-cluster-custom {
  background: rgba(44, 82, 130, 0.9);
  border-radius: 50%;
  color: white;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 600;
}

.marker-cluster-custom div {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
}

#accuracyIndicator {
    position: absolute;
    top: 10px;
    left: 10px;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    border: 2px solid rgba(255, 255, 255, 0.8);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    z-index: 1000;
    transition: background-color 0.3s ease;
}

/* hide the accuracy indicator on narrow screens */
@media (max-width: 360px) {
  #accuracyIndicator {
    display: none;
  }
}
    
/* ANIMATIONS */
@keyframes pulse {
  0%, 100% { opacity: 0.8; }
  50% { opacity: 1; }
}

@keyframes gradientShift {
  0% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes fadeOut {
  from { opacity: 1; }
  to { opacity: 0; }
}

.fade-in { animation: fadeIn 0.3s ease forwards; }
.fade-out { animation: fadeOut 0.3s ease forwards; }

/* UTILITIES */
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border: 0;
}

/* RESPONSIVE LOADING MESSAGE */
@media (max-width: 500px) {
  #loadingMessage > div {
    width: 85% !important;
    height: auto !important;
    min-height: 480px !important;
    padding: 25px 20px !important;
  }
}
</style>

<script>
(function() {
  'use strict';
  
  // Prevent multiple executions
  if (window.foucBusterActive) return;
  window.foucBusterActive = true;
  
  let isUnlocked = false;
  let emergencyTimeout;
  let fontCheckTimeout;
  
  // Perfect unlock function
  function unlock() {
    if (isUnlocked) return;
    isUnlocked = true;
    
    // Clear all safety timeouts
    clearTimeout(emergencyTimeout);
    clearTimeout(fontCheckTimeout);
    
    // Smooth unlock transition
    requestAnimationFrame(() => {
      document.documentElement.classList.add('unlock');
      
      // Accessibility announcement for screen readers
      setTimeout(() => {
        const announcement = document.createElement('div');
        announcement.setAttribute('aria-live', 'polite');
        announcement.setAttribute('aria-atomic', 'true');
        announcement.style.cssText = 'position:absolute;left:-10000px;width:1px;height:1px;overflow:hidden;';
        announcement.textContent = 'Application loaded and ready';
        document.body.appendChild(announcement);
        
        setTimeout(() => {
          if (announcement.parentNode) {
            announcement.parentNode.removeChild(announcement);
          }
        }, 1000);
      }, 100);
      
      // Dispatch unlock event for other scripts
      try {
        window.dispatchEvent(new CustomEvent('foucUnlocked', { detail: { timestamp: Date.now() } }));
      } catch (e) {
        // IE11 fallback
        const event = document.createEvent('CustomEvent');
        event.initCustomEvent('foucUnlocked', false, false, { timestamp: Date.now() });
        window.dispatchEvent(event);
      }
    });
  }
  
  // Font loading detection for critical fonts
  function checkCriticalFonts() {
    if (!document.fonts || !document.fonts.ready) {
      return Promise.resolve();
    }
    
    return new Promise((resolve) => {
      // Wait for Inter font (your main font) to load
      document.fonts.ready.then(() => {
        resolve();
      }).catch(() => {
        resolve(); // Don't block on font errors
      });
      
      // Font loading timeout (2 seconds max)
      fontCheckTimeout = setTimeout(resolve, 2000);
    });
  }
  
  // Check if critical CSS has loaded
  function verifyCSSLoaded() {
    return new Promise((resolve) => {
      // Test if our CSS variables are available
      const testDiv = document.createElement('div');
      testDiv.style.cssText = 'position:absolute;visibility:hidden;color:var(--primary-color);';
      document.body.appendChild(testDiv);
      
      const computedColor = window.getComputedStyle(testDiv).color;
      const hasCSS = computedColor && computedColor !== 'var(--primary-color)';
      
      if (testDiv.parentNode) {
        testDiv.parentNode.removeChild(testDiv);
      }
      
      if (hasCSS) {
        resolve();
      } else {
        // CSS not fully loaded, wait a bit more
        setTimeout(resolve, 100);
      }
    });
  }
  
  // Comprehensive unlock logic
  function initializeUnlock() {
    const checks = [verifyCSSLoaded()];
    
    // Add font check if fonts API is supported
    if (document.fonts) {
      checks.push(checkCriticalFonts());
    }
    
    Promise.all(checks).then(() => {
      // Ensure one more frame for rendering
      requestAnimationFrame(unlock);
    }).catch(() => {
      // Even if checks fail, unlock after short delay
      setTimeout(unlock, 150);
    });
  }
  
  // Emergency timeout - absolute maximum wait (4 seconds)
  emergencyTimeout = setTimeout(() => {
    console.warn('FOUC buster: Emergency unlock triggered after 4 seconds');
    unlock();
  }, 4000);
  
  // Smart initialization based on document state
  if (document.readyState === 'complete') {
    // Document fully loaded
    setTimeout(initializeUnlock, 0);
  } else if (document.readyState === 'interactive') {
    // DOM ready, resources may still be loading
    setTimeout(initializeUnlock, 100);
  } else {
    // Document still loading
    document.addEventListener('DOMContentLoaded', () => {
      setTimeout(initializeUnlock, 50);
    }, { once: true });
  }
  
  // Ultimate safety net
  window.addEventListener('load', () => {
    setTimeout(unlock, 100);
  }, { once: true });
  
  // Handle page visibility changes (back/forward navigation)
  document.addEventListener('visibilitychange', () => {
    if (!document.hidden && !isUnlocked) {
      setTimeout(unlock, 50);
    }
  }, { once: true });
  
  // Emergency user interaction unlock
  const emergencyEvents = ['click', 'touchstart', 'keydown'];
  emergencyEvents.forEach(eventType => {
    document.addEventListener(eventType, () => {
      if (!isUnlocked) {
        setTimeout(unlock, 0);
      }
    }, { once: true, passive: true });
  });
  
  // Handle cases where scripts load out of order
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      setTimeout(initializeUnlock, 50);
    }, { once: true });
  }
  
})();
</script>
</head>
    
<body>
     <noscript>
          <div style="padding:2rem;text-align:center;font-family:sans-serif">
            <h2>JavaScript Required</h2>
            <p>This map requires JavaScript to function. Please enable it in your browser.</p>
          </div>
    </noscript>
    
    <!-- Map container -->
    <div id="map"></div>

    <!-- GPS accuracy indicator, red, yellow, green -->
    <div id="accuracyIndicator"></div>
    
    <!-- Enhanced Distance Box with Dark Blue Border -->
    <div id="distanceBox">Initializing...</div>

    <!-- Location Hunt Container -->
    <div class="lochunt-container">
        <img id="locationImage" src="/placeholder.svg" alt="Location Image">
        <div class="lochunt-content">
            <div class="lochunt-info">
                <h2 id="locationTitle" class="mb-2 text-primary"></h2>
                <p id="locationCity" class="text-muted mb-1"></p>
                <p id="locationCreator" class="text-muted mb-3"></p>
            </div>
            <div class="audio-player">
                <div class="audio-progress">
                    <div class="progress">
                        <div id="progressBar" class="progress-bar" role="progressbar" style="width: 0%"></div>
                    </div>
                </div>
                <div class="audio-time">
                    <span id="currentTime">0:00</span>
                    <span id="duration">0:00</span>
                </div>
                <div class="audio-controls">
                    <button id="rewindBtn" class="audio-button" aria-label="Rewind 10 seconds"><i class="fas fa-backward"></i></button>
                    <button id="playPauseBtn" class="audio-button" aria-label="Play"><i class="fas fa-play"></i></button>
                    <button id="forwardBtn" class="audio-button" aria-label="Forward 10 seconds"><i class="fas fa-forward"></i></button>
                </div>
                <audio id="locationAudio" preload="auto" crossorigin="anonymous"></audio>
            </div>
        </div>
    </div>

    <!-- Additional Info Container -->
    <div class="additional-info-container">
        <h3 class="mb-3 text-primary text-center">Did You Know?</h3>
        <p id="additionalInfo" class="mb-3 fs-6"></p>
        <div class="d-flex justify-content-center">
            <button id="continueButton" class="btn btn-primary">Continue</button>
        </div>
    </div>
    
    <!-- Map Buttons -->
    <div class="map-buttons">
        <button id="recenterButton" class="map-button" aria-label="Recenter map"><i class="fas fa-crosshairs"></i></button>
        <button id="returnButton" class="map-button" aria-label="Return to main page"><i class="fas fa-sign-out-alt"></i></button>
        <button id="tipsButton" class="map-button" aria-label="Show navigation tips"><i class="fas fa-question-circle"></i></button>
    </div>

    <!-- Summary Modal -->
    <div id="summaryModal" class="modal" style="display: none;">
        <div class="modal-content">
            <p id="summaryContent"></p>
        </div>
    </div>

    <!-- Load scripts with defer to improve page load performance -->
    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js" defer></script>
    <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js" defer></script>
    <script src="/locations_main.js?v=1.0.4" defer></script>

    <script>
// MNThen - Complete JavaScript Application with Centered User Icon
if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
        navigator.serviceWorker.register('/test/sw.js')
            .then(registration => {
                console.log('Enterprise SW registered: ', registration);
                navigator.serviceWorker.addEventListener('message', event => {
                    if (event.data.type === 'SW_ACTIVATED') {
                        console.log('Enterprise Service Worker activated, version:', event.data.version);
                    }
                });
                setInterval(() => registration.update(), 60 * 60 * 1000);
                if (registration.waiting && !navigator.serviceWorker.controller) {
                    console.log('Enterprise SW installed & waiting');
                }
            })
            .catch(registrationError => {
                console.log('SW registration failed: ', registrationError);
            });
    });
}

class EnterpriseCacheManager {
    constructor() {
        this.cachePrefix = 'mnthen-enterprise-';
        this.maxCacheSize = 50 * 1024 * 1024;
        this.maxCacheAge = 7 * 24 * 60 * 60 * 1000;
        this.proximityThreshold = 1000;
    }
    async init() {
        await this.cleanupExpiredCache();
        this.startPeriodicCleanup();
    }
    async cacheLocationData(location, userPosition) {
        if (!userPosition || !location) return;
        const distance = this.calculateDistance(userPosition, location);
        const distanceFeet = distance * 3.28084;
        if (distanceFeet <= this.proximityThreshold) {
            try {
                const cacheData = {
                    location: location,
                    timestamp: Date.now(),
                    userPosition: userPosition,
                    distance: distanceFeet
                };
                const encryptedData = await this.encryptData(JSON.stringify(cacheData));
                localStorage.setItem(`${this.cachePrefix}location_${location.id}`, encryptedData);
                console.log(`Cached location ${location.name} (${distanceFeet.toFixed(0)} feet away)`);
            } catch (error) {
                console.warn('Failed to cache location data:', error);
            }
        }
    }
    async encryptData(data) {
        if (!window.crypto || !window.crypto.subtle) {
            return btoa(data);
        }
        try {
            const key = await window.crypto.subtle.generateKey(
                { name: 'AES-GCM', length: 256 },
                false,
                ['encrypt']
            );
            const iv = window.crypto.getRandomValues(new Uint8Array(12));
            const encodedData = new TextEncoder().encode(data);
            const encrypted = await window.crypto.subtle.encrypt(
                { name: 'AES-GCM', iv: iv },
                key,
                encodedData
            );
            return btoa(String.fromCharCode(...new Uint8Array(encrypted)));
        } catch (error) {
            console.warn('Encryption failed, using base64:', error);
            return btoa(data);
        }
    }
    async cleanupExpiredCache() {
        const now = Date.now();
        const keysToRemove = [];
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.startsWith(this.cachePrefix)) {
                try {
                    const data = JSON.parse(atob(localStorage.getItem(key)));
                    if (now - data.timestamp > this.maxCacheAge) {
                        keysToRemove.push(key);
                    }
                } catch (error) {
                    keysToRemove.push(key);
                }
            }
        }
        keysToRemove.forEach(key => localStorage.removeItem(key));
        if (keysToRemove.length > 0) {
            console.log(`Cleaned up ${keysToRemove.length} expired cache entries`);
        }
    }
    startPeriodicCleanup() {
        setInterval(() => {
            this.cleanupExpiredCache();
        }, 60 * 60 * 1000);
    }
    calculateDistance(pos1, pos2) {
        const R = 6371000;
        const lat1 = pos1.lat * Math.PI / 180;
        const lat2 = pos2.lat * Math.PI / 180;
        const deltaLat = (pos2.lat - pos1.lat) * Math.PI / 180;
        const deltaLng = (pos2.lng - pos1.lng) * Math.PI / 180;
        const a = Math.sin(deltaLat/2) * Math.sin(deltaLat/2) +
                Math.cos(lat1) * Math.cos(lat2) *
                Math.sin(deltaLng/2) * Math.sin(deltaLng/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        return R * c;
    }
}

class EnterpriseSecurityManager {
    constructor() {
        this.sessionToken = this.generateSecureToken();
        this.auditLog = [];
        this.cspViolations = [];
    }
    generateSecureToken() {
        const array = new Uint8Array(32);
        window.crypto.getRandomValues(array);
        return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
    }
    logSecurityEvent(event, details) {
        const logEntry = {
            timestamp: new Date().toISOString(),
            event: event,
            details: details,
            sessionToken: this.sessionToken,
            userAgent: navigator.userAgent,
            url: window.location.href
        };
        this.auditLog.push(logEntry);
        console.log('Security Event:', logEntry);
        if (this.auditLog.length > 100) {
            this.auditLog.shift();
        }
    }
    monitorCSPViolations() {
        document.addEventListener('securitypolicyviolation', (e) => {
            this.cspViolations.push({
                timestamp: new Date().toISOString(),
                violatedDirective: e.violatedDirective,
                blockedURI: e.blockedURI,
                documentURI: e.documentURI
            });
            this.logSecurityEvent('CSP_VIOLATION', {
                directive: e.violatedDirective,
                uri: e.blockedURI
            });
        });
    }
    init() {
        this.monitorCSPViolations();
        this.logSecurityEvent('SESSION_START', { timestamp: Date.now() });
    }
}

class EnterprisePerformanceMonitor {
    constructor() {
        this.metrics = {
            fps: 60, // Start with ideal value
            memory: 0,
            loadedLocations: 0,
            cacheHits: 0,
            networkRequests: 0
        };
        this.lastFrameTime = performance.now();
        this.frameCount = 0;
        this.alertCooldown = 0;
        this.isMonitoring = false;
    }
    
    startMonitoring() {
        if (this.isMonitoring) return;
        this.isMonitoring = true;
        
        this.monitorFPS();
        this.monitorMemory();
        setInterval(() => this.updateMetrics(), 5000); 
    }
    
    monitorFPS() {
        const measureFPS = (currentTime) => {
            if (!this.isMonitoring) return;
            
            this.frameCount++;
            const timeElapsed = currentTime - this.lastFrameTime;
            
            if (timeElapsed >= 1000) {
                // Only update FPS if we have meaningful frame data
                const calculatedFPS = Math.round((this.frameCount * 1000) / timeElapsed);
                
                // Filter out unrealistic values (0, extremely low, or extremely high)
                if (calculatedFPS > 0 && calculatedFPS <= 120) {
                    this.metrics.fps = calculatedFPS;
                }
                // If we get 0 FPS, it's likely the tab is hidden - don't update
                
                this.frameCount = 0;
                this.lastFrameTime = currentTime;
            }
            
            if (this.isMonitoring) {
                requestAnimationFrame(measureFPS);
            }
        };
        
        // Only monitor when tab is visible
        if (!document.hidden) {
            requestAnimationFrame(measureFPS);
        }
        
        // Restart monitoring when tab becomes visible
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden && this.isMonitoring) {
                this.lastFrameTime = performance.now();
                this.frameCount = 0;
                requestAnimationFrame(measureFPS);
            }
        });
    }
    
    monitorMemory() {
        if (performance.memory) {
            setInterval(() => {
                if (this.isMonitoring) {
                    this.metrics.memory = Math.round(performance.memory.usedJSHeapSize / 1024 / 1024);
                }
            }, 10000); 
        }
    }
    
    updateMetrics() {
        if (!this.isMonitoring) return;
        
        if (window.gameLocations) {
            this.metrics.loadedLocations = window.gameLocations.length;
        }
        
        // Cooldown to prevent spam
        if (this.alertCooldown > 0) {
            this.alertCooldown--;
            return;
        }
        
        // More realistic alert conditions
        const isLowFPS = this.metrics.fps > 0 && this.metrics.fps < 25; 
        const isHighMemory = this.metrics.memory > 150; 
        
        if (isLowFPS || isHighMemory) {
            console.warn('Performance Alert:', this.metrics);
            this.alertCooldown = 12; // ~1 minute cooldown (12 * 5s = 60s)
        }
    }
    
    getMetrics() {
        return this.metrics;
    }
    
    stopMonitoring() {
        this.isMonitoring = false;
    }
}

class EnterpriseBackgroundSync {
    constructor() {
        this.syncQueue = [];
        this.isOnline = navigator.onLine;
        this.setupEventListeners();
    }
    setupEventListeners() {
        window.addEventListener('online', () => {
            this.isOnline = true;
            this.processSyncQueue();
        });
        window.addEventListener('offline', () => {
            this.isOnline = false;
        });
    }
    addToSyncQueue(data) {
        this.syncQueue.push({
            timestamp: Date.now(),
            data: data,
            retries: 0
        });
        if (this.isOnline) {
            this.processSyncQueue();
        }
    }
    async processSyncQueue() {
        while (this.syncQueue.length > 0 && this.isOnline) {
            const item = this.syncQueue.shift();
            try {
                await this.syncData(item.data);
                console.log('Background sync completed for:', item.data.type);
            } catch (error) {
                item.retries++;
                if (item.retries < 3) {
                    this.syncQueue.push(item);
                }
                console.warn('Background sync failed:', error);
            }
        }
    }
    async syncData(data) {
        return new Promise((resolve) => {
            setTimeout(resolve, 100);
        });
    }
}

const enterpriseCacheManager = new EnterpriseCacheManager();
const enterpriseSecurityManager = new EnterpriseSecurityManager();
const enterprisePerformanceMonitor = new EnterprisePerformanceMonitor();
const enterpriseBackgroundSync = new EnterpriseBackgroundSync();

document.addEventListener('DOMContentLoaded', () => {
    enterpriseCacheManager.init();
    enterpriseSecurityManager.init();
    enterprisePerformanceMonitor.startMonitoring();
});

const CONFIG = {
    DISTANCE_THRESHOLD: 20,
    EXTENDED_DISTANCE_THRESHOLD: 100,
    MIN_DISTANCE_THRESHOLD: 2,
    PROXIMITY_THRESHOLD: 50,
    JITTER_THRESHOLD: 5,
    MICRO_MOVEMENT_THRESHOLD: 0.3,
    BACKGROUND_THRESHOLD: 25000,
    INACTIVITY_TIMEOUT: 29000,
    UPDATE_INTERVAL: 50,
    MIN_CENTERING_INTERVAL: 1000,
    STATIONARY_TIME_THRESHOLD: 5000,
    STATIONARY_CHECK_INTERVAL: 2500,
    SIGNIFICANT_MOVEMENT_COOLDOWN: 2000,
    RETRY_DELAY: 1000,
    ZOOM_COOLDOWN: 10000,
    MIN_RECENTER_INTERVAL: 2000,
    MAX_BUFFER_SIZE: 5,
    STATIONARY_BUFFER_SIZE: 10,
    MAX_ACCEPTABLE_ACCURACY: 39,
    STATIONARY_ACCURACY_MULTIPLIER: 1.1,
    STATIONARY_ACCURACY_WEIGHT: 0.7,
    MAX_ACCURACY_THRESHOLD: 2500,
    TARGET_ACCURACY_THRESHOLD: 100,
    MAX_SPEED: 80,
    VELOCITY_DECAY: 0.85,
    BEARING_WEIGHT: 0.3,
    SMOOTHING_FACTOR: 0.35,
    STATIONARY_THRESHOLD: 2,
    STATIONARY_SMOOTHING: 0.97,
    STATIONARY_THRESHOLDB: 3,
    MAX_ALPHA: 0.25,
    MIN_ALPHA: 0.02,
    MAX_RETRIES: 3,
    EDGE_THRESHOLD_PERCENTAGE: 0.25,
    STRICT_EDGE_THRESHOLD_PERCENTAGE: 0.15,
    CRITICAL_EDGE_THRESHOLD_PERCENTAGE: 0.07,
    OVERVIEW_ZOOM: 17,
    EXPLORATION_ZOOM: 17,
    DETAIL_ZOOM: 17,
    BASE_ZOOM: 17,
    CLOSE_ZOOM: 19,
    BASE_PROCESS_NOISE: 0.008,
    SPEED_ZOOM_THRESHOLDS: [
        { speed: 45, zoom: 16 },
        { speed: 30, zoom: 16 },
        { speed: 15, zoom: 17 },
        { speed: 10, zoom: 17 },
        { speed: 0, zoom: 17 }
    ],
    BEARING_TOLERANCE: 30,
    DWELL_TIME: 1500,
    LOCATION_COOLDOWN: 120000,
    PREDICTION_ENABLED: true,
    VELOCITY_PREDICTION_FACTOR: 0.35,
    ACCELERATION_DAMPING: 0.75,

   MAX_STATIONARY_CHECKS: 10
};

let map, userMarker, markerClusterGroup;
let tracking;
let currentLocationIndex = 0;
let visitedLocations = [];
let gameLocations = [];
let isLocationHuntVisible = false;
let lastPosition = null;
let positionBuffer = [];
let filteredPosition = null;
let followUser = true;
let lastVisitedLocationId = null;
let lastKnownPosition = null;
let isTransitioning = false;
let lastVelocity = { lat: 0, lng: 0 };
let isMapInteracting = false;
let isStationary = false;
let stationaryStartTime = null;
let stationaryCheckTimeout = null;
let lastUpdateTime = null;
let lastUpdateTimestamp = null;
let stationaryBuffer = [];
let stationaryPosition = null;
let stationaryCount = 0;
let lastSmoothedPosition = null;
let lastHiddenTime = 0;
let retryCount = 0;
let inactivityTimer;
let animationFrameId = null;
let loadingMessageMinDisplayTime = 0;
let lastCenteringTime = 0;
let lastZoomChangeTime = 0;
let isNearLocation = false;
let lastMapUpdateTime = 0;
let lastVisitTime = 0;
let lastSignificantMovement = Date.now();
let lastPositionForJitter = null;

let enhancedTrackingState = {
    velocity: { lat: 0, lng: 0 },
    acceleration: { lat: 0, lng: 0 },
    lastVelocityUpdate: 0,
    speedMPS: 0,
    heading: null,
    isMoving: false,
    stationaryStartTime: null
};

let zoomState = {
    currentTier: 'exploration',
    lastTierChange: 0,
    hysteresisBuffer: [],
    proximityOverride: false
};

let locationTriggerState = {
    cooldowns: new Map(),
    dwellTimers: new Map(),
    lastBearing: null,
    approachingLocations: new Set(),
    lastVibrations: new Map()
};

let accessibilityState = {
    highContrast: localStorage.getItem('highContrast') === 'true',
    lastAnnouncement: '',
    proximityAlerts: new Set()
};

let cachedElements = {};

function cacheElements() {
    cachedElements = {
        distanceBox: document.getElementById('distanceBox'),
        recenterButton: document.getElementById('recenterButton'),
        returnButton: document.getElementById('returnButton'),
        tipsButton: document.getElementById('tipsButton'),
        lochuntContainer: document.querySelector('.lochunt-container'),
        additionalInfoContainer: document.querySelector('.additional-info-container'),
        accessibilityAnnouncements: document.getElementById('accessibility-announcements'),
        proximityAnnouncements: document.getElementById('proximity-announcements'),
        contrastToggle: document.getElementById('contrastToggle')
    };
}

function announceToScreenReader(message, priority = 'polite') {
    const element = priority === 'assertive' ? 
        cachedElements.proximityAnnouncements : 
        cachedElements.accessibilityAnnouncements;
    
    if (element && message !== accessibilityState.lastAnnouncement) {
        element.textContent = message;
        accessibilityState.lastAnnouncement = message;
        
        setTimeout(() => {
            if (element.textContent === message) {
                element.textContent = '';
            }
        }, 1000);
    }
}

function toggleHighContrast() {
    accessibilityState.highContrast = !accessibilityState.highContrast;
    localStorage.setItem('highContrast', accessibilityState.highContrast);
    
    if (accessibilityState.highContrast) {
        document.body.classList.add('high-contrast');
        announceToScreenReader('High contrast mode enabled');
    } else {
        document.body.classList.remove('high-contrast');
        announceToScreenReader('High contrast mode disabled');
    }
}

function triggerHapticFeedback(pattern = [100]) {
    if ('vibrate' in navigator) {
        navigator.vibrate(pattern);
    }
}

function calculateBearing(from, to) {
    const lat1 = from.lat * Math.PI / 180;
    const lat2 = to.lat * Math.PI / 180;
    const deltaLng = (to.lng - from.lng) * Math.PI / 180;
    
    const y = Math.sin(deltaLng) * Math.cos(lat2);
    const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(deltaLng);
    
    const bearing = Math.atan2(y, x) * 180 / Math.PI;
    return (bearing + 360) % 360;
}

function isApproachingLocation(userPos, userBearing, locationPos) {
    // Check for null, undefined, or NaN specifically
    if (userBearing == null || isNaN(userBearing)) {
        return true; // Default to true if bearing is unknown
    }
    
    const bearingToLocation = calculateBearing(userPos, locationPos);
    const bearingDiff = Math.abs(userBearing - bearingToLocation);
    // Calculate the smallest angle between the two bearings
    const normalizedDiff = Math.min(bearingDiff, 360 - bearingDiff);
    
    // Check if the location is within the tolerance cone in front of the user
    return normalizedDiff <= CONFIG.BEARING_TOLERANCE;
}

function calculateIntelligentZoom(speedMPS, distanceToClosestPOI) {
    const currentTime = Date.now();
    const speedMPH = speedMPS * 2.23694;
    
    zoomState.hysteresisBuffer.push({ speed: speedMPH, time: currentTime });
    zoomState.hysteresisBuffer = zoomState.hysteresisBuffer.filter(
        entry => currentTime - entry.time < 10000
    );
    
    const avgSpeed = zoomState.hysteresisBuffer.reduce((sum, entry) => sum + entry.speed, 0) / 
                     zoomState.hysteresisBuffer.length;
    
    let targetTier;
    let targetZoom;
    
    if (distanceToClosestPOI <= CONFIG.PROXIMITY_THRESHOLD) {
        targetTier = 'detail';
        targetZoom = CONFIG.DETAIL_ZOOM;
        zoomState.proximityOverride = true;
    } else {
        zoomState.proximityOverride = false;
        
        if (avgSpeed > 10) {
            targetTier = 'overview';
            targetZoom = CONFIG.OVERVIEW_ZOOM;
        } else if (avgSpeed > 3) {
            targetTier = 'exploration';
            targetZoom = CONFIG.EXPLORATION_ZOOM;
        } else {
            targetTier = 'exploration';
            targetZoom = CONFIG.EXPLORATION_ZOOM;
        }
    }
    
    if (targetTier !== zoomState.currentTier) {
        if (currentTime - zoomState.lastTierChange > CONFIG.ZOOM_COOLDOWN) {
            zoomState.currentTier = targetTier;
            zoomState.lastTierChange = currentTime;
            
            announceToScreenReader(`Map zoom changed to ${targetTier} view`);
            
            return targetZoom;
        } else {
            return map ? map.getZoom() : CONFIG.EXPLORATION_ZOOM;
        }
    }
    
    return targetZoom;
}

function isValidPosition(pos) {
    return pos && 
           typeof pos.lat === 'number' && 
           typeof pos.lng === 'number' && 
           !isNaN(pos.lat) && 
           !isNaN(pos.lng);
}

function setupMemoryManagement() {
    const cleanupTasks = [];
    const managedTimeouts = new Set();
    const managedIntervals = new Set();
    
    const registerCleanupTask = (task) => {
        cleanupTasks.push(task);
    };
    
    // Managed timeout/interval functions
    const setTimeoutManaged = (callback, delay) => {
        const id = setTimeout(() => {
            callback();
            managedTimeouts.delete(id);
        }, delay);
        managedTimeouts.add(id);
        return id;
    };
    
    const setIntervalManaged = (callback, delay) => {
        const id = setInterval(callback, delay);
        managedIntervals.add(id);
        return id;
    };
    
    const cleanupAudioResources = () => {
        const audioElements = document.querySelectorAll('audio');
        audioElements.forEach(audio => {
            audio.pause();
            audio.src = '';
            audio.load();
        });
    };
    
    const cleanupMapResources = () => {
        if (markerClusterGroup) {
            markerClusterGroup.clearLayers();
        }
        
        if (animationFrameId !== null) {
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
        }
        
        // Safe timeout/interval cleanup - only clears ones we tracked
        managedTimeouts.forEach(id => clearTimeout(id));
        managedIntervals.forEach(id => clearInterval(id));
        managedTimeouts.clear();
        managedIntervals.clear();
    };
    
    registerCleanupTask(cleanupAudioResources);
    registerCleanupTask(cleanupMapResources);
    
    const executeCleanup = () => {
        cleanupTasks.forEach(task => {
            try {
                task();
            } catch (e) {
                console.error('Error during cleanup:', e);
            }
        });
    };
    
    document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
            cleanupAudioResources();
        }
    });
    
    window.addEventListener('beforeunload', executeCleanup);
    
    // Public API
    return {
        registerCleanupTask,
        executeCleanup,
        setTimeout: setTimeoutManaged,
        setInterval: setIntervalManaged
    };
}

// Initialize memory manager
const memoryManager = setupMemoryManagement();

function initMap() {
    // Clear cached data
    ['lastKnownPos', 'routeHistory', 'userPrefs'].forEach(key => {
        try {
            localStorage.removeItem(key);
            sessionStorage.removeItem(key);
        } catch (_) {}
    });

    if ('caches' in window) {
        caches.keys()
            .then(keys => Promise.all(keys.map(k => caches.delete(k))))
            .catch(() => {});
    }

    // Initialize interaction state
    if (!window.mapInteractionState) {
        window.mapInteractionState = {
            isUserInteracting: false,  // Fixed typo
            lastInteractionTime: 0,
            hasUserInteracted: false,
            lastGestureTime: 0,
            gestureDebounce: 100,
            lastSignificantMovement: Date.now(),
            consecutiveMicroMovements: 0,
            maxConsecutiveMicro: 3,
            lastProcessedPosition: null,
            minUpdateInterval: 50,
            pendingUpdate: null,
            inactivityTimer: null,
            INACTIVITY_TIMEOUT: 15000,
            isAnimating: false,
            smoothingBuffer: [],
            lastSpeedTier: null
        };
    }

    // Mobile-optimized map configuration
    const isMobile = window.innerWidth <= 768;
    const isTouch = 'ontouchstart' in window;
    
    window.map = L.map('map', {
        zoomControl: false,
        attributionControl: false,
        zoomSnap: 0.25,  // Changed for smoother zoom steps
        zoomDelta: 1,
        wheelDebounceTime: 40,
        wheelPxPerZoomLevel: 60,
        tap: isTouch,
        tapTolerance: isMobile ? 20 : 15,
        touchZoom: true,  // Always enable for consistent behavior
        doubleClickZoom: true,  // Always enable
        scrollWheelZoom: true,  // Always enable
        fadeAnimation: true,
        zoomAnimation: true,
        zoomAnimationThreshold: 18,
        markerZoomAnimation: true,
        preferCanvas: false,
        bounceAtZoomLimits: false,
        dragging: true,
        trackResize: true,
        boxZoom: false,  // Disable to prevent conflicts
        keyboard: true,
        inertia: true,  // Enable for smoother experience
        inertiaDeceleration: 3000,
        inertiaMaxSpeed: 1500,
        worldCopyJump: true,
        maxBoundsViscosity: 0.8
    }).setView([46.392410, -94.636230], 17);

    // Tile layer with mobile optimizations
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        minZoom: 7,
        maxZoom: 18,
        attribution: '',
        updateWhenIdle: false,
        updateWhenZooming: true,
        keepBuffer: isMobile ? 1 : 2,
        detectRetina: true,
        className: 'map-tiles',
        crossOrigin: true
    }).addTo(window.map);

    // Marker cluster group with mobile optimizations
    window.markerClusterGroup = L.markerClusterGroup({
        showCoverageOnHover: !isMobile,
        zoomToBoundsOnClick: true,
        spiderfyOnMaxZoom: true,
        animate: !isMobile,
        animateAddingMarkers: false,
        chunkedLoading: true,
        chunkProgress: typeof updateLoadingStatus === 'function' ? updateLoadingStatus : null,
        maxClusterRadius: (zoom) => {
            return isMobile ? (zoom > 16 ? 30 : 60) : (zoom > 16 ? 40 : 80);
        },
        iconCreateFunction: (cluster) => {
            const count = cluster.getChildCount();
            const size = isMobile ? 35 : 40;
            return L.divIcon({
                html: `<div class="cluster-inner"><span>${count}</span></div>`,
                className: 'marker-cluster-custom',
                iconSize: [size, size],
                iconAnchor: [size / 2, size / 2]
            });
        }
    }).addTo(window.map);

    // User marker with mobile optimizations
    const userMarkerSize = isMobile ? 18 : 20;
    window.userMarker = L.marker([46.392410, -94.636230], {
        icon: L.divIcon({
            className: 'user-marker',
            html: '<div class="user-marker-dot"></div>',
            iconSize: [userMarkerSize, userMarkerSize],
            iconAnchor: [userMarkerSize / 2, userMarkerSize / 2]
        }),
        zIndexOffset: 1000,
        interactive: false  // Prevent interference with map interactions
    }).addTo(window.map);

    // Setup interaction handlers - FIXED
    const state = window.mapInteractionState;
    const map = window.map;  // Consistent reference

    const startInteraction = () => {
        const now = Date.now();
        if (now - state.lastGestureTime < state.gestureDebounce) return;
        
        state.lastGestureTime = now;
        state.isUserInteracting = true;
        state.lastInteractionTime = now;
        state.hasUserInteracted = true;
        window.followUser = false;
        clearInactivityTimer();
    };

    const endInteraction = () => {
        state.isUserInteracting = false;
        startInactivityTimer();
    };

    // Unified interaction detection
    const startEvents = ['dragstart', 'zoomstart', 'movestart'];
    const endEvents = ['dragend', 'zoomend', 'moveend'];

    startEvents.forEach(event => {
        map.on(event, startInteraction);
    });

    endEvents.forEach(event => {
        map.on(event, () => {
            setTimeout(endInteraction, 150);  // Consistent delay
        });
    });

    // Animation handlers - SIMPLIFIED
    map.on('movestart zoomstart', () => state.isAnimating = true);
    map.on('moveend zoomend', () => state.isAnimating = false);

    // Mobile-specific optimizations
    if (isMobile) {
        map.getContainer().addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });
        
        window.addEventListener('orientationchange', () => {
            setTimeout(() => {
                map.invalidateSize();
                if (window.lastPosition) {
                    const speedMPH = (window.lastPosition.speedMPS || 0) * 2.23694;
                    const speedTier = getEnhancedSpeedTier(speedMPH);
                    centerUserIcon(window.lastPosition, speedTier, speedMPH);
                }
            }, 500);
        });
    }
    
    window.addEventListener('resize', () => {
        setTimeout(() => map.invalidateSize(), 100);
    });

    // Location error handler
    const handleLocationError = (error) => {
        console.error('Geolocation error:', error.message);
        if (typeof showPopup === 'function') {
            showPopup('Location Error', 'Unable to get your location');
        }
        map.flyTo([44.9778, -93.2650], 17);
        window.userMarker.setLatLng([44.9778, -93.2650]);
        if (typeof hideLoadingMessage === 'function') hideLoadingMessage();
    };

    // Initialize location tracking
    if ('geolocation' in navigator) {
        const geoOptions = {
            enableHighAccuracy: true,
            timeout: isMobile ? 30000 : 45000,
            maximumAge: 1000
        };
        
        navigator.geolocation.getCurrentPosition(
            (position) => {
                console.log('Initial location acquired');
                initializeUserLocation(position);
            },
            (error) => {
                console.warn('Initial location failed, retrying:', error.message);
                navigator.geolocation.getCurrentPosition(
                    initializeUserLocation,
                    handleLocationError,
                    {
                        ...geoOptions,
                        enableHighAccuracy: false,
                        timeout: 15000
                    }
                );
            },
            geoOptions
        );
    } else {
        console.error('Geolocation not supported');
        if (typeof showPopup === 'function') {
            showPopup('Geolocation Error', 'Geolocation is not supported');
        }
        map.flyTo([44.9778, -93.2650], 17);
        if (typeof hideLoadingMessage === 'function') hideLoadingMessage();
    }

    // Wait for map to be ready
    map.whenReady(() => {
        console.log('Map initialized and ready');
        if (typeof showLoadingMessage === 'function') showLoadingMessage();
    });
}


        
function updateLoadingStatus(processed, total, elapsed) {
    if (processed === total) {
        console.log(`Loaded ${processed} markers in ${elapsed.toFixed(2)}ms`);
    }
}

function showLoadingMessage() {
    const existingMessage = document.getElementById('loadingMessage');
    if (existingMessage) return;
    
    loadingMessageMinDisplayTime = Date.now() + 8000;
    
    const loadingMessage = document.createElement('div');
    loadingMessage.id = 'loadingMessage';
    loadingMessage.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        background-image: url('https://raw.githubusercontent.com/mreicher/MNThen/refs/heads/main/images/splash_screen.webp');
        background-size: cover;
        background-position: center;
        z-index: 1000;
        font-family: 'Montserrat', 'Segoe UI', 'Roboto', sans-serif;
        transition: opacity 0.5s ease;
    `;
    
    const contentContainer = document.createElement('div');
    contentContainer.style.cssText = `
        display: grid;
        grid-template-rows: auto auto 1fr auto auto;
        background-color: white;
        padding: 35px 30px;
        border-radius: 20px;
        box-shadow: 0 20px 50px rgba(0, 0, 0, 0.35), 0 2px 10px rgba(0, 0, 0, 0.2);
        width: 450px;
        height: 500px;
        text-align: center;
        backdrop-filter: blur(5px);
        border: 1px solid rgba(255, 255, 255, 0.18);
    `;
    
    const logoImage = document.createElement('img');
    logoImage.src = 'https://mnthen.com/images/logo.webp';
    logoImage.alt = 'Minnesota Then Logo';
    logoImage.style.cssText = `
        width: 180px;
        height: auto;
        margin: 0 auto 25px;
        border-radius: 12px;
        object-fit: contain;
        filter: drop-shadow(0 4px 8px rgba(0, 40, 85, 0.2));
    `;
    
    const mainTitle = document.createElement('h1');
    mainTitle.style.cssText = `
        margin: 0 0 8px 0;
        font-size: 22px;
        font-weight: 700;
        color: #002855;
        text-align: center;
        line-height: 1.2;
        letter-spacing: -0.02em;
        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
    `;
    mainTitle.textContent = 'The Museum Without Walls';
    
    const welcomeMessage = document.createElement('h2');
    welcomeMessage.style.cssText = `
        margin: 0 0 40px 0;
        font-size: 18px;
        font-weight: 500;
        color: #0066cc;
        text-align: center;
        line-height: 1.3;
        letter-spacing: 0.02em;
        opacity: 0.9;
    `;
    welcomeMessage.textContent = 'Where Every Step Tells a Story';
    
    const statusTextContainer = document.createElement('div');
    statusTextContainer.style.cssText = `
        min-height: 60px;
        display: flex;
        align-items: center;
        justify-content: center;
        margin-bottom: 20px;
    `;
    
    const statusText = document.createElement('p');
    statusText.id = 'loadingStatusText';
    statusText.style.cssText = `
        margin: 0;
        font-size: 18px;
        font-weight: 500;
        text-align: center;
        color: #0077dd;
        line-height: 1.4;
        animation: pulse 2s infinite;
        letter-spacing: 0.01em;
    `;
    statusText.textContent = 'Location found, proceeding to stabilization...';
    statusTextContainer.appendChild(statusText);
    
    const progressContainer = document.createElement('div');
    progressContainer.style.cssText = `
        width: 100%;
        height: 10px;
        background-color: rgba(0, 51, 102, 0.08);
        border-radius: 10px;
        overflow: hidden;
        margin-bottom: 12px;
        box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.12);
    `;
    
    const progressBar = document.createElement('div');
    progressBar.id = 'loadingProgressBar';
    progressBar.style.cssText = `
        height: 100%;
        width: 0%;
        background: linear-gradient(90deg, #0066cc, #0099ff, #00aaff, #0099ff, #0066cc);
        background-size: 200% auto;
        border-radius: 10px;
        transition: width 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
        box-shadow: 0 0 10px rgba(0, 120, 255, 0.6);
        animation: gradientShift 3s ease infinite;
    `;
    
    progressContainer.appendChild(progressBar);
    
    const noteContainer = document.createElement('div');
    noteContainer.style.cssText = `
        min-height: 50px;
        display: flex;
        align-items: center;
        justify-content: center;
    `;
    
    const loadingNote = document.createElement('p');
    loadingNote.style.cssText = `
        margin: 0;
        font-size: 16px;
        color: #555;
        font-weight: 500;
        opacity: 0.8;
    `;
    loadingNote.textContent = 'Preparing your experience.';
    noteContainer.appendChild(loadingNote);
    
    contentContainer.appendChild(logoImage);
    contentContainer.appendChild(mainTitle);
    contentContainer.appendChild(welcomeMessage);
    contentContainer.appendChild(statusTextContainer);
    contentContainer.appendChild(progressContainer);
    contentContainer.appendChild(noteContainer);
    
    loadingMessage.appendChild(contentContainer);
    document.body.appendChild(loadingMessage);
    
    const totalDuration = 10000;
    const updateInterval = 100;
    const steps = totalDuration / updateInterval;
    let progress = 0;
    
    const animations = [
        "Initializing map data...",
        "Processing location coordinates...",
        "Preparing exhibit data...",
        "Calibrating view perspective...",
        "Loading nearby points of interest...",
        "Optimizing content for your location...",
        "Finalizing your experience..."
    ];
    
    const progressInterval = setInterval(() => {
        progress += (100 / steps);
        
        if (progressBar) {
            progressBar.style.width = `${Math.min(progress, 100)}%`;
        }
        
        if (statusText) {
            const animationIndex = Math.min(
                Math.floor(progress / (100 / animations.length)),
                animations.length - 1
            );
            statusText.textContent = animations[animationIndex];
        }
        
        if (progress >= 100) {
            clearInterval(progressInterval);
            tryHideLoadingMessage();
        }
    }, updateInterval);
    
    loadingMessage.dataset.progressInterval = progressInterval;
}

function tryHideLoadingMessage() {
    if (Date.now() >= loadingMessageMinDisplayTime) {
        fadeOutLoadingMessage();
    } else {
        const timeRemaining = loadingMessageMinDisplayTime - Date.now();
        setTimeout(fadeOutLoadingMessage, timeRemaining + 100);
    }
}

function fadeOutLoadingMessage() {
    const loadingMessage = document.getElementById('loadingMessage');
    if (!loadingMessage) return;
    
    if (loadingMessage.dataset.progressInterval) {
        clearInterval(parseInt(loadingMessage.dataset.progressInterval));
    }
    
    const progressBar = document.getElementById('loadingProgressBar');
    if (progressBar) {
        progressBar.style.width = '100%';
    }
    
    const distanceBox = cachedElements.distanceBox || document.getElementById('distanceBox');
    if (distanceBox) {
        distanceBox.classList.add('show');
    }
    
    loadingMessage.style.opacity = '0';
    setTimeout(() => {
        if (loadingMessage && loadingMessage.parentNode) {
            loadingMessage.parentNode.removeChild(loadingMessage);
        }
    }, 500);
}

function hideLoadingMessage() {
    tryHideLoadingMessage();
}

function updateAccuracyIndicator(accuracy) {
    const indicator = document.getElementById('accuracyIndicator');
    indicator.style.backgroundColor = accuracy < 20 ? '#4CAF50' : 
                                     accuracy < 50 ? '#FF9800' : 
                                     '#F44336';
}

function initializeUserLocation(position) {
    console.log("🎯 INITIALIZE called with position:", position);
    
    if (!position?.coords) {
        console.error("Invalid position object");
        handleLocationError(new Error("Invalid initial position"));
        return;
    }
    
    const { latitude: userLat, longitude: userLng, accuracy } = position.coords;
    
    if (isNaN(userLat) || isNaN(userLng)) {
        console.error("Invalid coordinates:", userLat, userLng);
        handleLocationError(new Error("Invalid initial coordinates"));
        return;
    }
    
    console.log("✅ Valid coordinates received:", userLat, userLng);
    
    try {
        // 1. Set map view FIRST (this centers the map on GPS coordinates)
        if (map) {
            map.setView([userLat, userLng], 17);
            console.log("🗺️ Map centered on user");
        }
        
        // 2. Set marker to same coordinates (appears at screen center)
        if (userMarker) {
            userMarker.setLatLng([userLat, userLng]);
            console.log("📍 Marker set to:", userLat, userLng);
        }
        
        // 3. Initialize lastPosition for movement tracking (CRITICAL for Google Maps experience)
        lastPosition = {
            lat: userLat,
            lng: userLng,
            accuracy: accuracy,
            timestamp: Date.now(),
            speedMPS: 0
        };
        
        console.log("📋 Last position initialized:", lastPosition);
        
        // 4. Start continuous position tracking
        const watchOptions = {
            enableHighAccuracy: true,
            timeout: 27000,
            maximumAge: 5000
        };
        
        const watchId = navigator.geolocation.watchPosition(
            (pos) => {
                if (!pos?.coords) return;
                
                const { latitude: lat, longitude: lng, accuracy: acc } = pos.coords;
                const timestamp = Date.now();
                
                // Don't update if user is actively interacting with map
                if (window.mapInteractionState.isUserInteracting) {
                    console.log("⏸️ Skipping update - user is interacting");
                    return;
                }
                
                // Rate limiting
                const timeSinceLastUpdate = timestamp - (window.mapInteractionState.lastProcessedPosition?.timestamp || 0);
                if (timeSinceLastUpdate < window.mapInteractionState.minUpdateInterval) {
                    return;
                }
                
                // Update marker position
                if (userMarker) {
                    userMarker.setLatLng([lat, lng]);
                    console.log("📍 Marker updated to:", lat, lng);
                }
                
                // Update map view intelligently
                if (!window.mapInteractionState.hasUserInteracted) {
                    // First time or no user interaction - center on user
                    map.setView([lat, lng], map.getZoom());
                } else if (lastPosition) {
                    // Calculate distance moved
                    const R = 6371e3; // Earth's radius in meters
                    const φ1 = lastPosition.lat * Math.PI / 180;
                    const φ2 = lat * Math.PI / 180;
                    const Δφ = (lat - lastPosition.lat) * Math.PI / 180;
                    const Δλ = (lng - lastPosition.lng) * Math.PI / 180;
                    
                    const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
                              Math.cos(φ1) * Math.cos(φ2) *
                              Math.sin(Δλ/2) * Math.sin(Δλ/2);
                    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                    const distance = R * c;
                    
                    // Pan to follow if significant movement (>50 meters)
                    if (distance > 50) {
                        map.panTo([lat, lng]);
                        console.log("🗺️ Map panned to follow movement");
                    }
                }
                
                // Update position tracking
                lastPosition = { lat, lng, accuracy: acc, timestamp, speedMPS: pos.coords.speed || 0 };
                window.mapInteractionState.lastProcessedPosition = lastPosition;
                
                // Update UI
                if (typeof updateAccuracyIndicator === 'function') updateAccuracyIndicator(acc);
                if (typeof updateDistanceBox === 'function') updateDistanceBox();
            },
            (error) => console.error("Position watch error:", error),
            watchOptions
        );
        
        if (watchId) {
            console.log("🚀 Position tracking started with ID:", watchId);
        }
        
        // 5. Update UI
        updateAccuracyIndicator(accuracy);
        updateDistanceBox();
        
        // 6. Hide loading and announce
        hideLoadingMessage();
        announceToScreenReader('Location acquired. Map ready.');
        
        // 7. DELAY startHunt until after everything is set up
        setTimeout(() => {
            console.log("🕒 Delayed startHunt() called");
            startHunt();
        }, 1000);
        
    } catch (error) {
        console.error("💥 Error in initializeUserLocation:", error);
        handleLocationError(error);
    }
}

function startPositionUpdates(debug = false) {
    if (debug) console.log("🚀 Starting position updates...");
    
    const watchId = navigator.geolocation.watchPosition(
        (position) => {
            if (debug) {
                console.log("📍 GPS update received:", {
                    lat: position.coords.latitude, 
                    lng: position.coords.longitude,
                    accuracy: position.coords.accuracy,
                    speed: position.coords.speed
                });
            }
            handlePositionUpdate(position);
        },
        (error) => {
            console.error("❌ Geolocation error:", error); // Always log errors
            handleLocationError(error);
        },
        {
            enableHighAccuracy: true,
            maximumAge: 1000,
            timeout: 10000
        }
    );
    
    window.positionWatchId = watchId;
    if (debug) console.log("✅ Watch started with ID:", watchId);
    
    window.addEventListener('online', () => {
        if (debug) console.log("🌐 Online - restarting geolocation watcher");
        if (window.positionWatchId) {
            navigator.geolocation.clearWatch(window.positionWatchId);
            window.positionWatchId = navigator.geolocation.watchPosition(
                (position) => {
                    if (debug) console.log("📍 GPS update (after online):", position.coords);
                    handlePositionUpdate(position);
                },
                handleLocationError,
                {
                    enableHighAccuracy: true,
                    maximumAge: 1000,
                    timeout: 10000
                }
            );
        }
    });
    
    return watchId;
}

function handlePositionUpdate(position) {
    if (!position || !position.coords || 
        isNaN(position.coords.latitude) || 
        isNaN(position.coords.longitude)) {
        console.warn("Invalid position data received");
        return;
    }
    
    const positionTimestamp = position.timestamp || new Date().getTime();
    const currentTime = new Date().getTime();
    const maxAgeMs = 30000;
    
    if (currentTime - positionTimestamp > maxAgeMs) {
        console.warn("Position data too old, ignoring");
        return;
    }
    
    const accuracy = position.coords.accuracy || 0;
    window.lastPositionAccuracy = accuracy;
    
    window.lastValidPosition = {
        lat: position.coords.latitude,
        lng: position.coords.longitude,
        timestamp: positionTimestamp,
        accuracy: accuracy
    };
    
    updateUserLocation(position);
}
        
function handleVisibilityChange() {
    if (document.hidden) {
        lastHiddenTime = Date.now();
        lastKnownPosition = userMarker ? userMarker.getLatLng() : null;
    } else {
        const hiddenDuration = Date.now() - lastHiddenTime;
        if (hiddenDuration > CONFIG.BACKGROUND_THRESHOLD) {
            updateLocationAfterBackground();
        } else {
            map.invalidateSize();
        }
    }
    resetInactivityTimer();
}

function updateLocationAfterBackground() {
    if (!("geolocation" in navigator)) {
        console.warn("Geolocation is not available");
        return;
    }
    
    const quickOptions = {
        enableHighAccuracy: false,
        timeout: 5000,
        maximumAge: 60000,
    };
    
    const accurateOptions = {
        enableHighAccuracy: true,
        timeout: 15000,
        maximumAge: 30000,
    };
    
    const fallbackOptions = {
        enableHighAccuracy: false,
        timeout: 25000,
        maximumAge: 120000,
    };
    
    const handleSuccess = (position) => {
        console.log("Background update raw position:", JSON.stringify(position));
        
        if (!position?.coords) {
            console.warn("Invalid position object in background update");
            return;
        }
        const { latitude, longitude, accuracy } = position.coords;
        if (isNaN(latitude) || isNaN(longitude)) {
            console.warn("Invalid coordinates in background update:", { latitude, longitude });
            return;
        }
        console.log("Valid background position update:", { lat: latitude, lng: longitude });
        
        try {
            // Preserve current zoom level instead of setting a new one
            const currentZoom = map.getZoom();
            
            updateUserLocation(position, true);
            
            lastPosition = null;
            positionBuffer = [];
            lastVelocity = { lat: 0, lng: 0 };
            isStationary = false;
            stationaryStartTime = null;
            stationaryCount = 0;
            
            // Use current zoom level instead of calculating a new one
            map.setView([latitude, longitude], currentZoom, { 
                animate: false, 
                duration: 0,
                noMoveStart: true
            });
            
            lastUpdateTime = Date.now();
            lastUpdateTimestamp = Date.now();
            if (isSignificantMovement({lat: latitude, lng: longitude})) {
                resetInactivityTimer(false);
            }
                
            updateDistanceBox();
            
            if (map._container) {
                map._onResize();
            }
        } catch (error) {
            console.error("Error in updateUserLocation during background update:", error);
        }
    };
    
    const handleError = (error, stage) => {
        console.error(`Error getting location during ${stage} attempt:`, error);
        
        switch (error.code) {
            case 1:
                console.warn("User denied geolocation access");
                break;
                
            case 2:
                if (stage === "quick") {
                    console.log("Quick position unavailable, trying accurate position...");
                    navigator.geolocation.getCurrentPosition(
                        handleSuccess,
                        (err) => handleError(err, "accurate"),
                        accurateOptions
                    );
                } else if (stage === "accurate") {
                    console.log("Accurate position unavailable, trying fallback...");
                    navigator.geolocation.getCurrentPosition(
                        handleSuccess,
                        (err) => handleError(err, "fallback"),
                        fallbackOptions
                    );
                } else {
                    console.warn("All position attempts failed - location unavailable");
                }
                break;
                
            case 3:
                if (stage === "quick") {
                    console.log("Quick position timed out, trying accurate position...");
                    navigator.geolocation.getCurrentPosition(
                        handleSuccess,
                        (err) => handleError(err, "accurate"),
                        accurateOptions
                    );
                } else if (stage === "accurate") {
                    console.log("Accurate position timed out, trying fallback...");
                    navigator.geolocation.getCurrentPosition(
                        handleSuccess,
                        (err) => handleError(err, "fallback"),
                        fallbackOptions
                    );
                } else {
                    console.warn("All position attempts timed out");
                }
                break;
                
            default:
                if (stage !== "fallback") {
                    console.log("Unknown error, trying fallback options...");
                    navigator.geolocation.getCurrentPosition(
                        handleSuccess,
                        (err) => handleError(err, "fallback"),
                        fallbackOptions
                    );
                } else {
                    console.warn("All position attempts failed with unknown error");
                }
        }
    };
    
    navigator.geolocation.getCurrentPosition(
        handleSuccess,
        (error) => handleError(error, "quick"),
        quickOptions
    );
}

function updatePositionBuffer(position) {
    positionBuffer.push({
        lat: position.lat,
        lng: position.lng,
        accuracy: position.accuracy,
        timestamp: position.timestamp,
        heading: position.heading,
        speedMPS: position.speedMPS
    });
    
    while (positionBuffer.length > CONFIG.MAX_BUFFER_SIZE) {
        positionBuffer.shift();
    }
}

function calculateWeightedPosition(positions, smoothingFactor = 0.8) {
    if (!Array.isArray(positions) || positions.length === 0) {
        return null;
    }
    
    const validPositions = positions.filter(pos => 
        pos && typeof pos.lat === 'number' && typeof pos.lng === 'number' && 
        !isNaN(pos.lat) && !isNaN(pos.lng)
    );
    if (validPositions.length === 0) {
        return null;
    }
    
    let sumLat = 0, sumLng = 0, totalWeight = 0;
    for (let i = 0; i < validPositions.length; i++) {
        const position = validPositions[i];
        const weight = Math.pow(smoothingFactor, validPositions.length - i - 1);
        sumLat += position.lat * weight;
        sumLng += position.lng * weight;
        totalWeight += weight;
    }
    
    const result = {
        lat: sumLat / totalWeight,
        lng: sumLng / totalWeight,
        accuracy: Math.min(...validPositions.map(p => p.accuracy || 20)),
        timestamp: validPositions[validPositions.length - 1].timestamp,
        heading: validPositions[validPositions.length - 1].heading,
        speedMPS: validPositions[validPositions.length - 1].speedMPS
    };
    
    return result;
}

function checkProximityForZoom() {
    const now = Date.now();
    if (!window.lastProximityCheck) window.lastProximityCheck = 0;
    if (now - window.lastProximityCheck < 200) return;
    window.lastProximityCheck = now;
    
    if (!userMarker || !gameLocations?.length) return;
    
    const userPos = userMarker.getLatLng();
    if (!userPos || isNaN(userPos.lat)) return;
    
    let closestDistance = Infinity;
    for (const loc of gameLocations) {
        if (!loc?.lat) continue;
        const dist = calculateDistance(userPos, loc);
        if (dist < closestDistance) closestDistance = dist;
    }
    
    const distanceFeet = closestDistance * 3.28084;
    
    // Enhanced zoom thresholds with specified zoom levels
    const ZOOM_IN_THRESHOLD = CONFIG.PROXIMITY_THRESHOLD;
    const ZOOM_OUT_THRESHOLD = CONFIG.PROXIMITY_THRESHOLD * 1.3;
    const PROXIMITY_ZOOM_IN_LEVEL = 19;  // Zoom in to level 19
    const PROXIMITY_ZOOM_OUT_LEVEL = 17; // Zoom out to level 17
    
    const currentTime = Date.now();
    
    if (typeof window.zoomedInState === 'undefined') {
        window.zoomedInState = false;
    }
    
    const previousState = window.zoomedInState;
    
    if (!window.zoomedInState && distanceFeet <= ZOOM_IN_THRESHOLD) {
        if (currentTime - lastZoomChangeTime >= CONFIG.ZOOM_COOLDOWN) {
            window.zoomedInState = true;
            isNearLocation = true;
            lastZoomChangeTime = currentTime;
            
            window.blockSpeedZoom = true;
            setTimeout(() => window.blockSpeedZoom = false, 5000);
            
            if (!isMapInteracting) {
                // Enhanced zoom in with specified level and improved animation
                map.flyTo(userPos, PROXIMITY_ZOOM_IN_LEVEL, {
                    duration: 1.2,
                    easeLinearity: 0.25
                });
            }
        }
    } 
    else if (window.zoomedInState && distanceFeet >= ZOOM_OUT_THRESHOLD) {
        if (currentTime - lastZoomChangeTime >= CONFIG.ZOOM_COOLDOWN) {
            window.zoomedInState = false;
            isNearLocation = false;
            lastZoomChangeTime = currentTime;
            
            window.blockSpeedZoom = true;
            setTimeout(() => window.blockSpeedZoom = false, 5000);
            
            if (!isMapInteracting) {
                // Enhanced zoom out with specified level and improved animation
                map.flyTo(userPos, PROXIMITY_ZOOM_OUT_LEVEL, {
                    duration: 1.2,
                    easeLinearity: 0.25
                });
            }
        }
    }
    
    if (previousState !== window.zoomedInState) {
        window.lastProximityZoomTime = currentTime;
    }
}

function getSpeedBasedZoom(speedMPS) {
    if (window.blockSpeedZoom || isNearLocation) {
        return -1;
    }

    // Initialize state if needed
    if (typeof window.speedTrackingState === 'undefined') {
        window.speedTrackingState = {
            speedBuffer: [],
            lastZoom: 17,
            isInTransit: false,
            stoppedTime: null
        };
    }

    const state = window.speedTrackingState;
    const speedMPH = speedMPS * 2.23694;
    
    // Maintain a buffer of recent speeds for stability
    state.speedBuffer.push(speedMPH);
    if (state.speedBuffer.length > 5) {
        state.speedBuffer.shift();
    }
    
    // Use median speed to reduce noise
    const sortedSpeeds = [...state.speedBuffer].sort((a, b) => a - b);
    const medianSpeed = sortedSpeeds[Math.floor(sortedSpeeds.length / 2)];
    
    // Determine target zoom based on speed
    let targetZoom;
    if (medianSpeed < 1) targetZoom = 17;
    else if (medianSpeed < 5) targetZoom = 16;
    else if (medianSpeed < 15) targetZoom = 15;
    else if (medianSpeed < 30) targetZoom = 14;
    else if (medianSpeed < 50) targetZoom = 13;
    else if (medianSpeed < 70) targetZoom = 12;
    else targetZoom = 11;
    
    // Handle transit state
    const now = Date.now();
    const WALKING_SPEED = 3;
    const STOP_DELAY = 20000; // 20 seconds
    
    if (medianSpeed > WALKING_SPEED) {
        state.isInTransit = true;
        state.stoppedTime = null;
    } else if (state.isInTransit && medianSpeed <= WALKING_SPEED) {
        if (!state.stoppedTime) {
            state.stoppedTime = now;
        } else if (now - state.stoppedTime >= STOP_DELAY) {
            state.isInTransit = false;
        }
    }
    
    // If we just stopped after being in transit, zoom in gradually
    if (!state.isInTransit && state.stoppedTime && medianSpeed <= 1) {
        targetZoom = 17;
    }
    
    // Smooth zoom transitions
    const zoomDiff = targetZoom - state.lastZoom;
    const maxZoomChange = 0.3;
    
    if (Math.abs(zoomDiff) > maxZoomChange) {
        state.lastZoom += Math.sign(zoomDiff) * maxZoomChange;
    } else {
        state.lastZoom = targetZoom;
    }
    
    return Math.round(state.lastZoom * 10) / 10; // Round to 1 decimal
}
        
function checkStationaryState(newPosition) {
    if (!lastPosition) return;
    
    const distance = calculateDistance(lastPosition, newPosition);
    
    if (distance >= CONFIG.MICRO_MOVEMENT_THRESHOLD) {
        isStationary = false;
        stationaryStartTime = null;
        console.debug("Movement detected, resuming normal updates");
    }
    
    if (stationaryCheckTimeout) {
        clearTimeout(stationaryCheckTimeout);
        stationaryCheckTimeout = null;
    }
    
    if (isStationary) {
        stationaryCheckTimeout = setTimeout(() => checkStationaryState(newPosition), CONFIG.STATIONARY_CHECK_INTERVAL);
    }
}

function calculateFinalPosition() {
    if (positionBuffer.length === 0) {
        return null;
    }
    
    if (positionBuffer.length === 1) {
        return positionBuffer[0];
    }
    
    return calculateWeightedPosition(positionBuffer);
}

function throttle(func, limit) {
  let inThrottle;
  return function() {
    const args = arguments;
    const context = this;
    if (!inThrottle) {
      func.apply(context, args);
      inThrottle = true;
      setTimeout(() => inThrottle = false, limit);
    }
  };
}

function setUserIconVisibility(visible) {
    if (userMarker) {
        const iconElement = userMarker.getElement();
        if (iconElement) {
            iconElement.style.display = visible ? 'block' : 'none';
        }
    }
}

/**
 * Returns the speed‑tier configuration that best matches the supplied speed.
 *
 * The function is completely self‑contained – it builds the tier list
 * on the first call, then caches the result for each integer‑mph bucket
 * to avoid re‑scanning the array on every GPS fix.
 *
 * @param {number|string} speedMPH  Raw speed (may be a string, NaN, null, etc.).
 * @returns {SpeedTier}            A shallow copy of the matching tier.
 */
function getEnhancedSpeedTier(speedMPH) {
    // -----------------------------------------------------------------
    // 1️⃣  Normalise the incoming speed.
    // -----------------------------------------------------------------
    // `parseFloat` gracefully handles numbers, numeric strings, and returns NaN for non‑numeric.
    // `Math.max(0, …)` forces negative values to 0.
    const mph = Math.max(0, parseFloat(speedMPH) || 0);
    const bucket = Math.floor(mph); // integer bucket used for memoisation

    // -----------------------------------------------------------------
    // 2️⃣  Simple in‑function memo cache (static variable via closure).
    // -----------------------------------------------------------------
    // The cache lives on the function object itself – it survives across calls
    // without polluting the global scope.
    if (!getEnhancedSpeedTier._cache) {
        getEnhancedSpeedTier._cache = new Map();
    }
    const cache = getEnhancedSpeedTier._cache;

    if (cache.has(bucket)) {
        // Return a fresh copy so callers can mutate the result safely.
        return { ...cache.get(bucket) };
    }

    // -----------------------------------------------------------------
    // 3️⃣  Tier definitions – kept inside the function so the signature
    //     and side‑effects stay local.
    // -----------------------------------------------------------------
    const tiers = [
        {
            // 0‑1 mph – essentially stationary
            maxSpeed: 1,
            microMovementThreshold: 1.0,
            minDistanceThreshold:   0.8,
            maxAccuracy:            25,
            maxSpeedThreshold:      2,
            mapUpdateInterval:      500,
            mapUpdateDistance:      1,
            panDuration:            0.8,
            easeLinearity:          0.1,
            zoomThreshold:          1.5,
            zoomDuration:           1.5,
            targetZoom:             17
        },
        {
            // 1‑4 mph – walking
            maxSpeed: 4,
            microMovementThreshold: 1.0,
            minDistanceThreshold:   1.5,
            maxAccuracy:            20,
            maxSpeedThreshold:      8,
            mapUpdateInterval:      300,
            mapUpdateDistance:      2,
            panDuration:            0.5,
            easeLinearity:          0.15,
            zoomThreshold:          1.2,
            zoomDuration:           1.2,
            targetZoom:             17
        },
        {
            // 4‑15 mph – biking / brisk walk
            maxSpeed: 15,
            microMovementThreshold: 2.0,
            minDistanceThreshold:   3.0,
            maxAccuracy:            30,
            maxSpeedThreshold:      25,
            mapUpdateInterval:      200,
            mapUpdateDistance:      5,
            panDuration:            0.3,
            easeLinearity:          0.2,
            zoomThreshold:          1.0,
            zoomDuration:           1.0,
            targetZoom:             17
        },
        {
            // 15‑40 mph – moderate vehicle speed
            maxSpeed: 40,
            microMovementThreshold: 3.0,
            minDistanceThreshold:   5.0,
            maxAccuracy:            40,
            maxSpeedThreshold:      60,
            mapUpdateInterval:      150,
            mapUpdateDistance:      8,
            panDuration:            0.2,
            easeLinearity:          0.25,
            zoomThreshold:          0.8,
            zoomDuration:           0.8,
            targetZoom:             16
        },
        {
            // 40‑70 mph – fast vehicle / highway
            maxSpeed: 70,
            microMovementThreshold: 5.0,
            minDistanceThreshold:   8.0,
            maxAccuracy:            50,
            maxSpeedThreshold:      100,
            mapUpdateInterval:      100,
            mapUpdateDistance:      15,
            panDuration:            0.15,
            easeLinearity:          0.3,
            zoomThreshold:          0.6,
            zoomDuration:           0.6,
            targetZoom:             15
        },
        {
            // 70+ mph – high‑speed travel
            maxSpeed: Infinity,
            microMovementThreshold: 8.0,
            minDistanceThreshold:   12.0,
            maxAccuracy:            60,
            maxSpeedThreshold:      150,
            mapUpdateInterval:      80,
            mapUpdateDistance:      25,
            panDuration:            0.1,
            easeLinearity:          0.35,
            zoomThreshold:          0.5,
            zoomDuration:           0.5,
            targetZoom:             14
        }
    ];

    // -----------------------------------------------------------------
    // 4️⃣  Locate the proper tier.
    // -----------------------------------------------------------------
    const tier = tiers.find(t => mph < t.maxSpeed) || tiers[tiers.length - 1];

    // -----------------------------------------------------------------
    // 5️⃣  Store a copy in the cache for future calls.
    // -----------------------------------------------------------------
    cache.set(bucket, tier);

    // -----------------------------------------------------------------
    // 6️⃣  Return a shallow copy (prevents accidental mutation of the cached object).
    // -----------------------------------------------------------------
    return { ...tier };
}

/* -------------------------------------------------------------
   Global state management for Google Maps-like behavior
   ------------------------------------------------------------- */
function initializeMapState() {
    if (!window.mapInteractionState) {
        window.mapInteractionState = {
            // User interaction tracking
            isUserInteracting: false,
            lastInteractionTime: 0,
            hasUserInteracted: false,
            gestureDebounce: 100,
            lastGestureTime: 0,
            
            // Animation state
            isAnimating: false,
            lastAnimationEnd: 0,
            
            // Timers
            inactivityTimer: null,
            recenterTimer: null,
            INACTIVITY_TIMEOUT: 15000,
            
            // Position tracking
            lastProcessedPosition: null,
            minUpdateInterval: 50,
            smoothingBuffer: [],
            lastSpeedTier: null,
            
            // Centering control
            pendingCenter: null,
            forceCenterNext: false,
            centeringDisabled: false
        };
    }
    
    if (!window.positionSmoothing) {
        window.positionSmoothing = {
            previousLatLng: null,
            smoothingFactor: 0.7,
            velocityBuffer: []
        };
    }
    
    return window.mapInteractionState;
}

/* -------------------------------------------------------------
   centerUserIcon – Google Maps-like centering with perfect positioning
   ------------------------------------------------------------- */
function centerUserIcon(position, speedTier = null, speedMPH = 0, options = {}) {
    // -----------------------------------------------------------------
    // Guard clauses and initialization
    // -----------------------------------------------------------------
    if (!window.map || !window.userMarker) return;
    
    const state = initializeMapState();
    
    // -----------------------------------------------------------------
    // Configuration with speed-based overrides
    // -----------------------------------------------------------------
    const defaults = {
        panDuration: 0.30,
        easeLinearity: 0.20,
        deadZoneM: 1.5,
        autoCenterAfterInactivity: true,
        inactivityMs: 3000,
        smoothingFactor: 0.8,
        forceCenter: false
    };

    const config = { ...defaults, ...options };
    
    // Get speed-based parameters if available
    const panDuration = speedTier?.panDuration || config.panDuration;
    const easeLinearity = speedTier?.easeLinearity || config.easeLinearity;

    // -----------------------------------------------------------------
    // Position smoothing for jitter reduction
    // -----------------------------------------------------------------
    const gpsLatLng = L.latLng(position.lat, position.lng);
    const smoothing = window.positionSmoothing;
    
    let targetLatLng;
    if (!smoothing.previousLatLng || config.forceCenter) {
        smoothing.previousLatLng = gpsLatLng;
        targetLatLng = gpsLatLng;
    } else {
        // Apply velocity-based smoothing
        const speedFactor = Math.min(1, speedMPH / 10); // More smoothing at lower speeds
        const dynamicSmoothing = config.smoothingFactor * (1 - speedFactor * 0.3);
        
        targetLatLng = L.latLng(
            smoothing.previousLatLng.lat + (gpsLatLng.lat - smoothing.previousLatLng.lat) * dynamicSmoothing,
            smoothing.previousLatLng.lng + (gpsLatLng.lng - smoothing.previousLatLng.lng) * dynamicSmoothing
        );
        smoothing.previousLatLng = targetLatLng;
    }

    // -----------------------------------------------------------------
    // CRITICAL: Always update marker position first
    // This ensures the icon is always at the correct GPS location
    // -----------------------------------------------------------------
    window.userMarker.setLatLng(targetLatLng);

    // -----------------------------------------------------------------
    // Dead-zone check for map movement (not marker movement)
    // -----------------------------------------------------------------
    const currentCenter = map.getCenter();
    const distanceFromCenter = map.distance(currentCenter, targetLatLng);
    
    if (!config.forceCenter && !state.forceCenterNext && 
        distanceFromCenter < config.deadZoneM && !state.isAnimating) {
        return; // Skip map movement for tiny changes
    }

    // -----------------------------------------------------------------
    // Handle user interaction states
    // -----------------------------------------------------------------
    if (state.isUserInteracting && !config.forceCenter && !state.forceCenterNext) {
        // Store position for later centering
        state.pendingCenter = targetLatLng;
        
        // Set up auto-recenter timer
        if (config.autoCenterAfterInactivity) {
            clearTimeout(state.recenterTimer);
            state.recenterTimer = setTimeout(() => {
                if (state.pendingCenter && !state.isUserInteracting) {
                    centerUserIcon(
                        { lat: state.pendingCenter.lat, lng: state.pendingCenter.lng }, 
                        speedTier, 
                        speedMPH, 
                        { ...config, forceCenter: true }
                    );
                    state.pendingCenter = null;
                }
            }, config.inactivityMs);
        }
        return;
    }

    // -----------------------------------------------------------------
    // Execute map centering
    // -----------------------------------------------------------------
    // Clear any pending operations
    state.pendingCenter = null;
    state.forceCenterNext = false;
    clearTimeout(state.recenterTimer);
    
    // Stop any ongoing animation cleanly
    if (map._panAnim && typeof map._panAnim.stop === 'function') {
        map._panAnim.stop();
    }

    // Set animation state
    state.isAnimating = true;

    // Perform the centering animation
    map.panTo(targetLatLng, {
        animate: true,
        duration: panDuration,
        easeLinearity: easeLinearity,
        noMoveStart: false // Allow move events for proper state tracking
    });

    // Clean up animation state when done
    const onMoveEnd = () => {
        state.isAnimating = false;
        state.lastAnimationEnd = Date.now();
        map.off('moveend', onMoveEnd);
    };
    
    map.on('moveend', onMoveEnd);
}

/* -------------------------------------------------------------
   setUserIconVisibility – show/hide the user marker
   ------------------------------------------------------------- */
function setUserIconVisibility(visible) {
    if (window.userMarker) {
        const element = window.userMarker.getElement();
        if (element) {
            element.style.display = visible ? 'block' : 'none';
        }
    }
}

/* -------------------------------------------------------------
   Weighted average calculation for position smoothing
   ------------------------------------------------------------- */
function weightedAverage(buffer) {
    const weighted = buffer.reduce((acc, pos, i) => {
        // Weight grows linearly: newest gets highest weight.
        const w = (i + 1) / buffer.length;
        acc.lat += pos.lat * w;
        acc.lng += pos.lng * w;
        acc.wSum += w;
        return acc;
    }, { lat: 0, lng: 0, wSum: 0 });

    return {
        lat: weighted.lat / weighted.wSum,
        lng: weighted.lng / weighted.wSum
    };
}

function predictNextPosition(currentPos, previousPos, speedMPS, heading) {
    if (!previousPos || speedMPS < 1) return currentPos;
    
    const timeDelta = (currentPos.timestamp - previousPos.timestamp) / 1000;
    if (timeDelta <= 0) return currentPos;
    
    // Calculate movement vector
    const distance = speedMPS * timeDelta;
    const bearing = heading !== null ? heading * Math.PI / 180 : 
        Math.atan2(currentPos.lng - previousPos.lng, currentPos.lat - previousPos.lat);
    
    // Predict next position
    const earthRadius = 6371000;
    const angularDistance = distance / earthRadius;
    
    const lat1 = currentPos.lat * Math.PI / 180;
    const lng1 = currentPos.lng * Math.PI / 180;
    
    const predLat = Math.asin(Math.sin(lat1) * Math.cos(angularDistance) + 
        Math.cos(lat1) * Math.sin(angularDistance) * Math.cos(bearing));
    
    const predLng = lng1 + Math.atan2(Math.sin(bearing) * Math.sin(angularDistance) * Math.cos(lat1),
        Math.cos(angularDistance) - Math.sin(lat1) * Math.sin(predLat));
    
    return {
        lat: predLat * 180 / Math.PI,
        lng: predLng * 180 / Math.PI,
        accuracy: currentPos.accuracy,
        speedMPS: speedMPS,
        heading: heading,
        timestamp: currentPos.timestamp + timeDelta * 1000,
        isPredicted: true
    };
}

function manageMapTransitions(targetPosition, targetZoom, options = {}) {
    const {
        duration = 1.0,
        easeLinearity = 0.25,
        maxZoomChange = 2
    } = options;
    
    const currentZoom = map.getZoom();
    const zoomDifference = Math.abs(targetZoom - currentZoom);
    
    if (zoomDifference > maxZoomChange) {
        // Staged transition: zoom first, then pan
        const intermediateZoom = currentZoom + Math.sign(targetZoom - currentZoom) * maxZoomChange;
        
        map.flyTo(targetPosition, intermediateZoom, {
            duration: duration * 0.6,
            easeLinearity: easeLinearity
        });
        
        setTimeout(() => {
            map.flyTo(targetPosition, targetZoom, {
                duration: duration * 0.4,
                easeLinearity: easeLinearity
            });
        }, duration * 600 * 0.6);
    } else {
        // Single smooth transition
        map.flyTo(targetPosition, targetZoom, {
            duration: duration,
            easeLinearity: easeLinearity
        });
    }
}

function checkMapEdges(userPos) {
    if (!map || !userPos) return false;
    
    const mapContainer = map.getContainer();
    const mapRect = mapContainer.getBoundingClientRect();
    const userPixel = map.latLngToContainerPoint(userPos);
    
    const edgeThreshold = {
        horizontal: mapRect.width * 0.25,
        vertical: mapRect.height * 0.25
    };
    
    const isNearEdge = 
        userPixel.x < edgeThreshold.horizontal ||
        userPixel.x > mapRect.width - edgeThreshold.horizontal ||
        userPixel.y < edgeThreshold.vertical ||
        userPixel.y > mapRect.height - edgeThreshold.vertical;
    
    return isNearEdge;
}

function handleAccuracyBasedPositioning(position, speedTier) {
    const accuracy = position.coords.accuracy;
    const speedMPH = (position.coords.speed || 0) * 2.23694;
    
    // Adjust behavior based on accuracy
    if (accuracy > 30) {
        // Low accuracy - more smoothing, less frequent updates
        return {
            smoothingFactor: 0.9,
            updateInterval: Math.max(1000, speedTier.mapUpdateInterval * 2),
            deadZone: speedTier.microMovementThreshold * 2
        };
    } else if (accuracy > 15) {
        // Medium accuracy - balanced behavior
        return {
            smoothingFactor: 0.7,
            updateInterval: speedTier.mapUpdateInterval,
            deadZone: speedTier.microMovementThreshold
        };
    } else {
        // High accuracy - responsive behavior
        return {
            smoothingFactor: 0.5,
            updateInterval: Math.max(50, speedTier.mapUpdateInterval * 0.7),
            deadZone: speedTier.microMovementThreshold * 0.5
        };
    }
}

// updateUserLocation function
function updateUserLocation(position, forceUpdate = false) {
    const now = Date.now();
    
    // Critical: Check if map exists before proceeding
    if (!window.map) {
        console.warn('Map not initialized, skipping location update');
        return;
    }
    
    if (!window.mapInteractionState) {
        window.mapInteractionState = {
            isUserInteracting: false,
            lastInteractionTime: 0,
            hasUserInteracted: false,
            isAnimating: false,
            lastProcessedPosition: null,
            minUpdateInterval: 50,
            pendingUpdate: null,
            inactivityTimer: null,
            INACTIVITY_TIMEOUT: 15000,
            smoothingBuffer: []
        };
    }
    
    const state = window.mapInteractionState;
    const pos = {
        lat: position.coords.latitude,
        lng: position.coords.longitude,
        accuracy: position.coords.accuracy || 20,
        heading: position.coords.heading ?? null,
        timestamp: now,
        speedMPS: position.coords.speed || 0
    };
    
    const speedMPH = pos.speedMPS * 2.23694;
    const speedTier = getEnhancedSpeedTier(speedMPH);
    
    // Get accuracy-based positioning parameters - add null check
    const accuracyParams = typeof handleAccuracyBasedPositioning === 'function' 
        ? handleAccuracyBasedPositioning(position, speedTier)
        : { updateInterval: 1000, deadZone: 5, smoothingFactor: 0.7 }; // fallback values

    // First fix handling
    if (!window.lastPosition) {
        window.lastPosition = pos;
        const gpsLatLng = [pos.lat, pos.lng];
        
        try {
            window.map.setView(gpsLatLng, speedTier.targetZoom);
            if (window.userMarker) {
                window.userMarker.setLatLng(gpsLatLng);
            }
        } catch (err) {
            console.error('Error setting initial map view:', err);
            return;
        }
        
        window.lastUpdateTime = now;
        window.positionBuffer = [pos];
        
        if (state) {
            state.lastSignificantMovement = now;
            state.smoothingBuffer = [pos, pos, pos];
        }
        
        if (typeof updateDistanceBox === 'function') updateDistanceBox();
        if (typeof updateAccuracyIndicator === 'function') 
            updateAccuracyIndicator(pos.accuracy);
            
        console.log('Initial position set:', gpsLatLng);
        return;
    }
    
    // Apply accuracy-based throttling
    if (!forceUpdate && now - (window.lastUpdateTime || 0) < accuracyParams.updateInterval) {
        return;
    }
    
    // Calculate distance from last position
    const distance = Math.sqrt(
        Math.pow((pos.lat - window.lastPosition.lat) * 111320, 2) + 
        Math.pow((pos.lng - window.lastPosition.lng) * 111320 * 
                 Math.cos(pos.lat * Math.PI / 180), 2)
    );
    
    const timeDelta = (now - (window.lastUpdateTime || now)) / 1000;
    
    // Handle large position jumps
    if (distance > 100 || forceUpdate) {
        console.log('Large position change detected:', distance.toFixed(1) + 'm');
        
        try {
            if (window.map._panAnim) window.map._panAnim.stop();
            
            state.smoothingBuffer = [pos, pos, pos];
            
            if (window.userMarker) {
                window.userMarker.setLatLng([pos.lat, pos.lng]);
            }
            
            // Use managed transitions for large jumps - add null check
            if (typeof manageMapTransitions === 'function') {
                manageMapTransitions([pos.lat, pos.lng], speedTier.targetZoom, {
                    duration: 0.5,
                    easeLinearity: 0.25,
                    maxZoomChange: 3
                });
            } else {
                // Fallback to direct map manipulation
                window.map.setView([pos.lat, pos.lng], speedTier.targetZoom);
            }
        } catch (err) {
            console.error('Error handling large position jump:', err);
        }
        
        window.lastPosition = pos;
        window.lastUpdateTime = now;
        if (typeof updateDistanceBox === 'function') updateDistanceBox();
        return;
    }
    
    // Quality filtering with accuracy-adjusted dead zone
    if (!forceUpdate && (
        pos.accuracy > speedTier.maxAccuracy ||
        distance < accuracyParams.deadZone ||
        (timeDelta > 0 && distance / timeDelta > speedTier.maxSpeedThreshold * 1.5)
    )) {
        return;
    }
    
    // Position smoothing and prediction
    try {
        state.smoothingBuffer.push(pos);
        if (state.smoothingBuffer.length > 3) {
            state.smoothingBuffer.shift();
        }
        
        // Apply accuracy-based smoothing
        const avg = state.smoothingBuffer.reduce((acc, p, idx) => {
            const weight = (idx + 1) / state.smoothingBuffer.length;
            return {
                lat: acc.lat + p.lat * weight,
                lng: acc.lng + p.lng * weight,
                totalWeight: acc.totalWeight + weight
            };
        }, { lat: 0, lng: 0, totalWeight: 0 });
        
        let smoothed = {
            lat: avg.lat / avg.totalWeight,
            lng: avg.lng / avg.totalWeight,
            accuracy: pos.accuracy,
            speedMPS: pos.speedMPS,
            timestamp: pos.timestamp
        };
        
        // Apply additional smoothing based on accuracy
        if (window.lastPosition && accuracyParams.smoothingFactor > 0.5) {
            const factor = accuracyParams.smoothingFactor;
            smoothed = {
                lat: window.lastPosition.lat * (1 - factor) + smoothed.lat * factor,
                lng: window.lastPosition.lng * (1 - factor) + smoothed.lng * factor,
                accuracy: smoothed.accuracy,
                speedMPS: smoothed.speedMPS,
                timestamp: smoothed.timestamp
            };
        }
        
        // Predict next position for smoother tracking - add null check
        let predicted = smoothed;
        if (typeof predictNextPosition === 'function') {
            predicted = predictNextPosition(smoothed, window.lastPosition, pos.speedMPS, pos.heading);
        }
        
        // Use prediction for high-speed movement
        const finalPosition = speedMPH > 15 && predicted.isPredicted ? 
            {
                lat: smoothed.lat * 0.7 + predicted.lat * 0.3,
                lng: smoothed.lng * 0.7 + predicted.lng * 0.3,
                accuracy: smoothed.accuracy,
                speedMPS: smoothed.speedMPS,
                timestamp: smoothed.timestamp
            } : smoothed;
        
        // Update marker position
        if (window.userMarker) {
            window.userMarker.setLatLng([finalPosition.lat, finalPosition.lng]);
        }
        
        // Check if user is near map edges - add null check
        const nearEdge = typeof checkMapEdges === 'function' 
            ? checkMapEdges([finalPosition.lat, finalPosition.lng])
            : false;
        
        // Center map if not interacting or if near edge
        if (!state.isUserInteracting || nearEdge) {
            if (nearEdge) {
                // Force immediate centering when near edge
                if (typeof manageMapTransitions === 'function') {
                    manageMapTransitions([finalPosition.lat, finalPosition.lng], window.map.getZoom(), {
                        duration: 0.8,
                        easeLinearity: 0.2,
                        maxZoomChange: 1
                    });
                } else {
                    window.map.setView([finalPosition.lat, finalPosition.lng], window.map.getZoom());
                }
            } else if (typeof centerUserIcon === 'function') {
                centerUserIcon(finalPosition, speedTier, speedMPH, {
                    moveMarkerOnInteraction: false,
                    autoCenterAfterInactivity: true,
                    deadZoneM: accuracyParams.deadZone
                });
            }
        }
        
        // Speed-based zoom with managed transitions
        if (!state.isUserInteracting && now - state.lastInteractionTime > 2000) {
            const currentZoom = window.map.getZoom();
            const targetZoom = speedTier.targetZoom;
            
            if (!state.lastSpeedTier || 
                Math.abs(state.lastSpeedTier.targetZoom - targetZoom) >= 1) {
                
                console.log('Speed-based zoom adjustment:', currentZoom, 
                           '→', targetZoom, `(${speedMPH.toFixed(1)} mph)`);
                
                if (typeof manageMapTransitions === 'function') {
                    manageMapTransitions([finalPosition.lat, finalPosition.lng], targetZoom, {
                        duration: speedTier.zoomDuration || 1.0,
                        easeLinearity: 0.25,
                        maxZoomChange: 2
                    });
                } else {
                    window.map.setView([finalPosition.lat, finalPosition.lng], targetZoom);
                }
                
                state.lastSpeedTier = speedTier;
            }
        }
        
        // Update references
        window.lastPosition = finalPosition;
        window.lastUpdateTime = now;
        
        if (typeof window.positionBuffer !== 'undefined') {
            window.positionBuffer.push(pos);
            if (window.positionBuffer.length > 10) window.positionBuffer.shift();
        }
        
        if (typeof updateDistanceBox === 'function') updateDistanceBox();
        if (typeof checkProximityForZoom === 'function') checkProximityForZoom();
        
        if (distance > 0.5) {
            console.log(`Position updated: ${distance.toFixed(1)}m, ${speedMPH.toFixed(1)}mph, acc: ${pos.accuracy.toFixed(1)}m`);
        }
        
    } catch (err) {
        console.error('Location update error:', err);
        
        // Safe fallback handling
        try {
            if (window.map && window.map._panAnim) window.map._panAnim.stop();
            
            if (window.userMarker) {
                window.userMarker.setLatLng([pos.lat, pos.lng]);
            }
            
            // Fallback with managed transitions
            if (typeof manageMapTransitions === 'function') {
                manageMapTransitions([pos.lat, pos.lng], speedTier.targetZoom, {
                    duration: 0.3,
                    easeLinearity: 0.2,
                    maxZoomChange: 1
                });
            } else if (window.map) {
                window.map.setView([pos.lat, pos.lng], speedTier.targetZoom);
            }
            
            window.lastPosition = pos;
            if (typeof updateDistanceBox === 'function') updateDistanceBox();
        } catch (fallbackErr) {
            console.error('Fallback error handling also failed:', fallbackErr);
        }
    }
}

/* -------------------------------------------------------------
   Animation state tracking
   ------------------------------------------------------------- */
function setupAnimationHandlers() {
    const state = window.mapInteractionState;
    if (!state || !map) return;

    // Track animation start/end for proper state management
    const onAnimStart = () => {
        state.isAnimating = true;
    };

    const onAnimEnd = () => {
        state.isAnimating = false;
        state.lastAnimationEnd = Date.now();
    };

    // Bind to all relevant animation events
    map.on('movestart zoomstart', onAnimStart);
    map.on('moveend zoomend', onAnimEnd);
}

/* -------------------------------------------------------------
   Enhanced interaction detection for mobile and desktop
   ------------------------------------------------------------- */
function setupInteractionHandlers() {
    const state = initializeMapState();
    if (!map) return;

    const container = map.getContainer();

    // -----------------------------------------------------------------
    // Interaction state helpers
    // -----------------------------------------------------------------
    const startInteraction = () => {
        const now = Date.now();
        
        // Debounce rapid gesture starts
        if (now - state.lastGestureTime < state.gestureDebounce) {
            return;
        }
        
        state.lastGestureTime = now;
        state.isUserInteracting = true;
        state.lastInteractionTime = now;
        state.hasUserInteracted = true;
        
        // Clear any pending operations
        clearInactivityTimer();
        
        // Disable follow mode
        if (typeof window.followUser !== 'undefined') {
            window.followUser = false;
        }
    };

    const endInteraction = () => {
        state.isUserInteracting = false;
        state.lastInteractionTime = Date.now();
        startInactivityTimer();
    };

    // -----------------------------------------------------------------
    // Touch event handling (mobile)
    // -----------------------------------------------------------------
    container.addEventListener('touchstart', (e) => {
        startInteraction();
    }, { passive: true });
    
    container.addEventListener('touchend', (e) => {
        // Only end interaction when all touches are gone
        if (e.touches.length === 0) {
            setTimeout(endInteraction, 100); // Small delay for map events
        }
    }, { passive: true });

    // -----------------------------------------------------------------
    // Mouse event handling (desktop)
    // -----------------------------------------------------------------
    container.addEventListener('mousedown', startInteraction, { passive: true });
    container.addEventListener('mouseup', () => {
        setTimeout(endInteraction, 50);
    }, { passive: true });

    // -----------------------------------------------------------------
    // Leaflet map events (critical for proper detection)
    // -----------------------------------------------------------------
    map.on('dragstart zoomstart movestart', startInteraction);
    map.on('dragend zoomend moveend', () => {
        // Delay to allow animations to complete
        setTimeout(endInteraction, 100);
    });

    // -----------------------------------------------------------------
    // Wheel/scroll handling with debouncing
    // -----------------------------------------------------------------
    let wheelTimeout = null;
    
    container.addEventListener('wheel', (e) => {
        startInteraction();
        
        // Debounce wheel end detection
        clearTimeout(wheelTimeout);
        wheelTimeout = setTimeout(() => {
            if (!state.isUserInteracting) return;
            endInteraction();
        }, 300);
        
    }, { passive: true });

    // -----------------------------------------------------------------
    // Keyboard handling (arrow keys, +/- zoom)
    // -----------------------------------------------------------------
    document.addEventListener('keydown', (e) => {
        if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', '+', '-', '='].includes(e.key)) {
            if (document.activeElement === document.body || 
                container.contains(document.activeElement)) {
                startInteraction();
                setTimeout(endInteraction, 500);
            }
        }
    }, { passive: true });
}

/* -------------------------------------------------------------
   Inactivity timer management
   ------------------------------------------------------------- */
function clearInactivityTimer() {
    const state = window.mapInteractionState;
    if (!state) return;
    
    if (state.inactivityTimer) {
        clearTimeout(state.inactivityTimer);
        state.inactivityTimer = null;
    }
}

function startInactivityTimer() {
    const state = window.mapInteractionState;
    if (!state || !state.hasUserInteracted || state.isUserInteracting) {
        return;
    }

    clearInactivityTimer();

    state.inactivityTimer = setTimeout(() => {
        // Re-enable automatic centering after inactivity
        if (window.lastPosition && !state.isUserInteracting && window.userMarker) {
            console.log('🔄 Auto-recentering after inactivity');
            
            // Get speed-appropriate settings
            const speedMPH = (window.lastPosition.speedMPS || 0) * 2.23694;
            const speedTier = getEnhancedSpeedTier(speedMPH);
            
            // Force recenter with smooth animation
            centerUserIcon(window.lastPosition, speedTier, speedMPH, {
                forceCenter: true,
                panDuration: 1.2,
                easeLinearity: 0.25
            });
            
            // Reset interaction state
            state.hasUserInteracted = false;
            state.forceCenterNext = true;
            
            // Re-enable follow mode
            if (typeof window.followUser !== 'undefined') {
                window.followUser = true;
            }
            
            console.log('✅ Auto-centering resumed');
        }
        
        state.inactivityTimer = null;
    }, state.INACTIVITY_TIMEOUT);
}

/* -------------------------------------------------------------
   Utility functions for enhanced smoothing and filtering
   ------------------------------------------------------------- */
const clamp = (val, min, max) => Math.min(Math.max(val, min), max);

function calculateUltraSmoothingFactor(speedMPH) {
    // Higher speeds need less smoothing to maintain responsiveness
    const baseTable = [
        [0, 0.3],    // Very slow - more smoothing
        [1, 0.5],    // Walking - moderate smoothing  
        [4, 0.7],    // Biking - less smoothing
        [15, 0.8],   // Moderate speed - minimal smoothing
        [40, 0.85],  // Highway - very little smoothing
        [70, 0.9]    // High speed - least smoothing
    ];
    
    for (let i = baseTable.length - 1; i >= 0; i--) {
        if (speedMPH >= baseTable[i][0]) {
            return { factor: baseTable[i][1] };
        }
    }
    return { factor: baseTable[0][1] };
}

function updatePositionBuffer(newPosition) {
    if (!window.positionBuffer) window.positionBuffer = [];
    
    const buf = window.positionBuffer;
    buf.push(newPosition);
    
    // Keep buffer size manageable
    if (buf.length > 5) buf.splice(0, buf.length - 5);
}

function calculateFinalPosition() {
    const buf = window.positionBuffer;
    if (!buf || buf.length === 0) return null;
    if (buf.length === 1) return { ...buf[0] };
    
    const result = buf.reduce((acc, pos, idx) => {
        const age = buf.length - idx - 1;
        const accWeight = Math.max(0.1, 1 / Math.max(pos.accuracy, 5));
        const timeWeight = Math.pow(0.8, age);
        const weight = accWeight * timeWeight;
        
        acc.weightedLat += pos.lat * weight;
        acc.weightedLng += pos.lng * weight;
        acc.totalWeight += weight;
        acc.totalSpeed += pos.speedMPS || 0;
        
        if (pos.accuracy < acc.bestAccuracy) acc.bestAccuracy = pos.accuracy;
        return acc;
    }, {
        weightedLat: 0, weightedLng: 0, totalWeight: 0, 
        totalSpeed: 0, bestAccuracy: Infinity
    });
    
    return {
        lat: result.weightedLat / result.totalWeight,
        lng: result.weightedLng / result.totalWeight,
        accuracy: result.bestAccuracy,
        speedMPS: result.totalSpeed / buf.length,
        timestamp: Date.now()
    };
}

/* -------------------------------------------------------------
   Stationary state handling
   ------------------------------------------------------------- */
function checkStationaryState(currentPosition) {
    if (!isStationary || !currentPosition) return;
    
    stationaryCount++;
    console.log("🔍 Stationary check #" + stationaryCount);
    
    if (stationaryCount >= CONFIG.MAX_STATIONARY_CHECKS) {
        console.log("⏰ Max stationary checks reached, forcing update");
        isStationary = false;
        stationaryStartTime = null;
        stationaryCount = 0;
        
        // Force center when exiting stationary state
        const speedTier = getEnhancedSpeedTier(0);
        centerUserIcon(currentPosition, speedTier, 0, { forceCenter: true });
        
        lastPosition = currentPosition;
        if (typeof updateDistanceBox === 'function') updateDistanceBox();
        return;
    }
    
    if (stationaryCheckTimeout) {
        clearTimeout(stationaryCheckTimeout);
    }
    
    stationaryCheckTimeout = setTimeout(() => {
        checkStationaryState(currentPosition);
    }, CONFIG.STATIONARY_CHECK_INTERVAL);
}

/* -------------------------------------------------------------
   Initialize everything when DOM is ready
   ------------------------------------------------------------- */
function initializeGoogleMapsLikeBehavior() {
    if (typeof window.map !== 'undefined' && window.map) {
        setupAnimationHandlers();
        setupInteractionHandlers();
        console.log('🗺️  Google Maps-like behavior initialized');
    }
}

// Auto-initialize if map exists, otherwise wait for it
if (typeof window.map !== 'undefined' && window.map) {
    initializeGoogleMapsLikeBehavior();
} else {
    // Wait for map to be available
    const checkForMap = setInterval(() => {
        if (typeof window.map !== 'undefined' && window.map) {
            clearInterval(checkForMap);
            initializeGoogleMapsLikeBehavior();
        }
    }, 100);
}

function calculateIntelligentZoom(speedMPS, closestDistance) {
   const speedMPH = speedMPS * 2.23694;
   const baseZoom = getSpeedBasedZoom(speedMPS);
   
   if (closestDistance < 50) {
       return Math.min(baseZoom + 1, 18);
   } else if (closestDistance > 500) {
       return Math.max(baseZoom - 1, 10);
   }
   
   return baseZoom;
}

// Helper function to find closest location distance
function findClosestLocationDistance(position) {
    if (!gameLocations || gameLocations.length === 0) return Infinity;
    
    let closestDistance = Infinity;
    for (const loc of gameLocations) {
        if (loc && loc.lat && loc.lng) {
            const dist = calculateDistance(position, loc);
            if (dist < closestDistance) {
                closestDistance = dist;
            }
        }
    }
    
    return closestDistance * 3.28084; // Convert to feet
}

function updateDistanceBox() {
    const distanceBox = cachedElements.distanceBox || document.getElementById('distanceBox');
    
    if (!userMarker || !gameLocations || gameLocations.length === 0) {
        distanceBox.innerText = 'Initializing...';
        return;
    }
    
    const userLatLng = userMarker.getLatLng();
    let userLat = userLatLng.lat;
    let userLng = userLatLng.lng;
    
    if (!isFinite(userLat) || !isFinite(userLng)) {
        console.warn('Invalid user coordinates:', userLat, userLng);
        distanceBox.innerText = 'Initializing...';
        return;
    }
    
    if (userLat === 0 && userLng === 0) {
        const center = map.getCenter();
        userLat = center.lat;
        userLng = center.lng;
    }
    
    let closestDistance = Infinity;
    let closestLocation = null;
    const userPos = { lat: userLat, lng: userLng };
    
    for (const location of gameLocations) {
        if (!location || typeof location.lat !== 'number' || typeof location.lng !== 'number') {
            console.warn('Invalid location data:', location);
            continue;
        }
        const locationPos = { lat: location.lat, lng: location.lng };
        const distance = calculateDistance(userPos, locationPos);
        if (isFinite(distance) && distance < closestDistance) {
            closestDistance = distance;
            closestLocation = location;
        }
    }
    
    if (!isFinite(closestDistance) || closestDistance === Infinity) {
        console.warn('Invalid distance calculation:', closestDistance);
        distanceBox.innerText = 'Initializing...';
        return;
    }
    
    const distanceFeet = Math.round(closestDistance * 3.28084);
    const distanceText = distanceFeet < 5280 
        ? `${distanceFeet.toLocaleString()} feet` 
        : `${(distanceFeet / 5280).toFixed(2)} miles`;
    
    distanceBox.innerText = `Closest Stop: ${distanceText}`;
    
    if (closestLocation && closestLocation.markerColor) {
        let borderStyle = '';
        if (distanceFeet <= 100) {
            borderStyle = `3px solid ${closestLocation.markerColor}`;
        } else if (distanceFeet <= 500) {
            borderStyle = `2px solid ${closestLocation.markerColor}`;
        } else {
            borderStyle = `1px solid ${closestLocation.markerColor}`;
        }
        distanceBox.style.border = borderStyle;
    } else {
        distanceBox.style.border = '3px solid var(--dark-blue)';
        distanceBox.style.color = 'var(--dark-blue)';
        distanceBox.style.background = 'white';
    }
    
    // Enhanced haptic feedback with your triggerHapticFeedback function
    if (distanceFeet <= 20 && closestLocation) {
        const locationId = closestLocation.id;
        const now = Date.now();
        const lastVibration = locationTriggerState.lastVibrations?.get(locationId) || 0;
        
        if ((now - lastVibration) > 5000) {
            // Use your haptic feedback function with appropriate pattern
            if (distanceFeet <= 10) {
                triggerHapticFeedback([200, 100, 200]); // Double pulse for very close
            } else {
                triggerHapticFeedback([200]); // Single pulse for close
            }
            
            if (!locationTriggerState.lastVibrations) {
                locationTriggerState.lastVibrations = new Map();
            }
            locationTriggerState.lastVibrations.set(locationId, now);
        }
    }
    
    if (distanceFeet <= CONFIG.DISTANCE_THRESHOLD && !isLocationHuntVisible && closestLocation) {
        const userBearing = enhancedTrackingState.heading;
        const isApproaching = isApproachingLocation(userPos, userBearing, closestLocation);
        
        if (isApproaching) {
            const locationId = closestLocation.id;
            const now = Date.now();
            const lastTrigger = locationTriggerState.cooldowns.get(locationId);
            
            if (!lastTrigger || (now - lastTrigger) >= CONFIG.LOCATION_COOLDOWN) {
                if (!locationTriggerState.dwellTimers.has(locationId)) {
                    locationTriggerState.dwellTimers.set(locationId, now);
                } else {
                    const dwellStart = locationTriggerState.dwellTimers.get(locationId);
                    if ((now - dwellStart) >= CONFIG.DWELL_TIME) {
                        locationTriggerState.cooldowns.set(locationId, now);
                        locationTriggerState.dwellTimers.delete(locationId);
                        
                        // Trigger special haptic for location hunt activation
                        triggerHapticFeedback([100, 50, 100, 50, 100]);
                        
                        showLocationHunt(closestLocation);
                    }
                }
            } else {
                locationTriggerState.dwellTimers.delete(locationId);
            }
        } else {
            locationTriggerState.dwellTimers.delete(closestLocation.id);
        }
    } else {
        locationTriggerState.dwellTimers.clear();
    }
}

function calculateDistance(pos1, pos2) {
    if (!pos1 || !pos2 || 
        typeof pos1.lat !== 'number' || typeof pos1.lng !== 'number' || 
        typeof pos2.lat !== 'number' || typeof pos2.lng !== 'number') {
        return Infinity;
    }
    
    const R = 6371000;
    const lat1 = pos1.lat * Math.PI / 180;
    const lat2 = pos2.lat * Math.PI / 180;
    const deltaLat = (pos2.lat - pos1.lat) * Math.PI / 180;
    const deltaLng = (pos2.lng - pos1.lng) * Math.PI / 180;
    const a = Math.sin(deltaLat/2) * Math.sin(deltaLat/2) +
            Math.cos(lat1) * Math.cos(lat2) *
            Math.sin(deltaLng/2) * Math.sin(deltaLng/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return R * c;
}

function getGeolocationOptions(retryNumber) {
    return {
        enableHighAccuracy: retryNumber < 2,
        timeout: 10000 + (retryNumber * 5000),
        maximumAge: retryNumber * 5000
    };
}

function handleLocationError(error) {
    console.warn("Error getting user location:", error);
    
    if (retryCount < CONFIG.MAX_RETRIES) {
        retryCount++;
        console.log(`Retrying to get location (Attempt ${retryCount} of ${CONFIG.MAX_RETRIES})`);
        
        const currentRetryDelay = CONFIG.RETRY_DELAY * retryCount;
        
        setTimeout(() => {
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    console.log("Location retrieved successfully after retry");
                    hideLoadingMessage();
                    updateUserLocation(position, true);
                    retryCount = 0;
                }, 
                handleLocationError, 
                getGeolocationOptions(retryCount) 
            );
        }, currentRetryDelay);
        return;
    }
    
    retryCount = 0;
    hideLoadingMessage();
    
    let errorMessage = "An error occurred while getting your location.";
    if (error && error.code) {
        switch(error.code) {
            case 1:
                errorMessage = "Please allow access to your location to use this feature.";
                break;
            case 2:
                errorMessage = "Your location is currently unavailable. Please try again later.";
                break;
            case 3:
                errorMessage = "Getting your location took too long. Please try again.";
                break;
        }
    }
    
    showPopup("Location Error", errorMessage);
    
    if (typeof onLocationFailure === 'function') {
        onLocationFailure(error);
    }
}

function showPopup(title, message, type = "info", callback = null) {
    console.log("showPopup called with:", title, message);
    
    const existingPopups = document.querySelectorAll(".popup-overlay");
    existingPopups.forEach(popup => {
        document.body.removeChild(popup);
    });
    
    const overlay = document.createElement("div");
    overlay.className = "popup-overlay";
    overlay.style.position = "fixed";
    overlay.style.left = "0";
    overlay.style.top = "0";
    overlay.style.width = "100%";
    overlay.style.height = "100%";
    overlay.style.backgroundColor = "rgba(0, 0, 0, 0.7)";
    overlay.style.zIndex = "9999";
    
    const popupContainer = document.createElement("div");
    popupContainer.className = "popup-container";
    popupContainer.style.position = "absolute";
    popupContainer.style.left = "50%";
    popupContainer.style.top = "50%";
    popupContainer.style.transform = "translate(-50%, -50%)";
    popupContainer.style.backgroundColor = "white";
    popupContainer.style.borderRadius = "8px";
    popupContainer.style.padding = "20px";
    popupContainer.style.width = "300px";
    popupContainer.style.maxWidth = "90%";
    popupContainer.style.boxShadow = "0 4px 15px rgba(0, 0, 0, 0.2)";
    
    const titleElement = document.createElement("h3");
    titleElement.textContent = title;
    titleElement.style.margin = "0 0 15px 0";
    titleElement.style.textAlign = "center";
    titleElement.style.color = "#333";
    
    const messageElement = document.createElement("p");
    messageElement.textContent = message;
    messageElement.style.margin = "0 0 20px 0";
    messageElement.style.textAlign = "center";
    messageElement.style.color = "#555";
    
    const button = document.createElement("button");
    button.textContent = "OK";
    button.style.display = "block";
    button.style.margin = "0 auto";
    button.style.padding = "8px 20px";
    button.style.backgroundColor = "#2c5282";
    button.style.color = "white";
    button.style.border = "none";
    button.style.borderRadius = "4px";
    button.style.cursor = "pointer";
    
    button.addEventListener("click", function() {
        document.body.removeChild(overlay);
        if (callback && typeof callback === 'function') {
            callback();
        }
    });
    
    overlay.addEventListener("click", function(e) {
        if (e.target === overlay) {
            document.body.removeChild(overlay);
        }
    });
    
    popupContainer.appendChild(titleElement);
    popupContainer.appendChild(messageElement);
    popupContainer.appendChild(button);
    overlay.appendChild(popupContainer);
    document.body.appendChild(overlay);
    
    button.focus();
}

function recenterMap() {
    const recenterButton = cachedElements.recenterButton || document.getElementById('recenterButton');
    recenterButton.style.backgroundColor = 'var(--primary-color)';
    recenterButton.style.color = 'white';
    
    if (userMarker && userMarker.getLatLng()) {
        map.closePopup();
        
        const currentZoom = map.getZoom();
        
        map.panTo(userMarker.getLatLng(), {
            animate: true,
            duration: 0.5,
            easeLinearity: 0.25,
            noZoom: true
        });
        
        followUser = true;
        
        announceToScreenReader('Map recentered on your location');
    }
    
    setTimeout(() => {
        recenterButton.style.backgroundColor = 'white';
        recenterButton.style.color = 'var(--primary-color)';
    }, 500);
}

const COOLDOWN_PERIOD = 120 * 1000;
const MINIMUM_GAP = 15 * 1000;
const STORAGE_KEY = 'locationCooldowns';

const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
const DEBOUNCE_TIME = isTouchDevice ? 100 : 50;

let lastFunctionCall = 0;

class CooldownManager {
    constructor() {
        this.cooldowns = this.loadCooldowns();
        this.cleanupExpired();
    }
    loadCooldowns() {
        try {
            const stored = localStorage.getItem(STORAGE_KEY);
            return stored ? JSON.parse(stored) : {};
        } catch (e) {
            console.warn('Failed to load cooldowns:', e);
            return {};
        }
    }
    saveCooldowns() {
        try {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(this.cooldowns));
        } catch (e) {
            console.warn('Failed to save cooldowns:', e);
        }
    }
    cleanupExpired() {
        const now = Date.now();
        let cleaned = false;
        Object.keys(this.cooldowns).forEach(key => {
            const timeElapsed = now - this.cooldowns[key];
            
            if (timeElapsed > COOLDOWN_PERIOD) {
                delete this.cooldowns[key];
                cleaned = true;
            }
        });
        if (cleaned) {
            this.saveCooldowns();
        }
    }
    isOnCooldown(locationId) {
        const key = `location_${locationId}`;
        const now = Date.now();
        
        if (!this.cooldowns[key]) {
            return { onCooldown: false, reason: 'no_cooldown' };
        }
        const timeElapsed = now - this.cooldowns[key];
        
        if (timeElapsed < 0) {
            console.warn(`Invalid cooldown timestamp for ${locationId}, removing`);
            delete this.cooldowns[key];
            this.saveCooldowns();
            return { onCooldown: false, reason: 'invalid_timestamp' };
        }
        
        if (timeElapsed < MINIMUM_GAP) {
            return { 
                onCooldown: true, 
                reason: 'minimum_gap',
                timeRemaining: MINIMUM_GAP - timeElapsed,
                timeElapsed
            };
        }
        
        if (timeElapsed < COOLDOWN_PERIOD) {
            return { 
                onCooldown: true, 
                reason: 'cooldown_period',
                timeRemaining: COOLDOWN_PERIOD - timeElapsed,
                timeElapsed
            };
        }
        
        delete this.cooldowns[key];
        this.saveCooldowns();
        return { onCooldown: false, reason: 'expired' };
    }
    setCooldown(locationId) {
        const key = `location_${locationId}`;
        const now = Date.now();
        
        this.cooldowns[key] = now;
        this.saveCooldowns();
        
        console.log(`Cooldown set for location ${locationId} at ${now} (2-minute cooldown active)`);
    }
    clearAll() {
        this.cooldowns = {};
        this.saveCooldowns();
        console.log('All cooldowns cleared');
    }
    getRemainingTime(locationId) {
        const cooldownStatus = this.isOnCooldown(locationId);
        if (cooldownStatus.onCooldown) {
            return Math.ceil(cooldownStatus.timeRemaining / 1000);
        }
        return 0;
    }
}

const cooldownManager = new CooldownManager();

function showLocationHunt(location) {
    const now = Date.now();
    
    if (now - lastFunctionCall < DEBOUNCE_TIME) {
        console.log(`Function debounced (${now - lastFunctionCall}ms ago) on ${isTouchDevice ? 'touch' : 'desktop'} device`);
        return;
    }
    lastFunctionCall = now;
    
    console.log(`Processing location ${location.id} on ${isTouchDevice ? 'touch' : 'desktop'} device`);
    
    cooldownManager.cleanupExpired();
    
    const cooldownStatus = cooldownManager.isOnCooldown(location.id);
    
    if (cooldownStatus.onCooldown) {
        const remainingSeconds = Math.ceil(cooldownStatus.timeRemaining / 1000);
        const remainingMinutes = Math.ceil(remainingSeconds / 60);
        console.log(`Location ${location.id} is on cooldown: ${cooldownStatus.reason}, ${remainingSeconds}s (${remainingMinutes}min) remaining`);
        
        if (remainingSeconds > 60) {
            console.log(`Please wait ${remainingMinutes} more minute(s) before visiting this location again.`);
        } else {
            console.log(`Please wait ${remainingSeconds} more seconds before visiting this location again.`);
        }
        return;
    }
    
    console.log(`Location ${location.id} cooldown check passed: ${cooldownStatus.reason}`);
    
    cooldownManager.setCooldown(location.id);
    
    lastVisitedLocationId = location.id;
    isLocationHuntVisible = true;
    const lochuntContainer = cachedElements.lochuntContainer || document.querySelector('.lochunt-container');
    lochuntContainer.innerHTML = '';
    lochuntContainer.style.display = 'flex';
    lochuntContainer.classList.add('fade-in');
    
    announceToScreenReader(`Opened location: ${location.name}`);
    
    const scrollableContent = document.createElement('div');
    scrollableContent.style.cssText = `
        flex: 1;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
        scroll-behavior: smooth;
        will-change: scroll-position;
    `;
    
    const locationImage = document.createElement('img');
    locationImage.src = location.image;
    locationImage.alt = location.name;
    locationImage.style.cssText = `
        width: 100%;
        height: 45vh;
        object-fit: cover;
        object-position: center;
    `;
    locationImage.loading = "eager";
    scrollableContent.appendChild(locationImage);
    
    const contentContainer = document.createElement('div');
    contentContainer.classList.add('lochunt-content');
    contentContainer.style.cssText = `
        padding: 24px;
        display: flex;
        flex-direction: column;
        align-items: center;
        max-width: 800px;
        margin: 0 auto;
    `;
    
    const locationInfo = document.createElement('div');
    locationInfo.classList.add('lochunt-info');
    locationInfo.style.cssText = `
        text-align: center;
        width: 100%;
        margin-bottom: 15px;
    `;
    
    const locationName = document.createElement('h1');
    locationName.textContent = location.name;
    locationName.style.cssText = `
        font-size: clamp(1.8rem, 4vw, 2.5rem);
        font-weight: 700;
        color: #1a1a1a;
        margin-bottom: 8px;
        line-height: 1.2;
    `;
    
    const locationCity = document.createElement('p');
    locationCity.textContent = `${location.city}`;
    locationCity.style.cssText = `
        font-size: clamp(1.1rem, 2vw, 1.3rem);
        color: #2c5282;
        font-weight: 600;
        margin-bottom: 4px;
    `;
    
    const locationCreator = document.createElement('p');
    locationCreator.textContent = `Created by: ${location.creator}`;
    locationCreator.style.cssText = `
        font-size: calc(0.9rem + 0.4vw);
        color: #666666;
        font-weight: 500;
    `;
    
    locationInfo.appendChild(locationName);
    locationInfo.appendChild(locationCity);
    locationInfo.appendChild(locationCreator);
    contentContainer.appendChild(locationInfo);
    
    const audioPlayerContainer = createAudioPlayer(location.audio);
    contentContainer.appendChild(audioPlayerContainer);
    scrollableContent.appendChild(contentContainer);
    lochuntContainer.appendChild(scrollableContent);
    
    const bottomActionBar = createBottomActionBar(location);
    bottomActionBar.style.cssText += `
        position: sticky;
        bottom: 0;
        width: 100%;
    `;
    lochuntContainer.appendChild(bottomActionBar);
    
    setTimeout(() => {
        window.audioPlayerCleanup = initAudioPlayer();
    }, 100);
    
    if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
        const userPos = userMarker ? userMarker.getLatLng() : null;
        if (userPos && gameLocations) {
            navigator.serviceWorker.controller.postMessage({
                type: 'PREFETCH_AUDIO',
                data: {
                    userLocation: { lat: userPos.lat, lng: userPos.lng },
                    locations: gameLocations
                }
            });
        }
    }
}
        
function createAudioPlayer(audioSrc) {
    const audioPlayerContainer = document.createElement('div');
    audioPlayerContainer.classList.add('audio-player');
    audioPlayerContainer.style.cssText = `
        width: 100%;
        max-width: 400px;
        margin-bottom: 15px;
    `;
    const audio = document.createElement('audio');
    audio.id = 'locationAudio';
    audio.src = audioSrc;
    audio.preload = "auto";
    const audioProgress = document.createElement('div');
    audioProgress.classList.add('audio-progress');
    audioProgress.style.cssText = `
        width: 100%;
        margin-bottom: 15px;
    `;
    const progressContainer = document.createElement('div');
    progressContainer.classList.add('progress');
    progressContainer.style.cssText = `
        height: 8px;
        background-color: #e2e8f0;
        border-radius: 4px;
        cursor: pointer;
        margin-bottom: 12px;
        overflow: hidden;
    `;
    const progressBar = document.createElement('div');
    progressBar.id = 'progressBar';
    progressBar.classList.add('progress-bar');
    progressBar.style.cssText = `
        height: 100%;
        background-color: #2c5282;
        width: 0%;
        transition: width 0.1s linear;
    `;
    progressContainer.appendChild(progressBar);
    audioProgress.appendChild(progressContainer);
    const timeInfo = document.createElement('div');
    timeInfo.classList.add('audio-time');
    timeInfo.style.cssText = `
        display: flex;
        justify-content: space-between;
        color: #4a5568;
        font-size: 0.875rem;
        margin-bottom: 16px;
        font-weight: 500;
    `;
    const currentTimeSpan = document.createElement('span');
    currentTimeSpan.id = 'currentTime';
    currentTimeSpan.textContent = '0:00';
    const durationSpan = document.createElement('span');
    durationSpan.id = 'duration';
    durationSpan.textContent = '0:00';
    timeInfo.appendChild(currentTimeSpan);
    timeInfo.appendChild(durationSpan);
    const audioControls = document.createElement('div');
    audioControls.classList.add('audio-controls');
    audioControls.style.cssText = `
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 24px;
    `;
    const rewindBtn = createAudioButton('skip-backward', 'rewindBtn', 'Rewind 10 seconds');
    const playPauseBtn = createAudioButton('play', 'playPauseBtn', 'Play');
    const forwardBtn = createAudioButton('skip-forward', 'forwardBtn', 'Forward 10 seconds');
    audioControls.appendChild(rewindBtn);
    audioControls.appendChild(playPauseBtn);
    audioControls.appendChild(forwardBtn);
    audioPlayerContainer.appendChild(audio);
    audioPlayerContainer.appendChild(audioProgress);
    audioPlayerContainer.appendChild(timeInfo);
    audioPlayerContainer.appendChild(audioControls);
    return audioPlayerContainer;
}

function createAudioButton(iconName, id, ariaLabel) {
    const button = document.createElement('button');
    button.id = id;
    button.classList.add('audio-button');
    button.setAttribute('aria-label', ariaLabel);
    button.innerHTML = `<i class="bi bi-${iconName}"></i>`;
    button.style.cssText = `
        background-color: white;
        color: var(--primary-color);
        border: 2px solid var(--primary-color);
        border-radius: 50%;
        width: 55px;
        height: 55px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.3s ease;
    `;
    button.addEventListener('mouseover', () => {
        button.style.backgroundColor = 'var(--hover-color)';
    });
    button.addEventListener('mouseout', () => {
        button.style.backgroundColor = 'white';
    });
    button.addEventListener('click', () => {
        button.style.backgroundColor = 'var(--primary-color)';
        button.style.color = 'white';
        button.style.transform = 'scale(0.95)';
        
        setTimeout(() => {
            button.style.backgroundColor = 'white';
            button.style.color = 'var(--primary-color)';
            button.style.transform = 'scale(1)';
        }, 200);
    });
    return button;
}

function createBottomActionBar(location) {
    const actionBar = document.createElement('div');
    actionBar.classList.add('location-action-bar');
    actionBar.style.cssText = `
        width: 100%;
        height: 60px;
        background: linear-gradient(to right, #2c5282, #2b6cb0);
        margin-top: auto;
        box-shadow: 0 -2px 10px rgba(0,0,0,0.025);
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0 24px;
        position: sticky;
        bottom: 0;
    `;
    
    const imgSourceBtn = document.createElement('button');
    imgSourceBtn.classList.add('source-info-button', 'btn', 'btn-sm', 'me-2');
    imgSourceBtn.innerHTML = '<i class="bi bi-info-circle-fill text-white" style="font-size: 1.5rem;"></i>';
    imgSourceBtn.setAttribute('aria-label', 'Image source information');
    imgSourceBtn.onclick = () => {
        if (location && location.imageSource) {
            showSourcePopup('Image Source', location.imageSource);
        } else {
            showSourcePopup('Image Source', 'Image source information is not available');
        }
    };
    const feedbackButton = document.createElement('a');
    feedbackButton.href = 'mailto:mattreicher@protonmail.com?subject=Feedback';
    feedbackButton.target = '_blank';
    feedbackButton.rel = 'noopener noreferrer';
    feedbackButton.setAttribute('aria-label', 'Send feedback email');
    feedbackButton.innerHTML = '<i class="bi bi-envelope-fill text-white" style="font-size: 1.5rem;"></i>';
    feedbackButton.classList.add('feedback-email-button', 'btn', 'btn-sm');
    actionBar.appendChild(imgSourceBtn);
    actionBar.appendChild(feedbackButton);
    return actionBar;
}

function showSourcePopup(title, content) {
    const existingPopup = document.getElementById('sourceInfoPopup');
    if (existingPopup) {
        document.body.removeChild(existingPopup);
    }
    
    const overlay = document.createElement('div');
    overlay.id = 'sourceInfoPopup';
    overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 9999;
        backdrop-filter: blur(3px);
    `;
    
    const popup = document.createElement('div');
    popup.classList.add('source-info-content');
    popup.style.cssText = `
        background-color: white;
        border-radius: 8px;
        padding: 24px;
        width: 90%;
        max-width: 500px;
        max-height: 80vh;
        overflow-y: auto;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
        display: flex;
        flex-direction: column;
    `;
    
    const popupTitle = document.createElement('h3');
    popupTitle.textContent = title;
    popupTitle.style.cssText = `
        font-size: 1.5rem;
        font-weight: 600;
        color: #2c5282;
        margin-bottom: 16px;
        border-bottom: 1px solid #e2e8f0;
        padding-bottom: 12px;
    `;
    
    const popupContent = document.createElement('div');
    popupContent.style.cssText = `
        margin-bottom: 20px;
        line-height: 1.6;
        font-size: 1rem;
    `;
    popupContent.textContent = content;
    
    const closeButton = document.createElement('button');
    closeButton.textContent = 'Close';
    closeButton.classList.add('source-close-button', 'btn');
    closeButton.style.cssText = `
        background: linear-gradient(to right, #2c5282, #2b6cb0);
        border: none;
        color: white;
        padding: 8px 24px;
        border-radius: 4px;
        font-weight: 500;
        cursor: pointer;
        align-self: flex-end;
        transition: all 0.2s ease;
    `;
    
    closeButton.addEventListener('mouseover', () => {
        closeButton.style.opacity = '0.9';
    });
    
    closeButton.addEventListener('mouseout', () => {
        closeButton.style.opacity = '1';
    });
    
    closeButton.addEventListener('click', () => {
        document.body.removeChild(overlay);
    });
    
    overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
            document.body.removeChild(overlay);
        }
    });
    
    popup.appendChild(popupTitle);
    popup.appendChild(popupContent);
    popup.appendChild(closeButton);
    overlay.appendChild(popup);
    document.body.appendChild(overlay);
    
    overlay.style.opacity = '0';
    popup.style.transform = 'translateY(20px)';
    popup.style.transition = 'transform 0.3s ease, opacity 0.3s ease';
    overlay.style.transition = 'opacity 0.3s ease';
    
    setTimeout(() => {
        overlay.style.opacity = '1';
        popup.style.transform = 'translateY(0)';
    }, 10);
}

function initAudioPlayer() {
    const audio = document.getElementById('locationAudio');
    const playPauseBtn = document.getElementById('playPauseBtn');
    const rewindBtn = document.getElementById('rewindBtn');
    const forwardBtn = document.getElementById('forwardBtn');
    const progressBar = document.getElementById('progressBar');
    const progressContainer = document.querySelector('.progress');
    const currentTimeSpan = document.getElementById('currentTime');
    const durationSpan = document.getElementById('duration');
    if (!audio || !playPauseBtn || !progressBar) {
        console.error("Audio player elements not found");
        return;
    }
    
    if (audio.src && !audio.dataset.originalSrc) {
        audio.dataset.originalSrc = audio.src;
    }
    
    let wakeLock = null;
    let audioContext = null;
    let isPlayerActive = true;
    
    let retryCount = 0;
    const maxRetries = 3;
    let lastPlaybackPosition = 0;
    let recoveryInProgress = false;
    
    let wasPlayingWhenHidden = false;
    let screenWentAway = false;
    let wasPlaying = false;
    
    function initAudioContext() {
        if (!audioContext && isPlayerActive) {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const source = audioContext.createMediaElementSource(audio);
                source.connect(audioContext.destination);
            } catch (e) {
                console.log('AudioContext not available:', e);
            }
        }
        return audioContext;
    }
    
    async function requestWakeLock() {
        try {
            if ('wakeLock' in navigator && !wakeLock && isPlayerActive) {
                wakeLock = await navigator.wakeLock.request('screen');
                console.log('Wake lock acquired');
                
                wakeLock.addEventListener('release', () => {
                    console.log('Wake lock released');
                    wakeLock = null;
                    if (!audio.paused) {
                        screenWentAway = true;
                        wasPlayingWhenHidden = true;
                    }
                });
            }
        } catch (err) {
            console.warn('Wake lock failed:', err);
        }
    }
    
    async function releaseWakeLock() {
        if (wakeLock) {
            try {
                await wakeLock.release();
                wakeLock = null;
                console.log('Wake lock manually released');
            } catch (err) {
                console.warn('Wake lock release failed:', err);
            }
        }
    }
    
    document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
            if (!audio.paused) {
                wasPlayingWhenHidden = true;
                screenWentAway = true;
            }
        } else {
            if (wasPlayingWhenHidden && audio.paused) {
                setTimeout(() => {
                    if (screenWentAway) {
                        showSourcePopup("Audio Restarted", "Audio was interrupted when this tab became inactive and has restarted from the beginning. Keep this tab active to prevent interruptions.");
                        screenWentAway = false;
                        wasPlayingWhenHidden = false;
                    }
                }, 100);
            }
        }
    });
    
    audio.addEventListener('play', () => {
        wasPlaying = true;
        announceToScreenReader('Audio playback started');
    });
    
    audio.addEventListener('pause', () => {
        wasPlaying = false;
        announceToScreenReader('Audio playback paused');
    });
    
    function recoverAudioSource() {
        if (recoveryInProgress || !isPlayerActive) return;
        
        recoveryInProgress = true;
        console.log('Attempting audio recovery...');
        
        if (!isNaN(audio.currentTime)) {
            lastPlaybackPosition = audio.currentTime;
        }
        
        if (audio.dataset.originalSrc) {
            audio.src = audio.dataset.originalSrc;
        } else if (audio.getAttribute('data-src')) {
            audio.src = audio.getAttribute('data-src');
        }
        
        audio.load();
        
        const setPositionAfterNetworkRecovery = () => {
            if (lastPlaybackPosition > 0 && !screenWentAway) {
                audio.currentTime = lastPlaybackPosition;
            } else if (screenWentAway) {
                audio.currentTime = 0;
            }
            recoveryInProgress = false;
            retryCount = 0;
            audio.removeEventListener('loadedmetadata', setPositionAfterNetworkRecovery);
            audio.removeEventListener('canplay', setPositionAfterNetworkRecovery);
        };
        
        audio.addEventListener('loadedmetadata', setPositionAfterNetworkRecovery);
        audio.addEventListener('canplay', setPositionAfterNetworkRecovery);
    }
    
    function handleAudioError(error) {
       console.log('handleAudioError called, isPlayerActive:', isPlayerActive, 'audio exists:', !!audio);
       console.log('Screen went away:', screenWentAway, 'Was playing when hidden:', wasPlayingWhenHidden);
       console.log('Current lastPlaybackPosition:', lastPlaybackPosition);
       
       const actualError = audio ? audio.error : null;
       if (actualError) {
           console.error("Actual audio error details:", {
               code: actualError.code,
               message: actualError.message,
               MEDIA_ERR_ABORTED: actualError.code === 1,
               MEDIA_ERR_NETWORK: actualError.code === 2,
               MEDIA_ERR_DECODE: actualError.code === 3,
               MEDIA_ERR_SRC_NOT_SUPPORTED: actualError.code === 4
           });
       }
       
       if (!isPlayerActive && (!audio || audio.readyState === 0)) {
           console.log('Audio error ignored - player cleaned up');
           return;
       }
       
       console.error("Audio play error event:", error);
       releaseWakeLock();
       
       if (screenWentAway || wasPlayingWhenHidden) {
           const resumePosition = lastPlaybackPosition || 0;
           console.log('Screen interruption detected, stored position:', resumePosition);
           
           showSourcePopup("Audio Interrupted", `Audio was paused when you left the screen. Click play to resume from ${Math.floor(resumePosition / 60)}:${String(Math.floor(resumePosition % 60)).padStart(2, '0')}.`);
           
           if (audio) {
               audio.dataset.resumePosition = resumePosition.toString();
               
               const prepareForResume = () => {
                   console.log('Audio prepared for manual resume');
                   audio.removeEventListener('loadedmetadata', prepareForResume);
                   audio.removeEventListener('canplay', prepareForResume);
               };
               
               audio.addEventListener('loadedmetadata', prepareForResume);
               audio.addEventListener('canplay', prepareForResume);
               
               recoverAudioSource();
           }
           
           screenWentAway = false;
           wasPlayingWhenHidden = false;
       } else if (retryCount < maxRetries && isPlayerActive) {
           retryCount++;
           console.log(`Recovery attempt ${retryCount}/${maxRetries}`);
           
           setTimeout(() => {
               const currentPos = lastPlaybackPosition || 0;
               const setPositionAfterNetworkRecovery = () => {
                   if (currentPos > 0) {
                       console.log('Setting position after network recovery:', currentPos);
                       audio.currentTime = currentPos;
                   }
                   audio.removeEventListener('loadedmetadata', setPositionAfterNetworkRecovery);
                   audio.removeEventListener('canplay', setPositionAfterNetworkRecovery);
               };
               
               audio.addEventListener('loadedmetadata', setPositionAfterNetworkRecovery);
               audio.addEventListener('canplay', setPositionAfterNetworkRecovery);
               
               recoverAudioSource();
           }, 1000 * retryCount);
       } else if (retryCount >= maxRetries) {
           console.error('Audio recovery failed after maximum retries');
           playPauseBtn.innerHTML = '<i class="bi bi-exclamation-triangle"></i>';
           playPauseBtn.setAttribute('aria-label', 'Audio Error');
           showSourcePopup("Audio Error", "Unable to recover audio after multiple attempts. Please refresh the page or try again later.");
       } else {
           if (audio) {
               const currentPos = lastPlaybackPosition || 0;
               const setPositionAfterGenericRecovery = () => {
                   if (currentPos > 0) {
                       console.log('Setting position after generic recovery:', currentPos);
                       audio.currentTime = currentPos;
                   }
                   audio.removeEventListener('loadedmetadata', setPositionAfterGenericRecovery);
                   audio.removeEventListener('canplay', setPositionAfterGenericRecovery);
               };
               
               audio.addEventListener('loadedmetadata', setPositionAfterGenericRecovery);
               audio.addEventListener('canplay', setPositionAfterGenericRecovery);
               
               recoverAudioSource();
           }
           showSourcePopup("Audio Error", "An audio error occurred. Attempting to resume from last position.");
       }
       
       playPauseBtn.innerHTML = '<i class="bi bi-play"></i>';
       playPauseBtn.setAttribute('aria-label', 'Play');
    }
    
    function togglePlay() {
       if (audio.paused) {
           const resumePosition = audio.dataset.resumePosition;
           if (resumePosition && parseFloat(resumePosition) > 0) {
               console.log('Resuming from stored position:', resumePosition);
               audio.currentTime = parseFloat(resumePosition);
               delete audio.dataset.resumePosition;
           }
           
           audio.play().then(() => {
               playPauseBtn.innerHTML = '<i class="bi bi-pause"></i>';
               playPauseBtn.setAttribute('aria-label', 'Pause');
               requestWakeLock();
           }).catch(error => {
               handleAudioError(error);
           });
       } else {
           audio.pause();
           playPauseBtn.innerHTML = '<i class="bi bi-play"></i>';
           playPauseBtn.setAttribute('aria-label', 'Play');
       }
    }
    
    audio.addEventListener('timeupdate', () => {
       if (!isNaN(audio.currentTime) && isPlayerActive && audio.currentTime > 0) {
           lastPlaybackPosition = audio.currentTime;
           try {
               localStorage.setItem('audioPosition', audio.currentTime.toString());
           } catch (e) {}
       }
    });
    
    document.addEventListener('visibilitychange', () => {
       if (document.hidden) {
           if (audio && !audio.paused) {
               if (!isNaN(audio.currentTime)) {
                   lastPlaybackPosition = audio.currentTime;
                   try {
                       localStorage.setItem('audioPosition', audio.currentTime.toString());
                   } catch (e) {}
               }
               
               wasPlayingWhenHidden = true;
               screenWentAway = true;
               
               audio.pause();
               
               playPauseBtn.innerHTML = '<i class="bi bi-play"></i>';
               playPauseBtn.setAttribute('aria-label', 'Play');
           }
       }
    });
    
    window.addEventListener('blur', () => {
       if (audio && !audio.paused) {
           lastPlaybackPosition = audio.currentTime;
           wasPlayingWhenHidden = true;
           screenWentAway = true;
           console.log('Window blur, storing position:', lastPlaybackPosition);
       }
    });
    
    window.addEventListener('online', () => {
       if (audio.error && isPlayerActive) {
           console.log('Network recovered, attempting to reload audio');
           const savedPos = lastPlaybackPosition || 0;
           const setPositionAfterOnline = () => {
               if (savedPos > 0) {
                   audio.currentTime = savedPos;
               }
               audio.removeEventListener('loadedmetadata', setPositionAfterOnline);
               audio.removeEventListener('canplay', setPositionAfterOnline);
           };
           
           audio.addEventListener('loadedmetadata', setPositionAfterOnline);
           audio.addEventListener('canplay', setPositionAfterOnline);
           
           recoverAudioSource();
       }
    });
    
    playPauseBtn.addEventListener('click', togglePlay);
    rewindBtn.addEventListener('click', () => seek(-10));
    forwardBtn.addEventListener('click', () => seek(10));
    audio.addEventListener('timeupdate', updateProgress);
    audio.addEventListener('loadedmetadata', setDuration);
    audio.addEventListener('ended', async () => {
       playPauseBtn.innerHTML = '<i class="bi bi-play"></i>';
       playPauseBtn.setAttribute('aria-label', 'Play');
       await releaseWakeLock();
       
       try {
           localStorage.removeItem('audioPosition');
       } catch (e) {}
       
       audio.currentTime = 0;
       if (progressBar) {
           progressBar.style.width = '0%';
       }
       
       announceToScreenReader('Audio playback completed');
       showAdditionalInfo();
    });
    audio.addEventListener('pause', releaseWakeLock);
    audio.addEventListener('error', (e) => {
       handleAudioError(e);
    });
    
    if (progressContainer) {
       progressContainer.addEventListener('click', setProgress);
    }
    
    audio.addEventListener('loadedmetadata', () => {
       try {
           const savedPosition = localStorage.getItem('audioPosition');
           if (savedPosition && !isNaN(savedPosition) && parseFloat(savedPosition) > 0 && !screenWentAway && !wasPlayingWhenHidden) {
               audio.currentTime = parseFloat(savedPosition);
           }
       } catch (e) {}
    });
    
    audio.load();
    
async function togglePlay() {
    if (!isPlayerActive) return;
    
    // Add this check to prevent empty src errors
    if (!audio.src || audio.src.trim() === '' || audio.src === window.location.href) {
        return;
    }
    
    try {
        if (audio.paused) {
            const ctx = initAudioContext();
            if (ctx && ctx.state === 'suspended') {
                await ctx.resume();
            }
            
            const playPromise = audio.play();
            if (playPromise !== undefined) {
                playPromise.then(async () => {
                    playPauseBtn.innerHTML = '<i class="bi bi-pause"></i>';
                    playPauseBtn.setAttribute('aria-label', 'Pause');
                    await requestWakeLock();
                    retryCount = 0;
                }).catch(error => {
                    handleAudioError(error);
                });
            }
        } else {
            audio.pause();
            playPauseBtn.innerHTML = '<i class="bi bi-play"></i>';
            playPauseBtn.setAttribute('aria-label', 'Play');
            await releaseWakeLock();
        }
    } catch (error) {
        handleAudioError(error);
    }
}
    
    function seek(seconds) {
        if (!isPlayerActive) return;
        audio.currentTime = Math.max(0, Math.min(audio.currentTime + seconds, audio.duration));
        
        const direction = seconds > 0 ? 'forward' : 'backward';
        announceToScreenReader(`Skipped ${Math.abs(seconds)} seconds ${direction}`);
    }
    
    function updateProgress() {
        if (!isPlayerActive || !isFinite(audio.duration)) return;
        
        const percent = (audio.currentTime / audio.duration) * 100;
        progressBar.style.width = `${percent}%`;
        currentTimeSpan.textContent = formatTime(audio.currentTime);
    }
    
    function setProgress(e) {
        if (!isPlayerActive) return;
        
        const width = this.clientWidth;
        const clickX = e.offsetX;
        const duration = audio.duration;
        
        if (isFinite(duration) && width > 0) {
            audio.currentTime = (clickX / width) * duration;
            
            const newTime = formatTime(audio.currentTime);
            announceToScreenReader(`Jumped to ${newTime}`);
        }
    }
    
    function setDuration() {
        if (!isPlayerActive || !isFinite(audio.duration)) return;
        durationSpan.textContent = formatTime(audio.duration);
    }
    
    function formatTime(time) {
        if (!isFinite(time)) return "0:00";
        
        const minutes = Math.floor(time / 60);
        const seconds = Math.floor(time % 60);
        return `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }
    
    return function cleanup() {
        console.log('Audio player cleanup starting');
        releaseWakeLock();
        isPlayerActive = false;
        if (audioContext) {
            audioContext.close();
        }
        console.log('Audio player cleaned up');
    };
}

function showAdditionalInfo() {
    const location = gameLocations.find(loc => loc.id === lastVisitedLocationId);
    if (!location) {
        console.error('Location not found for ID:', lastVisitedLocationId);
        return;
    }
    
    const additionalInfoContainer = cachedElements.additionalInfoContainer || document.querySelector('.additional-info-container');
    additionalInfoContainer.style.display = 'block';
    additionalInfoContainer.classList.add('fade-in');
    
    document.getElementById('additionalInfo').textContent = location.additionalInfo || 
        "No additional information available for this location.";
    
    announceToScreenReader('Additional information is now available');
    
    const continueButton = document.getElementById('continueButton');
    continueButton.onclick = () => {
        additionalInfoContainer.classList.add('fade-out');
        setTimeout(() => {
            additionalInfoContainer.style.display = 'none';
            additionalInfoContainer.classList.remove('fade-out');
            
            const lochuntContainer = cachedElements.lochuntContainer || document.querySelector('.lochunt-container');
            lochuntContainer.classList.add('fade-out');
            setTimeout(() => {
                lochuntContainer.style.display = 'none';
                lochuntContainer.classList.remove('fade-out');
                isLocationHuntVisible = false;
                
                announceToScreenReader('Returned to map view');
                
                updateDistanceBox();
                
                if (window.audioPlayerCleanup) {
                    window.audioPlayerCleanup();
                    window.audioPlayerCleanup = null;
                }
            }, 300);
        }, 300);
    };
}

function showLocationSummary(locationId) {
  const location = locations.find(loc => String(loc.id) === String(locationId));

  if (!location || !location.summary) {
    console.log("Location or summary not found. Location ID:", locationId);
    showPopup("Error", "Summary not available for this location.");
    return;
  }

  // 1. Hide the distance box
  const distanceBox = document.querySelector('#distanceBox');
  if (distanceBox) distanceBox.style.display = 'none';

  // 2. Build modal
  const popupDiv = document.createElement('div');
  popupDiv.id = 'summaryModal';
  popupDiv.style.cssText = `
      position:fixed; inset:0;
      background:rgba(0,0,0,.6); backdrop-filter:blur(4px);
      display:flex; align-items:center; justify-content:center;
      z-index:1000; opacity:0; transition:opacity .3s ease;
  `;

  const darkBlue = '#1a3a8a';
  const darkBlueHover = '#0d2c6e';

  popupDiv.innerHTML = `
    <div style="
        background:#fff; border-radius:16px; width:90%; max-width:420px; max-height:80vh;
        box-shadow:0 15px 40px rgba(0,0,0,.2); overflow:hidden;
        transform:translateY(20px); transition:transform .4s cubic-bezier(.175,.885,.32,1.275);
        display:flex; flex-direction:column;
    ">
      <div style="background:${darkBlue}; color:#fff; text-align:center; padding:18px 28px;">
        <h3 style="margin:0; font-size:1.5rem; font-weight:600">${location.name}</h3>
      </div>

      <div style="flex:1; overflow-y:auto; padding:28px">
        <p style="color:#5c6c7c; line-height:1.6; font-size:1rem; margin:0 0 25px">
          ${location.summary}
        </p>

        <div style="
            border:2px solid ${darkBlue}; border-radius:12px; padding:16px;
            background:rgba(26,58,138,.05); margin-bottom:25px;
            display:flex; align-items:center;
        ">
          <div style="font-weight:600; color:#2c3e50; padding-right:15px; min-width:80px">Location:</div>
          <div style="flex:1; color:#2c3e50; border-left:1px solid rgba(26,58,138,.2); padding-left:15px">
            ${location.today || 'Information not available'}
          </div>
        </div>

        <div style="display:flex; justify-content:center">
          <button class="continue-btn" style="
              padding:14px 24px; background:${darkBlue}; color:#fff; border:none;
              border-radius:10px; cursor:pointer; font-size:1rem; font-weight:600;
              min-width:130px; transition:.2s
          ">Continue</button>
        </div>
      </div>
    </div>
  `;

  document.body.appendChild(popupDiv);

  // Animate in
  requestAnimationFrame(() => {
    popupDiv.style.opacity = '1';
    popupDiv.querySelector('div').style.transform = 'translateY(0)';
  });

  // Close helpers
  function close() {
    popupDiv.style.opacity = '0';
    popupDiv.querySelector('div').style.transform = 'translateY(20px)';
    setTimeout(() => {
      document.body.removeChild(popupDiv);
      // 3. Restore distance box
      if (distanceBox) distanceBox.style.display = 'block';
    }, 300);
  }

  const btn = popupDiv.querySelector('.continue-btn');
  btn.addEventListener('mouseover', () => btn.style.backgroundColor = darkBlueHover);
  btn.addEventListener('mouseout',  () => btn.style.backgroundColor = darkBlue);
  btn.addEventListener('click', close);
  popupDiv.addEventListener('click', e => { if (e.target === popupDiv) close(); });
}

function showNavigationTips() {
   const distanceBox = document.querySelector('#distanceBox'); 
   if (distanceBox) {
       distanceBox.style.display = 'none';
   }
   
   const modalOverlay = document.createElement("div");
   modalOverlay.className = "navigation-tips-overlay";
   modalOverlay.style.cssText = `
       position: fixed;
       top: 0;
       left: 0;
       width: 100%;
       height: 100%;
       background-color: rgba(0, 0, 0, 0.6);
       backdrop-filter: blur(4px);
       display: flex;
       justify-content: center;
       align-items: center;
       z-index: 1000;
       opacity: 0;
       transition: opacity 0.3s ease;
   `;
   
   const darkBlue = "var(--dark-blue)";
   const darkBlueHover = "var(--dark-blue-hover)";
   
   const modalContent = document.createElement("div");
   modalContent.className = "navigation-tips-content";
   modalContent.style.cssText = `
       background-color: white;
       border-radius: 16px;
       width: 90%;
       max-width: 450px;
       max-height: 95vh;
       box-shadow: 0 15px 40px rgba(0, 0, 0, 0.25);
       transform: translateY(20px);
       transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
       overflow: hidden;
       display: flex !important;
       flex-direction: column !important;
       position: relative;
   `;
   
   const header = document.createElement("div");
   header.style.cssText = `
       text-align: center;
       padding: 20px 28px 0;
   `;
   
   header.innerHTML = `
       <h3 style="
           margin: 0 0 10px 0;
           color: ${darkBlue};
           font-size: 1.5rem;
           font-weight: 600;
       ">Navigation Tips</h3>
   `;
   
   const contentArea = document.createElement("div");
   contentArea.style.cssText = `
       padding: 0 28px;
       color: #5c6c7c;
       line-height: 1.4;
       font-size: 0.9rem;
   `;
   
   contentArea.innerHTML = `
       <ul style="
           list-style-type: none;
           padding: 0;
           margin: 0 0 10px 0;
       ">
           <li style="margin-bottom: 8px; display: flex; align-items: flex-start;">
               <span style="color: ${darkBlue}; margin-right: 10px; font-size: 1.1rem;">•</span>
               <span>Use the map to navigate to the marked locations.</span>
           </li>
           <li style="margin-bottom: 8px; display: flex; align-items: flex-start;">
               <span style="color: ${darkBlue}; margin-right: 10px; font-size: 1.1rem;">•</span>
               <span>Tap the recenter button to focus on your current position.</span>
           </li>
           <li style="margin-bottom: 8px; display: flex; align-items: flex-start;">
               <span style="color: ${darkBlue}; margin-right: 10px; font-size: 1.1rem;">•</span>
               <span>The distance box shows how far you are from the closest location.</span>
           </li>
           <li style="margin-bottom: 8px; display: flex; align-items: flex-start;">
               <span style="color: ${darkBlue}; margin-right: 10px; font-size: 1.1rem;">•</span>
               <span>When you're within 20 feet of a location, you'll be able to interact with it.</span>
           </li>
           <li style="margin-bottom: 8px; display: flex; align-items: flex-start;">
               <span style="color: ${darkBlue}; margin-right: 10px; font-size: 1.1rem;">•</span>
               <span>Listen to the audio information for each location.</span>
           </li>
           <li style="margin-bottom: 0; display: flex; align-items: flex-start;">
               <span style="color: ${darkBlue}; margin-right: 10px; font-size: 1.1rem;">•</span>
               <span>After the audio, you'll see additional information about the location.</span>
           </li>
       </ul>
   `;
   
   const footer = document.createElement("div");
   footer.style.cssText = `
       padding: 15px 28px 20px !important;
       text-align: center !important;
       border-top: 1px solid rgba(0, 0, 0, 0.05);
       margin-top: 10px !important;
       display: flex !important;
       justify-content: center !important;
       align-items: center !important;
       position: relative !important;
       bottom: 0 !important;
       width: 100% !important;
       box-sizing: border-box !important;
   `;
   
   const closeButton = document.createElement("button");
   closeButton.className = "close-button";
   closeButton.textContent = "Close";
   closeButton.style.cssText = `
       padding: 10px 24px !important;
       background-color: ${darkBlue};
       color: white;
       border: none;
       border-radius: 10px;
       cursor: pointer;
       font-size: 1rem;
       font-weight: 600;
       width: 100% !important;
       max-width: 200px !important;
       transition: all 0.2s ease;
       margin: 0 auto !important;
       display: block !important;
       position: relative !important;
       left: 0 !important;
       right: 0 !important;
   `;
   
   footer.appendChild(closeButton);
   
   modalContent.appendChild(header);
   modalContent.appendChild(contentArea);
   modalContent.appendChild(footer);
   modalOverlay.appendChild(modalContent);
   document.body.appendChild(modalOverlay);
   
   setTimeout(() => {
       modalOverlay.style.opacity = "1";
       modalContent.style.transform = "translateY(0)";
   }, 10);
   
   closeButton.addEventListener("mouseover", function() {
       this.style.backgroundColor = darkBlueHover;
   });
   
   closeButton.addEventListener("mouseout", function() {
       this.style.backgroundColor = darkBlue;
   });
   
   closeButton.addEventListener("click", function() {
       modalOverlay.style.opacity = "0";
       modalContent.style.transform = "translateY(20px)";
       setTimeout(() => {
           document.body.removeChild(modalOverlay);
           if (distanceBox) {
               distanceBox.style.display = 'block';
           }
       }, 300);
   });
   
   modalOverlay.addEventListener("click", function(e) {
       if (e.target === modalOverlay) {
           modalOverlay.style.opacity = "0";
           modalContent.style.transform = "translateY(20px)";
           setTimeout(() => {
               document.body.removeChild(modalOverlay);
               if (distanceBox) {
                   distanceBox.style.display = 'block';
               }
           }, 300);
       }
   });
}

function startHunt() {
    gameLocations = locations.sort((a, b) => a.id - b.id);
    currentLocationIndex = 0;
    locationTriggerState.cooldowns.clear();
    lastVisitedLocationId = null;
    loadAllLocations();
}

function getMarkerColor(tours) {
    if (!tours) return '#0f2bab';
    
    switch (tours.toLowerCase()) {
        case 'person':
            return '#FFA500';
        case 'gangster':
            return '#3f9b0b';
        case 'event':
            return '#8B0000';
        case 'place':
            return '#800080';
        default:
            return '#0f2bab';
    }
}

function showAppMessage(appName, redirectUrl) {
    const messageEl = document.createElement('div');
    messageEl.style.cssText = `
        position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
        background: #333; color: white; padding: 35px; border-radius: 12px;
        z-index: 5000; text-align: center; line-height: 1.4;
        max-width: 85vw; box-sizing: border-box;
    `;
    messageEl.innerHTML = `
        <div style="font-size: clamp(22px, 5vw, 30px); font-weight: 500;">
            Opening ${appName}...
        </div>
        <div style="font-size: clamp(18px, 4vw, 24px); margin-top: 15px; opacity: 0.9;">
            To return: Switch back to your browser app
        </div>
    `;
    
    document.body.appendChild(messageEl);
    
    setTimeout(() => {
        messageEl.remove();
        window.location.href = redirectUrl;
    }, 3000);
}

let markersCreated = false;
let activePopups = new Set();

function recenterOnUser() {
    if (userMarker && map) {
        map.setView(userMarker.getLatLng(), map.getZoom(), {
            animate: true,
            duration: 0.5
        });
    }
}

function createMarkersOnly() {
    if (!gameLocations || !Array.isArray(gameLocations) || gameLocations.length === 0) {
        console.warn("No game locations available");
        return;
    }
    
    if (markerClusterGroup) {
        markerClusterGroup.clearLayers();
    }
    
    activePopups.clear();
    
    gameLocations.forEach((location) => {
        if (!location || typeof location.lat !== 'number' || typeof location.lng !== 'number') {
            console.warn("Invalid location data:", location);
            return;
        }
        const markerColor = getMarkerColor(location.tours);
        
        location.markerColor = markerColor;
        
        const locationMarker = L.marker([location.lat, location.lng], {
            icon: L.divIcon({
                className: 'custom-pin-icon',
                html: `<div class="pin-head" style="background-color: ${markerColor};"></div>`,
                iconSize: [30, 30],
                iconAnchor: [15, 30],
            })
        });
        const popupContent = `
            <div class="popup-content">
                <img loading="lazy" src="${location.image}" alt="${location.name}" class="location-image">
                <h4 class="location-name">
                    <a href="${location.link}" target="_blank" rel="noopener noreferrer" style="text-decoration: none; color: inherit;">${location.name}</a>
                </h4>
                <div class="popup-buttons">
                    <button class="button route-button" data-lat="${location.lat}" data-lng="${location.lng}" data-location-id="${location.id}">Directions</button>
                    <button class="button summary-button" data-location-id="${location.id}">Summary</button>
                </div>
            </div>
        `;
        locationMarker.bindPopup(popupContent, {
            offset: L.point(0, -25),
            className: 'custom-popup',
            maxWidth: 300,
            closeButton: true,
            autoClose: true,
            closeOnClick: true
        });
        
        locationMarker.on('popupopen', function(e) {
            activePopups.add(locationMarker);
            attachPopupEventListeners(e.popup._contentNode, location);
        });
        locationMarker.on('popupclose', function(e) {
            activePopups.delete(locationMarker);
        });
        markerClusterGroup.addLayer(locationMarker);
    });
    
    if (!map.hasLayer(markerClusterGroup)) {
        map.addLayer(markerClusterGroup);
    }
    
    markersCreated = true;
}

function attachPopupEventListeners(popupElement, location) {
    const routeButton = popupElement.querySelector('.route-button');
    const summaryButton = popupElement.querySelector('.summary-button');
    if (routeButton && !routeButton.hasAttribute('data-listener-attached')) {
        routeButton.setAttribute('data-listener-attached', 'true');
        routeButton.addEventListener('click', function(event) {
            event.preventDefault();
            event.stopPropagation();
            showNavigationModal(location.lat, location.lng);
        });
    }
    if (summaryButton && !summaryButton.hasAttribute('data-listener-attached')) {
        summaryButton.setAttribute('data-listener-attached', 'true');
        summaryButton.addEventListener('click', function(event) {
            event.preventDefault();
            event.stopPropagation();
            showLocationSummary(location.id);
        });
    }
}

function closeAllPopups() {
    activePopups.forEach(marker => {
        if (marker.isPopupOpen()) {
            marker.closePopup();
        }
    });
    activePopups.clear();
}

function showNavigationModal(destinationLat, destinationLng) {
    closeAllPopups();
    
    const existingModals = document.querySelectorAll('.modal');
    existingModals.forEach(modal => modal.remove());
    
    const modal = document.createElement("div");
    modal.className = "modal";
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
        opacity: 0;
        transition: opacity 0.3s ease;
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    `;
    
    modal.innerHTML = `
       <div class="modal-content" style="
           background-color: white;
           border-radius: 12px;
           padding: 20px;
           width: 90%;
           max-width: 400px;
           min-width: 280px;
           box-shadow: 0 10px 30px rgba(0,0,0,0.3);
           position: relative;
           transform: scale(0.9);
           transition: transform 0.3s ease;
           margin: 0;
           box-sizing: border-box;
       ">
           <h3 style="
               margin: 0 0 20px 0;
               text-align: center;
               color: #333;
               font-size: 1.2rem;
               font-weight: 600;
           ">Choose your preferred navigation app:</h3>
           <div class="modal-buttons" style="
               display: flex;
               flex-direction: column;
               align-items: center;
               gap: 12px;
               width: 100%;
               text-align: center;
           ">
               <button class="modal-button google-maps" style="
                   padding: 14px 20px;
                   margin: 0;
                   border: none;
                   border-radius: 8px;
                   cursor: pointer;
                   font-size: 1rem;
                   font-weight: 600;
                   transition: all 0.2s ease;
                   background-color: #4285F4;
                   color: white;
                   width: 100%;
                   display: flex;
                   align-items: center;
                   justify-content: center;
                   gap: 8px;
                   box-sizing: border-box;
               ">
                   <i class="fab fa-google" style="font-size: 1.1rem;"></i>
                   <span class="btn-text">Google Maps</span>
                   <i class="fas fa-spinner fa-spin location-spinner" style="font-size: 1rem; display: none; margin-left: 8px;"></i>
               </button>
               <button class="modal-button waze" style="
                   padding: 14px 20px;
                   margin: 0;
                   border: none;
                   border-radius: 8px;
                   cursor: pointer;
                   font-size: 1rem;
                   font-weight: 600;
                   transition: all 0.2s ease;
                   background-color: #00D4FF;
                   color: white;
                   width: 100%;
                   display: flex;
                   align-items: center;
                   justify-content: center;
                   gap: 8px;
                   box-sizing: border-box;
               ">
                   <i class="fas fa-route" style="font-size: 1rem;"></i>
                   <span class="btn-text">Waze</span>
                   <i class="fas fa-spinner fa-spin location-spinner" style="font-size: 1rem; display: none; margin-left: 8px;"></i>
               </button>
               <button class="modal-button apple-maps" style="
                   padding: 14px 20px;
                   margin: 0;
                   border: none;
                   border-radius: 8px;
                   cursor: pointer;
                   font-size: 1rem;
                   font-weight: 600;
                   transition: all 0.2s ease;
                   background-color: #007AFF;
                   color: white;
                   width: 100%;
                   display: flex;
                   align-items: center;
                   justify-content: center;
                   gap: 8px;
                   box-sizing: border-box;
               ">
                   <i class="fab fa-apple" style="font-size: 1.1rem;"></i>
                   <span class="btn-text">Apple Maps</span>
                   <i class="fas fa-spinner fa-spin location-spinner" style="font-size: 1rem; display: none; margin-left: 8px;"></i>
               </button>
               <button class="modal-button cancel" style="
                   padding: 14px 20px;
                   margin: 8px 0 0 0;
                   border: 2px solid #ddd;
                   border-radius: 8px;
                   cursor: pointer;
                   font-size: 1rem;
                   font-weight: 600;
                   transition: all 0.2s ease;
                   background-color: white;
                   color: #666;
                   width: 100%;
                   box-sizing: border-box;
               ">Cancel</button>
           </div>
       </div>
   `;
   
   document.body.appendChild(modal);
   
   setTimeout(() => {
       modal.style.opacity = "1";
       modal.querySelector(".modal-content").style.transform = "scale(1)";
   }, 10);
   
   let userLat = null;
   let userLng = null;
   let locationAttempted = false;
   
   const getUserLocation = () => {
       if (locationAttempted) return Promise.resolve();
       locationAttempted = true;
       
       return new Promise((resolve) => {
           if (navigator.geolocation) {
               navigator.geolocation.getCurrentPosition(
                   (position) => {
                       userLat = position.coords.latitude;
                       userLng = position.coords.longitude;
                       resolve();
                   },
                   (error) => {
                       console.log("Location access denied or failed");
                       resolve();
                   },
                   {
                       timeout: 5000,
                       enableHighAccuracy: false
                   }
               );
           } else {
               resolve();
           }
       });
   };
   
   const closeModal = () => {
       modal.style.opacity = "0";
       modal.querySelector(".modal-content").style.transform = "scale(0.9)";
       setTimeout(() => {
           if (modal.parentNode) {
               modal.remove();
           }
       }, 300);
   };
   
   const showReminderModal = (navigationUrl) => {
       const reminderModal = document.createElement("div");
       reminderModal.className = "reminder-modal";
       reminderModal.style.cssText = `
           position: fixed;
           top: 0;
           left: 0;
           width: 100%;
           height: 100%;
           background-color: rgba(0, 0, 0, 0.7);
           backdrop-filter: blur(4px);
           display: flex;
           justify-content: center;
           align-items: center;
           z-index: 10001;
           opacity: 0;
           transition: opacity 0.3s ease;
       `;
       
       reminderModal.innerHTML = `
           <div class="reminder-content" style="
               background-color: white;
               border-radius: 16px;
               padding: 24px;
               width: 90%;
               max-width: 400px;
               min-width: 280px;
               box-shadow: 0 15px 40px rgba(0,0,0,0.2);
               text-align: center;
               transform: translateY(20px);
               transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
           ">
               <div style="
                   width: 60px;
                   height: 60px;
                   background-color: #2c5282;
                   border-radius: 50%;
                   display: flex;
                   align-items: center;
                   justify-content: center;
                   margin: 0 auto 20px;
               ">
                   <i class="fas fa-map-marker-alt" style="color: white; font-size: 24px;"></i>
               </div>
               <h3 style="
                   margin: 0 0 15px 0;
                   color: #2c3e50;
                   font-size: 1.3rem;
                   font-weight: 600;
               ">Navigation Reminder</h3>
               <p style="
                   margin: 0 0 25px 0;
                   color: #5c6c7c;
                   line-height: 1.5;
                   font-size: 1rem;
               ">Remember to return to this map when you arrive at your destination to continue exploring!</p>
               <button class="reminder-ok-btn" style="
                   padding: 12px 30px;
                   background-color: #2c5282;
                   color: white;
                   border: none;
                   border-radius: 10px;
                   cursor: pointer;
                   font-size: 1rem;
                   font-weight: 600;
                   transition: all 0.2s ease;
                   min-width: 120px;
               ">Got it!</button>
           </div>
       `;
       
       document.body.appendChild(reminderModal);
       
       setTimeout(() => {
           reminderModal.style.opacity = "1";
           reminderModal.querySelector(".reminder-content").style.transform = "translateY(0)";
       }, 10);
       
       const okBtn = reminderModal.querySelector(".reminder-ok-btn");
       okBtn.addEventListener("mouseover", function() {
           this.style.backgroundColor = "#0d2c6e";
       });
       okBtn.addEventListener("mouseout", function() {
           this.style.backgroundColor = "#2c5282";
       });
       
       const closeReminderAndNavigate = () => {
           reminderModal.style.opacity = "0";
           reminderModal.querySelector(".reminder-content").style.transform = "translateY(20px)";
           setTimeout(() => {
               if (reminderModal.parentNode) {
                   reminderModal.remove();
               }
               window.open(navigationUrl, '_blank');
           }, 300);
       };
       
       okBtn.addEventListener("click", closeReminderAndNavigate);
   };
   
   const handleNavigation = async (button, appType) => {
       const spinner = button.querySelector('.location-spinner');
       const btnText = button.querySelector('.btn-text');
       
       spinner.style.display = 'inline-block';
       button.style.opacity = '0.8';
       button.style.cursor = 'wait';
       btnText.textContent = 'Getting location...';
       
       await getUserLocation();
       
       let navigationUrl;
       if (appType === 'google') {
           if (userLat && userLng) {
               navigationUrl = `https://www.google.com/maps/dir/${userLat},${userLng}/${destinationLat},${destinationLng}`;
           } else {
               navigationUrl = `https://www.google.com/maps/dir/?api=1&destination=${destinationLat},${destinationLng}`;
           }
       } else if (appType === 'waze') {
           if (userLat && userLng) {
               navigationUrl = `https://www.waze.com/ul?ll=${destinationLat}%2C${destinationLng}&navigate=yes&from=${userLat}%2C${userLng}`;
           } else {
               navigationUrl = `https://www.waze.com/ul?ll=${destinationLat}%2C${destinationLng}&navigate=yes`;
           }
       } else if (appType === 'apple') {
           const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
           if (!isIOS) {
               closeModal();
               showPopup('Info', 'Apple Maps is only available on iOS devices');
               return;
           }
           if (userLat && userLng) {
               navigationUrl = `maps://maps.apple.com/?saddr=${userLat},${userLng}&daddr=${destinationLat},${destinationLng}`;
           } else {
               navigationUrl = `maps://maps.apple.com/?daddr=${destinationLat},${destinationLng}`;
           }
       }
       
       closeModal();
       showReminderModal(navigationUrl);
   };
   
   const googleMapsBtn = modal.querySelector('.google-maps');
   const wazeBtn = modal.querySelector('.waze');
   const appleMapsBtn = modal.querySelector('.apple-maps');
   const cancelBtn = modal.querySelector('.cancel');
   
   getUserLocation();
   
   googleMapsBtn.addEventListener('mouseover', function() {
       if (this.style.cursor !== 'wait') {
           this.style.backgroundColor = '#3367D6';
           this.style.transform = 'translateY(-1px)';
       }
   });
   googleMapsBtn.addEventListener('mouseout', function() {
       if (this.style.cursor !== 'wait') {
           this.style.backgroundColor = '#4285F4';
           this.style.transform = 'translateY(0)';
       }
   });
   googleMapsBtn.addEventListener('click', () => handleNavigation(googleMapsBtn, 'google'));
   
   wazeBtn.addEventListener('mouseover', function() {
       if (this.style.cursor !== 'wait') {
           this.style.backgroundColor = '#00B8E6';
           this.style.transform = 'translateY(-1px)';
       }
   });
   wazeBtn.addEventListener('mouseout', function() {
       if (this.style.cursor !== 'wait') {
           this.style.backgroundColor = '#00D4FF';
           this.style.transform = 'translateY(0)';
       }
   });
   wazeBtn.addEventListener('click', () => handleNavigation(wazeBtn, 'waze'));
   
   appleMapsBtn.addEventListener('mouseover', function() {
       if (this.style.cursor !== 'wait') {
           this.style.backgroundColor = '#0056CC';
           this.style.transform = 'translateY(-1px)';
       }
   });
   appleMapsBtn.addEventListener('mouseout', function() {
       if (this.style.cursor !== 'wait') {
           this.style.backgroundColor = '#007AFF';
           this.style.transform = 'translateY(0)';
       }
   });
   appleMapsBtn.addEventListener('click', () => handleNavigation(appleMapsBtn, 'apple'));
   
   cancelBtn.addEventListener('mouseover', function() {
       this.style.backgroundColor = '#f5f5f5';
       this.style.borderColor = '#bbb';
   });
   cancelBtn.addEventListener('mouseout', function() {
       this.style.backgroundColor = 'white';
       this.style.borderColor = '#ddd';
   });
   cancelBtn.addEventListener('click', closeModal);
   
   modal.addEventListener('click', (e) => {
       if (e.target === modal) {
           closeModal();
       }
   });
}

function loadAllLocations() {
    if (!gameLocations || !Array.isArray(gameLocations) || gameLocations.length === 0) {
        console.error("No locations available to load");
        showPopup("Error", "No locations available. Please try reloading the page.");
        return;
    }
    
    createMarkersOnly();
    updateDistanceBox();
    resetInactivityTimer();
}

let visibilityTimeout;
document.addEventListener('visibilitychange', function() {
    if (!document.hidden) {
        if (visibilityTimeout) {
            clearTimeout(visibilityTimeout);
        }
        
        visibilityTimeout = setTimeout(() => {
            recenterOnUser();
            if (markerClusterGroup && markerClusterGroup.getLayers().length === 0) {
                createMarkersOnly();
            }
        }, 300);
    }
});

window.addEventListener('focus', function() {
    recenterOnUser();
});

function recenterMapAndClosePopups() {
    closeAllPopups();
    recenterOnUser();
}

function returnToIndex() {
   const distanceBox = document.querySelector('#distanceBox'); 
   if (distanceBox) {
       distanceBox.style.display = 'none';
   }
   
   const popupDiv = document.createElement("div");
   popupDiv.style.cssText = `
       position: fixed;
       top: 0;
       left: 0;
       width: 100%;
       height: 100%;
       background-color: rgba(0,0,0,0.6);
       backdrop-filter: blur(4px);
       display: flex;
       justify-content: center;
       align-items: center;
       z-index: 1000;
       opacity: 0;
       transition: opacity 0.3s ease;
   `;
   
   const darkBlue = "var(--dark-blue)";
   const darkBlueHover = "var(--dark-blue-hover)";
   
   popupDiv.innerHTML = `
       <div class="modal-container" style="
       background-color: white;
       border-radius: 16px;
       padding: 28px;
       width: 90%;
       max-width: 420px;
       max-height: 90vh;
       box-shadow: 0 15px 40px rgba(0,0,0,0.2);
       margin: auto;
       transform: translateY(20px);
       transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
       overflow: hidden;
       display: flex;
       flex-direction: column;
       ">
       <div style="
           text-align: center;
           margin-bottom: 25px;
       ">
                           <svg width="50" height="50" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
           <circle cx="12" cy="12" r="10" stroke="${darkBlue}" stroke-width="1.5"/>
           <path d="M12 8V13" stroke="${darkBlue}" stroke-width="2" stroke-linecap="round"/>
           <circle cx="12" cy="16" r="1" fill="${darkBlue}"/>
           </svg>
       </div>
       <h3 style="
           text-align: center;
           margin: 0 0 15px 0;
           color: #2c3e50;
           font-size: 1.5rem;
           font-weight: 600;
       ">Ready to Leave?</h3>
       <div style="flex-grow: 1; overflow-y: auto; padding: 0 10px;">
           <p style="
           text-align: center;
           margin: 0 0 30px 0;
           color: #5c6c7c;
           line-height: 1.5;
           font-size: 1rem;
           ">Are you sure you want to return to the main page?</p>
       </div>
       <div style="
           display: flex;
           justify-content: center;
           gap: 15px;
           margin-bottom: 15px;
       ">
           <button class="confirm-btn" style="
           padding: 14px 24px;
           background-color: ${darkBlue};
           color: white;
           border: none;
           border-radius: 10px;
           cursor: pointer;
           font-size: 1rem;
           font-weight: 600;
           min-width: 130px;
           transition: all 0.2s ease;
           ">Yes, Exit</button>
           <button class="cancel-btn" style="
           padding: 14px 24px;
           background-color: transparent;
           color: ${darkBlue};
           border: 1.5px solid ${darkBlue};
           border-radius: 10px;
           cursor: pointer;
           font-size: 1rem;
           font-weight: 600;
           min-width: 130px;
           transition: all 0.2s ease;
           ">Stay Here</button>
       </div>
       <div style="text-align: center; margin-top: 15px;">
           <a href="#" class="credits-link" style="
           display: inline-block;
           text-align: center;
           color: #64748b;
           text-decoration: none;
           font-size: 0.9rem;
           padding: 8px 20px;
           border-radius: 100px;
           border: 1px solid rgba(100, 116, 139, 0.2);
           background-color: rgba(100, 116, 139, 0.05);
           transition: all 0.2s ease;
           ">View Acknowledgements</a>
       </div>
       </div>
   `;
   
   document.body.appendChild(popupDiv);
   
   setTimeout(() => {
       popupDiv.style.opacity = "1";
       popupDiv.querySelector(".modal-container").style.transform = "translateY(0)";
   }, 10);
   
   const confirmBtn = popupDiv.querySelector(".confirm-btn");
   confirmBtn.addEventListener("mouseover", function() {
       this.style.backgroundColor = darkBlueHover;
   });
   confirmBtn.addEventListener("mouseout", function() {
       this.style.backgroundColor = darkBlue;
   });
   
   const cancelBtn = popupDiv.querySelector(".cancel-btn");
   cancelBtn.addEventListener("mouseover", function() {
       this.style.backgroundColor = "rgba(26, 58, 138, 0.05)";
   });
   cancelBtn.addEventListener("mouseout", function() {
       this.style.backgroundColor = "transparent";
   });
   
   const creditsLink = popupDiv.querySelector(".credits-link");
   creditsLink.addEventListener("mouseover", function() {
       this.style.backgroundColor = "rgba(100, 116, 139, 0.1)";
       this.style.borderColor = "rgba(100, 116, 139, 0.3)";
   });
   creditsLink.addEventListener("mouseout", function() {
       this.style.backgroundColor = "rgba(100, 116, 139, 0.05)";
       this.style.borderColor = "rgba(100, 116, 139, 0.2)";
   });
   
   confirmBtn.addEventListener("click", function() {
       popupDiv.style.opacity = "0";
       popupDiv.querySelector(".modal-container").style.transform = "translateY(20px)";
       setTimeout(() => {
           document.body.removeChild(popupDiv);
           window.location.href = "/index.html";
       }, 300);
   });
   
   cancelBtn.addEventListener("click", function() {
       popupDiv.style.opacity = "0";
       popupDiv.querySelector(".modal-container").style.transform = "translateY(20px)";
       setTimeout(() => {
           document.body.removeChild(popupDiv);
           if (distanceBox) {
               distanceBox.style.display = 'block';
           }
       }, 300);
   });
   
   creditsLink.addEventListener("click", function(e) {
       e.preventDefault();
       
       const creditsPopup = document.createElement("div");
       creditsPopup.style.cssText = `
           position: fixed;
           top: 0;
           left: 0;
           width: 100%;
           height: 100%;
           background-color: rgba(0,0,0,0.7);
           backdrop-filter: blur(6px);
           display: flex;
           justify-content: center;
           align-items: center;
           z-index: 1001;
           opacity: 0;
           transition: opacity 0.3s ease;
       `;
       
       creditsPopup.innerHTML = `
           <div class="credits-container" style="
               background-color: white;
               border-radius: 16px;
               width: 92%;
               max-width: 450px;
               max-height: 80vh;
               box-shadow: 0 20px 50px rgba(0,0,0,0.25);
               margin: auto;
               transform: translateY(20px);
               transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
               overflow: hidden;
               display: flex;
               flex-direction: column;
           ">
               <div style="
                   background-color: ${darkBlue};
                   padding: 20px;
                   color: white;
                   text-align: center;
               ">
                   <h3 style="margin: 0; font-size: 1.5rem; font-weight: 600;">Acknowledgements</h3>
               </div>
               <div style="
                   padding: 20px;
                   flex-grow: 1;
                   overflow-y: auto;
               ">
                   <ul style="list-style-type: none; padding: 0; margin: 0;">
                       <li style="margin-bottom: 20px;">
                           <strong style="color: #1e293b; font-size: 1.05rem;">OpenStreetMap</strong>
                           <p style="color: #64748b; margin: 5px 0 0 0; font-size: 0.9rem; line-height: 1.5;">
                               Providing the map data and tiles for this interactive experience.
                           </p>
                       </li>
                       <li style="margin-bottom: 20px;">
                           <strong style="color: #1e293b; font-size: 1.05rem;">Minnesota Historical Society</strong>
                           <p style="color: #64748b; margin: 5px 0 0 0; font-size: 0.9rem; line-height: 1.5;">
                               For their invaluable historical data, photographs, and archive materials.
                           </p>
                       </li>
                       <li style="margin-bottom: 20px;">
                           <strong style="color: #1e293b; font-size: 1.05rem;">Metropolitan State University</strong>
                           <p style="color: #64748b; margin: 5px 0 0 0; font-size: 0.9rem; line-height: 1.5;">
                               For fostering a passion for history and research methodology.
                           </p>
                       </li>
                       <li style="margin-bottom: 20px;">
                           <strong style="color: #1e293b; font-size: 1.05rem;">Leaflet.js</strong>
                           <p style="color: #64748b; margin: 5px 0 0 0; font-size: 0.9rem; line-height: 1.5;">
                               The open-source JavaScript library that powers the mapping features.
                           </p>
                       </li>
                       <li>
                           <strong style="color: #1e293b; font-size: 1.05rem;">All Contributors</strong>
                           <p style="color: #64748b; margin: 5px 0 0 0; font-size: 0.9rem; line-height: 1.5;">
                               Researchers, testers, and developers who made this project possible.
                           </p>
                       </li>
                   </ul>
               </div>
               <div style="padding: 15px; text-align: center; border-top: 1px solid #eee;">
                   <button class="close-credits-btn" style="
                       padding: 12px 30px;
                       background-color: ${darkBlue};
                       color: white;
                       border: none;
                       border-radius: 10px;
                       cursor: pointer;
                       font-size: 0.95rem;
                       font-weight: 600;
                       transition: background-color 0.2s ease;
                   ">Close</button>
               </div>
           </div>
       `;
       
       document.body.appendChild(creditsPopup);
       
       setTimeout(() => {
           creditsPopup.style.opacity = "1";
           creditsPopup.querySelector(".credits-container").style.transform = "translateY(0)";
       }, 10);
       
       const closeBtn = creditsPopup.querySelector(".close-credits-btn");
       closeBtn.addEventListener("mouseover", function() {
           this.style.backgroundColor = darkBlueHover;
       });
       closeBtn.addEventListener("mouseout", function() {
           this.style.backgroundColor = darkBlue;
       });
       closeBtn.addEventListener("click", function() {
           creditsPopup.style.opacity = "0";
           creditsPopup.querySelector(".credits-container").style.transform = "translateY(20px)";
           setTimeout(() => {
               document.body.removeChild(creditsPopup);
           }, 300);
       });
       
       creditsPopup.addEventListener("click", function(e) {
           if (e.target === creditsPopup) {
               creditsPopup.style.opacity = "0";
               creditsPopup.querySelector(".credits-container").style.transform = "translateY(20px)";
               setTimeout(() => {
                   document.body.removeChild(creditsPopup);
               }, 300);
           }
       });
   });
   
   popupDiv.addEventListener("click", function(e) {
       if (e.target === popupDiv) {
           popupDiv.style.opacity = "0";
           popupDiv.querySelector(".modal-container").style.transform = "translateY(20px)";
           setTimeout(() => {
               document.body.removeChild(popupDiv);
               if (distanceBox) {
                   distanceBox.style.display = 'block';
               }
           }, 300);
       }
   });
}

function isSignificantMovement(newPosition) {
    if (!lastPositionForJitter) {
        lastPositionForJitter = newPosition;
        lastSignificantMovement = Date.now();
        return true;
    }
    
    const distance = calculateDistance(lastPositionForJitter, newPosition);
    const timeSinceLastMovement = Date.now() - lastSignificantMovement;
    
    if (distance > CONFIG.JITTER_THRESHOLD && timeSinceLastMovement > CONFIG.SIGNIFICANT_MOVEMENT_COOLDOWN) {
        lastPositionForJitter = newPosition;
        lastSignificantMovement = Date.now();
        return true;
    }
    
    return false;
}

function resetInactivityTimer(isExplicitInteraction = true) {
    if (inactivityTimer) {
        clearTimeout(inactivityTimer);
        inactivityTimer = null;
    }
    
    inactivityTimer = setTimeout(() => {
        map.closePopup();
        if (!isMapInteracting && userMarker) {
            followUser = true;
            
            const userPos = userMarker.getLatLng();
            if (userPos && userPos.lat && userPos.lng) {
                map.flyTo(userPos, map.getZoom(), {
                    animate: true,
                    duration: 1.0,
                    easeLinearity: 0.25
                });
            }
        }
    }, CONFIG.INACTIVITY_TIMEOUT);
    
    if (isExplicitInteraction) {
        isMapInteracting = false;
    }
}

function optimizeImages() {
    // Use more specific selector and batch DOM operations
    const images = document.querySelectorAll('img:not([loading]):not([data-optimized])');
    
    if (images.length === 0) return; // Early exit if no images to optimize
    
    // Use requestAnimationFrame to avoid blocking the main thread
    requestAnimationFrame(() => {
        const fragment = document.createDocumentFragment();
        
        images.forEach(img => {
            // Add lazy loading
            img.loading = 'lazy';
            
            // Mark as optimized to avoid reprocessing
            img.setAttribute('data-optimized', 'true');
            
            // Set dimensions if not already set
            if (img.src && !img.width && !img.height) {
                // Use more efficient event handling
                const handleLoad = () => {
                    img.setAttribute('width', img.naturalWidth);
                    img.setAttribute('height', img.naturalHeight);
                    img.removeEventListener('load', handleLoad); // Clean up
                };
                
                img.addEventListener('load', handleLoad, { once: true });
                
                // Handle already loaded images
                if (img.complete && img.naturalWidth > 0) {
                    handleLoad();
                }
            }
        });
    });
}

function setupEventListeners() {
    // Enhanced state management with anti-jumping controls
    const interactionState = {
        followUser: true,
        isMapInteracting: false,
        inactivityTimer: null,
        touch: {
            startTime: 0,
            startPos: null,
            isMoving: false,
            isPinching: false,
            initialPinchDistance: 0,
            initialZoom: 0,
            // Anti-jumping additions
            lastUpdateTime: 0,
            velocityBuffer: [],
            smoothedPosition: null,
            jumpThreshold: 50 // pixels - sudden movement detection
        }
    };

    // Anti-jumping configuration
    const ANTI_JUMP_CONFIG = {
        MIN_DRAG_DISTANCE: 12,
        MAX_VELOCITY: 2000,        // pixels/second - filters impossible speeds
        VELOCITY_SAMPLES: 3,       // Number of velocity readings to average
        UPDATE_THROTTLE: 16,       // ~60fps max updates
        COORDINATE_SMOOTHING: 0.7, // Smoothing factor (0.5-0.9)
        PINCH_DEADZONE: 5,         // Minimum pinch distance change
        MOMENTUM_DECAY: 0.8        // iOS momentum scrolling decay
    };

    // Enhanced velocity and position tracking
    const trackTouchVelocity = (currentPos, timestamp) => {
        const state = interactionState.touch;
        
        if (state.smoothedPosition && timestamp > state.lastUpdateTime) {
            const deltaTime = timestamp - state.lastUpdateTime;
            const deltaX = currentPos.x - state.smoothedPosition.x;
            const deltaY = currentPos.y - state.smoothedPosition.y;
            const velocity = Math.sqrt(deltaX * deltaX + deltaY * deltaY) / deltaTime * 1000;
            
            // Add to velocity buffer
            state.velocityBuffer.push(velocity);
            if (state.velocityBuffer.length > ANTI_JUMP_CONFIG.VELOCITY_SAMPLES) {
                state.velocityBuffer.shift();
            }
            
            // Calculate average velocity
            const avgVelocity = state.velocityBuffer.reduce((a, b) => a + b, 0) / state.velocityBuffer.length;
            
            // Reject impossible velocities (likely GPS jumps)
            if (avgVelocity > ANTI_JUMP_CONFIG.MAX_VELOCITY) {
                console.debug('High velocity detected, smoothing movement:', avgVelocity);
                return false; // Don't update position
            }
        }
        
        // Apply coordinate smoothing
        if (state.smoothedPosition) {
            const smoothing = ANTI_JUMP_CONFIG.COORDINATE_SMOOTHING;
            state.smoothedPosition = {
                x: state.smoothedPosition.x * smoothing + currentPos.x * (1 - smoothing),
                y: state.smoothedPosition.y * smoothing + currentPos.y * (1 - smoothing)
            };
        } else {
            state.smoothedPosition = { ...currentPos };
        }
        
        state.lastUpdateTime = timestamp;
        return true;
    };

    // Consolidated interaction handlers (unchanged functionality)
    const handleInteractionStart = (source) => {
        interactionState.followUser = false;
        interactionState.isMapInteracting = true;
        
        if (interactionState.inactivityTimer) {
            clearTimeout(interactionState.inactivityTimer);
            interactionState.inactivityTimer = null;
        }
        
        // Update global state (preserving existing behavior)
        followUser = false;
        isMapInteracting = true;
        
        console.debug(`Interaction started: ${source}`);
    };

    const handleInteractionEnd = (source) => {
        interactionState.isMapInteracting = false;
        isMapInteracting = false;
        
        // Reset anti-jumping state
        interactionState.touch.velocityBuffer = [];
        interactionState.touch.smoothedPosition = null;
        
        resetInactivityTimer();
        console.debug(`Interaction ended: ${source}`);
    };

    // Map events (unchanged)
    const setupMapEvents = () => {
        if (!map) {
            console.error('Map not available for event setup');
            return;
        }

        try {
            map.on('dragstart', () => handleInteractionStart('drag'));
            map.on('dragend', () => handleInteractionEnd('drag'));
            map.on('zoomstart', () => handleInteractionStart('zoom'));
            map.on('zoomend', () => handleInteractionEnd('zoom'));
        } catch (error) {
            console.error('Error setting up map events:', error);
        }
    };

    // Enhanced touch events with maximum anti-jumping
    const setupTouchEvents = () => {
        let updateThrottle = null;

        const touchHandlers = {
            start: (e) => {
                try {
                    if (!e.touches || e.touches.length === 0) return;

                    const now = Date.now();
                    const touch = e.touches[0];
                    
                    if (e.touches.length === 1) {
                        // Single touch - reset anti-jumping state
                        interactionState.touch.startTime = now;
                        interactionState.touch.startPos = {
                            x: touch.clientX,
                            y: touch.clientY
                        };
                        interactionState.touch.isMoving = false;
                        interactionState.touch.velocityBuffer = [];
                        interactionState.touch.smoothedPosition = {
                            x: touch.clientX,
                            y: touch.clientY
                        };
                        interactionState.touch.lastUpdateTime = now;
                    } else if (e.touches.length === 2) {
                        // Pinch start
                        interactionState.touch.isPinching = true;
                        handleInteractionStart('pinch');
                        
                        const touch1 = e.touches[0];
                        const touch2 = e.touches[1];
                        
                        interactionState.touch.initialPinchDistance = Math.hypot(
                            touch2.clientX - touch1.clientX,
                            touch2.clientY - touch1.clientY
                        );
                        
                        if (map) {
                            interactionState.touch.initialZoom = map.getZoom();
                        }
                        
                        e.preventDefault();
                    }
                } catch (error) {
                    console.error('Touch start error:', error);
                }
            },

            move: (e) => {
                try {
                    if (!e.touches || e.touches.length === 0) return;

                    const now = Date.now();
                    
                    // Throttle updates to prevent overwhelming the system
                    if (updateThrottle && now - updateThrottle < ANTI_JUMP_CONFIG.UPDATE_THROTTLE) {
                        return;
                    }
                    updateThrottle = now;

                    if (e.touches.length === 1 && interactionState.touch.startPos) {
                        // Single touch move with anti-jumping
                        const touch = e.touches[0];
                        const currentPos = {
                            x: touch.clientX,
                            y: touch.clientY
                        };
                        
                        // Track velocity and smooth position
                        const validMovement = trackTouchVelocity(currentPos, now);
                        if (!validMovement) return;

                        // Use smoothed position for distance calculation
                        const smoothedPos = interactionState.touch.smoothedPosition;
                        const dx = smoothedPos.x - interactionState.touch.startPos.x;
                        const dy = smoothedPos.y - interactionState.touch.startPos.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        // Check for sudden jumps
                        const rawDx = currentPos.x - interactionState.touch.startPos.x;
                        const rawDy = currentPos.y - interactionState.touch.startPos.y;
                        const rawDistance = Math.sqrt(rawDx * rawDx + rawDy * rawDy);
                        
                        if (rawDistance > interactionState.touch.jumpThreshold && distance < ANTI_JUMP_CONFIG.MIN_DRAG_DISTANCE) {
                            console.debug('Touch jump detected and filtered');
                            return;
                        }
                        
                        if (distance > ANTI_JUMP_CONFIG.MIN_DRAG_DISTANCE && !interactionState.touch.isMoving) {
                            interactionState.touch.isMoving = true;
                            handleInteractionStart('touch-drag');
                        }
                    } else if (e.touches.length === 2 && interactionState.touch.isPinching) {
                        // Enhanced pinch zoom with deadzone
                        const touch1 = e.touches[0];
                        const touch2 = e.touches[1];
                        
                        const currentPinchDistance = Math.hypot(
                            touch2.clientX - touch1.clientX,
                            touch2.clientY - touch1.clientY
                        );
                        
                        // Apply deadzone to prevent micro-adjustments
                        const distanceChange = Math.abs(currentPinchDistance - interactionState.touch.initialPinchDistance);
                        if (distanceChange < ANTI_JUMP_CONFIG.PINCH_DEADZONE) {
                            return;
                        }
                        
                        if (map && interactionState.touch.initialPinchDistance > 0) {
                            const pinchRatio = currentPinchDistance / interactionState.touch.initialPinchDistance;
                            
                            // Limit pinch sensitivity to prevent jumping
                            const cappedRatio = Math.max(0.5, Math.min(2.0, pinchRatio));
                            const zoomDelta = Math.log2(cappedRatio) * 1.5; // Reduced from 2 for smoother zoom
                            const newZoom = Math.max(7, Math.min(18, interactionState.touch.initialZoom + zoomDelta));
                            
                            // Calculate center with bounds checking
                            const centerX = Math.max(0, Math.min(window.innerWidth, (touch1.clientX + touch2.clientX) / 2));
                            const centerY = Math.max(0, Math.min(window.innerHeight, (touch1.clientY + touch2.clientY) / 2));
                            const centerPoint = L.point(centerX, centerY);
                            
                            try {
                                const centerLatLng = map.containerPointToLatLng(centerPoint);
                                map.setView(centerLatLng, newZoom, { animate: false });
                            } catch (mapError) {
                                console.debug('Map view update filtered due to invalid coordinates');
                            }
                        }
                        
                        e.preventDefault();
                    }
                } catch (error) {
                    console.error('Touch move error:', error);
                }
            },

            end: (e) => {
                try {
                    const touchEndTime = Date.now();
                    const touchDuration = touchEndTime - interactionState.touch.startTime;
                    
                    if (interactionState.touch.isPinching) {
                        interactionState.touch.isPinching = false;
                        handleInteractionEnd('pinch');
                        
                        if (e.touches.length < 2) {
                            e.preventDefault();
                        }
                    } else if (interactionState.touch.startPos) {
                        // Apply momentum decay for iOS
                        if (ANTI_JUMP_CONFIG.MOMENTUM_DECAY < 1 && interactionState.touch.isMoving) {
                            setTimeout(() => {
                                if (interactionState.isMapInteracting) {
                                    handleInteractionEnd('touch-momentum');
                                }
                            }, 100);
                        }
                        
                        if (touchDuration >= 300 || interactionState.touch.isMoving) {
                            handleInteractionEnd('touch-drag');
                        }
                    }
                    
                    // Complete state reset
                    interactionState.touch.startPos = null;
                    interactionState.touch.isMoving = false;
                    interactionState.touch.velocityBuffer = [];
                    interactionState.touch.smoothedPosition = null;
                    updateThrottle = null;
                } catch (error) {
                    console.error('Touch end error:', error);
                }
            }
        };

        // Add listeners with enhanced error handling
        try {
            document.addEventListener('touchstart', touchHandlers.start, { passive: false });
            document.addEventListener('touchmove', touchHandlers.move, { passive: false });
            document.addEventListener('touchend', touchHandlers.end, { passive: false });
            
            // Additional jump prevention for problematic devices
            document.addEventListener('touchcancel', touchHandlers.end, { passive: false });
        } catch (error) {
            console.error('Error setting up touch events:', error);
        }
    };

    // All other functions remain exactly the same...
    const setupButtonEvents = () => {
        const buttonConfigs = [
            { id: 'recenterButton', handler: recenterMap, required: true },
            { id: 'returnButton', handler: returnToIndex, required: true },
            { id: 'tipsButton', handler: showNavigationTips, required: false }
        ];

        buttonConfigs.forEach(config => {
            try {
                const element = document.getElementById(config.id);
                if (element) {
                    element.addEventListener('click', config.handler);
                    console.debug(`${config.id} event listener attached`);
                } else if (config.required) {
                    console.error(`Required button element not found: ${config.id}`);
                } else {
                    console.warn(`Optional button element not found: ${config.id}`);
                }
            } catch (error) {
                console.error(`Error setting up ${config.id} event:`, error);
            }
        });
    };

    const setupAccessibilityEvents = () => {
        try {
            const contrastToggle = cachedElements?.contrastToggle;
            if (contrastToggle && typeof toggleHighContrast === 'function') {
                contrastToggle.addEventListener('click', toggleHighContrast);
                
                if (typeof accessibilityState !== 'undefined' && accessibilityState.highContrast) {
                    document.body.classList.add('high-contrast');
                }
                
                console.debug('Accessibility events setup complete');
            } else {
                console.warn('Contrast toggle or handler not available');
            }
        } catch (error) {
            console.error('Error setting up accessibility events:', error);
        }
    };

    const setupSystemEvents = () => {
        try {
            document.addEventListener('visibilitychange', () => {
                try {
                    if (typeof handleVisibilityChange === 'function') {
                        handleVisibilityChange();
                    }
                } catch (error) {
                    console.error('Visibility change handler error:', error);
                }
            });

            let resizeTimeout;
            window.addEventListener('resize', () => {
                try {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => {
                        if (map) {
                            map.invalidateSize();
                        }
                        if (typeof updateDistanceBox === 'function') {
                            updateDistanceBox();
                        }
                    }, 250);
                } catch (error) {
                    console.error('Resize handler error:', error);
                }
            });

            console.debug('System events setup complete');
        } catch (error) {
            console.error('Error setting up system events:', error);
        }
    };

    // Initialize all event listeners
    try {
        setupMapEvents();
        setupTouchEvents();
        setupButtonEvents();
        setupAccessibilityEvents();
        setupSystemEvents();
        
        console.log('All event listeners setup complete with anti-jumping protection');
    } catch (error) {
        console.error('Critical error in setupEventListeners:', error);
    }
}

// Rest of the code remains identical...
document.addEventListener('DOMContentLoaded', () => {
    console.log('DOM loaded, initializing application...');
    
    const initSteps = [
        { name: 'Cache Elements', fn: () => cacheElements() },
        { name: 'Initialize Map', fn: () => initMap() },
        { name: 'Setup Event Listeners', fn: () => setupEventListeners() },
        { name: 'Optimize Images', fn: () => optimizeImages() },
        { name: 'Initialize UI', fn: () => initializeUI() }
    ];

    let successCount = 0;
    
    initSteps.forEach((step, index) => {
        try {
            if (typeof step.fn === 'function') {
                step.fn();
                successCount++;
                console.debug(`✓ ${step.name} completed`);
            } else {
                console.warn(`⚠ ${step.name} function not available`);
            }
        } catch (error) {
            console.error(`✗ ${step.name} failed:`, error);
        }
    });

    console.log(`Application initialization: ${successCount}/${initSteps.length} steps completed`);
});

function initializeUI() {
    try {
        const additionalInfoContainer = cachedElements?.additionalInfoContainer;
        if (additionalInfoContainer) {
            additionalInfoContainer.style.display = 'none';
        }
        
        const lochuntContainer = cachedElements?.lochuntContainer;
        if (lochuntContainer) {
            lochuntContainer.style.display = 'none';
        }

        console.debug('UI initialization complete');
    } catch (error) {
        console.error('UI initialization error:', error);
    }
}
    </script>
</body>
</html>
