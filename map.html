<!DOCTYPE html>
<html>
<head>
  <title>Minnesota Then</title>
  <link rel="shortcut icon" type="image/jpg" href="/images/mnthenfav.ico" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta charset="UTF-8">
  <meta name="description" content="An interactive map for Minnesota history tours">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.markercluster/1.5.1/MarkerCluster.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.markercluster/1.5.1/MarkerCluster.Default.css" />
  <link rel="stylesheet" type="text/css" href="/css/map.css">
  <style>
      /* Add more styles for other tour types as needed */
.blue-marker {
  background-color: blue;
  /* Add other marker styling here */
}

.orange-marker {
  background-color: orange;
  /* Add other marker styling here */
}

.green-marker {
  background-color: green;
  /* Add other marker styling here */
}

.split-marker {
    background: linear-gradient(90deg, orange 50%, green 50%);
}

.purple-marker {
  background-color: purple;
  /* Add other marker styling here */
}

.burgundy-marker {
  background-color: #800000;
  /* Add other marker styling here */
}

.charcoal-marker {
  background-color: #34495E;
  /* Add other marker styling here */
}

.teal-marker {
  background-color: teal;
  /* Add other marker styling here */
}

.custom-marker-icon {
  border-radius: 50%;
  border: 4px solid #ffffff; /* White border */
  width: 8px;
  height: 8px;
  box-shadow: 0 0 10px rgba(0, 0, 0, 1); /* Add a shadow, adjust values as needed */
      z-index: 1000;
}

body {
    user-select: none;       /* standard syntax */
    -webkit-user-select: none; /* Safari 3.1+ */
    -moz-user-select: none;    /* Firefox 2+ */
    -ms-user-select: none;     /* IE 10+ */
}


/* Your custom styles */
#recenter-button {
    position: absolute;
    bottom: 10px;
    left: 10px;
    background-color: white;
    padding: 5px;
    border-radius: 50%;
    cursor: pointer;
    box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
    transition: transform 0.1s;  /* Smooth out the transition */
}

#recenter-icon {
    font-size: 29px;
}

@keyframes bounce {
    0%, 20%, 50%, 80%, 100% {
        transform: translateY(0);
    }
    40% {
        transform: translateY(-5px);
    }
    60% {
        transform: translateY(-3px);
    }
}

#recenter-button:active {
    animation: bounce 0.5s;
}


#location-popup {
  position: absolute;
  top: 40%;
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: #ffffff;
  border: 1px solid #ccc;
  padding: 20px;
  border-radius: 12px;
  box-shadow: 0px 0px 12px rgba(0, 0, 0, 0.35);
  z-index: 1000;
  font-size: 20px;
  text-align: center; /* Center-align the text */
}

.exit-button {
  border-radius: 10px; /* Rounded corners */
  font-size: 22px;
  min-width: 120px; /* Adjust the minimum width as needed */
  padding: 10px 20px; /* Add padding to the top and bottom, and left and right */
}

.info-box {
  border-radius: 10px; /* Rounded corners */
}

  #distanceBox.within-threshold {
    border-color: #00ff00;
  }
  
  #help-button {
    position: absolute;
    bottom: 10px;
    right: 10px;
    background-color: white;
    padding: 5px;
    border-radius: 50%;
    cursor: pointer;
    box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
    transition: transform 0.1s;
}

#help-icon {
    font-size: 29px;
}

#explanation-popup {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
      transition: transform 0.3s ease-out; 
    background-color: white;
    padding: 10px;
    box-shadow: 0 0 20px rgba(0, 0, 0, 0.4);
    z-index: 10000;  /* Ensure it's on top */
    width: 90%;      /* Adjust as needed */
      border-radius: 10px; /* Rounded corners */
          text-align: center; /* This will center the button horizontally */
}

#explanation-popup p {
    text-align: left; /* This will left-justify only the paragraphs inside the popup */
    margin: 0 auto; /* This ensures that the paragraph is centered but its content is left-justified */
    max-width: 90%; /* This sets a maximum width to the paragraph, adjust as needed */
    font-size: 20px;
}

.hidden {
    display: none;
}

#close-popup {
    font-size: 20px;    /* Adjust to the size you want */
    padding: 10px 20px; /* Gives the button some space and makes it look bigger */
    margin-top: 20px;   /* Provides some space between the button and the content above it */
    cursor: pointer;    /* Makes it clear that it's clickable */
    border: 1px solid #ccc;  /* Optional: Adds a border */
     border-radius: 10px; /* Rounded corners */
    background-color: #f5f5f5; /* Optional: Background color */
    transition: background-color 0.3s; /* Optional: Smooth transition effect for hover state */
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

#close-popup:hover {
    background-color: #e0e0e0; /* Optional: Changes the background color when hovered */
}

#explanation-popup button:focus {
    outline: none;
}

  </style>
 </head>
<body>
    <div id="map-container">
    <div id="map"></div>
    <div id="recenter-button" class="leaflet-bar leaflet-control leaflet-control-custom">
      <!-- Use the Font Awesome bullseye icon -->
      <i class="fas fa-crosshairs" id="recenter-icon"></i>
    </div>
        <div id="help-button" class="leaflet-bar leaflet-control leaflet-control-custom">
        <i class="fas fa-question-circle" id="help-icon"></i>
  </div>
  </div>
  
  <div id="distanceBox">Initializing ...</div>
  
  <div id="explanation-popup" class="hidden">
    <h3>App Features</h3>
    <p>&#8226; Pinch, zoom, and glide across the map to uncover hidden gems.</p>
    <p>&#8226; Different color markers denote which local tour(s) the location is part of.</p>
    <p>&#8226; Follow the map to get in range of the markers. The app with automatically open a location page to tell you about the history of the site. There's a cooldown mechanism to prevent too frequent redirects.</p>
    <p>&#8226; Open popups to read articles or get directions to any location you wish to visit - or simply learn more about.</p>
    <p>&#8226; Let the map re-align to your location, or tap the recenter button in the bottom-left corner.</p>
    <button id="close-popup">Close</button>
</div>

  <div class="container">
    <div class="row justify-content-center">
      <div class="col-10 col-md-8 col-lg-6">
        <div class="info-box-container">
          <div class="info-box">
            <strong>Navigation Tips:</strong> Move toward map markers. The app opens each site's history when youâ€™re in range. Exit below.
          </div>
 
          <!-- Exit Button -->
          <button class="exit-button btn btn-primary">Exit Map</button>
        </div>
      </div>
    </div>
  </div>

<script src="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.markercluster/1.5.1/leaflet.markercluster.js"></script>
<script src="./locations_1.js"></script> 

<script>

    // Initialize closestDistance with Infinity
    var closestDistance = Infinity;
    // Declare newMarkers at a higher scope
    var newMarkers = {};

// Define alpha-beta filter constants and variables
const alpha = 0.4;
const beta = 0.02;
var lastEstimatedPos = null;
var lastEstimatedVel = { lat: 0, lng: 0 };
    
document.addEventListener("DOMContentLoaded", function () {
    
    const distanceBox = document.getElementById("distanceBox");
    const locationPopup = document.createElement("div");
    locationPopup.id = "location-popup";
    locationPopup.innerHTML = "Searching for user location...";
    document.body.appendChild(locationPopup);

    const locationTimeout = setTimeout(() => {
        locationPopup.innerHTML = "Location not found. Please try again.";
    }, 10000);

    const INITIAL_DELAY = 2000; // 2 seconds
    const COOLDOWN = 25000; // 25 seconds
    const HIGH_ACCURACY_THRESHOLD = 1000; //Distance from marker map transitions to high accuracy
    const AUTO_CENTER_THRESHOLD = 25000;  // 25 seconds
    
    const thresholdFeet = 15; // 15 feet for triggering redirection based on proximity to a marker
    
    var lastTransitionTime = sessionStorage.getItem('lastTransitionTime');
    var lastVisitedLocation = sessionStorage.getItem('lastVisitedLocation');

    if (lastTransitionTime && Date.now() - lastTransitionTime < COOLDOWN) {
        console.log('Cooldown active');
    } else {
        console.log('No cooldown');
    }

    var map = L.map("map", {
        attributionControl: false,
        inertia: false,
    }).setView([45.09396938812941, -92.99743282865592], 20);

    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 20,
        id: "mapbox/streets-v11",
        tileSize: 512,
        zoomOffset: -1,
    }).addTo(map);

    L.control.attribution({ prefix: false }).addTo(map);

    var userLocationMarker = L.circleMarker([0, 0], {
        color: "red",
        fillColor: "#f03",
        fillOpacity: 0.5,
        radius: 6,
    }).addTo(map);

    var userInteracted = false;

    map.on("dragstart zoomstart", function() {
        userInteracted = true;
    });

    document.addEventListener("visibilitychange", function() {
        if (!document.hidden) {
            userInteracted = false;
        }
    });

    var markers = L.markerClusterGroup();
    map.addLayer(markers);

    markers.on("clusterclick", function (e) {
        var childMarkers = e.layer.getAllChildMarkers();
        if (childMarkers.length > 0) {
            childMarkers[0].openPopup();
        }
    });

function loadScriptWithCacheBust() {
    const cacheBust = Date.now();
    const script = document.createElement("script");

    script.src = `./locations_1.js?v=${cacheBust}`;

    script.onload = function() {
        if (Array.isArray(locations) && locations.length) {
            console.log("Location data loaded successfully:", locations);
            map.locate({ setView: false, maxZoom: 20 });
        } else {
            console.error("Location data is missing or empty:", locations);
        }
    };

    script.onerror = function() {
        console.error("Failed to load the script:", script.src);
    };

    document.body.appendChild(script);
}

loadScriptWithCacheBust();

var initialLocationSet = false;
var lastUserInteractionTime = 0;

// Detect when the user interacts with the map and update the timestamp
map.on("dragstart zoomstart", function() {
    lastUserInteractionTime = Date.now();
});

map.on("locationfound", function (e) {
    console.log("Location found:", e);
    clearTimeout(locationTimeout);
    locationPopup.innerHTML = "User location found.";
    setTimeout(() => {
        locationPopup.style.display = "none";
    }, 2000);

    if (!initialLocationSet) {
        map.setView(e.latlng, 20);
        initialLocationSet = true;
    } else {
        const timeSinceLastInteraction = Date.now() - lastUserInteractionTime;
        if (timeSinceLastInteraction > AUTO_CENTER_THRESHOLD) {
            map.setView(e.latlng, map.getZoom());
        }
    }
});

var currentMarkers = {};
var lastKnownLatLng = null;
var currentLatLng = null;
var closestLocation = null;

let useHighAccuracy = false; // Default to false

  function alphaBetaFilter(newMeasurement) {
        if (!lastEstimatedPos) {
            lastEstimatedPos = newMeasurement; // Initialize with the first measurement
            return lastEstimatedPos;
        }

        // Predict new position
        const predictedPos = {
            lat: lastEstimatedPos.lat + lastEstimatedVel.lat,
            lng: lastEstimatedPos.lng + lastEstimatedVel.lng
        };

        // Calculate the residual
        const residual = {
            lat: newMeasurement.lat - predictedPos.lat,
            lng: newMeasurement.lng - predictedPos.lng
        };

        // Update the estimate
        lastEstimatedPos.lat += alpha * residual.lat;
        lastEstimatedPos.lng += alpha * residual.lng;
        lastEstimatedVel.lat += beta * residual.lat;
        lastEstimatedVel.lng += beta * residual.lng;

        return lastEstimatedPos;
    }

    function updateUserLocation(e = null) {
    console.log('updateUserLocation called with', e);

    currentLatLng = e ? e.latlng : lastKnownLatLng; // Update the currentLatLng based on the event object or the last known location
    console.log('Set currentLatLng to:', currentLatLng);

    if (!currentLatLng) {
        return null; // Exit if no valid position is available
    }
    
        // Apply Alpha-Beta filter
        const smoothedLatLng = alphaBetaFilter(currentLatLng);
        console.log('Smoothed currentLatLng:', smoothedLatLng);

    lastKnownLatLng = currentLatLng;
    userLocationMarker.setLatLng(currentLatLng);
    if (!userInteracted) {
        map.setView(currentLatLng, map.getZoom());
    }

    // Initialize variables to keep track of the closest location
    let closestLocation = null;
    let closestDistance = Infinity;

    for (let i = 0; i < locations.length; i++) {
        const location = locations[i];
        const locationLatLng = L.latLng(location.lat, location.lng);
        const distance = currentLatLng.distanceTo(locationLatLng);
        const distanceFeet = Math.round(distance * 3.28084); // Convert meters to feet

        if (distanceFeet < closestDistance) {
            closestDistance = distanceFeet;
            closestLocation = location;
        }
    }

    // Update the distanceBox element
    const distanceBox = document.getElementById("distanceBox");
    distanceBox.innerHTML = "Closest Marker: " + closestDistance + " feet";

    // Check if closestDistance is within the threshold
        if (closestDistance <= thresholdFeet) {
          distanceBox.classList.add("within-threshold");

        if (
            (!lastTransitionTime || Date.now() - lastTransitionTime > COOLDOWN) &&
            (lastVisitedLocation === "-1" || closestLocation !== lastVisitedLocation)
        ) {
            console.log("Transition conditions met. Redirecting...");

            sessionStorage.setItem("lastTransitionTime", Date.now());
            sessionStorage.setItem("lastVisitedLocation", closestLocation);

            setTimeout(function () {
                window.location.href = closestLocation.htmlFile;
            }, INITIAL_DELAY);
        } else {
            console.log("Skipped transition block.");
        }
    }
    
     // Toggle high accuracy based on the distance to the closest marker
    if (closestDistance <= HIGH_ACCURACY_THRESHOLD && !useHighAccuracy) {
        // Enable high accuracy if the user is within 500 feet of a marker
        useHighAccuracy = true;
        // Restart location tracking with high accuracy
        map.stopLocate();
        map.locate({
            watch: true,
            enableHighAccuracy: useHighAccuracy,
            maximumAge: 25000,
        });
    } else if (closestDistance > HIGH_ACCURACY_THRESHOLD && useHighAccuracy) {
        // Disable high accuracy if the user is farther than 500 feet from a marker
        useHighAccuracy = false;
        // Restart location tracking without high accuracy
        map.stopLocate();
        map.locate({
            watch: true,
            enableHighAccuracy: useHighAccuracy,
            maximumAge: 25000,
        });
    }

    return currentLatLng;
}

// Update the distanceBox initially
distanceBox.innerHTML = "Initializing ...";

// Add the event listener for location found
map.on("locationfound", updateUserLocation);

for (let i = 0; i < locations.length; i++) {
    const location = locations[i];
    const locationLatLng = L.latLng(location.lat, location.lng);
    const markerId = location.lat + ',' + location.lng;

    // Define popupContent
    var popupContent = `
        <div class="popup-content">
            <img src="${location.image}" alt="${location.name}">
            <h4><a href="${location.link}" target="_blank">${location.name}</a></h4>
            <a href="https://www.google.com/maps/dir/?api=1&destination=${location.lat},${location.lng}" target="_blank" rel="noopener noreferrer">
                <img src="/images/route_icon.png" alt="Google Maps" style="width: 40px; height: 40px; margin-bottom: -10px;">
                <div style="margin-top: -10px; margin-bottom: -10px; color: black; font-size: 16px"><p class="dir">Directions</p></div>
            </a>
        </div>
    `;

    var iconClass = "blue-marker";
    switch (location.tour) {
        case "history":
            iconClass = "blue-marker";
            break;
        case "hamm":
            iconClass = "orange-marker";
            break;
        case "gangster":
            iconClass = "green-marker";
            break;
        case "split":
            iconClass = "split-marker";
            break;
        case "lake":
            iconClass = "purple-marker";
            break;
        case "capitol":
            iconClass = "burgundy-marker";
            break;
        case "summit":
            iconClass = "charcoal-marker";
            break;
        case "northeast":
            iconClass = "teal-marker";
            break;
        default:
            iconClass = "blue-marker";
            break;
    }
    
        // Create a custom marker icon
    const markerIcon = L.divIcon({
        className: `custom-marker-icon ${iconClass}`,
        iconSize: [12, 12],
        iconAnchor: [6, 6],
        popupAnchor: [0, -16],
    });

    var marker = L.marker(locationLatLng, { icon: markerIcon }).bindPopup(popupContent);

    if (!currentMarkers[markerId]) {
        newMarkers[markerId] = marker;
        markers.addLayer(marker);
    } else {
        newMarkers[markerId] = currentMarkers[markerId];
    }
}

// Finally, add the markers cluster group to the map
map.addLayer(markers);


// Assign the newMarkers to currentMarkers
currentMarkers = newMarkers;

let consolidatedInterval = setInterval(function() {
    
    var currentTime = Date.now();
    
    if (!lastTransitionTime || currentTime - lastTransitionTime > COOLDOWN) {
        console.log("Cooldown has passed in interval. Resetting last visited location.");
        sessionStorage.setItem('lastVisitedLocation', '-1');
    }

    updateUserLocation();

}, 8000);  // Check every 8 seconds.

    function onLocationError(e) {
        clearTimeout(locationTimeout);
        locationPopup.innerHTML = "Failed to access your location. Please make sure location services are enabled and try again.";
    }

    map.on("locationerror", onLocationError);

    let recenterTimeout; // Declare a variable to hold the timeout reference

    function recenterMap() {
        if (!userInteracted && userLocationMarker.getLatLng()) {
            map.setView(userLocationMarker.getLatLng(), 20); // Set zoom to 20 when recentering
        }
    }

    map.on("popupclose", function(event) {
        clearTimeout(recenterTimeout);
        recenterTimeout = setTimeout(() => {
            userInteracted = false;
            recenterMap();  // Call the recenterMap function after the delay
        }, 25000);  // 25 seconds delay
    });

    map.on("popupopen", function(event) {
        clearTimeout(recenterTimeout);
    });

    map.locate({
        watch: true,
        enableHighAccuracy: true,
        maximumAge: 25000,
    });
    
const questionBtn = document.getElementById('help-button');
const popup = document.getElementById('explanation-popup');

questionBtn.addEventListener('click', () => {
  popup.classList.toggle('hidden'); 
});

const closeBtn = document.getElementById('close-popup');

closeBtn.addEventListener('touchstart', closePopup); 
closeBtn.addEventListener('click', closePopup);

function closePopup(event) {
    event.stopPropagation(); // This stops the event from propagating up the DOM tree
    popup.classList.add('hidden'); 
}

    const recenterButton = document.getElementById("recenter-button");
    recenterButton.addEventListener("click", function () {
        if (userLocationMarker.getLatLng()) {
            const userLatLng = userLocationMarker.getLatLng();
            map.setView(userLatLng, 20);
            userInteracted = false; // Reset the flag when recenter button is tapped
            clearTimeout(recenterTimeout); // Clear the recenter delay
        } else {
            alert("User location not available. Please enable location services.");
        }
    });

    var exitButton = document.querySelector(".exit-button");
    exitButton.addEventListener("click", function () {
        sessionStorage.removeItem('lastTransitionTime');
        window.location.href = "index.html";
    });
});
</script>

</body>
</html>
